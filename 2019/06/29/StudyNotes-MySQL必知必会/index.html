<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/icons8-fox-32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/icons8-fox-16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,SQL,StudyNotes,">





  <link rel="alternate" href="/atom.xml" title="I'm Qiancun Huang" type="application/atom+xml">






<meta name="description" content="本系列为StudyNotes整理，所有笔记汇总如下：  StudyNotes-MySQL必知必会…..  本文为MySQL必知必会StudyNotes。  相关题解：数据库SQL实战题解  第1章 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库 以某种有组织的方式存储的数据集合 保存有组织的数据的容器（通常是一个文件或一组文件）   数据库软件 DBMS-数据库管理系统 使用DBMS">
<meta name="keywords" content="数据库,SQL,StudyNotes">
<meta property="og:type" content="article">
<meta property="og:title" content="StudyNotes-MySQL必知必会">
<meta property="og:url" content="http://huangqiancun.github.io/2019/06/29/StudyNotes-MySQL必知必会/index.html">
<meta property="og:site_name" content="I&#39;m Qiancun Huang">
<meta property="og:description" content="本系列为StudyNotes整理，所有笔记汇总如下：  StudyNotes-MySQL必知必会…..  本文为MySQL必知必会StudyNotes。  相关题解：数据库SQL实战题解  第1章 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库 以某种有组织的方式存储的数据集合 保存有组织的数据的容器（通常是一个文件或一组文件）   数据库软件 DBMS-数据库管理系统 使用DBMS">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-07-27T17:20:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="StudyNotes-MySQL必知必会">
<meta name="twitter:description" content="本系列为StudyNotes整理，所有笔记汇总如下：  StudyNotes-MySQL必知必会…..  本文为MySQL必知必会StudyNotes。  相关题解：数据库SQL实战题解  第1章 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库 以某种有组织的方式存储的数据集合 保存有组织的数据的容器（通常是一个文件或一组文件）   数据库软件 DBMS-数据库管理系统 使用DBMS">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":8,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://huangqiancun.github.io/2019/06/29/StudyNotes-MySQL必知必会/">





  <title>StudyNotes-MySQL必知必会 | I'm Qiancun Huang</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">I'm Qiancun Huang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Live it. Love it. Enjoy IT.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://huangqiancun.github.io/2019/06/29/StudyNotes-MySQL必知必会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Qiancun Huang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/photo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I'm Qiancun Huang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">StudyNotes-MySQL必知必会</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-29T00:54:14+08:00">
                2019-06-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2019-07-28T01:20:23+08:00">
                2019-07-28
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/StudyNotes/" itemprop="url" rel="index">
                    <span itemprop="name">StudyNotes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  23.4k
                </span>
              

              

              
            </div>
          

          
		  

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本系列为StudyNotes整理，所有笔记汇总如下：</p>
<ul>
<li><a href="https://huangqiancun.github.io/2019/06/14/StudyNotes-MySQL必知必会/">StudyNotes-MySQL必知必会</a><br>…..</li>
</ul>
<p>本文为<code>MySQL必知必会</code>StudyNotes。</p>
<ul>
<li>相关题解：<a href="https://huangqiancun.github.io/2019/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E5%AE%9E%E6%88%98%E9%A2%98%E8%A7%A3/">数据库SQL实战题解</a></li>
</ul>
<h1 id="第1章-了解SQL"><a href="#第1章-了解SQL" class="headerlink" title="第1章 了解SQL"></a>第1章 了解SQL</h1><h2 id="1-1-数据库基础"><a href="#1-1-数据库基础" class="headerlink" title="1.1 数据库基础"></a>1.1 数据库基础</h2><h3 id="1-1-1-什么是数据库"><a href="#1-1-1-什么是数据库" class="headerlink" title="1.1.1 什么是数据库"></a>1.1.1 什么是数据库</h3><ul>
<li>数据库<ul>
<li>以某种有组织的方式存储的数据集合</li>
<li>保存有组织的数据的容器（通常是一个文件或一组文件）</li>
</ul>
</li>
<li>数据库软件<ul>
<li>DBMS-数据库管理系统</li>
<li>使用DBMS访问数据库</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-表"><a href="#1-1-2-表" class="headerlink" title="1.1.2 表"></a>1.1.2 表</h3><ul>
<li>表<ul>
<li>是一种结构化的文件，用来存储某种特定类型的数据</li>
<li>某种特定类型数据的结构化清单</li>
<li>存储在表中的数据是一种类型或一个清单，不应该在同一个表中有两种类型或两个清单</li>
<li>表名用来标识自己，名字是唯一的</li>
<li>相同数据库中不能使用相同的表名，但在不同的数据库中可以使用相同的表名</li>
</ul>
</li>
<li>模式<ul>
<li>定义了数据在表中如何存储</li>
<li>用来描述数据库中特定的表以及整个数据库和其中表的关系</li>
<li>关于数据库和表的布局及特性的信息</li>
</ul>
</li>
</ul>
<h3 id="1-1-3-列和数据类型"><a href="#1-1-3-列和数据类型" class="headerlink" title="1.1.3 列和数据类型"></a>1.1.3 列和数据类型</h3><ul>
<li>列<ul>
<li>表由列组成，列中存储着表中某部分的信息</li>
<li>表中的一个字段，所有表都是有一个或者多个列组成的</li>
<li>正确地将数据分解分为多个列很重要</li>
</ul>
</li>
<li>数据类型<ul>
<li>所容许的数据的类型，每个表列都有响应的数据类型，限制（或容许）该列中存储的数据</li>
</ul>
</li>
</ul>
<h3 id="1-1-4-行"><a href="#1-1-4-行" class="headerlink" title="1.1.4 行"></a>1.1.4 行</h3><ul>
<li>行<ul>
<li>表中的一个记录</li>
<li>行 = 数据库记录</li>
</ul>
</li>
</ul>
<h3 id="1-1-5-主键"><a href="#1-1-5-主键" class="headerlink" title="1.1.5  主键"></a>1.1.5  主键</h3><ul>
<li>主键<ul>
<li>一列（或一组列），其值能够唯一区分表中的每个行</li>
<li>应该总是定义主键，便于数据操纵和管理</li>
<li>任意两行都不具有相同的主键值</li>
<li>表中任何列都可以作为主键，主要它满足一下条件<ul>
<li>每个行都必须具有一个主键值（主键列不允许NULL值）</li>
<li>通常定义在表的一列上，但也可以使用多个列作为主键</li>
</ul>
</li>
<li>好习惯<ul>
<li>不更新主键列中的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-什么是SQL"><a href="#1-2-什么是SQL" class="headerlink" title="1.2 什么是SQL"></a>1.2 什么是SQL</h2><ul>
<li>SQL<ul>
<li>结构化查询语言（Structured Query Language）</li>
<li>专门用来与数据库通信的语言</li>
<li>优点<ul>
<li>不是某个特定数据库供应商专有的语言，通用性</li>
<li>简单易学</li>
<li>强有力，灵活，可以进行非常复杂和高级的数据库操作</li>
</ul>
</li>
<li>任意两个DBMS实现的SQL都不完全相同，不是完全可移植的，本书针对MySQL</li>
</ul>
</li>
</ul>
<h2 id="1-3-动手实践"><a href="#1-3-动手实践" class="headerlink" title="1.3 动手实践"></a>1.3 动手实践</h2><ul>
<li>附录B</li>
</ul>
<h3 id="B-1-样例表-随身物品推销商使用的订单录入系统"><a href="#B-1-样例表-随身物品推销商使用的订单录入系统" class="headerlink" title="B.1 样例表 - 随身物品推销商使用的订单录入系统"></a>B.1 样例表 - 随身物品推销商使用的订单录入系统</h3><ul>
<li>管理供应商</li>
<li>管理产品目录</li>
<li>管理顾客列表</li>
<li>录入顾客订单</li>
</ul>
<h3 id="表的描述"><a href="#表的描述" class="headerlink" title="表的描述"></a>表的描述</h3><ul>
<li><p>6个表，表的列出顺序是因为它们之间的依赖关系</p>
</li>
<li><p>vendors表</p>
<ul>
<li>存储销售产品的供应商，每个供应商为一个记录。供应商列用来匹配产品和供应商</li>
<li>所有表都应该有主键，这个表使用vend_id作为主键，vend_id为一个自动增量字段</li>
</ul>
</li>
</ul>
<center><strong>表B-1 vendors表的列</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">vend_id</td>
<td style="text-align:center">唯一的供应商ID</td>
</tr>
<tr>
<td style="text-align:center">vend_name</td>
<td style="text-align:center">供应商名</td>
</tr>
<tr>
<td style="text-align:center">vend_address</td>
<td style="text-align:center">供应商的地址</td>
</tr>
<tr>
<td style="text-align:center">vend_city</td>
<td style="text-align:center">供应商的城市</td>
</tr>
<tr>
<td style="text-align:center">vend_state</td>
<td style="text-align:center">供应商的州</td>
</tr>
<tr>
<td style="text-align:center">vend_zip</td>
<td style="text-align:center">供应商的邮政编码</td>
</tr>
<tr>
<td style="text-align:center">vend_country</td>
<td style="text-align:center">供应商的国家</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>products表<ul>
<li>products表包含产品目录，每行一个产品，每个产品有唯一的ID（prod_id列），通过vend_id（供应商的唯一ID）关联到它的供应商</li>
<li>所有表都应该有主键，这个表使用prod_id列作为主键</li>
<li>为实施引用完整性，应该在vend_id上定义一个外键，关联到vendors的vend_id</li>
</ul>
</li>
</ul>
<center><strong>表B-2 products表的列</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">prod_id</td>
<td style="text-align:center">唯一的产品ID</td>
</tr>
<tr>
<td style="text-align:center">vend_id</td>
<td style="text-align:center">产品供应商ID（关联到vendors表中的vend_id）</td>
</tr>
<tr>
<td style="text-align:center">prod_name</td>
<td style="text-align:center">产品名</td>
</tr>
<tr>
<td style="text-align:center">prod_price</td>
<td style="text-align:center">产品价格</td>
</tr>
<tr>
<td style="text-align:center">prod_desc</td>
<td style="text-align:center">产品描述</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>customers表<ul>
<li>customers表存储所有顾客的信息，每个顾客有唯一的ID（cust_id列）</li>
<li>所有表都应该有主键，这个表使用cust_id列作为主键，cust_id是一个自动增量的字段</li>
</ul>
</li>
</ul>
<center><strong> 表B-3 customers表的列</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cust_id</td>
<td style="text-align:center">唯一的顾客ID</td>
</tr>
<tr>
<td style="text-align:center">cust_name</td>
<td style="text-align:center">顾客名</td>
</tr>
<tr>
<td style="text-align:center">cust_address</td>
<td style="text-align:center">顾客的地址</td>
</tr>
<tr>
<td style="text-align:center">cust_city</td>
<td style="text-align:center">顾客的城市</td>
</tr>
<tr>
<td style="text-align:center">cust_state</td>
<td style="text-align:center">顾客的州</td>
</tr>
<tr>
<td style="text-align:center">cust_zip</td>
<td style="text-align:center">顾客的邮政编码</td>
</tr>
<tr>
<td style="text-align:center">cust_country</td>
<td style="text-align:center">顾客的国家</td>
</tr>
<tr>
<td style="text-align:center">cust_contact</td>
<td style="text-align:center">顾客的联系名</td>
</tr>
<tr>
<td style="text-align:center">cust_email</td>
<td style="text-align:center">顾客的联系email地址</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>orders表<ul>
<li>orders表存储顾客订单（但不是订单细节），每个订单唯一的编号（order_num列），订单用cust_id列（它关联到customer表的顾客唯一ID）与响应的顾客关联</li>
<li>所有表都应该有主键，这个表使用order_num列作为主键，order_num是一个自动增量的字段 </li>
<li>为实施引用完整性，应该在cust_id上定义一个外键，关联到customers的cust_id</li>
</ul>
</li>
</ul>
<center><strong> 表B-4 orders表的列 </strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">order_num</td>
<td style="text-align:center">唯一订单号</td>
</tr>
<tr>
<td style="text-align:center">order_data</td>
<td style="text-align:center">订单日期</td>
</tr>
<tr>
<td style="text-align:center">cust_id</td>
<td style="text-align:center">订单顾客ID（关联到customers表的cust_id）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>orderitems表<ul>
<li>orderitems表存储每个订单中的实际物品，每个订单的每个物品占一行，对orders表中的一行，orderitems中有一行或多行，每个订单物品有订单号加订单物品（第一个物品、第二个物品等）唯一标识。订单物品通过order_num列（关联到orders中订单的唯一ID）与它们响应的订单相关联，每个订单项包含订单物品的产品ID（它关联物品到products表）</li>
<li>所有表都应该有主键，这个表使用order_num和order_item作为其主键</li>
<li>为实施引用完整性，应该在order_num上定义一个外键，关联到orders的order_num，在prod_id定义外键，关联到products的prod_id</li>
</ul>
</li>
</ul>
<center><strong>表B-5 orderitems表的列</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">order_num</td>
<td style="text-align:center">订单号（关联到orders表的order_num）</td>
</tr>
<tr>
<td style="text-align:center">order_item</td>
<td style="text-align:center">订单物品号（在某个订单中的顺序）</td>
</tr>
<tr>
<td style="text-align:center">prod_id</td>
<td style="text-align:center">产品ID（关联到products表的prod_id）</td>
</tr>
<tr>
<td style="text-align:center">quantity</td>
<td style="text-align:center">物品数量</td>
</tr>
<tr>
<td style="text-align:center">item_price</td>
<td style="text-align:center">物品价格</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>productnotes表<ul>
<li>productnotes表存储于特定产品有关的注释信息，并非所有产品都有相关的注释，而有的产品可能有许多相关的注释</li>
<li>所有表都应该有主键，这个表使用note_id作为其主键</li>
<li>列note_text必须为FULLTEXT搜索进行索引</li>
<li>由于这个表使用全文本搜索，因此必须指定ENGINE=MyISAM</li>
</ul>
</li>
</ul>
<center><strong>表B-6 productnotes表的列</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">列</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">note_id</td>
<td style="text-align:center">唯一注释ID</td>
</tr>
<tr>
<td style="text-align:center">prod_id</td>
<td style="text-align:center">产品ID（对应于products表中的prod_id）</td>
</tr>
<tr>
<td style="text-align:center">note_date</td>
<td style="text-align:center">增加注释的日期</td>
</tr>
<tr>
<td style="text-align:center">note_text</td>
<td style="text-align:center">注释文本</td>
</tr>
</tbody>
</table>
</div>
<h3 id="B-2-创建样例表"><a href="#B-2-创建样例表" class="headerlink" title="B.2 创建样例表"></a>B.2 创建样例表</h3><p>下载数据：<a href="https://www/forta.com/books/0672327120/" target="_blank" rel="noopener">https://www/forta.com/books/0672327120/</a></p>
<ul>
<li>创建一个新数据源</li>
<li>保证选择新数据源</li>
<li>执行create.sql脚本</li>
<li>重复前面的步骤，用populate.sql文件填充各个新表</li>
</ul>
<h1 id="第2章-MySQL简介"><a href="#第2章-MySQL简介" class="headerlink" title="第2章 MySQL简介"></a>第2章 MySQL简介</h1><h2 id="2-1-什么是MySQL"><a href="#2-1-什么是MySQL" class="headerlink" title="2.1 什么是MySQL"></a>2.1 什么是MySQL</h2><ul>
<li>MySQL<ul>
<li>是一种DBMS，数据库软件</li>
<li>广泛使用，原因：<ul>
<li>成本 - MySQL是开源的，可以免费使用（甚至可以免费修改）</li>
<li>性能 - MySQL执行很快</li>
<li>可信赖 - 很多公司，站点都用MySQL来处理自己的重要数据</li>
<li>简单 - MySQL很容易安装和使用    </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-客户机-服务器软件"><a href="#2-1-1-客户机-服务器软件" class="headerlink" title="2.1.1 客户机-服务器软件"></a>2.1.1 客户机-服务器软件</h3><ul>
<li>DBMS<ul>
<li>分两类，一类为基于共享文件系统的DBMS，另一类为基于客户机-服务器的DBMS</li>
<li>MySQL是基于客户机-服务器的数据库 </li>
<li>服务器部分是负责所有数据访问和处理的一个软件，运行在数据库服务器上，与数据文件打交道的只有服务器软件，数据添加、删除和更新都由服务器软件完成</li>
<li>客户机是与用户打交道的软件</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-MySQL版本"><a href="#2-1-2-MySQL版本" class="headerlink" title="2.1.2 MySQL版本"></a>2.1.2 MySQL版本</h3><ul>
<li>DBMS版本<ul>
<li>当前版本为5</li>
<li>版本4：InnoDB引擎，增加事物处理（第26章），并（第17章），改进全文本搜索（第18章）的支持</li>
<li>版本4.1：对函数库、子查询（第14章）、集成帮助等的重要增加</li>
<li>版本5：存储过程（第23章）、触发器（第25章）、游标（第24章）、视图（第22章）等</li>
</ul>
</li>
</ul>
<h2 id="2-2-MySQL工具"><a href="#2-2-MySQL工具" class="headerlink" title="2.2 MySQL工具"></a>2.2 MySQL工具</h2><h3 id="2-2-1-mysql命令行使用程序"><a href="#2-2-1-mysql命令行使用程序" class="headerlink" title="2.2.1 mysql命令行使用程序"></a>2.2.1 mysql命令行使用程序</h3><ul>
<li>指定登录名：mysql -u ben</li>
<li>指定用户名、主机名、端口和口令：mysql -u ben -p -h myserver -P 9999</li>
<li>完整的参数列表：mysql —help</li>
<li>命令输入在mysql&gt;之后</li>
<li>命令用 ; 或 \g 结束，仅按enter不执行命令</li>
<li>输入help或 -h 获得帮助</li>
<li>获得特定命令的帮助 如help select</li>
<li>输入quit或exit退出命令行实用程序</li>
</ul>
<h3 id="2-2-2-MySQL-Administrator"><a href="#2-2-2-MySQL-Administrator" class="headerlink" title="2.2.2 MySQL Administrator"></a>2.2.2 MySQL Administrator</h3><ul>
<li>MySQL Administrator（MySQL管理器）是一个图形交互客户机，简化MySQL服务器的管理</li>
<li>key points：<ul>
<li>Server Information（服务器信息）显示客户机和被连接的服务器的状态和版本信息</li>
<li>Server Control（服务控制）允许停止和启动MySQL以及指定服务器特性</li>
<li>User Administration（用户管理）用来定义MySQL用户、登录和权限</li>
<li>Catalogs（目录）列出可用的数据库并允许创建数据库和表</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-MySQL-Query-Browser"><a href="#2-2-3-MySQL-Query-Browser" class="headerlink" title="2.2.3 MySQL Query Browser"></a>2.2.3 MySQL Query Browser</h3><ul>
<li>MySQL Query Browser是一个图形交互客户机，编写和执行MySQL命令</li>
</ul>
<h1 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h1><h2 id="3-1-连接"><a href="#3-1-连接" class="headerlink" title="3.1 连接"></a>3.1 连接</h2><ul>
<li>MySQL有自己的用户列表，用户间的权限可能不同</li>
<li>MySQL Administrator 的Users视图可直接定义新用户，包括赋予口令和访问权限</li>
<li>主机名+端口+用户名+口令</li>
</ul>
<h2 id="3-2-选择数据库"><a href="#3-2-选择数据库" class="headerlink" title="3.2 选择数据库"></a>3.2 选择数据库</h2><ul>
<li>使用USE关键字 （关键字：作为MySQL的保留字，不要用关键字命名一个表和列。）</li>
<li>USE crashcourse （选择crashcourse数据库，不返回任何结果）</li>
</ul>
<h2 id="3-3-了解数据库和表"><a href="#3-3-了解数据库和表" class="headerlink" title="3.3 了解数据库和表"></a>3.3 了解数据库和表</h2><ul>
<li>SHOW DATABASES（返回可用数据库的一个列表）</li>
<li>SHOW TABLES（返回当前选择的数据库内可用表的列表）</li>
<li>SHOW COLUMNS FROM customers； （显示表列）<ul>
<li>对每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment）</li>
</ul>
</li>
<li>自动增量：某些表列需要唯一值，在每个行添加到表中时，MySQL自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值。在CREATE语句创建表时定义（第21章）</li>
<li>DESCRIBE是SHOW COLUMNS FROM的快捷方式，DESCRIBE customers 与 SHOW COLUMNS FROM customers 等价</li>
<li>SHOW STATUS （显示服务器状态信息）</li>
<li>SHOW CREATE DATABASE和SHOW CREATE TABLE （分别用来显示创建特定数据库或表的MySQL语句）</li>
<li>SHOW GRANTS （显示授予用户（所有用户或特定用户）的安全权限）</li>
<li>SHOW ERRORS和SHOW WARNINGS （显示服务器错误或警告消息）</li>
<li>HELP SHOW （显示所有允许的SHOW语句）</li>
<li>MySQL新增内容：INFORMATION_SCHEMA，获得和过滤模式信息</li>
</ul>
<h1 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h1><h2 id="4-1-SELECT语句"><a href="#4-1-SELECT语句" class="headerlink" title="4.1 SELECT语句"></a>4.1 SELECT语句</h2><ul>
<li>从一个表或多个表中检索信息</li>
<li>使用SELECT时，至少给出两条信息：想选择什么，以及从什么地方选择</li>
</ul>
<h2 id="4-2-检索单个列"><a href="#4-2-检索单个列" class="headerlink" title="4.2 检索单个列"></a>4.2 检索单个列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 从products表中检索一个名为prod_name的列，返回的数据是无序的</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>多条语句用分号分隔，在每一条语句后加分号没有坏处</li>
<li>SQL语句不区分大小写，SELECT=Select，一般对关键字使用大写，对列和表明使用小写，易于阅读和调试</li>
<li>在处理SQL语句时，所有空格被忽略，SQL语句可以在一行给出，也可以分成许多行，多行更容易阅读和调试</li>
</ul>
<h2 id="4-3-检索多个列"><a href="#4-3-检索多个列" class="headerlink" title="4.3 检索多个列"></a>4.3 检索多个列</h2><ul>
<li>使用相同的SELECT语句，在SELECT后给出多个列名，列名之间必须以逗号分隔，但最后一个列名后不加逗号，否则报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL语句一般返回原始的、无格式的数据</li>
<li>数据的格式化是一个表示问题，而不是检索问题，表示（对齐和数值）一般在显示该数据的应用程序中规定，一般很少使用实际检索出的原始数据</li>
</ul>
<h2 id="4-4-检索所有列"><a href="#4-4-检索所有列" class="headerlink" title="4.4 检索所有列"></a>4.4 检索所有列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用通配符 * </span><br><span class="line">SELECT *</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果给定一个通配符 * ，则返回表中所有列，列的顺序一般是列在表定义中出现的顺序，但表的模式的变化（如添加和删除列）可能会导致顺序的变化</li>
<li>使用通配符省事，但会降低检索和应用程序的性能</li>
<li>使用通配符优点，可以检索出名字未知的列</li>
</ul>
<h2 id="4-5-检索不同的行"><a href="#4-5-检索不同的行" class="headerlink" title="4.5 检索不同的行"></a>4.5 检索不同的行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 只返回不同的vend_id行</span><br><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用DISTINCT关键字只返回不同的值，放在列名的前面</li>
<li>不能部分使用DISTINCT，DISTINCT应用于所有列而不仅是前置它的列</li>
</ul>
<h2 id="4-6-限制结果"><a href="#4-6-限制结果" class="headerlink" title="4.6 限制结果"></a>4.6 限制结果</h2><ul>
<li>使用LIMIT语句返回前几行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回不多于5行</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定要检索的开始行和行数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回从行5开始的5行</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">LIMIT 5, 5;</span><br></pre></td></tr></table></figure>
<ul>
<li>LIMIT 5, 5返回从行5开始的5行，第一个数为开始位置，第二个数为要检索的行数</li>
<li>带一个值的LIMIT总是从第一行开始，给出的数为返回的行数</li>
<li>第一行是行0，LIMIT 1, 1将检索出第二行而不是第一行</li>
<li>LIMIT中指定要检索的行数为检索的最大行数</li>
<li>MySQL5支持LIMIT 4 OFFSET 3 与 LIMIT 3, 4等价，从行3开始取4行</li>
</ul>
<h2 id="4-7-使用完全限定的表名"><a href="#4-7-使用完全限定的表名" class="headerlink" title="4.7 使用完全限定的表名"></a>4.7 使用完全限定的表名</h2><ul>
<li>完全限定的名字：同时使用表名和列字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT products.prod_name # 完全限定的列名</span><br><span class="line">FROM products；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT products.prod_name # 完全限定的列名</span><br><span class="line">FROM crashcourse.products； # 完全限定的表名</span><br></pre></td></tr></table></figure>
<h1 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h1><ul>
<li>SELECT语句的ORDER BY 子句</li>
</ul>
<h2 id="5-1-排序数据"><a href="#5-1-排序数据" class="headerlink" title="5.1 排序数据"></a>5.1 排序数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上输出数据没有特定的顺序，如果不排序，一般会以它在底层表中出现的顺序显示，这可以是数据最初添加到表中的顺序，但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。</p>
</li>
<li><p>子句，SQL语句由子句构成，有些子句是必需的，而有的是可选的，一个子句通常由一个关键字和所提供的的数据组成，如SELECT语句的FROM子句。</p>
</li>
<li><p>ORDER BY子句取一个或多个列的名字，据此对输出进行排序。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>通常ORDER BY子句中使用的列为显示所选择的列，但用非检索列的列排序数据也是完全合法的。</li>
</ul>
<h2 id="5-2-按多个列排序"><a href="#5-2-按多个列排序" class="headerlink" title="5.2 按多个列排序"></a>5.2 按多个列排序</h2><ul>
<li>按多个列排序，只要指定列名，列名之间用逗号分开即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 首先按价格，再按名称排序</span><br><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-指定排序方向"><a href="#5-3-指定排序方向" class="headerlink" title="5.3 指定排序方向"></a>5.3 指定排序方向</h2><ul>
<li>默认是生序排序，无须指定关键字，也可以指定升序关键字ASC</li>
<li>降序排序需要指定DESC关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 降序排序</span><br><span class="line">SELECT prod_id, Prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># prod_price降序排序, prod_name 升序排序</span><br><span class="line">SELECT prod_id, Prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC, prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>在多个列上降序排序，必须对每个列指定DESC关键字。</li>
<li><p>大小写问题，MySQL认为A和a相同。</p>
</li>
<li><p>ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 找出价格最高物品的值</span><br><span class="line">SELECT prod_price</span><br><span class="line">FROM products</span><br><span class="line">ORDER BY prod_price DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>ORDER BY在FROM子句之后，LIMIT位于ORDER BY之后，次序不对将报错。</li>
</ul>
<h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><ul>
<li>使用SELECT的WHERE子句指定搜索条件。</li>
</ul>
<h2 id="6-1-使用WHERE子句"><a href="#6-1-使用WHERE子句" class="headerlink" title="6.1 使用WHERE子句"></a>6.1 使用WHERE子句</h2><ul>
<li>只检索所需数据需要指定搜索条件，搜索条件也称为过滤条件。</li>
<li>在SELECT中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 从products中检索两个列，只返回prod_price值为2.50的行</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price = 2.50;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-WHERE子句操作符"><a href="#6-2-WHERE子句操作符" class="headerlink" title="6.2 WHERE子句操作符"></a>6.2 WHERE子句操作符</h2><ul>
<li>WHERE支持的条件操作符。</li>
</ul>
<center><strong>WHERE子句操作符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;&gt;</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN</td>
<td style="text-align:center">在指定的两个值之间</td>
</tr>
</tbody>
</table>
</div>
<h3 id="6-2-1-检查单个值"><a href="#6-2-1-检查单个值" class="headerlink" title="6.2.1 检查单个值"></a>6.2.1 检查单个值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回prod_name的值为Fuses的行，不区分大小写，Fuces和fuces匹配</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name = &apos;fuses&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 列出价格小于10美元的所有产品</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt; 10;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-不匹配检查"><a href="#6-2-2-不匹配检查" class="headerlink" title="6.2.2 不匹配检查"></a>6.2.2 不匹配检查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 列出不是由供应商制造的所有产品</span><br><span class="line">SELECT vend_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id &lt;&gt; 1003;</span><br></pre></td></tr></table></figure>
<ul>
<li>何时使用引号：单引号用来限定字符串，如果将值与串类型的列进行比较，则需要限定引号，用来与数值列进行比较的值不用引号。</li>
<li>&lt;&gt; 和 != 等价。</li>
</ul>
<h3 id="6-2-3-范围值检查"><a href="#6-2-3-范围值检查" class="headerlink" title="6.2.3 范围值检查"></a>6.2.3 范围值检查</h3><ul>
<li>使用BETWEEN操作符，需要两个值，即范围的开始值和结束值，匹配范围内所有的值，包括开始值和结束值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索价格在5美元到10美元的所有产品</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price BETWEEN 5 AND 10;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-4-空值检查"><a href="#6-2-4-空值检查" class="headerlink" title="6.2.4 空值检查"></a>6.2.4 空值检查</h3><ul>
<li>在创建表时，可以指定其中的列可以不包含空值，空值为NULL。</li>
<li>空值NULL与字段包含0，空字符串或仅仅包含空格不同。</li>
<li>IS NULL子句用来检索NULL的列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回没有价格（空prod_price字段，不是价格为0）的所有产品的行</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price IS NULL;</span><br></pre></td></tr></table></figure>
<ul>
<li>NULL与不匹配：匹配过滤和不匹配过滤时不返回具有NULL值的行。</li>
</ul>
<h1 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h1><ul>
<li>组合WHERE子句，NOT和IN操作符。</li>
</ul>
<h2 id="7-1-组合WHERE子句"><a href="#7-1-组合WHERE子句" class="headerlink" title="7.1 组合WHERE子句"></a>7.1 组合WHERE子句</h2><ul>
<li>以ANF子句或OR子句的方式使用多个WHERE子句。</li>
<li>操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符。</li>
</ul>
<h3 id="7-1-1-AND操作符"><a href="#7-1-1-AND操作符" class="headerlink" title="7.1.1 AND操作符"></a>7.1.1 AND操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格</span><br><span class="line">SELECT prod_id, prod_price, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br></pre></td></tr></table></figure>
<ul>
<li>AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。</li>
</ul>
<h3 id="7-1-2-OR操作符"><a href="#7-1-2-OR操作符" class="headerlink" title="7.1.2 OR操作符"></a>7.1.2 OR操作符</h3><ul>
<li>OR操作符与AND不同，它指示检索匹配任一条件的行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索由供应商1002或1003制造的任何产品</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1002 OR vend_id = 1003;</span><br></pre></td></tr></table></figure>
<ul>
<li>OR 用在WHERE子句中的关键字，用来指示检索匹配任一给定条件的行。</li>
</ul>
<h3 id="7-1-3-计算次序"><a href="#7-1-3-计算次序" class="headerlink" title="7.1.3 计算次序"></a>7.1.3 计算次序</h3><ul>
<li>WHERE可包含任意数目的AND和OR操作符，允许两者结合以进行复杂和高级的过滤。</li>
<li>AND的计算优先级比OR高，使用圆括号明确地分组相应的操作符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索由供应商1002或1003制造的任何产品，并且价格大于等于10美元的行</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
<ul>
<li>在WHERE子句中，任何时候使用AND和OR操作时，都要使用圆括号明确地分组操作符，使用圆括号没有坏处，可以消除歧义。</li>
</ul>
<h2 id="7-2-IN操作符"><a href="#7-2-IN操作符" class="headerlink" title="7.2 IN操作符"></a>7.2 IN操作符</h2><ul>
<li>圆括号在WHERE子句中还有另外一种用法，IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，IN取合法值的由逗号分隔的清单，全都在圆括号中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 检索供应商1002和1003制造的所有产品</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br><span class="line">​`</span><br></pre></td></tr></table></figure>
<ul>
<li>IN操作符完成与OR相同的功能。</li>
</ul>
<p>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检索供应商1002和1003制造的所有产品</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1002 OR vend_id = 1003</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>IN操作符的优点：<ul>
<li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观</li>
<li>计算次数更容易管理</li>
<li>比OR操作符执行更快</li>
<li>最大的优点是可以包含其他SELECT语句，能够更加动态地建立WHERE子句</li>
</ul>
</li>
</ul>
<h2 id="7-3-NOT操作符"><a href="#7-3-NOT操作符" class="headerlink" title="7.3 NOT操作符"></a>7.3 NOT操作符</h2><ul>
<li>NOT操作符有且只有一个功能，否定它之后所跟的任何条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 匹配1002和1003之外的供应商</span><br><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id NOT IN (1002, 1003)</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>与IN操作符联合使用时，NOT使找出与条件列表不匹配的行。</li>
</ul>
<h1 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h1><h2 id="8-1-LIKE操作符"><a href="#8-1-LIKE操作符" class="headerlink" title="8.1 LIKE操作符"></a>8.1 LIKE操作符</h2><ul>
<li>通配符：用来匹配值的一部分的特殊字符。</li>
<li>搜索模式：由字面值、通配符或两者组合构成的搜索条件。</li>
<li>在搜索子句中使用通配符，必须使用LIKE操作符，LIKE指示后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。</li>
</ul>
<h3 id="8-1-1-百分号（-）通配符"><a href="#8-1-1-百分号（-）通配符" class="headerlink" title="8.1.1 百分号（%）通配符"></a>8.1.1 百分号（%）通配符</h3><ul>
<li>% 表示任何字符出现的任意次数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 检索任意jet起头的词，%告诉MySQL接受jet之后的任意字符，不管它有多少字符</span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &apos;jet%&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>区分大小写：搜索是可以区分大小写的。</li>
<li>通配符可以在搜索模式中任意位置使用，并且可以使用多个通配符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配任何位置包含文本anvil的值</span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &apos;%anvil%&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配以s起头以e结尾的所有产品</span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &apos;s%e&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>% 还可以匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。</li>
<li>注意尾空格，尾空格可能会干扰通配符匹配，例如anvil后有一个或多个空格时，则子句<code>WHERE prod_name LIKE &#39;%anvil&#39;</code>将不会匹配它们，因为在最后有空格，一个简单的方法是在搜索模式最后附加一个%，一个更好的方法是使用函数（第11章）去掉首尾空格。</li>
<li>注意NULL，%通配符不能匹配值为NULL的行。</li>
</ul>
<h3 id="8-1-2-下划线（-）通配符"><a href="#8-1-2-下划线（-）通配符" class="headerlink" title="8.1.2 下划线（_）通配符"></a>8.1.2 下划线（_）通配符</h3><ul>
<li>下划线只匹配单个字符而不是多个字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># （_）只匹配一个字符</span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &apos;_ ton anvil&apos;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-使用通配符的技巧"><a href="#8-2-使用通配符的技巧" class="headerlink" title="8.2 使用通配符的技巧"></a>8.2 使用通配符的技巧</h2><ul>
<li>通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。</li>
<li>技巧：<ul>
<li>不要过度使用通配符。</li>
<li>除非有必要，否则不要把它们用在搜索模式的开始处，因为置于开始处是最慢的。    </li>
<li>仔细注意通配符的位置。</li>
</ul>
</li>
</ul>
<h1 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h1><h2 id="9-1-正则表达式介绍"><a href="#9-1-正则表达式介绍" class="headerlink" title="9.1 正则表达式介绍"></a>9.1 正则表达式介绍</h2><ul>
<li>正则表达式：用来匹配文本的特殊的串（字符集合）。</li>
<li>更多参考<a href="https://book.douban.com/subject/2269648/" target="_blank" rel="noopener">《正则表达式必知必会》</a>。</li>
</ul>
<h2 id="9-2-使用MySQL正则表达式"><a href="#9-2-使用MySQL正则表达式" class="headerlink" title="9.2 使用MySQL正则表达式"></a>9.2 使用MySQL正则表达式</h2><ul>
<li>MySQL仅支持正则表达式实现的一个很小的子集。</li>
</ul>
<h3 id="9-2-1-基本字符匹配"><a href="#9-2-1-基本字符匹配" class="headerlink" title="9.2.1 基本字符匹配"></a>9.2.1 基本字符匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检索列prod_name包含1000的所有行</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;1000&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># .是表示匹配任意一个字符，因此可以匹配1000和2000</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;.000&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>LIKE和REGEXP比较。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不返回数据</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name LIKE &apos;1000&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 检索列prod_name包含1000的所有行</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;1000&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>LIKE匹配整个列，如果被匹配的文本在列值中出现，LIKE将不会找到它，除非使用通配符。</li>
<li>而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，响应的行将被返回。</li>
<li>匹配不区分大小写，为区分大小写，可使用BINARY关键字，如<code>WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;</code>。</li>
</ul>
<h3 id="9-2-2-进行OR匹配"><a href="#9-2-2-进行OR匹配" class="headerlink" title="9.2.2 进行OR匹配"></a>9.2.2 进行OR匹配</h3><ul>
<li>为检索两个串之一，使用|。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># | 表示OR操作，表示匹配其中之一，因此1000和2000都匹配</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;1000|2000&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以给出两个以上的OR条件，例如<code>&#39;1000|2000|3000&#39;</code>将匹配1000或2000或3000。</li>
</ul>
<h3 id="9-2-3-匹配几个字符之一"><a href="#9-2-3-匹配几个字符之一" class="headerlink" title="9.2.3 匹配几个字符之一"></a>9.2.3 匹配几个字符之一</h3><ul>
<li>使用一组用[]括起来的字符即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># [123]表示匹配1或2或3，因此，1 ton和2 ton都匹配</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;[123] Ton&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>[] 是另一种形式的OR语句，<code>[123] Ton</code>是<code>[1|2|3] Ton</code>的缩写。</li>
<li>需要用[]来定义OR语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 表示&apos;1&apos;或&apos;2&apos;或&apos;3 ton&apos;</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;1|2|3 Ton&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要把字符|括在一个集合里，否则它将应用于整个串。</li>
<li>字符集合也可以被否定，即它将匹配除指定字符外的任何东西，在集合的开始处放置一个^即可，例如<sup><a href="#fn_123" id="reffn_123">123</a></sup>匹配除1、2或3外的任何东西。</li>
</ul>
<h3 id="9-2-4-匹配范围"><a href="#9-2-4-匹配范围" class="headerlink" title="9.2.4 匹配范围"></a>9.2.4 匹配范围</h3><ul>
<li>集合可用来定义要匹配的一个或多个字符。例如<code>[0123456789]</code>将匹配数字0到9，可使用<code>-</code>来定义一个范围，简化为[0-9]。[a-z]匹配任意字母字符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># [1-5]表示匹配1到5, 5 ton是一个匹配</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;[1-5] ton&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-5-匹配特殊字符"><a href="#9-2-5-匹配特殊字符" class="headerlink" title="9.2.5 匹配特殊字符"></a>9.2.5 匹配特殊字符</h3><ul>
<li>加前导\\匹配特殊字符<code>.、[]、|、_</code>。<code>\\_</code>表示查找<code>_</code>，<code>\\.</code> 表示查找<code>.</code>。这种处理称为转义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用 \\. 匹配 . </span><br><span class="line">SELECT vend_name</span><br><span class="line">FROM vendors</span><br><span class="line">WHERE vend_name REGEXP &apos;\\.&apos;</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>\\</code>也用来引用元字符（具有特殊含义的字符）。</li>
</ul>
<center><strong>表9-1 空白元字符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\\f</code></td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td style="text-align:center"><code>\\n</code></td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center"><code>\\r</code></td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center"><code>\\t</code></td>
<td style="text-align:center">制表</td>
</tr>
<tr>
<td style="text-align:center"><code>\\v</code></td>
<td style="text-align:center">纵向制表</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>为了匹配反斜杠（\）字符本身，需要使用 <code>\\\</code></li>
<li>多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身，但MySQL要求两个反斜杠实现转义（MySQL解释一个，正则表达式库解释另一个）。</li>
</ul>
<h3 id="9-2-6-匹配字符类"><a href="#9-2-6-匹配字符类" class="headerlink" title="9.2.6 匹配字符类"></a>9.2.6 匹配字符类</h3><ul>
<li>存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。使用预定义的字符集，称为字符类。<center><strong>表9-2 字符类</strong></center>


</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[:alnum:]</code></td>
<td style="text-align:center">任意字母和数字（同<code>[a-aA-Z0-9]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:alpha:]</code></td>
<td style="text-align:center">任意字母（同<code>[a-zA-Z]</code>）]</td>
</tr>
<tr>
<td style="text-align:center"><code>[:blank:]</code></td>
<td style="text-align:center">空格和制表（同<code>[\\t]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:cntrl:]</code></td>
<td style="text-align:center">ASCII控制字符（ASCII 0到31和127）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:digit:]</code></td>
<td style="text-align:center">任意数字（同<code>[0-9]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:graph:]</code></td>
<td style="text-align:center">与<code>[:print:]</code>相同，但不包含空格</td>
</tr>
<tr>
<td style="text-align:center"><code>[:lower:]</code></td>
<td style="text-align:center">任意小写字母（同<code>[a-z]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:print:]</code></td>
<td style="text-align:center">任意可打印字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[:punct:]</code></td>
<td style="text-align:center">既不在<code>[:alnum:]</code>又不在<code>[:cntrl:]</code>中的任意字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[:space:]</code></td>
<td style="text-align:center">包括空格在内的任意空白字符（同<code>[\\f\\n\\r\\t\\v]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:upper:]</code></td>
<td style="text-align:center">任意大写字母（同<code>[A-Z]</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>[:xdigit:]</code></td>
<td style="text-align:center">任意十六进制数字（同<code>[a-fA-F0-9]</code>）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="9-2-7-匹配多个实例"><a href="#9-2-7-匹配多个实例" class="headerlink" title="9.2.7 匹配多个实例"></a>9.2.7 匹配多个实例</h3><center><strong>表9-3 重复元字符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">0个或多个匹配</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">1个或多个匹配（等于{1, }）</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td style="text-align:center">{n}</td>
<td style="text-align:center">指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center">{n, }</td>
<td style="text-align:center">不少于指定数目的匹配</td>
</tr>
<tr>
<td style="text-align:center">{n, m}</td>
<td style="text-align:center">匹配数目的范围{m不超过255}</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># \\(匹配)，[0-9]匹配任意数字，sticks？匹配stick和sticks(s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现)，没有？，匹配stick和sticks会非常困难</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;\\([0-9]) sticks?\\&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下匹配连在一起的4位数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># [:digit:] 匹配任意数字，&#123;4&#125;要求它前面的字符（任意数字）出现4次</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;[[:digit:]]&#123;4&#125;&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 与上例等价</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;[0-9][0-9][0-9][0-9]&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="9-2-8-定位符"><a href="#9-2-8-定位符" class="headerlink" title="9.2.8 定位符"></a>9.2.8 定位符</h3><ul>
<li>匹配特定位置的文本。</li>
</ul>
<center><strong>表9-4 定位元字符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">文本的开始</td>
</tr>
<tr>
<td style="text-align:center">$</td>
<td style="text-align:center">文本的结尾</td>
</tr>
<tr>
<td style="text-align:center">[[:&lt;:]]</td>
<td style="text-align:center">词的开始</td>
</tr>
<tr>
<td style="text-align:center">[[:&gt;:]]</td>
<td style="text-align:center">词的结尾</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用^定位符找出以一个数（包括小数点开始的数）开始的所有产品</span><br><span class="line">SELECT prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_name REGEXP &apos;^[0-9\\.]&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>^还可以在集合中[]用来否定该集合。</li>
<li>使REGEXP起类似LIKE的作用，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。</li>
<li>可以在不使用数据库表的情况下用SELECT来测试正则表达式，REGEXP总是返回0（不匹配）或者1（匹配）。如 <code>SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;</code>，返回0。</li>
</ul>
<h1 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h1><h2 id="10-1-计算字段"><a href="#10-1-计算字段" class="headerlink" title="10.1 计算字段"></a>10.1 计算字段</h2><ul>
<li>存储在数据库表中的数据一般不是应用程序所需要的格式，直接从数据库中检索出转换、计算或格式化过的数据，称为计算字段。</li>
<li><p>计算字段是运行SELECT语句是创建的。</p>
</li>
<li><p>字段，基本上与列的意思相同，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。</p>
</li>
<li>客户机与服务器的格式，可在客户机和服务器上完成转换和格式化工作，但在服务器上比客户机中要快得多。</li>
</ul>
<h2 id="10-2-拼接字段"><a href="#10-2-拼接字段" class="headerlink" title="10.2 拼接字段"></a>10.2 拼接字段</h2><ul>
<li>拼接，将值联结到一起构成单个值。</li>
<li>在SELECT语句中，用Concat()函数来拼接两个列。</li>
<li>MySQL的不同之处，多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回vend_name(vend_country)字段</span><br><span class="line">SELECT Concat(vend_name, &apos;(&apos;, vend_country, &apos;)&apos;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除数据右侧多于的空格整理数据，使用RTrim。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 拼接前使RTrim()函数删除vend_name和vend_country右侧的空格</span><br><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;)</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>LTrim()，去掉串左边的空格，Trim()，去掉左右两边的空格。</p>
</li>
<li><p>使用别名，SELECT语句拼接地址字段没有名字，需要使用别名（alias）表示一个字段或值，用AS关键字赋予。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用AS vend_title指定计算字段的列名</span><br><span class="line">SELECT Concat(vend_name, &apos;(&apos;, vend_country, &apos;)&apos;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>别名的其他用途，在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。</li>
<li>别名，有称为导出列（derived column）。</li>
</ul>
<h2 id="10-3-执行算术计算"><a href="#10-3-执行算术计算" class="headerlink" title="10.3 执行算术计算"></a>10.3 执行算术计算</h2><ul>
<li>对检索出的数据进行算术运算。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 汇总物品的价格（单价乘以订购数量），expanded_price为一个计算字段</span><br><span class="line">SELECT prod_id, </span><br><span class="line">	   quantity, </span><br><span class="line">	   item_price,</span><br><span class="line">	   quantity*item_price AS expanded_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 2005;</span><br></pre></td></tr></table></figure>
<ul>
<li>MySQL支持的基本算术运算符，圆括号可用来区分优先顺序。</li>
</ul>
<center><strong>表10-1 MySQL算术操作符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>测试计算，可以省略FROM子句以便简单地访问和处理表达式，例如 <code>SELECT 3*2</code> 将返回 6，<code>SELECT Trim(&#39; abc &#39;)</code>将返回abc，<code>SELECT Now()</code>返回当前日期和时间。</li>
</ul>
<h1 id="第11章-使用数据处理函数"><a href="#第11章-使用数据处理函数" class="headerlink" title="第11章 使用数据处理函数"></a>第11章 使用数据处理函数</h1><h2 id="11-1-函数"><a href="#11-1-函数" class="headerlink" title="11.1 函数"></a>11.1 函数</h2><ul>
<li>能运行在多个系统上的代码称为可移植的。</li>
<li>函数的可移植性不强。</li>
</ul>
<h2 id="11-2-使用函数"><a href="#11-2-使用函数" class="headerlink" title="11.2 使用函数"></a>11.2 使用函数</h2><ul>
<li>大多数SQL实现支持以下类型的函数。<ul>
<li>用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。</li>
<li>用于在数值数据上进行算术操作（如返回绝对值，进行代数计算）的数值函数。</li>
<li>用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等的日期和时间函数。</li>
<li>返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。</li>
</ul>
</li>
</ul>
<h3 id="11-2-1-文本处理函数"><a href="#11-2-1-文本处理函数" class="headerlink" title="11.2.1 文本处理函数"></a>11.2.1 文本处理函数</h3><ul>
<li>Upper()函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回vend_name和vend_name大写的一个计算字段</span><br><span class="line">SELECT vend_name, Upper(vend_name) AS vend_name_upcase</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>常用文本处理函数。</li>
</ul>
<center><strong>表11-1 常用的文本处理函数</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Left()</td>
<td style="text-align:center">返回串左边的字符</td>
</tr>
<tr>
<td style="text-align:center">Length()</td>
<td style="text-align:center">返回串的长度</td>
</tr>
<tr>
<td style="text-align:center">Locate()</td>
<td style="text-align:center">找出串的一个子串</td>
</tr>
<tr>
<td style="text-align:center">Lower()</td>
<td style="text-align:center">将串转换为小写</td>
</tr>
<tr>
<td style="text-align:center">LTrim()</td>
<td style="text-align:center">去掉串左边的空格</td>
</tr>
<tr>
<td style="text-align:center">Right()</td>
<td style="text-align:center">返回串右边的字符</td>
</tr>
<tr>
<td style="text-align:center">RTrim()</td>
<td style="text-align:center">去掉串右边的空格</td>
</tr>
<tr>
<td style="text-align:center">Soundex()</td>
<td style="text-align:center">返回串的SOUNDEX值</td>
</tr>
<tr>
<td style="text-align:center">SubString()</td>
<td style="text-align:center">返回子串的字符</td>
</tr>
<tr>
<td style="text-align:center">Upper()</td>
<td style="text-align:center">将串转换为大写</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>SOUNDEX，将任何文本串转换为描述其语音表示的字母数字模式的算法，其考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</p>
</li>
<li><p>例如customers表中有一个顾客Coyote Inc.，其联系名为Y. LEE。但如果这是输入错误，实际应为Y. Lie，按正确的联系名搜索将搜索不到。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回空，因为没有叫Y. Lie的</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_concact = &apos;Y.Lie&apos;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回Y.LEE，因为Y.LEE和Y.Lie发音相似</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE Soundex(cust_concact) = Soundex(&apos;Y.Lie&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="11-2-2-日期和时间处理函数"><a href="#11-2-2-日期和时间处理函数" class="headerlink" title="11.2.2 日期和时间处理函数"></a>11.2.2 日期和时间处理函数</h3><ul>
<li>常用的日期和时间处理函数</li>
</ul>
<center><strong>表11-2 常用日期和时间处理函数</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AddDate()</td>
<td style="text-align:center">增加一个日期（天、周等）</td>
</tr>
<tr>
<td style="text-align:center">AddTime()</td>
<td style="text-align:center">增加一个时间（时、分等）</td>
</tr>
<tr>
<td style="text-align:center">CurDate()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CurTime()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">Date()</td>
<td style="text-align:center">返回日期时间的日期部分</td>
</tr>
<tr>
<td style="text-align:center">DateDiff()</td>
<td style="text-align:center">计算两个日期之差</td>
</tr>
<tr>
<td style="text-align:center">Date_Add()</td>
<td style="text-align:center">高度灵活的日期运算函数</td>
</tr>
<tr>
<td style="text-align:center">Date_Format()</td>
<td style="text-align:center">返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td style="text-align:center">Day()</td>
<td style="text-align:center">返回一个日期的天数部分</td>
</tr>
<tr>
<td style="text-align:center">DatOfWeek()</td>
<td style="text-align:center">对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td style="text-align:center">Hour()</td>
<td style="text-align:center">返回一个时间的小时部分</td>
</tr>
<tr>
<td style="text-align:center">Minute()</td>
<td style="text-align:center">返回一个时间的分钟部分</td>
</tr>
<tr>
<td style="text-align:center">Month()</td>
<td style="text-align:center">返回一个日期的月份部分</td>
</tr>
<tr>
<td style="text-align:center">Now()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">Second()</td>
<td style="text-align:center">返回一个时间的秒部分</td>
</tr>
<tr>
<td style="text-align:center">Time()</td>
<td style="text-align:center">返回一个日期的时间部分</td>
</tr>
<tr>
<td style="text-align:center">Year()</td>
<td style="text-align:center">返回一个日期的年份部分</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>日期格式必须为yyyy-mm-dd。其他格式也可，但这是首选的，因为它排除了多义性。</li>
<li>使用4位数字的年份更可靠。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回order_date为&apos;2005-09-01&apos;的订单</span><br><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_date = &apos;2005-09-01&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>存储order_date值为 <code>2005-09-01 11:30:05</code>时，则 <code>WHERE order_date = &#39;2005-09-01&#39;</code>匹配失败。</li>
<li>解决方法是仅将给出的日期和列中的日期部分进行比较，而不是将给出的日期和整个列值进行比较。使用Date(order_date)指示仅提取列的日期部分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 更可靠的SELECT语句</span><br><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) = &apos;2005-09-01&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果要的是日期，使用Date()。想要的是时间，使用Time()。</p>
</li>
<li><p>检索2005年9月下的所有订单。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, order_num</span><br><span class="line">FROM orders</span><br><span class="line">WHERE Date(order_date) BETWEEN &apos;2005-09-01&apos; AND &apos;2005-09-30&apos;;</span><br><span class="line"></span><br><span class="line"># 更好的方法</span><br><span class="line">WHERE Year(order_date) = 2005 AND Month(order_date) = 9;</span><br></pre></td></tr></table></figure>
<h3 id="11-2-3-数值处理函数"><a href="#11-2-3-数值处理函数" class="headerlink" title="11.2.3 数值处理函数"></a>11.2.3 数值处理函数</h3><ul>
<li>常用数值处理函数</li>
</ul>
<center><strong>表11-3  常用数值处理函数</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Abs()</td>
<td style="text-align:center">返回一个数的绝对值</td>
</tr>
<tr>
<td style="text-align:center">Cos()</td>
<td style="text-align:center">返回一个角度的余弦</td>
</tr>
<tr>
<td style="text-align:center">Exp()</td>
<td style="text-align:center">返回一个数的指数值</td>
</tr>
<tr>
<td style="text-align:center">Mod()</td>
<td style="text-align:center">返回除操作的余数</td>
</tr>
<tr>
<td style="text-align:center">Pi()</td>
<td style="text-align:center">返回圆周率</td>
</tr>
<tr>
<td style="text-align:center">Rand()</td>
<td style="text-align:center">返回一个随机数</td>
</tr>
<tr>
<td style="text-align:center">Sin()</td>
<td style="text-align:center">返回一个角度的正弦</td>
</tr>
<tr>
<td style="text-align:center">Sqrt()</td>
<td style="text-align:center">返回一个数的平方根</td>
</tr>
<tr>
<td style="text-align:center">Tan()</td>
<td style="text-align:center">返回一个角度的正切</td>
</tr>
</tbody>
</table>
</div>
<h1 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h1><h2 id="12-1-聚集函数"><a href="#12-1-聚集函数" class="headerlink" title="12.1 聚集函数"></a>12.1 聚集函数</h2><ul>
<li>聚集函数，运行在行组上，计算和返回单个值的函数。</li>
</ul>
<center><strong>表12-1  SQL聚集函数</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AVG()</td>
<td style="text-align:center">返回某列的平均值</td>
</tr>
<tr>
<td style="text-align:center">COUNT()</td>
<td style="text-align:center">返回某列的行数</td>
</tr>
<tr>
<td style="text-align:center">MAX()</td>
<td style="text-align:center">返回某列的最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN()</td>
<td style="text-align:center">返回某列的最小值</td>
</tr>
<tr>
<td style="text-align:center">SUM()</td>
<td style="text-align:center">返回某列值之和</td>
</tr>
</tbody>
</table>
</div>
<h3 id="12-1-1-AVG-函数"><a href="#12-1-1-AVG-函数" class="headerlink" title="12.1.1 AVG()函数"></a>12.1.1 AVG()函数</h3><ul>
<li>可以返回所有列的平均值，也可以返回特定列或行的平均值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 返回products表中所有产品的平均价格</span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回特定供应商的产品平均价格</span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br></pre></td></tr></table></figure>
<ul>
<li>AVG只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出，为了获得多个列的平均值，必须使用多个AVG()函数。</li>
<li>AVG函数忽略列值为NULL的行。</li>
</ul>
<h3 id="12-1-2-COUNT-函数"><a href="#12-1-2-COUNT-函数" class="headerlink" title="12.1.2 COUNT()函数"></a>12.1.2 COUNT()函数</h3><ul>
<li>确定表中行的数目或符合特定条件的行的数目。</li>
<li>两种使用方式：<ul>
<li><code>COUNT(*)</code>，对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li>
<li>COUNT(column)，对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 对所有行计数</span><br><span class="line">SELECT COUNT(*) AS num_cust</span><br><span class="line">FROM customers;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 对只具有电子邮件地址的客户计数</span><br><span class="line">SELECT COUNT(cust_email) AS num_cust</span><br><span class="line">FROM customers;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果指定列名，则指定列的空值（NULL）被忽略，但如果用的是星号（不指定列名），则不忽略。</li>
</ul>
<h3 id="12-1-3-MAX-函数"><a href="#12-1-3-MAX-函数" class="headerlink" title="12.1.3 MAX()函数"></a>12.1.3 MAX()函数</h3><ul>
<li>返回列中的最大值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 返回products中的最大的价格</span><br><span class="line">SELECT MAX(prod_price) AS max_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>对非数值数据使用MAX()函数，允许返回任意列中的最大值，包括文本列。</li>
<li>MAX()函数忽略值为NULL的行。</li>
</ul>
<h3 id="12-1-4-MIN-函数"><a href="#12-1-4-MIN-函数" class="headerlink" title="12.1.4 MIN()函数"></a>12.1.4 MIN()函数</h3><ul>
<li>返回列中的最小值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 返回products中的最小的价格</span><br><span class="line">SELECT MIN(prod_price) AS min_price</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<ul>
<li>对非数值数据使用MIN()函数，允许返回任意列中的最小值，包括文本列。</li>
<li>MIN()函数忽略值为NULL的行。</li>
</ul>
<h3 id="12-1-5-SUM-函数"><a href="#12-1-5-SUM-函数" class="headerlink" title="12.1.5 SUM()函数"></a>12.1.5 SUM()函数</h3><ul>
<li>返回指定列值的和。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回orderitems表包含订单中实际的物品</span><br><span class="line">SELECT SUM(quantity) AS items_ordered</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<ul>
<li>SUM()函数也可以合并计算值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回orderitems表中所有物品价格之和</span><br><span class="line">SELECT SUM(item_price*quantity) AS total_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以执行多个列上的计算。</li>
<li>SUM()函数忽略列值为NULL的行。</li>
</ul>
<h2 id="12-2-聚焦不同值"><a href="#12-2-聚焦不同值" class="headerlink" title="12.2 聚焦不同值"></a>12.2 聚焦不同值</h2><ul>
<li>以下内容仅在MySQL 5及后期版本可用。</li>
<li>以上5个聚集函数都可以如下使用：<ul>
<li>对所有行执行计算，指定ALL参数或不给参数（因为ALL是默认的）。</li>
<li>只包含不同的值，指定DISTINCT参数。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 返回特定供应商的 不同价格 的平均值</span><br><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = 1003;</span><br></pre></td></tr></table></figure>
<ul>
<li>DISTINCT必须指定列名，COUNT(DISTINCT)会报错，还不能用于计算或表达式。</li>
<li>DISTINCT用于MIN()和MAX()，可行但没有价值。用不用结果一样。</li>
</ul>
<h2 id="12-3-组合函数"><a href="#12-3-组合函数" class="headerlink" title="12.3 组合函数"></a>12.3 组合函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 执行了4个聚集计算</span><br><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">	   MIN(prod_price) AS price_min,</span><br><span class="line">	   MAX(prod_price) AS price_max,</span><br><span class="line">	   AVG(prod_price) AS price_avg</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<h1 id="第13章-分组数据"><a href="#第13章-分组数据" class="headerlink" title="第13章 分组数据"></a>第13章 分组数据</h1><h2 id="13-1-数据分组"><a href="#13-1-数据分组" class="headerlink" title="13.1 数据分组"></a>13.1 数据分组</h2><ul>
<li>分组，把数据分为多个逻辑组，以便对每个组进行聚集计算。</li>
</ul>
<h2 id="13-2-创建分组"><a href="#13-2-创建分组" class="headerlink" title="13.2 创建分组"></a>13.2 创建分组</h2><ul>
<li>分组时在SELECT语句的 GROUP BY子句中建立的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用GROUP BY 对每个供应商计算产品数量</span><br><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>GROUP BY 可以包含任意数目的列，这使得能对分组进行嵌套。</li>
<li>如果使用了嵌套，数据将在最后规定的分组上进行汇总， 即所有列都一起计算。</li>
<li>GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式，如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名。</li>
<li>除聚集语句外，SELECT语句中的每个列都必须在GROUP BY 子句中给出。</li>
<li>若分组列中药NULL值，NULL值作为一个分组。</li>
<li><p>GROUP BY在WHERE子句之后，在ORDER BY 子句之前。</p>
</li>
<li><p>使用WITH ROOLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id WITH ROOLUP;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-过滤分组"><a href="#13-3-过滤分组" class="headerlink" title="13.3 过滤分组"></a>13.3 过滤分组</h2><ul>
<li>WHERE过滤的是行而不是分组。</li>
<li>使用HAVING过滤分组，WHERE子句可以用HAVING子句替代。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 找出两个以上的订单的分组，使用WHERE不起作用</span><br><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<ul>
<li>WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 列出具有2个及以上、价格为10及以上的产品的供应商</span><br><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &gt;= 10</span><br><span class="line">GROUP BY vend_id</span><br><span class="line">HAVING COUNT(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<h2 id="13-4-分组和排序"><a href="#13-4-分组和排序" class="headerlink" title="13.4 分组和排序"></a>13.4 分组和排序</h2><ul>
<li>ORDER BY 与GROUP BY的差别</li>
</ul>
<center><strong>表13-1 ORDER BY 与GROUP BY</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ORDER BY</th>
<th style="text-align:center">GROUP BY</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">排序产生的输出</td>
<td style="text-align:center">分组行。但输出可能不是分组的顺序</td>
</tr>
<tr>
<td style="text-align:center">任意列都可以使用（甚至非选择的列也可以使用）</td>
<td style="text-align:center">只可能使用选择列或表达式列，而且必须使用每个选择列表式</td>
</tr>
<tr>
<td style="text-align:center">不一定需要</td>
<td style="text-align:center">如果与聚集函数一起使用列（或表达式），则必须使用</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>一般在使用GROUP BY子句时，应该也给出ORDER BY 子句，这是保证数据正确排序的唯一方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 列出总计订单价格大于等于50的订单号和总订单价格</span><br><span class="line">SELECT order_num, SUM(quantity*item_price) AS ordertotal</span><br><span class="line">FROM orderitems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING SUM(quantity*item_price) &gt;= 50</span><br><span class="line">ORDER BY ordertotal;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-SELECT子句顺序"><a href="#13-5-SELECT子句顺序" class="headerlink" title="13.5 SELECT子句顺序"></a>13.5 SELECT子句顺序</h2><center><strong>表13-2 SELECT子句及其顺序</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">子句</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">是否必须使用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">要返回的列或表达式</td>
<td style="text-align:center">是</td>
</tr>
<tr>
<td style="text-align:center">FROM</td>
<td style="text-align:center">从中检索数据的表</td>
<td style="text-align:center">仅在从表选择数据时使用</td>
</tr>
<tr>
<td style="text-align:center">WHERE</td>
<td style="text-align:center">行级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">GROUP BY</td>
<td style="text-align:center">分组说明</td>
<td style="text-align:center">仅在按组计算聚集时使用</td>
</tr>
<tr>
<td style="text-align:center">HAVING</td>
<td style="text-align:center">组级过滤</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">ORDER BY</td>
<td style="text-align:center">输出排序顺序</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">LIMIT</td>
<td style="text-align:center">要检索的行数</td>
<td style="text-align:center">否</td>
</tr>
</tbody>
</table>
</div>
<h1 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h1><h2 id="14-1-子查询"><a href="#14-1-子查询" class="headerlink" title="14.1 子查询"></a>14.1 子查询</h2><ul>
<li>版本要求，MySQL4.1及以上版本。</li>
<li>查询，任何SQL语句都是查询，但此术语一般指SELECT语句。</li>
<li>子查询，嵌套在其他查询中的查询。</li>
</ul>
<h2 id="14-2-利用子查询进行过滤"><a href="#14-2-利用子查询进行过滤" class="headerlink" title="14.2 利用子查询进行过滤"></a>14.2 利用子查询进行过滤</h2><ul>
<li>把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN(SELECT cust_id</span><br><span class="line">                 FROM  orders</span><br><span class="line">                 WHERE order_num IN (SELECT order_num</span><br><span class="line">                 					 FROM orderitems</span><br><span class="line">									 WHERE prod_id = &apos;TNT2&apos;));</span><br><span class="line">					</span><br><span class="line"># 以上语句首先执行了SELECT order_num FROM orderitems	WHERE prod_id = &apos;TNT2&apos;; 在orderitems表里查询prod_id为TNT2的订单号，然后这些订单号以IN操作符传递给外部的WHERE子句。</span><br><span class="line"># 然后在orders表里查询具有这些订单号的客户ID，并将客户ID以IN操作符传递给最外层的WHERE子句。</span><br><span class="line"># 最后在customers表中查询这些客户ID的信息。</span><br></pre></td></tr></table></figure>
<ul>
<li>在SELECT语句中，子查询总是从内向外处理。</li>
<li>对于能嵌套的子查询的数目没有限制，但太多嵌套会影响性能。</li>
<li>列必须匹配，SELECT语句应该具有与WHERE子句中相同数目的列。</li>
<li>子查询可以与IN，=，&lt;&gt;等操作符结合使用。</li>
</ul>
<h2 id="14-3-作为计算字段使用子查询"><a href="#14-3-作为计算字段使用子查询" class="headerlink" title="14.3 作为计算字段使用子查询"></a>14.3 作为计算字段使用子查询</h2><ul>
<li>使用子查询的另一方法是创建计算字段。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 从customers表中检索客户列表</span><br><span class="line"># 对于检索出的每个客户，统计其在orders表中的订单数目</span><br><span class="line">SELECT cust_name,</span><br><span class="line">	   cust_state,</span><br><span class="line">	   (SELECT COUNT(*)</span><br><span class="line">	   FROM orders</span><br><span class="line">	   WHERE orders.cust_id = customers.cust_id) AS orders)</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询中的WHERE语句需要使用完全限定列名。<code>orders.cust_id = customers.cust_id</code>。这种类型的子查询称为相关子查询，即涉及外部查询的子查询，必须使用这种语法。否则可能出错。</li>
</ul>
<h1 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h1><h2 id="15-1-联结"><a href="#15-1-联结" class="headerlink" title="15.1 联结"></a>15.1 联结</h2><ul>
<li>SQL最强大的功能之一，在数据检索查询的执行中联结表。</li>
</ul>
<h3 id="15-1-1-关系表"><a href="#15-1-1-关系表" class="headerlink" title="15.1.1 关系表"></a>15.1.1 关系表</h3><ul>
<li>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（关系）互相关联。</li>
<li>外键，某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系。</li>
<li>好处：<ul>
<li>信息不重复，不浪费时间和空间。</li>
<li>信息变动，只更新对应表的单个记录，相关表中的数据不用改动。</li>
<li>数据无重复，处理更简单。</li>
<li>有效地存储和方便地处理。</li>
</ul>
</li>
<li>关系数据库的可伸缩性远比非关系数据库要好。</li>
<li>可伸缩性，能够适应不断增加的工作量而不失败。</li>
</ul>
<h3 id="15-1-2-为什么要使用联结"><a href="#15-1-2-为什么要使用联结" class="headerlink" title="15.1.2 为什么要使用联结"></a>15.1.2 为什么要使用联结</h3><ul>
<li>联结，用来在一条SELECT语句中关联表。</li>
<li>维护引用完整性，仅在关系列中插入合法的数据。</li>
</ul>
<h2 id="15-2-创建联结"><a href="#15-2-创建联结" class="headerlink" title="15.2 创建联结"></a>15.2 创建联结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># prod_name, prod_price在products中，而vend_name在vendors中</span><br><span class="line"># 使用WHERE正确联结，需完全限定列名</span><br><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendor, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>在引用的列可能出现二义性时，必须使用完全限定列名。</li>
</ul>
<h3 id="15-2-1-WHERE子句的重要性"><a href="#15-2-1-WHERE子句的重要性" class="headerlink" title="15.2.1 WHERE子句的重要性"></a>15.2.1 WHERE子句的重要性</h3><ul>
<li>WHERE作为过滤条件，只包含那些匹配给定条件（联结条件）的行。</li>
<li>没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 笛卡尔积，由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。又称叉联结。</li>
<li>应该保证所有联结都有WHERE子句，否则将返回比想要的数据多得多的数据</li>
</ul>
<h3 id="15-2-2-内部联结"><a href="#15-2-2-内部联结" class="headerlink" title="15.2.2 内部联结"></a>15.2.2 内部联结</h3><ul>
<li>基于两个表之间的相等测试，称为等值联结，也称为内部联结。</li>
<li>使用不同语法来明确联结的类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 与前面例子完全相同</span><br><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendor INNER JOIN products</span><br><span class="line">ON vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>ANSI SQL规范首选INNER JOIN 语法。</li>
</ul>
<h3 id="15-2-3-联结多个表"><a href="#15-2-3-联结多个表" class="headerlink" title="15.2.3 联结多个表"></a>15.2.3 联结多个表</h3><ul>
<li>SQL对一条SELECT语句中可以联结的表的数目没有限制。首先列出所有表，然后定义表之间的关系。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 显示订单编号为20005的订单中的物品</span><br><span class="line">SELECT vend_name, prod_name, prod_price, quantity</span><br><span class="line">FROM orderitems, products, vendor</span><br><span class="line">WHERE products.vend_id = vendors.vend_id</span><br><span class="line">	AND orderitems.prod_id = products.prod_id</span><br><span class="line">	AND order_num = 20005;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>性能考虑，联结的表越多，性能下降越厉害。</p>
</li>
<li><p>联结表可以替代子查询。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN(SELECT cust_id</span><br><span class="line">                 FROM  orders</span><br><span class="line">                 WHERE order_num IN (SELECT order_num</span><br><span class="line">                 					 FROM orderitems</span><br><span class="line">									 WHERE prod_id = &apos;TNT2&apos;));</span><br><span class="line"># 等价于</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orders.order_num = orderitems.order_num</span><br><span class="line">	AND prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<h1 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h1><h2 id="16-1-创建高级联结"><a href="#16-1-创建高级联结" class="headerlink" title="16.1 创建高级联结"></a>16.1 创建高级联结</h2><ul>
<li>给列起别名的语法如下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>给表名起别名，可以缩短SQL语句，并允许在单条SELECT语句中多次使用相同的表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">where c.cust_id = o.cust_id</span><br><span class="line">	AND io.order_num = o.order_nu</span><br><span class="line">	AND prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机。</li>
</ul>
<h2 id="16-2-使用不同类型的联结"><a href="#16-2-使用不同类型的联结" class="headerlink" title="16.2 使用不同类型的联结"></a>16.2 使用不同类型的联结</h2><ul>
<li>前文都是内部联结，下面介绍自联结、自然联结和外部联结。</li>
</ul>
<h3 id="16-2-1-自联结"><a href="#16-2-1-自联结" class="headerlink" title="16.2.1 自联结"></a>16.2.1 自联结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查询生产ID为DTNTR的供应商的其他物品</span><br><span class="line"></span><br><span class="line"># 使用子查询</span><br><span class="line">SELECT prod_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id = (SELECT vend_id</span><br><span class="line">				FROM products</span><br><span class="line">				WHERE prod_id = &apos;DTNTR&apos;);</span><br><span class="line"></span><br><span class="line"># 使用自联结</span><br><span class="line"># 使用两次products表，但用不同的别名</span><br><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id</span><br><span class="line">	AND p2.prod_id = &apos;DTNTR&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>用自联结而不用子查询，虽然结果相同，但自联结速度更快。</li>
</ul>
<h3 id="16-2-2-自然联结"><a href="#16-2-2-自然联结" class="headerlink" title="16.2.2 自然联结"></a>16.2.2 自然联结</h3><ul>
<li>自然联结排除列多次出现，使每个列只返回一次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 通配符只对第一个表使用，所有其他列明确列出，所有没有重复的列被检索出来</span><br><span class="line">SELECT c.*, o.order_num, o.order_date,</span><br><span class="line">		oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line">FROM customers AS c, orders AS o, orderitems AS oi</span><br><span class="line">WHERE c.cust_id = o.cust_id</span><br><span class="line">	AND oi.order_num = o.order_num</span><br><span class="line">	AND prod_id = &apos;FB&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>到目前为止 每个内部联结都是自然联结，一般不会用到不是自然联结的内部联结。</li>
</ul>
<h3 id="16-2-3-外部联结"><a href="#16-2-3-外部联结" class="headerlink" title="16.2.3 外部联结"></a>16.2.3 外部联结</h3><ul>
<li>外部联结，联结包含了在相关表中没有关联行的行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 内部联结 检索所有客户及其订单</span><br><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 外部联结 检索所有客户，包括没有订单的客户</span><br><span class="line">SELECT customers.cust_id, orders.order_num</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<ul>
<li>在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表，RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表。上例使用LEFT OUTER JOIN从FROM 子句的左边表(customers表)中选择所有行。</li>
<li>不支持<code>*=</code>和<code>=*</code>的使用。</li>
</ul>
<h2 id="16-3-使用带聚集函数的联结"><a href="#16-3-使用带聚集函数的联结" class="headerlink" title="16.3 使用带聚集函数的联结"></a>16.3 使用带聚集函数的联结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 检索所有客户及每个客户所下的订单数</span><br><span class="line">SELECT customers.cust_name,</span><br><span class="line">		customers.cust_id,</span><br><span class="line">		COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers INNER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 使用左外部联结来包含所有客户，包括没有任何下订单的客户</span><br><span class="line">SELECT customers.cust_name,</span><br><span class="line">		customers.cust_id,</span><br><span class="line">		COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers LEFT OUTER JOIN orders</span><br><span class="line">ON customers.cust_id = orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br></pre></td></tr></table></figure>
<h2 id="16-4-使用联结和联结条件"><a href="#16-4-使用联结和联结条件" class="headerlink" title="16.4 使用联结和联结条件"></a>16.4 使用联结和联结条件</h2><ul>
<li>注意所使用的联结条件，一般使用内部联结。</li>
<li>保证使用正确的联结条件，否则将返回不正确的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡尔积。</li>
<li>使用多个联结时，分别测试每个联结，这将使故障排除更为简单。</li>
</ul>
<h1 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h1><h2 id="17-1-组合查询"><a href="#17-1-组合查询" class="headerlink" title="17.1 组合查询"></a>17.1 组合查询</h2><ul>
<li>组合查询，执行多条SELECT语句，并将结果作为单个查询结果集返回，这些组合查询又称并或复合查询。</li>
<li>两种情况需要组合查询：<ul>
<li>在单个查询中从不同的表返回类似结构的数据。</li>
<li>对单个表执行多个查询，按单个查询返回数据。</li>
</ul>
</li>
<li>组合查询与具有多个WHERE子句条件的单条查询相同。</li>
</ul>
<h2 id="17-2-创建组合查询"><a href="#17-2-创建组合查询" class="headerlink" title="17.2 创建组合查询"></a>17.2 创建组合查询</h2><ul>
<li>用UNION操作符来组合数条SQL查询。</li>
</ul>
<h3 id="17-2-1-使用UNION"><a href="#17-2-1-使用UNION" class="headerlink" title="17.2.1 使用UNION"></a>17.2.1 使用UNION</h3><ul>
<li>给出每条SELECT语句，在各条语句之前放上关键字UNION。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 使用UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_in IN (1001, 1002);</span><br><span class="line"></span><br><span class="line"># 使用多条WHERE</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5 </span><br><span class="line">	OR vend_in IN (1001, 1002);</span><br></pre></td></tr></table></figure>
<h3 id="17-2-2-UNION规则"><a href="#17-2-2-UNION规则" class="headerlink" title="17.2.2 UNION规则"></a>17.2.2 UNION规则</h3><ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用UNION分隔。</li>
<li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（列出次序可以不同）</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是DBMS可以隐含地转换的类型。</li>
</ul>
<h3 id="17-2-3-包含或取消重复的行"><a href="#17-2-3-包含或取消重复的行" class="headerlink" title="17.2.3 包含或取消重复的行"></a>17.2.3 包含或取消重复的行</h3><ul>
<li>UNION从查询结果集中自动去除了重复的行。可以使用UNION ALL不去除重复的行。</li>
</ul>
<h3 id="17-2-4-对组合结果排序"><a href="#17-2-4-对组合结果排序" class="headerlink" title="17.2.4 对组合结果排序"></a>17.2.4 对组合结果排序</h3><ul>
<li>在使用UNION组合查询时，只能使用一条ORDER BY子句，必须出现在最后一条SELECT语句之后。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 使用UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE prod_price &lt;= 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id, prod_id, prod_price</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_in IN (1001, 1002)</span><br><span class="line">ORDER BY vend_id, prod_price;</span><br></pre></td></tr></table></figure>
<h1 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h1><h2 id="18-1-理解全文本搜索"><a href="#18-1-理解全文本搜索" class="headerlink" title="18.1 理解全文本搜索"></a>18.1 理解全文本搜索</h2><ul>
<li>两个最常用的引擎MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。</li>
<li>如果需要全文本搜索功能，在创建表时选择MyISAM引擎。</li>
<li>通配符和正则表达式存在几个重要的限制：<ul>
<li>性能，通配符和正则表达式通常要求尝试匹配表中所有行，行增加时非常耗时。</li>
<li>明确控制，很难明确控制匹配什么和不匹配什么。</li>
<li>智能化的结果。</li>
</ul>
</li>
</ul>
<h2 id="18-2-使用全文本搜索"><a href="#18-2-使用全文本搜索" class="headerlink" title="18.2 使用全文本搜索"></a>18.2 使用全文本搜索</h2><ul>
<li>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。</li>
<li>在索引之后，SELECT可与Match()和Against()一起使用以执行搜索。</li>
</ul>
<h3 id="18-2-1-启用全文本搜索支持"><a href="#18-2-1-启用全文本搜索支持" class="headerlink" title="18.2.1 启用全文本搜索支持"></a>18.2.1 启用全文本搜索支持</h3><ul>
<li>在创建表时启用全文本搜索，CRTATE TABLE语句（第21章介绍）接收FULLTEXT子句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CRTATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">	note_id   int      NOT NULL AUTO_INCREMENT,</span><br><span class="line">	prod_id   char(10) NOT NULL,</span><br><span class="line">	note_date datetime NOT NULL,</span><br><span class="line">	note_text text     NULL,</span><br><span class="line">	PROMARY KEY(note_id),</span><br><span class="line">	FULLTEXT(note_text)</span><br><span class="line">) ENGINE = MyISAM;</span><br></pre></td></tr></table></figure>
<ul>
<li>MySQL根据子句FULLTEXT(note_text)的指示对note_text进行索引。FULLTEXT可以索引单个或者多个列。MySQL自动维护该索引，在增加、更新或删除行时，索引随之自动更新。</li>
<li>可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立刻索引）。</li>
<li>不要在导入数据时使用FULLTEXT，更新索引比较耗时。</li>
</ul>
<h3 id="18-2-2-进行全文本搜索"><a href="#18-2-2-进行全文本搜索" class="headerlink" title="18.2.2 进行全文本搜索"></a>18.2.2 进行全文本搜索</h3><ul>
<li>使用函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 搜索note_text中含rabbit的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;rabbit&apos;);</span><br></pre></td></tr></table></figure>
<ul>
<li>传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）。</li>
<li>搜索默认不区分大小写，除非使用BINARY关键字。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 也使用LIKE 搜索note_text中含rabbit的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE note_text LIKE &apos;%rabbit%&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>LIKE以不那么有用的顺序返回数据，使用全文本搜索以文本匹配的良好程度排序返回数据。全文本搜索的一个重要部分就是对结果排序，具有较高等级的行先返回。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 全文本搜索排序过程，不包含rabbit的行等级为0，包含rabbit的行中词靠前的行等级高</span><br><span class="line">SELECT note_text</span><br><span class="line">		Match(note_text) Against(&apos;rabbit&apos;) AS rank</span><br><span class="line">FROM products;</span><br></pre></td></tr></table></figure>
<h3 id="18-2-3-使用查询扩展"><a href="#18-2-3-使用查询扩展" class="headerlink" title="18.2.3 使用查询扩展"></a>18.2.3 使用查询扩展</h3><ul>
<li>查询扩展用来设法放宽所返回的全文本搜索结果的范围。</li>
<li><p>使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索：</p>
<ul>
<li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行。</li>
<li>其次，MySQL检查这些匹配行并选择所有有用的词（如何判定什么有用，什么无用）。</li>
<li>再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。</li>
</ul>
</li>
<li><p>利用扩展查询，能找出可能相关的结果，即使它们并不精确包含所查找的词。</p>
</li>
<li>查询扩展功能只用于版本4.1.1或更高版本。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 搜索note_text中含rabbit的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
<ul>
<li>表中的行越多，使用查询扩展返回的结果越好。</li>
</ul>
<h3 id="18-2-4-布尔文本搜索"><a href="#18-2-4-布尔文本搜索" class="headerlink" title="18.2.4 布尔文本搜索"></a>18.2.4 布尔文本搜索</h3><ul>
<li>MySQL支持全文本搜索的另一种形式，称为布尔方式。</li>
<li>以布尔方式，可以提供如下内容的细节：<ul>
<li>要匹配的词；</li>
<li>要排斥的词；</li>
<li>排列提示；</li>
<li>表达式分组；</li>
<li>另外一些内容。</li>
</ul>
</li>
<li>即使没有FULLTEXT索引也可以使用，但性能比较差。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配词heavy，但排除包含任何以rope开始的词的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;heavy -rope*&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<center><strong>表18-1 全文本布尔操作符</strong></center>


<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">布尔操作符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">包含，词必须存在</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">排除，词必须不出现</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">包含，而且增加等级值</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">包含，而且减少等级值</td>
</tr>
<tr>
<td style="text-align:center">()</td>
<td style="text-align:center">把词组成表达式（允许这些子表达式作为一个组被包含、排除、排列等）</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">取消一个词的排序词</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">词尾的通配符</td>
</tr>
<tr>
<td style="text-align:center">“ ”</td>
<td style="text-align:center">定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语）</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配包含词rabbit和bait的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;+rabbit +bait&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 没有指定操作符，匹配包含rabbit和bait中的至少一个词的行</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;rabbit bait&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配rabbit和carrot，增加前者的等级，降低后者的等级</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;&gt;rabbit &lt;carrot&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 匹配safe和combination，降低后者的等级</span><br><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&apos;+safe +(&lt;combination)&apos; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<h3 id="18-2-5-全文本搜索的使用说明"><a href="#18-2-5-全文本搜索的使用说明" class="headerlink" title="18.2.5 全文本搜索的使用说明"></a>18.2.5 全文本搜索的使用说明</h3><ul>
<li>在索引全文本数据时，短语被忽略且从索引中排除，短语定义为具有3个及3个以下字符的词（如果需要，这个数目可以更改）。</li>
<li>MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略，如果需要，可以覆盖这个列表。</li>
<li>许多词出现的频率很高，搜索它们没有用处（返回太多结果），因此，如果一个词出现在50%的行中，则将它作为一个非用词忽略。%50规则不用于 IN BOOLEAN MODE。</li>
<li>如果表中的行数少于3，则全文本搜索不返回结果。</li>
<li>忽略词中的单引号。例如don’t索引为dont</li>
<li>不具有词分隔符的语言不能恰当地返回全文本搜索结果。</li>
<li>仅在MyISAM引擎中支持全文本搜索。</li>
<li>没有邻近操作符。</li>
</ul>
<h1 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h1><h2 id="19-1-数据插入"><a href="#19-1-数据插入" class="headerlink" title="19.1 数据插入"></a>19.1 数据插入</h2><ul>
<li>INSERT语句。</li>
<li>插入完整的行。</li>
<li>插入行的一部分。</li>
<li>插入多行。</li>
<li>插入某些查询的结果。</li>
</ul>
<h2 id="19-2-插入完整的行"><a href="#19-2-插入完整的行" class="headerlink" title="19.2 插入完整的行"></a>19.2 插入完整的行</h2><ul>
<li>指定表名和被插入到新行中的值。</li>
<li>存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。</li>
<li>各个列必须以它们在表定义中出现的次序填充。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 插入一个新客户到customers表</span><br><span class="line">INSERT INTO Customers</span><br><span class="line">VALUES(NULL,</span><br><span class="line">	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>简单但不安全，尽量避免使用，高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息，结构变动后各个列可能不能保持相同的次序。</p>
</li>
<li><p>更安全的方法（不过更繁琐），在表名后的括号里明确给出列名。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 插入一个新客户到customers表</span><br><span class="line">INSERT INTO Customers(cust_name,</span><br><span class="line">			cust_address,</span><br><span class="line">			cust_city,</span><br><span class="line">			cust_state,</span><br><span class="line">			cust_zip,</span><br><span class="line">			cust_country,</span><br><span class="line">			cust_contact,</span><br><span class="line">			cust_email)</span><br><span class="line">VALUES(	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>
<ul>
<li>提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序，即使表的结构改变，仍能正确工作。</li>
<li>总是使用列的列表。</li>
<li>仔细地给出正确数目的VALUES值。</li>
<li><p>使用给出列名的这种语法，还可以省略列，可以只给某些列提供值。</p>
<ul>
<li>该列定义为允许NULL值</li>
<li>在表定义中给出默认值，这表示如果不给出值，将使用默认值</li>
<li>如果对表中不允许NULL值且没有默认值的列不给出值，将会报错</li>
</ul>
</li>
<li><p>提高整体性能，INSERT操作比较耗时，可以在INSERT和INTO之间添加关键字LOW_PRIORITY，指示降低INSERT的优先级。</p>
</li>
</ul>
<h2 id="19-3-插入多个行"><a href="#19-3-插入多个行" class="headerlink" title="19.3 插入多个行"></a>19.3 插入多个行</h2><ul>
<li>使用多条INSERT语句，一次提交它们，每条语句用一个分号结束。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 插入多个新客户到customers表</span><br><span class="line">INSERT INTO Customers(cust_name,</span><br><span class="line">			cust_address,</span><br><span class="line">			cust_city,</span><br><span class="line">			cust_state,</span><br><span class="line">			cust_zip,</span><br><span class="line">			cust_country,</span><br><span class="line">			cust_contact,</span><br><span class="line">			cust_email)</span><br><span class="line">VALUES(	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br><span class="line">INSERT INTO Customers(cust_name,</span><br><span class="line">			cust_address,</span><br><span class="line">			cust_city,</span><br><span class="line">			cust_state,</span><br><span class="line">			cust_zip,</span><br><span class="line">			cust_country,</span><br><span class="line">			cust_contact,</span><br><span class="line">			cust_email)</span><br><span class="line">VALUES(	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>
<ul>
<li>或者，只要每条INSERT语句中的列名和次序相同，可以如下组合各语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 插入多个新客户到customers表</span><br><span class="line">INSERT INTO Customers(cust_name,</span><br><span class="line">			cust_address,</span><br><span class="line">			cust_city,</span><br><span class="line">			cust_state,</span><br><span class="line">			cust_zip,</span><br><span class="line">			cust_country,</span><br><span class="line">			cust_contact,</span><br><span class="line">			cust_email)</span><br><span class="line">VALUES(	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL)，</span><br><span class="line">VALUES(	&apos;Pep E. LaPew&apos;,</span><br><span class="line">	&apos;100 Main Street&apos;,</span><br><span class="line">	&apos;Los Angeles&apos;,</span><br><span class="line">	&apos;CA&apos;,</span><br><span class="line">	&apos;90046&apos;,</span><br><span class="line">	&apos;USA&apos;,</span><br><span class="line">	NULL,</span><br><span class="line">	NULL);</span><br></pre></td></tr></table></figure>
<ul>
<li>其中单条INSERT语句有多个值，每组值用一对圆括号括起来，用逗号分隔。此技术可以提高数据库处理的性能，因为用单条INSERT语句处理多个插入比使用多条INSERT语句块。</li>
</ul>
<h2 id="19-4-插入检索出的数据"><a href="#19-4-插入检索出的数据" class="headerlink" title="19.4 插入检索出的数据"></a>19.4 插入检索出的数据</h2><ul>
<li>利用INSERT语句将一条SELEECT语句的结果插入表中，这就是所谓的INSERT SELECT，即由一条INSERT语句和一条SELECT语句组成。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 从custnew表将所有数据导入到customers表中</span><br><span class="line"># 为避免重复，可以将INSERT和SELECT中的cust_id列忽略</span><br><span class="line">INSERT INTO customers(cust_id,</span><br><span class="line">					cust_contact,</span><br><span class="line">					cust_email,</span><br><span class="line">					cust_name,</span><br><span class="line">					cust_address,</span><br><span class="line">					cust_city,</span><br><span class="line">					cust_state,</span><br><span class="line">					cust_zip,</span><br><span class="line">					cust_country)</span><br><span class="line">SELECT cust_id,</span><br><span class="line">        cust_contact,</span><br><span class="line">        cust_email,</span><br><span class="line">        cust_name,</span><br><span class="line">        cust_address,</span><br><span class="line">        cust_city,</span><br><span class="line">        cust_state,</span><br><span class="line">        cust_zip,</span><br><span class="line">        cust_country</span><br><span class="line">FROM custnew;</span><br></pre></td></tr></table></figure>
<ul>
<li>INSERT SELECT中的列名，不一定要求列名匹配，使用的是列的位置，SELECT中的第一列（不管其列名）将会用来填充INSERT表列中指定的第一个列。这对于使用不同列名的表中导入数据非常有用。</li>
<li>INSERT SELECT语句可包含WHERE子句过滤插入的数据。</li>
</ul>
<h1 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h1><h2 id="20-1-更新数据"><a href="#20-1-更新数据" class="headerlink" title="20.1 更新数据"></a>20.1 更新数据</h2><ul>
<li>UPDATE语句更新（修改）表中的数据。<ul>
<li>更新表中特定行，使用WHERE子句</li>
<li>更新表中所有行</li>
</ul>
</li>
<li>UPDATE语句的组成。<ul>
<li>要更新的表</li>
<li>列名和它们的新值</li>
<li>确定要更新行的过滤条件</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 更新单个列</span><br><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = &apos;elmer@fudd.com&apos;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>
<ul>
<li>UPDATE后更要更新的表名。SET用来指定新值被赋予的列。WHERE指定特定的行，没有WHERE子句，将会更新所有行。</li>
<li>在更新多个列时，只需要使用单个SET命令，每个 “列=值”对之间用逗号分隔。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 更新两个列</span><br><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = &apos;elmer@fudd.com&apos;,</span><br><span class="line">	cust_name = &apos;The Fudds&apos;</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>
<ul>
<li>UPDATE语句可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。</li>
<li><p>IGNORE关键字，即使发生错误，也继续进行更新，UPDATE IGNORE customers..。</p>
</li>
<li><p>为删除某个列的值，可设置它为NULL值（假如表定义允许NULL值）。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE customers</span><br><span class="line">SET cust_email = NULL</span><br><span class="line">WHERE cust_id = 10005;</span><br></pre></td></tr></table></figure>
<h2 id="20-2-删除数据"><a href="#20-2-删除数据" class="headerlink" title="20.2 删除数据"></a>20.2 删除数据</h2><ul>
<li>DELETE语句删除（去掉）数据。<ul>
<li>从表中删除特定的行，使用WHERE子句</li>
<li>从表中删除所有行</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除一行</span><br><span class="line">DELETE FROM customers</span><br><span class="line">WHERE cust_id = 10006;</span><br></pre></td></tr></table></figure>
<ul>
<li>DELETE不需要列名和通配符。</li>
<li>DELET 删除整行而不是删除列，为了删除指定的列，使用UPDATE语句。</li>
<li>DELETE从表中删除行，不删除表本身。</li>
<li>如果想要删除表中所有的行，不要使用DELETE，可使用TRUNCATE TABLE语句，它完成同样的工作，但速度更快。</li>
</ul>
<h2 id="20-3-更新和删除的指导原则"><a href="#20-3-更新和删除的指导原则" class="headerlink" title="20.3 更新和删除的指导原则"></a>20.3 更新和删除的指导原则</h2><ul>
<li>除非打算更新和删除所有行，否则不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键，尽可能像WHERE子句那样使用它。</li>
<li>在对UPDATE或DELETE语句使用WHERE子句前，应先使用SELECT进行测试，保证正确过滤。</li>
<li>使用强制引用完整性的数据库。</li>
<li>没有撤销功能。</li>
</ul>
<h1 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h1><h2 id="21-1-创建表"><a href="#21-1-创建表" class="headerlink" title="21.1 创建表"></a>21.1 创建表</h2><ul>
<li>创建表的方法。<ul>
<li>使用具有交互式管理和创建表的工具</li>
<li>使用MySQL语句操纵，使用CREATE TABLE语句</li>
</ul>
</li>
</ul>
<h3 id="21-1-1-表创建基础"><a href="#21-1-1-表创建基础" class="headerlink" title="21.1.1 表创建基础"></a>21.1.1 表创建基础</h3><ul>
<li>创建表，必须给出以下信息。<ul>
<li>新表的名字，在关键字CREATE TABLE之后给出</li>
<li>表列的名字和定义，用逗号分隔</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建customers表</span><br><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">cust_id      int       NOT NULL AUTO_INCREMENT,</span><br><span class="line">cust_name    char(50)  NOT NULL,</span><br><span class="line">cust_address char(50)  NULL,</span><br><span class="line">cust_city    char(50)  NULL,</span><br><span class="line">cust_state   char(5)   NULL,</span><br><span class="line">cust_zip     char(10)  NULL,</span><br><span class="line">cust_conutry char(50)  NULL,</span><br><span class="line">cust_contact char(50)  NULL,</span><br><span class="line">cust_email   char(255) NULL,</span><br><span class="line">PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL对缩进空格等格式化没有规定，推荐采用某种缩进格式。</li>
<li>创建表时，指定的表名必须不存在，否则出错。如果表存在，一般首先手工删除表，然后在重建它。如果想仅在表不存在时创建，表名后使用IF NOT EXISTS。</li>
</ul>
<h3 id="21-1-2-使用NULL值"><a href="#21-1-2-使用NULL值" class="headerlink" title="21.1.2 使用NULL值"></a>21.1.2 使用NULL值</h3><ul>
<li>允许NULL值的列允许在插入行时不给出该列的值，不允许NULL值的列在插入或更新行时，该列必须有值。</li>
<li>创建表时，NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。</li>
<li>NULL值是没有值，而不是空串<code>&#39;&#39;</code>，空串是一个有效的值。</li>
</ul>
<h3 id="21-1-3-主键再介绍"><a href="#21-1-3-主键再介绍" class="headerlink" title="21.1.3 主键再介绍"></a>21.1.3 主键再介绍</h3><ul>
<li>主键值必须唯一，如果使用单个列，则它的值必须唯一，如果使用多个列，则这些列的组合值必须唯一。</li>
<li>多个列组成的主键，以逗号分隔的列表给出各列名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 多个列组成的主键</span><br><span class="line">CREATE TABLE orderitems</span><br><span class="line">(</span><br><span class="line">order_num   int          NOT NULL,</span><br><span class="line">order_item  int          NOT NULL,</span><br><span class="line">prod_id     char(10)     NOT NULL,</span><br><span class="line">quantity    int          NOT NULL,</span><br><span class="line">item_price  decimal(8,2) NOT NULL,</span><br><span class="line">PRIMARY KEY (order_num, order_item)</span><br><span class="line">) ENGINE = InnoDB</span><br></pre></td></tr></table></figure>
<ul>
<li>主键可以在创建表时定义，也可以在创建表之后定义。</li>
<li>主键中不允许NULL值的列，允许NULL值的列不能作为唯一标识。</li>
</ul>
<h3 id="21-1-4-使用AUTO-INCREMENT"><a href="#21-1-4-使用AUTO-INCREMENT" class="headerlink" title="21.1.4 使用AUTO_INCREMENT"></a>21.1.4 使用AUTO_INCREMENT</h3><ul>
<li>设置AUTO_INCREMENT 的列，每当增加一行时自动增量。</li>
<li>每个表只允许一个AUTO_INCREMENT 列，而且它必须被索引，可以通过使它成为主键值。</li>
<li>AUTO_INCREMENT 的列可以在插入时指定一个值，只要它是唯一（至今尚未使用过）即可，该值将被用来替代自动生成的值，后续的增量将开始使用该手工插入的值。</li>
<li>确定AUTO_INCREMENT的值，使用SELECT last_insert_id()返回最后一个AUTO_INCREMENT值，然后可以将该值用于其他MySQL语句。</li>
</ul>
<h3 id="21-1-5-指定默认值"><a href="#21-1-5-指定默认值" class="headerlink" title="21.1.5 指定默认值"></a>21.1.5 指定默认值</h3><ul>
<li>默认值用CREATE TABLE语句的列定义中的DEFALUT关键字指定。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 指定quantity的默认值为1</span><br><span class="line">CREATE TABLE orderitems</span><br><span class="line">(</span><br><span class="line">order_num  int NOT NULL,</span><br><span class="line">order_item int NOT NULL,</span><br><span class="line">prod_id char(10) NOT NULL,</span><br><span class="line">quantity int NOT NULL DEFAULT 1,</span><br><span class="line">item_price decimal(8,2) NOT NULL,</span><br><span class="line">PRIMARY KEY (order_num, order_item)</span><br><span class="line">) ENGINE = InnoDB;</span><br></pre></td></tr></table></figure>
<ul>
<li>不允许使用函数作为默认值，它只支持常量。</li>
<li>使用默认值而不是NULL值。</li>
</ul>
<h3 id="21-1-6-引擎类型"><a href="#21-1-6-引擎类型" class="headerlink" title="21.1.6 引擎类型"></a>21.1.6 引擎类型</h3><ul>
<li>如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。</li>
<li>InnoDB是一个可靠的事物处理引擎，不支持全文本搜索。</li>
<li>MEMORY在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（适合于临时表）。</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事物管理。</li>
<li>引擎类型可以混用。</li>
<li>外键不跨引擎。</li>
<li>MyISAM最受欢迎。</li>
</ul>
<h2 id="21-2-更新表"><a href="#21-2-更新表" class="headerlink" title="21.2 更新表"></a>21.2 更新表</h2><ul>
<li>使用ALTER TABLE更新表定义，但是，理想状态下，当表中存储数据以后，该表就不应该别更新。</li>
<li>使用ALTER TABLE更改表结构，需给出以下信息。<ul>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在）。</li>
<li>所做更改的列表。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 给表添加一个名为vend_phone的列，必须明确数据类型</span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">ADD vend_phone CHAR(20);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 删除列</span><br><span class="line">ALTER TABLE vendors</span><br><span class="line">DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用ALTER TABLE 定义外键。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br><span class="line"></span><br><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_products</span><br><span class="line">FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br></pre></td></tr></table></figure>
<ul>
<li>复杂的表结构更改需要手动删除过程，步骤：<ul>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句从旧表复制数据到新表，如果有必要，可使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ul>
</li>
<li>使用ALTER TABLE前应该做一个完整的备份，因为数据表的更改不能撤销。</li>
</ul>
<h2 id="21-3-删除表"><a href="#21-3-删除表" class="headerlink" title="21.3 删除表"></a>21.3 删除表</h2><ul>
<li>使用DROP TABLE 语句。DROP TABLE customers2，删除表没有确认，也不能撤销。</li>
</ul>
<h2 id="21-4-重命名表"><a href="#21-4-重命名表" class="headerlink" title="21.4 重命名表"></a>21.4 重命名表</h2><ul>
<li>使用RENAME TABLE语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重命名一个表</span><br><span class="line">RENAME TABLE customers2 TO customers;</span><br><span class="line"></span><br><span class="line"># 重命名多个表，使用逗号分隔</span><br><span class="line">RENAME TABLE backup_customers TO customers,</span><br><span class="line">				backup_vendors TO vendors,</span><br><span class="line">				backup_produts TO products;</span><br></pre></td></tr></table></figure>
<h1 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h1><h2 id="22-1-视图"><a href="#22-1-视图" class="headerlink" title="22.1 视图"></a>22.1 视图</h2><ul>
<li>版本要求，MySQL5及之后版本添加了对视图的支持。</li>
<li>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orders.order_num = orderitems.order_num</span><br><span class="line">	AND prod_id = &apos;TNT2&apos;;</span><br><span class="line">	</span><br><span class="line"># 假如可以把以上整个查询包装成一个productcustomers的虚拟表，则可以从虚拟表中检索数据</span><br><span class="line"># productcustomers是一个视图</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="22-1-1-为什么使用视图"><a href="#22-1-1-为什么使用视图" class="headerlink" title="22.1.1 为什么使用视图"></a>22.1.1 为什么使用视图</h3><ul>
<li>重用SQL语句。</li>
<li>简化复杂的SQL操作。</li>
<li>使用表的组成部分而不是整个表。</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li>
<li><p>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p>
</li>
<li><p>在视图创建之后，可以用于表基本相同的方式利用他们，可以执行SELECT，过滤和排序，联结，甚至是添加和更新数据的操作。</p>
</li>
<li>性能问题。视图不包含数据，每次使用视图时，都必须处理查询执行时所需的任一个查询，如果使用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。</li>
</ul>
<h3 id="22-1-2-视图的规则和限制"><a href="#22-1-2-视图的规则和限制" class="headerlink" title="22.1.2 视图的规则和限制"></a>22.1.2 视图的规则和限制</h3><ul>
<li>与表一样，视图必须唯一命名。</li>
<li>对于可创建的视图数目没有限制。</li>
<li>为了创建视图，必须具有足够的访问权限。这些限制通常有数据库管理人员授予。</li>
<li>视图可以嵌套。</li>
<li>ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY 将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或默认值。</li>
<li>视图可以和表一起使用。</li>
</ul>
<h2 id="22-2-使用视图"><a href="#22-2-使用视图" class="headerlink" title="22.2 使用视图"></a>22.2 使用视图</h2><ul>
<li>视图用CREATE VIEW语句来创建。</li>
<li>使用SHOW CREATE VIEW viewname，来查看创建视图的语句。</li>
<li>用DROP删除视图，其语法为DROP VIEW viewname。</li>
<li>更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图，如果要更新的视图存在，则第2条语句会替换原有视图。</li>
</ul>
<h3 id="22-2-1-利用视图简化复杂的联结"><a href="#22-2-1-利用视图简化复杂的联结" class="headerlink" title="22.2.1 利用视图简化复杂的联结"></a>22.2.1 利用视图简化复杂的联结</h3><ul>
<li>视图最常用的应用之一是隐藏复杂的SQL。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为productcustomers的视图，联结三个表，以返回以订购了任意产品的所有客户的列表</span><br><span class="line">CREATE VIEW productcustomers AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM customers, orders, orderitems</span><br><span class="line">WHERE customers.cust_id = orders.cust_id</span><br><span class="line">	AND orders.order_num = orderitems.order_num;</span><br><span class="line">	</span><br><span class="line"># 如果执行 SELECT * FROM productcustomers，将列出订购了任意产品的客户</span><br><span class="line"></span><br><span class="line"># 检索订购了产品TNT2的客户</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM productcustomers</span><br><span class="line">WHERE prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建可重用的视图是一种好方法。</li>
</ul>
<h3 id="22-2-2-用视图重新格式化检索出的数据"><a href="#22-2-2-用视图重新格式化检索出的数据" class="headerlink" title="22.2.2 用视图重新格式化检索出的数据"></a>22.2.2 用视图重新格式化检索出的数据</h3><ul>
<li>视图的另一常见用途是重新格式化检索出的数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 返回供应商名和位置（来自第10章）</span><br><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;)</span><br><span class="line">		AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<ul>
<li>假如要经常使用这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图 返回供应商名和位置</span><br><span class="line">CREATE VIEW vendorlocations AS</span><br><span class="line">SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;)</span><br><span class="line">		AS vend_title</span><br><span class="line">FROM vendors</span><br><span class="line">ORDER BY vend_name;</span><br><span class="line"></span><br><span class="line"># 检索所有供应商和位置的数据</span><br><span class="line">SELECT * </span><br><span class="line">FROM vendorlocations;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-3-用视图过滤不想要的数据"><a href="#22-2-3-用视图过滤不想要的数据" class="headerlink" title="22.2.3 用视图过滤不想要的数据"></a>22.2.3 用视图过滤不想要的数据</h3><ul>
<li>视图也可以使用WHERE子句过滤数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图，排除没有电子邮件地址的用户</span><br><span class="line">CREATE VIEW customeremaillist AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_email is NOT NULL;</span><br><span class="line"></span><br><span class="line"># 检索</span><br><span class="line">SELECT * </span><br><span class="line">FROM customeremaillist</span><br></pre></td></tr></table></figure>
<ul>
<li>如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</li>
</ul>
<h3 id="22-2-4-使用视图与计算字段"><a href="#22-2-4-使用视图与计算字段" class="headerlink" title="22.2.4 使用视图与计算字段"></a>22.2.4 使用视图与计算字段</h3><ul>
<li>视图对于简化计算字段的使用特别有用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 检索某个特定订单中的物品，计算每种物品的总价格（来自第10章）</span><br><span class="line">SELECT prod_id,</span><br><span class="line">		quantity,</span><br><span class="line">		item_price,</span><br><span class="line">		quantity*item_price AS expand_price</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = 20005;</span><br><span class="line"></span><br><span class="line"># 将其转化为一个视图</span><br><span class="line">CREATE VIEW orderitemsexpanded AS </span><br><span class="line">SELECT prod_id,</span><br><span class="line">		quantity,</span><br><span class="line">		item_price,</span><br><span class="line">		quantity*item_price AS expand_price</span><br><span class="line">FROM orderitems;</span><br><span class="line"></span><br><span class="line"># 检索订单20005的详细内容</span><br><span class="line">SELECT *</span><br><span class="line">FROM orderitemsexpanded</span><br><span class="line">WHERE order_num = 20005;</span><br></pre></td></tr></table></figure>
<h3 id="22-2-5-更新视图"><a href="#22-2-5-更新视图" class="headerlink" title="22.2.5 更新视图"></a>22.2.5 更新视图</h3><ul>
<li>视图的数据是否可以更新是视情况而定。</li>
<li>通常，视图是可以更新的，更新一个视图将更新其基表（视图本身没有数据）。</li>
<li>但是，并非所有视图都是可更新的，如果不能正确地确定被更新的基数据，则不允许更新。</li>
<li>如果视图定义中有以下操作，将不能更新：<ul>
<li>分组（GROUP BY 和HAVING）</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数（MIN()、COUNT()、SUM() 等）</li>
<li>DISTINCT</li>
<li>导出（计算）列</li>
</ul>
</li>
<li>视图主要用于数据检索（SELECT），很少用于更新（INSERT、UPDATE和DELETE）。</li>
</ul>
<h1 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h1><h2 id="23-1-存储过程"><a href="#23-1-存储过程" class="headerlink" title="23.1 存储过程"></a>23.1 存储过程</h2><ul>
<li>MySQL添加了对存储过程的支持，支持MySQL5及以后的版本。</li>
<li>存储过程，就是为以后的使用而保存的一条或多条MySQL语句的集合，可将其视为批文件。</li>
</ul>
<h2 id="23-2-为什么要使用存储过程"><a href="#23-2-为什么要使用存储过程" class="headerlink" title="23.2 为什么要使用存储过程"></a>23.2 为什么要使用存储过程</h2><ul>
<li>存储过程的好处：<ul>
<li>通过把处理封装在容易使用的单元中，简化复杂的操作。</li>
<li>由于不要求反复建立一系列处理步骤，保证了数据的完整性，所有开发人员和应用程序都使用同一的存储过程，则所使用的代码都是相同的。 防止错误，需要执行的步骤越多，出错的可能性就越大。</li>
<li>简化对变动的管理，如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码。通过对存储过程限制对基础数据的访问保证了安全性。</li>
<li>提高性能，使用存储过程比适用单独的SQL语句要快。</li>
<li>总结：简单，安全，高性能。</li>
</ul>
</li>
<li>存储过程的缺陷：<ul>
<li>编写比基本的SQL语句复杂。</li>
<li>MySQL将编写和执行存储过程的安全和访问区分开来，你可能没有创建存储过程的安全访问权限。</li>
<li>不能编写存储过程，但仍然可以使用。</li>
</ul>
</li>
</ul>
<h2 id="23-3-使用存储过程"><a href="#23-3-使用存储过程" class="headerlink" title="23.3 使用存储过程"></a>23.3 使用存储过程</h2><h3 id="23-3-1-执行存储过程"><a href="#23-3-1-执行存储过程" class="headerlink" title="23.3.1 执行存储过程"></a>23.3.1 执行存储过程</h3><ul>
<li>调用，CALL，接受存储过程的名字以及需要传递给它的任意参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行名为productpricing的存储过程，返回产品的最低、最高和平均价格</span><br><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">					@pricehigh,</span><br><span class="line">					@priceaverage);</span><br></pre></td></tr></table></figure>
<ul>
<li>存储过程可以显示结果，也可以不显示结果。</li>
</ul>
<h3 id="23-3-2-创建存储过程"><a href="#23-3-2-创建存储过程" class="headerlink" title="23.3.2 创建存储过程"></a>23.3.2 创建存储过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 返回平均价格的存储过程，名为productpricing，没有参数</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为存储过程的语句结束分隔符也为<code>;</code>，需要临时更改语句结束分隔符。除 \ 符号外，任何字符都可以作为语句分隔符。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 告诉命令行使用 // 作为新的语句结束分隔符</span><br><span class="line">DELIMITER //</span><br><span class="line"># 返回平均价格的存储过程，名为productpricing，没有参数</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">	FROM products;</span><br><span class="line">END//</span><br><span class="line"></span><br><span class="line"># 恢复为原来的语句结束分隔符</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 调用存储过程</span><br><span class="line">CALL productpricing();</span><br></pre></td></tr></table></figure>
<h3 id="23-3-3-删除存储过程"><a href="#23-3-3-删除存储过程" class="headerlink" title="23.3.3 删除存储过程"></a>23.3.3 删除存储过程</h3><ul>
<li>存储过程创建后，被保存在服务器上以供使用，直至被删除。</li>
<li>删除存储过程，<code>DROP PROCEDURE productpricing;</code>。存储过程名后不带()，只给出存储过程名。</li>
<li>仅当存在时删除，<code>DROP PROCEDURE IF EXISTS productpricing</code>。</li>
</ul>
<h3 id="23-3-4-使用参数"><a href="#23-3-4-使用参数" class="headerlink" title="23.3.4 使用参数"></a>23.3.4 使用参数</h3><ul>
<li>一般地，存储过程并不显示结果，而是把结果返回给你指定的变量。</li>
<li>变量，内存中一个特定的位置，用来临时存储数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 以下是productpricing的修改版本，如果不事先删除此存储过程，则不能再次创建它</span><br><span class="line"># 此存储过程接受三个参数，pl存储最低价格，ph存储最高价格，pa存储最高价格</span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">OUT pl DECIMAL(8,2),</span><br><span class="line">OUT ph DECIMAL(8,2),</span><br><span class="line">OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Min(prod_price)</span><br><span class="line">	INTO pl</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Max(prod_price)</span><br><span class="line">	INTO ph</span><br><span class="line">	FROM products;</span><br><span class="line">	SELECT Avg(prod_price)</span><br><span class="line">	INTO pa</span><br><span class="line">	FROM products;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个参数必须具有指定的类型，关键字OUT指出相应的参数用来从存储过程传出一个值，返回给调用者。</li>
<li>IN（传递给存储过程），OUT（从存储过程传出），INTO（对存储过程传入和传出）。</li>
<li>记录集是不允许的类型，不能通过一个参数返回多个行和列。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 调用此修改过的存储过程，需指定三个变量名</span><br><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">					@pricehigh,</span><br><span class="line">					@priceavgerage);</span><br><span class="line"># 调用时不现实任何数据，返回可以显示的变量，显示产品的平均价格</span><br><span class="line">SELECT @priceaverage;</span><br><span class="line"># 显示三个值</span><br><span class="line">SELECT @pricehigh, @pricelow, @priceaverage;</span><br></pre></td></tr></table></figure>
<ul>
<li>MySQL的所有变量都必须以@开始。</li>
</ul>
<ul>
<li>使用IN和OUT参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 使用IN和OUT参数，ordertotal接受订单号并返回该订单的合计</span><br><span class="line"># onumber定义为IN，订单号被传入存储过程</span><br><span class="line"># ototal定义为OUT，从存储过程返回合计</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO ototal;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"># 调用这个存储过程</span><br><span class="line"># 第一个参数为输入订单号，第二个参数为返回计算出来的合计的变量名</span><br><span class="line">CALL ordertotal(20005, @total);</span><br><span class="line"></span><br><span class="line"># 显示此合计</span><br><span class="line">SELECT @total</span><br></pre></td></tr></table></figure>
<h3 id="23-3-5-建立智能存储过程"><a href="#23-3-5-建立智能存储过程" class="headerlink" title="23.3.5 建立智能存储过程"></a>23.3.5 建立智能存储过程</h3><ul>
<li>包含业务规则和智能处理的存储过程。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># name: ordertotal</span><br><span class="line"># parameters: onumber = order number</span><br><span class="line"># 			  taxable = 0 if not taxable, 1 if taxable</span><br><span class="line"># 			  ototal = order total variable</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	IN taxable BOOLEAN,</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)COMMENT &apos;Obtain order total, optionally adding tax&apos; </span><br><span class="line"># COMMENT不是必须的，如果给出，将在SHOW PROCEDURE STATUS的结果中显示</span><br><span class="line">BEGIN</span><br><span class="line">	# Declare variable for total</span><br><span class="line">	DECLARE total DECIMAL(8,2);</span><br><span class="line">	# Declare tax percentage</span><br><span class="line">	DECLARE taxrate INT DEFAULT 6;</span><br><span class="line">	</span><br><span class="line">	# Get the order total</span><br><span class="line">	SELECT Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO total;</span><br><span class="line">	</span><br><span class="line">	# Is this taxable</span><br><span class="line">	IF taxable THEN</span><br><span class="line">		# Yes, so add taxrate to the total</span><br><span class="line">		SELECT total+(total/100*rate) INTO total</span><br><span class="line">	END IF;</span><br><span class="line">	</span><br><span class="line">	# And finaly, save to out variable</span><br><span class="line">	SELECT total INTO ototal;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"># 调用，通过给中间的参数指定0或1，可以有条件地将营业税加到合计上</span><br><span class="line">CALL ordertotal(2005, 0, @total);</span><br><span class="line">SELECT @total;</span><br><span class="line">CALL ordertotal(2005, 1, @total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure>
<h3 id="23-3-6-检查存储过程"><a href="#23-3-6-检查存储过程" class="headerlink" title="23.3.6 检查存储过程"></a>23.3.6 检查存储过程</h3><ul>
<li>显示用来创建一个存储过程，的CREATE语句。<code>SHOW CREATE PROCEDURE ordertotal</code>。</li>
<li>获得包括何时、由谁创建等详细信息的所有存储过程列表，使用<code>SHOW PROCEDURE STATUS</code>。</li>
<li>使用LIKE指定一个过滤模式，列出指定的存储过程，使用<code>SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;</code>。</li>
</ul>
<h1 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h1><h2 id="24-1-存储过程"><a href="#24-1-存储过程" class="headerlink" title="24.1 存储过程"></a>24.1 存储过程</h2><ul>
<li>版本MySQL5及之后的版本支持。</li>
<li>使用游标的原因，需要在检索出来的行中前进或后退一行或多行。</li>
<li>游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。</li>
<li>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或作出更改。</li>
<li>MySQL的游标只能用于存储过程（和函数）。</li>
</ul>
<h2 id="24-2-使用游标"><a href="#24-2-使用游标" class="headerlink" title="24.2 使用游标"></a>24.2 使用游标</h2><ul>
<li>使用前需要声明（定义）游标。</li>
<li>声明后，需要打开游标以供使用。</li>
<li>对于填有数据的游标，根据需要取出（检索）各行。</li>
<li>在结束游标使用时，必须关闭游标。</li>
</ul>
<h3 id="24-2-1-创建游标"><a href="#24-2-1-创建游标" class="headerlink" title="24.2.1 创建游标"></a>24.2.1 创建游标</h3><ul>
<li>游标用DECLARE语句创建，并定义响应的SELECT语句，根据需要带WHERE和其他子句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>存储过程处理完成后，游标就消息（因为它局限于存储过程），在定义游标之后，可以打开它。</li>
</ul>
<h3 id="24-2-2-打开和关闭游标"><a href="#24-2-2-打开和关闭游标" class="headerlink" title="24.2.2 打开和关闭游标"></a>24.2.2 打开和关闭游标</h3><ul>
<li>使用OPEN CURSOR语句打开游标。如<code>OPEN ordernumbers</code>。在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。</li>
<li>关闭游标，<code>CLOSE ordernumbers</code>。CLOSE释放游标使用的所有内部内存和资源，游标不需要时应该关闭。</li>
<li>隐含关闭，如果不明确关闭游标，将会在到达END语句时自动关闭。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	# 声明游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	# 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	# 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h3 id="24-2-3-使用游标数据"><a href="#24-2-3-使用游标数据" class="headerlink" title="24.2.3 使用游标数据"></a>24.2.3 使用游标数据</h3><ul>
<li><p>使用FETCH语句分别访问它的每一行，FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行。</p>
</li>
<li><p>从游标中检索单个行。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	# 声明游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	# 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	# 检索当前行的order_num列（自动从第一行开始）到一个名为o的局部声明的变量中。</span><br><span class="line">	FETCH ordernumbers INTO o</span><br><span class="line">	</span><br><span class="line">	# 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>循环检索数据，从第一行到最后一行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	# 声明游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	# 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	# 循环检索</span><br><span class="line">	REPEAT</span><br><span class="line">		FETCH ordernumbers INTO o;</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line">	</span><br><span class="line">	# 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>需设置变量done为真的停止条件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 定义了CONTINUE HANDLER，指出当SQLSTATE &apos;02000&apos;出现时，SET done 1,</span><br><span class="line"># SQLSTATE &apos;02000&apos;是一个未找到条件</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done = 1;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。</p>
</li>
<li><p>更详细的游标存储过程样例。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	# 定义局部变量</span><br><span class="line">	DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">	DECLARE o INT;</span><br><span class="line">	DECLARE t DECIMAL(8,2);</span><br><span class="line"></span><br><span class="line">	# 声明游标</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	</span><br><span class="line">	# 定义句柄</span><br><span class="line">	DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done = 1;</span><br><span class="line">	</span><br><span class="line">	# 创建一个表保存结果</span><br><span class="line">	CREATE TABLE IF NOT EXISTS ordertotals(</span><br><span class="line">			order_num INT,</span><br><span class="line">			total DECIMAL(8,2));</span><br><span class="line">	</span><br><span class="line">	# 打开游标</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	</span><br><span class="line">	# 循环检索</span><br><span class="line">	REPEAT</span><br><span class="line">		# 获取订单号</span><br><span class="line">		FETCH ordernumbers INTO o;</span><br><span class="line">		# 获取该订单号的带税的合计，该存储过程在前一章创建</span><br><span class="line">		CALL ordertotal(o, 1, @t);</span><br><span class="line">		# 将订单号和订单合计插入ordertotals结果表中</span><br><span class="line">		INSERT INTO ordertotals(order_num, total)</span><br><span class="line">		VALUES(o, t);</span><br><span class="line">		</span><br><span class="line">	UNTIL done END REPEAT;</span><br><span class="line">	</span><br><span class="line">	# 关闭游标</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>此存储过程不返回数据，但它能够创建和填充另一个表。查看该表，<code>SELECT * FROM ordertotals</code>。</li>
</ul>
<h1 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h1><h2 id="25-1-触发器"><a href="#25-1-触发器" class="headerlink" title="25.1 触发器"></a>25.1 触发器</h2><ul>
<li>MySQL5或之后的版本支持触发器。</li>
<li>希望某条语句（或某些语句）在事件发生时自动执行。</li>
<li>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：<ul>
<li>DELETE</li>
<li>INSERT</li>
<li>UPDATE</li>
</ul>
</li>
<li>其他MySQL语句不支持触发器。</li>
</ul>
<h2 id="25-2-创建触发器"><a href="#25-2-创建触发器" class="headerlink" title="25.2 创建触发器"></a>25.2 创建触发器</h2><ul>
<li>在创建触发器时，需要给出四条信息：<ul>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）</li>
<li>触发器何时执行（处理之前或之后）</li>
</ul>
</li>
<li><p>触发器在每个表中唯一，在数据库中的两个表可以具有相同名字的触发器。但最好在数据库范围内使用唯一的触发器名。</p>
</li>
<li><p>触发器用CREATE TRIGGER语句创建。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建名为newproduct的触发器，将在INSERT语句执行后执行</span><br><span class="line"># 指定FOR EACH ROW SELECT，对每个插入行执行</span><br><span class="line"># 本文Product added对每个插入行显示一次</span><br><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products</span><br><span class="line">FOR EACH ROW SELECT &apos;Product added&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有表才支持触发器，视图不支持（临时表也不支持）。</li>
<li>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器，每个表最多支持6个触发器（每天INSERT、UPDATE和DELETE的之前和之后）。</li>
<li>单个触发器不能与多个事件或多个表关联，如果你需要对一个INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。</li>
</ul>
<h2 id="25-3-删除触发器"><a href="#25-3-删除触发器" class="headerlink" title="25.3 删除触发器"></a>25.3 删除触发器</h2><ul>
<li>使用DROP TRIGGER 语句。如<code>DROP TRIGGER newproduct</code>。</li>
<li>触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。</li>
</ul>
<h2 id="25-4-使用触发器"><a href="#25-4-使用触发器" class="headerlink" title="25.4 使用触发器"></a>25.4 使用触发器</h2><h3 id="25-4-1-INSERT触发器"><a href="#25-4-1-INSERT触发器" class="headerlink" title="25.4.1 INSERT触发器"></a>25.4.1 INSERT触发器</h3><ul>
<li>INSERT 触发器在INSERT语句执行之前或之后执行。<ul>
<li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行。</li>
<li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）。</li>
<li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名为neworder的触发器</span><br><span class="line"># 插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中</span><br><span class="line"># 触发器从NEW.order_num取得这个值并返回它</span><br><span class="line">CREATE TRIGGER neworder AFTER INSERT ON orders</span><br><span class="line">FOR EACH ROW SELECT NEW.order_num;</span><br><span class="line"></span><br><span class="line"># 插入一个新行</span><br><span class="line"># orders包含3行，order_date和 cust_id必须给出，order_num由MySQL自动生成</span><br><span class="line">INSERT INTO order(order_date, cust_id)</span><br><span class="line">VALURES(now(), 10001)</span><br></pre></td></tr></table></figure>
<h3 id="25-4-2-DELETE触发器"><a href="#25-4-2-DELETE触发器" class="headerlink" title="25.4.2 DELETE触发器"></a>25.4.2 DELETE触发器</h3><ul>
<li>DELETE触发器在DELETE语句执行之前或之后执行。<ul>
<li>在DELETE触发器代码内，可引用一个名为OLD的虚拟表，访问被删除的行。</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 在任意订单被删除前将执行此触发器，它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到archive_orders存档表中</span><br><span class="line">CREATE TRIGGER deleteorder BEFORE DELETE ON orders</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO archive_orders(order_num, order_date, cust_id)</span><br><span class="line">	VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用BEGIN 和 END语句的好处是触发器能容纳多条SQL语句。</li>
</ul>
<h3 id="25-4-3-UPDATE触发器"><a href="#25-4-3-UPDATE触发器" class="headerlink" title="25.4.3 UPDATE触发器"></a>25.4.3 UPDATE触发器</h3><ul>
<li>UPDATE 触发器在UPDATE语句执行之前或之后执行。<ul>
<li>在UPDATE触发器代码内，可引用一个名为OLD的虚拟表访问以前的值，引用一个名为NEW的虚拟表访问被新更新的值。</li>
<li>在BEFORE UPDATE触发器中，NEW中的值也可以被更新（允许更改被插入的值）。</li>
<li>OLD中的值全都是只读的，不能更新。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 保证输入的州名是大写，不管输入是大写还是小写</span><br><span class="line">CREATE TRIGGER updatevendor BEFORE UPDATE ON vendors</span><br><span class="line">FOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state)</span><br></pre></td></tr></table></figure>
<h3 id="25-4-4-关于触发器的进一步介绍"><a href="#25-4-4-关于触发器的进一步介绍" class="headerlink" title="25.4.4 关于触发器的进一步介绍"></a>25.4.4 关于触发器的进一步介绍</h3><ul>
<li>创建触发器可能需要特殊的安全访问权限。但是触发器的执行时自动的。</li>
<li>用触发器保证数据的一致性（大小写、格式等）。</li>
<li>触发器可以创建审计跟踪，把更改记录到另一个表非常容易。</li>
<li>触发器不支持CALL语句。</li>
</ul>
<h1 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h1><h2 id="26-1-事务处理"><a href="#26-1-事务处理" class="headerlink" title="26.1 事务处理"></a>26.1 事务处理</h2><ul>
<li>MyISAM和InnoDB是两种最常使用的引擎，前者不支持明确的事务处理管理，后者支持。</li>
<li>事务处理用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。</li>
<li>利用事务管理，可以保证一组操作不会中途停止，它们作为整体执行，或者完全不执行。</li>
<li><p>如果没有发生错误，整组语句提交给数据库表，如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。</p>
</li>
<li><p>事务（transaction）：一组SQL语句。</p>
</li>
<li>回退（rollback）：撤销指定SQL语句的过程。</li>
<li>提交（commit）：将未存储的SQL语句结果写入数据库表。</li>
<li>保留点（savepoint）：事务处理中设置的临时占位符（placeholder），你可以对它发布回退。</li>
</ul>
<h2 id="26-2-控制事务处理"><a href="#26-2-控制事务处理" class="headerlink" title="26.2 控制事务处理"></a>26.2 控制事务处理</h2><ul>
<li>关键在于将SQL语句分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。</li>
<li>使用<code>START TRANSACTION</code>来标识事务的开始。</li>
</ul>
<h3 id="26-2-1-使用ROLLBACK"><a href="#26-2-1-使用ROLLBACK" class="headerlink" title="26.2.1 使用ROLLBACK"></a>26.2.1 使用ROLLBACK</h3><ul>
<li>使用ROLLBACK来回退（撤销）MySQL语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM ordertotals; # 显示表ordertotals不为空</span><br><span class="line">START TRANSACTION; # 开始一个事务处理</span><br><span class="line">DELETE FROM ordertotals; # 删除ordertotals中的所有行，注意不是删除表</span><br><span class="line">SELECT * FROM ordertotals; # 验证ordertotals确实为空</span><br><span class="line">ROLLBACK; # 回退START TRANSACTION之后的所有语句</span><br><span class="line">SELECT * FROM ordertotals; # 显示表ordertotals不为空，回退成功</span><br></pre></td></tr></table></figure>
<ul>
<li>ROLLBACK 只能在一个事务处理内使用（执行一条START TRANSACTION 命令之后）。</li>
<li>事务管理用来管理INSERT、UPDATE和DELETE语句。</li>
<li>不能回退SELECT语句、CREATE和DROP操作。</li>
</ul>
<h3 id="26-2-2-使用COMMIT"><a href="#26-2-2-使用COMMIT" class="headerlink" title="26.2.2 使用COMMIT"></a>26.2.2 使用COMMIT</h3><ul>
<li>一般的MySQL语句都是隐含提交的，即提交（写或保存）操作都是自动的。</li>
<li>但事务处理块中，提交不会隐含地进行，使用COMMIT语句进行明确的提交。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用COMMIT语句仅在不出错时写出更改</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<ul>
<li>当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。</li>
</ul>
<h3 id="26-2-3-使用保留点"><a href="#26-2-3-使用保留点" class="headerlink" title="26.2.3 使用保留点"></a>26.2.3 使用保留点</h3><ul>
<li>复杂的事务处理可能需要部分提交或回退。</li>
<li><p>为了支持回退部分事务处理，必须能在事务处理块中合适位置放置占位符，如果需要回退，可以回退到某个占位符。</p>
</li>
<li><p>创建占位符，使用SAVEPOINT，例如<code>SAVEPOINT delete1;</code>。</p>
</li>
<li>每个保留点都标识它的唯一名字。</li>
<li><p>回退到保留点，<code>ROLLBACK TO delete1;</code>。</p>
</li>
<li><p>保留点越多越好，越灵活。</p>
</li>
<li>保留点在事务处理完成后自动释放，也可以用RELEASE SAVEPOINT明确地释放保留点。</li>
</ul>
<h3 id="26-2-4-更改默认的提交行为"><a href="#26-2-4-更改默认的提交行为" class="headerlink" title="26.2.4 更改默认的提交行为"></a>26.2.4 更改默认的提交行为</h3><ul>
<li>MySQL默认自动提交所有更改。</li>
<li>为只是MySQL不自动提交更改，使用<code>SET autocommit=0;</code>。</li>
</ul>
<h1 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h1><h2 id="27-1-字符集和校对顺序"><a href="#27-1-字符集和校对顺序" class="headerlink" title="27.1 字符集和校对顺序"></a>27.1 字符集和校对顺序</h2><ul>
<li>MySQL需要适应不同的字符集，适应不同的排序和检索数据的方法。</li>
<li>字符集：字母和符号的结合。</li>
<li>编码：某个字符集成员的内部表示。</li>
<li>校对：规定字符如何比较的指令。</li>
<li>使用何种字符集合校对的决定在服务器、数据库和表级进行。</li>
</ul>
<h2 id="27-2-使用字符集和校对顺序"><a href="#27-2-使用字符集和校对顺序" class="headerlink" title="27.2 使用字符集和校对顺序"></a>27.2 使用字符集和校对顺序</h2><ul>
<li>查看所支持的字符集完整列表，<code>SHOW CHARACTER SET;</code>。</li>
<li>查看所支持校对的完整列表，<code>SHOW COLLATION</code>。</li>
<li><p>可以在安装时定义一个默认的字符集和校对，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，使用语句，<code>SHOW VARIABLES LIKE &#39;character%&#39;</code>和<code>SHOW VARIABLES LIKE &#39;collation%&#39;</code>。</p>
</li>
<li><p>给表指定字符集和校对，使用带子句的CREATE TABLE。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">column1 INT,</span><br><span class="line">column2 VARCHAR(10)</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了可以给表指定字符集和校对，还可以对每个列设置它们。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">column1 INT,</span><br><span class="line">column2 VARCHAR(10),</span><br><span class="line">column3 VARCHAR(10) CHARACTER SET latin1 </span><br><span class="line">					COLLATE latin1_general_ci;</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>
<ul>
<li>校对在用ORDER BY子句检索出来的数据排序时起重要的作用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用与创建表时不同的校对顺序排序特定的SELECT语句</span><br><span class="line">SELECT * FROM customers</span><br><span class="line">ORDER BY lastname, firstname COLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>
<h1 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h1><h2 id="28-1访问控制"><a href="#28-1访问控制" class="headerlink" title="28.1访问控制"></a>28.1访问控制</h2><ul>
<li>安全基础：用户应该对他们需要的数据具有恰当的访问权，既不能多也不能少。用户不能对过多的数据具有过多的访问权。</li>
<li>访问控制：给用户提供他们所需的访问权，且仅提供他们所需的访问权。</li>
<li>不要在日常操作中使用root。</li>
</ul>
<h2 id="28-2-管理用户"><a href="#28-2-管理用户" class="headerlink" title="28.2 管理用户"></a>28.2 管理用户</h2><ul>
<li>获取所有用户账户列表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># mysql数据库有一个名为user的表，它包含所有用户账号</span><br><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;</span><br></pre></td></tr></table></figure>
<h3 id="28-2-1-创建用户账户"><a href="#28-2-1-创建用户账户" class="headerlink" title="28.2.1 创建用户账户"></a>28.2.1 创建用户账户</h3><ul>
<li>创建新用户。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新用户，用户名ben，口令p@$$word</span><br><span class="line">CREATE USER ben IDENTIFIED BY &apos;p@$$word&apos;;</span><br></pre></td></tr></table></figure>
<ul>
<li>IDENTIFIED BY为纯文本口令，为了作为散列指定加密口令，使用IDENTIFIED BY PASSWORD。</li>
<li>重命名用户名。使用<code>RENAME USER ben TO bforta;</code>。</li>
</ul>
<h3 id="28-2-2-删除用户账户"><a href="#28-2-2-删除用户账户" class="headerlink" title="28.2.2 删除用户账户"></a>28.2.2 删除用户账户</h3><ul>
<li>使用DROP USER语句，如<code>DROP USER bforta;</code>。</li>
</ul>
<h3 id="28-2-3-设置访问权限"><a href="#28-2-3-设置访问权限" class="headerlink" title="28.2.3 设置访问权限"></a>28.2.3 设置访问权限</h3><ul>
<li>新创建的用户没有访问权限。</li>
<li><p>查看赋予用户的权限，<code>SHOW GRANTS FOR bforta;</code>。</p>
</li>
<li><p>用户定义为user@host。默认主机名为%。</p>
</li>
<li>为设置权限，使用GRANT语句，需给出以下信息：<ul>
<li>要授予的权限。</li>
<li>被授予访问权限的数据库或表。</li>
<li>用户名。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECT</span><br><span class="line">GRANT SELECT ON crashcourse.* TO bforta;</span><br><span class="line"></span><br><span class="line"># 查看添加的权限</span><br><span class="line">SHOW GRANTS FOR bforta;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>撤销特定的全效，使用REVOKE语句。<code>REVOKE SELECT ON crashcourse.* FROM bforta;</code>，撤销了bforta的SELECT访问权限。</p>
</li>
<li><p>GRANT 和REVOKE可在几个层次上控制访问权限。</p>
<ul>
<li>整个服务器，使用GRANT ALL 和 REVOKE ALL。</li>
<li>整个数据库，使用ON database.*。</li>
<li>特定的表，使用ON database.table。</li>
<li>特定的列。</li>
<li>特定的存储过程。</li>
</ul>
</li>
</ul>
<h3 id="28-2-4-更改口令"><a href="#28-2-4-更改口令" class="headerlink" title="28.2.4 更改口令"></a>28.2.4 更改口令</h3><ul>
<li>使用SET PASSWORD，新口令必须使用Password加密：<code>SET PASSWORD FOR bforta = Password(&#39;n3w p@$$word&#39;)</code>。</li>
<li>设置自己的口令：<code>SET PASSWORD = Password(&#39;n3w p@$$word&#39;)</code>。</li>
</ul>
<h1 id="第29章-数据库维护"><a href="#第29章-数据库维护" class="headerlink" title="第29章 数据库维护"></a>第29章 数据库维护</h1><h2 id="29-1-备份数据"><a href="#29-1-备份数据" class="headerlink" title="29.1 备份数据"></a>29.1 备份数据</h2><ul>
<li>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。</li>
<li>可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据。</li>
<li>可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。</li>
</ul>
<h2 id="29-2-进行数据库维护"><a href="#29-2-进行数据库维护" class="headerlink" title="29.2 进行数据库维护"></a>29.2 进行数据库维护</h2><ul>
<li>ANALYZE TABLE，用来检查表键是否正确。</li>
<li>CHECK TABLE，用来针对许多问题对表进行检查。</li>
</ul>
<h2 id="29-3-诊断启动问题"><a href="#29-3-诊断启动问题" class="headerlink" title="29.3 诊断启动问题"></a>29.3 诊断启动问题</h2><ul>
<li>服务器启动问题通常在对MySQL匹配或服务器本身进行更改时出现。</li>
<li>排除系统启动问题时，首先应该尽量用手动启动服务器。</li>
<li>mysql命令行选项。<ul>
<li>—help显示帮助。</li>
<li>—safe -mode装载减去某些最佳配置的服务器。</li>
<li>—verbose显示全文本信息。</li>
<li>—version显示版本信息。</li>
</ul>
</li>
</ul>
<h2 id="29-4-查看日志文件"><a href="#29-4-查看日志文件" class="headerlink" title="29.4 查看日志文件"></a>29.4 查看日志文件</h2><ul>
<li>错误日志。—log-error</li>
<li>查询日志。—log</li>
<li>二进制日志。—log- bin</li>
<li>缓慢查询日志。—log-slow-queries</li>
</ul>
<h1 id="第30章-改善性能"><a href="#第30章-改善性能" class="headerlink" title="第30章 改善性能"></a>第30章 改善性能</h1><h2 id="30-1-改善性能"><a href="#30-1-改善性能" class="headerlink" title="30.1 改善性能"></a>30.1 改善性能</h2><ul>
<li>运行在专用服务器上。</li>
<li>调整内存分配、缓冲区大小。</li>
<li>显示所有活动进程，KILL命令终结某个特定的进程。</li>
<li>使用联结、并、子查询等方法编写SELECT语句。</li>
<li>使用存储过程。</li>
<li>使用正确的数据类型。</li>
<li>不要检索比需求还要多的数据，尽量不要用SELECT *。</li>
<li>使用DELAYED关键字。</li>
<li>导入数据时，应该关闭自动提交。</li>
<li>索引数据库表以改善数据检索的性能。</li>
<li>使用多条SELECT语句和联结它们的UNION语句来替代一系列复杂的OR语句。</li>
<li>LIKE很慢，最好使用FULLTEXT。</li>
<li>每条规则在某些条件下都会被打破。</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Qiancun Huang WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Qiancun Huang Alipay">
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Qiancun Huang
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://huangqiancun.github.io/2019/06/29/StudyNotes-MySQL必知必会/" title="StudyNotes-MySQL必知必会">http://huangqiancun.github.io/2019/06/29/StudyNotes-MySQL必知必会/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/SQL/" rel="tag"># SQL</a>
          
            <a href="/tags/StudyNotes/" rel="tag"># StudyNotes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/20/数据结构-赫夫曼树及赫夫曼编码/" rel="next" title="数据结构-赫夫曼树及赫夫曼编码">
                <i class="fa fa-chevron-left"></i> 数据结构-赫夫曼树及赫夫曼编码
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/10/数据库SQL实战题解/" rel="prev" title="数据库SQL实战题解">
                数据库SQL实战题解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
	
	
  
  
  
  </article>
  <div>
		
			<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------------The End------------</div>
    
</div>
		
	</div>
	
 


    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/photo.jpg" alt="Qiancun Huang">
            
              <p class="site-author-name" itemprop="name">Qiancun Huang</p>
              <p class="site-description motion-element" itemprop="description">A second-year graduate student in Southeast University</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/huangqiancun?tab=repositories" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto://huangqiancun@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-了解SQL"><span class="nav-text">第1章 了解SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-数据库基础"><span class="nav-text">1.1 数据库基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-什么是数据库"><span class="nav-text">1.1.1 什么是数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-表"><span class="nav-text">1.1.2 表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-列和数据类型"><span class="nav-text">1.1.3 列和数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-行"><span class="nav-text">1.1.4 行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-主键"><span class="nav-text">1.1.5  主键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-什么是SQL"><span class="nav-text">1.2 什么是SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-动手实践"><span class="nav-text">1.3 动手实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#B-1-样例表-随身物品推销商使用的订单录入系统"><span class="nav-text">B.1 样例表 - 随身物品推销商使用的订单录入系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表的描述"><span class="nav-text">表的描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-2-创建样例表"><span class="nav-text">B.2 创建样例表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-MySQL简介"><span class="nav-text">第2章 MySQL简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-什么是MySQL"><span class="nav-text">2.1 什么是MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-客户机-服务器软件"><span class="nav-text">2.1.1 客户机-服务器软件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-MySQL版本"><span class="nav-text">2.1.2 MySQL版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-MySQL工具"><span class="nav-text">2.2 MySQL工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-mysql命令行使用程序"><span class="nav-text">2.2.1 mysql命令行使用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-MySQL-Administrator"><span class="nav-text">2.2.2 MySQL Administrator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-MySQL-Query-Browser"><span class="nav-text">2.2.3 MySQL Query Browser</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-使用MySQL"><span class="nav-text">第3章 使用MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-连接"><span class="nav-text">3.1 连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-选择数据库"><span class="nav-text">3.2 选择数据库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-了解数据库和表"><span class="nav-text">3.3 了解数据库和表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-检索数据"><span class="nav-text">第4章 检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-SELECT语句"><span class="nav-text">4.1 SELECT语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-检索单个列"><span class="nav-text">4.2 检索单个列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-检索多个列"><span class="nav-text">4.3 检索多个列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-检索所有列"><span class="nav-text">4.4 检索所有列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-检索不同的行"><span class="nav-text">4.5 检索不同的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-限制结果"><span class="nav-text">4.6 限制结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-使用完全限定的表名"><span class="nav-text">4.7 使用完全限定的表名</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-排序检索数据"><span class="nav-text">第5章 排序检索数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-排序数据"><span class="nav-text">5.1 排序数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-按多个列排序"><span class="nav-text">5.2 按多个列排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-指定排序方向"><span class="nav-text">5.3 指定排序方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-过滤数据"><span class="nav-text">第6章 过滤数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-使用WHERE子句"><span class="nav-text">6.1 使用WHERE子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-WHERE子句操作符"><span class="nav-text">6.2 WHERE子句操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-检查单个值"><span class="nav-text">6.2.1 检查单个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-不匹配检查"><span class="nav-text">6.2.2 不匹配检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-范围值检查"><span class="nav-text">6.2.3 范围值检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-空值检查"><span class="nav-text">6.2.4 空值检查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第7章-数据过滤"><span class="nav-text">第7章 数据过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-组合WHERE子句"><span class="nav-text">7.1 组合WHERE子句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-AND操作符"><span class="nav-text">7.1.1 AND操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-OR操作符"><span class="nav-text">7.1.2 OR操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-计算次序"><span class="nav-text">7.1.3 计算次序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-IN操作符"><span class="nav-text">7.2 IN操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-NOT操作符"><span class="nav-text">7.3 NOT操作符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第8章-用通配符进行过滤"><span class="nav-text">第8章 用通配符进行过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-LIKE操作符"><span class="nav-text">8.1 LIKE操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-百分号（-）通配符"><span class="nav-text">8.1.1 百分号（%）通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-下划线（-）通配符"><span class="nav-text">8.1.2 下划线（_）通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-使用通配符的技巧"><span class="nav-text">8.2 使用通配符的技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第9章-用正则表达式进行搜索"><span class="nav-text">第9章 用正则表达式进行搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-正则表达式介绍"><span class="nav-text">9.1 正则表达式介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-使用MySQL正则表达式"><span class="nav-text">9.2 使用MySQL正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-基本字符匹配"><span class="nav-text">9.2.1 基本字符匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-进行OR匹配"><span class="nav-text">9.2.2 进行OR匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-3-匹配几个字符之一"><span class="nav-text">9.2.3 匹配几个字符之一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-4-匹配范围"><span class="nav-text">9.2.4 匹配范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-5-匹配特殊字符"><span class="nav-text">9.2.5 匹配特殊字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-6-匹配字符类"><span class="nav-text">9.2.6 匹配字符类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-7-匹配多个实例"><span class="nav-text">9.2.7 匹配多个实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-8-定位符"><span class="nav-text">9.2.8 定位符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第10章-创建计算字段"><span class="nav-text">第10章 创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-计算字段"><span class="nav-text">10.1 计算字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-拼接字段"><span class="nav-text">10.2 拼接字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-执行算术计算"><span class="nav-text">10.3 执行算术计算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第11章-使用数据处理函数"><span class="nav-text">第11章 使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-函数"><span class="nav-text">11.1 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-使用函数"><span class="nav-text">11.2 使用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-文本处理函数"><span class="nav-text">11.2.1 文本处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-日期和时间处理函数"><span class="nav-text">11.2.2 日期和时间处理函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-3-数值处理函数"><span class="nav-text">11.2.3 数值处理函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第12章-汇总数据"><span class="nav-text">第12章 汇总数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-聚集函数"><span class="nav-text">12.1 聚集函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-1-AVG-函数"><span class="nav-text">12.1.1 AVG()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-2-COUNT-函数"><span class="nav-text">12.1.2 COUNT()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-3-MAX-函数"><span class="nav-text">12.1.3 MAX()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-4-MIN-函数"><span class="nav-text">12.1.4 MIN()函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-5-SUM-函数"><span class="nav-text">12.1.5 SUM()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-聚焦不同值"><span class="nav-text">12.2 聚焦不同值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-组合函数"><span class="nav-text">12.3 组合函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第13章-分组数据"><span class="nav-text">第13章 分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-数据分组"><span class="nav-text">13.1 数据分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-创建分组"><span class="nav-text">13.2 创建分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-过滤分组"><span class="nav-text">13.3 过滤分组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-分组和排序"><span class="nav-text">13.4 分组和排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-SELECT子句顺序"><span class="nav-text">13.5 SELECT子句顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第14章-使用子查询"><span class="nav-text">第14章 使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-子查询"><span class="nav-text">14.1 子查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-利用子查询进行过滤"><span class="nav-text">14.2 利用子查询进行过滤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-作为计算字段使用子查询"><span class="nav-text">14.3 作为计算字段使用子查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第15章-联结表"><span class="nav-text">第15章 联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-联结"><span class="nav-text">15.1 联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-1-关系表"><span class="nav-text">15.1.1 关系表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-2-为什么要使用联结"><span class="nav-text">15.1.2 为什么要使用联结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-创建联结"><span class="nav-text">15.2 创建联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-1-WHERE子句的重要性"><span class="nav-text">15.2.1 WHERE子句的重要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-2-内部联结"><span class="nav-text">15.2.2 内部联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-3-联结多个表"><span class="nav-text">15.2.3 联结多个表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第16章-创建高级联结"><span class="nav-text">第16章 创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-创建高级联结"><span class="nav-text">16.1 创建高级联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-使用不同类型的联结"><span class="nav-text">16.2 使用不同类型的联结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-1-自联结"><span class="nav-text">16.2.1 自联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-2-自然联结"><span class="nav-text">16.2.2 自然联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-3-外部联结"><span class="nav-text">16.2.3 外部联结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-3-使用带聚集函数的联结"><span class="nav-text">16.3 使用带聚集函数的联结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-使用联结和联结条件"><span class="nav-text">16.4 使用联结和联结条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第17章-组合查询"><span class="nav-text">第17章 组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#17-1-组合查询"><span class="nav-text">17.1 组合查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-2-创建组合查询"><span class="nav-text">17.2 创建组合查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-1-使用UNION"><span class="nav-text">17.2.1 使用UNION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-2-UNION规则"><span class="nav-text">17.2.2 UNION规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-3-包含或取消重复的行"><span class="nav-text">17.2.3 包含或取消重复的行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-4-对组合结果排序"><span class="nav-text">17.2.4 对组合结果排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第18章-全文本搜索"><span class="nav-text">第18章 全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#18-1-理解全文本搜索"><span class="nav-text">18.1 理解全文本搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-2-使用全文本搜索"><span class="nav-text">18.2 使用全文本搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-1-启用全文本搜索支持"><span class="nav-text">18.2.1 启用全文本搜索支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-2-进行全文本搜索"><span class="nav-text">18.2.2 进行全文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-3-使用查询扩展"><span class="nav-text">18.2.3 使用查询扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-4-布尔文本搜索"><span class="nav-text">18.2.4 布尔文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-5-全文本搜索的使用说明"><span class="nav-text">18.2.5 全文本搜索的使用说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第19章-插入数据"><span class="nav-text">第19章 插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#19-1-数据插入"><span class="nav-text">19.1 数据插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-2-插入完整的行"><span class="nav-text">19.2 插入完整的行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-3-插入多个行"><span class="nav-text">19.3 插入多个行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-4-插入检索出的数据"><span class="nav-text">19.4 插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第20章-更新和删除数据"><span class="nav-text">第20章 更新和删除数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#20-1-更新数据"><span class="nav-text">20.1 更新数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-2-删除数据"><span class="nav-text">20.2 删除数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-3-更新和删除的指导原则"><span class="nav-text">20.3 更新和删除的指导原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第21章-创建和操纵表"><span class="nav-text">第21章 创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-1-创建表"><span class="nav-text">21.1 创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-1-表创建基础"><span class="nav-text">21.1.1 表创建基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-2-使用NULL值"><span class="nav-text">21.1.2 使用NULL值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-3-主键再介绍"><span class="nav-text">21.1.3 主键再介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-4-使用AUTO-INCREMENT"><span class="nav-text">21.1.4 使用AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-5-指定默认值"><span class="nav-text">21.1.5 指定默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1-6-引擎类型"><span class="nav-text">21.1.6 引擎类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-2-更新表"><span class="nav-text">21.2 更新表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-3-删除表"><span class="nav-text">21.3 删除表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-4-重命名表"><span class="nav-text">21.4 重命名表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第22章-使用视图"><span class="nav-text">第22章 使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#22-1-视图"><span class="nav-text">22.1 视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#22-1-1-为什么使用视图"><span class="nav-text">22.1.1 为什么使用视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-1-2-视图的规则和限制"><span class="nav-text">22.1.2 视图的规则和限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-2-使用视图"><span class="nav-text">22.2 使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-1-利用视图简化复杂的联结"><span class="nav-text">22.2.1 利用视图简化复杂的联结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-2-用视图重新格式化检索出的数据"><span class="nav-text">22.2.2 用视图重新格式化检索出的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-3-用视图过滤不想要的数据"><span class="nav-text">22.2.3 用视图过滤不想要的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-4-使用视图与计算字段"><span class="nav-text">22.2.4 使用视图与计算字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-2-5-更新视图"><span class="nav-text">22.2.5 更新视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第23章-使用存储过程"><span class="nav-text">第23章 使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#23-1-存储过程"><span class="nav-text">23.1 存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-2-为什么要使用存储过程"><span class="nav-text">23.2 为什么要使用存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-3-使用存储过程"><span class="nav-text">23.3 使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-1-执行存储过程"><span class="nav-text">23.3.1 执行存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-2-创建存储过程"><span class="nav-text">23.3.2 创建存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-3-删除存储过程"><span class="nav-text">23.3.3 删除存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-4-使用参数"><span class="nav-text">23.3.4 使用参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-5-建立智能存储过程"><span class="nav-text">23.3.5 建立智能存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-3-6-检查存储过程"><span class="nav-text">23.3.6 检查存储过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第24章-使用游标"><span class="nav-text">第24章 使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#24-1-存储过程"><span class="nav-text">24.1 存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-2-使用游标"><span class="nav-text">24.2 使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#24-2-1-创建游标"><span class="nav-text">24.2.1 创建游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-2-2-打开和关闭游标"><span class="nav-text">24.2.2 打开和关闭游标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-2-3-使用游标数据"><span class="nav-text">24.2.3 使用游标数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第25章-使用触发器"><span class="nav-text">第25章 使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#25-1-触发器"><span class="nav-text">25.1 触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-2-创建触发器"><span class="nav-text">25.2 创建触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-3-删除触发器"><span class="nav-text">25.3 删除触发器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-4-使用触发器"><span class="nav-text">25.4 使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4-1-INSERT触发器"><span class="nav-text">25.4.1 INSERT触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4-2-DELETE触发器"><span class="nav-text">25.4.2 DELETE触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4-3-UPDATE触发器"><span class="nav-text">25.4.3 UPDATE触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-4-4-关于触发器的进一步介绍"><span class="nav-text">25.4.4 关于触发器的进一步介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第26章-管理事务处理"><span class="nav-text">第26章 管理事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#26-1-事务处理"><span class="nav-text">26.1 事务处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-控制事务处理"><span class="nav-text">26.2 控制事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2-1-使用ROLLBACK"><span class="nav-text">26.2.1 使用ROLLBACK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2-2-使用COMMIT"><span class="nav-text">26.2.2 使用COMMIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2-3-使用保留点"><span class="nav-text">26.2.3 使用保留点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-2-4-更改默认的提交行为"><span class="nav-text">26.2.4 更改默认的提交行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第27章-全球化和本地化"><span class="nav-text">第27章 全球化和本地化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#27-1-字符集和校对顺序"><span class="nav-text">27.1 字符集和校对顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-2-使用字符集和校对顺序"><span class="nav-text">27.2 使用字符集和校对顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第28章-安全管理"><span class="nav-text">第28章 安全管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#28-1访问控制"><span class="nav-text">28.1访问控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-2-管理用户"><span class="nav-text">28.2 管理用户</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#28-2-1-创建用户账户"><span class="nav-text">28.2.1 创建用户账户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-2-2-删除用户账户"><span class="nav-text">28.2.2 删除用户账户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-2-3-设置访问权限"><span class="nav-text">28.2.3 设置访问权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-2-4-更改口令"><span class="nav-text">28.2.4 更改口令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第29章-数据库维护"><span class="nav-text">第29章 数据库维护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#29-1-备份数据"><span class="nav-text">29.1 备份数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-2-进行数据库维护"><span class="nav-text">29.2 进行数据库维护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-3-诊断启动问题"><span class="nav-text">29.3 诊断启动问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-4-查看日志文件"><span class="nav-text">29.4 查看日志文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第30章-改善性能"><span class="nav-text">第30章 改善性能</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#30-1-改善性能"><span class="nav-text">30.1 改善性能</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiancun Huang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">491.3k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


</body>
</html>
