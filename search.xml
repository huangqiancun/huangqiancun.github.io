<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是字符串相关题目题解总结。 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑’*’： 如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符’‘考虑进去，它可以匹配任意次的字符，当然出现0次也可以： 而当模式中的第二个字符是时： 如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 1. 模式后移2字符，相当于x*被忽略； 2. 字符串后移1字符，模式后移2字符，正好匹配x*中的&apos;x&apos;位； 3. 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&apos;*&apos;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符&apos;.&apos;的情况。 1. 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为&apos;.&apos;的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 2. 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1.1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = left+(right-left)//2 if data[mid] == k: temp = 0 for i in range(left, right+1): if data[i] == k: temp += 1 return temp elif data[mid] &lt; k: left += 1 else: right -= 1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 0: return False Dict = &#123;&#125; for i in range(len(numbers)): if numbers[i] not in Dict: Dict[numbers[i]] = 1 else: Dict[numbers[i]] += 1 if Dict[numbers[i]] == 2: duplication[0] = numbers[i] return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1–&gt;0k+2–&gt;1n-1 –&gt; n-k-20 – &gt; n-k-1 k-1 –&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # 思路1 # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res # 思路2 res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) –&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
