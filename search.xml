<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[GitNotes]]></title>
    <url>%2F2019%2F12%2F25%2FStudyNotes%2FGitNotes%2F</url>
    <content type="text"><![CDATA[本地库初始化 git init 设置签名 作用：区分不同开发人员的身份。与登录远程库的账号密码没有关系 项目级别/仓库级别：仅在当前本地库范围内有效 123git config user.name xxxgit config user.email xxx@xxx.com信息保存位置：././git/config文件 系统用户级别：登录当前操作系统的用户范围 123git config --global username xxxgit config --global useremail xxx@xxx.com信息保存位置：~/.gitconfig 文件 - 级别优先级： 123就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名如果只有系统用户级别的签名，就以系统用户级别的签名为准二者至少有一个 基本操作 状态查看git status查看工作区、暂存区状态 添加git add [filename] 将工作区的“新建/修改”添加到暂存区 提交 git commit -m “commit message” 将暂存区内容提交到本地库 查看历史记录 1、git log 2、git log —pretty=oneline 3、git log —oneline 4、git reflog 版本前进后退 1、基于索引值操作 git reset —hard [局部索引值] 如 git reset — hard a6ace91 2、使用^符号：只能后退 git reset —hard HEAD^ 注：一个^表示后退一步，n个表示后退n步 3、使用~符号：只能后退 git reset —hard HEAD~n 注：表示后退n步 4、reset命令的三个参数对比 —soft参数：仅在本地库移动HEAD指针 —mixed参数：在本地库移动HEAD指针，重置暂存区 —hard参数：在本地库移动HEAD指针，重置暂存区，重置工作区 删除文件并找回 前提：删除前，文件 存在时的状态提交到了本地库 操作：git reset —hard [指针位置] 删除操作已经提交到本地库：指针位置指向历史纪录 删除操作尚未提交到本地库：指针位置使用HEAD 比较文件差异 git diff [文件名] 将工作区的文件和暂存区进行比较 git diff [本地库中的历史版本] [文件名] 将工作区中的文件和本地库历史记录比较 不带文件名时，比较多个文件 分支管理 分支的好处 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响，失败的分支重新开始即可 创建分支 git branch [分支名] 查看分支 git branch -v 切换分支 git checkout [分支名] 合并分支 第一步：切换到接受修改的分支上：git checkout [分支名] 第二步：执行merge命令：git merge [有新内容的分支名] 第三步：解决冲突（可选） 解决冲突 第一步：编辑文件，删除特殊符号 第二步：修改文件，保存退出 第二步：git add [文件名] 第三步：git commit -m “日志消息” （此时commit不带具体文件名） Git基本原理 哈希算法是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点： 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 哈希算法确定，输入数据确定，输出数据能够保证不变 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 哈希算法不可逆 Git底层采用的是SHA-1算法（哈希算法的一种） GitHub 创建远程库地址别名 git remote add [别名] [远程地址] 查看当前所有远程地址别名 git remote -v 推送 git push [别名] [分支名] 克隆 git clone [远程地址] 效果： 完整的把远程库下载到本地 创建origin 远程地址别名 初始化本地库 拉取 pull = fetch+merge git fetch [远程地址别名] [远程分支名] git merge [远程地址别名/远程分支名] git pull [远程地址别名] [远程分支名] 解决冲突 如果不是基于远程库的最新版所做的修改，不能推送，必须先拉取 拉取下来后如果进入冲突状态，则按照“解决冲突”操作即可 跨团队协作 第一步：Fork 第二步：本地修改，然后推送到远程 第三步：Pull Request 第四步：审核代码 第五步：合并代码 第六步：将远程库拉取到本地]]></content>
      <categories>
        <category>StudyNotes</category>
      </categories>
      <tags>
        <tag>StudyNotes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode第167场周赛]]></title>
    <url>%2F2019%2F12%2F16%2FLeetCodeContest%2FLeetCode%E7%AC%AC167%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[本文是leetcode contest 107的题解，包括：12341290.二进制链表转整数（简单）1291. 顺次数 （中等）1283.使结果不超过阈值的最小除数 （中等）1284.转化为全零矩阵的最少反转次数（困难） AC1290和1292两题。 1290. 二进制链表转整数题目描述给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1：123输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5) 示例 2：12输入：head = [0]输出：0 示例 3：12输入：head = [1]输出：1 示例 4：12输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]输出：18880 示例 5：12输入：head = [0,0]输出：0 提示：123链表不为空。链表的结点总数不超过 30。每个结点的值不是 0 就是 1。 解题思路复杂度：O(30) 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int getDecimalValue(ListNode head) &#123; int res = 0; while (head != null)&#123; res = res * 2 + head.val; head = head.next; &#125; return res; &#125;&#125; 1291. 顺次数题目描述我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。 请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。 示例 1：12输出：low = 100, high = 300输出：[123,234] 示例 2：12输出：low = 1000, high = 13000输出：[1234,2345,3456,4567,5678,6789,12345] 提示：110 &lt;= low &lt;= high &lt;= 10^9 解题思路枚举所有的顺次数，如果符合条件则加入结果列表中，最后排序。 12345678910111213141516171819202122import java.util.ArrayList;import java.util.Collections;import java.util.List;class Solution &#123; public List&lt;Integer&gt; sequentialDigits(int low, int high) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 9; i++)&#123; int val = 0; for (int j = i; j &lt;= 9; j++)&#123; val = val *10 + j; if (low &lt;=val &amp;&amp; val &lt;= high)&#123; res.add(val); &#125; &#125; &#125; Collections.sort(res); return res; &#125;&#125; 1292. 元素和小于等于阈值的正方形的最大边长题目描述 给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。 请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。 示例 1： 123输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4输出：2解释：总和小于 4 的正方形的最大边长为 2，如图所示。 示例 2：12输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1输出：0 示例 3：12输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6输出：3 示例 4：12输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184输出：2 提示：123451 &lt;= m, n &lt;= 300m == mat.lengthn == mat[i].length0 &lt;= mat[i][j] &lt;= 100000 &lt;= threshold &lt;= 10^5 解题思路维护二维前缀和（304题），，然后枚举正方形子矩阵的起点和变长，然后用二维子矩阵的和与threshold比较，如果满足就更新答案。复杂度：O(n*m*min(n,m)) 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int maxSideLength(int[][] mat, int threshold) &#123; int m = mat.length, n = mat[0].length; int[][] dp = new int[m+1][n+1]; for (int i = 1; i &lt;= m; i++)&#123; for (int j = 1; j &lt;= n; j++)&#123; dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]; &#125; &#125; int res = 0; for (int i = 0; i &lt;= m; i++)&#123; for (int j = 0; j &lt;= n; j++) &#123; int index = 1; while (i+index &lt;= m &amp;&amp; j+index &lt;= n)&#123; int sum = dp[i+index][j+index] - dp[i+index][j] - dp[i][j+index] + dp[i][j]; if (sum &lt;= threshold)&#123; res = Math.max(res, index); &#125; index ++; &#125; &#125; &#125; return res; &#125;&#125; 1293. 网格中的最短路径题目描述给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。 如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。 示例 1：123456789101112输入： grid = [[0,0,0], [1,1,0], [0,0,0], [0,1,1], [0,0,0]], k = 1输出：6解释：不消除任何障碍的最短路径是 10。消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2). 示例 2：123456789输入：grid = [[0,1,1], [1,1,1], [1,0,0]], k = 1输出：-1解释：我们至少需要消除两个障碍才能找到这样的路径。 提示：123456grid.length == mgrid[0].length == n1 &lt;= m, n &lt;= 401 &lt;= k &lt;= m*ngrid[i][j] == 0 or 1grid[0][0] == grid[m-1][n-1] == 0 解题思路BFS暴力搜索。 搜索的过程中携带三个状态 (x, y, cost)，(x, y) 代表点的位置，cost 代表这个点已经花费的消除次数。 dp[x][y][cost]：记录到达 (x, y) 且花费消除次数为 cost 的情况是否存在。如果存在这个情况或者cost&gt;k则忽略当前点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayDeque;import java.util.Queue;class Solution &#123; class Node &#123; private int x; private int y; private int cost; private int step; public Node(int x, int y, int cost, int step) &#123; this.x = x; this.y = y; this.cost = cost; this.step = step; &#125; &#125; public int shortestPath(int[][] grid, int k) &#123; int m = grid.length, n = grid[0].length; boolean[][][] dp = new boolean[m][n][k + 1]; int[][] dirs = new int[][]&#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(new Node(0, 0, 0, 0)); while (!queue.isEmpty()) &#123; Node node = queue.poll(); if (node.x == m - 1 &amp;&amp; node.y == n - 1) &#123; return node.step; &#125; for (int[] dir : dirs) &#123; int x = node.x + dir[0], y = node.y + dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n) &#123; int cost = node.cost + grid[x][y]; if (cost &gt; k || dp[x][y][cost]) continue; dp[x][y][cost] = true; queue.offer(new Node(x, y, cost, node.step + 1)); &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode第166场周赛]]></title>
    <url>%2F2019%2F12%2F08%2FLeetCodeContest%2FLeetCode%E7%AC%AC166%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[本文是leetcode contest 106的题解，包括：12341281.整数的各位积和之差（简单）1282.用户分组 （中等）1283.使结果不超过阈值的最小除数 （中等）1284.转化为全零矩阵的最少反转次数（困难） 第一次打比赛，AC前三题，全国248 / 1675，全球1289 / 5585。 1281. 整数的各位积和之差题目描述给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1：123456输入：n = 234输出：15 解释：各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2：123456输入：n = 4421输出：21解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示：11 &lt;= n &lt;= 10^5 解题思路123456789101112class Solution &#123; public int subtractProductAndSum(int n) &#123; int mut = 1, sum = 0; while (n &gt; 0)&#123; int temp = n % 10; mut *= temp; sum += temp; n /= 10; &#125; return mut - sum; &#125;&#125; 1282. 用户分组题目描述有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。 你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。 示例 1：1234输入：groupSizes = [3,3,3,3,3,1,3]输出：[[5],[0,1,2],[3,4,6]]解释： 其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 示例 2：12输入：groupSizes = [2,1,3,3,3,2]输出：[[1],[0,5],[2,3,4]] 提示：123groupSizes.length == n1 &lt;= n &lt;= 5001 &lt;= groupSizes[i] &lt;= n 解题思路12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; groupThePeople(int[] groupSizes) &#123; // 将原数据转化为map，key为分组长度，value为索引 Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; groupSizes.length; i++)&#123; if (!map.containsKey(groupSizes[i]))&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(i); map.put(groupSizes[i], temp); &#125;else&#123; map.get(groupSizes[i]).add(i); &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 将map中数据按照长度拆分存入res for (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry:map.entrySet())&#123; if (entry.getKey() == entry.getValue().size())&#123; res.add(entry.getValue()); &#125;else&#123; for (int i = 0; i &lt; entry.getValue().size(); i += entry.getKey())&#123; List&lt;Integer&gt; temp = entry.getValue().subList(i, i+entry.getKey()); res.add(temp); &#125; &#125; &#125; return res; &#125;&#125; 1283. 使结果不超过阈值的最小除数题目描述给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。 请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。 示例 1：1234输入：nums = [1,2,5,9], threshold = 6输出：5解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。 示例 2：12输入：nums = [2,3,5,7,11], threshold = 11输出：3 示例 3：12输入：nums = [19], threshold = 5输出：4 提示：1231 &lt;= nums.length &lt;= 5 * 10^41 &lt;= nums[i] &lt;= 10^6nums.length &lt;= threshold &lt;= 10^6 解题思路除数越大，除法结果和越小。 使用二分，除数范围为1~ max(nums)。因为提示中nums有界，为了少一轮遍历求数组最大值，可直接将上界取为10^6+1。 如果这个除法结果和大于阀值， 说明除数mid取的太小了，我们在[mid+1, right]中继续查找 如果这个除法结果和小于等于阀值，说明除数mid或者取得太大，或者满足要求，我们在[left,mid]中继续查找。 注意在2的情形下，mid可能是我们所要求的解，不应被剔除在搜索区间之外。 1234567891011121314151617181920class Solution &#123; public int smallestDivisor(int[] nums, int threshold) &#123; int left = 1, right = 1000000+1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int sum = 0; for (int num : nums) &#123; //向上取整 sum += num / mid + ((num % mid == 0) ? 0 : 1); &#125; if (sum &gt; threshold) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right; &#125;&#125; 1284. 转化为全零矩阵的最少反转次数题目描述给你一个 m x n 的二进制矩阵 mat。 每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。（注：相邻的两个单元格共享同一条边。） 请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。 二进制矩阵的每一个格子要么是 0 要么是 1 。 全零矩阵是所有格子都为 0 的矩阵。 示例 1： 123输入：mat = [[0,0],[0,1]]输出：3解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。 示例 2：123输入：mat = [[0]]输出：0解释：给出的矩阵是全零矩阵，所以你不需要改变它。 示例 3：12输入：mat = [[1,1,1],[1,0,1],[0,0,0]]输出：6 示例 4：123输入：mat = [[1,0,0],[1,0,0]]输出：-1解释：该矩阵无法转变成全零矩阵 提示：12345m == mat.lengthn == mat[0].length1 &lt;= m &lt;= 31 &lt;= n &lt;= 3mat[i][j] 是 0 或 1 。 解题思路使用位向量（即整数）保存矩阵的状态，使用BFS对每一个可能的状态，对其中的每一位进行翻转。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.ArrayDeque;import java.util.HashSet;import java.util.Queue;import java.util.Set;class Solution &#123; int n, m; public int minFlips(int[][] mat) &#123; n = mat.length; m = mat[0].length; //初始化状态 int bitVec = createBitVec(mat); if (bitVec == 0) &#123; return 0; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); // 队列 queue.offer(bitVec); Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // 保存访问过的数 int res = 0; // 常规BFS while (!queue.isEmpty()) &#123; int queueLen = queue.size(); for (int k = 0; k &lt; queueLen; k++) &#123; int curVec = queue.poll(); // 取出队顶元素 if (curVec == 0) &#123; //如果为0,返回 return res; &#125; //如果当前元素不为0,对其中每一位进行翻转 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; bitVec = getFlip(i, j, curVec); // 获取翻转后的数值 if (!visited.contains(bitVec)) &#123; //如果没访问过，加入队列和访问过的数的集合 queue.offer(bitVec); visited.add(bitVec); &#125; &#125; &#125; &#125; res++; &#125; return -1; &#125; public int createBitVec(int[][] mat) &#123; /*初始状态：获得矩阵的值 [[1,1,1], [1,0,1], [0,0,0]] 转化为二进制 111101000-&gt;十进制 488 */ int bitVec = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; bitVec &lt;&lt;= 1; bitVec |= mat[i][j]; &#125; &#125; return bitVec; &#125; public int getFlip(int i, int j, int bitVec) &#123; int pos = i * m + j; //根据i,j位置得到对应位 bitVec ^= (1 &lt;&lt; pos); //翻转 int[][] dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; //翻转四个方向的 for (int[] dir : dirs) &#123; int x = i + dir[0], y = j + dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m) &#123; pos = x * m + y; bitVec ^= (1 &lt;&lt; pos); &#125; &#125; return bitVec; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode周赛</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-7-支持向量机]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-7-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[0 前言支持向量机是一种二类分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器；使用核技巧使得支持向量机成为实质上的非线性分类器。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。 线性可分支持向量机：当训练数据线性可分时，通过硬间隔最大化学习的线性分类器。 线性支持向量机：当训练数据近似线性可分时，通过软间隔最大化学习的线性分类器。 非线性支持向量机：当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。 当输入空间为欧式空间或离散集合、特征空间为希尔伯特空间时，核函数表示将输入从输入空间映射到特征空间得到的特征向量之间的內积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。 1 线性可分支持向量机与硬间隔最大化1.1 线性可分支持向量机假设给定一个特征空间上的训练数据集 T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$。 再假设训练数据集是线性可分的。学习的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程$w\cdot x+b=0$，它由法向量$w$和截距$b$决定，可用$(w,b)$来表示。分离超平面将特征空间划分为两部分。 一般地，当训练数据集线性可分时，存在无穷个超平面可将两类数据正确分开。线性可分支持向量机利用间隔最大化求最优分离超平面，这时解是唯一的。 定义：线性可分支持向量机：给定线性可分训练数据集，通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为 w^*\cdot x + b^*=0以及相应的分类决策函数 f(x)=sign(w^*\cdot x + b^*)称为线性可分支持向量机。 1.2 函数间隔对于给定的训练数据集$T$和超平面$(w,b)$，定义超平面$(w,b)$关于样本点$(x_i, y_i)$的函数间隔为 \hat{\gamma}_i = y_i(w \cdot x_i + b)定义超平面$(w,b)$关于训练数据集$T$的函数间隔为超平面$(w,b)$关于$T$中所有样本点$(x_i,y_i)$的函数间隔之最小值，即 \hat{\gamma}=\min_{i=1,\cdots,N} \hat{\gamma}_i函数间隔可以表示分类预测的正确性及确信度。分离超平面的法向量$w$加规范化$||w||=1$，使得间隔是确定的，这是函数间隔成为几何间隔。 几何间隔：对于给定的训练数据集$T$和超平面$(w,b)$，定义超平面$(w,b)$关于样本点$(x_i, y_i)$的几何间隔为 {\gamma}_i = y_i(\frac{w}{||w||} \cdot x_i + \frac{b}{||w||})定义超平面$(w,b)$关于训练数据集$T$的几何间隔为超平面$(w,b)$关于$T$中所有样本点$(x_i,y_i)$的几何间隔之最小值，即 {\gamma}=\min_{i=1,\cdots,N} {\gamma}_i函数间隔和几何间隔的关系 \begin{array} {} \gamma _i = \frac{\hat{\gamma}_i}{||w||} \\ \gamma = \frac{\hat{\gamma}}{||w||} \end{array}如果$||w||=1$，那么函数间隔和几何间隔相等，如果超平面参数$w$和$b$成比例地改变（超平面没有改变），函数间隔也按此比例改变，而几何间隔不变。 1.3 间隔最大化支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。（硬间隔最大化）。 间隔最大化的直观解释：对训练数据集找到几何间隔最大的超平面意味着以充分大的确信度对训练数据进行分类。这样的超平面对未知的新实例有很好的分类预测能力。 最大间隔分离超平面：可表示为下面的约束最优化问题。 \begin{array} {} \max \limits _{(w,b)} &\gamma\\ s.t. & y_i \left( \frac{w}{||w||} \cdot x_i + \frac{b}{||w||} \right) \ge\gamma,i=1,2,\cdots,N \end{array}我们希望最大化超平面$(w,b)$关于训练数据集的几何间隔$\gamma$，约束条件表示的是超平面$(w,b)$关于每一个训练样本点的几何间隔至少是$\gamma$。 考虑到几何间隔和函数间隔的关系，这个问题可改写为 \begin{array} {} \max \limits _{(w,b)} & \frac{\hat{\gamma}} {||w||}\\ s.t. & y_i \left( w \cdot x_i + b \right) \ge \hat{\gamma},i=1,2,\cdots,N \end{array}函数间隔$\hat{\gamma}$的取值并不影响最优化问题的解，这里去$\hat{\gamma}=1$，注意到最大化$\frac{1}{||w||}$和最小化$\frac{1}{2} ||w||^2$是等价的，于是可以得到线性可分支持向量机学习的最优化问题 \begin{array} {} \min \limits _{(w,b)} & \frac{1}{2} {||w||}^2\\ s.t. & y_i \left( w \cdot x_i + {b} \right)-1 \ge 0,i=1,2,\cdots,N \end{array}这是一个凸二次规划问题。 算法：线性可分支持向量机学习算法—最大间隔法 输入：线性可分训练数据集$T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}$，其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$，$1,2,\cdots,N$ 输出：最大间隔分离超平面和分类决策函数 （1）构造并求解约束最优化问题： \begin{array} {} \min \limits _{(w,b)} & \frac{1}{2} {||w||}^2\\ s.t. & y_i \left( w \cdot x_i + {b} \right)-1 \ge 0,i=1,2,\cdots,N \end{array}求得最优解$w^,b^$。 （2）由此得到分离超平面： w^* \cdot x + b^* = 0分类决策函数 f(x)= \operatorname{sign}(w^* \cdot x + b ^*)可以证明线性可分训练集的最大间隔分离超平面是存在且唯一的。（证明略） 支持向量：在线性可分情况下，训练数据集的样本点中与分离超平面最近的样本点的实例。支持向量是使约束条件式$y_i \left( w \cdot x_i + {b} \right)-1 =0$的点。 间隔边界：超平面$H_1:w\cdot x +b=1$和$H_2:w \cdot x+b=-1$称为间隔边界。 间隔：$H_1$和$H_2$之间的距离称为间隔，等于$\frac{2}{||w||}$。 在决定分离超平面时只有支持向量起作用，而其他实例点并不起作用，如果移动支持向量将改变所求的解。但是如果在间隔边界以外移动其他实例点，甚至去掉这些点，则解是不会改变的。支持向量的个数一般很少，所以支持向量机由很少的”重要的”训练样本确定。 1.4 学习的对偶问题引入对偶的优点：一是对偶问题往往更容易求解，二是自然引入核函数，进而推广到非线性分类问题。 构建拉格朗日函数，对每一个不等式约束引进拉格朗日乘子$\alpha_i \ge 0, i=1,2,\cdots,N$，定义拉格朗日函数： L(w, b, \alpha)=\frac{1}{2}\|w\|^{2}-\sum_{i=1}^{N} \alpha_{i} y_{i}\left(w \cdot x_{i}+b\right)+\sum_{i=1}^{N} \alpha_{i}其中，$\alpha=(\alpha_1,\alpha_2,\cdots ,\alpha_N)^T$为拉格朗日乘子。 根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题： \max_\alpha \min_{w,b} L(w,b,\alpha)所以，为了求解对偶问题的解，需要先求$L(w,b,\alpha)$对$w,b$的极小，然后对$\alpha$求极大。 （1）求$\min\limits_{w,b}L(w,b,\alpha)$ 将拉格朗日函数$L(w,b,\alpha)$分别对$w,b$求偏导并令其等于0。 \begin{array}{c}{\nabla_{w} L(w, b, \alpha)=w-\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}=0} \\ {\nabla_{b} L(w, b, \alpha)=\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \end{array}得 \begin{array}{} {w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}} \\ {\sum_{i=1}^{N} \alpha_{i} y_{i}=0}\end{array}将以上两式代入拉格朗日函数，得 \begin{aligned} L(w, b, \alpha)=& \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} y_{i}\left(\left(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j}\right) \cdot x_{i}+b\right)+\sum_{i=1}^{N} \alpha_{i} \\=&-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N} \alpha_{i} \end{aligned}即 \min _{w, b} L(w, b, \alpha)=-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N} \alpha_{i}（2）求$\min\limits_{w,b} L(w,b,\alpha)$对$\alpha$的极大，即是对偶问题： \begin{array}{} \max\limits _{\alpha} & -\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N} \alpha_{i} \\ s.t. & \sum_{i=1} ^N \alpha_i y_i = 0\\ & \alpha_i \ge 0, i=1,2,\cdots ,N \end{array}将以上目标函数由求极大转换成求极小，就得到下面与之等价的对偶最优化问题： \begin{array}{} \min \limits_{\alpha} & \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\ s.t. & \sum_{i=1} ^N \alpha_i y_i = 0\\ & \alpha_i \ge 0, i=1,2,\cdots ,N \end{array}以上最优化的解的形式为： \begin{array}{} w^* = \sum ^N_{i=1} \alpha_i^*y_ix_i\\ b^* = y_j - \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j) \end{array}因此分离超平面可以写成 \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j)+b^*=0分类决策函数可以写成 f(x) = \operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j)+b^* \right)分类决策函数只依赖于输入$x$和训练样本输入的內积，上式称为线性可分支持向量机的对偶形式。 $KTT$条件：$KKT$条件给出了判断某点是否为最优解的必要条件。 \begin{array}{l}{\nabla_{w} L\left(w^{*}, b^{*}, \alpha^{*}\right)=w^{*}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i}=0} \\ {\nabla_{b} L\left(w^{*}, b^{*}, \alpha^{*}\right)=-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}=0} \\ {\alpha_{i}^{*}\left(y_{i}\left(w^{*} \cdot x_{i}+b^{*}\right)-1\right)=0, \quad i=1,2, \cdots, N} \\ {y_{i}\left(w^{*} \cdot x_{i}+b^{*}\right)-1 \geqslant 0, \quad i=1,2, \cdots, N} \\ {\alpha_{i}^{*} \geqslant 0, \quad i=1,2, \cdots, N}\end{array}算法：线性可分支持向量学习算法 输入：线性可分训练数据集$T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}$，其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$，$1,2,\cdots,N$ 输出：最大间隔分离超平面和分类决策函数 （1）构造并求解约束最优化问题： \begin{array}{} \min \limits_{\alpha} & \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i} \\ s.t. & \sum_{i=1} ^N \alpha_i y_i = 0\\ & \alpha_i \ge 0, i=1,2,\cdots ,N \end{array}求得最优解$\alpha^=(\alpha_1^,\alpha_2^,\cdots ,\alpha_N^)^T$。 （2）计算： w^* = \sum ^N_{i=1} \alpha_i^*y_ix_i并选择$\alpha^$的一个正分量$\alpha_j^ &gt; 0$，计算 b^* = y_j - \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j)（3）求得分离超平面 w^* \cdot x + b^* = 0分类决策函数： f(x)=\operatorname{sign} (w^* \cdot x + b^*)在线性可分支持向量机中，$w^$和$b^$只依赖于训练数据中对应于$\alpha_i^&gt;0$的样本点$(x_i,y_i)$，这些样本点称为支持向量，而其他样本点对$w^$和$b^*$没有影响。 2 线性支持向量机与软间隔最大化2.1 线性支持向量机线性可分问题的支持向量机学习方法，对线性不可分训练数据是不适用的，需要修改硬间隔最大化，使其称为软间隔最大化，从而扩展到线性不可分问题。 假定训练数据集不是线性可分的，训练数据中有一些特异点，将这些特异点去除后，剩下大部分的样本点组成的集合是线性可分的。线性不可分意味着某些样本点$(x_i,y_i)$不能满足函数间隔大于等于1的约束条件，为了解决这个问题，可以对每个样本点$(x_i,y_i)$引入一个松弛变量$\xi_i \ge 0$，使函数间隔加上松弛变量大于等于1，约束条件变为： y_i(w \cdot x_i + b) \ge 1- \xi_i同时，对每个松弛变量$\xi_i$，支付一个代价$\xi_i$，目标函数由原来 $\frac{1}{2} ||w||^2$变为： \begin{equation} \frac{1}{2} ||w||^2 + C \sum^N_{i=1} \xi_i \end{equation}其中$C&gt;0$是惩罚参数，一般由应用问题决定，$C$值大时对误分类的惩罚增大，$C$值小时对误分类的惩罚减小，以上目标函数包含两层含义：使$\frac{1}{2}||w||^2$尽量小即间隔尽量大，同时使误分类点的个数尽量小，$C$是调和二者的系数。 因此，可以和训练数据集线性可分时一样来考虑训练数据集线性不可分的线性支持向量机学习问题。称为软间隔最大化。 学习问题为： \begin{array}{} \min & \frac{1}{2} ||w||^2 + C \sum^N_{i=1} \xi_i \\ \operatorname{s.t.} & y_i(w \cdot x+b )\ge 1- \xi_i, i=1,2,\cdots, N \\ & \xi_i \ge 0, i=1,2,\cdots,N \end{array}求得分离超平面 w^* \cdot x + b^* = 0分类决策函数为 f(x)=\operatorname{sign} (w^* \cdot x + b^*)称为线性支持向量机。 2.2 学习的对偶算法上节中学习的原始问题的对偶问题是： \begin{array}{cl}{\min _{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}\end{array}推导过程： 原始最优化问题的拉格朗日函数是： \begin{equation} L(w, b, \xi, \alpha, \mu) \equiv \frac{1}{2}\|w\|^{2}+C \sum_{i=1}^{N} \xi_{i}-\sum_{i=1}^{N} \alpha_{i}\left(y_{i}\left(w \cdot x_{i}+b\right)-1+\xi_{i}\right)-\sum_{i=1}^{N} \mu_{i} \xi_{i} \end{equation}其中，$\alpha_i \ge 0, \mu_i \ge 0$。 对偶问题是拉格朗日函数的极大极小问题，首先求$L(w, b, \xi, \alpha, \mu)$对$w,b,\xi$的极小，由 \begin{array}{c}{\nabla_{w} L(w, b, \xi, \alpha, \mu)=w-\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}=0} \\ {\nabla_{b} L(w, b, \xi, \alpha, \mu)=-\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {\nabla_{\xi_{i}} L(w, b, \xi, \alpha, \mu)=C-\alpha_{i}-\mu_{i}=0} \end{array}得 \begin{array}{} {w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}} \\ {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {C-\alpha_{i}-\mu_{i}=0} \end{array}将以上三式代入原始最优化问题的拉格朗日函数中，得 \min _{w, b, \xi} L(w, b, \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N} \alpha_{i}再对$\min \limits _{w, b, \xi} L(w, b, \xi, \alpha, \mu)$求$\alpha$的极大，即得对偶问题： \begin{array}{} \max_\alpha & -\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)+\sum_{i=1}^{N} \alpha_{i}\\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ & C-\alpha_i-\mu_i=0\\ & \alpha_i \ge 0\\ {} & \mu_i \ge 0, \quad i=1,2, \cdots, N \end{array}利用等式约束$C-\alpha_i-\mu_i=0$消去$\mu_i$，从而只留下变量$\alpha_i$，并将以上后三个约束条件写成： {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}再对目标函数求极大转换为求极小，即可得到原始问题的对偶问题。 $KKT条件$： \begin{aligned} \nabla_{w} L\left(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*}\right) =w^{*}-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i} x_{i}=0 \\ \nabla_{b} L\left(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*}\right) =-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}=0 \\ \nabla_{\xi} L\left(w^{*}, b^{*}, \xi^{*}, \alpha^{*}, \mu^{*}\right) =-\sum_{i=1}^{N} \alpha_{i}^{*} y_{i}=0 \\ \qquad \begin{array}{rl}{\alpha_{i} L\left(w^{*}, b^{*}, \xi^{*}, \mu^{*}\right)} {=C-\alpha^{*}-\mu^{*}=0} \\ {\mu_{i}^{*}\left(y_{i}\left(w^{*} \cdot x_{i}+b^{*}\right)-1+\xi_{i}^{*}\right)} {=0} \\ {y_{i}\left(w^{*} \cdot x_{i}+b^{*}\right)} {-1+\xi_{i}^{*}} {=0} \\ {\xi_{i}^{*}} {\geqslant 0} \\ {\mu_{i}^{*} \geqslant 0} \quad {i=1,2, \cdots, N} \end{array} \end{aligned}因此分离超平面可以写成 \sum _{i=1} ^N \alpha_i^*y_i(x \cdot x_i)+b^*=0分类决策函数可以写成 f(x) = \operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_i(x \cdot x_i)+b^* \right)上式即为线性支持向量机的对偶形式。 输入：线性支持向量机学习算法 输入：线性可分训练数据集$T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}$，其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$，$1,2,\cdots,N$ 输出：最大间隔分离超平面和分类决策函数 （1）构造并求解约束最优化问题： \begin{array}{cl}{\min _{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}\left(x_{i} \cdot x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}\end{array}求得最优解$\alpha^=(\alpha_1^,\alpha_2^,\cdots ,\alpha_N^)^T$。 （2）计算： w^* = \sum ^N_{i=1} \alpha_i^*y_ix_i并选择$\alpha^$的一个正分量$0 &lt; \alpha_j^ &lt; C$，计算 b^* = y_j - \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j)（3）求得分离超平面 w^* \cdot x + b^* = 0分类决策函数： f(x)=\operatorname{sign} (w^* \cdot x + b^*)在步骤（2）中，对任一适合条件$0 &lt; \alpha_j^ &lt; C$的$\alpha_j^$，都可以求出$b^*$，但是由于原始问题对$b$的解并不唯一，所以实际计算时可以取在所有符合条件的样本点上的平均值。 2.3 支持向量如下图所示，软间隔的支持向量要比线性可分的情况复杂一些。分离超平面由实线表示，间隔边界由虚线表示，正例点由o表示，负例点由x表示。 软间隔的支持向量$x_i$或者在间隔边界上，或者在间隔边界与分离超平面之间，或者在分离超平面误分一侧。若$\alpha_i^ &lt;C$，则$\xi_i=0$，支持向量恰好落在间隔边界上；若$\alpha_i^ =C$，$0&lt;\xi_i1$，则支持向量位于分离超平面误分一侧。 2.4 合页损失函数线性支持向量机学习还有另一种解释，就是最小化以下目标函数： \sum_{i=1}^{N}\left[1-y_{i}\left(w \cdot x_{i}+b\right)\right]_{+}+\lambda\|w\|^{2}目标函数的第一项是经验损失或者经验风险，函数 L(y(w\cot x+b))=\left[1-y_{i}\left(w \cdot x_{i}+b\right)\right]_{+}称为合页损失函数（hinge loss）。下标$+$表示大于0取自身，小于等于0取0。这就是说，当样本点$(x_i,y_i)$被正确分类且函数间隔$y_i(w\cdot x_i + b)$大于1时，损失时0，否则损失是$1-y_i(w \cdot x_i + b)$。目标函数第二项是系数为$\lambda$的$w$的$L_2$的范数，是正则化项。 即 线性支持向量机原始最优化问题： \begin{array}{} \min & \frac{1}{2} ||w||^2 + C \sum^N_{i=1} \xi_i \\ \operatorname{s.t.} & y_i(w \cdot x+b )\ge 1- \xi_i, i=1,2,\cdots, N \\ & \xi_i \ge 0, i=1,2,\cdots,N \end{array}等价于 \min \limits _{w,b} \quad \sum_{i=1}^{N}\left[1-y_{i}\left(w \cdot x_{i}+b\right)\right]_{+}+\lambda\|w\|^{2}如下图，0-1损失函数是二类分类问题的真正的损失函数，而合页损失函数是0-1损失函数的上界。由于0-1损失函数不是连续可导的，直接优化由其构成的目标函数比较困难，可以认为线性支持向量机是优化由0-1损失函数的上界构成的目标函数。 上图中虚线显示的是感知机的损失函数$\left[y_{i}\left(w \cdot x_{i}+b\right)\right]_{+}$。这时，当样本点$(x_i, y_i)$合页损失被正确分类时，损失是0，否则损失是$-y_{i}\left(w \cdot x_{i}+b\right)$。相比之下，合页损失函数不仅要分类正确，而且确信度足够高时损失才是0。也就是说，合页损失函数对学习有更高的要求。 3 非线性支持向量机与核函数3.1 核技巧非线性分类问题 非线性分类问题是指通过利用非线性模型才能很好地进行分类的问题。 非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题。所采取的方法是进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。如上图，通过变换，将左图中椭圆变换成右图中的直线，从而将非线性分类问题变换为线性分类问题。 设原空间为$\mathcal{X} \subset \mathbf{R}^2, x=(x^{(1)}, x^{(2)})^T \in \mathcal{X}$，新空间$\mathcal{Z} \subset \mathbf{R}^2, z=(z^{(1)}, z^{(2)})^T \in \mathcal{Z}$，定义从原空间到新空间的变换（映射）： z=\phi(x)=\left((x^{(1)})^2, (x^{(2)})^2\right)^T经过变换，原空间$\mathcal{X} \subset \mathbf{R}^2$变换为新空间$\mathcal{Z} \subset \mathbf{R}^2$，原空间中的点响应地变换为新空间中的点，原空间中的椭圆 {w_{1}\left(x^{(1)}\right)^{2}+w_{2}\left(x^{(2)}\right)^{2}+b=0}变换成新空间中的直线 {w_{1} z^{(1)}+w_{2} z^{(2)}+b=0}在变换后的新空间里，直线$ {w_{1} z^{(1)}+w_{2} z^{(2)}+b=0}$可以将变换后的正负实例点正确分开。这样，原空间的非线性可分问题就变成了新空间的线性可分问题。 用线性分类的方法求解非线性分类问题分为两步：首先使用一个变换将原空间的数据映射到新空间；然后在新空间中用线性分类学习方法从训练数据中学习分类模型。核技巧就属于这样的方法。 核函数的定义 设$\mathcal{X}$是输入空间（欧式空间$R^n$的子集或离散集合），又设$\mathcal{H}$为特征空间（希尔伯特空间），如果存在一个从$\mathcal{X}$到$\mathcal{H}$的映射 \phi{(x)}:\mathcal{X}\rightarrow \mathcal{H}使得对所有$x,z\in \mathcal{X}$，函数$K(x,z)$满足条件 K(x,z)=\phi(x)\cdot\phi(z)其中$K(x,z)$为核函数，$\phi(x)$为映射函数，式中$\phi(x)\cdot\phi(z)$为两者的內积。 核技巧的想法是，在学习与预测时只定义核函数$K(x,z)$，而不显式地定义映射函数$\phi$，通常，直接计算$K(x,z)$比较容易，而通过$\phi(z)$和$\phi(z)$计算$K(x,z)$并不容易，特征空间$\mathcal{H}$一般是高维的，甚至是无穷维的，对于给定的核函数，特征空间$\mathcal{H}$和映射函数$\phi$的取法并不唯一，可以取不同的特征空间，即便在同一特征空间里也可以取不同的映射。 核技巧在支持向量机中的应用 在线性支持向量机的对偶问题中，无论是目标函数还是决策函数（分离超平面）都只涉及输入实例与实例之间的內积。在对偶问题的目标函数中的內积$x_i\cdot x_j$可以用$K(x_i,x_j)=\phi(x_i)\cdot\phi(z)$来代替。此时对偶问题的目标函数成为： W(\alpha)={\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}K\left(x_{i} , x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}}同样，分类决策函数中的內积也可以用核函数代替，而分类决策函数式成为 f(x) =\operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_i \phi(x) \cdot \phi(x_i)+b^* \right)= \operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_iK(x_i,x)+b^* \right)这等价于经过映射函数$\phi$将原来的输入空间变换到一个新的特征空间，将输入空间的內积$x_i\cdot x_j$变换为特征空间的內积$\phi(x_i)\cdot \phi(x_j)$，在新的特征空间里从训练样本中学习线性支持向量机，当映射函数是非线性函数时，学习到的含有核函数的支持向量机是非线性分类模型。 3.2 正定核正定核的充要条件：设$K:\mathcal{X} \times \mathcal{X} \rightarrow \mathbf{R}$是对称函数，则$K(x,z)$为正定核函数的充要条件是对任意$x_i \in \mathcal{X}, i=1,2,\cdots,m$，$K(x,z)$对应的$Gram$矩阵 $K=\left[K(x_i, x_j) \right]_{m\times m}$是半正定的。 3.3 常用核函数 多项式核函数 K(x,z)=(x\cdot z + 1) ^p对应的支持向量机是一个$p$次多项式分类器，分类决策函数成为 f(x) =\operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_i (x_i \cdot x + 1)^p+b^* \right) 高斯核函数 K(x, z)=\exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)对应的支持向量机是高斯径向基函数分类器，分类决策函数成为 f(x) =\operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_i \exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)+b^* \right)3.3 非线性支持向量机算法：非线性支持向量机学习算法 输入：线性可分训练数据集$T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}$，其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$，$1,2,\cdots,N$ 输出：分类决策函数 （1）选取适当的核函数$K(x,z)$和适当的参数$C$，构造并求解最优化问题 \begin{array}{cl}{\min \limits_{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}K\left(x_{i} , x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}\end{array}求得最优解$\alpha^=(\alpha_1^,\alpha_2^,\cdots ,\alpha_N^)^T$。 （2）并选择$\alpha^$的一个正分量$0 &lt; \alpha_j^ &lt; C$，计算 b^* = y_j - \sum _{i=1} ^N \alpha_i^*y_i(x_i \cdot x_j)（3）构造决策函数： f(x) = \operatorname{sign} \left( \sum _{i=1} ^N \alpha_i^*y_iK(x_i,x)+b^* \right)当$K(x,z)$是正定核函数时，最优化问题是凸二次规划问题，解是存在的。 4 序列最小最优化算法SMO算法要解以下凸二次规划的对偶问题： \begin{array}{cl}{\min \limits_{\alpha}} & {\frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N} \alpha_{i} \alpha_{j} y_{i} y_{j}K\left(x_{i} , x_{j}\right)-\sum_{i=1}^{N} \alpha_{i}} \\ {\text { s.t. }} & {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {} & {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N}\end{array}在这个问题中，变量时朗格朗日乘子，一个变量$\alpha_i$对应于一个样本点$(x_i,y_i)$。 SMO是一种启发式算法：如果所有变量的解都满足此最优化问题的KKT条件，那么这个最优化问题的解就得到了。因为KKT条件是该最优化问题的充分必要条件。否则，选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题。这个二次规划问题关于这两个变量的解应该更接近原始二次规划问题的解，因为这会使得原始二次规划问题的目标函数值变得很小。 这时子问题可以通过解析方法求解，可以大大提高整个算法的计算速度。子问题有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定。如此，SMO算法将原问题不断分解为子问题并对子问题求解，进而达到求解原问题的目的。 4.1 两个变量二次规划的求解方法假设选择的两个变量是$\alpha_1, \alpha_2$，其他变量$\alpha_i(i=3,4,\cdots,N)$是固定的。于是SMO的最优化问题的子问题可以写成： \begin{array}{l} \min\limits _{\alpha_{1}, \alpha_{2}} & W\left(\alpha_{1}, \alpha_{2}\right)= &\frac{1}{2} K_{11} \alpha_{1}^{2}+\frac{1}{2} K_{22} \alpha_{2}^{2}+y_{1} y_{2} K_{12} \alpha_{1} \alpha_{2} \\ & &{-\left(\alpha_{1}+\alpha_{2}\right)+y_{1} \alpha_{1} \sum_{i=3}^{N} y_{i} \alpha_{i} K_{i 1}+y_{2} \alpha_{2} \sum_{i=3}^{N} y_{i} \alpha_{i} K_{i 2}} \\ & \operatorname{s.t.} &{\alpha_{1} y_{1}+\alpha_{2} y_{2}=-\sum_{i=3}^{N} y_{i} \alpha_{i}=\zeta} \\ & &{0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2} \end{array}其中$K_{ij}=K(x_i, x_j)，i,j=1,2,\cdots , N$，$\zeta$是常数。忽略了不含$\alpha_1,\alpha_2$的常数项。 4.2 变量选择方法一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定。具体略。 算法：SMO算法 输入：线性可分训练数据集$T=\{(x_1,y_1), (x_2, y_2), \cdots, (x_N, y_N)\}$，其中$x_i\in\mathcal{X} = \mathbf{R}^n$，$y_i \in \mathcal{Y}=\{+1,-1\}$，$1,2,\cdots,N$，精度$\epsilon$ 输出：近似解$\hat{\alpha}$。 （1）取初值$\alpha^{(0)}=0$，令$k=0$； （2）选取最优化变量$\alpha_1^{(k)},\alpha_2^{(k)}$，解析求解两个变量的最优化问题，求得最优解$\alpha_1^{(k+1)},\alpha_2^{(k+1)}$，更新$\alpha$为$\alpha^{(k+1)}$; （3）若在精度$\epsilon$范围内满足停止条件： \begin{array}{c} {\sum_{i=1}^{N} \alpha_{i} y_{i}=0} \\ {0 \leqslant \alpha_{i} \leqslant C, \quad i=1,2, \cdots, N} \\ y_i \cdot g(x_i)=\left\{ \begin{aligned} {\geqslant 1, \left\{x_{i} | \alpha_{i}=0\right\}} \\ {=1, \left\{x_{i} | 0]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-5-决策树]]></title>
    <url>%2F2019%2F10%2F28%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-5-%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前言决策树是一种基本的分类与回归方法。本文主要讨论用于分类的决策树。决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程，它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。其主要优点是模型具有可读性，分类速度快。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型。预测时，对新的数据，利用决策树模型进行分类。 决策树学习包括三个步骤：特征选择、决策树的生成和决策树的修剪。 决策树模型与学习决策树模型分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成，结点有两种类型：内部结点和叶结点。内部结点表示一个特征或属性，叶结点表示一个类。 用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归地对实例进行测试并分配，直至到达叶结点。最后将实例分到叶结点的类中。 决策树与if-then规则可以将决策树看成一个if-then规则的集合。将决策树转换成if-then规则的过程是这样的：由决策树的根结点到叶结点的每一条路径构建一条规则；路径上内部结点的特征对应着规则的条件，而叶结点对应着规则的结论。决策树的路径是互斥并且完备的。即每一个实例都被一条路径或一条规则所覆盖，并且只被一条路径或一条规则所覆盖。 决策树与条件概率分布决策树还表示给定特征条件下类的条件概率分布。这一条件概率分布定义在特征空间的一个划分上。将特征空间划分为互不相交的单元或区域，并在每个单元定义一个类的概率分布就构成了一个条件概率分布。决策树的一条路径对应于划分中的一个单元。决策树所表示的条件概率分布由各个单元给定条件下类的条件概率分布组成。 决策树学习决策树学习，假设给定训练数据集$D=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}$为输入实例，$n$为特征个数，$y_i \in \{1,2,\cdots,K\}$为类标记，$i=1,2,\cdots,N$，$N$为样本容量。学习的目标是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。 决策树学习的本质是从给定的训练数据集中依据属性或特征归纳出一组分类规则。与给定的训练数据集相符合的分类规则可能有多个，决策树模型就是需要从多个符合的分类规则中找到损失最小的，泛化能力最好的一组分类规则。 决策树常用的损失函数是正则化的极大似然函数，决策树的学习策略是以损失函数为目标函数的最小化。由于所有可能的决策树组成的解空间较大，从中找到最优的决策树是NP完全问题，因此一般多采用启发式算法来近似求解。 决策树学习的算法通常是一个递归的选择最优特征的过程。从可选的特征集合中选出最优的特征（即依据该特征能最有效的将训练数据集分类），按照这一特征将数据集分割成子集，该特征作为这些子集的根节点。如果这些子集已经基本可以正确分类，那么构建叶节点，并将这些子集分到所对应的的叶节点中去。如果还有子集不能被正确分类，那么对这些子集选取新的最优特征，继续对其进行分割，直至所有训练数据都被正确分类。至此就构建出来一颗决策树。 通过上述步骤构建的决策树可以对训练数据集进行很好的分类，但是并不一定有很好的泛化能力，即可能发生过拟合现象。为了增强其泛化能力，我们需要对构建好的决策树进行自底向上的剪枝，即将树变得更简单一点。通过去掉决策树中过于细分的叶节点，使其回退到父节点甚至更高节点，用父节点或更高节点作为新的叶节点。 特征选择特征选择在于选取对训练数据具有良好分类能力的特征，这样可以提高决策树的学习效率。通常特征选择的准则是信息增益或信息增益比。 信息增益熵：表示随机变量不确定性的度量。设$X$是一个取有限个值的离散随机变量，其概率分布为 P(X=x_i)=p_i,\quad i = 1,2,\cdots,n则随机变量$X$的熵定义为 H(X) = -\sum^n_{i=1}p_ilogp_i熵越大，随机变量的不确定性就越大。$0\le H(X)\le logn$。 条件熵：条件熵$H(Y|X)$表示在已知随机变量$X$的条件下随机变量$Y$的不确定性。定义为$X$给定条件下$Y$的条件概率分布的熵对$X$的数学期望 H(Y|X)=\sum^n_{i=1}p_iH(Y|x_i)其中$p_i=P(X=x_i),\quad i = 1,2,\cdots,n$。 当熵和条件熵重的概率由数据估计（极大似然估计） 得到时，所对应的熵与条件熵分别称为经验熵和经验条件熵。 信息增益：表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度。 特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为集合$D$的经验熵$H(D)$与给定条件下$D$的经验条件熵$H(D|A)$之差，即 g(D,A)=H(D)-H(D|A)信息增益等价于类与特征的互信息。 信息增益大的特征具有更强的分类能力。根据信息增益准则进行特征选择：对训练数据集（或子集），计算其每个特征的信息增益，选择信息增益最大的特征。 信息增益比以信息增益作为选择特征的准则，存在偏向于选择取值较多的特征的问题。即当一个特征可能的取值较多时，其计算出来的信息增益可能会较高，但是并不一定就一定是一个更有效的分类特征。采用信息增益比可以对这一问题进行校正，这是特征选择的另一准则。 特征$A$对训练数据集$D$的信息增益比$g_R(D,A)$定义为其信息增益$g(D,A)$与训练数据集$D$的经验熵$H(D)$之比： g_R(D,A)=\frac{g(D,A)}{H(D)}其中$H_{A}(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2} \frac{\left|D_{i}\right|}{|D|}$，$n$是特征$A$取值的个数。 决策树的生成$ID3$算法在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。 算法：$ID3$算法 输入：训练数据集$D$，特征集$A$，阈值$\epsilon$； 输出：决策树$T$。 （1）若$D$中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$； （2）若$A=\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$； （3）否则，计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$； （4）如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$； （5）否则，对$A_g$的每一个可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$； （6）对第$i$个子结点，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~（5），得到子树$T_i$，返回$T_i$。 $C4.5$算法$C4.5$算法对$ID3$算法进行了改进，使用信息增益比来选择特征。 算法：$C4.5$算法 输入：训练数据集$D$，特征集$A$，阈值$\epsilon$； 输出：决策树$T$。 （1）若$D$中所有实例属于同一类$C_k$，则$T$为单结点树，并将类$C_k$作为该结点的类标记，返回$T$； （2）若$A=\emptyset$，则$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$； （3）否则，计算$A$中各特征对$D$的信息增益比，选择信息增益比最大的特征$A_g$； （4）如果$A_g$的信息增益小于阈值$\epsilon$，则置$T$为单结点树，并将$D$中实例数最大的类$C_k$作为该结点的类标记，返回$T$； （5）否则，对$A_g$的每一个可能值$a_i$，依$A_g=a_i$将$D$分割为若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树$T$，返回$T$； （6）对第$i$个子结点，以$D_i$为训练集，以$A-\{A_g\}$为特征集，递归地调用步（1）~（5），得到子树$T_i$，返回$T_i$。 决策树的剪枝通过前边决策树生成算法的步骤生成的决策树可能对训练数据有很好的拟合效果，但是由于分支过细，可能会包含太多训练集中的信息，导致泛化能力很差，对未知的数据没有准确的分类。解决这个问题的办法是考虑决策树的复杂度，对已生成的决策树进行简化。 剪枝是从已生成的树上裁掉一些子树或叶结点，并将其根结点或父节点作为新的叶结点，从而简化分类树模型。通过极小化决策树整体的损失函数或代价函数来实现。 设树$T$的叶结点个数为$|T|$，$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_{tk}$个，则损失函数可以定义为： C_{\alpha}(T)=\sum_{t=1}^{|T |} N_{t} H_{t}(T)+\alpha|T|其中右边第一项为经验熵表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，$T$表示模型复杂度，参数$\alpha \ge0$控制两者之间的影响。较大的$\alpha$促使选择较简单的模型，较小的$\alpha$促使选择较复杂的模型。 决策树的生成只考虑通过提高信息增益（或信息增益比）对训练数据进行更好的拟合，而决策树剪枝通过优化损失函数还考虑了减小模型复杂度。决策树生成学习局部的模型，而决策树剪枝学习整体的模型。 算法：树的剪枝算法 输入：生成算法产生的整个树$T$，参数$\alpha$； 输出：修剪后的子树$T_\alpha$。 （1）计算每个结点的经验熵； （2）递归地从树的叶结点向上回缩；设一组叶结点回缩到其父结点之前与之后的整体树分别为$T_B$与$T_A$，其对应的损失函数值分别为$C_\alpha(T_B)$与$C_\alpha(T_A)$，如果 $C_\alpha(T_A) \le C_\alpha(T_B)$则进行剪枝，即将父结点变为新的叶结点； （3）返回（2），直至不能继续为止，得到损失函数最小的子树$T_\alpha$。 CART算法CART可以用于分类也可以用于回归。CART在给定输入随机变量$X$条件下输出随机变量$Y$的条件概率分布的学习方法。它假设决策时是二叉树，内部结点特征的取值为“是”和“否”，左分支是取值为“是”的分支，右分支是取值为“否”的分支，这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。 CART算法由两步组成： （1）决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大； （2）决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准。 CART生成决策树的生成就是递归地构建二叉决策树的过程，对回归树用平方误差最小化准确，对分类树用基尼指数最小化准则，进行特征选择，生成二叉树。 回归树的生成 算法：最小二乘回归树生成算法 输入：训练数据集$D$； 输出：回归树$f(x)$。 在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树。 （1）选择最优切分变量$j$与切分点$s$，求解 \min _{j, s}\left[\min _{c_1} \sum_{x_i \in R_{1}(j,s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_i \in R_{2} (j, s)}\left(y_{i}-c_{2}\right)^{2}\right]遍历变量$j$，对固定的切分变量$j$扫描切分点$s$，选择使上式达到最小值的对$(j,s)$。 （2）用选定的对$(j,s)$划分区域并决定相应的输出值： \begin{aligned} R_{1}(j, s) &=\left\{x | x^{(j)} \leqslant s\right\}, \quad R_{2}(j, s)=\left\{x | x^{(j)}>s\right\} \\ \hat{c}_{m} &=\frac{1}{N_{m}} \sum_{x_{i} \in R_{m}(j, s)} y_{i}, \quad x \in R_{m}, \quad m=1,2 \end{aligned}（3）继续对两个子区域调用步骤（1），（2），直至满足停止条件。 （4）将输入空间划分为$M$个区域$R_1,R_2,\cdots,R_M$，生成决策树： f(x) = \sum^M_{m=1}\hat{c}_mI(x\in R_m)分类树的生成 分类树用基尼指数最小选择最优特征，同时决定该特征的最优二值切分点。 基尼指数：分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为： \operatorname{Gini}(p)=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}^{2}对于给定的样本集合$D$，其基尼指数为： \operatorname{Gini}(D)=1-\sum_{k=1}^{K} \left(\frac{|C_k|}{D} \right)^2这里$C_k$是$D$中属于第$k$类的样本子集，$K$是类的个数。 如果样本集合$D$根据特征$A$是否取某一可能值$a$被分割成$D_1$和$D_2$两部分，则在特征$A$的条件下，集合$D$的基尼指数为： \operatorname{Gini}(D, A)=\frac{\left|D_{1}\right|}{|D|} \operatorname{Gini}\left(D_{1}\right)+\frac{\left|D_{2}\right|}{|D|} \operatorname{Gini}\left(D_{2}\right)基尼指数越大，样本集合的不确定性越大。 算法：CART生成算法 输入：训练数据集$D$，停止计算的条件； 输出：CART决策树。 根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树： （1）设结点的训练数据集为$D$，计算现有特征对该数据集的基尼指数。对每一个特征，对其每一个可能取值$a$，根据样本点对$A$是否等于$a$将$D$分割成$D_1$和$D_2$两部分，利用上式计算$A=a$时的基尼指数。 （2）在所有可能的特征$A$以及它们所有可能的切分点$a$中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。 （3）对两个子结点递归地调用（1）（2），直至满足停止条件。 （4）生成CART决策树。 算法停止的条件是结点中的样本个数小于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。 CART的剪枝CART剪枝主要由两步构成： （1）首先从生成算法产生的决策树$T_0$底端开始不断剪枝，直到$T_0$的根结点，形成一个子树序列$\{T_0,T_1,\cdots,T_n\}$； （2）通过交叉验证的方式在独立的验证数据集上对子树序列进行测试，从中选择最优子树。 算法：CART剪枝算法 输入：CART算法生成的决策树$T_0$； 输出：最优决策树$T_\alpha$。 （1）设$k=0,~T=T_0$； （2）设$\alpha = +\infty$； （3）自下而上地对各内部结点$t$计算$C(T_t)$，$|T_t|$以及 \begin{aligned} g(t)=\frac{C(t)-C\left(T_{t}\right)}{\left|T_{t}\right|-1}\\ \alpha = \min(\alpha,g(t))\ \end{aligned}其中$T_t$表示以$t$为根结点的子树，$C(T_t)$是对训练数据的预测误差，$|T_t|$是$T_t$的叶结点个数，$g(t)$表示剪枝后整体损失函数减少的程度。 （4）自上而下地访问内部结点$t$，如果有$g(t)=\alpha$，进行剪枝，并对叶结点$t$以多数表决法决定其类，得到树$T$。 （5）设$k=k+1$，$\alpha_k=\alpha$，$T_k=T$。 （6）如果$T$不是由根结点单独构成的树，则回到步骤（4）。 （7）采用交叉验证法在子树序列$T_0,T_1,\cdots,T_n$中选取最优子树$T_\alpha$。 例5.2 根据信息增益选择最优特征例5.3 ID3算法生成决策树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193import numpy as npimport pandas as pd## 例5.2 根据信息增益选择最优特征def create_date(): datasets = [['青年', '否', '否', '一般', '否'], ['青年', '否', '否', '好', '否'], ['青年', '是', '否', '好', '是'], ['青年', '是', '是', '一般', '是'], ['青年', '否', '否', '一般', '否'], ['中年', '否', '否', '一般', '否'], ['中年', '否', '否', '好', '否'], ['中年', '是', '是', '好', '是'], ['中年', '否', '是', '非常好', '是'], ['中年', '否', '是', '非常好', '是'], ['老年', '否', '是', '非常好', '是'], ['老年', '否', '是', '好', '是'], ['老年', '是', '否', '好', '是'], ['老年', '是', '否', '非常好', '是'], ['老年', '否', '否', '一般', '否'], ] labels = [u'年龄', u'有工作', u'有自己的房子', u'信贷情况', u'类别'] return datasets, labels# 熵的计算def calc_ent(datasets): data_length = len(datasets) label_count = &#123;&#125; for i in range(data_length): label = datasets[i][-1] if label not in label_count: label_count[label] = 0 label_count[label] += 1 ent = -sum([(p/data_length) * np.log2(p/data_length) for p in label_count.values()]) return ent# 经验条件熵def cond_ent(datasets, axis=0): # axis代表选定的特征列 data_length = len(datasets) feature_sets = &#123;&#125; for i in range(data_length): feature = datasets[i][axis] if feature not in feature_sets: feature_sets[feature] = [] feature_sets[feature].append(datasets[i]) cond_ent = sum(len(p) / data_length * calc_ent(p) for p in feature_sets.values()) return cond_ent# 信息增益def info_gain(ent, cond_ent): return ent - cond_ent# 获取最优特征def info_gain_train(datasets): count = len(datasets[0]) - 1 ent = calc_ent(datasets) best_feature = [] for c in range(count): c_info_gain = info_gain(ent, cond_ent(datasets, axis=c)) best_feature.append((c, c_info_gain)) print("特征(&#123;&#125;) - info_gain - &#123;:.3f&#125;".format(labels[c], c_info_gain)) best_ = max(best_feature, key=lambda x:x[-1]) return '特征(&#123;&#125;)的信息增益最大，选择为根节点特征'.format(labels[best_[0]])## 例5.3 ID3算法生成决策树# 定义结点类 二叉树class Node: def __init__(self, root=True, label=None, feature_name=None, feature=None): self.root = root self.label = label self.feature_name = feature_name self.feature = feature self.tree = &#123;&#125; self.result = &#123; 'label:': self.label, 'feature': self.feature, 'tree': self.tree &#125; def __repr__(self): return '&#123;&#125;'.format(self.result) def add_node(self, val, node): self.tree[val] = node def predict(self, features): if self.root is True: return self.label return self.tree[features[self.feature]].predict(features)class DTree: def __init__(self, epsilon=0.1): self.epsilon = epsilon self._tree = &#123;&#125; # 熵 @staticmethod def calc_ent(datasets): data_length = len(datasets) label_count = &#123;&#125; for i in range(data_length): label = datasets[i][-1] if label not in label_count: label_count[label] = 0 label_count[label] += 1 ent = -sum([(p / data_length) * np.log2(p / data_length) for p in label_count.values()]) return ent # 经验条件熵 def cond_ent(self, datasets, axis=0): # axis代表选定的特征列 data_length = len(datasets) feature_sets = &#123;&#125; for i in range(data_length): feature = datasets[i][axis] if feature not in feature_sets: feature_sets[feature] = [] feature_sets[feature].append(datasets[i]) cond_ent = sum(len(p) / data_length * calc_ent(p) for p in feature_sets.values()) return cond_ent # 信息增益 @staticmethod def info_gain(ent, cond_ent): return ent - cond_ent # 获取最优特征 def info_gain_train(self, datasets): count = len(datasets[0]) - 1 ent = calc_ent(datasets) best_feature = [] for c in range(count): c_info_gain = info_gain(ent, cond_ent(datasets, axis=c)) best_feature.append((c, c_info_gain)) print("特征(&#123;&#125;) - info_gain - &#123;:.3f&#125;".format(labels[c], c_info_gain)) best_ = max(best_feature, key=lambda x: x[-1]) print('特征(&#123;&#125;)的信息增益最大，选择为节点特征'.format(labels[best_[0]])) return best_ def train(self, train_data): _, y_train, features = train_data.iloc[:, :-1], train_data.iloc[:, -1], train_data.columns[:-1] # 1,若D中实例属于同一类Ck，则T为单节点树，并将类Ck作为结点的类标记，返回T if len(y_train.value_counts())==1: return Node(root=True, label=y_train.iloc[0]) # 2, 若A为空，则T为单节点树，将D中实例树最大的类Ck作为该节点的类标记，返回T if len(features) == 0: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0]) # 3,计算A中各特征对D的信息增益，选择最大信息增益的特征Ag max_feature, max_info_gain = self.info_gain_train(np.array(train_data)) max_feature_name = features[max_feature] # 4,Ag的信息增益小于阈值eta,则置T为单节点树，并将D中是实例数最大的类Ck作为该节点的类标记，返回T if max_info_gain &lt; self.epsilon: return Node(root=True, label=y_train.value_counts().sort_values(ascending=False).index[0]) # 5 构建Ag子集 node_tree = Node(root=False, feature_name=max_feature_name, feature=max_feature) feature_list = train_data[max_feature_name].value_counts().index for f in feature_list: sub_train_df = train_data.loc[train_data[max_feature_name]==f].drop([max_feature_name],axis=1) # 6 递归生成树 sub_tree = self.train(sub_train_df) node_tree.add_node(f, sub_tree) return node_tree def fit(self, train_data): self._tree = self.train(train_data) return self._tree def predict(self, X_test): return self._tree.predict(X_test)if __name__ == '__main__': # 例5.2 print("\n例题5.2==") datasets, labels = create_date() train_data = pd.DataFrame(datasets, columns=labels) print(info_gain_train(np.array(datasets))) # 例5.3 print("\n例题5.3==") datasets, labels = create_date() data_df = pd.DataFrame(datasets, columns=labels) dt = DTree() tree = dt.fit(data_df) print(tree) res = dt.predict(['老年', '否', '否', '一般']) print(res) 输出 12345678910111213141516171819例题5.2==特征(年龄) - info_gain - 0.083特征(有工作) - info_gain - 0.324特征(有自己的房子) - info_gain - 0.420特征(信贷情况) - info_gain - 0.363特征(有自己的房子)的信息增益最大，选择为根节点特征例题5.3==特征(年龄) - info_gain - 0.083特征(有工作) - info_gain - 0.324特征(有自己的房子) - info_gain - 0.420特征(信贷情况) - info_gain - 0.363特征(有自己的房子)的信息增益最大，选择为节点特征特征(年龄) - info_gain - 0.252特征(有工作) - info_gain - 0.918特征(有自己的房子) - info_gain - 0.474特征(有工作)的信息增益最大，选择为节点特征&#123;&apos;label:&apos;: None, &apos;feature&apos;: 2, &apos;tree&apos;: &#123;&apos;否&apos;: &#123;&apos;label:&apos;: None, &apos;feature&apos;: 1, &apos;tree&apos;: &#123;&apos;否&apos;: &#123;&apos;label:&apos;: &apos;否&apos;, &apos;feature&apos;: None, &apos;tree&apos;: &#123;&#125;&#125;, &apos;是&apos;: &#123;&apos;label:&apos;: &apos;是&apos;, &apos;feature&apos;: None, &apos;tree&apos;: &#123;&#125;&#125;&#125;&#125;, &apos;是&apos;: &#123;&apos;label:&apos;: &apos;是&apos;, &apos;feature&apos;: None, &apos;tree&apos;: &#123;&#125;&#125;&#125;&#125;否 sklearn实现123456789101112131415161718192021import numpy as npimport pandas as pdfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom sklearn.tree import DecisionTreeClassifierdef create_data(): iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, [0,1,-1]]) return data[:,:2], data[:,-1]if __name__ == '__main__': X,y = create_data() X_train, X_test, y_train, y_test = train_test_split(X, y,test_size=0.3) clf = DecisionTreeClassifier() print(clf.fit(X_train, y_train)) print(clf.score(X_test, y_test)) 参考文献统计学习方法. 李航https://github.com/fengdu78/lihang-code/tree/master/%E7%AC%AC05%E7%AB%A0%20%E5%86%B3%E7%AD%96%E6%A0%91]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-4-朴素贝叶斯法]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-4-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对给定的输入$x$，利用贝叶斯定理求出后验概率最大的输出$y$。 朴素贝叶斯法是典型的生成学习方法，生成方法由训练数据学习联合概率分布$P(X,Y)$，然后求得后验概率分布$P(Y|X)$。具体来说，利用训练数据学习$P(X|Y)$和$P(Y)$的估计，得到联合概率分布： P(X,Y)=P(Y)P(X|Y)贝叶斯原理朴素贝叶斯法的基本理论是贝叶斯原理。贝叶斯公式直接可以根据条件概率的定义直接推出。考虑一个问题： $P(A|B)$ 是在B发生的情况下A发生的可能性。首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称A的先验概率，用 $P(A)$ 表示。其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用 $P(A|B)$ 表示。同样地定义 $P(B)$ 和 $P(B|A)$ 。所以根据贝叶斯公式为： P(A | B)=\frac{P(B | A) P(A)}{P(B)}根据条件概率公式，在事件B发生的情况下事件A发生的概率是 {P}({A} | {B})={P}({A}, {B}) / {P}({B})同样地，在事件A发生的条件下事件B发生的概率是 {P}({B} | {A})={P}({A} , {B}) / {P}({A})整合上述两个公式：$P(A|B)P(B)=P(B|A)P(A)$ ，上式两边同除 $P(B)$ ，若$P(B)$是非零的，我们可以直接得到贝叶斯定理的公式表达式。 朴素贝叶斯的学习与分类设输入空间$\mathcal{X} \subseteq \mathbf{R}^n$为$n$维随机变量的集合，输出空间为类标记集合$\mathcal{Y}=\{ c_1, c_2, \cdots, c_K\}$。输入为特征向量$x \in \mathcal{X}$，输出为类标记$y \in \mathcal{Y}$。$X$是定义在输入空间$\mathcal{X}$上的随机向量，$Y$是定义在输出空间$\mathcal{Y}$上的随机变量。$P(X,Y)$是$X$和$Y$的联合概率分布。训练数据集$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$由$P(X,Y)$独立同分布产生。 朴素贝叶斯通过训练数据集学习联合概率分布$P(X,Y)$，具体地，学习先验概率分布和条件概率分布。先验概率分布： P\left(Y=c_{k}\right), \quad k=1,2, \cdots, K条件概率分布： P\left(X=x | Y=c_{k}\right)=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right), \quad k=1,2, \cdots, K于是根据$P(X,Y)=P(Y)P(X|Y)$可以学习到联合概率分布。 条件概率分布$P\left(X=x | Y=c_{k}\right)$有指数级数量的参数，其估计实际是不可行的，假设$x^{(j)}$可能值有$S_j$个，$j=1,2,\cdots,n$，$Y$可取值有$K$个，那么参数为$K\prod^n_{j=1}S_j$。 朴素贝叶斯法对条件概率分布作了独立性的假设，朴素贝叶斯法也因此得名。条件独立性假设是： \begin{aligned} P\left(X=x | Y=c_{k}\right) &=P\left(X^{(1)}=x^{(1)}, \cdots, X^{(n)}=x^{(n)} | Y=c_{k}\right) \\ &=\prod_{j=1}^{n} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right) \end{aligned}朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说用于分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。 朴素贝叶斯法用于分类时，对给定的输入$x$，通过学习到的模型计算后验概率分布$P\left(X=x | Y=c_{k}\right) $，将后验概率最大的类作为$x$的类的输出。后验概率计算根据贝叶斯定理进行： P\left(Y=c_{k} | X=x\right)=\frac{P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}{\sum_{k} P\left(X=x | Y=c_{k}\right) P\left(Y=c_{k}\right)}将条件独立性假设代入上式： P\left(Y=c_{k} | X=x\right)=\frac{P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}{\sum_{k} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}, \quad k=1,2, \cdots, K这就是朴素贝叶斯法分类的基本公式，于是，朴素贝叶斯分类器可表示为： y=f(x)=\arg \max _{c_{k}} \frac{P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}{\sum_{k} P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}上式中，分母对于所有的$c_k$都是相同的，所以， y=f(x)=\arg \max _{c_{k}} {P\left(Y=c_{k}\right) \prod_{j} P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}后验概率最大化的含义朴素贝叶斯法将实例分到后验概率最大的类中，这等价于期望风险最小化，假设选择0-1损失函数： L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.式中$f(X)$是分类决策函数，期望风险函数为： R_{\mathrm{exp}}(f)=E[L(Y, f(X))]期望是对联合分布$P(X,Y)$取的。由此取条件期望： R_{\mathrm{exp}}(f)=E_{X} \sum^K_{k=1}[L(c_k, f(X))]P(c_k|X)为了使期望风险最小化，只需对$X=x$逐个极小化，由此得到： \begin{aligned} f(x) &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} L\left(c_{k}, y\right) P\left(c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}} \sum_{k=1}^{K} P\left(y \neq c_{k} | X=x\right) \\ &=\arg \min _{y \in \mathcal{Y}}\left(1-P\left(y=c_{k} | X=x\right)\right) \\ &=\arg \max _{y \in \mathcal{Y}} P\left(y=c_{k} | X=x\right) \end{aligned}这样一来，根据期望风险最小化准则就得到了后验概率最大化准则： \begin{aligned} f(x) =\arg \max _{c_k} P\left(c_{k} | X=x\right) \end{aligned}即朴素贝叶斯法所采样的原理。 朴素贝叶斯法的参数估计极大似然估计在朴素贝叶斯法中，学习意味着估计$P(Y=c_k)$和$P(X^{(j)}=x^{(j)}|Y=c_k)$。可以应用极大似然估计法估计相应的概率。先验概率$P(Y=c_k)$的极大似然估计是 P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K设第$j$个特征$x^{(j)}$可能取值的集合为$\{a_{j1},a_{j2},\cdots, a_{jS_j}\}$，条件概率$P(X^{(j)}=a_{jl}|Y=c_k)$的极大似然估计是 \begin{array}{l}{P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j_{1}} y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}} \\ {j=1,2, \cdots, n ; l=1,2, \cdots, S_{j}, \quad k=1,2, \cdots, K}\end{array}式中，$x^{(j)}$是第$i$个样本的第$j$个特征；$a_{jl}$是第$j$个特征可能取的第$l$个值；$I$为指示函数。 学习与分类算法算法：朴素贝叶斯算法 输入：训练数据集$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_i = (x^{(1)}_i,x^{(2)}_i,\cdots,x^{(n)}_i)^T$，$x^{(j)}_i$是第$i$个样本的第$j$个特征，$x^{(j)}_i \in \{a_{j1},a_{j2},\cdots, a_{jS_j}\}$，$a_{jl}$是第$j$个特征可能取的第$l$个值，$j=1,2, \cdots, n$ ，$ l=1,2, \cdots, S_{j}$, $y_i \in \{ c_1, c_2, \cdots, c_K\}$，实例$x$。 输出：实例$x$的分类。 （1）计算先验概率即及条件概率 P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}{N}, \quad k=1,2, \cdots, K \begin{array}{l}{P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j_{1}} y_{i}=c_{k}\right)}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)}} \\ {j=1,2, \cdots, n ; l=1,2, \cdots, S_{j}, \quad k=1,2, \cdots, K}\end{array}（2）对于给定的实例$x = (x^{(1)},x^{(2)},\cdots,x^{(n)},、)^T$，计算 {P\left(Y=c_{k}\right) \prod_{j=1}^n P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)},k=1,2,\cdots,K（3）确定实例$x$的类 y=\arg \max _{c_{k}} {P\left(Y=c_{k}\right) \prod_{j=1}^n P\left(X^{(j)}=x^{(j)} | Y=c_{k}\right)}例题 贝叶斯估计用极大似然估计可能会出现所要估计的概率值为0的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。具体地，条件概率的贝叶斯估计是： {P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(x_{i}^{(j)}=a_{j_{1}} y_{i}=c_{k}\right)+\lambda}{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right)+S_j\lambda}}式中$\lambda \ge0$。等价于在随机变量各个取值的频数上赋予一个正数。当$\lambda=0$时就是极大似然估计。常取$\lambda=1$，这时称为拉普卡斯平滑，显然，对任何${j=1,2, \cdots, n ; l=1,2, \cdots, S_{j}, \quad k=1,2, \cdots, K}$，有 \begin{array}{l}{P_{\lambda}\left(X^{(j)}=a_{j l} | Y=c_{k}\right)>0} \\ {\sum_{l=1}^{s_{j}} P\left(X^{(j)}=a_{j l} | Y=c_{k}\right)=1}\end{array}先验概率的贝叶斯估计是 P\left(Y=c_{k}\right)=\frac{\sum_{i=1}^{N} I\left(y_{i}=c_{k}\right) + \lambda}{N+K\lambda}例题 高斯朴素贝叶斯特征的可能性被假设为高斯。 概率密度函数： P\left(x_{i} | y_{k}\right)=\frac{1}{\sqrt{2 \pi \sigma_{y k}^{2}}} e x p\left(-\frac{\left(x_{i}-\mu_{y k}\right)^{2}}{2 \sigma_{y k}^{2}}\right)数学期望：$\mu$ 方差：$\sigma^2=\frac{\sum(X-\mu)^2}{N}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import numpy as npimport pandas as pdimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisfrom sklearn.model_selection import train_test_splitfrom collections import Counterimport math# datadef create_data(): iris = load_iris() df = pd.DataFrame(iris.data, columns=iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] data = np.array(df.iloc[:100, :]) return data[:, :-1], data[:, -1]class NaiveBayes: def __init__(self): self.model = None # 数学期望 @staticmethod def mean(X): return sum(X) / float(len(X)) # 标准差 def stdev(self, X): avg = self.mean(X) return math.sqrt(sum([pow(x - avg, 2) for x in X])) / float(len(X)) # 概率密度函数 def gaussian_probability(self, x, mean, stdev): exponent = math.exp(-(math.pow(x-mean, 2) / (2 * math.pow(stdev, 2)))) return (1 / (math.sqrt(2 * math.pi)*stdev)) * exponent # 处理X_train def summarize(self, train_data): summaries = [(self.mean(i), self.stdev(i)) for i in zip(*train_data)] return summaries # 分类别求出数学期望和方差 def fit(self, X, y): labels = list(set(y)) data = &#123;label: [] for label in labels&#125; for f, label in zip(X, y): data[label].append(f) self.model = &#123;label:self.summarize(value) for label, value in data.items()&#125; return "gaussianNB train done!" # 计算概率 def calculate_probabilities(self, input_data): probabilities = &#123;&#125; for label, value in self.model.items(): probabilities[label] = 1 for i in range(len(value)): mean, stdev = value[i] probabilities[label] *= self.gaussian_probability(input_data[i], mean, stdev) return probabilities # 类别 def predict(self, X_test): label = sorted(self.calculate_probabilities(X_test).items(), key=lambda x: x[-1])[-1][0] return label def score(self, X_test, y_test): right = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right += 1 return right / float(len(X_test))if __name__ == '__main__': X, y = create_data() X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3) model = NaiveBayes() model.fit(X_train, y_train) print(model.predict([4.4, 3.2, 1.3, 0.2])) score = model.score(X_test, y_test) print(score) # sklean实现 print("==sklean==") from sklearn.naive_bayes import GaussianNB clf = GaussianNB() clf.fit(X_train, y_train) print(clf.predict([[4.4, 3.2, 1.3, 0.2]])) print(clf.score(X_test, y_test)) 参考文献统计学习方法. 李航https://github.com/fengdu78/lihang-code/blob/master/%E7%AC%AC04%E7%AB%A0%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/4.NaiveBayes.ipynb]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-3-k近邻法]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-3-k%E8%BF%91%E9%82%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[$k$近邻算法$k$近邻法是一种基本分类与回归方法。以分类为例，$k$近邻的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。 $k$近邻算法思想：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的$k$个实例，这$k$个实例的多数属于某个类，就把该输入实例分为这个类。 算法：$k$近邻算法 输入：训练数据集$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i} \in \mathcal{X}=\mathbf{R}^{n}$为实例的特征向量，$y_{i} \in \mathcal{Y}=\{c_1,c_2,\dots,c_K\}$为实例的类别，$ i=1,2, \cdots, N$；实例特征向量$x$。 输出：实例$x$所属的类$y$。 （1）根据给定的距离度量，在训练集中找出与$x$最邻近的$k$个点，涵盖着$k$个点的$x$的邻域记作$N_k(x)$； （2）在$N_k(x)$中根据分类决策规则（如多数表决）决定$x$的类别$y$： y=\arg \max _{c_{j}} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right), \quad i=1,2, \cdots, N ; \quad j=1,2, \cdots, K式中，$I$为指示函数，即当$y_i=c_j$时$I$为1，否则$I$为0。 $k$近邻法的特殊情况是$k=1$的情形，称为最近邻算法。对于输入的实例点（特征向量）$x$，最近邻法将训练数据集中与$x$最邻近点的类作为$x$的类。$k$近邻没有显示的学习过程。 $k$近邻模型模型当训练集、距离度量、$k$值及分类决策规则确定后，对于任何一个新的输入实例，它所属的类唯一地确定，这相当于根据上述要素将特征空间划分为一些子空间，确定子空间里的每个点所属的类。 特征空间中，对每一个训练实例点$x_i$，距离该点比其他点更近的所有点组成一个区域，叫作单元。每个训练实例点拥有一个单元，所有训练实例点的单元构成对特征空间的一个划分。 距离度量特征空间中两个实例点的距离是两个实例点相似程度的反映。一般使用的是欧式距离，也可以是更一般的$L_p$距离。 设特征空间$\mathcal{X}$是$n$维实数向量空间$\mathbf{R}^n$，$x_{i}, x_{j} \in \mathcal{X}, \quad x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(n)}\right)^{\mathrm{T}}, \quad x_{j}=\left(x_{j}^{(1)}, x_{j}^{(2)}, \cdots, x_{j}^{(n)}\right)^{\mathrm{T}}$，$x_i, x_j$的$L_p$距离定义为： L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}当$p=2$时，称为欧式距离；当$p=1$时，称为曼哈顿距离。 $k$值的选择$k$值的选择会对$k$近邻法的结果产生重大影响。 （1）较小的$k$值：相当于用较小的邻域中的训练实例进行预测。”学习”的近似误差会减小，只有与输入实例较近的（相似的）训练实例才会对预测结果起作用。但缺点是”学习”的估计误差会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声，预测就会出错。$k$值的减小意味着整体模型变得复杂，容易发生过拟合。 （2）较大的$k$值：相当于用较大邻域中的训练实例进行预测。其优点是可以减少学习的估计误差。但缺点是学习的近似误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。$k$值的增大意味着整体的模型变得简单。 如果$k=N$，那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类，这时，模型过于简单，完全忽略训练实例中的大量有用信息，是不可取的的。 在实际应用中，$k$值一般取一个比较小的数值，通常可以采用交叉验证来选取最优的$k$值。 分类决策规则$k$近邻法中的分类决策规则往往是多数表决，即由输入实例的$k$个邻近的训练实例中的多数类决定输入实例的类。 多数表决规则：如果分类的损失函数为0-1损失函数，分类函数为 f: \mathbf{R}^{n} \rightarrow\left\{c_{1}, c_{2}, \cdots, c_{K}\right\}那么误分类的概率是 P(Y\not=f(X))=1-P(Y=f(X))对给定的实例$x \in \mathcal{X}$,其最近邻的$k$个训练实例点构成集合$N_k(x)$。如果涵盖$N_k(x)$的区域的类别是$c_j$，那么误分类率是 \frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i} \neq c_{j}\right)=1-\frac{1}{k} \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)要使误分类率最小即经验风险最小，就要使$ \sum_{x_{i} \in N_{k}(x)} I\left(y_{i}=c_{j}\right)$最大，所以多数表决规则等价于经验风险最小化。 $k$近邻法的实现：$kd$树实现$k$近邻法时，主要的问题是如何对训练数据进行快速$k$近邻搜索。 $k$近邻法最简单的实现方法是线性扫描，这时要计算输入实例与每一个训练实例的距离，当训练集很大时，计算非常耗时，这种方法是不可行的。 为了提高$k$近邻搜索的效率，考虑使用特殊的结构存储训练数据，以减少计算距离的次数，如$kd$树方法。 构造$kd$树$kd$树是一种对$k$维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。$kd$树是二叉树，表示对$k$维空间的一个划分(partition)。构造$kd$树相当于不断地用垂直于坐标轴的超平面将$k$维空间切分，构成一系列的$k$维超矩形区域。$kd$树的每个结点对应于一个$k$维超矩形区域. 构造$kd$树：构造根结点，使根结点对应于$k$维空间中包含所有实例点的超矩形区域；通过下面的递归方法，不断地对$k$维空间进行切分，生成子结点。在超矩形区域（结点）上选择一个坐标轴和在此坐标轴上的一个切分点，确定一个超平面，这个超平面通过选定的切分点并垂直于选定的坐标轴，将当前超矩形区域切分为左右两个子区域（子结点）；这时，实例被分到两个子区域。这个过程直到子区域内没有实例时终止（终止时的结点为叶结点）。在此过程中，将实例保存在相应的结点上。 通常，依次选择坐标轴对空间切分，选择训练实例点在选定坐标轴上的中位数为切分点，这样得到的$kd$树是平衡的。平衡的$kd$树搜索时的效率未必是最优的. 算法：构造平衡$kd$树 输入：k维空间数据集$T=\{x_1,x_2,\dots,x_N\}$，其中$x_{i}=\left(x_{i}^{(1)}, x_{i}^{(2)}, \cdots, x_{i}^{(k)}\right)^{\mathrm{T}}, \quad i=1,2, \cdots, N$。 输出：$kd$树。 （1）开始：构造根结点，使根结点对应于$k$维空间中包含所有实例点的超矩形区域； 选择$x^{(1)}$为坐标轴，以$T$中所有实例的$x^{(1)}$坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域，切分由通过切分点并于坐标轴$x^{(1)}$垂直的超平面实现。 由根结点生成深度为1的左、右子结点：左子结点对应于坐标$x^{(1)}$小于切分点的子区域，右子结点对应于坐标$x^{(1)}$大于切分点的子区域。 将落在切分超平面的实例点保存在根结点。 （2）重复：对深度为$j$的结点，选择$x^{(j)}$为切分的坐标轴，$l=j(mod ~k)+1$，以该结点的区域中所有实例的$x^{(j)}$坐标的中位数为且分点，将该结点对应的超矩形区域切分为两个子区域。切分由通过切分点并于坐标轴$x^{(j)}$垂直的超平面实现。 由该结点生成深度为$j+1$的左、右子结点：左子结点对应于坐标$x^{(j)}$小于切分点的子区域，右子结点对应于坐标$x^{(j)}$大于切分点的子区域。 将落在切分超平面的实例点保存在该结点。 （3）直到两个子区域没有实例点存在时停止，从而形成$kd$树的区域划分。 搜索$kd$树利用$kd$树可以省去对大部分数据点的搜索，从而减少搜索的计算量。 给定一个目标点，搜索其最近邻。首先找到包含目标点的叶结点；然后从该叶结点出发，依次回退到父结点；不断查找与目标点最邻近的结点，当确定不可能存在更近的结点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。 算法：用$kd$树的最近邻搜索 输入：已构造的$kd$树；目标点$x$； 输出：$x$的最近邻。 （1） 在$kd$树中找出包含目标点$x$的叶结点：从根结点出发，递归地向下访问$kd$树。若目标点$x$当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点。直到子结点为叶结点为止。 （2）以此叶结点为“当前最近点”。 （3）递归地向上回退，在每个结点进行以下操作: ​ （a） 如果该结点保存的实例点比当前最近点距离目标点更近，则以该实例点为“当前最近点“。 ​ （b）当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。具体地，检查另一子结点对应的区域是否与以目标点为球心、以目标点与“当前最近点”间的距离为半径的超球体相交。如果相交，可能在另一个子结点对应的区域内存在距目标点更近的点，移动到另一个子结点。接着，递归地进行最近邻搜索。如果不相交，向上回退。 （4）当回退到根结点时，搜索结束最后的“当前最近点”即为$x$的最近邻点。 如果实例点是随机分布的，$kd$树搜索的平均计算复杂度是$O(log N)$，这里$N$是训练实例数。$kd$树更适用于训练实例数远大于空间维数时的$k$近邻搜索。当空间维数接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。 $k$近邻算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class KNN: def __init__(self, X_train, y_train, n_neighbors = 3, p = 2): self.n = n_neighbors self.p = p self.X_train = X_train self.y_train = y_train def predict(self, X): # 初始化取出N个点放到结果列表里 knn_list = [] for i in range(self.n): dist = np.linalg.norm(X - self.X_train[i], ord=self.p) knn_list.append((dist, self.y_train[i])) # 对剩余的点计算距离: # 每次取出距离最大的点, 如果当前点距离更小, 则替换 # 最后的结果列表中保存的是距离最小的N个点 for i in range(self.n, len(self.X_train)): max_index = knn_list.index(max(knn_list, key=lambda x:x[0])) dist = np.linalg.norm(X - self.X_train[i], ord=self.p) if knn_list[max_index][0] &gt; dist: knn_list[max_index] = (dist, self.y_train[i]) # 对结果列表进行多数表决，返回多数类 knn = [k[-1] for k in knn_list] count_pairs = Counter(knn) max_count = sorted(count_pairs.items(), key=lambda x:x[1])[-1][0] return max_count def score(self, X_test, y_test): right_count = 0 for X, y in zip(X_test, y_test): label = self.predict(X) if label == y: right_count += 1 return right_count / len(X_test)if __name__ == '__main__': import numpy as np import pandas as pd import matplotlib.pylab as plt from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from collections import Counter iris = load_iris() df = pd.DataFrame(iris.data, columns= iris.feature_names) df['label'] = iris.target df.columns = ['sepal length', 'sepal width', 'petal length', 'petal width', 'label'] # 原始数据选取二维画图 plt.scatter(df[:50]['sepal length'], df[:50]['sepal width'], label='0') plt.scatter(df[50:100]['sepal length'], df[50:100]['sepal width'], label='1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() plt.show() # 选取前两维+label-&gt;data data = np.array(df.iloc[:100,[0,1,-1]]) X, y = data[:, :-1], data[:, -1] X_train, X_test, y_train, y_test = train_test_split(X,y, test_size=0.3) model = KNN(X_train, y_train) score = model.score(X_test, y_test) print(score) # sklearn实现 from sklearn.neighbors import KNeighborsClassifier clf_sk = KNeighborsClassifier() clf_sk.fit(X_train, y_train) score_sk = clf_sk.score(X_test, y_test) print(score_sk) $kd$树的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# kd_tree每个结点中主要包含的数据结构如下class KdNode(object): def __init__(self, dom_elt, split, left, right): self.dom_elt = dom_elt # k维空间向量结点 self.split = split # 整数(进行分割维度的序号) self.left = left # 该结点分割超平面子空间构成的kd-tree self.right = right # 该结点分割超平面右子空间构成kd-treeclass KdTree(object): def __init__(self, data): k = len(data[0]) # 数据维度 # 按split维划分数据集创建KdNode def CreateNode(split, data_set): if not data_set: return None data_set.sort(key = lambda x: x[split]) split_pos = len(data_set) // 2 median = data_set[split_pos] split_next = (split + 1) % k return KdNode(median, split, CreateNode(split_next, data_set[:split_pos]), CreateNode(split_next, data_set[split_pos+1:])) self.root = CreateNode(0, data)# KDTree的前序遍历def preorder(root): print(root.dom_elt) if root.left: preorder(root.left) if root.right: preorder(root.right)# 对构建好的kd树进行搜索，寻找与目标点最近的样本点from math import sqrtfrom collections import namedtuple# 定义一个namedtuple，分别存放最近坐标点、最近距离和访问过的结点树result = namedtuple("Result_tuple", "nearest_point nearest_dist nodes_visited")def find_nearest(tree, point): k = len(point) # 数据维度 def travel(kd_node, target, max_dist): if not kd_node: return result([0] * k, float("inf"), 0) nodes_visited = 1 s = kd_node.split # 进行分割的维度 pivot = kd_node.dom_elt # 进行分割的轴 if target[s] &lt;= pivot[s]: # 如果目标点第s维小于分割轴的对应值（目标离左子树更近） nearer_node = kd_node.left # 下一个访问结点为左子树根节点 further_node = kd_node.right # 同时记录下右子树 else: # 目标离右子树更近 nearer_node = kd_node.right further_node = kd_node.left temp1 = travel(nearer_node, target, max_dist) # 进行遍历找到包含目标点的区域 nearest = temp1.nearest_point # 进行遍历找到包含目标点的区域 dist = temp1.nearest_dist # 更新最近距离 nodes_visited += temp1.nodes_visited if dist &lt; max_dist: max_dist = dist # 最近点将在目标点为球心，max_dist为半径的超球体内 temp_dist = abs(pivot[s] - target[s]) # 第s维上目标点与分割超平面的距离 if max_dist &lt; temp_dist: # 判断超球面是否与超平面相交 return result(nearest, dist, nodes_visited) # 不想交则直接可以返回 # 计算目标点与分割点的欧式距离 temp_dist = sqrt(sum((p1-p2)**2 for p1, p2 in zip(pivot, target))) if temp_dist &lt; dist: # 如果更近 nearest = pivot dist = temp_dist max_dist = dist # 检查另一个子结点对应的区域是否有更近的点 temp2 = travel(further_node, target, max_dist) nodes_visited += temp2.nodes_visited if temp2.nearest_dist &lt; dist: # 如果另一个子结点内存在更近距离 nearest = temp2.nearest_point # 更新最近点 dist = temp2.nearest_dist # 更新最近距离 return result(nearest, dist, nodes_visited) return travel(tree.root, point, float("inf"))if __name__ == '__main__': data = [[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]] kd = KdTree(data) preorder(kd.root) # 寻找[3,4.5]最近邻的点 res = find_nearest(kd, [3, 4.5]) print(res) from random import random # 产生一个k维随机变量，每维分量值在0~1之间 def random_point(k): return [random() for _ in range(k)] # 产生n个k维随机向量 def random_points(k, n): return [random_point(k) for _ in range(n)] # 构建包含四十万个3维空间样本点的kd树 N = int(4e5) kd2 = KdTree(random_points(3, N)) # 四十万个样本点中寻找离目标最近的点 res2 = find_nearest(kd2, [0.1, 0.5, 0.8]) print(res2) 参考文献统计学习方法. 李航https://github.com/fengdu78/lihang-code/blob/master/%E7%AC%AC03%E7%AB%A0%20k%E8%BF%91%E9%82%BB%E6%B3%95/3.KNearestNeighbors.ipynb]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-2-感知机]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2-%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[感知机感知机是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取+1和-二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型。基于误分类的损失函数，利用梯度下降法对损失函数进行最小化，求得感知机模型。 感知机分为原始形式和对偶形式，利用学习得到的感知机模型对新的输入实例进行分类，是神经网络与支持向量机的基础。 感知机模型假设输入空间（特征空间）$\mathcal{X} \subseteq \mathbf{R}^{n}$，输出空间是$\mathcal{Y}=\{+1,-1\}$。输入$x \in \mathcal{X}$表示实例的特征向量，对应于输出空间（特征空间）的点；输出$y \in \mathcal{Y}$表示实例的类别。感知机表示输入空间到输出空间的函数： f(x)=\operatorname{sign}(w \cdot x+b)$w \in \mathbf{R}^{n}$和$b \in \mathbf{R}$为感知机模型参数，前者为权值向量，后者为偏置。$w \cdot x$表示$w$和$x$的内积，sign是符号函数： \operatorname{sign}(x)=\left\{\begin{array}{ll}{+1,} & {x \geqslant 0} \\ {-1,} & {x0因此，误分类点$x_i$到超平面$S$的距离是： -\frac{1}{\|w\|} y_{i}\left(w \cdot x_{i}+b\right)假设超平面$S$的误分类点集合为$M$，那么所有误分类点到超平面$S$的总距离为： -\frac{1}{\|w\|} \sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)不考虑$-\frac{1}{|w|}$，可以得到感知机$\operatorname{sign}(w \cdot x+b)$学习的损失函数为： L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)这个损失函数就是感知机学习的经验风险函数。显然损失函数是非负的，如果没有误分类点，损失函数值为0。而且，误分类点越少，误分类点离超平面越近，损失函数越小。一个特定样本点的损失函数是参数$w$和$b $的线性函数。对于给定训练集，损失函数$L(w, b)$是参数$w$和$b $的连续可导函数。 感知机的学习策略就是在假设空间中选取损失函数最小的模型参数$w$和$b $。 感知机学习算法的原始形式给定一个训练数据集 T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}其中$x_{i} \in \mathcal{X}=\mathbf{R}^{n}, \quad y_{i} \in \mathcal{Y}=\{-1,1\}, \quad i=1,2, \cdots, N$，求参数$w$和$b $，使其为以下损失函数极小化问题 \min _{w, b} L(w, b)=-\sum_{x_{i} \in M} y_{i}\left(w \cdot x_{i}+b\right)其中$M$为误分类点的集合。 采用随机梯度下降法求解。首先，任意选取一个超平面$w_0，b_0$，然后用梯度下降法不断地极小化目标函数。极小化过程中不是一次使$M$中所有误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。 假设误分类点集合$M$是古典的，那么损失损失$L(w, b)$的梯度由 \begin{array}{c}{\nabla_{w} L(w, b)=-\sum_{x_{i} \in M} y_{i} x_{i}} \\ {\nabla_{b} L(w, b)=-\sum_{x_{i} \in M} y_{i}}\end{array}给出。 随机选取一个误分类点$(x_i, y_i)$，对$w, b$进行更新： \begin{array}{c}{w \leftarrow w+\eta y_{i} x_{i}} \\ {b \leftarrow b+\eta y_{i}}\end{array}其中$\eta(0&lt;\eta\le1)$是步长或者学习率。通过迭代可以使损失函数不断减小，直到为0。 算法1：感知机学习算法的原始形式 输入：训练数据集$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i} \in \mathcal{X}=\mathbf{R}^{n}, \quad y_{i} \in \mathcal{Y}=\{-1,1\}, \quad i=1,2, \cdots, N$，学习率$\eta(0&lt;\eta\le1)$； 输出：$w, b$；感知机模型$f(x)=\operatorname{sign}(w \cdot x+b)$。 （1）选取初值$w_0，b_0$； （2）在训练集中选取数据$(x_i, y_i)$； （3）如果$ y_{i}\left(w \cdot x_{i}+b\right)\le0$ \begin{array}{c}{w \leftarrow w+\eta y_{i} x_{i}} \\ {b \leftarrow b+\eta y_{i}}\end{array}（4）转至（2），直到训练集中没有误分类点。 算法解释：当一个实例点被误分类，即位于分离超平面的错误一侧时，则调整$w,b$的值，使分离超平面向该误分类点的一侧移动，以减少该误分类点与超平面的距离，直至超平面越过该误分类点使其被正确分类。 当然感知机学习算法由于采用不同的初值或选取不同的误分类点，解可以不同。 算法收敛性：对于线性可分数据集感知机学习算法原始形式收敛，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。详细证明略。 感知机学习算法的对偶形式感知机学习算法的原始形式和对偶形式与SVM的原始形式和对偶形式对应。 对偶形式的基本思想是将$w$和$b$表示为实例$x_i$和标记$y_i$的线性组合的形式，通过求解其系数而求得$w$和$b$。将初始值$w_0$，$b_0$都设为0，原始形式中对误分类点$(x_i, y_i)$通过 \begin{array}{c}{w \leftarrow w+\eta y_{i} x_{i}} \\ {b \leftarrow b+\eta y_{i}}\end{array}逐步修改$w$和$b$，设修改$n$次，则$w$，$b$关于$(x_i, y_i)$的增量分别是$\alpha_iy_ix_i$和$\alpha_i y_i$，这里$\alpha_i=n_i\eta$。因此最后学习到的$w$和$b$分别为 \begin{array}{l}{w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}} \\ {b=\sum_{i=1}^{N} \alpha_{i} y_{i}}\end{array}当$\eta=1$时，表示第$i$个实例点由于误分而进行更新的次数。实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响最大。 算法2：感知机学习算法的对偶形式 输入：训练数据集$T=\left\{\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{N}, y_{N}\right)\right\}$，其中$x_{i} \in \mathcal{X}=\mathbf{R}^{n}, \quad y_{i} \in \mathcal{Y}=\{-1,1\}, \quad i=1,2, \cdots, N$，学习率$\eta(0&lt;\eta\le1)$； 输出：$\alpha, b$；感知机模型$f(x)=\operatorname{sign}(\sum_{j=1}^{N} \alpha_{j} y_{j} x_{j} \cdot x+b)$，其中$\alpha=\left(\alpha_{1}, \alpha_{2}, \cdots, \alpha_{N}\right)^{\mathrm{T}}$ （1）选取初值$\alpha\leftarrow0，b\leftarrow0$； （2）在训练集中选取数据$(x_i, y_i)$； （3）如果$·$ \begin{array}{c}{\alpha_i \leftarrow \alpha_i+\eta} \\ {b \leftarrow b+\eta y_{i}}\end{array}（4）转至（2），直到训练集中没有误分类点。 算法结束之后带入${w=\sum_{i=1}^{N} \alpha_{i} y_{i} x_{i}} $得到最终的$w$。 算法解释：对偶形式中训练实例仅以內积的形式出现。为了方便，可以预先将训练集中实例间的內积计算出来并以矩阵的形式存储，即Gram矩阵$G=\left[x_{i} \cdot x_{j}\right]_{N \times N}$。 与原始形式一样，感知机学习算法的对偶形式迭代也是收敛的，存在多个解。 实战前文已经详细介绍了感知机的原理，包括原始形式和对偶形式，使用iris数据集中两个分类的数据和[sepal length，sepal width]作为特征对感知机进行实现。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisclass Perceptron: def __init__(self, data, label, learning_rate = 1): self.w = np.zeros(data.shape[1]) self.b = 0 self.eta = learning_rate self.X = data self.y = label def sign(self, x, w, b): return np.dot(x, w) + b def fit(self): flag = False while not flag: wrongNum = 0 for x, y in zip(self.X, self.y): if y * self.sign(x, self.w, self.b) &lt;= 0: self.w += np.dot(y, x) * self.eta self.b += y * self.eta wrongNum += 1 if wrongNum == 0: flag = True print("Fit finished") def fit_dual(self): a = np.zeros(self.X.shape[0]) G = self.X @ self.X.T flag = False while not flag: wrongNum = 0 for i, y in enumerate(self.y): if y * self.sign(a * self.y, G[i], self.b) &lt;= 0: a[i] += self.eta self.b += self.eta * y wrongNum += 1 if wrongNum == 0: flag = True print("Fit dual finished") for j in range(self.X.shape[0]): self.w += a[j] * self.X[j] * self.y[j]if __name__ == '__main__': iris = load_iris() data = iris["data"][:100, :2] label = iris["target"][:100] label = np.array([1 if i == 1 else -1 for i in label]) flag = 1 if flag == 0: # 原始形式 model = Perceptron(data, label, learning_rate=1) model.fit() else: # 对偶形式 model = Perceptron(data, label, learning_rate=1) model.fit_dual() w, b = model.w, model.b plt.scatter(data[:50, 0], data[:50, 1], label='-1') plt.scatter(data[50:100, 0], data[50:100, 1], label='1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() xHyper = np.linspace(4, 7, 10) yHyper = -(w[0] * xHyper + b) / w[1] plt.plot(xHyper, yHyper, 'r') plt.show() 原始形式结果：对偶形式结果：可以看到原始形式和对偶形式都能将数据进行分类。 sklearn实现12345678910111213141516171819202122232425from sklearn.linear_model import Perceptronimport numpy as npimport matplotlib.pyplot as pltfrom sklearn.datasets import load_irisif __name__ == '__main__': iris = load_iris() data = iris["data"][:100, :2] label = iris["target"][:100] label = np.array([1 if i == 1 else -1 for i in label]) model = Perceptron(max_iter=1000, tol=None) model.fit(data, label) w, b = model.coef_[0], model.intercept_ plt.scatter(data[:50, 0], data[:50, 1], label='-1') plt.scatter(data[50:100, 0], data[50:100, 1], label='1') plt.xlabel('sepal length') plt.ylabel('sepal width') plt.legend() xHyper = np.linspace(4, 7, 10) yHyper = -(w[0] * xHyper + b) / w[1] plt.plot(xHyper, yHyper, 'r') plt.show() 运行结果为：其中tol 参数规定了如果本次迭代的损失和上次迭代的损失之差小于一个特定值时，停止迭代。所以不同的tol值会有不同的解。 参考文献https://github.com/fengdu78/lihang-code/blob/master/%E7%AC%AC02%E7%AB%A0%20%E6%84%9F%E7%9F%A5%E6%9C%BA/2.Perceptron.ipynbhttps://github.com/cherichy/statistical_learning/blob/master/python/perceptron.py统计学习方法. 李航]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-1-概论]]></title>
    <url>%2F2019%2F10%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1-%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[统计学习学习：如果一个系统能够通过执行某个过程改进它的性能，就是学习。分类：监督学习、非监督学习、半监督学习和强化学习。三要素：模型、策略和算法。 统计学习的步骤： 得到一个有限的训练数据集合； 确定包含所有可能的模型的假设空间，即学习模型的集合； 确定模型选择的准则，即学习的策略； 实现求解最优模型的算法，即学习的算法； 通过学习方法选择最优模型； 利用学习的最优模型对新数据进行预测和分析。 监督学习学习一个模型，使模型能够对任意给定的输入，对其相应的输出作出一个好的预测。 输入空间：输入的所有可能取值的集合。输出空间：输出的所有可能取值的集合。特征空间：特征向量存在的空间。有时输入空间与特征空间相同，有时不同，需要将输入空间映射到特征空间。假设空间：输入空间到输出空间的映射模型的集合，假设空间的确定意味着学习范围的确定，学习的目的就是找到最好的模型。 回归问题：输入变量与输出变量均为连续变量。分类问题：输出变量为有限个离散变量。标注问题：输入变量与输出变量均为变量序列。 联合概率分布：监督学习假设输入与输出的随机变量$X$和$Y$遵循联合概率分布$P(X,Y)$。在学习过程中，假定该这一联合概率分布存在，但对学习系统来说，联合概率分布的具体定义是未知的。训练数据和测试数据被看做是依联合概率分布$P(X,Y)$独立同分布产生的。 学习三要素一、模型模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。 决策函数： \mathcal{F}=\left\{f | Y=f_{\theta}(X), \theta \in \mathbf{R}^{n}\right\}条件概率分布： \mathcal{F}=\left\{P\left|P_{\theta}(Y | X), \theta \in \mathbf{R}^{n}\right\}\right.由决策函数表示的模型为非概率模型，由条件概率表示的模型为概率模型。 二、策略损失函数：度量模型一次预测的好坏。常见损失函数有以下几种： 0-1函数函数： L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right. 平方损失函数： L(Y, f(X))=(Y-f(X))^{2} 绝对损失函数： L(Y, f(X))=|Y-f(X)| 对数损失函数 ： L(Y, P(Y | X))=-\log P(Y | X)损失函数值越小，模型就越好。 风险函数（期望损失）：度量平均意义下模型预测的好坏。由于模型的输入、输出$(X,Y)$是随机变量，遵循联合分布$P(X, Y)$，所以损失函数的期望是： R_{\mathrm{exp}}(f)=E_{p}[L(Y, f(X))]=\int_{\mathrm{x*y}} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y这是理论上模型$f(X)$关于联合分布$P(X, Y)$的平均意义下的损失。学习的目的就是选择期望风险最小的模型，但联合分布$P(X, Y)$未知，$R_{\mathrm{exp}}(f)$不能直接计算。 经验风险（经验损失）：给定$N$个样本的训练集，模型$f(X)$关于训练数据集的平均损失称为经验损失： R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)期望风险$R_{\mathrm{exp}}(f)$是模型关于联合分布的期望损失，经验风险$R_{\mathrm{emp}}(f)$是模型关于训练集的平均损失。根据大数定律，当样本容量$N$趋于无穷时，经验风险$R_{\mathrm{emp}}(f)$趋于期望风险$R_{\mathrm{exp}}(f)$，所以很自然的想法是用经验风险估计期望风险。但在样本数比较小的时候，需要引入结构风险对经验风险进行矫正。 经验风险最小化和结构风险最小化经验风险最小化认为经验风险最小的模型就是最优的模型，优化目标为： \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)当样本量足够大时，经验风险最小化能保证有很好的学习效果。极大似然估计就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。 但样本容量很小时，经验风险最小化最小化会产生过拟合现象。 结构风险最小化是为了防止过拟合而提出来的策略，其在经验风险上加上表示模型复杂度的正则化项。 R_{\mathrm{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)其中$J(f)$为模型的复杂度，是定义在假设空间$\mathcal{F}$上的泛函。模型$f$越复杂，复杂度$J(f)$就越大，反之模型$f$越简单，复杂度$J(f)$就越小。复杂度表示了对复杂模型的惩罚。$\lambda \ge 0$是系数，用以权衡经验风险和模型复杂度，结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据和未知的测试数据都有较好的预测。 贝叶斯估计中的最大后验估计就是结构风险最小化的一个例子。当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。 结构风险最小化的策略认为结构风险最小的模型是最优的模型。 \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)三、算法算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要选择合适的算法求解最优化问题。 模型评估与模型选择假设学习到的模型是$Y=\hat{f}(X)$。训练误差是模型$Y=\hat{f}(X)$关于训练数据集的平均损失： R_{\mathrm{emp}}(\hat{f})=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, \hat{f}\left(x_{i}\right)\right)测试误差是模型$Y=\hat{f}(X)$关于测试数据集的平均损失： e_{\mathrm{test}}=\frac{1}{N^{\prime}} \sum_{i=1}^{N^{\prime}} L\left(y_{i}, \hat{f}\left(x_{i}\right)\right)泛化能力：学习方法对未知数据的预测能力。过拟合：随着模型的复杂度比真实模型更高，所选择的模型包含的参数过多，模型对已知数据预测得很好，但对未知数据预测很差。 模型选择旨在避免过拟合并提高模型的预测能力。 下图描述了训练误差和测试误差与模型的复杂度之间的关系。当模型的复杂度增大时，训练误差会逐渐减小并趋向于0；而测试误差会先减小，达到最小值后又增大。当选择的模型复杂度过大时，过拟合现象就会发生。因此需要选择适当的模型，以达到测试误差最小的目的。常用的模型选择方法：正则化与交叉验证。 模型选择之正则化正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项，正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。通常，正则化项是模型参数向量的范数。一般形式为： \min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$L_2$正则： L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}\|w\|^{2}$L_1$正则： L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\lambda\|w\|_{1}第一项的经验风险较小的模型可能较复杂，这时第二项的模型复杂度会较大。正则化的作用是选择经验风险与模型复杂度同时较小的模型。 正则化符合奥卡姆原理：在所有可能选择的模型中，能够很好地解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。 先验：从贝叶斯估计的角度来看，正则化项对应于模型的先验概率，通常较复杂的模型有较大的先验概率，简单的模型有较小的先验概率。 模型选择之交叉验证 简单交叉验证：首先随机地将数据分为两部分，一部分作为训练集(70%)，另一部分作为测试集(30%)；然后用训练集在各种条件下训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。 $S$折交叉验证：首先随机地将已给数据切分为$S$个互不相交的大小相同的子集；然后利用$S-1$个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的$S$中选择重复进行；最后选出$S$次评测中平均测试误差最小的模型。 留一交叉验证：$S$折交叉验证的特殊情形是$S=N$，称为留一交叉验证，往往在数据缺乏的情况下使用。 泛化能力泛化能力：学习到的模型对未知数据的预测能力。泛化误差：如果学习的模型是$\hat{f}$，那么用这个模型对未知数据预测的误差即为泛化误差： R_{\mathrm{exp}}(\hat{f})=E_{P}[L(Y, \hat{f}(X))]=\int_{x*y } L(y, \hat{f}(x)) P(x, y) dxd y泛化误差反映了学习方法的泛化能力，如果一种方法学习的模型比另一种方法学习的模型有更小的泛化误差，那么这种方法就更有效。泛化误差就是所学习到的模型的期望风险。 泛化误差上界通常通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。泛化误差上界的性质：它是样本容量的函数，当样本容量增加时，泛化上界趋于0；它是假设空间容量的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。 关于$f$的期望风险和经验风险如下： R(f)=E[L(Y, f(X))] \hat{R}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)经验风险最小化函数是： f_{N}=\arg \min _{f \in \mathcal{F}} \hat{R}(f)人们更关心$f_{N}$的泛化能力： R\left(f_{N}\right)=E\left[L\left(Y, f_{N}(X)\right)\right]对于二分类问题，当假设空间是有限个函数的集合$\mathcal{F}=\left\{f_{1}, f_{2}, \cdots, f_{d}\right\}$，泛化误差上界为： R(f) \leqslant \hat{R}(f)+\varepsilon(d, N, \delta)其中 \varepsilon(d, N, \delta)=\sqrt{\frac{1}{2 N}\left(\log d+\log \frac{1}{\delta}\right)}不等式中左端$R(f)$是泛化误差，右端为泛化误差上界，第一项是训练误差，训练误差越小，泛化误差也越小，第二项是$N$的的单调递减函数，当$N$趋于无穷时趋于0；同时它也是$\sqrt{\log d}$阶的函数，假设空间$\mathcal{F}$包含的函数越多，其值越大。 生成模型与判别模型生成方法由数据学习联合分布$P(X,Y)$，然后求出条件概率分布$P(X|Y)$作为预测的模型，即生成模型： P(Y | X)=\frac{P(X, Y)}{P(X)}这样的方法之所以称为生成方法，是因为模型表示了给定输入$X$产生输出$Y$的生成关系。常见的有朴素贝叶斯和隐马尔科夫模型。 判别方法由数据直接学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型，即判别模型。判别模型关心的是对给定的输入$X$，应该预测什么样的输出$Y$。常见的有$k$近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法和条件随机场。 生成方法的特点：生成方法可以还原出联合概率分布$P(X,Y)$，而判别方法则不能；生成方法的学习收敛速度更快，即当样本容量增加时，学到的模型可以更快地收敛于真实模型；当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。 判别方法的特点：判别方法直接学习的是条件概率$P(Y|X)$或决策函数$f(X)$，直接面向预测，往往学习的准确率更高；由于直接学习$P(Y|X)$或$f(X)$，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。 分类问题在监督学习中，当输出变量$Y$取有限个离散值时，则为分类问题。这时，输入变量$X$可以是离散的，也可以是连续的。 准确率：分类器正确分类的样本数与总样本数之比。 A = \frac{TP+TN}{TP+TN+FP+FN}精确率：分类正确的正样本个数占分类器判定为正样本的样本个数的比例。 P = \frac{TP}{TP+FP}召回率：分类正确的正样本个数占真正的正样本个数的比例。 R = \frac{TP}{TP+FN}$F_1$值：精确率和召回率的调和均值。 {\frac{2}{F_{1}}=\frac{1}{P}+\frac{1}{R}} {F_{1}=\frac{2 T P}{2 T P+F P+F N}}常见分类方法：$k$近邻法、感知机、朴素贝叶斯、决策树、决策列表、逻辑斯蒂回归模型、支持向量机、提升方法、贝叶斯网络、神经网络。 标注问题标注问题是分类问题的一个推广。标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目的在于学习一个模型，使它能够对观测序列给出标记序列作为预测。 标注问题的评价指标和分类指标一样，常用的有标注准确率、精确率和召回率。 常用的标注方法有：隐马尔科夫模型、条件随机场。 回归问题回归用于预测输入变量和输出变量之间的关系。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测位置数据。 回归学习最常用的损失函数是平方损失函数，可以由最小二乘法求解。 参考文献统计学习方法. 李航]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络]]></title>
    <url>%2F2019%2F08%2F24%2FStudyNotes%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[1 概述网络的网络网络把主机连接起来，而互联网是把不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等联网设备，个人或机构向ISP缴纳一定的费用就可以接入互联网。目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP，区域ISP和接入ISP。互联网交换点IXP允许两个ISP直接相连而不用经过第三个ISP。 主机之间的通信方式客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。对等（P2P）：不区分客户和服务器。 电路交换和分组交换电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到10%。 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组不会互相影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。在一个邮局通信系统中，邮局收到一封邮件之后，先存储下来，然后把相同目的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也利用了存储转发过程。 时延总时延=排队时延+处理时延+传输时延+传播时延 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据，进行差错校验或查找适当的路由等。 传输时延主机或路由器传输数据帧所需要的时间。 \operatorname{del} a y=\frac{l(b i t)}{v(b i t / s)}其中$l$表示数据帧的长度，$v$表示传输速率。 传播延时电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 \operatorname{del} a y=\frac{l(m)}{v(m / s)}其中$l$表示信道长度，$v$表示电磁波在信道上的传播速度$3*10^8m/s$。 计算机网络体系结构OSI分层（七层）物理层，数据链路层，网络层，传输层，会话层，表示层，应用层TCP/IP分层（四层）网络接口层，网络层，传输层，应用层五层协议（五层）物理层，数据链路层，网络层，传输层，应用层 每一层的协议如下：物理层：RJ45，CLOCK，IEEE802.3（中继器，集线器）数据链路层：PPP，FR，HDLC，VLAN，MAC（网桥，交换机）网络层：IP，ICMP，ARP，RARP，OSPF，IPX，RIP，IGRP（路由器）传输层：TCP，UDP，SPX会话层：NFS，SQL，NETBIOS，RPC表示层：JPEG，MPEG，ASII应用层：TFTP，DNS，Telnet，SMTP，WWW，NFS 每一层的作用：物理层：通过媒介传输比特，确定机械以及电气规范。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。（中继器、集线器） 数据链路层：将比特组装成帧和点到点的传递。网络层针对的是主机之间的数据传输服务，而主机之间可以有很多链路，链路层就是为同一链路的主机提供数据传输服务，数据链路层把网络层传下来的分组封装成帧。（网桥、交换机） 网络层：负责数据包从源到宿的传递和网际互联。为主机提供数据传输服务，而传输层协议是为主机中的进程提供数据传输服务，网络层把传输层传递下来的报文段或者用户数据报封装成分组。（路由器） 传输层：提供端到端的可靠报文传递和错误恢复。主要包括TCP和UDP，TCP（传输控制协议），提供面向连接、可靠的数据传输服务，数据单位为报文段；UDP（用户数据报协议），提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务。 会话层：建立、管理和终止会话。 表示层：对数据进行翻译，加密和压缩，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 应用层：允许访问OSI环境的手段。例如HTTP、DNS等协议，数据单位是报文。 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。 各种协议的介绍ICMP协议：因特网控制报文协议，它是TCP/IP协议族的一个子协议，用于IP主机、路由器之间传递控制消息； FTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务； HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其便捷、快速的方式，适用于分布式超媒体信息系统； NAT协议：网络地址转换接入广域网技术，是一种将私有（保留）地址转化为合法IP地址的转换技术； DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 交换机、路由器、网关交换机工作在数据链路层，具有自学习能力，学习的是交换表的内容，交换表中存储着MAC地址到接口的映射。正式由于这种自学能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 路由器工作在网络层，主要完成两个功能：路由选择和分组转发，路由选择指的是决定数据包从来源端到目的所经过的路由路径；转发是指将路由器输入端的数据包送至适当的路由输出端。 网关是连接两个网络的设备，能在网络间传递数据包，区别于路由器，网关中并没有路由表，它只能按照预先设定的不同网段来进行转发。 2 物理层通信方式根据信息在传输线上的传送方向，分为以下三种通信方式：①单工通信：单向传输②半双工通信：双向交替传输；③全双工通信：双向同时传输 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 3 数据链路层基本问题封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要把数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 信道分类广播信道一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突。主要有两种控制方法进行协调，一个是使用信道复用技术，一个是使用CSMA/CD协议。 点对点信道一对一通信。因此不会发生冲突，使用PPP（Point to Point Protocol）协议进行控制。 信道复用技术频分复用频分复用的所有主机在相同的时间占用不同的频率带宽资源。时分复用时分复用的所有主机在不同的时间占用相同的频率带宽资源。 使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 码分复用为每个用户分配$m$ bit的码片，并且所有的码片正交，对于任意两个码片S和T有 \frac{1}{m} \vec{S} \cdot \vec{T}=0为了讨论方便，取 $m=8$，设码片S为$00011011$，在拥有该码片的用户发送比特1时就发送该码片，发送比特0时就发送该码片的反码$11100100$.在计算时将$00011011$记作（-1-1-1+1+1-1+1+1=1），可以得到 \frac{1}{m} \vec{S} \cdot \vec{S}=1 \frac{1}{m} \vec{S} \cdot \overrightarrow{S^{\prime}}=-1其中S’为S的反码。当接收端使用码片S对接收到的数据进行內积运算时，结果为0的是其他用户发送的数据，结果为1的是用户发送的比特1，结果为-1是用户发送的比特0。码分复用需要发送的数据量为原先的m倍。 CSMA/CDCSMA/CD表示载波监听多点接入/碰撞检测Carrier Sense Multiple Access with Collision Detection。 多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延，还是有可能发生碰撞。 记端到端的传播时延为T，最先发送的站点最多经过2T就可以知道是否发生了碰撞，称2T为争用期。只有经过争用期还没有检测到碰撞，才能肯定发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送，这个时间采用截断二进制指数退避算法来确定，从离散的整数集合${0,1，…,(2^k-1)}$中随机取出一个数，然后取$r$倍的争用期作为重传等待时间。 PPP协议PPP协议表示Point to Point protocol。互联网用户通常需要连接到某个ISP之后才能接入到互联网，PPP协议是用户计算机和ISP进行通信时所使用的数据链路协议。PPP的帧格式： F字段为帧的定界符 A和C字段暂时没有意义 FCS字段是使用CRC的校验序列 信息部分的长度不超过1500 MAC地址MAC标识 Media Access Control 介质访问控制。MAC地址是链路层地址，长度为6字节（48位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个MAC地址，例如笔记本电脑普遍存在无限网络适配器和有线网络适配器，因此就有两个MAC地址。 局域网局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。主要有以太网、令牌环网、FDDI（Fiber Distributed Data Interface，光纤分布式数据接口）和ATM（asynchronous transfer mode，异步传输模式）等局域网技术，目前以太网占据着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类：星型，环型，总线型。 以太网以太网是一种星型拓扑结构局域网。早期使用集线器进行连接，集线器是一种物理层设备，作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到了两个不同接口的帧，那么就发生了碰撞。 目前以太网使用了交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发。以太网帧格式： 类型：标记上层使用的协议 数据：长度在46~1500之间，如果太小则需要填充 FCS：帧检验序列，使用的是CRC检验方法 交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着MAC地址到接口的映射。正是由于这种自学能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 虚拟局域网（VLAN）虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。例如下图中（A1,A2,A3,A4）属于一个虚拟局域网，A1发送的广播会被A2,A3,A4收到，而其他站点收不到。使用VLAN干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连交换机。IEEE定义了一种扩展的以太网帧格式802.1Q，它在标准以太网帧上加进了4字节首部VLAN标签，用于表示该帧属于哪一个虚拟局域网。 4 网络层概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用IP协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。与IP协议配套使用的还有三个协议： 地址解析协议ARP（address resolution protocol） 网际控制报文协议ICMP（Internet control message protocol） 网际组管理协议IGMP（Internet group management protocol） IP数据报格式 版本：有4（ipv4）和6（ipv6）两个值 首部长度：占4位，因此最大值为15。值为1表示是1个32位字的长度，也就是4字节。因为首部固定长度为20字节，因此最小值为5.如果可选字段的长度不是4字节的整数倍，就用尾部的填充部分来填充。 区分服务：用来获得更好的服务，一般情况下不使用。 总长度：包括首部长度和数据部分长度。 生存时间：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子，以路由器跳数为单位，当TTL为0时就丢弃数据报。 协议：指出携带的数据应该上交给哪个协议进行处理，例如ICMP，TCP，UDP。 首部检验和：因为数据报每经过一个路由器，都要重新计算校验和，因此检验和不包含数据部分可以减少计算的工作量。 标识：在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移：和标识符一起，用于发生分片的情况，片偏移的单位为8字节。 IP地址编址方式IP地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 分类由两部分组成，网络号和主机号，其中不同的分类具有不同的网络号长度，并且是固定的。IP地址={&lt;网络号&gt;,&lt;主机号&gt;} IP地址的分类A类地址：以0开头，第一个字节范围：1~126（1.0.0.0-126.255.255.255）B类地址：以10开头，第一个字节范围：128-191（128.0.0.0-191.255.255.255）C类地址：以110开头，第一个字节范围：192-223（192.0.0.0-223.255.255.255）D类地址：以1110开头，第一个字节范围：224-239（224.0.0.0-239.255.255.255）；作为多播使用E类地址：以1111开头，保留其中A,B,C是基本类，D,E类作为多播和保留使用。 留用的内部私有地址A类：10.0.0.0-10.255.255.255B类：172.16.0.0-172.31.255.255C类：192.168.0.0-192.168.255.255 IP地址与子网掩码相与得到网络号：123 192.168.2.110&amp; 255.255.255.0 192.168.2.0 主机号全为0的是网络号（如192.168.2.0），主机号全为1的为广播地址（192.168.2.255）。 子网划分通过在主机号字段中拿出一部分作为子网号，把两级IP地址划分为三级IP地址。IP地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;} 要使用子网，必须配置子网掩码。一个B类地址的默认子网掩码为255.255.0.0，如果B类地址的子网占两个比特，那么子网掩码为1111111 11111111 11000000 00000000，也就是255.255.192.0。注意，外部网络看不到子网的存在。 无分类无分类编址CIDR消除了传统A类、B类和C类地址以及划分子网的概念，使用网络前缀和主机号来对IP地址进行编码，网络前缀的长度可以根据需要变化。IP地址={&lt;网络前缀号&gt;,&lt;主机号&gt;} CIDR的记法上采用在IP地址后面加上网络前缀长度的方法，例如128.14.35.7/20表示前20位为网络前缀。 CIDR的地址掩码可以继续称为子网掩码，子网掩码首1长度为网络前缀的长度。 一个CIDR地址块中有很多地址，一个CIDR表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为构成超网。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 地址解析协议ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP数据报的源地址和目的地址始终不变，而MAC地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 ARP工作原理1 首先，每个主机都会在自己的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址的对应关系； 2 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包的内容包括：源主机IP地址，源主机MAC地址，目的主机的IP地址； 3 当本网络的所有主机收到该ARP数据包时，首先检查数据报中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址； 4 源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表中，并利用此信息发送数据，如果源主机已知没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 逆地址解析协议RARPRARP协议是逆地址解析协议，作用是完成MAC地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 网际控制报文协议ICMPICMP是为了更有效地转发IP数据报和提高交付的机会，它封装在IP数据报中，但是不属于高层协议。ICMP报文分为差错报告报文和询问报文。 PingPing是ICMP的一个重要应用，主要用来测试两台主机之间的连通性。 Ping的原理是通过向目的主机发送ICMP Echo请求报文，目的主机收到之后会发送Echo回答报文，Ping会根据时间和成功响应的次数估算出数据包往返时间及丢包率。 TracetouteTraceroute是ICMP的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute发送的IP数据报封装的是无法交付的UDP用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的IP数据报。第一个数据报P1的生存时间TTL设置为1，当P1到达路径上的第一个路由器R1时，R1收下它并把TTL减1，此时TTL等于0，R1就把P1丢弃，并向源主机发送一个ICMP时间超过差错报告报文； 源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达R1，R1收下后把TTL减1在转发给R2，R2收下后也把TTL减1，此时TTL等于0，R2就丢弃P2，并向源主机发送一个ICMP时间超过差错报文； 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把TTL减1，但是因为数据报封装的是无法交付的UDP，因此目的主机要向源主机发送ICMP不可达差错报文； 之后源主机知道了到达目的主机所经过的路由器IP地址及达到每个路由器的往返时间。 虚拟专用网VPN虚拟专用网表示Virtual Private Network。由于IP地址的紧缺，一个机构能申请到的IP地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的IP地址（专用地址）。有三个专用地址块： 10.0.0.0~10.255.255.255 172.16.0.0~172.31.255.255 192.168.0.0~192.168.255.255 VPN使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其他主机通信，虚拟指的是它经过公有的互联网。 下图中，场所A和场所B的通信经过互联网，如果场所A的主机X要和另一个场所B的主机Y通信，IP数据报的源地址是10.1.0.1，目的地址是10.2.0.3。数据报先发送到与互联网相连的路由器R1，R1对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器R1的全球地址125.1.2.3，目的地址是路由器R2的全球地址194.4.5.6。路由器R2收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为10.2.0.3，就交付给Y。 网络地址转换NAT专用网内部的主机使用本地IP地址又想和互联网上的主机通信时，可以使用NAT来将本地IP转换为全球IP。在以前，NAT将本地IP和全球IP一一对应，这种方式下拥有n个全球IP地址的专用网内最多只可以同时有n台主机接入互联网。为了更有效地利用全球IP地址，现在常用的NAT转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球IP地址。使用端口号的NAT也叫作网络地址与端口转换NAPT。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发。分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程 从数据报的首部提取目的主机的IP地址D，得到目的网络地址N； 若N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为D的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由器中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 否则，报文转发分组出错。 路由选择协议路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP（路由信息协议 Routing information protocol）和OSPF（开放式最短路径优先 Open shortest pathfirst） 自治系统间的路由选择：BGP（边界网关协议 border gateway protocol） 内部网关协议RIPRIP是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为1。跳数最多为15，超过15位不可达。 RIP按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为X的相邻路由器发来的RIP报文，先修改报文中的所有项目，把下一跳字段中的地址改为X，并把所有的距离字段加1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP协议实现简单，开销小，但是RIP能使用的最大距离为15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将次消息传送到所有的路由器。 内部网关协议OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法； 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示； 只有当链路状态发生变化时，路由器才会发送信息。所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 外部网关协议BGPBGP（Border gateway protocol， 边界网关协议）AS之间的路由选择很困难，主要是由于： 互联网的规模很大； 各个AS内部使用不同的路由选择协议，无法准确定义路径的度量； AS之间的路由选择必须考虑有关的策略，比如有些AS不愿意让其他AS经过。 BGP只能寻找一条比较好的路由，而不是最佳路由。每个AS都必须配置BGP发言人，通过在两个相邻BGP发言人之间建立TCP连接来交换路由信息。 5 传输层网络组只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 UDP和TCP的特点TCP是面向连接的，可靠的数据流传输，有流量控制，拥塞控制，提供全双工，传输单位是TCP报文段，每一条TCP连接都是点对点的（一对一的），安全性较高。 UDP是无连接的，不可靠的，尽最大可能交付的数据流传输，没有拥塞控制，传输单位是用户数据报，支持一对一，一对多，多对一和多对多的交互通信，安全性一般。 TCP对应的协议FTP：定义了文件传输协议，使用21端口Telnet：一种远程登录的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供DOS模式下的通信服务SMTP：简单邮件传输协议，用于发送邮件，使用25号端口POP3：它是与SMTP对应，POP3用于接收邮件，POP3协议所用的是110端口HTTP：是从Web服务器传输超文本到本地浏览器的传送协议 UDP对应的协议DNS：用于域名解析服务，将域名地址转换为IP地址，使用53号端口SNMP：简单网络管理协议，用来管理网络设备，由于网络设备很多，无连接的服务就体现在其优势，使用的是161端口TFTP（Trivial File Transfer Protocol）：简单文件传输协议，该协议在熟知端口69上使用UDP服务。 同一个IP同一个端口可以同时建立tcp和udp的连接同一个端口虽然udp和tcp的端口数字是一样的，但实质他们是不同的端口，所以是没有影响的，从底层实质分析，对于每一个连接内核维护了一个五元组，包含了源ip，目的ip、源端口目的端口、以及传输协议，在这里尽管前4项都一样，但是传输协议是不一样的，所以内核会认为是2个不同的连接，在ip层就会进行开始分流，tcp的走tcp，udp走udp。 UDP首部格式首部字段8个字节，包括源端口、目的端口、长度和校验和。12字节的伪首部是为了计算检验和临时添加的。 TCP首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP的三次握手假设A为客户端，B为服务器端： 首先B处理Listen（监听）状态，等待客户的连接请求； A向B发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号x； B收到连接请求报文，则向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y； A收到B的连接确认报文后，还要向B发出确认，确认号为y+1，序号为x+1； B收到A的确认后，建立连接。 总结：主机A向服务器B发送连接请求；B对收到的报文进行确认，A再次对B的确认进行确认。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误地打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长时间才会收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是前面那个滞留的连接请求还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP的四次挥手以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A发送连接释放报文，FIN=1；（finish） B收到之后发出确认，此时TCP处于半关闭状态，B能向A发送数据但是A不能向B发送数据； 当B不再需要连接时，发送连接释放报文，FIN=1； A收到之后发出确认，进入TIME-WAIT状态，等到2MSL （Maximum Segment Lifetime，最大报文存活时间）后释放连接； B收到A的确认后释放连接 四次挥手的原因客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT状态，这个状态是为了让服务器发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。客户端收到服务器端的FIN报文后进入TIME-WAIT状态，此时并不是直接进入CLOSED状态，还需要等待2MSL，这么做有两个理由： 确保最后一个确认报文能够到达，如果B没收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生； 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP可靠传输TCP使用超时重传来实现可靠传输：如果一个已经发送的报文在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间RTT，加权平均往返时间RTTs计算如下： R T T s=(1-a) *(R T T s)+a * R T T其中，$0 \leqslant a&lt;1$，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： R T O=R T T s+4 * R TT_{d}其中 RTTd 为偏差的加权平均值。 TCP滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其他信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率，将窗口字段设置为0，则发送方不能发送数据。 TCP拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高，因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不一样。流量控制是为了接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（congestion window，cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 6 应用层域名系统DNS是一个分布式数据库，提供了主机名和IP地址之间相互转化的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS域名系统工作原理当DNS客户机需要在程序中使用域名时，需要查询DNS服务器来解析该域名，客户机发送的每条查询信息包括三条信息：包括指定的DNS域名，指定的查询类型，DNS域名的指定类别，DNS可以使用UDP或者TCP进行传输，使用的端口号是53,，大多数情况下使用UDP进行传输，在两种情况下会使用TCP进行传输： 如果返回的响应超过512字节（UDP最大只支持512字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 文件传送协议FTPFTP使用TCP进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号21等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答； 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为20，客户端的端口号随机，但是必须大于1024，因为0~1023是熟知端口号； 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 动态主机配置协议DHCPDHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。DHCP配置的内容不仅是IP地址，还包括子网掩码，网关IP地址。 DHCP工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNET用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 POP3POP3 （Post Office Protocol - Version 3 邮局协议版本3）的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 IMAPIMAP（Internet Mail Access Protocol, Internet邮件访问协议）协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口 Web页面请求过程1 DHCP配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FFFFFFFFFF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2 ARP解析MAC地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FFFFFFFFFF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3 DNS解析域名 知道了网关路由器的MAC地址之后，就可以继续DNS的解析过程了 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4 HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 Reference： cyc2018博客：计算机网络 牛客网：计算机网络专题 计算机网络（第6版）(自顶向下方法)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统-协同过滤]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%2F</url>
    <content type="text"><![CDATA[在现今的推荐技术和算法中，最被大家广泛认可和采用的就是基于协同过滤的推荐方法。 什么是集体智慧集体智慧 (Collective Intelligence) 并不是 Web2.0 时代特有的，只是在 Web2.0 时代，大家在 Web 应用中利用集体智慧构建更加有趣的应用或者得到更好的用户体验。集体智慧是指在大量的人群的行为和数据中收集答案，帮助你对整个人群得到统计意义上的结论，这些结论是我们在单个个体上无法得到的，它往往是某种趋势或者人群中共性的部分。 Wikipedia 和 Google 是两个典型的利用集体智慧的 Web 2.0 应用： Wikipedia 是一个知识管理的百科全书，相对于传统的由领域专家编辑的百科全书，Wikipedia 允许最终用户贡献知识，随着参与人数的增多，Wikipedia 变成了涵盖各个领域的一本无比全面的知识库。也许有人会质疑它的权威性，但如果你从另一个侧面想这个问题，也许就可以迎刃而解。在发行一本书时，作者虽然是权威，但难免还有一些错误，然后通过一版一版的改版，书的内容越来越完善。而在 Wikipedia 上，这种改版和修正被变为每个人都可以做的事情，任何人发现错误或者不完善都可以贡献他们的想法，即便某些信息是错误的，但它一定也会尽快的被其他人纠正过来。从一个宏观的角度看，整个系统在按照一个良性循环的轨迹不断完善，这也正是集体智慧的魅力。 Google：目前最流行的搜索引擎，与 Wikipedia 不同，它没有要求用户显式的贡献，但仔细想想 Google 最核心的 PageRank 的思想，它利用了 Web 页面之间的关系，将多少其他页面链接到当前页面的数目作为衡量当前页面重要与否的标准；如果这不好理解，那么你可以把它想象成一个选举的过程，每个 Web 页面都是一个投票者同时也是一个被投票者，PageRank 通过一定数目的迭代得到一个相对稳定的评分。Google 其实利用了现在 Internet 上所有 Web 页面上链接的集体智慧，找到哪些页面是重要的。 什么是协同过滤协同过滤是利用集体智慧的一个典型方法。要理解什么是协同过滤 (Collaborative Filtering, 简称 CF)，首先想一个简单的问题，如果你现在想看个电影，但你不知道具体看哪部，你会怎么做？大部分的人会问问周围的朋友，看看最近有什么好看的电影推荐，而我们一般更倾向于从口味比较类似的朋友那里得到推荐。这就是协同过滤的核心思想。 换句话说，就是借鉴和你相关人群的观点来进行推荐，很好理解。 User-Based CF和Item-Based CF要实现协同过滤的推荐算法，要进行以下三个步骤： 收集数据——找到相似用户和物品——进行推荐 收集数据 这里的数据指的都是用户的历史行为数据，比如用户的购买历史，关注，收藏行为，或者发表了某些评论，给某个物品打了多少分等等，这些都可以用来作为数据供推荐算法使用，服务于推荐算法。需要特别指出的在于，不同的数据准确性不同，粒度也不同，在使用时需要考虑到噪音所带来的影响。 找到相似用户和物品 这一步也很简单，其实就是计算用户间以及物品间的相似度。以下是几种计算相似度的方法： 欧几里德距离 d(x, y)=\sqrt{\left(\sum\left(x_{i}-y_{i}\right)^{2}\right)} \quad \operatorname{sim}(x, y)=\frac{1}{1+d(x, y)} 皮尔逊相关系数 p(x, y)=\frac{\sum x_{i} y_{i}-n \overline{x y}}{(n-1) s_{x} s_{y}}=\frac{n \sum x_{i} y_{i}-\sum x_{i} \sum y_{i}}{\sqrt{n \sum x_{i}^{2}-\left(\sum x_{i}\right)^{2}} \sqrt{n \sum y_{i}^{2}-\left(\sum y_{i}\right)^{2}}}Cosine 相似度 T(x, y)=\frac{x \bullet y}{\|x\|^{2} \times\|y\|^{2}}=\frac{\sum x_{i} y_{i}}{\sqrt{\sum x_{i}^{2}} \sqrt{\sum y_{i}^{2}}}Tanimoto 系数 T(x, y)=\frac{x \bullet y}{\|x\|^{2}+\|y\|^{2}-x \bullet y}=\frac{\sum x_{i} y_{i}}{\sqrt{\sum x_{i}^{2}}+\sqrt{\sum y_{i}^{2}}-\sum x_{i} y_{i}}进行推荐 在知道了如何计算相似度后，就可以进行推荐了。 在协同过滤中，有两种主流方法：基于用户的协同过滤，和基于物品的协同过滤。具体怎么来阐述他们的原理呢，看个图大家就明白了 基于用户的 CF 的基本思想相当简单，基于用户对物品的偏好找到相邻邻居用户，然后将邻居用户喜欢的推荐给当前用户。计算上，就是将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度，找到 K 邻居后，根据邻居的相似度权重以及他们对物品的偏好，预测当前用户没有偏好的未涉及物品，计算得到一个排序的物品列表作为推荐。 下图给出了一个例子，对于用户 A，根据用户的历史偏好，这里只计算得到一个邻居 - 用户 C，然后将用户 C 喜欢的物品 D 推荐给用户 A。 基于物品的 CF 的原理和基于用户的 CF 类似，只是在计算邻居时采用物品本身，而不是从用户的角度，即基于用户对物品的偏好找到相似的物品，然后根据用户的历史偏好，推荐相似的物品给他。从计算的角度看，就是将所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度，得到物品的相似物品后，根据用户历史的偏好预测当前用户还没有表示偏好的物品，计算得到一个排序的物品列表作为推荐。下图给出了一个例子，对于物品 A，根据所有用户的历史偏好，喜欢物品 A 的用户都喜欢物品 C，得出物品 A 和物品 C 比较相似，而用户 C 喜欢物品 A，那么可以推断出用户 C 可能也喜欢物品 C。 总结 以上两个方法都能很好的给出推荐，并可以达到不错的效果。但是他们之间还是有不同之处的，而且适用性也有区别。下面进行一下对比 计算复杂度 Item CF 和 User CF 是基于协同过滤推荐的两个最基本的算法，User CF 是很早以前就提出来了，Item CF 是从 Amazon 的论文和专利发表之后（2001 年左右）开始流行，大家都觉得 Item CF 从性能和复杂度上比 User CF 更优，其中的一个主要原因就是对于一个在线网站，用户的数量往往大大超过物品的数量，同时物品的数据相对稳定，因此计算物品的相似度不但计算量较小，同时也不必频繁更新。但我们往往忽略了这种情况只适应于提供商品的电子商务网站，对于新闻，博客或者微内容的推荐系统，情况往往是相反的，物品的数量是海量的，同时也是更新频繁的，所以单从复杂度的角度，这两个算法在不同的系统中各有优势，推荐引擎的设计者需要根据自己应用的特点选择更加合适的算法。 适用场景 在非社交网络的网站中，内容内在的联系是很重要的推荐原则，它比基于相似用户的推荐原则更加有效。比如在购书网站上，当你看一本书的时候，推荐引擎会给你推荐相关的书籍，这个推荐的重要性远远超过了网站首页对该用户的综合推荐。可以看到，在这种情况下，Item CF 的推荐成为了引导用户浏览的重要手段。同时 Item CF 便于为推荐做出解释，在一个非社交网络的网站中，给某个用户推荐一本书，同时给出的解释是某某和你有相似兴趣的人也看了这本书，这很难让用户信服，因为用户可能根本不认识那个人；但如果解释说是因为这本书和你以前看的某本书相似，用户可能就觉得合理而采纳了此推荐。 相反的，在现今很流行的社交网络站点中，User CF 是一个更不错的选择，User CF 加上社会网络信息，可以增加用户对推荐解释的信服程度。 基于模型的推荐算法ALS(交替最小二乘)在用户数量以及用户评分不足的情况下，上述两种方法就不是那么地好使了，近年来，基于模型的推荐算法ALS(交替最小二乘)在Netflix成功应用并取得显著效果提升，ALS使用机器学习算法建立用户和物品间的相互作用模型，进而去预测新项。它已经集成到Spark的Mllib库中，使用起来比较方便。从协同过滤的分类来说，ALS算法属于User-Item CF，也叫做混合CF。它同时考虑了User和Item两个方面。 基本原理用户对物品的打分行为可以表示成一个打分矩阵 R，例如下表所示： 矩阵中的打分值 $r_{ij}$ 表示用户 $u_i$ 对物品 $v_j$的打分，其中”?”表示用户没有打分，这也就是要通过机器学习的方法去预测这个打分值，从而达到推荐的目的。 在实际使用中，由于n和m的数量都十分巨大，因此R矩阵的规模很容易就会突破1亿项。这时候，传统的矩阵分解方法对于这么大的数据量已经是很难处理了。 另一方面，一个用户也不可能给所有商品评分，因此，R矩阵注定是个稀疏矩阵。矩阵中所缺失的评分，又叫做missing item。 模型抽象按照User-Based CF的思想，R 的行向量对应每个用户 u ，按照Item-Based CF的思想，R 的列向量对应每个物品 v 。ALS 的核心思想是，将用户和物品都投影到 k 维空间，也就是说，假设有 k 个隐含特征，至于 k 个隐含特征具体指什么不用关心，将每个用户和物品都用 k 维向量来表示，把它们之间的内积近似为打分值，这样就可以得到如下近似关系： R \approx U V^T R 为打分矩阵($m \times n$)，m 个用户，n 个物品，U 为用户对隐含特征的偏好低秩矩阵($m \times k$)，V 为物品对隐含特征的偏好低秩矩阵($n \times k$)。 上述模型的参数就是矩阵 U 和 V，即求解出 U 和 V 我们就可以重现打分矩阵，填补原始打分矩阵中的缺失值”?”。同时，矩阵 U和 V，还可以用于比较不同的User（或Item）之间的相似度。 显示反馈代价函数要求解上述模型中的 U 和 V，那么就需要一个代价函数来衡量参数的拟合程度，如果有比较明确的显式反馈打分数据，那么可以比较重构出来的打分矩阵与实际打分矩阵，即得到重构误差，由于实际打分矩阵有很多缺失值，所以仅计算已知打分的重构误差，下面函数为显示反馈代价函数。 J\left( U, V \right) = \sum_i \sum_j \left[ \left( r_{ij} - u_i v_j^T \right)^2 + \lambda \left( \|u_i\|^2 + \|v_j\|^2 \right) \right] $r_{ij}$ 为矩阵 R 的第 i 行第 j 列，表示用户 $u_i $对物品 $v_j $的打分，$u_i $为矩阵 U 的第 i 行 $(1 \times k)$，$v_j^T$ 为矩阵$V^T $的第 j 列 $(k \times 1)$，$\lambda $为正则项系数。 隐式反馈代价函数很多情况下，用户并没有明确反馈对物品的偏好，需要通过用户的相关行为来推测其对物品的偏好，例如，在视频推荐问题中，可能由于用户就懒得对其所看的视频进行反馈，通常是收集一些用户的行为数据，得到其对视频的偏好，例如观看时长等。通过这种方式得到的偏好值称之为隐式反馈值，即矩阵 R 为隐式反馈矩阵，引入变量 $p_{ij}$ 表示用户 $u_i$ 对物品 $v_j $的置信度，如果隐式反馈值大于0，置信度为1，否则置信度为0。 p_{ij} = \left\{\begin{matrix}1 \qquad r_{ij} > 0 & \\ 0 \qquad r_{ij} = 0 & \end{matrix}\right.但是隐式反馈值为0并不能说明用户就完全不喜欢，用户对一个物品没有得到一个正的偏好可能源于多方面的原因，例如，用户可能不知道该物品的存在，另外，用户购买一个物品也并不一定是用户喜欢它，所以需要一个信任等级来显示用户偏爱某个物品，一般情况下，$r_{ij} $越大，越能暗示用户喜欢某个物品，因此，引入变量 $c_{ij}$，来衡量 $p_{ij}$ 的信任度。 c_{ij} = 1 + \alpha r_{ij} $\alpha$ 为置信度系数 那么，代价函数则变成如下形式： J\left( U, V \right) = \sum_i \sum_j \left[ c_{ij} \left( p_{ij} - u_i v_j^T \right)^2 + \lambda \left( \|u_i\|^2 + \|v_j\|^2 \right)\right]算法无论是显示反馈代价函数还是隐式反馈代价函数，它们都不是凸的，变量互相耦合在一起，常规的梯度下降法可不好使了。但是如果先固定 U 求解 V，再固定V 求解 U ，如此迭代下去，问题就可以得到解决了。 U^{(0)} \rightarrow V^{(1)} \rightarrow U^{(1)} \rightarrow V^{(2)} \rightarrow \cdots那么固定一个变量求解另一个变量如何实现呢，梯度下降？虽然可以用梯度下降，但是需要迭代，计算起来相对较慢，试想想，固定 U 求解 V，或者固定 V 求解 U，其实是一个最小二乘问题，由于一般隐含特征个数 k 取值不会特别大，可以将最小二乘转化为正规方程一次性求解，而不用像梯度下降一样需要迭代。如此交替地解最小二乘问题，所以得名交替最小二乘法ALS，下面是基于显示反馈和隐式反馈的最小二乘正规方程。 显示反馈固定 V 求解 U U ^T = \left( V^T V + \lambda I \right)^{-1} V^T R^T更直观一点，每个用户向量的求解公式如下： u_i ^T = \left( V^T V + \lambda I \right)^{-1} V^T r_i^T $u_i^T $为矩阵 U 的第 i 行的转置$(k \times 1)$，$r_i^T$ 为矩阵 R 的第 i 行的转置$(n \times 1)$。 固定 U 求解 V V ^T = \left( U^T U + \lambda I \right)^{-1} U^T R更直观一点，每个物品向量的求解公式如下： v_j ^T = \left( U^T U + \lambda I \right)^{-1} U^T r_j^T $v_j^T$ 为矩阵 $V^T$ 的第 j 列$(k \times 1)$，$r_j^T$ 为矩阵 R 的第 j 列$(m \times 1)$。 隐式反馈固定 V 求解 U U ^T = \left( V^T C_v V + \lambda I \right)^{-1} V^T C_v R^T更直观一点，每个用户向量的求解公式如下： u_i ^T = \left( V^T C_v V + \lambda I \right)^{-1} V^T C_v r_i^T $u_i^T$ 为矩阵 U 的第 i 行的转置$(k \times 1)$，$r_i^T $为矩阵 R 的第 i 行的转置$(n \times 1)$，$C_v $为对角矩阵$(n \times n)$。 固定 U 求解 V V ^T = \left( U^T C_u U + \lambda I \right)^{-1} U^T C_u R更直观一点，每个物品向量的求解公式如下： v_j ^T = \left( U^T C_u U + \lambda I \right)^{-1} U^T C_u r_j^T $v_j^T$ 为矩阵$V^T$ 的第 j 列$(k \times 1)$，$r_j^T$ 为矩阵 R 的第 j 列$(m \times 1)$,， $C_u$ 为对角矩阵$(m \times m)$。 总结ALS算法的缺点在于它是一个离线算法，无法准确评估新加入的User或Item，这个问题也被称为Cold Start问题。ALS算法的核心就是将稀疏评分矩阵分解为User特征向量矩阵和Item特征向量矩阵的乘积。交替使用最小二乘法逐步计算User/Item特征向量，使得误差平方和最小。通过User/Item特征向量的矩阵来预测某个用户对某个产品的评分。 Reference：https://www.ibm.com/developerworks/cn/web/1103_zhaoct_recommstudy2/index.htmlhttps://www.cnblogs.com/luchen927/archive/2012/02/01/2325360.htmlhttp://sharkdtu.com/posts/ml-als.html]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-缓存算法]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LRU缓存LRU（Least recently used，最近最少使用）首先淘汰最长时间未被使用的页面。 leetcode 146. LRU缓存机制链接运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例:1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 思路：get()相当于读，put()即是写。一次读或写意味着对缓存块使用了一次，该缓存的优先级就提高。 思路比较简单，基于哈希表和双向链表。先通过哈希表查找缓存块的位置，也就是缓存块在链表中的位置。然后在表中删除该缓存块，重新把该缓存块置于链表表尾。如果插入后缓存已经满了，那就把表头的缓存块丢掉，同时删除哈希表对应的记录。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Node(object): def __init__(self, k, v): self.key = k self.val = v self.prev = None self.next = Noneclass LRUCache(object): def __init__(self, capacity): """ :type capacity: int """ self.capacity = capacity self.dic = dict() self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key): """ :type key: int :rtype: int """ if key in self.dic: node = self.dic[key] self.remove(node) self.add(node) return node.val return -1 def put(self, key, value): """ :type key: int :type value: int :rtype: None """ if key in self.dic: self.remove(self.dic[key]) node = Node(key, value) self.add(node) self.dic[key] = node if len(self.dic) &gt; self.capacity: node = self.head.next self.remove(node) del self.dic[node.key] def remove(self, node): pNode = node.prev nNode = node.next pNode.next = nNode nNode.prev = pNode def add(self, node): pNode = self.tail.prev pNode.next = node self.tail.prev = node node.prev = pNode node.next = self.tail# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)if __name__ == '__main__': cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) #// 返回 1 cache.put(3, 3) #// 该操作会使得密钥 2 作废 print(cache.get(2)) # // 返回 -1 (未找到) cache.put(4, 4) # // 该操作会使得密钥 1 作废 print(cache.get(1)) #// 返回 -1 (未找到) print(cache.get(3)) # // 返回 3 print(cache.get(4)) #// 返回 4 LFU缓存LRU（Least recently used，最近最少使用）首先淘汰最近一定时期内被访问次数最少的页面。 leetcode 460. LFU缓存链接 设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。 进阶：你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例：123456789101112LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 去除 key 2cache.get(2); // 返回 -1 (未找到key 2)cache.get(3); // 返回 3cache.put(4, 4); // 去除 key 1cache.get(1); // 返回 -1 (未找到 key 1)cache.get(3); // 返回 3cache.get(4); // 返回 4 待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树形DP]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2DP%2F</url>
    <content type="text"><![CDATA[树上的动态规划，即树形DP。做树形DP一般步骤是先将树转换为有根树，然后在树上进行深搜操作，从子节点或子树中返回信息层层往上更新至根节点。 思路：小树计算完，再算父亲树。 分析可能性（先计算小树，再计算大树） 列信息全集，定下返回值结构。 编写代码的时候，默认每颗子树都给你这样的信息，然后看拿到这些子树信息后怎么加工出父的信息。 Basecase要单独考虑一下，作为最简单的情况，要给父返回啥，不至于让他干扰。 1. 给定一棵二叉树的头节点head，请返回最大搜索二叉子树的大小假设以每个节点为头的树，求出它的最大二叉子树，答案一定在所有节点的最大二叉子树中。 第一步：列出可能性 可能来自左子树的某棵子树 可能来自右子树的某棵子树 整棵树都是，左右子树都是搜索二叉树并且左子树最大值小于该节点，右子树最小值大于该节点 第二步：收集信息 左子树最大搜索子树大小 右子树最大搜索子树大小 左子树中最大二叉搜索子树的头部（通过查看这个头部是否等于节点的左孩子，来判断整个左子树是否都是二叉搜索树）4、右子树最大二叉搜索子树的头部5、左子树最大值6、右子树最小值 因此不管对于左子树还是右子树都需要收集的信息： 最大搜索子树大小 最大搜索子树的头部 这棵树的最大值 这棵树的最小值 第三步：改递归先假设左和右都给我这样的信息了，然后怎么利用左边和右边的信息，组出来我该返回的信息。 对于某节点，如果其左子树返回的头结点是该节点的左孩子，且其右子树返回的头结点是该节点的右孩子，且左子树的最大值小于该节点值，且右子树的最小值大于该节点值，则以该节点为根的整棵子树是二叉搜索树，长度是左长+1+右长。 如果1不成立，则判断左搜和右搜的大小，以该节点为根的最大二叉搜索树的大小为其中较大者。 BaseCase是当一棵树为空时，大小为0，头部为空，最小值为系统最小，最大值为系统最大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, size, root, min, max): self.size = size self.root = root self.min = min self.max = maxclass Solution(object): def BiggestSubBSTInTree(self, root): if not root: return 0 res = self.process(root) return res.size def process(self, root): if not root: return returnData(0, None, float('inf'), float('-inf')) leftData = self.process(root.left) rightData = self.process(root.right) includeItSelf = 0 if leftData.root == root.left and rightData.root == root.right and root.val &gt; leftData.max and root.val &lt; rightData.min: includeItSelf = leftData.size + 1 + rightData.size p1 = leftData.size p2 = rightData.size maxSize = max(p1, p2, includeItSelf) maxHead = leftData.root if p1 &gt; p2 else rightData.root if maxSize == includeItSelf: maxHead = root return returnData(maxSize, maxHead, min(leftData.min, rightData.min, root.val), max(leftData.max, rightData.max, root.val))if __name__ == '__main__': root = TreeNode(16) root.left = TreeNode(200) root.left.left = TreeNode(6) root.left.right = TreeNode(9) root.left.left.left = TreeNode(5) root.left.left.right = TreeNode(7) root.left.right.right = TreeNode(12) root.right = TreeNode(20) root.right.left = TreeNode(17) root.right.right = TreeNode(21) res = Solution().BiggestSubBSTInTree(root) print(res) 2 求二叉树中节点的最大距离二叉树中，一个节点可以往上走和往下走，那么从节点A总能走到节点B。节点A走到节点B的距离为：A走到B最短路径上的节点个数。求一棵二叉树上的最远距离。 考虑每一个节点为根节点的情况，答案一定在其中。 第一步：列出可能性 来自左子树的最长距离 来自右子树的最长距离 经过该节点情况下的最远距离，左子树深度+1+右子树深度 第二步：收集信息 最长距离 树的深度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, maxLen, depth): self.maxLen = maxLen self.depth = depthclass Solution(object): def MaxDistanceInTree(self, root): if not root: return 0 res = self.process(root) return res.maxLen def process(self, root): if not root: return returnData(0, 0) leftData = self.process(root.left) rightData = self.process(root.right) includeHeadDLen = leftData.depth + 1 + rightData.depth maxLen = max(leftData.maxLen, rightData.maxLen, includeHeadDLen) depth = max(leftData.depth, rightData.depth) + 1 return returnData(maxLen, depth)if __name__ == '__main__': root = TreeNode(16) root.left = TreeNode(200) root.left.left = TreeNode(6) root.left.right = TreeNode(9) root.left.left.left = TreeNode(5) root.left.left.right = TreeNode(7) root.left.right.right = TreeNode(12) root.right = TreeNode(20) root.right.left = TreeNode(17) root.right.right = TreeNode(21) res = Solution().MaxDistanceInTree(root) print(res) 3 没有上司的晚会一个公司的上下节关系是一棵多叉树，这个公司要举办晚会，你作为组织者已经摸清了大家的心理：一个员工的直接上级如果到场，这个员工肯定不会来。每个员工都有一个活跃度的值，决定谁来你会给这个员工发邀请函，怎么让舞会的气氛最活跃？返回最大的活跃值。 给定一个矩阵来表述这种关系 matrix = [[1,6],[1,5],[1,4]] 这个矩阵的含义是：matrix[0] = {1 , 6}，表示0这个员工的直接上级为1,0这个员工自己的活跃度为6matrix[1] = {1 , 5}，表示1这个员工的直接上级为1（他自己是这个公司的最大boss）,1这个员工自己的活跃度为5matrix[2] = {1 , 4}，表示2这个员工的直接上级为1,2这个员工自己的活跃度为4为了让晚会活跃度最大，应该让1不来，0和2来。最后返回活跃度为10 对于某节点 i可能性： i 来，活跃度就是X的活跃度+下属员工不来的活跃度总和 i 不来，活跃度就是每个下属员工来或不来中选最大的总和 我们可以定义 $ f(i, 0 / 1)$ 代表以 i 为根的子树的最优解（第二维的值为 0 代表不来的情况，1 代表 来的情况）。则转移方程为（其中下面的 x 都是 i 的儿子）：）： $f(i, 0)=\sum \max \{f(x, 1), f(x, 0)\}$（上司不来时，下属可以来，也可以不来）$f(i, 1)=\sum f(x, 0)+a_{i}$ (上司来时，下属都不会来） 结果返回 $max(f(i, 0), f(i, 1))$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Node(object): def __init__(self, happy): self.happy = happy self.nexts = []class returnData(object): def __init__(self, comeHappy, notComeHappy): self.comeHappy = comeHappy self.notComeHappy = notComeHappyclass Solution(object): def MaxHappy(self, root): if not root: return 0 # 找到大Boss，后面从大Boss开始计算 root = 0 for i in range(len(matrix)): if i == matrix[i][0]: root = i break # 构建数据结构 Node [happy, nexts] happy表示活跃度，nexts表示它的直接下属 Nodes = [] for i in range(len(matrix)): Nodes.append(Node(matrix[i][1])) Dicts = &#123;&#125; for i in range(len(matrix)): if matrix[i][0] == i: continue if matrix[i][0] not in Dicts: Dicts[matrix[i][0]] = [i] else: Dicts[matrix[i][0]].append(i) for i in range(len(matrix)): if i in Dicts: for j in Dicts[i]: Nodes[i].nexts.append(Nodes[j]) res = self.process(Nodes[root]) return max(res.comeHappy, res.notComeHappy) def process(self, root): if not root: return returnData(0, 0) comeHappy = root.happy notComeHappy = 0 for i in range(len(root.nexts)): data = self.process(root.nexts[i]) comeHappy += data.notComeHappy notComeHappy += max(data.comeHappy, data.notComeHappy) return returnData(comeHappy, notComeHappy)if __name__ == '__main__': matrix = [[0,16],[0,5],[0,4],[0,300], [1,6],[1,7],[1,9], [2,3],[2,7], [3,10],[3,2],[3,3],[3,5]] res = Solution().MaxHappy(matrix) print(res) 4 判断一棵树是否是平衡二叉树1234567891011121314151617181920212223242526272829303132333435363738394041424344class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, isB, depth): self.isB = isB self.depth = depthclass Solution(object): def IsBalancedTree(self, root): if not root: return True return self.process(root).isB def process(self, root): if not root: return returnData(True, 0) leftData = self.process(root.left) if not leftData.isB: return returnData(False, 0) rightData = self.process(root.right) if not rightData.isB: return returnData(False, 0) if abs(leftData.depth - rightData.depth) &gt; 1: return returnData(False, 0) return returnData(True, max(leftData.depth, rightData.depth)+1)if __name__ == '__main__': root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.left.left = TreeNode(6) res = Solution().IsBalancedTree (root) print(res)`]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-Morris遍历]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Morris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[背景对二叉树节点的遍历一般来说有中序，后序，和前序三种遍历方法，如果二叉树的高用$h$来表示，那三种遍历方法所需要的空间复杂度为$O(h)$。遍历的时候因为没有指向父节点的指针，无法从下往上走，所以采用栈，但是树的节点有很多的left，right指向null，Morris遍历利用了这些指针实现了$O(1)$的空间复杂度。 Morris遍历原理要使用$O(1)$空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针），由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。 使用Morris实现中序，后序，和前序的历程都是一样的，区别在于输出打印的时机不同。记当前节点为cur。 如果当前节点无左子树，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 Morris前序顺序当前节点的mostRight的右指针指向空，或者当前节点左子树为空格，打印该节点。具体过程为： 如果当前节点无左子树，打印当前节点，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，打印当前节点，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空(恢复树的形状)，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 图示： 代码：leetcode 144. 二叉树的前序遍历 测试通过。12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: res.append(cur.val) cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: res.append(cur.val) mostRight.right = cur cur = cur.left elif mostRight.right == cur: mostRight.right = None cur = cur.right return res 复杂度分析：空间复杂度：$O(1)$，因为只用了两个辅助指针。时间复杂度：$O(n)$。证明时间复杂度为$O(n)$，最大的疑惑在于寻找中序遍历下二叉树中所有节点的前驱节点的时间复杂度是多少，即以下两行代码：12while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right 直觉上，认为它的复杂度是$O(nlgn)$，因为找单个节点的前驱节点与树的高度有关。但事实上，寻找所有节点的前驱节点只需要$O(n)$时间。n个节点的二叉树中一共有n-1条边，整个过程中每条边最多只走2次，一次是为了定位到某个节点，另一次是为了寻找上面某个节点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点。所以复杂度为$O(n)$。 Morris中序遍历当前节点往右移动之前打印。具体过程为： 如果当前节点无左子树，打印当前节点，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，打印当前节点，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 图示： 代码：leetcode 94. 二叉树的中序遍历 测试通过。123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: res.append(cur.val) cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: mostRight.right = cur cur = cur.left elif mostRight.right == cur: res.append(cur.val) mostRight.right = None cur = cur.right return res 复杂度分析：时间复杂度和空间复杂度都与前序遍历情况相同。 Morris后序遍历当发现当前节点的mostRight的右指针指向自己，逆序打印左子树的右边界，直到当前节点为空时，逆序打印整棵树根节点的右边界。具体过程为 如果当前节点无左子树，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，逆序打印从当前节点的左子树的右边界，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空； 逆序打印整棵树根节点的右边界。 逆序打印的过程可以将该右边界上的节点看做以right指针为后继指针的链表，将其反转reverse然后打印，最后恢复成原始结构即可。 图示： 代码：leetcode 145. 二叉树的后序遍历 测试通过。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: mostRight.right = cur cur = cur.left elif mostRight.right == cur: mostRight.right = None self.printEdge(cur.left,res) cur = cur.right self.printEdge(root, res) return res def printEdge(self, head, res): tail = self.reverseEdge(head) cur = tail while cur: res.append(cur.val) cur = cur.right self.reverseEdge(tail) def reverseEdge(self, head): pre = None while head: next = head.right head.right = pre pre = head head = next return pre 复杂度分析：空间复杂度同样是$O(1)$；时间复杂度也是$O(n)$，逆序输出过程只不过是加大了常数系数。 总结morris遍历结点的顺序不是先序、中序、后序，而是按照自己的一套标准来决定接下来要遍历哪个结点。morris遍历的独特之处就是充分利用了叶子结点的无效引用（引用指向的是空，但该引用变量仍然占内存），从而实现了$O(1)$的时间复杂度。 Reference：https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.htmlhttps://www.jianshu.com/p/484f587c967chttps://blog.csdn.net/zjucor/article/details/72898494]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单调栈]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[单调栈的定义单调栈就是栈内元素单调递增或者单调递减的栈，单调栈只能在栈顶操作。 为了更好的理解单调栈，则可将单调栈用生活情形模拟实现，例如： 我们借用拿号排队的场景来说明下。现在有很多人在排队买可乐，每个人手里都拿着号，越靠前的人手里的号越小，但是号不一定是连续的。小明拿了号后并没有去排队，而是跑去约会了。等他回来后，发现队伍已经排得很长了，他不能直接插入到队伍里，不然人家以为他是来插队的。小明只能跑到队伍最后，挨个询问排队人手里的号，小明认为号比他大的人都是“插队”的，于是小明就会施魔法把这些人变消失，直到小明找到号比他小的为止。 在上面这个场景里，大家排的队伍就像是单调栈，因为大家手里拿的号是单调递增的。而小明找自己位置的这个过程就是元素加入单调栈的过程。新加入的元素如果加到栈顶后，如果栈里的元素不再是单调递增了，那么我们就删除加入前的栈顶元素，就像小明施魔法把“插队”的人变消失一样。直到新元素加入后，栈依然是单调递增时，我们才把元素加进栈里。 （这样做的目的是“维护”单调栈，是单调栈保持原来的单调性不变） 单调栈的一大优势就是线性的时间复杂度$O(N)$，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。 单调递增栈可以找到左右两边最近的且比当前数字小的元素。比如数组 [2 1 4 6 5]刚开始2入栈，栈为[2]；数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，收集元素2左右两边最近的比2小的数，左边为null，右边为1，此后1入栈，栈为[1];然后数字4入栈的时候，栈顶元素1小于4，4入栈，此时栈里为[1,4]然后数字6入栈的时候，栈顶元素4小于6，6入栈，此时栈里有[1,4,6]然后数字5入栈的时候，栈顶元素6大于5，将6移除，收集元素6左右两边最近的比6小的数，左边为4，右边为5，栈为[1,4]，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，收集5入栈栈内数字为 [1,4,5]。 遍历完数组之后，栈中元素出栈。5出栈，栈为[1,4]，收集元素5左右两边最近的比5小的数，左边为4，右边为null；4出栈，栈为[1]，收集元素4左右两边最近的比4小的数，左边为1，右边为null；1出栈，栈为[]，收集元素1左右两边最近的比1小的数，左边为null，右边为null； 单调递减栈可以找到左右两边最近的且比当前数字大的元素。 单调栈的应用leetcode 84. 柱状图中最大的矩形题目描述给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3]输出: 10 解题思路使用一个递增单调栈，栈中保存坐标，数组中坐标依次入栈，当当前坐标的值小于栈顶坐标的值，则栈顶坐标弹出，并计算弹出坐标的面积，它的右边界是当前坐标的值（因为当前坐标让它出栈），左边界是栈顶坐标（当栈为空时为-1）。当数组遍历完成后，栈不为空，则依次弹出，计算弹出坐标的面积，右边界是数组长度，左边界是栈顶坐标（当栈为空时为-1）。 例如：[2,1,5,6,2,3]先将2的坐标入栈，栈为[0]；元素1的坐标1入栈前比较，因为1位置的元素比栈顶(0)位置的元素小，则位置0出栈，栈为空，计算0位置的面积(1-(-1)-1)*2=2，在将1入栈，栈为[1]；坐标2的元素5大于栈顶位置元素(1)，则坐标2入栈，栈为[1,2]；坐标3的元素6大于栈顶位置元素(5)，则坐标3入栈，栈为[1,2,3]；坐标4的元素2小于栈顶位置元素(6)，则将栈顶位置3弹出，栈为[1,2]，计算3位置的面积(4-2-1)*6 = 6，此时2依然小于栈顶位置2的元素5，则栈顶位置2出栈，栈为[1]，计算2位置的面积(4-1-1)*5=10；此时2大于栈顶位置元素，则2的坐标4入栈，栈为[1,4]；坐标5的元素3大于栈顶位置元素(2)，坐标5入栈，栈为[1,4,5]；数组遍历完成。 此时栈不为空，依次弹出计算面积。弹出位置5，栈为[1,4]，面积为(6-4-1)*3=3;弹出位置4，栈为[1]，面积为(6-1-1)*2=8;弹出位置1，栈为空，面积为(6-(-1)-1)*1=6;所以最大面积为max(2,6,10,3,8,6)=10。 123456789101112131415161718192021222324class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i-left-1)*heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1)*heights[index]) return res leetcode 85 最大矩形题目描述给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 解题思路使用一个辅助数组，大小为矩阵列宽，依次以矩阵每一行为底计算最大面积，直接调用上一题的代码计算。辅助数组计算方法：初始化为0，当当前元素为1是，高度加1，为0时直接为0。例如上例的辅助数组情况为：第一行 [1 0 1 0 0]第二行 [2 0 2 1 1]第三行 [3 1 3 2 2]第四行 [4 0 0 3 0] 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def maximalRectangle(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 heights = [0] * len(matrix[0]) res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 res = max(res, self.largestRectangleArea(heights)) return res def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i - left - 1) * heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1) * heights[index]) return res leetcode 42. 接雨水题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路解法一：先找出最高点，然后分别从左到最高点遍历，从右到最高点遍历。遍历过程中收集信息。123456789101112131415161718192021222324252627282930313233343536class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if len(height) &lt; 3: return 0 # 求最高点处的索引 #从左往最高点遍历 # 从右往最高点遍历 maxIndex = 0 for i in range(1, len(height)): if height[i] &gt; height[maxIndex]: maxIndex = i res = 0 curMax = height[0] for i in range(1, maxIndex): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] curMax = height[-1] for i in range(len(height)-2, maxIndex, -1): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] return res 解法二：单调栈利用一个单调递减栈，保存元素的坐标，当遇到当前高度比栈顶高度大的时候，说明有可能会有坑的存在，此时我们的栈里至少有一个高度，如果只有一个时，不能形成坑，弹出栈中元素，将当前高度压入栈，因为当前高度比栈顶高度大，替换即可。如果两个及以上时，说明形成坑了，弹出栈顶元素作为坑，右边界为当前高度，左边界为新的栈顶元素，取二者较小的减去坑的高度就为这个坑的高度，长度就是右边界坐标减去左边界左边再减1，二者相差就是这个坑的盛水量。 123456789101112131415161718192021class Solution(object): def trap(self, height): """ :type height: List[int] :rtype: int """ if len(height) &lt; 3: return 0 res = 0 stack = [] for i in range(len(height)): while stack and height[i] &gt; height[stack[-1]]: low = stack.pop() if not stack: break res += (min(height[i], height[stack[-1]]) - height[low]) * (i - stack[-1] -1) stack.append(i) return res 京东2017年笔试题 保卫方案（山峰对数量）题目描述战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。 输入描述:输入中有多组测试数据，每一组测试数据的第一行为一个整数$n(3&lt;=n&lt;=10^6)$,为首都周围的小山数量，第二行为n个整数，依次表示为小山的高度$h（1&lt;=h&lt;=10^9）$. 输出描述:对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。示例1 12345输入51 2 4 5 3输出7 解题思路使用单调递减的栈，栈中的数据结构是高度和该高度连续出现的次数。找到最大值的下标，从最大值处开始循环遍历。当遇到当前高度大于栈顶高度时，弹出栈顶元素，收集该元素的山峰对数量，等于该高度山峰内部形成的对数与该高度山峰和两边的高点形成的山峰对。遍历完成之后，对栈中元素依次弹出，收集信息。 例如：1 2 4 5 3。找出最大值下标，从最大值开始遍历，遍历顺序为 5 3 1 2 4。res = 05入栈，stack=[(5,1)]3入栈，stack=[(5,1),(3,1)]1入栈，stack=[(5,1),(3,1),(1,1)]当前元素2，2大于栈顶元素1，(1,1)出栈，stack=[(5,1),(3,1)]，因为连续1只有一个，所以curTimes=1，所以连续1内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素1的左边高点为当前栈顶3，右边高点为当前栈顶2，所以山峰对数量 curTimes*2=2，res = 2。当前元素2小于当前栈顶3，2入栈，stack=[(5,1),(3,1),(2,1)]当前元素4，4大于栈顶元素2，(2,1)出栈，stack=[(5,1),(3,1)]，因为连续2只有一个，所以curTimes=1，所以连续2内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素2的左边高点为当前栈顶3，右边高点为当前栈顶4，所以山峰对数量 curTimes*2=2，res = 4。当前元素4，4大于栈顶元素3，(3,1)出栈，stack=[(5,1)]，因为连续3只有一个，所以curTimes=1，所以连续3内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素3的左边高点为当前栈顶5，右边高点为当前栈顶4，所以山峰对数量 curTimes*2=2，res = 6。当前元素4小于当前栈顶5，4入栈，stack=[(5,1),(4,1)] 遍历完成之后，依次弹出栈中元素。弹出(4,1)，stack=[(5,1)]，因为连续4只有一个，所以curTimes=1，所以连续4内部山峰对数量为curTimes*(curTimes-1)//2=0， 栈中元素为1个，且次数为1，4的左边高点为当前栈顶5，右边无高点，所以山峰对数量 curTimes=1，res = 7。弹出(5,1)，stack=[]，山峰对为0。最终山峰对为7。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Pair(object): def __init__(self, value): self.value = value self.times = 1 # 默认个数为1class Solution(object): def main(self, height): if len(height) &lt;= 1: return 0 if len(height) == 2: return 1 res = 0 maxIndex = 0 for i in range(1, len(height)): maxIndex = i if height[i] &gt; height[maxIndex] else maxIndex stack = [Pair(height[maxIndex])] curIndex = self.nextIndex(maxIndex, len(height)) while curIndex != maxIndex: while stack and height[curIndex] &gt; stack[-1].value: curTimes = stack.pop().times # 连续相等高度内部的山峰对 + 到一个高点的山峰对 res += curTimes*(curTimes-1)//2 + curTimes # 到另一个高点的山峰对 res += curTimes if stack else 0 if stack and stack[-1].value == height[curIndex]: stack[-1].times += 1 else: stack.append(Pair(height[curIndex])) curIndex = self.nextIndex(curIndex, len(height)) while stack: curTimes = stack.pop().times res += curTimes*(curTimes-1)//2 # 当前高度山峰内部的对数 if stack: res += curTimes # 到一个高点的对数 # 如果剩下两个以上高点的话，加上另一个高点的对数 if len(stack) &gt;= 2: res += curTimes else: # 如果只有一个的话，个数大于等于2，相当于有两个高点，加times # 个数等于1，则只有一个高点，加0 res += curTimes if stack[-1].times &gt;= 2 else 0 return res def nextIndex(self, curIndex, len): return curIndex+1 if curIndex &lt; len-1 else 0 if __name__ == '__main__': result = Solution().main([1,2,4,5,3]) print(result) 参考文献https://www.cnblogs.com/grandyang/p/8887985.htmlhttps://blog.csdn.net/qq_35314344/article/details/76083170]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-滑动窗口问题]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原始问题分析给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。常规解法：时间复杂度为$O(N * w)$，也就是每次对一个窗口都需要遍历其中的 w 个数，选出最大值。 $O(N)$解法：准备一个双端队列，双端队列存放着数组中的下标值。假设当前为 arr[i]，则放入规则如下：left 和 right 指针都只会向右移动，不会回退。 right 右滑，窗口加数： 1）如果 queue 为空，直接把下标 i 放入 queue 中； 2）如果 queue 不为空，取出当前 queue 队尾存放的下标 j。如果 arr[j] &gt; arr[i]，则直接把 i 放入队尾； 3）如果 arr[j] &lt;= arr[i]，则一直从 queue 的队尾弹出下标，直到某个下标在 queue 中的对应值大于 arr[i]，然后把 i 放入队尾 【为什么可以弹出，因为我永远比你晚过期，我又比你大或者和你一样大，有我在，你永远不可能最大，所以你可以弹出了】 left 右滑，窗口减数： 1）看弹出的 left 是否与队列头相等，如果相等，说明这个队列头已经不在窗口内了，所以弹出 queue 当前的队首元素 。 双端队列的队头就是当前窗口最大值的下标。 应用上面的滑动窗口的实现是通用结构，即 left 和 right 指针随便往右移，而在实际解题过程在，都是会限制窗口的大小。 1. 剑指offer：滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 常规解法：时间复杂度为O(N * w)，也就是每次对一个窗口都需要遍历其中的 w 个数，选出最大值。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result) $O(N)$解法：和通用结构相比。只在弹出时稍微改变：如果queue对应的下标等于i-size, 说明当前队首下标已经过期，则弹出queue当前队首下标。 1234567891011121314151617181920from collections import deque# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] res = [0] * (len(num)-size+1) index = 0 queue = deque() for i in range(len(num)): while len(queue) != 0 and num[queue[-1]] &lt;= num[i]: queue.pop() queue.append(i) if queue[0] == i-size: queue.popleft() if i &gt;= size-1: # 有窗口形成后，在计算窗口内最大值 res[index] = num[queue[0]] index += 1 return res 2. 最大值减去最小值小于或等于num的子数组数量给定数组arr和整数num，返回有多少个子数组满足如下情况: $max(arr[i:j]) - min(arr[i:j]) &lt;= num$ $max(arr[i:j])$表示子数组$arr[i:j]$中的最大值，$min(arr[i:j])$表示子数组$arr[i:j]$中的最小值。 要求：如果数组长度为 N，请实现时间复杂度为 O(N)的解法。 解题思路子数组的数量：以0开始：0~0，0~1，...，0~N-1，共N种情况；以1开始：1~1，1~2，...，1~N-1，共N-1种情况；……以N-1开始：N-1~N-1，共1种情况。所以总共有 $N+N-1+N-2+…+2+1=\frac{N(N-1)}{2}$种情况。 暴力解法：两层遍历所有情况，一层遍历求最大最小值，共三层遍历，时间复杂度$O(N^3)$。 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def main(self, arr, num): # write code here res = 0 for start in range(len(arr)): for end in range(start, len(arr)): if self.isValid(arr, start, end, num): res += 1 return res def isValid(self, arr, start, end , num): max_value = float('-inf') min_value = float('inf') for i in range(start, end+1): max_value = max(max_value, arr[i]) min_value = min(min_value, arr[i]) return max_value-min_value &lt;= numif __name__ == '__main__': result = Solution().main([1,3,5,7,9,11,13,15],4) print(result) $O(N)$解法： 两个结论： 如果子数组arr[i:j]满足条件，那么arr[k:l]（i&lt;=k&lt;=l&lt;=j）一定满足条件，即若一个数组满足条件，它的所有子数组肯定满足条件，因为[max 变小 - min 变大 &lt;= num 肯定成立]。 如果子数组 arr[i:j] 不满足条件，那么 arr[k:l] （k &lt;= i，I &gt;= j） 都不满足条件，即若一个数组不满足条件，所有包含它的数组肯定都不满足条件。因为[max变大 - min变小 &gt;= num肯定成立]。 步骤：准备两个双端队列，一个 maxQueue 是窗口内最大值更新结构，一个 minQueue 是窗口内最小值更新结构，left、right 表示窗口的左右边，窗口范围为 [left , right - 1]；算以 left 开头达标的子数组个数，每个 left 就可以算出一批答案，相加即可。 1)以 left 开头的情况下，right 往外扩，扩到不达标就停【因为再往外肯定也不达标】，算以 left 开头的子数组有多少个【这些子数组都达标的】； 2)left 右移一位，然后重复 1）。 因为 left，right 都不后退，且每个数都只进出一次，所以时间复杂度是 $O(N)$。 12345678910111213141516171819202122232425262728293031323334353637383940from collections import deque# -*- coding:utf-8 -*-class Solution: def main(self, arr, num): # write code here maxQueue = deque() minQueue = deque() left, right = 0, 0 res = 0 while left &lt; len(arr): while right &lt; len(arr): while len(maxQueue) != 0 and arr[maxQueue[-1]] &lt;= arr[right]: maxQueue.pop() maxQueue.append(right) while len(minQueue) != 0 and arr[minQueue[-1]] &gt;= arr[right]: minQueue.pop() minQueue.append(right) if arr[maxQueue[0]] - arr[minQueue[0]] &gt; num: # 不满足 break right += 1 # left向前推动， 两个双端队列调整 if maxQueue[0] == left: maxQueue.popleft() if minQueue[0] == left: minQueue.popleft() res += right - left # 收集满足的结果 left += 1 # 下一个开头 return res if __name__ == '__main__': result = Solution().main([1,3,5,7,9,11,13,15],4) print(result) 参考文献：https://blog.csdn.net/pcwl1206/article/details/96431668https://www.cnblogs.com/xieyupeng/p/10373585.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-BFPRT算法]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-BFPRT%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。而目前解决TOP-K问题最有效的算法即是BFPRT算法，其又称为中位数的中位数算法，该算法由Blum、Floyd、Pratt、Rivest、Tarjan提出，最坏时间复杂度为$O(n)$。 在首次接触TOP-K问题时，我们的第一反应就是可以先对所有数据进行一次排序，然后取其前k即可，但是这么做有两个问题：（1）快速排序的平均复杂度为$O(nlogn)$，但最坏时间复杂度为$O(n^2)$，不能始终保证较好的复杂度。（2）我们只需要前k大的，而对其余不需要的数也进行了排序，浪费了大量排序时间。 除这种方法之外，堆排序也是一个比较好的选择，可以维护一个大小为k的堆，时间复杂度为$O(nlogk)$。 那是否还存在更有效的方法呢？受到快速排序的启发，通过修改快速排序中主元的选取方法可以降低快速排序在最坏情况下的时间复杂度（即BFPRT算法），并且我们的目的只是求出前k，故递归的规模变小，速度也随之提高。下面来简单回顾下快速排序的过程，以升序为例：（1）选取主元（首元素，尾元素或一个随机元素）；（2）以选取的主元为分界点，把小于主元的放在左边，大于主元的放在右边；（3）分别对左边和右边进行递归，重复上述过程。 快速排序代码12345678910111213141516171819202122232425262728293031323334class Solution(object): def main(self, nums, k): self.quickSort(nums, 0, len(nums)-1) return nums[k] def quickSort(self, nums, left, right): if left &gt;= right: return povit = self.partition(nums, left, right) self.quickSort(nums, left, povit-1) self.quickSort(nums, povit+1, right) def partition(self, nums, left, right): temp = nums[left] while left &lt; right: while left &lt; right and nums[right] &gt;= temp: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &lt;= temp: left += 1 self.swap(nums, left, right) return left def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = tempif __name__ == '__main__': res = Solution().main([3,4,1,2,5,7,23,4,1,5], 4) print(res) BFPRT算法BFPRT算法步骤如下：（1）选取主元； （1.1）将n个元素划分为$n/5$个组，每组5个元素，最后不足5个的为一组； （1.2）使用插入排序找到$n/5$个组中每一组的中位数； （1.3）对于（1.2）中找到的所有中位数，调用BFPRT算法求出它们的中位数，作为主元；（2）以（1.3）选取的主元为分界点，把小于主元的放在左边，等于主元的放中间，大于主元的放在右边，返回等于主元的左右边界；（3）判断主元的位置与k的大小，有选择的对左边或右边递归。 下面为代码实现，其所求为前K小的数：注意：在partition()中，需要首先将主元和最左边的元素进行交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution(object): def main(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ return self.bfprt(nums, 0, len(nums)-1, k-1) def bfprt(self, nums, left, right, k): if left &gt;= right: return nums[left] povitValue = self.medianOfMedians(nums, left, right) povitRange = self.partition(nums, left, right, povitValue) # 等于区域的左右边界 if k &gt;= povitRange[0] and k &lt;= povitRange[1]: # k 在左右边界内 直接返回 return nums[k] elif k &lt; povitRange[0]: # k在左边 return self.bfprt(nums, left, povitRange[0]-1, k) else: # k在右边 return self.bfprt(nums, povitRange[1]+1, right, k) def medianOfMedians(self, nums, left, right): len_ = right-left + 1 offset = 0 if len_%5 == 0 else 1 mArr = [0]*(len_//5+offset) for i in range(len(mArr)): left_I = left + i*5 right_I = left_I + 4 mArr[i] = self.getMedian(nums, left_I, min(right, right_I)) return self.bfprt(mArr, 0, len(mArr)-1, len(mArr)//2) def getMedian(self, nums, left, right): for i in range(left+1, right+1): j = i temp = nums[i] while j-1 &gt;= left and nums[j-1] &gt; temp: nums[j] = nums[j-1] j -= 1 nums[j] = temp return nums[(left+right)//2 + (left+right)%2] def partition(self, nums, left, right, povitValue): index = nums.index(povitValue) self.swap(nums, left, index) while left &lt; right: while left &lt; right and nums[right] &gt;= povitValue: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &lt;= povitValue: left += 1 self.swap(nums, left, right) return [left, right] def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = tempif __name__ == '__main__': res = Solution().main([7,6,5,4,3,2,1], 5) print(res) 时间复杂度分析BFPRT算法在最坏情况下的时间复杂度是$O(n)$，下面予以证明。令$T(n)$为所求的时间复杂度，则有： $T(n)≤T(\frac{n}{5})+T(\frac{7n}{10})+c⋅n$ (c为一个正常数) 其中： $T(\frac{n}{5})$来自medianOfMedians()，n个元素，5个一组，共有$\frac{n}{5}$个中位数； $T(\frac{7n}{10})$来自bfprt()，在$\frac{n}{5}$个中位数中，主元x大于其中 $\frac{1}{2}\frac{n}{5} = \frac{n}{10}$的中位数，而每个中位数在其本来的5个数的小组中又大于或等于其中的3个数，所以主元x至少大于所有数中的 $\frac{n}{10}3=\frac{3n}{10}$个。即划分之后，任意一边的长度至少为$\frac{3}{10}$，在最坏情况下，每次选择都选到了$\frac{7}{10}$的那一部分。 $c⋅n$来自其它操作，比如getMedian()中的插入排序，以及medianOfMedians()和partition()里所需的一些额外操作。 设$T(n)=t \cdot n$，其中t为未知，它可以是一个正常数，也可以是一个关于n的函数，代入上式： $t \cdot n \leq \frac{t \cdot n}{5}+\frac{7 t \cdot n}{10}+c \cdot n$ (两边消去n)$t \leq \frac{t}{5}+\frac{7 t}{10}+c$ (再化简)$t \leq \frac{9t}{10}+ c$ (c为一个正常数)$t \leq 10 c$ 其中c为一个正常数，故t也是一个正常数，即$T(n) \leq 10 c \cdot n$ (c为一个正常数)，因此$T(n)=O(n)$，至此证明结束。 例题： leetcode 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路可以使用快排，堆排，归并排序等算法进行解题，但平均复杂度为$O(nlogn)$。 以下代码为使用BFPRT算法解决，复杂度为$O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 return self.bfprt(nums, 0, len(nums)-1, k-1) def bfprt(self, nums, left, right, k): if left &gt;= right: return nums[left] povitValue = self.medianOfMedians(nums, left, right) povitRange = self.partition(nums, left, right, povitValue) # 等于区域的左右边界 if k &gt;= povitRange[0] and k &lt;= povitRange[1]: # k 在左右边界内 直接返回 return nums[k] elif k &lt; povitRange[0]: # k在左边 return self.bfprt(nums, left, povitRange[0]-1, k) else: # k在右边 return self.bfprt(nums, povitRange[1]+1, right, k) def medianOfMedians(self, nums, left, right): len_ = right-left + 1 offset = 0 if len_%5 == 0 else 1 mArr = [0]*(len_//5+offset) for i in range(len(mArr)): left_I = left + i*5 right_I = left_I + 4 mArr[i] = self.getMedian(nums, left_I, min(right, right_I)) return self.bfprt(mArr, 0, len(mArr)-1, len(mArr)//2) def getMedian(self, nums, left, right): self.insertSort(nums, left, right) return nums[(left+right)//2 + (left+right)%2] def partition(self, nums, left, right, povitValue): index = nums.index(povitValue) self.swap(nums, left, index) while left &lt; right: while left &lt; right and nums[right] &lt;= povitValue: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &gt;= povitValue: left += 1 self.swap(nums, left, right) return [left, right] def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = temp def insertSort(self, nums, left, right): for i in range(left+1, right+1): j = i temp = nums[i] while j-1 &gt;= left and nums[j-1] &lt; temp: nums[j] = nums[j-1] j -= 1 nums[j] = temp 参考文献：https://en.wikipedia.org/wiki/Median_of_medianshttps://blog.csdn.net/laojiu_/article/details/54986553]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-Manacher算法]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Manacher%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 算法过程由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 … s[i] # a # b # b # a # h # … p[i] 1 2 1 2 5 2 1 2 1 2 1 … 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图： 设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def manacher(self, s): if len(s) == 0: return 0 s = self.init(s) p = [0] * len(s) id = -1 mx = -1 res = 0 center = 0 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i # id是最右回文子串的中心 return res-1 def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return resif __name__ == '__main__': res = Solution().manacher("cbbd") print(res)` 算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 O(n)O(n)，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线 + 两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 while (s[i - p[i]] == s[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher（）中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。 例子： leetcode 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。 12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] Manacher算法 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) == 0: return '' s = self.init(s) p = [0] * len(s) id = -1 # 记录最右回文子串的中心 mx = -1 res = 0 maxCenter = 0 # 记录最长回文子串的中心 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if p[i] &gt; res: maxCenter = i res = p[i] return ''.join(s[maxCenter-(res-1):maxCenter+res-1+1].split('#')) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return res` 在字符串后面添加最少字符使成为回文字符串解题思路使用马拉车算法求解，求得最右回文子串，其左边的逆序添加到后面即整体变为回文。添加的长度为最右回文子串的左边部分长度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def manacher(self, s): if len(s) == 0: return 0 new_s = self.init(s) p = [0] * len(new_s) id = -1 mx = -1 maxContainsEnd = -1 for i in range(len(new_s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(new_s) and i - p[i] &gt; -1: if new_s[i+p[i]] == new_s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if mx == len(new_s): maxContainsEnd = p[i] break return len(s) - (maxContainsEnd -1) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return resif __name__ == '__main__': res = Solution().manacher("abcd123321") print(res) Reference：https://subetter.com/algorithm/manacher-algorithm.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E8%B4%AA%E5%BF%83%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[拼接所有字符串产生字典顺序最小的字符串123456789101112class Solution: def lowerString(self, strs): for i in range(len(strs)): for j in range(i+1, len(strs)): if strs[i] + strs[j] &gt; strs[j] + strs[i]: strs[i], strs[j] = strs[j], strs[i] return ''.join(strs)if __name__ == '__main__': res = Solution().lowerString(['b','ba','abc']) print(res) 分金条一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？ 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。 输入一个数组，返回分割的最小代价 123456789101112131415161718from heapq import *class Solution: def gold(self, nums): heap = [] for x in nums : heappush(heap, x) res = 0 while len(heap) &gt; 1: cur = heappop(heap) + heappop(heap) res += cur heappush(heap, cur) return resif __name__ == '__main__': res = Solution().gold([10,20,30]) print(res) 502. IPO解题思路以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:12345678910输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意: 假设所有输入数字都是非负整数。表示利润和资本的数组的长度不超过 50000。答案保证在 32 位有符号整数范围内。 解题思路用两个堆。所有项目进入按照启动资金进小根堆。每一次做项目时，先将当前资本能做的项目从小根堆中弹出，进入大根堆，大根堆按照最大利润组织，然后从大根堆中弹出利润最大的项目，将所得利润加到资本中。这样可以保证每次先做当前资本所有能做的项目中利润最大的项目。 1234567891011121314151617181920212223242526272829from heapq import *class Solution(object): def findMaximizedCapital(self, k, W, Profits, Capital): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ minCHeap = [] # 项目启动资金的小根堆 for i in range(len(Profits)): heappush(minCHeap, [Capital[i], Profits[i]]) # 资本大于项目启动资金的所有项目按利润大根堆 maxPHeap = [] while k &gt; 0: while minCHeap and W &gt;= minCHeap[0][0]: pair = heappop(minCHeap) heappush(maxPHeap, -pair[1]) if maxPHeap: W += -heappop(maxPHeap) k -= 1 return W` 最多的会议场数一些项目要占用一个会议室宣讲， 会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数组， 里面 是一个个具体的项目)，你来安排宣讲的日程， 要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。输入：n 代表有n个会议需要安排之后的 n 行，每行有两个数子，代表会议的开始和结束的时间 思路：我们只需要按照会议结束的时间进行排序，然后依次安排，就能够安排最多的场数 123456789101112131415161718192021222324252627282930313233343536373839class Meeting(object): def __init__(self, start, end): self.start = start self.end = endclass Solution(object): def Main (self): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ n = int(input()) # 按结束时间排序 meeting = [None]*n for i in range(n): pair = [int(x) for x in input().split()] meeting[i] = Meeting(pair[0], pair[1]) meeting = sorted(meeting, key = lambda x:x.end) res = 1 lastEnd = meeting[0].end for i in range(len(meeting)): if meeting[i].start &lt; lastEnd: continue res += 1 lastEnd = meeting[i].end return resif __name__ == '__main__': res = Solution().Main () print(res)`]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构-并查集]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 合并-查找问题什么是合并查找问题呢？顾名思义，就是既有合并又有查找操作的问题。举个例子，有一群人，他们之间有若干好友关系。如果两个人有直接或者间接好友关系，那么我们就说他们在同一个朋友圈中，这里解释下，如果Alice是Bob好友的好友，或者好友的好友的好友等等，即通过若干好友可以认识，那么我们说Alice和Bob是间接好友。随着时间的变化，这群人中有可能会有新的朋友关系，这时候我们会对当中某些人是否在同一朋友圈进行询问。这就是一个典型的合并－查找操作问题，既包含了合并操作，又包含了查找操作。 这个问题很容易想到朴素算法，每个人用一个编号来表示他所在的朋友圈，如果有新认识的朋友，我们就合并朋友圈，即把两人的朋友圈中所有人编号标识成一样。 简单解释一下这个图，刚开始A和B是好友，用蓝色背景标记，C和D是好友，用绿色背景标记，如果询问两个人是否在同一个朋友圈，那么只要看一下他们标记是否相同。过了不久，A和D又成为了好友，我们把两个朋友圈中所有的人标记变成相同的颜色，这就完成了一次合并的操作。 我们来粗略的计算下复杂度，假设我们要合并Alice和Bob的朋友圈，需要找到所有和Bob在同一朋友圈里的人，并标记为Alice所在的朋友圈。代码如下 12345# group[i]表示i所在的朋友圈编号# 将朋友圈B合并到朋友圈A中for i in range(n): if group[i] == group[B]: group[i] = group[A] 合并代码非常简单，那么可以看到一次合并的复杂度为$O(n)$，一共有n个人，因此最多可能要合并$n-1$次，合并的复杂度为$n^2$，加上Q个朋友圈询问，那么总的复杂度就是$O(n^2+Q)$。当n很大的时候，算法是不可接受的。 并查集这个时候我们就希望重新设计一种数据结构，能够高效的处理这三种操作，分别是 MAKE-SET(x)，创建一个只有元素x的集合，且x不应出现在其他的集合中 UNION(x, y)，将元素x所在集合Sx和元素y所在的集合Sy合并，这里我们假定Sx不等于Sy FIND-SET(x)，查找元素x所在集合的代表 现在我们再来看一下刚刚那道题，起初每个人都互相不认识，我们可以调用n次MAKE-SET来创建n个集合，当有两个人互相认识的时候，那么我们用UNION来合并两个集合。最后，如果询问x和y是否在同一个朋友圈的时候，我们调用两次FIND-SET来判断x和y所在集合的代表是否相同，从而判断他们是否在同一个集合内。 这个时候就该并查集出场了，它能够高效的处理前面提到的三种操作，用于维护一系列不相交集合动态操作的数据结构。每个不相交集合都有一个代表用于表示整个集合，并且这个代表也是集合内的成员。下面来说一下并查集是如何工作的。在并查集中，每个不相交的集合都用一颗有根树来表示，每个元素都是树上的一个节点，我们继续用刚刚的朋友圈问题来解释。 我们来解释下这个图，起初有5个人，编号为1-5，刚开始大家都互不认识，所以各自为一个节点的树。这时候如果1和2认识了，那么我们就把这两个节点所代表的树合并起来，由编号较小的1作为根。接着3和4又认识了，那么我们重复刚刚的过程，把3和4所代表树合并起来。现在1和4认识了，该怎么办呢，首先我们先找到1和4所在树的根，1的根就是1，而4的根就是3，这时候我们把这两颗树合并，并把1设置为3的父亲节点，这时候就完成了两颗树的合并。在这系列操作中，初始化构建树就是MAKE-SET操作，树的合并就是UNION操作，而找根的过程就是FIND-SET操作。 下面讲一讲并查集的具体实现。对于有根树或者说森林的表示，可以用一个数组parent来实现。parent[i]记录元素i的父节点的编号，如果节点i本身就是根节点，那么parent[i]就是-1。MAKE-SET操作就是将parent数组赋值为-1。123def MAKE_SET(self, arr): parent = [-1]*len(arr) return parent UNION操作需要找到两个元素的根，并把其中一个元素的根节点设置为另一个元素的根节点，其实就是调用了两次FIND-SET，代码如下12345678# 将y所在的集合合并到x所在的集合中# 分别查找出x和y所在集合的根节点# 将y元素所在的集合的代表节点的根节点设置为x所在集合的根节点def union(self, x, y): px = find_set(x) py = find_set(y) if px != py: parent[py] = px 再来说下FIND-SET这个操作的实现。首先有个很朴素的算法，对父节点递归调用FIND-SET，直到找到根为止。如果父节点是-1，那么返回当前节点，否则递归调用查询父亲的根节点。代码如下12345# 递归查找x所在集合的根节点def find_set(self, x): if parent[x] == -1: return x return find_set(parent[x]) 但是，如果我们这棵树很深，那么每次调用FIND-SET可能会需要O(n)的时间。 这时候，我们就要引入路径压缩这个概念。什么是路径压缩呢？就是在递归找到根节点的时候，把当前节点到根节点间所有节点的父节点都设置为根节点。举个例子 我们来看下图，首先我们有个这样的一棵树，现在要找到元素9所在树的根节点，在找根节点的过程中使用路径压缩，也就是说9到根的路径上的节点9，6，3，1的父节点都设置成为根节点0，所以呢，在FIND-SET(9)之后，树的形态就变成了下面的样子 我们可以看到经过路径压缩的节点及其子树到根节点的深度减小了很多，所以在以后的操作中，查找根节点的速度会快很多，平摊下来每次FIND-SET的操作几乎是常数级别的。代码也相当简单，就只多了一句话123456# 带有路径压缩的并查集def find_set(self, x): if parent[x] == -1: return x parent[x] = find_set(parent[x]) return parent[x] 刚刚在合并的过程中，并没有提到说到如何选取根，一般情况下两个根节点随意选取一个，如果需要更优的算法，可以按秩合并，就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。 12345678910111213141516171819# 初始化根节点为-1# 初始化各集合大小为1def MAKE_SET(self, arr): parent = [-1] * len(arr) sizeMap = [1] * len(arr) return parentdef union(self, x, y): px = find_set(x) py = find_set(y) if px != py: xSize = sizeMap[px] ySize = sizeMap[py] if xSize &lt;= ySize: parent[px] = py sizeMap[py] = xSize + ySize else: parent[py] = px sizeMap[px] = xSize + ySize 并查集是一种支持合并集合和查找集合的一种数据结构，能用均摊线性的复杂度执行各种操作，在kruskal算法、求联通分支数等算法中起到关键的作用。 总结为了表示一个元素所属的集合，我们从一个集合当中挑选出一个代表元素作为根节点。对于每个元素，都记录一下它对应的根节点是谁，这样就可以通过根节点来表示它所述的集合。在集合合并时，如果对一个小集合中的所有元素都修改其根节点，则会造成合并的开销过大。为了减小开销，我们在合并时采取层次化的结构，按照按秩合并的方法，可以使合并操作的复杂度降为O(1)，但是这在减少合并开销的同时又增加了查询开销，使得总开销并没有降低。为了进一步减少查询开销，引入了路径压缩这个操作，使得长路径上的检索只需要发生一次。 参考文献：https://mp.weixin.qq.com/s/50QN956P6Udpo4AKlWfeewhttps://zhuanlan.zhihu.com/p/54567565https://zhuanlan.zhihu.com/p/54727138]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-一致性哈希]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 一、Redis集群的使用我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示： 同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。 假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下： 由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。 二、为Redis集群使用Hash可想而知，如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如下： 上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！ 三、使用Hash的问题上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！ 试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！ 同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！ 所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！ 四、一致性Hash算法的神秘面纱一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下： 整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！ 例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 五、一致性Hash算法的容错性和可扩展性现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示： 下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示： 此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。 六、Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。 例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。 注意：上图有些误导性，实际上要把NodeA#1, NodeA#2, NodeA#3, NodeB#1, NodeB#2, NodeB#3打乱。 七、总结上文中，我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！ 原文链接：https://zhuanlan.zhihu.com/p/34985026感谢原作者的辛勤付出！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 哈希表]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 散列表散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。即:存储位置=f(关键字)采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表，关键字对应的记录存储位置称为散列地址。散列技术既是一种存储方法，也是一种查找方法。它也线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字关联。因此，散列主要是面向查找的存储结构，适合求解的问题是查找与给定值相等的记录。 1.1 散列冲突每个关键字 $key1 \not= key2$，但却有$f(key1) = f(key2)$，这种现象称为冲突，并把key1和key2称为这个散列函数的同义词。出现了冲突当然非常糟糕，那将造成数 据查找错误。 2 散列函数的构造方法2.1 构造原则 计算简单。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。 散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，并减少为处理冲突而耗费的时间。 2.2 构造方法2.2.1 直接定址法取关键字的某个线性函数值为散列函数，即：$f(key) = a * key + b$，（a、b为常数） 优点是简单、均匀、不会产生冲突 缺点是需要首先知道关键字的分布情况，适合查找表较小且连续的情况 2.2.2 数字分析法基于抽取的方法，即使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布 且关键字的若干位分布较均匀，就可以考虑用这个方法。 2.2.3 平均取中法先对关键字求平方，在抽取中间的k位作为散列地址。比如关键字是 1234， 那么它的平方就是 1522756，再抽取中间的 3 位就是 227 ，用做散列地址。适合于不知道关键字的分布，且位数不是很大的情况。 2.2.4 折叠法将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够 时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如我们的关键字是 9876543210 ，散列表表长为三位，我们将它分为四组， 9871654132110， 然后将它们叠加求和987+654+321+0=1962，再求后 3 位得到散列 地址为 962。有时可能这还不能够保证分布均匀 ， 不妨从一端向另一端来回折叠后对齐相加。 比如我们将 987 和 321 反转，再与 654 和 0 相加， 变成 789+654+123+0=1566，此时散列地址为 566.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。 2.2.5 除留余数法对于散列表长为m的散列函数公式为：$f(key) = key mod p, (p \leq m)$不仅可以对关键字直接取模，还可在折叠、平方取中后再取模。 2.2.6 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址。即：$f (key) =random (key)$这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 3 散列冲突的处理方法3.1 开放定址法 (线性探测法)一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1,2,3,…,m-1)$ 堆积：两个关键字同时争夺同一个地址。此时需要不断处理冲突，降低存入和查找的效率。 解决方法1：二次探测法，增加平方运算使关键字尽可能分散。即：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1^2, -1^2, 2^2, -2^2 ,…,q^2, -q^2, q \leq m/2)$ 解决方法2：随机探测法，在冲突时，对于位移量 $d_i$，采用随机函数计算得到。即：$f_i (key) = (f(key) + d_i) mod m, d_i )$是一个随机数列 3.2 再散列函数法换一个不同的函数重新计算散列地址。$f_i (key) = RH_i(key), i=1,2,…,ki )$$RH_i$为不同的散列函数，如除留余数、折叠、平方取中等。 3.3 链地址法不存在冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。但带来了查找时需要遍历单链装的性能损耗。 3.4 公共溢出区法为所有冲突的关键字建立一个公共的溢出区来存放。查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对， 如果相等，则查找成功； 如果不相等，则到溢出表去进顺序查找； 如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。 4 散列表查找性能时间复杂度为O(1)。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-布隆过滤器]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 布隆过滤器背景虽然位图可以节省空间，但是数据量大的时候需要的内存还是比较大的。布隆过滤器就是为了解决这个问题，对位图数据结构的一种改进。 举例：考虑数据个数是1千万，数字范围是1到10亿，使用位图需要10亿个二进制位，而布隆过滤器的做法是，使用一个1亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这1到1亿范围内。比如我们把哈希函数设计成 $f(x)=x%n$。其中，x表示数字，n表示位图的大小（1亿），也就是，对数字跟位图的大小进行取模求余。 这时哈希函数会存在冲突的问题啊，一亿零一和1两个数字，经过你刚刚那个取模求余的哈希函数处理之后，最后的结果都是1。这样我就无法区分，位图存储的是1还是一亿零一了。如何降低冲突的概率？用K个哈希函数！！ 布隆过滤器定义布隆过滤器是一种空间效率很高的随机数据结构，它的原理是当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，将它们置为1。检索时，我们只要看看这些点是不是都是1就大约知道集合中有没有它了：如果这些点有任何一个点为0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。这就是布隆过滤器的基本思想。 但布隆过滤器的这种高效是有代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom filter不适合那些“零错误”的应用场合。而在能容忍低错误率的场景下，布隆过滤器通过极少的错误换取了存储空间的极大节省。 布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。 集合表示和元素查询具体来看Bloom Filter是如何用位数组表示集合的。初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0。 为了表达$ \mathrm{S}=\left\{\mathrm{x}_{1}, \mathrm{x}_{2}, \ldots, \mathrm{x}_{\mathrm{n}}\right\} $这样一个$n$个元素的集合，Bloom Filter使用$k$个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到$\{1,…,m\}$的范围中。对任意一个元素$x$，第$i$个哈希函数映射的位置$h_i(x)$就会被置为1（$1≤i≤k$）。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。 在判断y是否属于这个集合时，我们对y应用k次哈希函数，如果所有$h_i(y)$的位置都是1（1≤i≤k），那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中$y_1$就不是集合中的元素（因为$y_1$有一处指向了“0”位）。$y_2$或者属于这个集合，或者刚好是一个false positive。 位数组大小对于给定的p（误判率）和将要加入集合的元素个数n，位数组大小m由如下公式定义： m=-\frac{n \cdot \ln p}{(\ln 2)^{2}}最优的哈希函数个数对于给定的位数组大小m和将要加入集合的元素个数n，使得误判率最小的哈希函数个数k通过如下公式定义： k=\frac{m}{n} \ln 2 \approx 0.7 \cdot \frac{m}{n}误判率估计对于给定的位数组大小m，将要加入集合的元素个数n，及哈希函数个数k，误判率可以重新计算为： p=\left(1-\mathrm{e}^{-k n / m}\right)^{k}应用在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。Bloom Filter在时间空间这两个因素之外又引入了另一个因素：错误率。在使用Bloom Filter判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（False Positive），但不会把属于这个集合的元素误认为不属于这个集合（False Negative）。在增加了错误率这个因素之后，Bloom Filter通过允许少量的错误来节省大量的存储空间。 Bloom Filter就被广泛用于拼写检查和数据库系统中。 也可以用来实现数据字典，进行数据的判重，或者集合求交集 。 参考文献：https://blog.csdn.net/v_july_v/article/details/6685894https://blog.csdn.net/jiaomeng/article/details/1495500https://blog.csdn.net/tick_tock97/article/details/78688159]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-跳表]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 跳表跳表(SkipList)：增加了向前指针的链表叫做跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质是一种可以进行二分查找的有序链表。跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。 跳表是redis的一个核心组件，也同时被广泛地运用到了各种缓存地实现当中，它的主要优点，就是可以跟红黑树、AVL等平衡树一样，做到比较稳定地插入、查询与删除。理论插入查询删除的算法时间复杂度为O(logN)。 有序表的搜索背景：考虑一个有序表，我们要查找其中的元素，我们只能从头开始遍历链表，直到查找到元素为止。链表是有序的，但是不能使用二分查找，是不是很捉急？（P.S.数组可以实现二分查找）那么，有没有什么方法可以实现有序链表的二分查找呢？答案是肯定的，那就是我们将要介绍的这种数据结构——跳表。 从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗? 链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构： 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构： 这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。 跳表的结构下面的结构是就是跳表：其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。 跳表的性质(1) 由很多层结构组成(2) 每一层都是一个有序的链表(3) 最底层(Level 1)的链表包含所有元素(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 跳表的搜索 例子：查找元素 117(1) 比较 21， 比 21 大，往后面找(2) 比较 37, 比 37大，比链表最大值小，从 37 的下面一层开始找(3) 比较 71, 比 71 大，比链表最大值小，从 71 的下面一层开始找(4) 比较 85， 比 85 大，从后面找(5) 比较 117， 等于 117， 找到了节点。 具体的搜索算法如下，C代码12345678910111213/* 如果存在 x, 返回 x 所在的节点， * 否则返回 x 的后继节点 */ find(x) &#123; p = top; while (1) &#123; while (p-&gt;next-&gt;key &lt; x) p = p-&gt;next; if (p-&gt;down == NULL) return p-&gt;next; p = p-&gt;down; &#125; &#125; 跳表的插入先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）然后在 Level 1 … Level K 各个层的链表都插入元素。例子：插入 119， K = 2 如果 K 大于链表的层数，则要添加新的层。例子：插入 119， K = 4 丢硬币决定 K插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：1234567int random_level() &#123; K = 1; while (random(0,1)) K++; return K; &#125; 相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 $p = 1/2$ 的几何分布，K 的期望值 $E[K] = 1/p = 2$. 就是说，各个元素的层数，期望值是 2 层。 跳表的复杂度在跳表中每两个结点都会抽出一个结点作为上一级索引的结点。如果链表里有n个结点，那么第一级索引的个数大约就是n/2，第二级的索引大约就是n/4，第三级的索引就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那么第k级的索引结点个数为：$\frac{n}{2^k}$。如果最高级索引有 2 个结点，即$\frac{n}{2^k}=2$，那总的索引级数 $k=log_2n−1$，如果我们算上原始链表的话，那也就是跳表的高度为$log_2n$级。 在第 k 级索引中，假设我们要查找的数据为 x，当我们查找到 y 结点时，发现 $y&lt;x&lt;z $时此时我们就要下降到 k−1 级索引继续查找。在第 k−1 级索引中，y 和 z 之间只有三个结点，因此，我们最多只需要查找 3 个结点。以此类推，每一级的索引最多都只需要遍历 3 个结点。 而总的级别数为 $log_2n$，因此查找的时间复杂度就为 $3∗log_2n=logn$。跳表查找的时间复杂度和二分查找一样，但这其实是以空间来换时间的设计思路。 跳表的所有额外索引结点总数为 $\frac{n}{2} + \frac{n}{4} + \frac{n}{8} + … + 4 + 2 = n-2$，所以跳表的空间复杂度为$O(n)$。 跳表的删除在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。例子：删除 71 跳表的应用Redis中的有序集合使用跳表。Redis 中的有序集合支持的核心操作主要有以下几个： 插入一个数据 删除一个数据 查找一个数据 按照区间查找数据 迭代输出有序序列 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度和跳表是一样的。 但是，按照区间查找数据这个操作，红黑树的效率没有跳表高。跳表可以在 O(logn) 时间复杂度定位区间的起点，然后在原始链表中顺序向后查询就可以了，这样非常高效。 此外，相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点，因此 Redis 用跳表来实现有序集合。 参考文献：SkipList 跳表数据结构和算法之——跳表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解-数据库]]></title>
    <url>%2F2019%2F07%2F18%2FLeetCode%2FLeetcode-%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[175. 组合两个表题目描述表1: Person12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供?person 的以下信息： 1FirstName, LastName, City, State 解题思路123select p.FirstName, p.LastName, a.City, a.Statefrom Person as p left join Address as aon p.PersonId = a.PersonId; 176. 第二高的薪水题目描述编写一个 SQL 查询，获取 Employee?表中第二高的薪水（Salary）?。1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述?Employee?表，SQL查询应该返回?200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 解题思路直接select无法输出第二高薪水为空的情况。1select distinct salary as SecondHighestSalary from Employee order by salary desc limit 1, 1; 在外面加一层select，可以将空的赋值给SecondHighestSalary。1select(select distinct salary from Employee order by salary desc limit 1, 1) as SecondHighestSalary; 177. 第N高的薪水题目描述编写一个 SQL 查询，获取 Employee 表中第?n?高的薪水（Salary）。1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述?Employee?表，n = 2?时，应返回第二高的薪水?200。如果不存在第?n?高的薪水，那么查询应返回?null。12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ 解题思路123456789CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN SET N = N-1; RETURN ( # Write your MySQL query statement below. select distinct ifnull(salary, null) from Employee order by salary desc limit N, 1 ); END 178. 分数排名题目描述编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ 例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ 解题思路12345# Write your MySQL query statement belowselect p1.Score as Score,(select Count(distinct p2.score) from Scores as p2 where p2.score &gt;= p1.score) as Rankfrom Scores as p1order by Score desc; 180. 连续出现的数字题目描述编写一个 SQL 查询，查找所有至少连续出现三次的数字。1234567891011+----+-----+| Id | Num |+----+-----+| 1 | 1 || 2 | 1 || 3 | 1 || 4 | 2 || 5 | 1 || 6 | 2 || 7 | 2 |+----+-----+ 例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。12345+-----------------+| ConsecutiveNums |+-----------------+| 1 |+-----------------+ 解题思路1234# Write your MySQL query statement belowselect distinct l1.Num as ConsecutiveNumsfrom Logs l1, Logs l2, Logs l3where l1.num = l2.num and l2.num = l3.Num and l2.Id = l1.Id+1 and l3.Id = l2.id+1 181. 超过经理收入的员工题目描述Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。12345+----------+| Employee |+----------+| Joe |+----------+ 解题思路1234# Write your MySQL query statement belowselect e1.Name as Employee from Employee e1, Employee e2where e1.ManagerId = e2.Id and e1.salary &gt; e2.salary 182. 查找重复的电子邮箱题目描述编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例：1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果：12345+---------+| Email |+---------+| a@b.com |+---------+ 说明：所有电子邮箱都是小写字母。 解题思路123# Write your MySQL query statement belowselect Email from Person group by Email having count(ID)&gt;1 123# Write your MySQL query statement belowselect distinct p1.Email from Person p1, Person p2 where p1.Email = p2.Email and p1.Id != p2.Id 183. 从不订购的客户题目描述某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表：12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表：123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回：123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ 解题思路1234# Write your MySQL query statement belowselect c.Name as Customers from Customers c left join Orders o on c.Id = o.CustomerId where o.id is null 123# Write your MySQL query statement belowselect Name as Customers from Customers where Id not in (select CustomerId from Orders) 184. 部门工资最高的员工题目描述Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ 解题思路12345678# Write your MySQL query statement belowselect d.Name as Department, e.Name as Employee, e.Salaryfrom Employee as e,Department as d,(select DepartmentId, max(Salary) as max from Employee group by DepartmentId) as mwhere e.DepartmentId = m.DepartmentIdand e.Salary = m.maxand e.DepartmentId = d.Id]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 贪心算法]]></title>
    <url>%2F2019%2F07%2F18%2FLeetCode%2FLeetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是贪心算法相关题目题解总结。 [TOC] 贪心思想概念 最优子结构：最优子结构反映了分解问题的方式，我们在解决问题的时候，都会尝试将问题分解进行解决，产生的子问题，进而会产生局部解（总体解的子结构）。通常而言局部解也不仅只有一个，当局部解是局部最优解，并且该局部最优解是全局最优解的一部分时，我们称子问题的最优解为最优子结构。 最优子结构的性质：问题的最优解由相关自问题的最优解组合而成，而这些子问题可以独立求解。（需要注意这里独立求解的含义：当前最优，不考虑后面的步骤）；最优子结构的形式（或者是否有最优子结构）取决于你分解问题的方式。合理的分解达到的效果是：与最终问题的目标存在紧密的关系。如果分解问题之后却无法导出最终问题的解，那么这种问题分解的方式就是无意义的。 基本思想 贪心算法的基本思想是找出整体当中每个小的局部的最优解，并且将所有的这些局部最优解合起来形成整体上的一个最优解。因此能够使用贪心算法的问题必须满足下面的两个性质： 整体的最优解可以通过局部的最优解来求出； 一个整体能够被分为多个局部，并且这些局部都能够求出最优解。使用贪心算法当中的两个典型问题是活动安排问题和背包问题。 主要步骤 建立对问题精确描述的数学模型，包括定义最优解的模型； 将问题分解为一系列子问题，同时定义子问题的最优解结构； 应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。 0.1 拼接所有字符串产生字典顺序最小的字符串123456789101112class Solution: def lowerString(self, strs): for i in range(len(strs)): for j in range(i+1, len(strs)): if strs[i] + strs[j] &gt; strs[j] + strs[i]: strs[i], strs[j] = strs[j], strs[i] return ''.join(strs)if __name__ == '__main__': res = Solution().lowerString(['b','ba','abc']) print(res) 0.2 分金条一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？ 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。 输入一个数组，返回分割的最小代价 123456789101112131415161718from heapq import *class Solution: def gold(self, nums): heap = [] for x in nums : heappush(heap, x) res = 0 while len(heap) &gt; 1: cur = heappop(heap) + heappop(heap) res += cur heappush(heap, cur) return resif __name__ == '__main__': res = Solution().gold([10,20,30]) print(res) 0.3 IPO解题思路以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:12345678910输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意: 假设所有输入数字都是非负整数。表示利润和资本的数组的长度不超过 50000。答案保证在 32 位有符号整数范围内。 解题思路用两个堆。所有项目进入按照启动资金进小根堆。每一次做项目时，先将当前资本能做的项目从小根堆中弹出，进入大根堆，大根堆按照最大利润组织，然后从大根堆中弹出利润最大的项目，将所得利润加到资本中。这样可以保证每次先做当前资本所有能做的项目中利润最大的项目。 1234567891011121314151617181920212223242526272829from heapq import *class Solution(object): def findMaximizedCapital(self, k, W, Profits, Capital): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ minCHeap = [] # 项目启动资金的小根堆 for i in range(len(Profits)): heappush(minCHeap, [Capital[i], Profits[i]]) # 资本大于项目启动资金的所有项目按利润大根堆 maxPHeap = [] while k &gt; 0: while minCHeap and W &gt;= minCHeap[0][0]: pair = heappop(minCHeap) heappush(maxPHeap, -pair[1]) if maxPHeap: W += -heappop(maxPHeap) k -= 1 return W` 0.4 最多的会议场数一些项目要占用一个会议室宣讲， 会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数组， 里面 是一个个具体的项目)，你来安排宣讲的日程， 要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。输入：n 代表有n个会议需要安排之后的 n 行，每行有两个数子，代表会议的开始和结束的时间 思路：我们只需要按照会议结束的时间进行排序，然后依次安排，就能够安排最多的场数 123456789101112131415161718192021222324252627282930313233343536373839class Meeting(object): def __init__(self, start, end): self.start = start self.end = endclass Solution(object): def Main (self): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ n = int(input()) # 按结束时间排序 meeting = [None]*n for i in range(n): pair = [int(x) for x in input().split()] meeting[i] = Meeting(pair[0], pair[1]) meeting = sorted(meeting, key = lambda x:x.end) res = 1 lastEnd = meeting[0].end for i in range(len(meeting)): if meeting[i].start &lt; lastEnd: continue res += 1 lastEnd = meeting[i].end return resif __name__ == '__main__': res = Solution().Main () print(res)` 45. 跳跃游戏 II题目描述给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例:1234输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 解题思路需要知道每一步能跳的范围，然后遍历这个范围，根据该位置上的跳力来预测下一步能跳到的最远范围，贪的是一个能达到的最远范围。一旦这个范围达到了末尾，则返回。cur表示当前能达到的最远位置，初始为0pre表示之前能达到的最远位置，初始为0在每一次循环中， pre = cur，表示上一次循环后能达到的最远位置，在范围内求解当前位置能达到的最远距离cur。 1234567891011121314151617181920212223class Solution(object): def jump(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 res = 0 cur = 0 i = 0 while cur &lt; len(nums) - 1: res += 1 pre = cur while i &lt; pre+1: cur = max(cur, i+nums[i]) if cur &gt;= len(nums)-1: return res i += 1 return res` 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路设置最大和maxsub = nums[0]，中间和temp = 0；遍历数组加到temp中，若temp &gt; maxsub，则更新最大和maxsun；若temp &lt; 0，则置为0从新开始。 1234567891011121314151617class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 maxsub = nums[0] temp = 0 for i in range(len(nums)): temp += nums[i] if temp &gt; maxsub: maxsub = temp if temp &lt; 0: temp = 0 return maxsub 55. 跳跃游戏题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2:123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路贪心。使用一个变量保存当前能到达的最后位置的索引，向后遍历每个位置，如果该位置大于前面能到达的最大位置，则返回False，如果这个位置可以达到，则更新能达到的最后位置索引，更新策略是当前位置索引+这个数字能走多少步和原来能到的最大值。12345678910111213141516class Solution(object): def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 0: return True reach = 0 for i in range(len(nums)): if i &gt; reach: return False reach = max(reach, i+nums[i]) return True 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对数组进行遍历，定义到目前为止最大利润maxsum和加上当前利润的中间利润temp； 如果temp&gt;maxsum，则到目前最大利润maxsum = temp； 如果temp小于0，舍弃，temp = 0。 1234567891011121314151617class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxsum = 0 temp = 0 for i in range(1,len(prices)): temp += prices[i] - prices[i-1] if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ； 因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，从而在局部最优的情况下也保证全局最优。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxp = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: maxp += prices[i] - prices[i-1] return maxp 134. 加油站题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2:12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 解题思路12345678910111213141516171819202122class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ if len(gas) != len(cost) or len(gas) == 0: return -1 start = 0 rest = 0 overall = 0 for i in range(len(gas)): rest += gas[i]-cost[i] overall += gas[i]-cost[i] if rest &lt; 0: rest = 0 start = i+1 return start if overall &gt;= 0 else -1 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = “abc”, t = “ahbgdc”返回 true. 示例 2: s = “axc”, t = “ahbgdc”返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路双指针，遍历两个序列。 1234567891011121314151617181920class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if not s: return True if not t or len(s) &gt; len(t): return False i = j = 0 while i &lt; len(s) and j &lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s)if __name__ == '__main__': result = Solution().isSubsequence("ace","abcde") print(result) 406. 根据身高重建队列题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路 对people进行排序，h越大k越小的在前； 然后按顺序给个高的先排序，因为个高的排好后，再怎么对矮个排序，都不会影响个高人的相对位置。 12345678910111213class Solution(object): def reconstructQueue(self, people): """ :type people: List[List[int]] :rtype: List[List[int]] """ if len(people) &lt;= 1: return people people.sort(key = lambda x:[-x[0],x[1]]) res = [] for i in range(len(people)): res.insert(people[i][1],people[i]) return res 435. 无重叠区间题目描述给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 解题思路区间题目一般按照排序+贪心去求解： 先将区间按照起点升序； 令第一个区间为起始老区间，然后从第二个起进行遍历，如果遍历到的区间的起点比老区间的终点小，说明有重叠； 此时计数并移除区间，移除的为终点大的区间，即将老区间设置为终点小的区间； 如果没有重叠，则更新老区间为当前遍历到的区间。 12345678910111213141516171819202122232425# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def eraseOverlapIntervals(self, intervals): """ :type intervals: List[Interval] :rtype: int """ if len(intervals) &lt;= 1: return 0 intervals = sorted(intervals, key = lambda interval:interval.start) last = 0 count = 0 for i in range(1,len(intervals)): if intervals[i].start &lt; intervals[last].end: count += 1 if intervals[i].end &lt;intervals[last].end: last = i else: last = i return count 452. 用最少数量的箭引爆气球题目描述在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 Example: 输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 解题思路 使用排序+贪心。把所有坐标按照右边界进行排序，因为每个气球都要被打破，初始当前最远的位置curr_pos为第一个坐标的右边界，对坐标进行遍历； 如果当前遍历到的坐标左边界小于curr_pos，则说明有重叠，继续； 否则说明没有重叠，修改curr_pos为当前坐标的右边界，计数加1。 1234567891011121314151617181920class Solution(object): def findMinArrowShots(self, points): """ :type points: List[List[int]] :rtype: int """ if not points: return 0 points.sort(key=lambda x: x[1]) curr_pos = points[0][1] ans = 1 for i in range(len(points)): if curr_pos &gt;= points[i][0]: continue curr_pos = points[i][1] ans += 1 return ansif __name__ == '__main__': result = Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) print(result) 455. 分发饼干题目描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路对孩子胃口值g和饼干尺寸s排序，先用最小的饼干满足最小胃口值的孩子，如果最小饼干满足不了最小胃口值的孩子，则加大饼干值去满足该孩子。 1234567891011121314151617181920class Solution(object): def findContentChildren(self, g, s): """ :type g: List[int] :type s: List[int] :rtype: int """ if len(g)==0 or len(s)==0: return 0 g.sort() s.sort() child = i = 0 while child &lt; len(g) and i &lt; len(s): if s[i] &gt;= g[child]: child += 1 i += 1 return childif __name__ == '__main__': result = Solution().findContentChildren([10,9,8,7],[5,6,7,8]) print(result) 763. 划分字母区间题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1: 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意: S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。 解题思路 用字典记录每个字母在字符串中出现的最右位置； 然后对每个字母和位置进行遍历，找到最靠右位置end； 如果遍历到的当前位置和最靠右位置重合，说明已经找到了一个划分； 更新开始位置start，继续。 1234567891011121314151617181920class Solution(object): def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ if not S: return [] charIndex = &#123;c: i for i, c in enumerate(S)&#125; end = start = 0 ans = [] for i, c in enumerate(S): end = max(end,charIndex[c]) if i == end: ans.append(end-start+1) start = end + 1 return ansif __name__ == '__main__': result = Solution().partitionLabels("ababcbacadefegdehijhklij") print(result) 502. IPO解题思路以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:12345678910输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意: 假设所有输入数字都是非负整数。表示利润和资本的数组的长度不超过 50000。答案保证在 32 位有符号整数范围内。 解题思路用两个堆。所有项目进入按照启动资金进小根堆。每一次做项目时，先将当前资本能做的项目从小根堆中弹出，进入大根堆，大根堆按照最大利润组织，然后从大根堆中弹出利润最大的项目，将所得利润加到资本中。这样可以保证每次先做当前资本所有能做的项目中利润最大的项目。 1234567891011121314151617181920212223242526272829from heapq import *class Solution(object): def findMaximizedCapital(self, k, W, Profits, Capital): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ minCHeap = [] # 项目启动资金的小根堆 for i in range(len(Profits)): heappush(minCHeap, [Capital[i], Profits[i]]) # 资本大于项目启动资金的所有项目按利润大根堆 maxPHeap = [] while k &gt; 0: while minCHeap and W &gt;= minCHeap[0][0]: pair = heappop(minCHeap) heappush(maxPHeap, -pair[1]) if maxPHeap: W += -heappop(maxPHeap) k -= 1 return W`]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-串的模式匹配]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 朴素的模式匹配算法对主串的每一个字符作为子串开头，与要匹配的字符串进行匹 配。对主串做大循环，每个字符开头做 子串 的长度的小循环，直到匹配成功或全部遍历完成为止。 Python实现：123456789101112131415161718def index(S,T): if len(T)&gt;len(S): return False i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if S[i] == T[j]: i += 1 j += 1 else: i = i-j+1 j = 0 if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': result = index('goodgoogle','google') print(result) 时间复杂度： 最坏情况：一开始就匹配成功，时间复杂度为$O(1)$； 稍差一些：如果每次都是首字母就不匹配，那么对子串的循环就不必进行了，时间复杂度为$O(n+m)$，其中 n 为主串长度， m 为要匹配的子串长度； 平均情况：根据等概率原则，平均是 $(n+m) /2$ 次查找，时间复杂度为 $O(n+m)$； 最差情况： 每次不成功的匹配都发生在子串 的最后一个字符，时间复杂度为 $O((n- m+ 1)*m)$。 2 KMP模式匹配算法通过对模式串(子串)的一个预处理，将时间复杂度减少到了一个线性的水平。 举例：首先我们有主串：acabaabaabcacaabc，有模式串：abaabcac，现在假设我们匹配到了如下的图的步骤： 现在模式串的第六个字符和主串匹配不上了，那么现在我们就需要把模式串往右移动，并且重新选择主串和模式串的比较位置重新开始比较。 朴素模式匹配的做法是直接把子串向右移动一位，然后，主串的第四个字符和我们模式串的第一个字符重新开始做比较。 但是其实主串的第三个字符到第六个字符我们都是已经和模式串做过比较的，而且我们知道他们的各个位置上的内容是什么，那么为什么不把这些已经知道的信息充分利用起来了？比如：我们知道模式串中红色的两个字符和绿色的两个字符是相等的，而且红色的两个字符正好是模式串开始的两个字符，所以我们可以直接把模式串向右移动四位，然后，我们主串从刚才发现不匹配那个字符位置开始和模式串的第三个位置比较，这样我们就可以减少五次比较。 这个时候，我们就需要对我们的模式串做一个预处理，通过预处理我们可得到一个next数组，它保存的就是当我们在模式串某个位置匹配失败后，应该从模式串的哪个位置重新开始比较。 12345678910111213141516171819202122232425262728293031323334def get_next(T): #KMP next = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 next.append(j) else: j = next[j-1] return nextdef index(S,T): if len(T)&gt;len(S): return False next = get_next(T) i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if j == 0 or S[i] == T[j]: i += 1 j += 1 else: j = next[j-1] if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': next = get_next('ababaaaba') print(next) result = index('ababaabc','abc') print(result) 改进的KMP模式匹配算法如果模式串中的当前位置的字符与前缀字符相等，则将该前缀字符的next值赋给当前next值。 123456789101112131415def get_nextval(T):#改进的KMP nextval = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 if T[j-1] != T[i-1]: nextval.append(j) else: nextval.append(nextval[j-1]) else: j = nextval[j-1] return nextval 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习小结]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1 基本概念1.1 深度学习和机器学习的区别深度学习和传统机器学习方法区别．主要体现在“深层”和“学习高层特征”：传统机器学习以浅层模型为主，比如逻辑回归、支持向量机等；深度学习模型深度则有几十甚至上百层．比如LeNet-5有7层（输入-卷积-池化-卷积-池化-卷积-全连接-输出层），Alexnet有8层（5个卷积层、3个全连接层），GoogleNet 有 22 层． ResNet 有 152 层网络，因为非线性网络层次深．模型拟合能力非常好；高层特征的表示在传统机器学习上以人工设计特征为主，需要复杂的特征工程和领域知识．比如做特征抽取、特征变换、特征组合、特征选择等；深度学习能通过复杂的深层网络学习出高层特征表示，大大减少了特征工程工作，且只需要很少的领域知识。这两点优势让深度学习在越来越多的领域有突破性的进展。 2 激活函数2.1 常见的激活函数及其导数常用的激活函数主要有三种形式，Sigmoid函数，Tanh函数和ReLU函数。 Sigmoid函数及其导数 f(z)=\frac{1}{1+\exp (-z)} f^{\prime}(z)=f(z)(1-f(z)) Tanh函数及其导数 f(z)=\tanh (z)=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}} f^{\prime}(z)=1-(f(z))^{2} ReLU函数及其导数 f(z)=\max (0, z) f^{\prime}(z)=\left\{\begin{array}{l}{1, z>0} \\ {0, z \leqslant 0}\end{array}\right. 2.2 Sigmoid和Tanh激活函数会导致梯度消失Sigmoid激活函数的曲线如下所示，它将输入z映射到区间$(0, 1)$，当z很大时，$f(z)$趋近于1；当z很小时，$f(z$)趋近于0。其导数 $f^{\prime}(z)=f(z)(1-f(z))$ 在z很大或很小时都会趋近于0，造成梯度消失的现象。 Tanh激活函数的曲线如下所示。当z很大时，$f(z)$趋近于1；当z很小时，$f(z)$趋近于−1。其导数 $f^{\prime}(z)=1-(f(z))^{2}$ 在z很大或很小时都会趋近于0，同样会出现“梯度消失”。实际上，Tanh激活函数相当于Sigmoid的平移：$\tanh (x)=2 \operatorname{sigmoid}(2 x)-1$。 2.3 ReLU系列的激活函数相对于Sigmoid和Tanh激活函数的优点，局限性和改进优点 从计算的角度上，Sigmoid和Tanh激活函数均需要计算指数，复杂度高，而ReLU只需要一个阈值即可得到激活值。 ReLU的非饱和性可以有效地解决梯度消失的问题，提供相对宽的激活边界。 ReLU的单侧抑制提供了网络的稀疏表达能力。 局限性 ReLU的局限性在于其训练过程中会导致神经元死亡的问题。这是由于函数$f(z)=\max (0, z)$ 导致负梯度在经过该ReLU单元时被置为0，且在之后也不被任何数据激活，即流经该神经元的梯度永远为0，不对任何数据产生响应。在实际训练中，如果学习率（Learning Rate）设置较大，会导致超过一定比例的神经元不可逆死亡，进而参数梯度无法更新，整个训练过程失败。 改进一：为解决这一问题，人们设计了ReLU的变种Leaky ReLU（LReLU），其形式表示为 f(z)=\left\{\begin{array}{ll}{z,} & {z>0} \\ {a z,} & {z \leqslant 0}\end{array}\right.ReLU和LReLU的函数曲线对比如下图所示。LReLU与ReLU的区别在于，当$z&lt;0$时其值不为0，而是一个斜率为a的线性函数，一般a为一个很小的正常数， 这样既实现了单侧抑制，又保留了部分负梯度信息以致不完全丢失。但另一方面，a值的选择增加了问题难度，需要较强的人工先验或多次重复训练以确定合适的参数值。 改进二：基于此，参数化的PReLU（Parametric ReLU）应运而生。它与LReLU的主要 区别是将负轴部分斜率a作为网络中一个可学习的参数，进行反向传播训练，与其 他含参数网络层联合优化。 3 神经网络训练技巧在大规模神经网络的训练过程中，我们常常会面临“过拟合”的问题，即当参数数目过于庞大而相应的训练数据短缺时，模型在训练集上损失值很小，但在测试集上损失较大，泛化能力很差。解决“过拟合”的方法有很多，包括数据集增强（Data Augmentation）、参数范数惩罚/正则化（Regularization）、模型集成（ModelEnsemble）等；其中Dropout是模型集成方法中最高效与常用的技巧。同时，深度神经网络的训练中涉及诸多手调参数，如学习率、权重衰减系数、Dropout比例等，这些参数的选择会显著影响模型最终的训练效果。批量归一化（Batch Normalization，BN）方法有效规避了这些复杂参数对网络训练产生的影响，在加速训练收敛的同时也提升了网络的泛化能力。 3.1 神经网络训练时是否可以将全部参数初始化为0考虑全连接的深度神经网络，同一层中的任意神经元都是同构的，它们拥有相同的输入和输出，如果再将参数全部初始化为同样的值，那么无论前向传播还是反向传播的取值都是完全相同的。学习过程将永远无法打破这种对称性，最终同一网络层中的各个参数仍然是相同的。 因此，我们需要随机地初始化神经网络参数的值，以打破这种对称性。简单来说，我们可以初始化参数为取值范围的均匀分布。偏置可以被简单地设为0，并不会导致参数对称的问题。 3.2 Dropout的工作原理和实现，抑制过拟合Dropout是指在深度网络的训练中，以一定的概率随机地“临时丢弃”一部分神经元节点。具体来讲，Dropout作用于每份小批量训练数据，由于其随机丢弃部分神经元的机制，相当于每次迭代都在训练不同结构的神经网络。类比于Bagging方法，Dropout可被认为是一种实用的大规模深度神经网络的模型集成算法。这是由于传统意义上的Bagging涉及多个模型的同时训练与测试评估，当网络与参数规模庞大时，这种集成方式需要消耗大量的运算时间与空间。Dropout在小批量级别上的操作，提供了一种轻量级的Bagging集成近似，能够实现指数级数量神经网络的训练与评测。 Dropout的具体实现中，要求某个神经元节点激活值以一定的概率p被“丢弃”，即该神经元暂时停止工作。因此，对于包含N个神经元节点的网络，在Dropout的作用下可看作为 $2^N$ 个模型的集成。这 $2^N$ 个模型可认为是原始网络的子网络，它们共享部分权值，并且具有相同的网络层数，而模型整体的参数数目不变，这就大大简化了运算。对于任意神经元，每次训练中都与一组随机挑选的不同的神经元集合共同进行优化，这个过程会减弱全体神经元之间的联合适应性，减少过拟合的风险，增强泛化能力。 在神经网络中应用Dropout包括训练和预测两个阶段。在训练阶段中，每个神经元节点需要增加一个概率系数，一般使用Bernoulli函数，以概率系数p随机生成一个取值为0或1的向量，代表每个神经元是否需要被丢弃。如果取值为0，则该神经元将不会计算梯度或参与后面的误差传播。测试阶段是前向传播的过程。在前向传播的计算时，每个神经元的参数要预先乘以概率系数p，以恢复在训练中该神经元只有p的概率被用于整个神经网络的前向传播计算。 3.3 批量归一化（BN）神经网络训练过程的本质是学习数据分布，如果训练数据与测试数据的分布不同将大大降低网络的泛化能力，因此我们需要在训练开始前对所有输入数据进行归一化处理。 然而随着网络训练的进行，每个隐层的参数变化使得后一层的输入发生变化，从而每一批训练数据的分布也随之改变，致使网络在每次迭代中都需要拟合不同的数据分布，增大训练的复杂度以及过拟合的风险。 批量归一化方法是针对每一批数据，在网络的每一层输入之前增加归一化处 理（均值为0，标准差为1），将所有批数据强制在统一的数据分布下，即对该层 的任意一个神经元（假设为第k维）$X^{(k)}$采用如下公式 \hat{x}^{(k)}=\frac{x^{(k)}-E\left[x^{(k)}\right]}{\sqrt{\operatorname{Var}\left[x^{(k)}\right]}}批量归一化可以看作在每一层输入和上一层输出之间加入了一个新的计算层，对数据的分布进行额外的约束，从而增强模型的泛化能力。但是批量归一化同时也降低了模型的拟合能力，归一化之后的输入分布被强制为0均值和1标准差。以Sigmoid激活函数为例，批量归一化之后数据整体处于函数的非饱和区域，只包含线性变换，破坏了之前学习到的特征分布。 4 卷积神经网络4.1 全连接网络存在的问题（1）参数太多：如果输入图像大小为100×100×3（即图像高度为100，宽度为100，3个颜色通道：RGB）。在全连接前馈网络中，第一个隐藏层的每个神 经元到输入层都有100×100×3=30,000个相互独立的连接，每个连接都对应一个权重参数。随着隐藏层神经元数量的增多，参数的规模也会急剧增加。这会导致整个神经网络的训练效率会非常低，也很容易出现过拟合。（2）局部不变性特征：自然图像中的物体都具有局部不变性特征，比如在尺度缩放、平移、旋转等操作不影响其语义信息。而全连接前馈网络很难提取这些局部不变特征，一般需要进行数据增强来提高性能。 4.2 卷积神经网络卷积神经网络（Convolutional Neural Networks，CNN）也是一种前馈神经网 络，其特点是每层的神经元节点只响应前一层局部区域范围内的神经元（区别：全连接网络中每个神经元节点响应前一层的全部节点）。一个深度卷积神经网络模型通常由若干卷积层叠加若干全连接层组成，中间也包含各种非线性操作以及池化操作。卷积神经网络同样可以使用反向传播算法进行训练，相较于其他网络模型，卷积操作的参数共享特性使得需要优化的参数数目大大缩减，提高了模型的训练 效率以及可扩展性。由于卷积运算主要用于处理类网格结构的数据，因此对于时间序列以及图像数据的分析与识别具有显著优势。 4.3 卷积操作的本质特性包括稀疏交互和参数共享 稀疏交互 在传统神经网络中，网络层之间输入与输出的连接关系可以由一个权值参数矩阵来表示，其中每个单独的参数值都表示了前后层某两个神经元节点之间的交互。对于全连接网络，任意一对输入与输出神经元之间都产生交互，形成稠密的连接结构，如下图所示，神经元$s_i$与输入的所有神经元$x_j$均有连接。而在卷积神经网络中，卷积核尺度远小于输入的维度，这样每个输出神经元仅与前一层特定局部区域内的神经元存在连接权重（即产生交互），我们称这种特性为稀疏交互，此时优化过程的时间复杂度将会大大降低，过拟合的情况也得到了较好的改善。稀疏交互的物理意义是，通常图像、文本、语音等现实世界中的数据都具有局部的特征结构，我们可以先学习局部的特征，再将局部的特征组合起来形成更复杂和抽象的特征。以人脸识别为例，最底层的神经元可以检测出各个角度的边缘特征（见图9.17（a））；位于中间层的神经元可以将边缘组合起来得到眼睛、鼻子、嘴巴等复杂特征（见图9.17（b））；最后，位于上层的神经元可以根据各个器官的组合检测出人脸的特征（见图9.17（c））。 参数共享 参数共享是指在同一个模型的不同模块中使用相同的参数，它是卷积运算的固有属性。全连接网络中，计算每层的输出时，权值参数矩阵中的每个元素只作用于某个输入元素一次；而在卷积神经网络中，卷积核中的每一个元素将作用于每一次局部输入的特定位置上。根据参数共享的思想，我们只需要学习一组参数集合，而不需要针对每个位置的每个参数都进行优化，从而大大降低了模型的存储需求。 参数共享的物理意义是使得卷积层具有平移等变性。假如图像中有一只猫，那么无论它出现在图像中的任何位置，我们都应该将它识别为猫，也就是说神经网络的输出对于平移变换来说应当是等变的。 4.5 池化操作常用的池化操作主要针对非重叠区域，包括均值池化（meanpooling）、最大池化（maxpooling）等。其中均值池化通过对邻域内特征数值求平均来实现，能够抑制由于邻域大小受限造成估计值方差增大的现象，特点是对背景的保留效果更好。最大池化则通过取邻域内特征的最大值来实现，能够抑制网络参数误差造成估计均值偏移的现象，特点是更好地提取纹理信息。池化操作的本质是降采样。例如，我们可以利用最大池化将4×4的矩阵降采样为2×2的矩阵，如图9.18所示。图中的池化操作窗口大小为2×2，步长为2。每次在2×2大小的窗口上进行计算，均值池化是求窗口中元素的均值，最大池化则求窗口中元素的最大值；然后将窗口向右或向下平移两格，继续操作。池化操作除了能显著降低参数量外，还能够保持对平移、伸缩、旋转操作的不变性。平移不变性是指输出结果对输入的小量平移基本保持不变。例如，输入为（1,5,3），最大池化将会取5，如果将输入右移一位得到（0,1,5），输出的结果仍将为5。对伸缩的不变性（一般称为尺度不变性）可以这样理解，如果原先神经元在最大池化操作之后输出5，那么在经过伸缩（尺度变换）之后，最大池化操作在该神经元上很大概率的输出仍然是5。因为神经元感受的是邻域输入的最大值，而并非某一个确定的值。旋转不变性可以参照图9.19。图中的神经网络由3个学得的过滤器和一个最大池化层组成。这3个过滤器分别学习到不同旋转方向的“5”。当输入中出现“5”时，无论进行何种方向的旋转，都会有一个对应的过滤器与之匹配并在对应的神经元中引起大的激活。最终，无论哪个神经元获得了激活，在经过最大池化操作之后输出都会具有大的激活。 4.6 卷积神经网络如何用于文本分类任务卷积神经网络的核心思想是捕捉局部特征，起初在图像领域取得了巨大的成功，后来在文本领域也得到了广泛的应用。对于文本来说，局部特征就是由若干单词组成的滑动窗口，类似于N-gram。卷积神经网络的优势在于能够自动地对Ngram特征进行组合和筛选，获得不同抽象层次的语义信息。由于在每次卷积中采用了共享权重的机制，因此它的训练速度相对较快，在实际的文本分类任务中取得了非常不错的效果。 5 深度残差网络5.1 ResNet的提出背景和核心理论ResNet的提出背景是解决或缓解深层的神经网络训练中的梯度消失问题。假设有一个L层的深度神经网络，如果我们在上面加入一层，直观来讲得到的L+1层深度神经网络的效果应该至少不会比L层的差。因为我们简单地设最后一层为前一层的拷贝（用一个恒等映射即可实现），并且其他层维持原来的参数即可。然而在进行反向传播时，我们很难找到这种形式的解。实际上，通过实验发现，层数更深的神经网络反而会具有更大的训练误差。 ResNet通过调整网络结构来解决上述问题。首先考虑两层神经网络的简单叠加（见图9.23（a）），这时输入x经过两个网络层的变换得到H(x)，激活函数采用ReLU。反向传播时，梯度将涉及两层参数的交叉相乘，可能会在离输入近的网络层中产生梯度消失的现象。ResNet把网络结构调整为，既然离输入近的神经网络层较难训练，那么我们可以将它短接到更靠近输出的层，如图9.23（b）所示。输入x经过两个神经网络的变换得到 $F(x)$，同时也短接到两层之后，最后这个包含两层的神经网络模块输出 $H(x)=F(x)+x$。这样一来，$F(x)$ 被设计为只需要拟合输入x与目标输出的残差，残差网络的名称也因此而来。如果某一层的输出已经较好的拟合了期望结果，那么多加入一层不会使得模型变得更差，因为该层的输出将直接被短接到两层之后，相当于直接学习了一个恒等映射，而跳过的两层只需要拟合上层输出和目标之间的残差即可。 ResNet可以有效改善深层的神经网络学习问题，使得训练更深的网络成为可能，传统神经网络的可能随着模 型结构的加深训练误差反而上升；而ResNet的随着模型结构的加深，训练误差逐渐降低，并且优于相同层数的传统的神经网络。 6 循环神经网络循环神经网络（Recurrent Neural Network，RNN）是用来建模序列化数据的一种主流深度学习模型。我们知道，传统的前馈神经网络一般的输入都是一个定长的向量，无法处理变长的序列信息，即使通过一些方法把序列处理成定长的向量，模型也很难捕捉序列中的长距离依赖关系。RNN则通过将神经元串行起来处理序列化的数据。由于每个神经元能用它的内部变量保存之前输入的序列信息，因此整个序列被浓缩成抽象的表示，并可以据此进行分类或生成新的序列。 6.1 处理文本数据时，循环神经网络与前馈神经网络相比有什么特点传统文本处理任务的方法中一般将TF-IDF向量作为特征输入。显而易见，这样的表示实际上丢失了输入的文本序列中每个单词的顺序。在神经网络的建模过程中，一般的前馈神经网络，如卷积神经网络，通常接受一个定长的向量作为输入。卷积神经网络对文本数据建模时，输入变长的字符串或者单词串，然后通过滑动窗口加池化的方式将原先的输入转换成一个固定长度的向量表示，这样做可以捕捉到原文本中的一些局部特征，但是两个单词之间的长距离依赖关系还是很难被学习到。 循环神经网络却能很好地处理文本数据变长并且有序的输入序列。它模拟了人阅读一篇文章的顺序，从前到后阅读文章中的每一个单词，将前面阅读到的有用信息编码到状态变量中去，从而拥有了一定的记忆能力，可以更好地理解之后的文本。下图展示了一个典型的循环神经网络结构。一个长度为T的序列用循环神经网络建模，展开之后可以看作是一 个T层的前馈神经网络。其中，第t层的隐含状态ht编码了序列中前t个输入的信息，可以通过当前的输入$x_t$和上一层神经网络的状态$h_{t−1}$计算得到；最后一层的状态$h_T$编码了整个序列的信息，因此可以作为整篇文档的压缩表示，以此为基础的结构可以应用于多种具体任务。例如，在$h_T$后面直接接一个Softmax层，输出文本所属类别的预测概率 y，就可以实现文本分类。 通过最小化损失误差（即输出的y与真实类别之间的距离），我们可以不断训练网络，使得得到的循环神经网络可以准确地预测文本所属的类别，达到分类目的。相比于卷积神经网络等前馈神经网络，循环神经网络由于具备对序列顺序信息的刻画能力，往往能得到更准确的结果。 6.2 循环神经网络的梯度消失问题循环神经网络模型的求解可以采用BPTT（BackPropagationThroughTime，基于时间的反向传播）算法实现，BPTT实际上是反向传播算法的简单变种。如果将循环神经网络按时间展开成T层的前馈神经网络来理解，就和普通的反向传播算法没有什么区别了。循环神经网络的设计初衷之一就是能够捕获长距离输入之间的依赖。从结构上来看，循环神经网络也理应能够做到这一点。然而实践发现，使用BPTT算法学习的循环神经网络并不能成功捕捉到长距离的依赖关系，这一现象主要源于深度神经网络中的梯度消失。传统的循环神经网络梯度可以表示成连乘的形式。 由于预测的误差是沿着神经网络的每一层反向传播的，因此当雅克比矩阵的最大特征值大于1时，随着离输出越来越远，每层的梯度大小会呈指数增长，导致梯度爆炸；反之，若雅克比矩阵的最大特征值小于1，梯度的大小会呈指数缩小，产生梯度消失。对于普通的前馈网络来说，梯度消失意味着无法通过加深网络层次来改善神经网络的预测效果，因为无论如何加深网络，只有靠近输出的若干层才真正起到学习的作用。这使得循环神经网络模型很难学习到输入序列中的长距离依赖关系。 梯度爆炸的问题可以通过梯度裁剪来缓解，即当梯度的范式大于某个给定值时，对梯度进行等比收缩。而梯度消失问题相对比较棘手，需要对模型本身进行改进。深度残差网络是对前馈神经网络的改进，通过残差学习的方式缓解了梯度消失的现象，从而使得我们能够学习到更深层的网络表示；而对于循环神经网络来说，长短时记忆模型[LSTM]及其变种门控循环单元（Gated recurrent unit，GRU）等模型通过加入门控机制，很大程度上弥补了梯度消失所带来的损失。 6.3 长短期记忆网络 LSTM长短期记忆网络（Long Short Term Memory，LSTM）是循环神经网络的最知 名和成功的扩展。由于循环神经网络有梯度消失和梯度爆炸的问题，学习能力有限，在实际任务中的效果往往达不到预期效果。LSTM可以对有价值的信息进行长期记忆，从而减小循环神经网络的学习难度。 \mathbf{c}_{t}=\mathbf{f}_{t} \odot \mathbf{c}_{t-1}+\mathbf{i}_{t} \odot \tilde{\mathbf{c}}_{t} \mathbf{h}_{t}=\mathbf{o}_{t} \odot \tanh \left(\mathbf{c}_{t}\right)与传统的循环神经网络相比，LSTM仍然是基于当前输入和上一时刻的内部状态来计算当前输出，只不过对内部的结构进行了更加精心的设计，加入了输入门$i_t$、遗忘门$f_t$以及输出门$o_t$三个门和一个内部记忆单元$c_t$。输入门控制当前计算的新状态以多大程度更新到记忆单元中；遗忘门控制前一步记忆单元中的信息有多大程度被遗忘掉；输出门控制当前的输出有多大程度上取决于当前的记忆单元。 在一个训练好的网络中，当输入的序列中没有重要信息时，LSTM的遗忘门的值接近于1，输入门的值接近于0，此时过去的记忆会被保存，从而实现了长期记忆功能；当输入的序列中出现了重要的信息时，LSTM应当把其存入记忆中，此时其输入门的值会接近于1；当输入的序列中出现了重要信息，且该信息意味着之前的记忆不再重要时，输入门的值接近1，而遗忘门的值接近于0，这样旧的记忆被遗忘，新的重要信息被记忆。经过这样的设计，整个网络更容易学习到序列之间 的长期依赖。 6.4 LSTM里各模块的激活函数关于激活函数的选取，在LSTM中，遗忘门、输入门和输出门使用Sigmoid函数作为激活函数；在生成候选记忆时，使用双曲正切函数Tanh作为激活函数。值得注意的是，这两个激活函数都是饱和的，也就是说在输入达到一定值的情况 下，输出就不会发生明显变化了。如果是用非饱和的激活函数，例如ReLU，那么 将难以实现门控的效果。 Sigmoid函数的输出在0～1之间，符合门控的物理定义。 且当输入较大或较小时，其输出会非常接近1或0，从而保证该门开或关。在生成候选记忆时，使用Tanh函数，是因为其输出在−1～1之间，这与大多数场景下特征 分布是0中心的吻合。此外，Tanh函数在输入为0附近相比Sigmoid函数有更大的梯 度，通常使模型收敛更快。 6.5 GRU门控循环单元网络（（GatedRecurrentUnit，GRU）也是通过引入门机制来控制信息更新的方式，在LSTM网络中，输入门和遗忘门是互补关系，用两个门比较冗余。GRU将输入门与和遗忘门合并成一个门：更新门。也就是说我们使用了同一个门控就同时可以进行遗忘和选择记忆（LSTM则要使用多个门控）。与LSTM相比，GRU内部少了一个”门控“，参数比LSTM少，但是却也能够达到与LSTM相当的功能。考虑到硬件的计算能力和时间成本，因而很多时候我们也就会选择更加”实用“的GRU啦。 7 Seq2Seq模型Seq2Seq模型的核心思想是，通过深度神经网络将一个作为输入的序列映射为一个作为输出的序列，这一过程由编码输入与解码输出两个环节构成。在经典的实现中，编码器和解码器各由一个循环神经网络构成，既可以选择传统循环神经网络结构，也可以使用长短期记忆模型、门控循环单元等。在Seq2Seq模型中，两个循环神经网络是共同训练的。 假想一个复习和考试的场景。如图10.3所示，我们将学到的历史信息经过了一系列加工整理，形成了所谓的知识体系，这便是编码过程。然后在考试的时候，将高度抽象的知识应用到系列问题中进行求解，这便是解码过程。譬如对于学霸，他们的网络很强大，可以对很长的信息进行抽象理解，加工内化成编码向量，再在考试的时候从容应答一系列问题。而对于大多数普通人，很难记忆长距离、长时间的信息。在考前只好临时抱佛脚，编码很短期的序列信号，考试时也是听天由命，能答多少写多少，解码出很短时效的信息。 对应于机器翻译过程，如图10.4所示。输入的序列是一个源语言的句子，有三个单词A、B、C，编码器依次读入A、B、C和结尾符。在解码的第一步，解码器读入编码器的最终状态，生成第一个目标语言的词W；第二步读入第一步的输出W，生成第二个词X；如此循环，直至输出结尾符。输出的序列W、X、Y、Z就是翻译后目标语言的句子。 在文本摘要任务中，输入的序列是长句子或段落，输出的序列是摘要短句。在图像描述文本生成任务中，输入是图像经过视觉网络的特征，输出的序列是图像的描述短句。进行语音识别时，输入的序列是音频信号，输出的序列是识别出的文本。不同场景中，编码器和解码器有不同的设计，但对应Seq2Seq的底层结构是一样的。 7.1 Seq2Seq模型解码方法eq2Seq模型最核心的部分是其解码部分，大量的改进也是在解码环节衍生的。Seq2Seq模型最基础的解码方法是贪心法，即选取一种度量标准后，每次都在当前状态下选择最佳的一个结果，直到结束。贪心法的计算代价低，适合作为基准结果与其他方法相比较。很显然，贪心法获得的是一个局部最优解，由于实际问题的复杂性，该方法往往并不能取得最好的效果 集束搜索是常见的改进算法，它是一种启发式算法。该方法会保存beamsize（后面简写为b）个当前的较佳选择，然后解码时每一步根据保存的选择进行下一步扩展和排序，接着选择前b个进行保存，循环迭代，直到结束时选择最佳的一个作为解码的结果。由图可见，当前已经有解码得到的第一个词的两个候选：I和My。然后，将I 和My输入到解码器，得到一系列候选的序列，诸如I decided、My decision、I thought等。最后，从后续序列中选择最优的两个，作为前两个词的两个候选序列。很显然，如果b取1，那么会退化为前述的贪心法。随着b的增大，其搜索的空间增大，最终效果会有所提升，但需要的计算量也相应增大。在实际的应用（如机器翻译、文本摘要）中，b往往会选择一个适中的范围，以8～12为佳。 解码时使用堆叠的RNN、增加Dropout机制、与编码器之间建立残差连接等，均是常见的改进措施，另外，解码环节中一个重要的改进是注意力机制，注意力机制的引入，使得在解码时每一步可以有针对性地关注与当前有关的编码结果，从而减小编码器输出表示的学习难度，也更容易学到长期的依赖关系。此外，解码时还可以采用记忆网络等，从外界获取知识。 7.2 Seq2Seq模型引入注意力机制解决了什么问题在实际任务（例如机器翻译）中，使用Seq2Seq模型，通常会先使用一个循环神经网络作为编码器，将输入序列（源语言句子的词向量序列）编码成为一个向量表示；然后再使用一个循环神经网络模型作为解码器，从编码器得到的向量表示里解码得到输出序列（目标语言句子的词序列）。 在实际使用中，会发现随着输入序列的增长，模型的性能发生了显著下降。这是因为编码时输入序列的全部信息压缩到了一个向量表示中。随着序列增长，句子越前面的词的信息丢失就越严重。试想翻译一个有100个词的句子，需要将整个句子全部词的语义信息编码在一个向量中。而在解码时，目标语言的第一个词大概率是和源语言的第一个词相对应的，这就意味着第一步的解码就需要考虑100步之前的信息。建模时的一个小技巧是将源语言句子逆序输入，或者重复输入两遍来训练模型，以得到一定的性能提升。使用长短期记忆模型能够在一定程度上缓解这个问题，但在实践中对于过长的序列仍然难以有很好的表现。同时，Seq2Seq模型的输出序列中，常常会损失部分输入序列的信息，这是因为在解码时，当前词及对应的源语言词的上下文信息和位置信息在编解码过程中丢失了。 Seq2Seq模型中引入注意力机制就是为了解决上述的问题。在注意力机制中，仍然可以用普通的循环神经网络对输入序列进行编码，得到隐状态h1,h2…hT。但是在解码时，每一个输出词都依赖于前一个隐状态以及输入序列每一个对应的隐状态及对应的注意力权重。在生成一个输出词时，会考虑每一个输入词和当前输出词的对齐关系，对齐越好的词，会有越大的权重，对生成当前输出词的影响也就越大。 8 注意力注意力是一种人类不可或缺的复杂认知功能，指人可以在关注一些信息的同时忽略另一些信息的选择能力。在日常生活中，我们通过视觉、听觉、触觉等方式接收大量的感觉输入。但是人脑可以在这些外界的信息轰炸中还能有条不紊地工作，是因为人脑可以有意或无意地从这些大量输入信息中选择小部分的有用信息来重点处理，并忽略其他信息。这种能力就叫做注意力。注意力可以体现在外部的刺激（听觉、视觉、味觉等），也可以体现在内部的意识（思考、回忆等）。 一个和注意力有关的例子是鸡尾酒会效应。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而忽略其他人的声音（聚焦式注意力）。同时，如果未注意到的背景声中有重要的词（比如他的名字），他会马上注意到（显著性注意力）。 聚焦式注意力一般会随着环境、情景或任务的不同而选择不同的信息。比如当要从人群中寻找某个人时，我们会将专注于每个人的脸部；而当要统计人群的人数时，我们只需要专注于每个人的轮廓。 参考文献：诸葛越, 葫芦娃. 百面机器学习]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-字典树]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 字典树字典树，即Trie树，又称单词查找树或键树，是一种树形结构，常用于统计和排序大量字符串等场景（但不限于字符串），且经常被搜索引擎用于文本词频统计。它的优点是最大限度减少无谓的字符串比较，查询效率比较高。Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。它有以下三个基本性质： 根结点不包含字符，除根结点外每一个结点都只包含一个字符； 从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。 树的构建举例：题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。现在回到例子中，如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是$O(n^2)$。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的： 如上图所示，从根结点遍历到每个结点的路径就是一个单词，如果这个结点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，只要顺着它从根走到对应的结点，再看这个结点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成我们可以看到，trie树每一层的节点数是$26^i$级别的。为了节省空间，还可以动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数乘以单词长度。 查询Trie树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的AJAX搜索框时，就是Trie开始。本质上，Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie： 可以看出： 每条边对应一个字母。 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。 单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。 查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。 搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步：考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。 实现性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import collectionsclass Node(object): def __init__(self): self.children = collections.defaultdict(Node) self.isWord = Falseclass Trie(object): def __init__(self): """ Initialize your data structure here. """ self.root = Node() def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: None """ cur = self.root for w in word: cur = cur.children[w] cur.isWord = True def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ cur = self.root for w in word: cur = cur.children.get(w) if not cur: return False return cur.isWord def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ cur = self.root for w in prefix: cur = cur.children.get(w) if not cur: return False return Trueif __name__ == '__main__':# Your Trie object will be instantiated and called as such: obj = Trie() obj.insert('apple') print(obj.search('apple')) print(obj.search('app')) print(obj.startsWith('app')) obj.insert('app') print(obj.search('app')) 问题实例 Q. 10个频繁出现的词： 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。A. 用Trie树统计每个词出现的次数，时间复杂度是$O(nl)$（$l$表示单词的平均长度，最终用最小堆找到出现次数最频繁的10个词，时间复杂度为$O(nlog10)$ 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有1000万个记录，这些查询串的重复度比较高，虽然总数是1000万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。A. 可以使用Trie树，观察关键字在该查询串出现的次数，若没有出现则为0，最后用10个元素的最小堆来对出现频率进行排序。 参考文献：从Trie树（字典树）谈到后缀树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 动态规划]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是动态规划相关题目题解总结。 [TOC] 动态规划递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是动态规划保存了子问题的解，避免重复计算。 动态规划与分治算法类似，都是通过组合子问题的解来求解原问题的： 分治算法将问题划分为互不相关的子问题，再递归地求解子问题，最后将它们的解组合起来，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，需要反复求解那些公共子问题，而动态规划对于每个子子问题只求解一次，将其保存在一个表格里面，从而无需每次求解一个子子问题时都需要重新计算，避免了不必要的计算工作。 动态规划的应用场景 动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。 动态规划的一般步骤 定义一个状态，这是一个最优解的结构特征； 进行状态递推，得到递推公式； 进行初始化； 返回结果。 动态规划的实质就是分治思想和解决冗余。将原来具有指数级复杂性的算法改进成具有多项式时间的算法，这是动态规划算法的目的。由于在实现的过程中，需要存储各种状态，所以它的空间复杂性要大于其他算法，这是一种以空间换时间的技术。 动态规划三要素最优子结构性质、子问题重叠性、自底向上的求解方法。 最优子结构性质 最优子结构性质，就是问题的最优解包含其子问题的最优解。如果不具备该性质，就不能使用动态规划来解决。常用反证法分析论证问题是否具备最优子结构的性质； 有时对某个子问题的解不一定达到最优，但是当把它延伸成整个问题的解时反而成了最优解，这种问题不满足最优子结构性质，无法使用动态规划。 子问题重叠性质 动态规划对每个子问题只求解一次，并把其答案保存在表格里，因此可以避免重复计算； 子问题重叠性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。 自底向上的求解方法由于动态规划解决的问题具有子问题重叠的问题，求解时需要自底向上的方法： 首先选择合适的表格（一维或二维），将递归的停止条件填入表格的相应位置； 然后将问题的规模一级一级放大，求出每一级子问题的最优解，并将其填入表格的相应位置 ； 直到问题所要求的规模，此时求出的便是原问题的最优解。 除了自底向上的方法，还可以使用 “带备忘录的自顶向下方法”。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（用数组或列表保存）。当需要子问题的解时，过程首先检查是否已经保存过此解。如果是，直接返回保存的值，从而节省时间；否则，按通常方式计算这个子问题。这个递归过程是带备忘的，因为它记住了之前已经计算出的结果。 贪婪算法的局限性动态规划的一个关键特点是每次做选择之前，对所有选择的效果进行计算。在计算的结果上选择能够达到最优的选项，从而保证每次选择都是最优的。 但是这种策略在当选项的数量非常巨大的时候将不堪重负。例如下围棋的时候，如果采用动态规划策略，则需要先对每步可能的行棋的影响进行计算，然后比较选择最优的走法。但每一步可行进的走法实在太多，如果再考虑到一盘棋有几乎不计其数的步骤，所以计算任务非常大几乎不可能完成。这种情况就是上面介绍的动态规划的缺点。这个时候应该采用贪婪策略。 贪婪策略运行我们不对所有可能选择的影响计算一遍后作出决策。我们可以在进行选择的时候不进行任何计算，而根据当时的情况作出我们认为最好的选择，这样就避免了大量计算，从而大大提高了算法的效率。 【算法】详解动态规划算法导论——-动态规划是什么 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路动态规划：当我们想要获得0~n中最大的子串和时，如果0~n-1的连续和小于0，则连续和等于它自己nums[n]，如果为正，则连续和等于它自己加上0~n-1的连续和。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dp = [0]*len(nums) dp[0] = nums[0] for i in range(1,len(nums)): if dp[i-1] &lt; 0: dp[i] = nums[i] else: dp[i] = nums[i] + dp[i-1] return max(dp) temp比0小，那就从开始重新记录 12345678910111213141516171819class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] res = nums[0] temp = 0 for x in nums: temp += x if temp &gt; res: res = temp if temp &lt; 0: temp = 0 return res 讨论区里很精巧的解法。将每一个nums[i]的值，看成是存放前面连续的和大于0的序列；通过遍历，纠正错误存放的值；nums[i]中的每一个数存放的都是序号i前面连续数据的最大和。 123456789101112class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 for i in range(1,len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1] return max(nums) 62. 不同路径题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 解题思路动态规划。 当只有一行或者一列的时候，只有一种方式； 遍历其余位置，每一个位置只能由其左边或上边的元素达到，即迭代公式为: 遍历完成后，dp矩阵存放了每一个位置的走法数，因此返回最后一个数即为所求。 1234567891011121314151617181920class Solution(object): def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m &lt; 1 or n &lt; 1: return 0 if m == 1 or n == 1: return 1 dp = [[1]*n for i in range(m)] for i in range(m): dp[i][0] = 1 for i in range(n): dp[0][i] == 1 for i in range(1,m): for j in range(1,n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] 63. 不同路径 II题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解题思路有障碍物的地方走法为0。 12345678910111213141516171819202122232425262728293031class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ if len(obstacleGrid) == 0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for i in range(m)] for i in range(m): if obstacleGrid[i][0] == 0: dp[i][0] = 1 else: break for i in range(n): if obstacleGrid[0][i] == 0: dp[0][i] = 1 else: break for i in range(1,m): for j in range(1,n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1] 64. 最小路径和题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路每个位置的最小数字总和为当前位置数值加上 上方及左方数字总和 较小的数。 1234567891011121314151617181920212223class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for i in range(m)] dp[0][0] = grid[0][0] for i in range(1,m): dp[i][0] = grid[i][0] + dp[i-1][0] for i in range(1,n): dp[0][i] = grid[0][i] + dp[0][i-1] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1] 70. 爬楼梯题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1：12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2：123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归 (超时)1234567891011class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 动态规划1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n dp = [0]*n dp[0] = 1 dp[1] = 2 for i in range(2,n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n a, b = 1, 2 res = 0 for i in range(3, n+1): res = a + b a, b = b, res return res 72. 编辑距离题目描述给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1:123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例 2:12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 解题思路维护一个二维的数组dp，其大小为 (m+1)x(n+1)，m和n分别为 word1 和word2 的长度。$dp[i][j] $表示从 word1 的前i个字符转换到 word2 的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。当$word1[i] == word2[j]$时，$dp[i][j] = dp[i - 1][j - 1]$当$word1[i] != word2[j]$时，有三种处理方法，首先是直接插入一个 word2[j]，那么 word2[j] 位置的字符就跳过了，接着比较 $word1[i+1]$ 和 $word2[j+1] $即可。第二个种方法是删除，即将 $word1[i]$ 字符直接删掉，接着比较 $word1[i+1]$ 和 $word2[j]$ 即可。第三种则是将 $word1[i]$ 修改为 $word2[j]$，接着比较 $word1[i+1]$ 和 $word[j+1]$ 即可。所以 $dp[i][j]$是其左，左上，上的三个值中的最小值加1，其实这里的左，上，和左上，分别对应的增加，删除，修改操作。转移方程为：如果 $word1[i - 1] == word2[j - 1]$, $dp[i][j] = dp[i - 1][j - 1]$否则 $dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1$ 123456789101112131415161718192021222324class Solution(object): def minDistance(self, word1, word2): """ :type word1: str :type word2: str :rtype: int """ dp = [[0] * (len(word1)+1) for _ in range(len(word2)+1)] for i in range(1, len(word1)+1): dp[0][i] = i for i in range(1, len(word2)+1): dp[i][0] = i for i in range(1, len(word2)+1): for j in range(1, len(word1)+1): if word2[i-1] == word1[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1] 91. 解码方法题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码：1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2:123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 解题思路dp[i]代表解析是s[:i]字符串的所有可能的方式数目。则：12dp[i] = dp[i-1] if s[i] != &apos;0&apos; + dp[i-2] if &apos;9&apos; &lt; s[i-2:i] &lt; &apos;27&apos; 举例子：对于’226’： 令dp=[0,0,0,0]，初始化为[1,0,0,0]； 从第一个位置开始，输入’2’，不为0，dp=[1,1,0,0]； 第二个位置为’2’，不为0，所以dp=[1,1,1,0]，此时前两位为’22’，满足区间，所以变为[1,1,2,0]; 第三个位置为’6’，不为0，所以dp=[1,1,2,2]，此时前两位为’26’，满足区间，所以变为[1,1,2,3]。 12345678910111213141516class Solution(object): def numDecodings(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 dp = [0] * (len(s)+1) dp[0] = 1 for i in range(1, len(s)+1): if s[i-1] != '0': dp[i] = dp[i-1] if i != 1 and '09' &lt; s[i-2:i] &lt; '27': dp[i] += dp[i-2] return dp[len(s)] 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 解题思路12345678910111213141516171819202122232425262728给定一个数n，求1到n这些数可以构成多少棵二叉树。给定一个序列1.....n，为了构造所有二叉树，我们可以使用1......n中的每一个数i作为根节点，自然1......(i-1)必然位于树的左子树中，(i+1).....n位于树的右子树中。然后可以递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。使用两个状态来记录：dp(n)：长度为n的序列的所有唯一的二叉树。dp(i,n)，1&lt;=i&lt;=n：以i作为根节点的二叉树的数量。dp(n)就是我们要求解的答案，dp(n)可以由F(i,n)计算而来。dp(n)=F(1,n)+F(2,n)+...+F(n,n) (1)dp(0)=1,dp(1)=1对于给定的一个序列1.....n，我们取i作为它的根节点，那么以i作为根节点的二叉树的数量F(i)可以由下面的公式计算而来：F(i,n)=dp(i-1)*dp(n-i-1) 1&lt;=i&lt;=n (2)比i小的数1...i-1作为左子树，比i大的数i+1...n作为右子树，左子树的排列和右子树的排列的乘积是此时的数目。例如 i=3，n=3时， dp[3] = dp[0]*dp[2]+dp[1]*dp[1]+dp[2]dp[0]。即左右子树节点数量分别为(0,2),(1,1),(2,0)。综合公式（1）和公式（2），可以看出：dp(n) = dp(0) * dp(n-1) + dp(1) * dp(n-2) + … + dp(n-1) * dp(0)[参考](https://blog.csdn.net/u012501459/article/details/46622501) 1234567891011121314class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt;= 2: return dp[n] dp += [0] * (n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[n] 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:1234567891011输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 解题思路 遍历1~n选择一个数当作根节点，所以其左边的数字构成左子树，右边的数字构成右子树。 当左子树固定的时候，把所有可能的右子树都构成，然后再变换左子树。（两层for循环遍历leftnodes和rightnodes）。 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 120. 三角形最小路径和题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形：123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路新建dp和三角形一样大小，dp[i][j]为第i层第j个位置的最短路径，dp初始化为最下面一层，从倒数第二层自底向上遍历，则：1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j] 123456789101112131415161718class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = [] for i in range(len(triangle)): dp.append([0]*len(triangle[i])) dp[-1] = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j] return dp[0][0] 由于 $dp[i][j]$ 只被用了一次，所以可以变为一维dp：1dp[i] = min(dp[i],dp[i+1]) + triangle[i][j] 1234567891011121314class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0] 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路维护两个变量，到目前为止的最小值和最大收益。 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 minprice = prices[0] for i in range(1, len(prices)): minprice = min(minprice, prices[i]) maxprofit = max(maxprofit, prices[i]-minprice) return maxprofit 动态规划dp[i]为前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1种的最小价格) dp[i] = max(dp[i-1]-min(prices[:i]) 123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0]*len(prices) for i in range(1,len(prices)): dp[i] = max(dp[i-1], prices[i]-min(prices[:i])) return dp[-1] 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路当今天价格比昨天价格高时，就做一次交易。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 for i in range(1,len(prices)): if prices[i]&gt;prices[i-1]: maxprofit += prices[i]-prices[i-1] return maxprofit 动态规划，dp[i]为到第i天的最大收益，当今天价格比昨天价格高时，就做一次交易，dp[i] = dp[i-1]+prices[i]-prices[i-1] if prices[i]&gt;prices[i-1] else 0. 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0] * len(prices) for i in range(1,len(prices)): dp[i] = dp[i-1] if prices[i] &gt; prices[i-1]: dp[i] += prices[i]-prices[i-1] return dp[-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = &quot;Leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;Leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2：1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 152. 乘积最大子序列题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1:123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路暴力，超时。12345678910111213141516171819class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = nums[0] for i in range(len(nums)): res = max(res, nums[i]) cur = nums[i] for j in range(i+1,len(nums)): cur *= nums[j] res = max(res, cur) return res 动态规划 考虑某个位置出现负数或0的情况。当遇到0时，整个乘积变为0；当遇到负数时，当前的最大乘积变为最小乘积，最小乘积变为最大乘积。 使用两个数组分别记录以某个位置i结尾时的最大乘积和最小乘积，另最大乘积为dpmax，最小乘积为dpmin： 当前最大值为已知最大值乘当前值，当前值，已知最小值乘当前值，三者中的最大值； 当前最小值为已知最小值乘当前值，当前值，已知最大值乘当前值，三者中的最小值； 结果为最大值数组中的最大值。 1234567891011121314151617181920class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = [0]*len(nums) dpmax = [0]*len(nums) dpmin[0] = dpmax[0] = nums[0] res = nums[0] for i in range(1,len(nums)): dpmin[i] = min(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) dpmax[i] = max(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) res = max(res, dpmax[i]) # return max(dpmax) return res 空间优化。123456789101112131415161718class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = dpmax = nums[0] res = nums[0] for i in range(1,len(nums)): lastmin = dpmin lastmax = dpmax dpmin = min(lastmax*nums[i], nums[i], lastmin*nums[i]) dpmax = max(lastmax*nums[i], nums[i], *nums[i]) res = max(res, dpmax) return res 198. 打家劫舍题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路动态规划，维护一个长为len(nums)的数组dp，dp[i]代表在i处能取得的最大金额，这个房子该不该偷，这么决定的因素是这个房子偷了的话的收益和不偷留着偷下一个房子的收益那个比较高： 房子i的金额+dp[i-2]的金额 大于 dp[i-1]时，偷； 房子i的金额+dp[i-2]的金额 小于 dp[i-1]时，不偷。 即递推式为：123dp[0] = nums[0] dp[1] = nums[1] dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 12345678910111213141516171819class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(2,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 213. 打家劫舍 II题目描述你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路本题相比第198题就多了不同时偷第一个和最后一个的约束条件。所以，两种偷的情况：第一种不偷最后一个房间，第二种不偷第一个房间，求这两种偷法能获得的最大值。 12345678910111213141516171819202122class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) return max(self.helper(nums[:len(nums)-1]), self.helper(nums[1:])) def helper(self, nums): if len(nums) == 2: return max(nums) dp = [0]*len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(1,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 221. 最大正方形题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例:12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路使用DP，设DP[i][j]为以i,j位置为右下角顶点的能构成的最大正方形的边长，DP数组的第一行和第一列和matrix相等，其他位置当matrix[i][j]==1时，能构成的正方形边长等于左边，上边，左上角能构成正方形边长的最小值+1.递推公式：12341 when i==0 or j == 0, dp[i][j] = matrix[i][j]2 when i &gt; 0 and j &gt; 0, if matrix[i][j] == 0 dp[i][j] = 0 if matrix[i][j] == 1 dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 参考 12345678910111213141516171819202122class Solution(object): def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0]) for i in range(len(matrix))] res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if i == 0 or j == 0: dp[i][j] = 1 if matrix[i][j] == '1' else 0 elif matrix[i][j] == '1': dp[i][j] = 1+ min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) res = max(res, dp[i][j]) return res*res 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:121 是丑数。n 不超过1690。 解题思路123456789101112131415161718192021222324class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 6: return n dp = [1] t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp.append(min(dp[t2]*2, dp[t3]*3, dp[t5]*5)) if dp[t2]*2 == dp[-1]: t2 += 1 if dp[t3]*3 == dp[-1]: t3 += 1 if dp[t5]*5 == dp[-1]: t5 += 1 return dp[-1] 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路dp[i] = 1+min(dp[i-1^2],dp[i-2^2],…,dp[i-k^2]) 12345678910111213141516171819class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0]*(n+1) for i in range(1, n+1): minval = float('inf') for j in range(1, int(i**0.5)+1): minval = min(minval, dp[i-j*j]) dp[i] = minval + 1 return dp[-1] 四平方数定理https://github.com/grandyang/Leetcode/issues/2791234567891011121314151617181920class Solution: def numSquares(self, n: int) -&gt; int: if n == 0: return 0 while n % 4 == 0: n //= 4 if n % 8 == 7: return 4 for i in range(int(n**0.5)+1): j = int((n - i*i)**0.5) if i*i + j*j == n: if i != 0 and j != 0: return 2 else: return 1 return 3 300. 最长上升子序列题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路使用dp保存包目前为止的最大递增子序列长度，最后求所有为止的最大值，而不是dp的最后元素1初始化dp[i]=12对每一个位置，如果当前位置比之前位置的大，则此时为递增子序列，更新之 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) res = 1 dp = [1]*len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(res, dp[i]) return res 303. 区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例：12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路先把到当前位置的和求出来，然后再调用的时候直接右边的和减去左边的和。 12345678910111213141516171819202122232425262728class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.data = [] total = 0 for num in nums: total += num self.data.append(total) def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i == 0: return self.data[j] else: return self.data[j]-self.data[i-1]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 304. 二维区域和检索 - 矩阵不可变题目描述给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例:1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 解题思路使用dp保存当前位置到左上角元素构成的矩形的所有元素和，添加了第一列和第一行全是0，这样能保证在求和的时候，每个位置的和是是左边的和+上边的和-左上元素的和+当前位置的值1Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA) 参考 123456789101112131415161718192021222324252627class NumMatrix(object): def __init__(self, matrix): """ :type matrix: List[List[int]] """ if not matrix or not matrix[0]: m, n = 0, 0 else: m, n = len(matrix), len(matrix[0]) self.dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m): for j in range(n): self.dp[i+1][j+1] = self.dp[i+1][j]+self.dp[i][j+1]-self.dp[i][j] + matrix[i][j] def sumRegion(self, row1, col1, row2, col2): """ :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int """ return self.dp[row2+1][col2+1]-self.dp[row2+1][col1]-self.dp[row1][col2+1]+self.dp[row1][col1] 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路使用两个数组1 sell[i]表示该天结束之后手里没有股票的情况下的最大收益，可能情况为该天手里有股票卖了，或者该天没进行交易，即 max(hold[i-1]+prices[i]， sell[i-1]);2 hold[i]表示该天结束之后手里有股票的情况下的最大收益，可能情况为手里有股票但是没进行交易，或者手里没有股票买进股票，今天买进的条件是昨天必须休息，即max(hold[i-1], sell[i-2]-prices[i])。 注意：第一天不可能有卖股票的操作，hold[0] = -prices[0]。 该算法的时间复杂度是O(n)，空间复杂度是O(n)。123456789101112131415161718class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 sell = [0 for _ in range(len(prices))] hold = [0 for _ in range(len(prices))] hold[0] = -prices[0] for i in range(1, len(prices)): sell[i] = max(sell[i-1], hold[i-1]+prices[i]) hold[i] = max(hold[i-1], (sell[i-2] if i&gt;=2 else 0)-prices[i]) return sell[-1] 优化空间复杂度到O(1)123456789101112131415161718192021class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 cursell = 0 precell = 0 hold = -prices[0] for i in range(1, len(prices)): temp = cursell cursell = max(cursell, hold+prices[i]) hold = max(hold, (presell if i&gt;= 2 else 0)-prices[i]) presell = temp return cursell 322. 零钱兑换题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 解题思路DP。构建一个amount+1的数组，保存面额从0到amount+1需要使用的最少硬币数量。对于每一个位置i，如果j-c &gt;= 0, dp[i] = min(dp[i],dp[i-c]+1) 1234567891011121314151617181920212223class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [float('inf')]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for c in coins: if i-c &gt;= 0: dp[i] = min(dp[i], dp[i-c]+1) return dp[-1] if dp[-1] != float('inf') else -1 f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1123456789101112131415161718192021222324class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [0 for _ in range(amount+1)] for i in range(1, amount+1): cost = float('inf') for c in coins: if i-c &gt;= 0: cost = min(cost, dp[i-c]+1) dp[i] = cost return dp[-1] if dp[-1] != float('inf') else -1 338. 比特位计数题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1:12输入: 2输出: [0,1,1] 示例 2:12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 builtin_popcount）来执行此操作。 解题思路找规律使用dp，如果i是偶数，它的二进制1的位数等于i//2中1的位数；如果i是奇数，那么它的二进制位数等于i-1的二进制位数+1.即 if i%2==0: dp[i] = dp[i//2]else: dp[i] = dp[i-1]+1 又因为i为奇数时，i-1为偶数，即dp[i-1]=dp[i//2]，此时dp[i] = dp[i//2]+1，综合起来可以写成dp[i] = dp[i//2] + (i&amp;1) 123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] dp = [0] * (num+1) for i in range(1, num+1): # if i % 2 == 0: # dp[i] = dp[i//2] # else: # dp[i] = dp[i-1] + 1 dp[i] = dp[i//2] + (i&amp;1) return dp 暴力，时间复杂度为O(n*sizeof(integer))123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] res = [] for i in range(num+1): count = 0 while i: if i&amp;1: count += 1 i &gt;&gt;= 1 res.append(count) return res 343. 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 解题思路使用dp，dp[i]表示i拆分后的最大乘积，将i分为两部分j和i-j，将这两部分相乘取最大的。 123456789101112131415161718192021class Solution(object): def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 dp = [0]*(n+1) dp[2] = 1 dp[3] = 2 for i in range(4, n+1): for j in range(1, i//2 + 1): dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j])) return dp[-1] 357. 计算各个位数不同的数字个数题目描述给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。 示例:123输入: 2输出: 91 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。 解题思路//dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1)); //加上dp[i-1]没什么可说的，加上之前的数字 //dp[i-1]-dp[i-2]的意思是我们之前判断各位不重复的数字 //我们要在这些数字后面填新的数字。当i=2时，说明之前选取的数字只有 //1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。 //当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的 //有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9） 123456789101112131415161718class Solution(object): def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0] * (n+1) dp[0] = 1 dp[1] = 10 for i in range(2, n+1): dp[i] = dp[i-1] + (dp[i-1]-dp[i-2]) * (10-(i-1)) return dp[-1] 368. 最大整除子集题目描述给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。 如果有多个目标子集，返回其中任何一个均可。 示例 1:12输入: [1,2,3]输出: [1,2] (当然, [1,3] 也正确) 示例 2:12输入: [1,2,4,8]输出: [1,2,4,8] 解题思路首先对数组进行排序，使用dp，dp[i]的含义是从0~i位置满足题目的数组最长长度，先用i遍历每个数字，然后用j从后向前（从前到后也可以）寻找能被nums[i]整除的数字，这样如果判断能整除的时候，在判断dp[i]&lt;d[j]+1，即判断对于以i为结尾的最长数组是否变长了。在变长的情况下，需要更新dp[i]，同时使用parent[i]更新i的前面能整除的数字。另外还要统计对于整个数组最长的子数组长度。 知道了对于每个位置最长的子数组之后，我们也就知道了对于0~n区间内最长的满足题目条件的数组，最后需要再次遍历，使用parent就能把正儿个数组统计输出出来。因为这个最大的索引mx_index是对n而言的，所以输出是逆序的。 参考 1234567891011121314151617181920212223242526272829303132class Solution(object): def largestDivisibleSubset(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] nums.sort() dp = [0] * len(nums) parent = [0] * len(nums) maxlen = 0 maxlenIndex = -1 for i in range(len(nums)): for j in range(i-1, -1, -1): # for j in range(i): if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j]+1: dp[i] = dp[j] + 1 parent[i] = j if dp[i] &gt; maxlen: maxlen = dp[i] maxlenIndex = i res = [] for i in range(maxlen+1): res.append(nums[maxlenIndex]) maxlenIndex = parent[maxlenIndex] return res[::-1] 375. 猜数字大小 II题目描述我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例:123456789n = 10, 我选择了8.第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。游戏结束。8 就是我选的数字。你最终要支付 5 + 7 + 9 = 21 块钱。 给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。 解题思路这题要求我们在猜测数字y未知的情况下（1~n任意一个数），要我们在最坏情况下我们支付最少的钱。也就是说要考虑所有y的情况。 我们假定选择了一个错误的数x，（1&lt;=x&lt;=n &amp;&amp; x!=y ）那么就知道接下来应该从[1,x-1 ] 或者[x+1,n]中进行查找。 假如我们已经解决了[1,x-1] 和 [x+1,n]计算问题，我们将其表示为solve(L,x-1) 和solve(x+1,n)，那么我们应该选择max(solve(L,x-1),solve(x+1,n)) 这样就是求最坏情况下的损失。总的损失就是 f(x) = x + max(solve(L,x-1),solve(x+1,n)) 那么将x从1~n进行遍历，取使得 f(x) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。 上面的说法其实是一个自顶向下的过程（Top-down），可以用递归来解决。很容易得到如下的代码（这里用了记忆化搜索）： 参考 123456789101112131415161718class Solution(object): def getMoneyAmount(self, n): """ :type n: int :rtype: int """ dp = [[0]*(n+1) for _ in range(n+1)] return self.solve(dp, 1, n) def solve(self, dp, left, right): if left &gt;= right: return 0 if dp[left][right]: return dp[left][right] dp[left][right] = min(i + max(self.solve(dp, left, i-1), self.solve(dp, i+1, right)) for i in range(left, right+1)) return dp[left][right] 376. 摆动序列题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 解题思路摆动为一升一降，一个up就要配一个down构成一组。注意去重 123456789101112131415161718192021class Solution(object): def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) up = 1 down = 1 for i in range(1, len(nums)): if nums[i] &gt; nums[i-1]: up = down + 1 elif nums[i] &lt; nums[i-1]: down = up + 1 return max(up, down) 377. 组合总和 Ⅳ题目描述给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶： 如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？ 解题思路使用dp[i]表示组合数为i时使用nums中的数组能组成组合数的个数，因为都是正数，所以长度最多是target,target个1组成。 从1遍历到target，对于每一个数i，遍历nums数组，如果i&gt;=x, dp[i] += dp[i - x]。比如说对于[1,2,3] 4，在计算dp[3]的时候，3可以拆分为1+x，而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了。 1234567891011121314151617181920class Solution(object): def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 dp = [0] * (target+1) dp[0] = 1 for i in range(1, target+1): for x in nums: if i &gt;= x: dp[i] += dp[i-x] return dp[-1] 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1:123s = &quot;abc&quot;, t = &quot;ahbgdc&quot;返回 true. 示例 2:123s = &quot;axc&quot;, t = &quot;ahbgdc&quot;返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路dp的tag不用dp。使用一个指针index记录最后s[:index]在t中存在的最后位置。 123456789101112131415161718192021class Solution(object): def isSubsequence(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(t) &lt; len(s): return False if len(s) == 0: return True index = 0 for i in range(len(t)): if t[i] == s[index]: index += 1 if index == len(s): return True return index == len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 位运算]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是位运算相关题目题解总结。 [TOC] 位运算基本原理0s表示一串0，1s表示一串1。123x^0s = x x&amp;0s = 0 x|0s = xx^1s = ~x x&amp;1s = x x|1s = 1sx^x = 0 x&amp;x = x x|x = x 利用x^1s=~x的特点，可以将位级表示翻转； 利用x^x=0的特点，可以将三个数中重复的两个数去除，只留下另一个数； 利用x&amp;0s=0和x&amp;1s=x的特点，可以实现掩码操作，一个数num与mask进行位与操作，只保留num中与mask的1部分相对应的位；例如num:10101010和mask:00111100，进行位与操作得00101000。 利用x|0s=x和x|1s=1s的特点，可以实现设值操作，一个数num与mask进行位或操作，将num中与mask中的1部分相对应的位都设置为1；例如num:10101010和mask:00111100，进行位或操作得10111110。 位与运算技巧： n&amp;(n-1) 表示去掉n的位级表示中最低位的1。例如n:10110100，减去1得到10110011，将这两个数相与得到10110000。 n&amp;(-n)表示n的位级表示中的最低位的1，-n得到n的反码加1，对于二进制表示10110100，-n得到01001100，相与得到00000100。 n-n&amp;(~n+1)表示去掉n的位级表示中的最高位的1。例如n:10110100，则n-n&amp;(~n+1): ??? 移位运算： &gt;&gt;n为算术右移，相当于除以2^n； &gt;&gt;n为无符号右移，左边会补上0； &lt;&lt;n为算术左移，相当于乘以2^n。 mask计算： 要获取11111111，将0取反即可，~0； 要得到只有第i位为1的mask，将1向左移动i-1位即可，1&lt;&lt;(i-1)。例如1&lt;&lt;4得到只有第5位为1的mask：00010000； 要得到1到i位为1的mask，(1&lt;&lt;(i+1))-1即可，例如将1&lt;&lt;(4+1)-1=00010000-1=00001111； 要得到1到i位为0的mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。 参考 136. 只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 解题思路方法1：使用异或操作，一个数自己异或自己等于0, 一个数异或0等于数本身，即把所有数字进行异或操作，如果一个数出现两次，则变为0消失，最后剩下只出现一次的数字。 123456789101112class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for x in nums: res ^= x return res 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。1234567891011121314151617class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key in Dict: if Dict[key] == 1: return key 137. 只出现一次的数字 II题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,3,2]输出: 3 示例 2:12输入: [0,1,0,1,0,1,99]输出: 99 解题思路方法1：位运算，把32位的二进制数进行遍历，统计所有数字的每一位出现0或1的次数。因为每个数字出现3次或者1次，当某一位出现次数不为3时，则一定是出现1次，使用或操作将每个位置叠加起来。python的整形没有最大值，当输入是负数时，会认为是很大的正数，如果大于2^31-1时，则需要减去2^32。1234567891011121314151617181920class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count % 3 == 1: res |= mask mask &lt;&lt;= 1 return res if res &gt;&gt; 31 == 0 else res-(1&lt;&lt;32) 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。123456789101112131415161718class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val == 1: return key 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1:12输入: [3,2,3]输出: 3 示例 2:12输入: [2,2,1,1,1,2,2]输出: 2 解题思路方法1：将原数组排序nums.sort()， 返回nums[len(nums)//2]; 方法2：使用字典记录每个数出现的次数，返回出现次数大于len(nums)//2的数；优化：在计数时同时判断数字出现的次数，只用一个for循环； 方法3：位运算，遍历二进制的每一位，每一位上的1或0（代码使用1）出现次数大于一半，即为所求的值在该位上的值，统计每一位的1或0组合即可，减去2^32对负数进行处理。以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去2 ^ 32。 1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count &gt; len(nums)//2: res |= mask break mask &lt;&lt;= 1 return res if res&gt;&gt;31 == 0 else res - (1&lt;&lt;32) 方法4：摩尔投票法，待续。 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 解题思路方法1：遍历+set，从头到尾把字符串遍历，然后判断这10个字母是否已经出现过，如果出现过，则加入结果中，否则，加入辅助集合中。用set是因为一个字符串可能出现多次，为了防止重复添加到结果中，使用set去重。时间空间复杂度均为O(N)。1234567891011121314151617class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ if len(s) &lt; 10: return [] res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 方法2：位运算，待续 190. 颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1：1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 解题思路使用python二进制转换。12345678class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = '&#123;0:032b&#125;'.format(n) # 032b的0用于填充，0:32b为' 10100101000001111010011100'，0:032b为'00000010100101000001111010011100' res = res[::-1] res = int(res,2) return res 位运算。从n的最后一位向前遍历，放到res的后面，并且res向左移动。 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 for i in range(32): res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return res 12345678910111213class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 count = 0 while n: res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 count += 1 res = res&lt;&lt;(32-count) return res 191. 位1的个数题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题思路123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 while n: if n&amp;1: res += 1 n &gt;&gt;= 1 return res 123456789101112131415class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 mask = 1 for i in range(32): if mask &amp; n: res += 1 mask &lt;&lt;= 1 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 树]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是树相关题目题解总结。 [TOC] 94. 二叉树的中序遍历题目描述给定一个二叉树，返回它的中序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) return res 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] self.allLeftIntoStack(root, stack) while stack: root = stack.pop() res.append(root.val) if root.right: self.allLeftIntoStack(root.right, stack) return res def allLeftIntoStack(self, root, stack): while root: stack.append(root) root = root.left 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:123456789101112131415161718输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路依次以1~n作为根节点，其左边的为左子树，右边的为右子树。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划 给定一个序列1,…,n，为了构造所有的二叉树，我们遍历以i为节点，则1,…,i-1为构成左子树，i+1,…,n构成右子树；然后通过递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。 设dp[n]为1,…,n组成二叉搜索树的个数，初始化dp[0]=1,dp[1]=1,dp[2]=2； dp[n] = F(1,n)+F(2,n)+…+F(n,n)F(i,n) = dp(i-1)dp(n-i-1), 如F(1,3) = dp[0]dp[2]F(i,n)为以i为根节点的二叉树个数。等于左右子树的排列的乘积。 dp[3] = dp[0]dp[2] + dp[1]dp[1] + dp[2]*dp[0] 因为dp[n] = dp[0]*dp[n-1] + dp[1][n-2] + … + dp[n-1]dp[0] 12345678910111213141516class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt; 3: return dp[n] dp += [0]*(n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[-1] 98. 验证二叉搜索树题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:12345输入: 2 / \ 1 3输出: true 示例 2:123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路根据二叉搜索树的定义，左子树的值在(left, root.val)之间，右子树的值在(root.val, right)，每次递归是判断当前节点值是否满足取值上界和下界，计算下一节点是要根据左右节点进行更新上下界。 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.dfs(root, float('-inf'), float('inf')) def dfs(self, root, left, right): if not root: return True if root.val &lt;= left or root.val &gt;= right: return False return self.dfs(root.left, left, root.val) and self.dfs(root.right, root.val, right) 先中序遍历（递归），判断数组是否升序。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] self.inorder(root, queue) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def inorder(self, root, queue): if not root: return self.inorder(root.left, queue) queue.append(root.val) self.inorder(root.right, queue) return queue 先中序遍历（迭代），判断数组是否升序。1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] stack = [] self.LeftintoStack(root, stack) while stack: root = stack.pop() queue.append(root.val) if root.right: self.LeftintoStack(root.right, stack) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def LeftintoStack(self, root, stack): if not root: return while root: stack.append(root) root = root.left 100. 相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1:1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2:1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3:1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题思路123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 101. 对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.judge(root.left, root.right) def judge(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.judge(left.left, right.right) and self.judge(left.right, right.left) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = collections.deque() queue.append([root.left, root.right]) while queue: pair = queue.popleft() left, right = pair[0], pair[1] if not left and not right: continue if not left or not right: return False if left.val != right.val: return False queue.append([left.left, right.right]) queue.append([left.right, right.left]) return True 102. 二叉树的层次遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其层次遍历结果：12345[ [3], [9,20], [15,7]] 解题思路迭代1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res 递归123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 103. 二叉树的锯齿形层次遍历题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]] 解题思路迭代123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res 递归123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 104. 二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解题思路递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res += 1 return res 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for node in queue: if node.left: temp.append(node.left) if node.right: temp.append(node.right) res += 1 queue = temp return res 105. 从前序与中序遍历序列构造二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if not preorder or not inorder: return None rootval = preorder[0] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root 106. 从中序与后序遍历序列构造二叉树题目描述根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ if not inorder or not postorder: return None rootval = postorder[-1] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root 107. 二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为：12345[ [15,7], [9,20], [3]] 解题思路递归1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res[::-1] def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res[::-1] 108. 将有序数组转换为二叉搜索树题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ if len(nums) == 0: return None mid = len(nums)//2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 110. 平衡二叉树题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7]12345 3 / \9 20 / \ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True leftdepth = self.getdepth(root.left) rightdepth = self.getdepth(root.right) if abs(leftdepth-rightdepth) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) def getdepth(self, root): if not root: return 0 return max(self.getdepth(root.left), self.getdepth(root.right)) + 1 111. 二叉树的最小深度题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回它的最小深度 2. 解题思路迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: res += 1 for i in range(len(queue)): node = queue.pop(0) if not node.left and not node.right: return res if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 递归1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if not root.left and root.right: return self.minDepth(root.right) + 1 if not root.right and root.left: return self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 112. 路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路递归12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right: return root.val == sum return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 回溯123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False return self.dfs(root, sum-root.val) def dfs(self, root, target): if not root: return False if target == 0 and not root.left and not root.right: return True left, right = False, False if root.left: left = self.dfs(root.left, target-root.left.val) if root.right: right = self.dfs(root.right, target-root.right.val) return left or right 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False queue = [(root, sum-root.val)] while queue: node, target = queue.pop(0) if not node: continue if not node.left and not node.right and target == 0: return True if node.left: queue.append((node.left, target-node.left.val)) if node.right: queue.append((node.right, target-node.right.val)) return False 113. 路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 解题思路回溯1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [root.val], res, sum) return res def dfs(self, root, path, res, target): if not root: return if sum(path) == target and not root.left and not root.right: res.append(path) if root.left: self.dfs(root.left, path+[root.left.val], res, target) if root.right: self.dfs(root.right, path+[root.right.val], res, target) 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [], res, sum) return res def dfs(self, root, path, res, target): if not root: return if not root.left and not root.right and target == root.val: path.append(root.val) res.append(path) if root.left: self.dfs(root.left, path+[root.val], res, target-root.val) if root.right: self.dfs(root.right, path+[root.val], res, target-root.val) 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] #if not root.left and not root.right and root.val == sum: # return [[root.val]] #temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) #return [[root.val]+i for i in temp] res = [] if not root.left and not root.right and root.val == sum: return [[root.val]] temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) for i in temp: res.append([root.val]+i) return res 迭代12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: node, target, temp = queue.pop(0) if not node.left and not node.right and target == sum: res.append(temp) if node.left: queue.append((node.left, target+node.left.val, temp+[node.left.val])) if node.right: queue.append((node.right, target+node.right.val, temp+[node.right.val])) return res 114. 二叉树展开为链表题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树12345 1 / \ 2 5 / \ \3 4 6 将其展开为：12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路先前序遍历，在讲所有节点的左子树置空，并将右子树置为下一节点。空间复杂度为O(n)。12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return root #迭代 res = [] stack = [root] while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) if node.left: stack.append(node.left) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] # 递归 res = [] self.preorder(root, res) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] def preorder(self, root, res): if not root: return res.append(root) self.preorder(root.left, res) self.preorder(root.right, res) 116. 填充同一层的兄弟节点题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。示例: 给定完美二叉树，12345 1 / \ 2 3 / \ / \4 5 6 7 调用你的函数后，该完美二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路递归，从根节点开始找到任意节点，将其左孩子指向其右孩子，如果该节点的next节点已经指向其他节点，说明需要连接两个子树；比如2-&gt;3，需要把2的左子树4指向5，同时需要将左右子树连接起来，即5-&gt;6。 1234567891011121314151617181920# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.right: root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) 迭代。层次遍历，将队列中的元素弹出时，如果他不是最后一个元素，则将其的next节点指向队列中的下一个节点。1234567891011121314151617181920212223242526# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = [root] while queue: length = len(queue) for i in range(length): node = queue.pop(0) if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 117. 填充同一层的兄弟节点 II题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例: 给定二叉树，12345 1 / \ 2 3 / \ \4 5 7 调用你的函数后，该二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路递归。主要先右再左，因为在递归左子树的时候，需要不断寻找同层的next节点，需要保证右子树先建立好next节点。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.left and root.right: root.left.next = root.right temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next elif root.left: temp = root.next while temp: if temp.left: root.left.next = temp.left; break if temp.right: root.left.next = temp.right; break temp = temp.next elif root.right: temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next self.connect(root.right) self.connect(root.left) 迭代。和上题思路代码一样123456789101112131415161718192021222324252627# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = collections.deque() queue.append(root) while queue: length = len(queue) for i in range(length): node = queue.popleft() if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 129. 求根到叶子节点数字之和题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2:123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 self.res = 0 self.dfs(root, root.val) return self.res def dfs(self, root, path): if not root.left and not root.right: self.res += path if root.left: self.dfs(root.left, path*10+root.left.val) if root.right: self.dfs(root.right, path*10+root.right.val) 迭代。栈123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 stack = [(root, root.val)] while stack: node, val = stack.pop() if not node.left and not node.right: res += val if node.left: stack.append((root.left, val*10+root.left.val)) if node.right: stack.append((root.right, val*10+root.right.val)) return res 迭代。队列 144. 二叉树的前序遍历题目描述给定一个二叉树，返回它的 前序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return res.append(root.val) self.dfs(root.left, res) self.dfs(root.right,res) 迭代。栈12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 迭代。队列1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] queue = collections.deque() queue.append(root) while queue: node = queue.pop() res.append(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return res 145. 二叉树的后序遍历题目描述给定一个二叉树，返回它的 后序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 解题思路常规思路1 递归123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.postOrder(root, res) return res def postOrder(self, root, res): if not root: return self.postOrder(root.left, res) self.postOrder(root.right, res) res.append(root.val) 常规思路2 迭代 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] stack.append(root) while stack: node = stack.pop() if stack and node == stack[-1]: if node.right: stack.append(node.right) stack.append(node.right) if node.left: stack.append(node.left) stack.append(node.left) else: res.append(node.val) return res 思路3 借鉴前序根左右遍历的思路，按照根右左的方式遍历，最后的结果翻转即为后序遍历结果。以下为递归和非递归的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = None# 递归class Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.help(root, res) return res[::-1] def help(self, root, res): if not root: return res.append(root.val) self.help(root.right, res) self.help(root.left, res)# 非递归class Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return res[::-1] 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.level(root, 0, res) return [res[i][-1] for i in range(len(res))] def level(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res 208. 实现 Trie (前缀树)题目描述实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例:12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 解题思路字典树性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import collectionsclass Node(object): def __init__(self): self.children = collections.defaultdict(Node) self.isWord = Falseclass Trie(object): def __init__(self): """ Initialize your data structure here. """ self.root = Node() def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: None """ cur = self.root for w in word: cur = cur.children[w] cur.isWord = True def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ cur = self.root for w in word: cur = cur.children.get(w) if not cur: return False return cur.isWord def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ cur = self.root for w in prefix: cur = cur.children.get(w) if not cur: return False return True # Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) 222. 完全二叉树的节点个数题目描述给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 解题思路分治递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 对于一棵满二叉树，若其高度为l，则节点个数为2^l-1个节点。递归求解。 首先从根节点开始，沿左子树的左节点一路向下，得到整棵二叉树的最大深度h_l（因为是完全二叉树，所以最左侧叶节点的高度可以代表整棵树的最大高度）。 其次计算根节点右子树最左侧子节点的高度h_r。若h_l = h_r，则说明左子树为一满二叉树，可通过公式2^h_l计算其节点个数。若h_l &gt; h_r（h_l = h_r + 1），则说明右子树为满二叉树，可通过公式2^h_r计算其节点个数。 递归计算另一棵子树的节点数目。终止条件：当前节点高度为子树高度h_l，h_r均为0，说明其左右节点均为空，没有进入循环调节，即到达最后的叶节点。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 h_l, h_r = 0, 0 curRoot = root.left while curRoot: h_l += 1 curRoot = curRoot.left curRoot = root.right if curRoot: h_r += 1 curRoot = curRoot.left while curRoot: h_r += 1 curRoot = curRoot.left if h_l == h_r: sum_l = 2**h_l - 1 sum_r = self.countNodes(root.right) if h_l &gt; h_r: sum_r = 2**h_r - 1 sum_l = self.countNodes(root.left) return sum_l + sum_r + 1 226. 翻转二叉树题目描述翻转一棵二叉树。 示例：1234567891011121314输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if not root: return root temp = root.left root.left = root.right root.right = temp self.invertTree(root.left) self.invertTree(root.right) return root 230. 二叉搜索树中第K小的元素题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 解题思路中序遍历。12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ if not root or k &lt;= 0: return 0 res = [] self.inorder(root, res) return res[k-1] def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) python3的yield。1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if not root or k &lt;= 0: return 0 iteration = self.inorder(root) res = 0 for i in range(k): res = next(iteration) return res def inorder(self, root): if root: yield from self.inorder(root.left) yield root.val yield from self.inorder(root.right) 235. 二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路首先保证p的值一定比q的小利用二叉搜索树的特性，左子树一定比根节点小，右子树一定比根节点大； p和q在root两侧，那么root就是公共祖先 pq均小于root，那么从左子树寻找 pq均大于root，那么从右子树寻找 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if p.val &gt; q.val: p, q = q, p node = root while True: if node.val == p.val or node.val == q.val: return node elif p.val &lt; node.val &lt; q.val: return node elif q.val &lt; node.val: node = node.left else: node = node.right 可以将其看做普通的二叉树，使用236题的代码也可AC.123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root elif not left and not right: return None return left if left else right 236. 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路递归。对以root为根的树进行查找p和q 如果root为空或root==p或root==q，直接返回root，表明当前树已经查询完成； 如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 否则对左右子树进行查找，根据左右子树的返回值进行判断： 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA 左右子树返回值均为null, p和q均不在树中, 返回null 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left and not right: return None elif left and right: return root else: return left if left else right 257. 二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 解题思路递归1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] self.dfs(root, str(root.val), res) return res def dfs(self, root, path, res): if not root: return if not root.left and not root.right: res.append(path) return if root.left: self.dfs(root.left, path + '-&gt;' + str(root.left.val), res) if root.right: self.dfs(root.right, path + '-&gt;' + str(root.right.val), res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] stack = [(root, str(root.val))] while stack: node, path = stack.pop(0) if not node.left and not node.right: res.append(path) if node.left: stack.append((node.left, path + '-&gt;' + str(node.left.val))) if node.right: stack.append((node.right, path + '-&gt;' + str(node.right.val))) return res 297. 二叉树的序列化与反序列化题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例:123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 提示: 这与 Leetcode 目前使用的方式一致，详情请参阅 Leetcode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路采用前序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return '#' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ tree = data.split(',') return self.Tree(tree) def Tree(self, tree): if not tree: return None root = None val = tree.pop(0) if val != '#': root = TreeNode(int(val)) root.left = self.Tree(tree) root.right = self.Tree(tree) return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 337. 打家劫舍 III题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1:12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2:12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路对于一个以root为根节点的二叉树而言： 如果偷root节点，那么不能偷其左右子节点 如果不偷该节点，那么可以偷其左右子节点 比较两种方式的大小，取大值 递归完成，每次返回的是(偷，不偷)当前节点的值，如果偷根节点了，那么不能偷其子节点，即加上的是left[1]，和right[1]，1表示的是返回不偷该节点的值。 如果不偷根节点，那么可以偷左右子节点 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rob(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.tryrob(root)) def tryrob(self, root): if not root: return (0, 0) left = self.tryrob(root.left) right = self.tryrob(root.right) # rob now now = root.val + left[1] + right[1] # rob later later = max(left) + max(right) return (now, later) 404. 左叶子之和题目描述计算给定二叉树的所有左叶子之和。 示例：1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回24 解题思路递归，当遇到左叶子节点时加到和里，然后取递归右子树 否则，还没遇到左叶子节点，遍历左子树和右子树123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumOfLeftLeaves(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if root.left and not root.left.left and not root.left.right: return root.left.val + self.sumOfLeftLeaves(root.right) else: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 二分查找]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是二分查找相关题目题解总结。 [TOC] 二分查找二分查找也称折半查找，它是一种效率较高的查找方法。但是折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排序。 查找过程二分查找适用于有序的顺序表。首先将表中间位置记录的关键字和查找关键字比较；如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表；如果中间位置记录的关键字大于查找关键字，则进入前一子表，否则进入后一子表；重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止。 算法要求 必须采用顺序存储结构； 必须按关键字大小有序排序。 复杂度时间复杂度O(log2n)，空间复杂度为O(1)。 中值mid的计算有两种计算中值mid的方式： mid = (left+right) // 2; mid = left + (right-left)//2left+right 可能出现加法溢出，最好使用第二种方式。 返回值 如果成功查找到key： 返回key所在的位置。 如果循环退出时仍然没有找到key，表示查找失败，有两种可能返回值： -1:以一个错误码表示没有查找到key；pos：将key插入到原列表中合适的位置。 正常实现1234567891011121314class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == key: return mid elif nums[mid] &gt; key: right = mid - 1 else: left = mid + 1 return -1 二分查找的变种二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：123456789101112131415class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt; right: # 小于 而不是小于等于 mid = left + (right-left)//2 if nums[mid] &gt;= key: right = mid # mid 不是mid-1 else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().binarySearch([1,1,1,2,3,3,4,5,6,7],1) print(result) 与正常实现不同： right 的赋值表达式为 right = mid； 循环条件为left&lt;right; 最后返回left而不是-1。 解释： 在nums[mid] &gt;= key的情况下，可以推导出最左key位于[left,mid]区间中，right 的赋值表达式为 right = mid，因为mid位置也可能为解； 在right 的赋值表达式为 right = mid的情况下，如果循环条件为left&lt;=right，将会导致陷入死循环的情况； 当循环退出时，不表示没有查找成功，为了验证有没有查找到，应该在调用函数时判断一下返回值上的值和key是否相等。 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int divide(int dividend, int divisor) &#123; int flag = 1; if ((dividend&lt;0) != (divisor&lt;0)) flag = -1; long newDividend = Math.abs((long) dividend); long newDivisor = Math.abs((long) divisor); long res = 0; while (newDividend &gt;= newDivisor)&#123; long count = 1; long tempDivisor = newDivisor; while (tempDivisor &lt;= newDividend)&#123; res += count; newDividend -= tempDivisor; tempDivisor &lt;&lt;= 1; count &lt;&lt;= 1; &#125; &#125; if (flag == -1) res = -res; if (res &lt; Integer.MIN_VALUE || res &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; return (int)res; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int res = sol.divide(-2147483648, -1); System.out.println(res); &#125;&#125; 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 123456789101112131415161718192021222324252627282930class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return -1 34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解题思路二分查找。 当nums[mid] == target时，说明target在数组中的[left,right]中，其中开始位置在[left,mid]，结束位置在[mid,right]中； 从头遍历[left,mid]，找到第一个等于target的位置作为开始位置； 从后遍历[mid,right]，从后找到第一个等于target的位置作为结束位置； 当nums[mid] &gt; target时，right = mid-1 当nums[mid] &lt; target时，left = mid+1 12345678910111213141516171819202122232425262728293031class Solution(object): def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1,-1] left, right = 0 ,len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: temp = [] for i in range(left,mid+1): if nums[i] == target: temp.append(i) break for i in range(right, mid-1,-1): if nums[i] == target: temp.append(i) break return temp elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return [-1,-1]if __name__ == '__main__': result = Solution().searchRange([5,7,7,8,8,10],8) print(result) 35. 搜索插入位置题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 2输出: 1 示例 3:12输入: [1,3,5,6], 7输出: 4 示例 4:12输入: [1,3,5,6], 0输出: 0 解题思路1234567891011121314151617181920212223class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return left 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: # return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2 示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 解题思路 二分查找。一个数x的开根号一定在[1,x//2+1]之间，因为在(x//2+1)^2 &gt; x，所以我们将二分查找的终点设为x//2+1; 对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 left &lt;= right 并且循环退出时，right 总是比 left 小 1，也就是说 right = 2，left = 3，因此最后的返回值应该为 right 而不是 left。 1234567891011121314151617181920class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x == 0: return 0 if x == 1: return 1 left, right = 1, x//2+1 while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在正式比较之前，先移动左指针，使它指向和右指针不同的数字上。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: while left &lt; right and nums[left] == nums[right]: left += 1 mid = left + (right-left)//2 if nums[mid] == target: return True if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 153. 寻找旋转排序数组中的最小值题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 示例 2: 输入: [4,5,6,7,0,1,2]输出: 0 解题思路数组分为两个升序的数组，使用二分查找。 当nums[mid]&gt;nums[mid+1]时，最小值为nums[mid+1]; 当nums[mid]&gt;nums[right]时,left = mid+1; 当nums[mid]&gt;nums[right]时,right = mid，因为mid位置可能就是最小值了； 由于right = mid，则循环条件为left&lt;right。 1234567891011121314151617181920212223class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] left, right = 0, len(nums)-1 while left &lt; right: mid = left + (right-left)//2 if mid+1 &lt;= len(nums)-1 and nums[mid] &gt; nums[mid+1]: return nums[mid+1] if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]if __name__ == '__main__': result = Solution().findMin([4,5,6,7,0,1,2]) print(result) 二刷12345678910111213141516171819202122class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if mid-1&gt;=0 and nums[mid-1] &gt; nums[mid]: return nums[mid] if nums[mid] &lt;= nums[right]: right = mid-1 else: left = mid + 1 return nums[left] 162. 寻找峰值题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 解题思路用两个mid，判断上坡还是下坡，上坡将left移到坡顶，下坡将right移到坡顶123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 left, right = 0, len(nums)-1 while left &lt; right: mid1 = left+(right-left)//2 mid2 = mid1 + 1 if nums[mid1] &lt; nums[mid2]: left = mid2 else: right = mid1 return left 278. 第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -false调用 isBadVersion(5) -true调用 isBadVersion(4) -true所以，4 是第一个错误的版本。 解题思路给定 n = 5，并且 version = 4 是第一个错误的版本时，输入分布为[1,2,3,4,5]，对应版本正误情况为[0,0,0,1,1]，题目要求出最靠左的1的位置。使用二分查找： 如果第mid个版本出错，则第一个出错版本在[left,mid]，有可能出现在mid位置，因此right = mid； 如果第mid个版本没错，则第一个出错版本在[mid+1,right]，因此left = mid+1; 当循环条件为left&lt;=right时，会陷入死循环。 总结：当right的赋值表达式为 right = mid 时，循环条件为 left &lt; right。 123456789101112131415161718192021222324252627# The isBadVersion API is already defined for you.# @param version, an integer# @return a booldef isBadVersion(version): if version in (1,2,3): return False elif version in (4,5): return Trueclass Solution(object): def firstBadVersion(self, n): """ :type n: int :rtype: int """ left, right = 1, n while left &lt; right: mid = left + (right-left)//2 if isBadVersion(mid): right = mid else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().firstBadVersion(5) print(result) 540. 有序数组中的单一元素题目描述给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例 2: 输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 解题思路如果题目不限制在 O(log n)时间复杂度运行，可使用异或运算。1234567891011def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for i in nums: res ^= i return res 使用二分查找法实现O(log n)时间复杂度和 O(1)空间复杂度。初始令左右指针分别为 0，len(nums)-1;当left&lt;= right时循环：mid = left+(right-left)//2 当nums[mid] == nums[mid-1]时，数组可以分为[left, mid-2], [mid+1, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-2]长度为偶数，则目标位于[mid+1, right]，令left = mid +1;当mid为偶数时，说明[left, mid-2]长度为奇数，则目标位于该数组内，令right = mid -1; 同理当nums[mid] == nums[mid+1]时，数组可以分为[left, mid-1], [mid+2, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-1]长度为奇数，则目标位于该数组内，令right = mid -1;当mid为偶数时，说明[left, mid-1]长度为偶数，则目标位于[mid+2, right]，令left = mid +1; 当nums[mid]与nums[mid - 1], nums[mid + 1]均不相等，则返回nums[mid]。 1234567891011121314151617181920212223242526class Solution(object): def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left) //2 if mid-1 &gt;= 0 and nums[mid] == nums[mid-1]: if mid %2 == 1: left = mid + 1 else: right = mid - 2 elif mid+1 &lt;= len(nums)-1 and nums[mid] == nums[mid+1]: if mid %2 == 1: right = mid - 1 else: left = mid + 2 else: return nums[mid]if __name__ == '__main__': result = Solution().singleNonDuplicate([3,3,7,7,10,11,11]) print(result) 744. 寻找比目标字母大的最小字母题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 示例: 输入:letters = [“c”, “f”, “j”]target = “a”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f” 输入:letters = [“c”, “f”, “j”]target = “g”输出: “j” 输入:letters = [“c”, “f”, “j”]target = “j”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “k”输出: “c” 注: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路二分搜索。注意当有重复字母时，如[“e”,”e”,”e”,”e”,”e”,”e”,”n”,”n”,”n”,”n”],”e”，当letters[mid] 小于及 等于 target时，left都要向前走一步;如果left大于右边界时，说明target比数组里的所有字母都大，返回letters[0];否则返回letters[left]。 1234567891011121314151617181920class Solution(object): def nextGreatestLetter(self, letters, target): """ :type letters: List[str] :type target: str :rtype: str """ if len(letters) == 0: return '' left, right = 0, len(letters)-1 while left &lt;= right: mid = left + (right-left)//2 if letters[mid] &lt;= target: left = mid + 1 else: right = mid - 1 return letters[0] if left == len(letters) else letters[left]if __name__ == '__main__': result = Solution().nextGreatestLetter(["e","e","e","e","e","e","n","n","n","n"],"e") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 搜索]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是搜索相关题目题解总结。 [TOC] 搜索本文内容主要包括广度优先搜索(breadth first search)，深度优先搜索(depth first search)。 广度优先搜索(BFS)主要思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点依次访问它们的邻接点，并使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起点，重复上述过程，直至图中所有顶点都被访问到。 注意：遍历过的节点不能再次被遍历。 每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。 实现 BFS 时需要考虑以下问题：队列：用来存储每一轮遍历得到的节点；标记：对于遍历过的节点，应该将它标记，防止重复遍历。 无向图的广度优先搜索 第1步：访问A。并将C，D，F加入到访问队列，[C,D,F] 第2步：访问C。并将 B加入到访问队列，[D,F,B] 第3步：访问D。由于D的邻接点C已经访问过，则不加入访问队列，[F,B]; 第4步：访问F。并将G加入访问队列，[B,G]; 第5步：访问B。 第6步：访问G。并将E加入到访问队列，[E]; 第7步：访问E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索 访问顺序：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 深度优先搜索(DFS)主要思想：假设初始状态所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历，直到所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问到。 深度优先搜索是一个递归的过程。 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种可达性问题。 实现 DFS 时需要考虑以下问题：栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。 无向图的深度优先搜索访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 参考 127. 单词接龙题目描述给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -“hot” -“dot” -“dog” -“cog”, 返回它的长度 5。 示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 解题思路使用BFS，最短路的思路。将beginWord放进队列，如果队列不为空，那么取出第一个数，将其周围的在字典的字符放进队列，直到周围的存在endword。1234567891011121314151617181920212223242526import collectionsclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) queue = collections.deque() queue.append([beginWord, 1]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i + 1:] if nextWord in wordList: wordList.remove(nextWord) queue.append([nextWord, length + 1]) return 0if __name__ == '__main__': result = Solution().ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]) print(result) 123456789101112131415161718192021222324class Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) stack = [(beginWord, 1)] while stack: word, length = stack.pop(0) if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i+1:] if nextWord in wordList: wordList.remove(nextWord) stack.append((nextWord, length+1)) return 0 130. 被围绕的区域题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例:1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为：1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路从边上开始搜索，如果是’O’,那么搜索’O’周围的元素，并将’O’置换为’D’。如果该’O’周围都是’X’，则会跳出，这样内部的’O’将不受影响。最后没有被’X’围住的’O’都置换成了’D’,被围住的’O’还是’O’，没有改变。然后遍历一遍，将’O’置换为’X’，将’D’置换为’O’。 在Leetcode中文网站无法提交，英文网站正常。 迭代 BFS。123456789101112131415161718192021222324252627class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ import collections queue = collections.deque([]) for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board) - 1] or c in [0, len(board[0]) - 1]) and board[r][c] == "O": queue.append((r, c)) while queue: r, c = queue.popleft() if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == "O": board[r][c] = "D" queue.append((r - 1, c)) queue.append((r + 1, c)) queue.append((r, c - 1)) queue.append((r, c + 1)) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == "O": board[r][c] = "X" elif board[r][c] == "D": board[r][c] = "O" 递归 DFS1234567891011121314151617181920212223class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O': self.dfs(board, r, c) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == 'O': board[r][c] = 'X' elif board[r][c] == 'D': board[r][c] = 'O' def dfs(self, board, r, c): if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == 'O': board[r][c] = 'D' self.dfs(board, r-1, c) self.dfs(board, r+1, c) self.dfs(board, r, c-1) self.dfs(board, r, c+1) 133. 克隆图题目描述克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。 OJ的无向图序列化： 节点被唯一标记。 我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。 例如，序列化无向图 {0,1,2#1,2#2,2}。 该图总共有三个节点, 被两个分隔符 # 分为三部分。 第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。 第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。 第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。 我们将图形可视化如下： 解题思路由于遍历一个图有两种方式：bfs和dfs。所以深拷贝一个图也可以采用这两种方法。不管使用dfs还是bfs都需要一个哈希表map来存储原图中的节点和新图中的节点的一一映射。map的作用在于替代bfs和dfs中的visit数组，一旦map中出现了映射关系，就说明已经复制完成，也就是已经访问过了。 BFS12345678910111213141516171819202122232425262728# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None queue = [] dic = &#123;&#125; newhead = UndirectedGraphNode(node.label) dic[node] = newhead queue.append(node) while queue: curr = queue.pop() for neighbor in curr.neighbors: if neighbor not in dic: copy = UndirectedGraphNode(neighbor.label) dic[curr].neighbors.append(copy) dic[neighbor] = copy queue.append(neighbor) else: dic[curr].neighbors.append(dic[neighbor]) return newhead DFS12345678910111213141516171819202122# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None return self.dfs(node, &#123;&#125;) def dfs(self, input, dic): if input in dic: return dic[input] output = UndirectedGraphNode(input.label) dic[input] = output for neighbor in input.neighbors: output.neighbors.append(self.dfs(neighbor, dic)) return output 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 解题思路按层次遍历，没层取最右边元素。 BFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res DFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, 0, res) return [level[-1] for level in res] def dfs(self, root, level, res): if not root: return [] if level == len(res): res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 200. 岛屿的个数题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路给定由0和1组成的二维数组，求1的连通块。 BFS 超时12345678910111213141516171819202122232425262728class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.bfs(grid, i, j) count += 1 return count def bfs(self, grid, i, j): queue = collections.deque() queue.append((i,j)) grid[i][j] = '#' direction = [(0,1), (0,-1), (1,0), (-1,0)] while queue: i, j = queue.popleft() for d in direction: r, c = i + d[0], i + d[1] if 0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0]) and grid[r][c] == '1': grid[r][c] == '#' queue.append((r, c)) DFS12345678910111213141516171819202122class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0]) and grid[i][j] == '1': grid[i][j] = '#' self.dfs(grid, i-1, j) self.dfs(grid, i+1, j) self.dfs(grid, i, j-1) self.dfs(grid, i, j+1) 207. 课程表题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: **输入:** 2, [[1,0]] **输出: **true **解释:** 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: **输入:** 2, [[1,0],[0,1]] **输出: **false **解释:** 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 解题思路使用拓扑排序。在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件： 每个顶点出现且只出现一次。 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。 有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。 BFS方法：我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个 queue 变量，将所有入度为0的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为0，则说明环存在，返回 false，反之则返回 true。 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ graph = collections.defaultdict(list) indegree = [0] * numCourses # 使用邻接表存储图 for u, v in prerequisites: graph[v].append(u) indegree[u] += 1 # 保存入度为0的课表 queue = [] for i in range(numCourses): if indegree[i] == 0: queue.append(i) while queue: node = queue.pop(0) if node not in graph: continue for i in graph[node]: indegree[i] -= 1 if indegree[i] == 0: queue.append(i) for i in range(numCourses): if indegree[i] != 0: return False return True DFS：这个方法是，我们每次找到一个新的点，判断从这个点出发是否有环。具体做法是使用一个visited数组，当visited[i]值为0，说明还没判断这个点；当visited[i]值为1，说明当前的循环正在判断这个点；当visited[i]值为2，说明已经判断过这个点，含义是从这个点往后的所有路径都没有环，认为这个点是安全的。 那么，我们对每个点出发都做这个判断，检查这个点出发的所有路径上是否有环，如果判断过程中找到了当前的正在判断的路径，说明有环；找到了已经判断正常的点，说明往后都不可能存在环，所以认为当前的节点也是安全的。如果当前点是未知状态，那么先把当前点标记成正在访问状态，然后找后续的节点，直到找到安全的节点为止。最后如果到达了无路可走的状态，说明当前节点是安全的。1234567891011121314151617181920212223242526272829303132class Solution(object): def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ graph = collections.defaultdict(list) # 使用邻接表存储图 for u, v in prerequisites: graph[v].append(u) visited = [0] * numCourses for i in range(numCourses): if not self.judge(graph, visited, i): return False return True def judge(self, graph, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.judge(graph, visited, j): return False visited[i] = 2 return True 210. 课程表 II题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1:123**输入:** 2, [[1,0]] **输出: **[0,1]**解释:** 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**输入:** 4, [[1,0],[2,0],[3,1],[3,2]]**输出: **[0,1,2,3] or [0,2,1,3]**解释:** 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。``` **说明:**1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。2. 你可以假定输入的先决条件中没有重复的边。**提示:**1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&amp;amp;fromid=2148012&amp;amp;fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2) 完成。### 解题思路拓扑排序BFS```pythonimport collectionsclass Solution(object): def findOrder(self, numCourses, prerequisites): &quot;&quot;&quot; :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] &quot;&quot;&quot; graph = collections.defaultdict(list) indegrees = [0] * numCourses for u, v in prerequisites: graph[v].append(u) indegrees[u] += 1 queue = [] for i in range(numCourses): if indegrees[i] == 0: queue.append(i) res = [] while queue: node = queue.pop(0) res.append(node) for t in graph[node]: indegrees[t] -= 1 if indegrees[t] == 0: queue.append(t) return res if len(res) == numCourses else [] DFS1234567891011121314151617181920212223242526272829303132333435import collectionsclass Solution(object): def findOrder(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] """ graph = collections.defaultdict(list) for u, v in prerequisites: graph[v].append(u) res = [] visited = [0] * numCourses for i in range(numCourses): if not self.judge(graph, visited, i, res): return [] return res[::-1] if len(res) == numCourses else [] def judge(self, graph, visited, i, res): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.judge(graph, visited, j, res): return False visited[i] = 2 res.append(i) return True 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路使用DFS，如n=12，首先计算出可能存在的平方数candidate = [1,4,9]，然后对当前残差及candidate进行遍历，直到残差等于candidate，则返回。 123456789101112131415161718192021222324252627282930313233class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ if n &lt; 0: return 0 if n &lt;= 1: return 1 candidate = [] i = 1 while i*i &lt;= n: candidate.append(i*i) i += 1 count = 0 toCheck = &#123;n&#125; while toCheck: count += 1 temp = set() for residue in toCheck: for cand in candidate: if residue == cand: return count if residue &lt; cand: break temp.add(residue-cand) toCheck = temp return countif __name__ == '__main__': result = Solution().numSquares(12) print(result) 547. 朋友圈题目描述班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1:1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2:123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意：123N 在[1,200]的范围内。对于所有学生，有M[i][i] = 1。如果有M[i][j] = 1，则有M[j][i] = 1。 解题思路思路1 DFS1234567891011121314151617181920212223class Solution(object): def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ if len(M) == 0: return 0 res = 0 visited = [False]*len(M) for i in range(len(M)): if not visited[i]: res += 1 self.dfs(M, i, visited) return res def dfs(self, M, i, visited): visited[i] = True for j in range(len(M)): if M[i][j] == 1 and not visited[j]: self.dfs(M, j, visited) 思路2 并查集 核心思想是初始时给每一个对象都赋上不同的标签，然后对于属于同一类的对象，在root中查找其标签，如果不同，那么将其中一个对象的标签赋值给另一个对象，注意root数组中的数字跟数字的坐标是有很大关系的，root存的是属于同一组的另一个对象的坐标，这样通过getRoot函数可以使同一个组的对象返回相同的值。 123456789101112131415161718192021222324252627282930class Solution(object): def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ if len(M) == 0: return 0 res = len(M) root = [0] * len(M) for i in range(len(M)): root[i] = i for i in range(len(M)): for j in range(i+1, len(M)): if M[i][j] == 1: p1 = self.getRoot(root, i) p2 = self.getRoot(root, j) if p1!=p2: res -= 1 root[p2] = p1 return res def getRoot(self, root, i): while i != root[i]: root[i] = root[root[i]] i = root[i] return i]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 栈和队列]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是栈和队列相关题目题解总结。 [TOC] 栈和队列栈的顺序为后进先出，队列 的顺序为先进先出。 20. 有效的括号题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;&#123;[]&#125;&quot;输出: true 解题思路使用栈，遍历字符串，当栈为空或者当前字符为左括号’(‘,’[‘,’{‘时或者为右括号但是栈顶字符与其不匹配，则将字符加入栈，否则栈顶字符出栈。最后判断栈是否为空。12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ if not s: return True Dict = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for c in s: if not stack or c not in Dict or stack[-1] != Dict[c]: stack.append(c) else: stack.pop() return True if not stack else False 71. 简化路径题目描述以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：123输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 示例 2：123输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：123输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：12输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot; 示例 5：12输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot; 示例 6：12输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot; 解题思路将字符串按照‘/‘分隔得到了每个文件的目录，然后遍历每个目录进行入栈或者出栈。如果目录为空或者为当前目录’.’，则不进行任何操作；如果为’..’，表示返回上一级目录，如果栈中有上级目录，则将其弹出。 12345678910111213141516171819class Solution(object): def simplifyPath(self, path): """ :type path: str :rtype: str """ if not path: return '/' stack = [] path = path.split('/') for c in path: if not c or c == '.': continue if c == '..': if stack: stack.pop() else: stack.append(c) return '/'+'/'.join(stack) 84. 柱状图中最大的矩形题目描述给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3]输出: 10 解题思路使用一个递增单调栈，栈中保存坐标，数组中坐标依次入栈，当当前坐标的值小于栈顶坐标的值，则栈顶坐标弹出，并计算弹出坐标的面积，它的右边界是当前坐标的值（因为当前坐标让它出栈），左边界是栈顶坐标（当栈为空时为-1）。当数组遍历完成后，栈不为空，则依次弹出，计算弹出坐标的面积，右边界是数组长度，左边界是栈顶坐标（当栈为空时为-1）。 例如：[2,1,5,6,2,3]先将2的坐标入栈，栈为[0]；元素1的坐标1入栈前比较，因为1位置的元素比栈顶(0)位置的元素小，则位置0出栈，栈为空，计算0位置的面积(1-(-1)-1)*2=2，在将1入栈，栈为[1]；坐标2的元素5大于栈顶位置元素(1)，则坐标2入栈，栈为[1,2]；坐标3的元素6大于栈顶位置元素(5)，则坐标3入栈，栈为[1,2,3]；坐标4的元素2小于栈顶位置元素(6)，则将栈顶位置3弹出，栈为[1,2]，计算3位置的面积(4-2-1)*6 = 6，此时2依然小于栈顶位置2的元素5，则栈顶位置2出栈，栈为[1]，计算2位置的面积(4-1-1)*5=10；此时2大于栈顶位置元素，则2的坐标4入栈，栈为[1,4]；坐标5的元素3大于栈顶位置元素(2)，坐标5入栈，栈为[1,4,5]；数组遍历完成。 此时栈不为空，依次弹出计算面积。弹出位置5，栈为[1,4]，面积为(6-4-1)*3=3;弹出位置4，栈为[1]，面积为(6-1-1)*2=8;弹出位置1，栈为空，面积为(6-(-1)-1)*1=6;所以最大面积为max(2,6,10,3,8,6)=10。 123456789101112131415161718192021222324class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i-left-1)*heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1)*heights[index]) return res 85. 最大矩形题目描述给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 解题思路使用一个辅助数组，大小为矩阵列宽，依次以矩阵每一行为底计算最大面积，直接调用上一题的代码计算。辅助数组计算方法：初始化为0，当当前元素为1是，高度加1，为0时直接为0。例如上例：第一行 [1 0 1 0 0]第二行 [2 0 2 1 1]第三行 [3 1 3 2 2]第四行 [4 0 0 3 0] 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def maximalRectangle(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 heights = [0] * len(matrix[0]) res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 res = max(res, self.largestRectangleArea(heights)) return res def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i - left - 1) * heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1) * heights[index]) return res 150. 逆波兰表达式求值题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2：123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3：12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 12345678910111213141516171819202122232425class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for c in tokens: if c not in ('+','-','*','/'): stack.append(c) else: a = int(stack.pop()) b = int(stack.pop()) if c == '+': stack.append(str(b+a)) if c == '-': stack.append(str(b-a)) if c == '*': stack.append(str(b*a)) if c == '/': if b*a &lt; 0 and b%a != 0: stack.append(str(b/a+1)) else: stack.append(str(b/a)) return int(stack[0]) 155. 最小栈题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.data = [] self.min = [] def push(self, x): """ :type x: int :rtype: void """ self.data.append(x) if not self.min or x &lt;= self.min[-1]: self.min.append(x) def pop(self): """ :rtype: void """ val = self.data.pop() if val == self.min[-1]: self.min.pop() def top(self): """ :rtype: int """ return self.data[-1] def getMin(self): """ :rtype: int """ return self.min[-1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 224. 基本计算器题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。 示例 1:12输入: &quot;1 + 1&quot;输出: 2 示例 2:12输入: &quot; 2-1 + 2 &quot;输出: 3 示例 3:12输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;输出: 23 说明： 你可以假设所给定的表达式都是有效的。请不要使用内置的库函数 eval。 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 if len(s) == 1: return int(s[0]) stack = [] i = 0 while i &lt; len(s): if s[i] == ')': helpStack = [] while stack and stack[-1] != '(': helpStack.insert(0, stack.pop()) stack.pop() stack.append(self.help(helpStack)) elif s[i] in "+-(": stack.append(s[i]) elif s[i] in "0123456789": num = 0 while i &lt; len(s) and s[i] not in ['+', '-', '(', ')', ' ']: num = num * 10 + int(s[i]) i += 1 i -= 1 stack.append(num) i += 1 if len(stack) != 1: stack.append(self.help(stack)) return stack[0] def compute(self, b, op, a): if op == '+': return b + a elif op == '-': return b - a def help(self, stack): if len(stack) == 1: return int(stack[0]) while len(stack) &gt;= 3: a = int(stack.pop(0)) op = stack.pop(0) b = int(stack.pop(0)) stack.insert(0, self.compute(a, op, b)) return stack[0] 225. 用队列实现栈题目描述使用队列实现栈的下列操作：1234push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空 注意: 你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路使用一个队列，每次新元素进队列的时候，先把当前的数字进入队列，然后把它前面的所有的元素移到新进队的后面。 例如：1进队列， [1] -&gt; [1]2进队列, [1,2] -&gt;[2,1]3进队列, [2,1,3] -&gt;[3,2,1]4进队列, [3,2,1,4] -&gt;[4,3,2,1] 栈顶为第一个元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyStack(object): def __init__(self): """ Initialize your data structure here. """ self.queue = collections.deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: None """ self.queue.append(x) for i in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.queue.popleft() def top(self): """ Get the top element. :rtype: int """ return self.queue[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.queue) == 0# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() 232. 用栈实现队列题目描述使用栈实现队列的下列操作： push(x) — 将一个元素放入队列的尾部。pop() — 从队列首部移除元素。peek() — 返回队列首部的元素。empty() — 返回队列是否为空。示例:1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue(object): def __init__(self): """ Initialize your data structure here. """ self.stack1 = [] self.stack2 = [] def push(self, x): """ Push element x to the back of queue. :type x: int :rtype: None """ self.stack1.append(x) def pop(self): """ Removes the element from in front of queue and returns that element. :rtype: int """ if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): """ Get the front element. :rtype: int """ if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def empty(self): """ Returns whether the queue is empty. :rtype: bool """ return not self.stack1 and not self.stack2 # Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 字符串]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是字符串相关题目题解总结。 [TOC] 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] Manacher算法 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) == 0: return '' s = self.init(s) p = [0] * len(s) id = -1 # 记录最右回文子串的中心 mx = -1 res = 0 maxCenter = 0 # 记录最长回文子串的中心 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if p[i] &gt; res: maxCenter = i res = p[i] return ''.join(s[center-(res-1):center+res-1+1].split('#')) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return res` 6. Z 字形变换题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LeetcodeISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数：1string convert(string s, int numRows); 示例 1:12输入: s = &quot;LeetcodeISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:12345678输入: s = &quot;LeetcodeISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 解题思路将字符分为numRows保存，遍历字符串，从上到下和从下到上反复将字符加到对应的行里，当遍历到第一行时，index递增，当遍历到最后一行时，index递减。 12345678910111213141516171819202122232425class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): return s res = ['' for i in range(numRows)] index = 0 step = 1 for x in s: res[index] += x if index == 0: step = 1 elif index == numRows-1: step = -1 index += step return ''.join(res) 10. 正则表达式匹配题目描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 &#39;*&#39; 的正则表达式匹配。123&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明:12s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 解题思路以下超时，剑指中可以通过。 我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑&#39;*&#39;：如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符&#39;*&#39;考虑进去，它可以匹配任意次的字符，当然出现0次也可以：而当模式中的第二个字符是*时：如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 模式后移2字符，相当于x*被忽略； 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符’.’的情况。 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为’.’的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 1234567891011121314151617181920212223class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if not s and not p: return True if not p: return False if len(p) &gt;= 2 and p[1] == "*": if s and (s[0] == p[0] or p[0] == "."): return self.isMatch(s[1:], p[2:]) or self.isMatch(s, p[2:]) or self.isMatch(s[1:], p) else: return self.isMatch(s, p[2:]) else: if s and (s[0] == p[0] or p[0] == "."): return self.isMatch(s[1:],p[1:]) return False 动态规划AC1234定义一个二维的DP数组，其中dp[i][j]表示s[0,i)和p[0,j)是否match，然后有下面三种情况:1. P[i][j] = P[i - 1][j - 1], if p[j - 1] != &apos;*&apos; &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;);2. P[i][j] = P[i][j - 2], if p[j - 1] == &apos;*&apos; and the pattern repeats for 0 times;3. P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;), if p[j - 1] == &apos;*&apos; and the pattern repeats for at least 1 times. 参考 https://www.cnblogs.com/grandyang/p/4461713.html123456789101112131415161718192021222324class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if not s and not p: return True if not p: return False dp = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[0][0] = True for i in range(len(s)+1): for j in range(1, len(p)+1): if j&gt;1 and p[j-1] == '*': dp[i][j] = (dp[i][j-2]) or (i&gt;0 and dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.')) else: dp[i][j] = (i &gt; 0) and dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.') return dp[-1][-1] 14. 最长公共前缀题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路首先把第一个字符串作为答案，然后遍历后面的字符串，当后面的字符串长度小于第一个字符串时，需要对第一个字符串进行裁剪，然后依次判断每一个字符是否相等，不相等时将第一个字符串裁剪。 12345678910111213141516171819202122class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' res = strs[0] for i in range(1, len(strs)): if len(res) &gt; len(strs[i]): res = res[:len(strs[i])] for j in range(len(res)): if res[j] != strs[i][j]: res = res[:j] break if res == '': return '' return res 30. 串联所有单词的子串题目描述给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1：1234567输入： s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。 示例 2：1234输入： s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[] 解题思路用一个Map记录words中每个单词出现的次数。遍历s，对于每一个位置进行判断。 12345678910111213141516171819202122232425262728293031323334class Solution(object): def findSubstring(self, s, words): """ :type s: str :type words: List[str] :rtype: List[int] """ if not s or not words: return [] wordBag = &#123;&#125; for x in words: wordBag[x] = wordBag.get(x, 0) + 1 wordLen, numWords = len(words[0]), len(words), totalLen = wordLen * numWords res = [] for i in range(len(s) - totalLen + 1): seen = wordBag.copy() #深拷贝 for j in range(i, i + totalLen, wordLen): curWord = s[j:j + wordLen] if curWord in wordBag: seen[curWord] -= 1 if seen[curWord] &lt; 0: seen[curWord] = float('-inf') # 避免 [0,-1,1] sum(seen.values()) == 0 的情况 break else: break if sum(seen.values()) == 0: res.append(i) return res 32. 最长有效括号题目描述给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1:123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2:123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 解题思路思路一：遍历每个位置为起点，将’(‘看成1， ‘)’看成-1，如果和为0说明是有效括号，判断长度，如果和为负数，则说明一定无法构成有效括号，因为左边一定会多了一个’)’。 Python超时，JavaAC。123456789101112131415161718class Solution(object): def longestValidParentheses(self, s): """ :type s: str :rtype: int """ res = 0 for i in range(len(s)): num = 0 for j in range(i, len(s)): num += 1 if s[j] == '(' else -1 if num == 0 and res &lt; j-i+1: res = j-i+1 elif num &lt; 0: break return res 12345678910111213141516171819202122class Solution &#123; public int longestValidParentheses(String s) &#123; char[] array = s.toCharArray(); int num = 0; int res = 0; for (int i = 0; i&lt;array.length; i++)&#123; num = 0; for (int j = i; j&lt;array.length; j++)&#123; int temp = array[j] == '('?1:-1; num += temp; if (num == 0 &amp;&amp; res &lt; j-i+1)&#123; res = j-i+1; &#125; else if (num&lt;0)&#123; break; &#125; &#125; &#125; return res; &#125;&#125; 思路2：动态规划新建一个dp数组，数组的每个位置表示包含该位置及之前的所有字符所形成的有效括号的长度。从第二个下标开始遍历，当S[i]=’)’及S[i-1]=’(‘，形成一个有效括号长度加2。当S[i]=’)’及S[i-1]=’)’，判断S[i-1]形成的有效括号的前一位是否为’(‘，即S[i-dp[i-1]-1]是否为’(‘，如果是，则S[i-dp[i-1]-1]=’(‘和S[i]=’)’之间为有效括号，长度为dp[i-1]+2，然后再加上i-dp[i-1]-1的前一位i-dp[i-1]-2所形成的的有效括号数dp[i-dp[i-1]-2]. 123456789101112131415161718192021222324class Solution(object): def longestValidParentheses(self, s): """ :type s: str :rtype: int """ if len(s) &lt;= 1: return 0 dp = [0] * len(s) res = 0 for i in range(1, len(s)): if s[i] == ')': if s[i - 1] == '(': dp[i] = dp[i - 2] + 2 if i - 2 &gt;= 0 else 2 res = max(res, dp[i]) else: if i - dp[i - 1] - 1 &gt;= 0 and s[i - dp[i - 1] - 1] == '(': dp[i] = dp[i - 1] + 2 if i - dp[i - 1] - 2 &gt;= 0: dp[i] += dp[i - dp[i - 1] - 2] res = max(res, dp[i]) return res 38. 报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。 11 被读作 “two 1s” (“两个一”）, 即 21。 21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:12输入: 1输出: &quot;1&quot; 示例 2:12输入: 4输出: &quot;1211&quot; 解题思路1234567891011121314151617181920212223class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return '1' pre = '1' for i in range(1, n): count = 1 res = '' for j in range(1, len(pre)): if pre[j] == pre[j-1]: count += 1 else: res += str(count) + pre[j-1] count = 1 res += str(count) + pre[-1] pre = res return res 44. 通配符匹配题目描述给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。12&apos;?&apos; 可以匹配任何单个字符。&apos;*&apos; 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明:12s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &apos;*&apos; 可以匹配任意字符串。 示例 3:12345输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &apos;?&apos; 可以匹配 &apos;c&apos;, 但第二个 &apos;a&apos; 无法匹配 &apos;b&apos;。 示例 4:12345输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &apos;*&apos; 可以匹配空字符串, 第二个 &apos;*&apos; 可以匹配字符串 &quot;dce&quot;. 示例 5:1234输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输出: false 解题思路参考 这道题通配符外卡匹配问题还是小有难度的，有特殊字符 ‘’ 和 ‘?’，其中 ‘?’ 能代替任何字符，‘’ 能代替任何字符串，注意跟另一道 Regular Expression Matching 正则匹配的题目区分开来。两道题的星号的作用是不同的，注意对比区分一下。这道题最大的难点，就是对于星号的处理，可以匹配任意字符串，简直像开了挂一样，就是说在星号对应位置之前，不管你s中有任何字符串，我大星号都能匹配你，主角光环啊。但即便叼如斯的星号，也有其处理不了的问题，那就是一旦p中有s中不存在的字符，那么一定无法匹配，因为星号只能增加字符，不能消除字符，再有就是星号一旦确定了要匹配的字符串，对于星号位置后面的匹配情况也就鞭长莫及了。所以p串中星号的位置很重要，用 jStar 来表示，还有星号匹配到s串中的位置，使用 iStart 来表示，这里 iStar 和 jStar 均初始化为 -1，表示默认情况下是没有星号的。然后再用两个变量i和j分别指向当前s串和p串中遍历到的位置。 开始进行匹配，若i小于s串的长度，进行 while 循环。若当前两个字符相等，或着p中的字符是问号，则i和j分别加1。若 p[j] 是星号，那么我们要记录星号的位置，jStar 赋为j，此时j再自增1，iStar 赋为i。若当前 p[j] 不是星号，并且不能跟 p[i] 匹配上，那么此时就要靠星号了，若之前星号没出现过，那么就直接跪，比如 s = “aa” 和 p = “c“，此时 s[0] 和 p[0] 无法匹配，虽然 p[1] 是星号，但还是跪。如果星号之前出现过，可以强行续一波命，比如 s = “aa” 和 p = “c”，当发现 s[1] 和 p[1] 无法匹配时，但是好在之前 p[0] 出现了星号，我们把 s[1] 交给 p[0] 的星号去匹配。至于如何知道之前有没有星号，这时就能看出 iStar 的作用了，因为其初始化为 -1，而遇到星号时，其就会被更新为i，那么我们只要检测 iStar 的值，就能知道是否可以使用星号续命。虽然成功续了命，匹配完了s中的所有字符，但是之后我们还要检查p串，此时没匹配完的p串里只能剩星号，不能有其他的字符，将连续的星号过滤掉，如果j不等于p的长度，则返回false，参见代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if p == "*": return True if p == '' and s == '': return True if p == '' or s == '': return False iStar, jStar = -1, -1 i, j = 0, 0 while i &lt; len(s): if j&lt;len(p) and (s[i] == p[j] or p[j] == '?'): i += 1 j += 1 elif j&lt;len(p) and p[j] == "*": iStar = i jStar = j j += 1 elif iStar &gt;= 0: iStar += 1 i = iStar j = jStar + 1 else: return False while j &lt; len(p) and p[j] == '*': j += 1 return j == len(p) 这道题也能用动态规划 Dynamic Programming 来解，写法跟之前那道题 Regular Expression Matching 很像，但是还是不一样。外卡匹配和正则匹配最大的区别就是在星号的使用规则上，对于正则匹配来说，星号不能单独存在，前面必须要有一个字符，而星号存在的意义就是表明前面这个字符的个数可以是任意个，包括0个，那么就是说即使前面这个字符并没有在s中出现过也无所谓，只要后面的能匹配上就可以了。而外卡匹配就不是这样的，外卡匹配中的星号跟前面的字符没有半毛钱关系，如果前面的字符没有匹配上，那么直接返回 false 了，根本不用管星号。而星号存在的作用是可以表示任意的字符串，当然只是当匹配字符串缺少一些字符的时候起作用，当匹配字符串p包含目标字符串s中没有的字符时，将无法成功匹配。 对于这种玩字符串的题目，动态规划 Dynamic Programming 是一大神器，因为字符串跟其子串之间的关系十分密切，正好适合DP这种靠推导状态转移方程的特性。那么先来定义dp数组吧，我们使用一个二维 dp 数组，其中 dp[i][j] 表示 s中前i个字符组成的子串和p中前j个字符组成的子串是否能匹配。大小初始化为 (m+1) x (n+1)，加1的原因是要包含 dp[0][0] 的情况，因为若s和p都为空的话，也应该返回 true，所以也要初始化 dp[0][0] 为 true。还需要提前处理的一种情况是，当s为空，p为连续的星号时的情况。由于星号是可以代表空串的，所以只要s为空，那么连续的星号的位置都应该为 true，所以我们现将连续星号的位置都赋为 true。然后就是推导一般的状态转移方程了，如何更新 dp[i][j]，首先处理比较 tricky 的情况，若p中第j个字符是星号，由于星号可以匹配空串，所以如果p中的前 j-1 个字符跟s中前i个字符匹配成功了（ dp[i][j-1] 为true）的话，那么 dp[i][j] 也能为 true。或者若p中的前j个字符跟s中的前i-1个字符匹配成功了（ dp[i-1][j] 为true ）的话，那么 dp[i][j] 也能为 true（因为星号可以匹配任意字符串，再多加一个任意字符也没问题）。若p中的第j个字符不是星号，对于一般情况，我们假设已经知道了s中前 i-1 个字符和p中前 j-1 个字符的匹配情况（即 dp[i-1][j-1] ），那么现在只需要匹配s中的第i个字符跟p中的第j个字符，若二者相等（s[i-1] == p[j-1] ），或者p中的第j个字符是问号（ p[j-1] == &#39;?&#39; ），再与上 dp[i-1][j-1] 的值，就可以更新 dp[i][j] 了，参见代码如下： 1234567891011121314151617181920212223242526272829class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if p == "*": return True if p == '' and s == '': return True if p == '' or s == '': return False dp = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[0][0] = True for j in range(1, len(p)+1): if p[j-1] == '*': dp[0][j] = dp[0][j-1] for i in range(1, len(s)+1): for j in range(1, len(p)+1): if p[j-1] == '*': dp[i][j] = dp[i][j-1] or dp[i-1][j] else: dp[i][j] = (s[i-1] == p[j-1] or p[j-1] == '?') and dp[i-1][j-1] return dp[-1][-1] 58. 最后一个单词的长度题目描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: &quot;Hello World&quot;输出: 5 解题思路库函数。123456789101112class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 s = s.split() return len(s[-1]) if s else 0 双指针，一个指向最后一个单词的末尾，一个指向最后一个单词的开头。1234567891011121314151617181920class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 left, right = 0, len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 left = right while left &gt;= 0 and s[left] != ' ': left -= 1 return right - left 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = &quot;Leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;Leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2：1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 151. 翻转字符串里的单词题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例:12输入: &quot;the sky is blue&quot;,输出: &quot;blue is sky the&quot;. 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 解题思路库函数1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return ' '.join(s.split()[::-1]) 自己写的。先将头尾的空格去掉，新建一个字符串，将单词字符加入，去掉多余的空格。 然后先将整个字符串翻转，在将每个单词翻转。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ if not s: return "" left = 0 while left &lt; len(s) and s[left] == ' ': left += 1 right = len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 s = s[left:right+1] newstring = '' i = 0 while i &lt; len(s): if s[i] != ' ': newstring += s[i] i += 1 else: newstring += ' ' while i &lt; len(s) and s[i] == ' ': i += 1 newstring = list(newstring) self.reverse(newstring, 0, len(newstring)) start, end = 0, 0 while end &lt; len(newstring): while end &lt; len(newstring) and newstring[end] != ' ': end += 1 self.reverse(newstring, start, end) start = end + 1 end = start return ''.join(newstring) def reverse(self, s, start, end): left, right = start, end-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 165. 比较版本号题目描述比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1:12输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;输出: -1 示例 2:12输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;输出: 1 示例 3:12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 示例 4：123输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5：123输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示： 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。 版本字符串不以点开始或结束，并且其中不会有两个连续的点。 解题思路先将两个版本号以’.’分隔为两个列表，然后按位比较，短的补零。1234567891011121314151617181920212223242526class Solution(object): def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ if not version1 or not version2: return 0 version1 = version1.split('.') version2 = version2.split('.') i = 0 while i &lt; len(version1) or i &lt; len(version2): v1 = version1[i] if i &lt; len(version1) else 0 v2 = version2[i] if i &lt; len(version2) else 0 if int(v1) &gt; int(v2): return 1 if int(v1) &lt; int(v2): return -1 i += 1 return 0 227. 基本计算器 II题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:12输入: &quot;3+2*2&quot;输出: 7 示例 2:12输入: &quot; 3/2 &quot;输出: 1 示例 3:12输入: &quot; 3+5 / 2 &quot;输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路用num保存上一个数字，用pre_op保存上一个操作符。当遇到新的操作符的时候，需要根据pre_op进行操作。乘除的优先级高于加减。所以有以下规则： 之前的运算符是+，那么需要把之前的数字num进栈，然后等待下一个操作数的到来。 之前的运算符是-，那么需要把之前的数字求反-num进栈，然后等待下一个操作数的到来。 之前的运算符是×，那么需要立刻出栈和之前的数字相乘，重新进栈，然后等待下一个操作数的到来。 之前的运算符是/，那么需要立刻出栈和之前的数字相除，重新进栈，然后等待下一个操作数的到来。 注意比较的都是之前的操作符和操作数，现在遇到的操作符是没有什么用的。 另外，坑爹的Python地板除。 参考 12345678910111213141516171819202122232425262728293031323334class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 stack = [] num = 0 pre_op = '+' for i in range(len(s)): if s[i] in '0123456789': num = num*10+int(s[i]) if i == len(s)-1 or s[i] in '+-*/': if pre_op == '+': stack.append(num) elif pre_op == '-': stack.append(-num) elif pre_op == '*': stack.append(stack.pop()*num) elif pre_op == '/': top = stack.pop() if top*num &lt; 0 and top % num != 0: stack.append(top // num + 1) else: stack.append(top // num) pre_op = s[i] num = 0 return sum(stack) 344. 反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2：12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题思路12345678class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ s[:] = s[::-1] 1234567891011121314class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left, right = left + 1, right - 1 return 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:12输入: &quot;hello&quot;输出: &quot;holle&quot; 示例 2:12输入: &quot;Leetcode&quot;输出: &quot;leotcede&quot; 说明:元音字母不包含字母”y”。 解题思路12345678910111213141516171819class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in 'aAeEiIoOuU': left += 1 while right &gt; left and s[right] not in 'aAeEiIoOuU': right -= 1 s[left], s[right] = s[right], s[left] left, right = left+1, right-1 return ''.join(s) 383. 赎金信题目描述给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 解题思路遍历ransomNote，如果不在magazine，返回False，如果在，删除magazine中对应的字符。 需要转成list才可以用remove。 12345678910111213141516171819202122class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if len(ransomNote ) == 0: return True if len(magazine) == 0: return False magazine = list(magazine) for x in ransomNote: if x not in magazine: return False else: magazine.remove(x) return True 385. 迷你语法分析器题目描述给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。 列表中的每个元素只可能是整数或整数嵌套列表 提示：你可以假定这些字符串都是格式良好的： 字符串非空字符串不包含空格字符串只包含数字0-9, [, - ,, ] 示例 1：123给定 s = &quot;324&quot;,你应该返回一个 NestedInteger 对象，其中只包含整数值 324。 示例 2：123456789给定 s = &quot;[123,[456,[789]]]&quot;,返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：1. 一个 integer 包含值 1232. 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 解题思路不太理解。参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def __init__(self, value=None):# """# If value is not specified, initializes an empty list.# Otherwise initializes a single integer equal to value.# """## def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def add(self, elem):# """# Set this NestedInteger to hold a nested list and adds a nested integer elem to it.# :rtype void# """## def setInteger(self, value):# """# Set this NestedInteger to hold a single integer equal to value.# :rtype void# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class Solution(object): def deserialize(self, s): """ :type s: str :rtype: NestedInteger """ if len(s) == 0: return NestedInteger() if s[0] != '[': return NestedInteger(int(s)) res = NestedInteger() numP, start = 0, 1 for i in range(1, len(s)): if (numP == 0 and s[i] == ',') or i == len(s)-1: if start &lt; i: res.add(self.deserialize(s[start:i])) start = i + 1 elif s[i] == '[': numP += 1 elif s[i] == ']': numP -= 1 return res 387. 字符串中的第一个唯一字符题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = &quot;Leetcode&quot;返回 0.s = &quot;loveLeetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路两次遍历 12345678910111213141516171819202122class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return -1 Dict = &#123;&#125; for x in s: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for i in range(len(s)): if Dict[s[i]] == 1: return i return -1 415. 字符串相加题目描述给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路123456789101112131415161718192021222324252627282930313233343536class Solution(object): def addStrings(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ midsum = [] num1, num2 = num1[::-1], num2[::-1] index = 0 while index &lt; len(num1) and index &lt; len(num2): midsum.append(ord(num1[index])-48 + ord(num2[index]) - 48) index += 1 if index == len(num1): for i in range(index, len(num2)): midsum.append(ord(num2[i]) - 48) else: for i in range(index, len(num1)): midsum.append(ord(num1[i]) - 48) res = '' plus = 0 for x in midsum: num = plus + x res = str(num % 10) + res plus = num // 10 if plus: res = str(plus) + res return res 434. 字符串中的单词数题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:12输入: &quot;Hello, my name is John&quot;输出: 5 解题思路12345678910class Solution(object): def countSegments(self, s): """ :type s: str :rtype: int """ s = s.split() return len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数学]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是数学相关题目题解总结。 [TOC] 2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路使用哨兵节点，设置进位carry，直接相加，当进位为1时加到下一位。 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next 第一次写的思路：先求和，在构建链表。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 num1, num2 = 0, 0 base = 1 while l1: num1 += l1.val * base base *= 10 l1 = l1.next base = 1 while l2: num2 += l2.val*base base *= 10 l2 = l2.next num = num1 + num2 if num == 0: root = ListNode(0) return root return self.helper(num) def helper(self, num): if num == 0: return None root = ListNode(num % 10) root.next = self.helper(num // 10) return root 7. 整数反转题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:1假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路123456789101112131415class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &lt; 0: x = -x flag = -1 res = 0 while x: res = res * 10 + x % 10 x = x // 10 return res * flag if -2**31 &lt;= res &lt;= 2**31-1 else 0 8. 字符串转换整数 (atoi)题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路一个一个条件判断。。。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def myAtoi(self, str): """ :type str: str :rtype: int """ if not str: return 0 i = 0 while i &lt; len(str) and str[i] == ' ': i += 1 if i == len(str) or str[i] not in '1234567890+-': return 0 flag = 1 if str[i] in '+-': if i == len(str)-1 or str[i+1] not in '1234567890': return 0 elif str[i] == '-': flag = -1 i = i+1 start = i end = start while end &lt; len(str) and str[end] in '1234567890': end += 1 res = flag*int(str[start:end]) if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 9. 回文数题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:1234输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶: 你能不将整数转为字符串来解决这个问题吗？ 解题思路1234567891011121314151617class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False xhat = 0 temp = x while temp: xhat = xhat*10 + temp % 10 temp //= 10 return x == xhat 12345678910111213141516171819class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) left, right = 0, len(x)-1 while left &lt; right: if x[left] != x[right]: return False left += 1 right -= 1 return True 12. 整数转罗马数字题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:12输入: 3输出: &quot;III&quot; 示例 2:12输入: 4输出: &quot;IV&quot; 示例 3:12输入: 9输出: &quot;IX&quot; 示例 4:123输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例 5:123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ if not num: return '' val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = '' for i in range(len(val)): while num &gt;= val[i]: res += st[i] num -= val[i] return res 13. 罗马数字转整数题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: &quot;III&quot;输出: 3 示例 2:12输入: &quot;IV&quot;输出: 4 示例 3:12输入: &quot;IX&quot;输出: 9 示例 4:123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920212223class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if not s: return 0 val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] Dict = &#123;'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 'IV':4,'I':1&#125; res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in Dict: res += Dict[s[i:i+2]] i += 2 else: res += Dict[s[i]] i += 1 return res 1234567891011121314151617181920212223242526class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] strs = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in strs: index = strs.index(s[i:i+2]) res += vals[index] i += 2 else: index = strs.index(s[i]) res += vals[index] i += 1 return res 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 43. 字符串相乘题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1:12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2:12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明：1234num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路按照乘法竖式计算，将num1和num2翻转，用num1中的每一个数和num2进行相乘，乘法过程中考虑进位和位数。 1234567891011121314151617181920212223class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ if num1 == '0' or num2 == '0': return '0' res = 0 for i, n1 in enumerate(num1[::-1]): carry = 0 temp = 0 for j, n2 in enumerate(num2[::-1]): multi = (ord(n1)-ord('0')) * (ord(n2)-ord('0')) carrytemp, val = multi//10, multi%10 temp += (val+carry) * (10**j) carry = carrytemp temp += carry * (10**len(num2)) res += temp * (10**i) return str(res) 二刷。 123456789101112131415161718192021222324252627282930class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ num1, num2 = num1[::-1], num2[::-1] temp = [0]*(len(num1)+len(num2)) for i in range(len(num1)): for j in range(len(num2)): temp[i+j] += (ord(num1[i])-ord('0')) * (ord(num2[j])-ord('0')) res = [] for i in range(len(temp)): digit = temp[i] % 10 carry = temp[i] // 10 if i &lt; len(temp)-1: temp[i+1] += carry res.insert(0, str(digit)) i = 0 while i&lt;len(res)-1 and res[i] == '0': i += 1 res = res[i:] return ''.join(res) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public String multiply(String num1, String num2) &#123; if (num1.length()==0 || num2.length()==0) return "0"; int[] tempMulti = new int[(num1.length()+num2.length())]; num1 = new StringBuffer(num1).reverse().toString(); num2 = new StringBuffer(num2).reverse().toString(); for (int i=0; i&lt;num1.length(); i++)&#123; for (int j=0; j&lt;num2.length(); j++)&#123; tempMulti[i+j] += (num1.charAt(i)-'0') * (num2.charAt(j)-'0'); &#125; &#125; StringBuilder res = new StringBuilder(); int car =0; for (int i:tempMulti)&#123; int temp = (i+car)%10; res.insert(0, temp); car = (i+car) / 10; &#125; int index = 0; while (index &lt; res.length()-1 &amp;&amp; res.charAt(index) == '0') index ++; String ans = res.substring(index); return (res.length()==0)?"0":ans; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); String res = sol.multiply("0", "0"); System.out.print(res); &#125;&#125; 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：123456&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明：12给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:12输入: n = 3, k = 3输出: &quot;213&quot; 示例 2:12输入: n = 4, k = 9输出: &quot;2314&quot; 解题思路以n=4, k=9为例，初始化k=k-1=8。 最高位可取数字为[1,2,3,4]，每一个取值都有3!=6种取法，那么第9个下标为k//(n-1)!=8//6=1，即2，可取数字删去2更新为[1,3,4]，k=k%(n-1)!=2； 次高位可取数字为[1,3,4]，每一个取值都有2!=2种取法，那么第九个下标为k//(n-1-1)!=2//2=1,即3，可取数字删去3更新为[1,4]，k=k%(n-1-1)!=0； 第三位可取数字为[1,4]，每一个取值都有1!=1中取法，那么第九个下标为k//(n-1-1-1)!=0//1=0，即1，可取数字删去1更新为[4]，k=k%(n-1-1-1)=0; 第四位为[4]。 123456789101112131415161718192021222324252627class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' num = [str(i) for i in range(1, n+1)] fact = [1] * n for i in range(1, n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' res = '' k = k-1 for i in range(n): index = k // fact[n-1-i] res += num[index] num.pop(index) k = k % fact[n-1-i] return res 66. 加一题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路数九。从最后一位开始遍历，若当前遍历的值为9，则置为0；如果不是9，则当前位加1跳出循环；最后判断最高位是否为0，若为0，则需要在增加数组长度，即在最高位之前插入1。 123456789101112131415161718192021class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] for i in range(len(digits))[::-1]: if digits[i] == 9: digits[i] = 0 continue else: digits[i] += 1 break if digits[0] == 0: digits.insert(0, 1) return digits 采用进位。初始化进位为0，首先对最后一位加1操作，从后向前遍历，当当前位加上进位等于10时，将改为置0，进位置1，如小于10，则将进位置0，跳出循环。 1234567891011121314151617181920212223242526class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] pos = len(digits)-1 carry = 0 digits[-1] += 1 while pos &gt;= 0: digits[pos] += carry if digits[pos] &gt;= 10: digits[pos] -= 10 carry = 1 else: carry = 0 break pos -= 1 if carry: digits.insert(0, 1) return digits 一刷。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] temp = 0 for x in digits: temp = temp*10 + x temp += 1 res = [] while temp: res.insert(0, temp%10) temp //= 10 return res 67. 二进制求和题目描述给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 解题思路设置当前位和plus，从后向前遍历，将每一位(plus%2)加入到结果中，将进位(plus//2)赋给下一次迭代位和plus。 1234567891011121314151617181920212223242526class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ res = '' carry = 0 m, n, plus = len(a)-1, len(b)-1, 0 i, j = m, n res = '' while i &gt;= 0 or j &gt;= 0 or plus: if i &gt;= 0: plus += int(a[i]) i -= 1 if j &gt;= 0: plus += int(b[j]) j -= 1 res = str(plus%2) + res plus //= 2 return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:12输入: 4输出: 2 示例 2:1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路二分查找。 12345678910111213141516171819202122class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x &lt;= 1: return x left, right = 1, x while left &lt;= right: mid = left + (right-left)//2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2:12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3:12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 解题思路先处理分子，分母为零，负数的情况。然后使用字典将余数保存起来，当余数不为零时，在结果后加小数位数，当余数重复出现时，找到最开始重复的位置，加括号返回。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ if denominator == 0: return '' if numerator == 0: return '0' res = '' if numerator*denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) remainder = numerator % denominator if remainder == 0: return res res += '.' Dict = &#123;&#125; Dict[remainder] = len(res) while remainder: remainder *= 10 res += str(remainder // denominator) remainder %= denominator if remainder in Dict: start = Dict[remainder] res = res[:start] + '(' + res[start:] + ')' break else: Dict[remainder] = len(res) return res 168. Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如，123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1:12输入: 1输出: &quot;A&quot; 示例 2:12输入: 28输出: &quot;AB&quot; 示例 3:12输入: 701输出: &quot;ZY&quot; 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def convertToTitle(self, n): """ :type n: int :rtype: str """ res = '' while n: if n % 26 == 0: res = 'Z' + res n -= 26 else: res = chr(n % 26 -1 + ord('A')) + res n -= n % 26 n //= 26 return res 171. Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如，12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1:12输入: &quot;A&quot;输出: 1 示例 2:12输入: &quot;AB&quot;输出: 28 示例 3:12输入: &quot;ZY&quot;输出: 701 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 base = 1 for x in s[::-1]: res += (ord(x) - ord('A') + 1) * base base *= 26 return res 123456789101112class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 for x in s: res = res*26 + (ord(x) - ord('A') + 1) return res 172. 阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1:123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2:123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 6!=[123456]，其中25才有0，所以可以抛开其他数据，只看2,5出现的次数； 10!=[12345678910]，有2,5组成的有2,4(22),5,6(23),8(222),10(25)，一个2和一个5配对产生一个0，所以有两个配对有两个0。由于2一定比5多，只对5计数就可以了。 123456789101112class Solution(object): def trailingZeroes(self, n): """ :type n: int :rtype: int """ res = 0 while n: n //= 5 res += n return res 202. 快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例:1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路12345678910111213141516171819202122232425262728class Solution(object): def isHappy(self, n): """ :type n: int :rtype: bool """ if n == 0: return False if n == 1: return True seen = [n] while n != 1: lastN = n nextN = 0 while lastN: nextN += (lastN % 10) ** 2 lastN //= 10 n = nextN if n in seen: return False seen.append(n) return True 204. 计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路超时12345678910111213141516171819202122class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = 0 for i in range(2, n): flag = 1 for j in range(2, i): if i % j == 0: flag = 0 break if flag: res += 1 return res 厄拉多塞筛法.比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推. 首先生成了一个全部为1的列表 res= [1] * n 因为0和1不是质数,所以列表的前两个位置赋值为0 res[0],res[1] = 0,0 此时从index = 2开始遍历,res[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引,全部赋值为0.此时res[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推. 123456789101112131415161718class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = [1] * n res[0], res[1] = 0, 0 for i in range(2, int(n**0.5)+1): if res[i] == 1: res[i*i:n:i] = [0] * len(res[i*i:n:i]) return sum(res) 223. 矩形面积题目描述在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例:12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 解题思路分两种情况，第一种是不重叠，第二种重叠123456789101112131415161718class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): """ :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int """ if E &gt;= C or A &gt;= G or F &gt;= D or B &gt;= H: return (C-A)*(D-B) + (G-E)*(H-F) else: return (C-A)*(D-B) + (G-E)*(H-F) - (min(G,C)-max(A,E)) * (min(D,H)-max(B,F)) 231. 2的幂题目描述12345678910111213141516给定一个整数，编写一个函数来判断它是否是 2 的幂次方。示例 1:输入: 1输出: true解释: 20 = 1示例 2:输入: 16输出: true解释: 24 = 16示例 3:输入: 218输出: false 解题思路2的幂的二进制中只有一位是1.12345678910111213141516171819class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False res = 0 while n: if n &amp; 1: res += 1 if res &gt;= 2: return False n &gt;&gt;= 1 return True 2的幂的数 n和(n-1)相与一定是0，不为0则不是2的幂 如8(0000 1000) &amp; 7 (0000 0111) ==024(0001 1000) &amp; 23 (0001 0111) != 0 1234567891011class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False return n&amp;(n-1) == 0 258. 各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例:123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路暴力12345678910111213141516171819class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num while num &gt;= 10: lastn = num nextn = 0 while lastn: nextn += lastn % 10 lastn //= 10 num = nextn return num 余9法。1234567891011假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。 参考1234567891011121314class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num if num % 9 == 0: return 9 else: return num % 9 263. 丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:123输入: 6输出: true解释: 6 = 2 × 3 示例 2:123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3:123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明：121 是丑数。2 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路不断的除5,3,2，最后为1则为丑数 12345678910111213141516class Solution(object): def isUgly(self, num): """ :type num: int :rtype: bool """ if num == 0: return False for x in [5,3,2]: while num and num % x == 0: num //= x if num == 1: return True return False 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路1234567891011121314151617181920212223242526class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 dp = [0] * (n) dp[0] = 1 t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp[i] = min(dp[t2]*2, dp[t3]*3, dp[t5]*5) if dp[t2]*2 == dp[i]: t2 += 1 if dp[t3]*3 == dp[i]: t3 += 1 if dp[t5]*5 == dp[i]: t5 += 1 return dp[-1] 313. 超级丑数题目描述编写一段程序来查找第 n 个超级丑数。 超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。 示例:123输入: n = 12, primes = [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 说明:12341 是任何给定 primes 的超级丑数。 给定 primes 中的数字以升序排列。0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。第 n 个超级丑数确保在 32 位有符整数范围内。 解题思路123456789101112131415161718192021222324252627class Solution(object): def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ if n &lt;= 1: return n dp = [0] * n dp[0] = 1 t = [0] * len(primes) for i in range(1, n): temp = float('inf') for j in range(len(t)): temp = min(temp, dp[t[j]]*primes[j]) dp[i] = temp for j in range(len(t)): if temp == dp[t[j]]*primes[j]: t[j] += 1 return dp[-1] 319. 灯泡开关题目描述初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例:123456789输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 解题思路暴力超时。1234567891011121314151617181920class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 if n &lt;= 3: return 1 dp = [1] * n for i in range(1, n): for i in range(i, n, i+1): dp[i] *= -1 return dp.count(1) 数学法。开平方？12345678class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ return int(n**0.5) 326. 3的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27输出: true示例 2: 输入: 0输出: false示例 3: 输入: 9输出: true示例 4: 输入: 45输出: false进阶：你能不使用循环或者递归来完成本题吗？ 解题思路1234567891011121314class Solution(object): def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 0: return False while n % 3 == 0: n //= 3 return n == 1 365. 水壶问题题目描述有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空示例 1: (From the famous “Die Hard” example)12输入: x = 3, y = 5, z = 4输出: True 示例 2:12输入: x = 2, y = 6, z = 5输出: False 解题思路1234567891011121314151617这是一道脑筋急转弯题，我想很多人以前应该听过这道题目，有一个容量为3升和一个容量为5升的水罐，问我们如何准确的称出4升的水。我想很多人都知道怎么做，先把5升水罐装满水，倒到3升水罐里，这时5升水罐里还有2升水，然后把3升水罐里的水都倒掉，把5升水罐中的2升水倒入3升水罐中，这时候把5升水罐解满，然后往此时有2升水的3升水罐里倒水，这样5升水罐倒出1升后还剩4升即为所求。这个很多人都知道，但是这道题随意给我们了三个参数，问有没有解法，这就比较难了。这里我就照搬网上大神的讲解吧：这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为x和y，问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么我们可以用一个公式来表达：z = m * x + n * y其中m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即3升的水罐往外倒了两次水，5升水罐往里舀了两次水。那么问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立。根据裴蜀定理，ax + by = d的解为 d = gcd(x, y)，那么我们只要只要z % d == 0，上面的等式就有解，所以问题就迎刃而解了，我们只要看z是不是x和y的最大公约数的倍数就行了，别忘了还有个限制条件x + y &gt;= z，因为x和y不可能称出比它们之和还多的水，参见代码如下；时间复杂度很小，但是不会算，空间复杂度是O(1). 参考 123456789101112131415161718class Solution(object): def canMeasureWater(self, x, y, z): """ :type x: int :type y: int :type z: int :rtype: bool """ return z == 0 or (x+y &gt;= z and z % self.gcd(x, y) == 0) def gcd(self, x, y): res = x % y while res != 0: x, y = y, res res = x % y return y 367. 有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：12输入：16输出：True 示例 2：12输入：14输出：False 解题思路二分搜索12345678910111213141516171819202122class Solution(object): def isPerfectSquare(self, num): """ :type num: int :rtype: bool """ if num == 0: return False left, right = 1, int(num**0.5)+1 while left &lt;= right: mid = left + (right-left)//2 if mid*mid == num: return True elif mid*mid &gt; num: right = mid-1 else: left = mid+1 return False 372. 超级次方题目描述你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1:12输入: a = 2, b = [3]输出: 8 示例 2:12输入: a = 2, b = [1,0]输出: 1024 解题思路二分求幂123456789101112131415161718192021class Solution(object): def superPow(self, a, b): """ :type a: int :type b: List[int] :rtype: int """ res = 1 for n in b: res = self.pow(res, 10) * self.pow(a, n) % 1337 return res def pow(self, x, n): if x == 1 or n == 0: return 1 if n % 2: return self.pow(x, n-1) * x % 1337 else: return self.pow(x*x%1337, n//2) % 1337 396. 旋转函数题目描述给定一个长度为 n 的整数数组 A 。 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：1F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。 计算F(0), F(1), …, F(n-1)中的最大值。 注意:可以认为 n 的值小于 105。 示例:12345678A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。 解题思路看了数据规模是10^5，可以知道时间复杂度是O(N)量级，这就难办了。我们为了找规律，先把具体的数字抽象为A,B,C,D，那么我们可以得到：123456789101112F(0) = 0A + 1B + 2C +3DF(1) = 0D + 1A + 2B +3CF(2) = 0C + 1D + 2A +3BF(3) = 0B + 1C + 2D +3A 那么，我们通过仔细观察，我们可以得出下面的规律：123456789F(1) = F(0) + sum - 4DF(2) = F(1) + sum - 4CF(3) = F(2) + sum - 4B 那么我们就找到规律了,1F(i) = F(i-1) + sum - n * A[n-i]， 是个递推公式。我们最后求的是这个所有F(i)中的最大值。 时间复杂度是O(N)，空间复杂度是O(1). 参考12345678910111213141516class Solution(object): def maxRotateFunction(self, A): """ :type A: List[int] :rtype: int """ sumA = sum(A) f = sum(i*A[i] for i in range(len(A))) res = f for i in range(1, len(A)): f = f + sumA - len(A)*A[-i] res = max(res, f) return res 397. 整数替换题目描述给定一个正整数 n，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。n 变为 1 所需的最小替换次数是多少？ 示例 1:12345678输入:8输出:3解释:8 -&gt; 4 -&gt; 2 -&gt; 1 示例 2:12345678910输入:7输出:4解释:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1或7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 解题思路思路1：递归，速度很慢1234567891011121314151617class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n &lt;= 1: return 0 if n == 2: return 1 if n % 2 == 0: return 1 + self.integerReplacement(n//2) else: return 1 + min(self.integerReplacement(n-1), self.integerReplacement(n+1)) 思路2：位运算，速度很快当n是偶数时，直接除2；当n是奇数时，-1还是+1？奇数二进制数一定是01或者11结尾，如果把一个奇数化为4的倍数，变成1的步骤会更少（3除外）：15-&gt;16-&gt;8-&gt;4-&gt;2-&gt;115-&gt;14-&gt;7-&gt;6-&gt;3-&gt;2-&gt;1 因此：如果结尾是01，减1，如果结尾时11，加1，3的时候直接减1。 1234567891011121314151617181920212223class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 res = 0 while n &gt; 1: res += 1 if n % 2 == 0: n &gt;&gt;= 1 else: if n &amp; 2 and n != 3: n += 1 else: n -= 1 return res 400. 第N个数字题目描述在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1:12345输入:3输出:3 示例 2:12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 解题思路一位数字有9个，有9位；2位数字有9*10=90个，有2*90=180位；3位数字有9*100=900个，有3*900=2700位； 首先找到n是几位数字，然后找到n是所在位数的第几个数字，最后求在这个数字的第几位上。 1234567891011121314151617181920212223class Solution(object): def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt;= 9: return n bitlen = 1 count = 9 start = 1 while n &gt; bitlen*count: n -= bitlen*count bitlen += 1 count *= 10 start *= 10 res = start + (n-1) // bitlen return str(res)[(n-1) % bitlen] 892. 三维形体的表面积题目描述在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： **输入：**[[2]] **输出：**10 示例 2： **输入：**[[1,2],[3,4]] **输出：**34 示例 3： **输入：**[[1,0],[0,2]] **输出：**16 示例 4： **输入：**[[1,1,1],[1,0,1],[1,1,1]] **输出：**32 示例 5： **输入：**[[2,2,2],[2,1,2],[2,2,2]] **输出：**46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 解题思路对矩阵进行遍历，分别求每个位置的表面积，当某个位置垒了n（n&gt;0）个正方体，则其表面积为4*n+2 (四个侧面+上下两个面)，如果其前面或者上面有立方体存在，则会产生重叠，需要减去，重叠部分为两者较矮的那堆立方体个数乘以2。 1234567891011121314151617181920class Solution(object): def surfaceArea(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] &gt; 0: res += 4*grid[i][j] + 2 if i &gt; 0: res -= min(grid[i][j], grid[i-1][j]) * 2 if j &gt; 0: res -= min(grid[i][j], grid[i][j-1]) * 2 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数组]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是数组相关题目题解总结。 [TOC] 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415161718class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt;= 1: return False Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i return False 4. 寻找两个有序数组的中位数题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。123456789101112示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解题思路 复杂度$O(log(m + n))$方法待续。。。 归并排序。复杂度为$O((m+n)log(m+n))$，不符合。 1234567891011121314151617181920212223242526272829class Solution(object): def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ if len(nums1) == 0 and len(nums2) == 0: return 0 res = [] i, j = 0, 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] &lt; nums2[j]: res.append(nums1[i]) i += 1 else: res.append(nums2[j]) j += 1 if i != len(nums1): res.extend(nums1[i:]) else: res.extend(nums2[j:]) if len(res) % 2: return res[len(res)//2] else: return (res[len(res)//2-1] + res[len(res)//2]) / 2.0 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 31. 下一个排列题目描述解题思路先找到从后面开始数第一个降序的位置，在将这个位置之后的数字翻转，然后遍历翻转的部分数字，最后交换这个降序数字和后面第一个比他大的数。12345678910111213141516171819202122class Solution(object): def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums) &lt; 2: return index = len(nums) - 2 while index &gt;= 0: if nums[index] &lt; nums[index+1]: #从后找到第一个降序数字 break index -= 1 nums[index+1:] = nums[index+1:][::-1] #将降序数字后面的数字翻转 for i in range(index+1, len(nums)): if nums[i] &gt; nums[index]: #在翻转的数字中找到第一个大于降序数字的 nums[i], nums[index] = nums[index], nums[i] #交换 break 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public void nextPermutation(int[] nums) &#123; if (nums.length &lt;= 1) return; int index = nums.length-1; while (index &gt;= 1)&#123; if(nums[index] &gt; nums[index-1]) break; index --; &#125; reverse(nums, index, nums.length-1); if (index == 0) return; for (int i=index; i&lt;nums.length; i++)&#123; if (nums[i] &gt; nums[index-1])&#123; swap(nums, i, index-1); break; &#125; &#125; return; &#125; public void reverse(int[] nums, int start, int end)&#123; while (start &lt; end)&#123; swap(nums, start, end); start ++; end --; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;3,2,1&#125;; sol.nextPermutation(nums); for (int i = 0; i &lt; nums.length; i++) System.out.print(nums[i]); &#125;&#125; 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 41. 缺失的第一个正数题目描述给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1:12输入: [1,2,0]输出: 3 示例 2:12输入: [3,4,-1,1]输出: 2 示例 3:12输入: [7,8,9,11,12]输出: 1 说明:你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 解题思路从第一个位置开始，让每个数字放在自己应该在的位置上，终止条件为一旦发现该位置的数字不应该出现在数组中（&lt;=0或&gt;len(nums)），则终止交换。然后遍历数组，将第一个不符合要求的数字输出。 123456789101112131415161718class Solution(object): def firstMissingPositive(self, nums): """ :type nums: List[int] :rtype: int """ for i in range(len(nums)): while nums[i] &gt; 0 and nums[i] &lt;= len(nums) and nums[i] != nums[nums[i]-1]: temp = nums[nums[i]-1] nums[nums[i]-1] = nums[i] nums[i] = temp # nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i] 这样交换错误 for i in range(len(nums)): if nums[i] != i+1: return i+1 return len(nums)+1 42. 接雨水题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路求最高点处的索引，从左往最高点遍历，从右往最高点遍历遍历过程以初始点为最高点，当遇到比其低的点，则说明可以接水，接水量为两者之差，当遇到比其高的点，则更新当前最高点。1234567891011121314151617181920212223242526272829303132class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if len(height) &lt; 3: return 0 maxIndex = 0 for i in range(1, len(height)): if height[i] &gt; height[maxIndex]: maxIndex = i res = 0 curMax = height[0] for i in range(1, maxIndex): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] curMax = height[-1] for i in range(len(height)-2, maxIndex, -1): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] return res 48. 旋转图像题目描述给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路1234567891011121314class Solution(object): def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ # 先沿着左上右下的对角线翻转 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] #在翻转每一行 for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 54. 螺旋矩阵题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2:1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路从左到右，从上到下，从右到左，从下到上，循环。123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if len(matrix) == 0: return [] top, buttom = 0, len(matrix)-1 left, right = 0, len(matrix[0])-1 res = [] while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1, buttom+1): res.append(matrix[i][right]) if top &lt; buttom: # 当top==buttom时，最后为一行，前面已经从左到右遍历过，不需重复遍历 for i in range(right-1, left-1, -1): res.append(matrix[buttom][i]) if left &lt; right: # 当left == right时， 最后为一列，前面已经从上到下遍历过了，不需重复遍历 for i in range(buttom-1, top, -1): res.append(matrix[i][left]) top, buttom = top+1, buttom-1 left, right = left+1, right-1 return res 59. 螺旋矩阵 II题目描述给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ if n == 0: return [] if n == 1: return [[1]] matrix = [[0]*n for i in range(n)] top, buttom = 0, n-1 left, right = 0, n-1 val = 1 while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): matrix[top][i] = val val += 1 for i in range(top+1, buttom+1): matrix[i][right] = val val += 1 if top &lt; buttom: for i in range(right-1, left-1, -1): matrix[buttom][i] = val val += 1 if left &lt; right: for i in range(buttom-1, top, -1): matrix[i][left] = val val += 1 top, buttom = top+1, buttom-1 left, right = left+1, right-1 return matrix 73. 矩阵置零题目描述给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1:123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2:123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路O(m+n)12345678910111213141516171819202122class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = [False] * len(matrix) col = [False] * len(matrix[0]) # 找出0的位置 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: row[i] = True col[j] = True # 将0所在的行和列置0 for i in range(len(matrix)): for j in range(len(matrix[0])): if row[i] or col[j]: matrix[i][j] = 0 将0所在的行或列的其他位置置为’#’，然后替换成0123456789101112131415161718192021222324class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ if len(matrix) == 0: return for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): if matrix[i][k] != 0: matrix[i][k] = '#' for k in range(len(matrix)): if matrix[k][j] != 0: matrix[k][j] = '#' for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == '#': matrix[i][j] = 0 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在每个while循环中，先将开头重复的和结尾重复的去掉。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: val = nums[left] while left &lt; right and nums[left+1] == val: left += 1 val = nums[right] while left &lt; right and nums[right-1] == val: right -= 1 mid = left + (right-left)//2 if nums[mid] == target: return True elif nums[mid] &lt; nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 118. 杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路12345678910111213141516171819202122class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(2, numRows+1): pre = res[-1] temp = [] i = 0 while i &lt; len(pre)-1: temp.append(pre[i]+pre[i+1]) i += 1 res.append([1]+temp+[1]) return res 119. 杨辉三角 II题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路123456789101112131415161718class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ if rowIndex == 0: return [1] res = [1] for i in range(2, rowIndex+2): temp = [] for i in range(len(res)-1): temp.append(res[i]+res[i+1]) res = [1]+temp+[1] return res 189. 旋转数组题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1:123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解题思路切片，拼接1234567891011121314class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return nums k = k%len(nums) nums[:] = nums[-k:]+nums[:-k] 先把所有的翻转，然后在对0~k和k~n分别进行翻转。12345678910111213141516171819202122class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return k = k%len(nums) self.reverse(nums, 0, len(nums)-1) self.reverse(nums, 0, k-1) self.reverse(nums, k, len(nums)-1) def reverse(self, nums, left, right): while left &lt; right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路双指针 123456789101112131415161718192021222324class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = float('inf') left, right = 0, 0 while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res!=float('inf') else 0 216. 组合总和 III题目描述找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2:12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0 or n &gt; 45: return [] nums = [x for x in range(1, 10)] res = [] self.dfs(nums, [], 0, k, n, res) return res def dfs(self, nums, path, index, k, target, res): if k == 0 and target == 0 and path: res.append(path) return for i in range(index, len(nums)): if nums[i] &gt; target: return self.dfs(nums, path+[nums[i]], i+1, k-1, target-nums[i], res) 217. 存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题思路12345678910111213class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 1: return False set1 = set(nums) return len(set1) != len(nums) 219. 存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1:12输入: nums = [1,2,3,1], k = 3输出: true 示例 2:12输入: nums = [1,0,1,1], k = 1输出: true 示例 3:12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路123456789101112131415161718192021class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ if len(nums) &lt;= 0 or k &lt;= 0: return False Dict = &#123;&#125; for i in range(len(nums)): if nums[i] not in Dict: Dict[nums[i]] = i else: if i - Dict[nums[i]] &lt;= k: return True Dict[nums[i]] = i return False 228. 汇总区间题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:123输入: [0,1,2,4,5,7]输出: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:123输入: [0,2,3,4,6,8,9]输出: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 解题思路1234567891011121314151617181920212223class Solution(object): def summaryRanges(self, nums): """ :type nums: List[int] :rtype: List[str] """ if len(nums) == 0: return [] res = [] i = 0 while i &lt; len(nums): j = i while j &lt; len(nums)-1 and nums[j+1] == nums[j]+1: j += 1 if i == j: res.append(str(nums[i])) else: res.append(str(nums[i])+'-&gt;'+str(nums[j])) i = j+1 return res 229. 求众数 II题目描述给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1:12输入: [3,2,3]输出: [3] 示例 2:12输入: [1,1,1,3,3,2,2,2]输出: [1,2] 解题思路1234567891011121314151617181920212223class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in set(nums): if Dict[x] &gt; len(nums)//3: res.append(x) return res 238. 除自身以外数组的乘积题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 解题思路123456789101112131415161718192021class Solution(object): def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] res = [1]*len(nums) for i in range(1, len(nums)): res[i] = res[i-1]*nums[i-1] temp = 1 for i in range(len(nums)-2, -1, -1): temp *= nums[i+1] res[i] *= temp return res 268. 缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:12输入: [3,0,1]输出: 2 示例 2:12输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路123456789101112131415class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = len(nums) for i in range(len(nums)): res ^= nums[i]^i return res 283. 移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路12345678910111213141516class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. """ if len(nums) &lt;= 1: return index = 0 for i in range(len(nums)): if nums[i] != 0: nums[index] = nums[i] index += 1 nums[index:] = [0] * (len(nums)-index) 287. 寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:12输入: [1,3,4,2,2]输出: 2 示例 2:12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路123456789101112131415161718192021class Solution(object): def findDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[fast] slow = nums[slow] return fast 289. 生命游戏题目描述根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例:1234567891011121314输入: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]输出: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] 进阶: 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def gameOfLife(self, board): """ :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. """ if len(board) == 0: return Live = [] Dead = [] for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: if self.judgeLive(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) else: if self.judgeDead(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) for pair in Live: board[pair[0]][pair[1]] = 1 for pair in Dead: board[pair[0]][pair[1]] = 0 def judgeLive(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if 2&lt;=count&lt;=3 else False def judgeDead(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if count==3 else False 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.keyIndex = &#123;&#125;#记录键、下标对 self.indexKey = &#123;&#125;#记录下标、键对 self.len = 0#记录长度，便于随机返回元素 def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ #插入时，分别对两个哈希表都进行插入，同时len+1 if val not in self.keyIndex: self.len += 1 self.keyIndex[val] = self.len self.indexKey[self.len] = val return True return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ #删除时将index_key中键为len的覆盖到键为key_index[val]，然后删除键为len的；key_index操作类似。最后len-1 if val in self.keyIndex: self.indexKey[self.keyIndex[val]] = self.indexKey[self.len] self.keyIndex[self.indexKey[self.len]] = self.keyIndex[val] self.indexKey.pop(self.len) self.keyIndex.pop(val) self.len -= 1 return True return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return self.indexKey[random.randint(1, self.len)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 381. O(1) 时间插入、删除和获取随机元素 - 允许重复题目描述设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。 remove(val)：当 val 存在时，从集合中移除一个 val。 getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例:1234567891011121314151617181920// 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection();// 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2);// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom();// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1);// getRandom 应有相同概率返回 1 和 2 。collection.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class RandomizedCollection(object): def __init__(self): """ Initialize your data structure here. """ self.data = [] def insert(self, val): """ Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.data: self.data.append(val) return True else: self.data.append(val) return False def remove(self, val): """ Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool """ if val not in self.data: return False else: self.data.remove(val) return True def getRandom(self): """ Get a random element from the collection. :rtype: int """ return random.choice(self.data)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 414. 第三大的数题目描述给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2:12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路123456789101112131415161718192021222324class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) s1, s2, s3 = float('-inf'), float('-inf'), float('-inf') for num in nums: if num &gt; s1: s1, s2, s3 = num, s1, s2 elif num &lt; s1 and num &gt; s2: s2, s3 = num, s2 elif num &lt; s2 and num &gt; s3: s3 = num return s3 if s3 != float('-inf') else max(s1, s2) 442. 数组中重复的数据题目描述给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例：12345输入:[4,3,2,7,8,2,3,1]输出:[2,3] 解题思路12345678910111213141516171819class Solution(object): def findDuplicates(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) &lt;= 1: return [] res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res 448. 找到所有数组中消失的数字题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路123456789101112131415161718192021class Solution(object): def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1] *= -1 res = [] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i+1) return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 双指针]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是双指针相关题目题解总结。 [TOC] 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 28. 实现strStr()题目描述实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1:12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路123456789101112131415161718class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if len(needle) == 0: return 0 if len(haystack) == 0 or len(haystack) &lt; len(needle): return -1 for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 80. 删除排序数组中的重复项 II题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) left = 0 for n in nums: if left &lt; 2 or n &gt; nums[left-2]: nums[left] = n left += 1 return left 88. 合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出:[1,2,2,3,5,6] 解题思路 从尾向前遍历，设置两个指针p1和p2遍历数组，p1，p2分别从m-1和n-1开始向前遍历； 每一次遍历将大的元素放到nums1后面（最后一位为m-n+1），并向前移动一步，直到一个数组先遍历完成； 若nums1首先遍历完成，则需要将nums2剩下的元素放到nums1的前面。 123456789101112131415161718192021222324252627class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ if len(nums1)&lt; m+n: return False p1,p2 = m-1,n-1 point = m+n-1 while p1&gt;= 0 and p2 &gt;= 0: if nums1[p1]&lt;nums2[p2]: nums1[point] = nums2[p2] p2 -= 1 else: nums1[point] = nums1[p1] p1 -= 1 point -= 1 if p2 &gt;= 0: nums1[:p2+1] = nums2[:p2+1]if __name__ == '__main__': result = Solution().merge([1,2,3,0,0,0],3,[2,5,6],3) print(result) 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 141. 环形链表题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用双指针，一个一次走两步，另一个一次走一步，若有环，则必然相遇。 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始， 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2。 解题思路使用两个指针left和right，left指向数组第一个元素并从头向后遍历，right指向数组最后一个元素并从尾向前遍历： 如果两个指针指向元素之和numbers[left]+numbers[right] == target, 则返回 [left+1,right+1]，结束； 如果两个指针指向元素之和numbers[left]+numbers[right] &gt; target，则right -= 1； 如果两个指针指向元素之和numbers[left]+numbers[right] &lt; target，则left += 1。 12345678910111213141516171819202122class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt; 2: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().twoSum([2,7,11,15], 9) print(result) 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路123456789101112131415161718192021class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt;= 1: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return [] 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路12345678910111213141516171819class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ left, right = 0, 0 res = float('inf') while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res != float('inf') else 0 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “Leetcode”输出: “leotcede” 说明: 元音字母不包含字母”y”。 解题思路元音字母有五个：aAeEIioOuU。使用双指针，left从头向后遍历，right从后向前遍历，分别找到元音字母时时进行一次交换。 1234567891011121314151617181920212223class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ vowels = 'aAeEiIoOuU' s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in vowels: left += 1 while right &gt; left and s[right] not in vowels: right -= 1 if left &lt; right: s[left],s[right] = s[right], s[left] left += 1 right -= 1 return ''.join(s)if __name__ == '__main__': result = Solution().reverseVowels("Leetcode") print(result) 524. 通过删除字母匹配到字典里最长单词题目描述给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例 1: 输入:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出:“apple” 示例 2: 输入:s = “abpcplea”, d = [“a”,”b”,”c”]输出:“a” 说明: 所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 解题思路先把d中元素排序，以长度为主，字典序为辅；然后遍历d中字符串，依此判断是否满足条件，满足条件则返回；因为经过了排序，第一个满足条件的可以保证返回长度最长且字典顺序最小的字符串。 123456789101112131415161718192021222324252627282930313233class Solution(object): def findLongestWord(self, s, d): """ :type s: str :type d: List[str] :rtype: str """ if len(d) == 0 or len(s) == 0: return '' d = sorted(d, key=lambda x: (-len(x), x)) res = '' for x in d: if self.judge(s,x): return x return '' def judge(self,s,x): if len(s) &lt; len(x): return False p1,p2 = 0, 0 while p1 &lt; len(s) and p2 &lt; len(x): if s[p1] == x[p2]: p1 += 1 p2 += 1 else: p1 += 1 if p2 == len(x): return True return Falseif __name__ == '__main__': result = Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) print(result) 633. 平方数之和题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1： 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 解题思路假设\(a=0\)，则 \(b=\sqrt{c}\)，则最大整数为 \(\sqrt{c}\)，设置两个指针，left指向0并向前遍历，right指向\(\sqrt{c}\)并向后遍历： 如果 left*left+right*right = c， 返回True,结束； 如果 left*left+right*right &gt; c， right -= 1； 如果 left*left+right*right &lt; c， left += 1； 123456789101112131415161718192021class Solution(object): def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ if c &lt; 0: return False left, right = 0, int(pow(c,1.0/2)) while left &lt;= right: if left*left+right*right == c: return True elif left*left+right*right &gt; c: right -= 1 else: left += 1 return Falseif __name__ == '__main__': result = Solution().judgeSquareSum(6) print(result) 680. 验证回文字符串 Ⅱ题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意： 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路使用双指针，找到第一个不相等的位置后，去除left或着right后判断是否成为回文。 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): """ :type s: str :rtype: bool """ left, right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return self.isPalindrome(s[:left]+s[left+1:]) or self.isPalindrome(s[:right]+s[right+1:]) left += 1 right -= 1 return True def isPalindrome(self,s): left ,right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == '__main__': result = Solution().validPalindrome("aba") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 排序]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是排序相关题目题解总结。 [TOC] 排序快速排序用于求解 Kth 问题，使用快速排序的partition()进行实现，需要首先打乱数组，否则最坏情况下时间复杂度为O(N^2)。 堆排序用于求解 TopK 问题，通过维护一个大小为K的堆，堆中的元素就是TopK elements； 堆排序也可以用于求解 Kth 问题，堆顶元素就是 Kth elements； 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements； 因此快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 56. 合并区间题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 将区间按起始元素排序，新建返回res数组，遍历所有区间； 若res为空或res中最后一个区间的结束元素小于当前区间的起始元素，则无需合并，直接将该区间添加到res中；若res中最后一个区间的结束元素大于当前区间的起始元素，则需要合并，将res最后区间的结束元素置为原来的值与当前区间结束值的最大值。 1234567891011121314151617181920# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ intervals = sorted(intervals, key=lambda x:x.start) res = [] for t in intervals: if not res or res[-1].end &lt; t.start: res.append(t) else: res[-1].end = max(res[-1].end,t.end) return res 57. 插入区间题目描述给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 解题思路12345678910111213141516171819202122class Solution(object): def insert(self, intervals, newInterval): """ :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] """ cur = 0 res = [] while cur &lt; len(intervals) and intervals[cur][1] &lt; newInterval[0]: res.append(intervals[cur]) cur += 1 while cur &lt; len(intervals) and intervals[cur][0] &lt;= newInterval[1]: newInterval[0] = min(intervals[cur][0], newInterval[0]) newInterval[1] = max(intervals[cur][1], newInterval[1]) cur += 1 res.append(newInterval) while cur &lt; len(intervals): res.append(intervals[cur]) cur += 1 return res 123456789101112131415161718class Solution(object): def insert(self, intervals, newInterval): """ :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] """ intervals.append(newInterval) intervals = sorted(intervals, key = lambda x:x[0]) res = [intervals[0]] for i in range(1, len(intervals)): if intervals[i][0] &lt;= res[-1][1]: res[-1][1] = max(intervals[i][1], res[-1][1]) else: res.append(intervals[i]) return res 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 147. 对链表进行插入排序题目描述对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。 示例 1： 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路插入排序：插入排序的实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），用指针 head 逐一向后遍历 申请一个 dummyHead 节点，其下一个节点指向头结点。如果要在头结点出插入，dummyHead 会给我们带来便利； 当 head 的值不大于下一节点值，就进行遍历下一节点； 当 head 的值大于下一节点，那么就将 head 的下一节点取出，从前向后扫描，在第一个比它的值大的节点之前插入该节点。 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: temp = head.next q = dummy head.next = head.next.next while q.next and q.next.val &lt; temp.val: q = q.next temp.next = q.next q.next = temp return dummy.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head and head.next: if head.val &lt;= head.next.val: head = head.next else: pre = dummy while pre.next and pre.next.val &lt;= head.next.val: pre = pre.next temp = head.next head.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路使用归并排序，使用快慢指针找到中间结点后进行递归。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Nonehead = ListNode(4)head.next = ListNode(2)head.next.next = ListNode(1)head.next.next.next = ListNode(3)class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None # left = self.sortList(leftHead) # right = self.sortList(rightHead) # sortMerge = self.merge(left,right) # return sortMerge return self.merge(self.sortList(leftHead),self.sortList(rightHead)) def getmiddle(self,head): if not head: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self,leftHead,rightHead): dummyNode = ListNode(0) dummyHead = dummyNode i,j = leftHead, rightHead while i and j: if i.val &lt; j.val: dummyNode.next = i i = i.next else: dummyNode.next = j j = j.next dummyNode = dummyNode.next if i: dummyNode.next = i if j: dummyNode.next = j return dummyHead.nextif __name__ == '__main__': result = Solution().sortList(head) while result: print(result.val,end = ' ') result = result.next 179. 最大数题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2]输出: 210 示例 2: 输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路两层循环遍历，每一个数和之后的每一个数进行比较，交换大的数放在前面；两个数谁应该放在前面：拼接两个字符串进行比较 a+b&gt;b+a，则a在前面。 1234567891011121314151617class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ if len(nums) == 0: return '0' if len(nums) == 1: return str(nums[0]) for i in range(len(nums)-1): for j in range(i+1, len(nums)): if str(nums[i])+str(nums[j]) &lt; str(nums[j])+str(nums[i]): nums[i], nums[j] = nums[j], nums[i] return '0' if nums[0] == 0 else ''.join([str(x) for x in nums]) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路思路1：利用堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质；即子结点的键值或索引总是小于（或者大于）它的父节点。 通常堆是通过一维数组来实现的。在起始数组为 0 的情形中 父节点i的左子节点在位置 (2i+1)；父节点i的右子节点在位置 (2i+2)；子节点i的父节点在位置 floor((i-1)/2)。 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作 最大堆调整（Min_Heapify）：将堆的末端子结点作调整，使得子结点永远小于父结点；创建最大堆（Build_Min_Heap）：将堆所有数据重新排序;注：堆排序不是一种稳定排序。 用小根堆得办法寻找最大的K个数 用容量为K的最小堆来存储最大的K个数。最小堆的堆顶元素就是最大K个数中的最小的一个；每次扫描一个数据X，如果X比堆顶元素Y小，则不需要改变原来的堆。如果X比堆顶元素大；那么用X替换堆顶元素Y，在替换之后，X可能破坏了最小堆的结构，需要调整堆来维持堆的性质；调整过程时间复杂度为O(logK)。 全部的时间复杂度为O(N*logK)；这种方法当数据量比较大的时候，比较方便。因为对所有的数据只会遍历一次。 堆排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k,len(nums)+1): if change: for j in range(k//2,-1,-1): self.adjust(res,j,k) for j in range(k-1,0,-1): res[j],res[0] = res[0],res[j] self.adjust(res,0,j) change = False if i != len(nums) and nums[i] &gt; res[k-1]: res[k-1] = nums[i] change = True return res[k-1] def adjust(self,res,parent,length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1]&lt;res[child]: child = child+1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = tempif __name__ == '__main__': result = Solution().findKthLargest([3,2,3,1,2,4,5,5,6],4) print(result) 思路2：利用快速排序 快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：分割左边都是比它小的数，右边都是比它大的数。 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，因此达到整个数据变成有序序列。 举例：nums = [3,2,1,5,6,4] 首先以nums[0]=3为基准点，设置指针left指向第一个元素(0)，right指向最后一个元素(len(nums)-1)； 从右至左偏移right指针，寻找到第一个比基准点3小的元素，将该元素(这里为1)赋给left指针所指的位置，此时数组为[1,2,1,5,6,4]; 从左至右偏移left指针，寻找到第一个比基准点3大的元素，将该元素赋给right指针所指的位置，此时数组 不断循环步骤一二，知道left和right重合，将基准点3赋给重合位置，一轮排序结束数组为[1,2,3,5,6,4]; 经过递归过程，最后排序结束。 **快速排序1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left 思路3：归并排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = self.dfs(nums) return res[-k] def dfs(self, nums): if len(nums) &lt;= 1: return nums mid = len(nums)//2 left = self.dfs(nums[:mid]) right = self.dfs(nums[mid:]) return self.merge(left, right) def merge(self, left, right): res = [] i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 if i &lt; len(left): res += left[i:] else: res += right[j:] return res 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 451. 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 分治算法]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是分治算法相关题目题解总结。 [TOC] 分治算法基本概念分治法字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或者更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。如快速排序，归并排序。 基本思想及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治法的策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 分治法使用场景分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题； 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑使用贪心法或者动态规划法； 第四条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可以使用分治法，但一般动态规划较好。 分治法的基本步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 分治法的应用二分搜索大整数乘法Strassen矩阵乘法棋盘覆盖合并排序快速排序线性时间选择最接近点对问题循环赛日程表汉诺塔 二分搜索 二分搜索的要求：线性表为有序表，并且要用向量作为表的存储结构； 二分搜索得基本思想：先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录位置。1234567891011121314151617class Solution(object): def searchRange(self, nums, key): """ :type nums: List[int] :type target: int :rtype: List[int] """ return self.bSearch(nums, 0, len(nums)-1,key) def bSearch(self, nums, left, right, key): mid = (left+right) // 2 if nums[mid] == key: return mid elif nums[mid] &gt; key: return self.bSearch(nums,left,mid-1,key) else: return self.bSearch(nums, mid+1,right,key) 汉诺塔从左到右 A B C 柱 大盘子在下, 小盘子在上, 借助B柱将所有盘子从A柱移动到C柱, 期间只有一个原则: 大盘子只能在小盘子的下面。求解思路： 当盘子只有一个的时候,只有一个动作 从 A 移动到 C 即结束； 当有N个盘子的时候, 中间的动作是从 A 移动到 C, 表示最下面的第N个盘子移动完毕； 中间动作之上都可以认为是: 从 A 移动到 B； 中间动作之下都可以认为是: 从 B 移动到 C。 12345678910class Solution(object): def move(self, n, a, b, c): if n == 1: print(a+&apos;-&gt;&apos;+c) else: self.move(n-1, a, c, b) print(a+&apos;-&gt;&apos;+ c) self.move(n-1, b, a, c)if __name__ == &apos;__main__&apos;: Solution().move(3,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) 参考https://www.cnblogs.com/xsyfl/p/6921687.htmlhttps://blog.csdn.net/not_guy/article/details/72823951 241. 为运算表达式设计优先级题目描述给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: “2-1-1”输出: [0, 2]解释:((2-1)-1) = 0(2-(1-1)) = 2 示例 2: 输入: “23-45”输出: [-34, -14, -10, -10, 10]解释:(2(3-(45))) = -34((23)-(45)) = -14((2(3-4))5) = -10(2((3-4)5)) = -10(((23)-4)5) = 10 解题思路如果字符串为数字直接返回；使用分治法，遍历字符串，当遇到运算符时，将字符串分为运算符前及运算符后两部分，根据运算符做相应运算。1234567891011121314151617181920212223242526272829class Solution(object): def diffWaysToCompute(self, input): &quot;&quot;&quot; :type input: str :rtype: List[int] &quot;&quot;&quot; if input.isdigit(): return [int(input)] res = [] for i in range(len(input)): if input[i] in &apos;+-*&apos;: left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) for j in left: for k in right: res.append(self.helper(j, k, input[i])) return res def helper(self, j, k, op): if op == &apos;+&apos;: return j + k elif op == &apos;-&apos;: return j - k elif op == &apos;*&apos;: return j * kif __name__ == &apos;__main__&apos;: result = Solution().diffWaysToCompute(&quot;2*3-4*5&quot;) print(result) 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 解题思路摩尔投票法 维护一个候选数candidate和计数器counter。遍历数组中所有的元素， 设当前的元素为x，若 counter = 0,则 candidate = x, counter = 1; 否则， 根据candidate 与x是否相等来更新counter（相等+1，不等-1）在遍历一次，判断候选数是否为合法的主元素。为什么这样做是对的呢？因为若在有解的情况下，一个元素y出现&gt;n/2次，那么要抵消掉它，必然也要有相同的元素才行，而总的元素才n个，也就是说元素y在这样的计数中不会被抵消。保证有解的情况最后的候选数就是主要元素。1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; candidate = 0 count = 0 for x in nums: if count == 0: count = 1 candidate = x elif x == candidate: count += 1 else: count -= 1 return candidateif __name__ == &apos;__main__&apos;: result = Solution().majorityElement([6,5,5]) print(result) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路 堆排序。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k, len(nums)+1): if change: for j in range(k//2, -1, -1): self.adjust(res, j, k) for j in range(k-1, 0, -1): res[j], res[0] = res[0], res[j] self.adjust(res, 0, j) change = False if i != len(nums) and nums[i] &gt; res[-1]: res[-1] = nums[i] change = True return res[-1] def adjust(self, res, parent, length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1] &lt; res[child]: child += 1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = temp 分治算法，这里使用快速排序算法。 通过一趟排序将要排序的数据分割成两个独立的两部分：左部分都是比它小的数，右部分都是比它大的数； 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，最终使整个数据变成有序序列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums[-k] def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 回溯算法]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是回溯算法相关题目题解总结。 [TOC] 回溯算法回溯算法属于DFS。在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。 普通DFS主要用于可达性问题，这种问题只需要执行到特定的位置然后返回即可； 而Backtracking主要用于求解排列组合问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。 Backtracking的基本思想是： 从一条路往前走，能进则进，不能进则退回来，换一条路再试。 八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。 回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。 回溯算法说白了就是穷举法。 因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素； 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。 17. 电话号码的字母组合题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路回溯。要求所有位置都要有字母，即组合的长度为数字的长度。 123456789101112131415161718192021class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] dic = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; res = [] self.dfs(digits, 0, '', dic, res) return res def dfs(self, digits, index, path, dic, res): if len(path) == len(digits): if path: res.append(path) return if digits[index] not in dic: return [] for j in dic[digits[index]]: self.dfs(digits, index+1, path+j, dic, res) 123456789101112131415161718192021222324252627class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] Dict = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; strs = [] for x in digits: strs.append(Dict[x]) res = [] self.dfs(strs, 0, '', res) return res def dfs(self, strs, index, path, res): if len(path) == len(strs): res.append(path) return for j in strs[index]: self.dfs(strs, index+1, path+j, res) 22. 括号生成题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解题思路回溯。如果左括号还有剩余，则放置左括号，如果有括号剩余数大于左括号，则可以放置有括号，停止条件为所有括号全部放置完。 12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n &lt;= 0: return [] res = [] self.dfs(n, n, '', res) return res def dfs(self, left, right, path, res): if left == 0 and right == 0: res.append(path) return if left &gt; 0: self.dfs(left-1, right, path+'(', res) if left &lt; right: self.dfs(left, right-1, path+')', res) 39. 组合总和题目描述给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题思路先进行排序在dfs。123456789101112131415161718192021class Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, start, templist, res): if residue == 0: res.append(templist) return for i in range(start, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i, templist+[candidates[i]], res) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Arrays;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates.length==0) return res; Arrays.sort(candidates); dfs(candidates, new ArrayList&lt;&gt;(), 0, target, res); return res; &#125; public void dfs(int[] candidates, List&lt;Integer&gt; path, int index, int target, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (target == 0 &amp;&amp; !(res.contains(path)))&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i&lt; candidates.length;i++)&#123; if (candidates[i] &gt; target)&#123; break; &#125; path.add(candidates[i]); dfs(candidates, path, i, target-candidates[i], res); path.remove(path.size() - 1); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;2,3,5&#125;; List&lt;List&lt;Integer&gt;&gt; res = sol.combinationSum(nums, 8); System.out.print(res); &#125;&#125; 40. 组合总和 II题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解题思路和39差不多，加判断条件防止res中出现重复项，调用时为i+1，防止重复的数字。12345678910111213141516171819202122class Solution(object): def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, index, templist, res): if residue == 0 and templist not in res: res.append(templist) return for i in range(index, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i+1, templist+[candidates[i]], res) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Arrays;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates.length==0) return res; Arrays.sort(candidates); dfs(candidates, new ArrayList&lt;&gt;(), 0, target, res); return res; &#125; public void dfs(int[] candidates, List&lt;Integer&gt; path, int index, int target, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (target == 0 &amp;&amp; !(res.contains(path)))&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i&lt; candidates.length;i++)&#123; if (candidates[i] &gt; target)&#123; break; &#125; path.add(candidates[i]); dfs(candidates, path, i+1, target-candidates[i], res); path.remove(path.size() - 1); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;2,3,5&#125;; List&lt;List&lt;Integer&gt;&gt; res = sol.combinationSum(nums, 8); System.out.print(res); &#125;&#125; 46. 全排列题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例:12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路12345678910111213141516171819202122class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(temp) == len(nums): res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(nums, new ArrayList&lt;&gt;(), res); return res; &#125; public void dfs(int[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (path.size() == nums.length)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i&lt;nums.length; i++)&#123; if (!(path.contains(nums[i])))&#123; path.add(nums[i]); dfs(nums, path, res); path.remove(path.size()-1); &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); List&lt;List&lt;Integer&gt;&gt; res = sol.permute(new int []&#123;1,2,3&#125;);// System.out.print(); &#125;&#125; 47. 全排列 II题目描述给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路123456789101112131415161718192021class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(nums) == len(temp) and temp not in res: res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, temp, res): if not nums and temp not in res: res.append(temp) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], temp+[nums[i]], res) 51. N皇后题目描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例:12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 解题思路N皇后定义：在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 回溯算法。建立一个nxn的全是点的数组，从第0行开始遍历。判断当前行是否已经超过矩阵范围，如果是，说明找到一种解法，加到res中。否则，遍历当前行的所有列的位置，对于每一个位置，判断当前位置是否会产生冲突（isValid，判断两条对角线和一个垂直线），若当前行找到一个没有冲突的位置，则对下一行进行递归查找。 12345678910111213141516171819202122232425262728293031323334353637383940import copyclass Solution(object): def solveNQueens(self, n): """ :type n: int :rtype: List[List[str]] """ res = [] queens = [['.'] * n for _ in range(n)] self.helper(0, queens, res) for queens in res: for i in range(len(queens)): queens[i] = ''.join(queens[i]) return res def helper(self, curRow, queens, res): if curRow == len(queens): res.append(copy.deepcopy(queens)) return for i in range(len(queens)): if self.isValid(queens, curRow, i): queens[curRow][i] = 'Q' self.helper(curRow + 1, queens, res) queens[curRow][i] = '.' def isValid(self, queens, row, col): for i in range(row): if queens[i][col] == 'Q': return False i, j = row - 1, col - 1 while i &gt;= 0 and j &gt;= 0: if queens[i][j] == 'Q': return False i, j = i - 1, j - 1 i, j = row - 1, col + 1 while i &gt;= 0 and j &lt; len(queens): if queens[i][j] == 'Q': return False i, j = i - 1, j + 1 return True 52. N皇后 II题目描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:1234567891011121314输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解题思路12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def totalNQueens(self, n): """ :type n: int :rtype: int """ self.res = 0 queens = [['.']*n for _ in range(n)] self.helper(0, queens) return self.res def helper(self, curRow, queens): if curRow == len(queens): self.res += 1 return for i in range(len(queens)): if self.isValid(queens, curRow, i): queens[curRow][i] = 'Q' self.helper(curRow+1, queens) queens[curRow][i] = '.' def isValid(self, queens, row, col): for i in range(row): if queens[i][col] == 'Q': return False i, j = row-1, col-1 while i &gt;= 0 and j &gt;= 0: if queens[i][j] == 'Q': return False i, j = i-1, j-1 i, j = row-1, col+1 while i &gt;= 0 and j &lt; len(queens): if queens[i][j] == 'Q': return False i, j = i-1, j+1 return True 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 解题思路所有元素共有 n! 种排列。根据下图对’1234’的全排列，按照第一个字符可以分为4组，按照第二个字符可以分为3组，按照第三个字符可以分为2组，所以一共有4x3x2种排列方式。 要得到第九个排列’2314’，转换为数组下标也就是8，在level 1 中下标为1，level 2 中下标为1，level 3 中下标为0。具体过程为： 最高位可以取{1,2,3,4}，并且每个数在最高位出现3!=6次，第9个排序的最高位下标为：8//3!=1，也就是2； 次位可以取{1,3,4}，并且每个数在次位出现2!=2次，第9个排序的最高位下标为：(8%6)//2!=1，也就是3; 第三位可以取{1,4},并且每个数在第三位出现1次，第9个排列的第三位取值下标为：(8%6%2)//1=0，也就是1； 最后一位只有一个数字4。 用ki表示在数组中的取值下标，n表示集合中数字个数： k = k-1，此步是关键 k1 = k//(n-1)! k = k%(n-1)! k2 = k//(n-2)! k = k%(n-2)! … kn-1 = k//1 参考文章1234567891011121314151617181920212223class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' fact = [1]*n for i in range(1,n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' k = k-1 res = '' num = [str(i) for i in range(1,n+1)] for i in range(n, 0, -1): index = k // fact[i-1] res += num[index] k = k % fact[i-1] num.pop(index) return res 77. 组合题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路回溯法，我们抽取第一个字符，然后从后面n-1个字符中抽取k-1个；抽取第二个字符，再从后面的n-2个字符抽出k-1. 12345678910111213141516171819202122class Solution(object): def combine(self, n, k): """ :type n: int :type k: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0: return [] res = [] self.dfs(range(1, n+1), k, [], res) return res def dfs(self, nums, k, path, res): if k &gt; len(nums): return if k == 0: res.append(path) return for i in range(len(nums)): self.dfs(nums[i+1:], k-1, path+[nums[i]], res) 78. 子集题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路12345678910111213141516class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [[]] res = [] self.dfs(nums, 0, res, []) return res def dfs(self, nums, index, res, path): res.append(path) for i in range(index, len(nums)): self.dfs(nums, i+1, res, path+[nums[i]]) 79. 单词搜索题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例:12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 解题思路Leetcode65题12345678910111213141516171819202122232425262728293031323334class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ if len(board) == 0: return False if len(word) == 0: return True visited = [[False]*len(board[0]) for i in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, word, i, j, 0, visited): return True return False def helper(self, board, word, i, j, pathlength, visited): if pathlength == len(word): return True curHaspath = False if 0&lt;=i&lt;len(board) and 0&lt;=j&lt;len(board[0]) and board[i][j] == word[pathlength] and not visited[i][j]: visited[i][j] = True pathlength += 1 curHaspath = self.helper(board,word,i+1,j,pathlength,visited) or self.helper(board,word,i-1,j,pathlength,visited) or self.helper(board,word,i,j+1,pathlength,visited) or self.helper(board,word,i,j-1,pathlength,visited) if not curHaspath: visited[i][j] = False pathlength -= 1 return curHaspath 89. 格雷编码题目描述格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路格雷码的生成过程：res[i] = i ^ (i//2)。如n = 3： res[0] = 0 = 000 res[1] = 1^(1//2) = 001^000 = 001 res[2] = 2^(2//2) = 010^001 = 011 res[3] = 3^(3//2) = 011^001 = 010 res[4] = 4^(4//2) = 100^010 = 110 res[5] = 5^(5//2) = 101^010 = 111 res[6] = 6^(6//2) = 110^011 = 101 res[7] = 7^(7//2) = 111^011 = 100 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] num = 1 for i in range(n): num *= 2 res = [0]*num while i &lt; num: res[i] = i ^ (i//2) i += 1 return res 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] res = [0]*(2**n) for i in range(len(res)): res[i] = i^(i//2) return res 90. 子集 II题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路123456789101112131415161718192021class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] nums.sort() res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, index, path, res): if path not in res: res.append(path) for i in range(index, len(nums)): if i &gt; index and nums[i] == nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) 93. 复原IP地址题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: “25525511135”输出: [“255.255.11.135”, “255.255.111.35”] 解题思路IP地址由四部分组成，每一部分的数字为0~255，使用回溯算法验证每一部分的数字大小,一部分数字做多为3位（range(1,4))，在使用完字符串中所有字符且当前IP地址为四部分时添加到结果中。每次dfs的时候都去检查一下所有的字符串的长度是不是能满足在最多4个3位数字组成。 123456789101112131415161718192021222324class Solution(object): def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ if not s or len(s) &lt; 4 or len(s) &gt; 12: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and len(temp) == 4: res.append('.'.join(temp)) return if len(temp) &gt;= 4 or len(s) &gt; (4-len(temp))*3: return for i in range(1, 4): if i &gt; len(s): continue number = int(s[:i]) if str(number) == s[:i] and number &lt;= 255: self.dfs(s[i:], temp + [s[:i]], res) 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 216. 组合总和 III题目描述找出所有相加之和为 n的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12**输入:*****k*** = 3, ***n*** = 7**输出:** [[1,2,4]] 示例 2:12**输入:*****k*** = 3, ***n*** = 9**输出:** [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if k == 0 or n == 0: return [] res = [] self.help(k, 1, n, [], res) return res def help(self, k, index, n, path, res): if k == 0: if n == 0: res.append(path) return for i in range(index, 10): if n - i &lt; 0: break self.help(k-1, i+1, n-i, path + [i], res)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 链表]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是链表相关题目题解总结。 [TOC] 链表2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路设置哨兵节点，每次新建节点保存当前位的值，并将进位给下一次迭代用。 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = ListNode(0) cur = dummy plus = 0 while l1 or l2 or plus: if l1: plus += l1.val l1 = l1.next if l2: plus += l2.val l2 = l2.next cur.next = ListNode(plus%10) plus //= 10 cur = cur.next return dummy.next 19. 删除链表的倒数第N个节点题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 解题思路新建伪结点，先让原指针走n步，寻找到删除的位置，然后一起遍历，原指针走到尾了，伪指针走到要删除节点的前一个，将伪指针的下一个节点跳过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head or n &lt; 0: return None dummy = ListNode(0) dummy.next = head pre = dummy for i in range(n): head = head.next while head: head = head.next pre = pre.next pre.next = pre.next.next return dummy.next 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public String toString() &#123; return "ListNode [val=" + val + "]"; &#125;&#125;class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy, slow = dummy; for (int i = 0; i &lt; n; i++)&#123; fast = fast.next; &#125; while (fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return dummy.next; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode ln1= new ListNode(1); ListNode ln2= new ListNode(2); ListNode ln3= new ListNode(3); ListNode ln4= new ListNode(4); ListNode ln5= new ListNode(5); ln1.next=ln2; ln2.next=ln3; ln3.next=ln4; ln4.next=ln5; ln5.next=null; Solution sol = new Solution(); ListNode res = sol.removeNthFromEnd(ln1, 2); while (res!=null) &#123; System.out.println(res.toString()); res = res.next; &#125; &#125;&#125; 21. 合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1: return l2 if not l2: return l1 dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val &lt; l2.val: pre.next = ListNode(l1.val) l1 = l1.next else: pre.next = ListNode(l2.val) l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next 23. 合并K个排序链表题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解题思路分治+归并1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; if len(lists) == 0: return None if len(lists) == 1: return lists[0] mid = len(lists) // 2 left = self.mergeKLists(lists[:len(lists)//2]) right = self.mergeKLists(lists[len(lists)//2:]) return self.merge(left, right) def merge(self, left, right): if not left: return right if not right: return left dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路设置头节点，向后遍历。 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while pre.next and pre.next.next: cur = pre.next pre.next = pre.next.next cur.next = cur.next.next pre.next.next = cur pre = pre.next.next return dummy.next 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public String toString() &#123; return "ListNode [val=" + val + "]"; &#125;&#125;class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head==null || head.next == null) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; while (pre!=null &amp;&amp; pre.next!=null &amp;&amp; pre.next.next!=null)&#123; ListNode Node = new ListNode(pre.next.val); Node.next = pre.next.next.next; pre.next = pre.next.next; pre.next.next = Node; pre = pre.next.next; &#125; return dummy.next; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode ln1= new ListNode(1); ListNode ln2= new ListNode(2); ListNode ln3= new ListNode(3); ListNode ln4= new ListNode(4); ListNode ln5= new ListNode(5); ln1.next=ln2; ln2.next=ln3; ln3.next=ln4; ln4.next=ln5; ln5.next=null; Solution sol = new Solution(); ListNode res = sol.swapPairs(ln1); while (res!=null) &#123; System.out.println(res.toString()); res = res.next; &#125; &#125;&#125; 25. K 个一组翻转链表题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 :12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路求出翻转的次数+对每一次进行反转 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseKGroup(self, head, k): &quot;&quot;&quot; :type head: ListNode :type k: int :rtype: ListNode &quot;&quot;&quot; if not head or not head.next or k &lt;= 1: return head length = 0 pre = head while pre: length += 1 pre = pre.next cycle = length // k dummy = ListNode(0) dummy.next = head pre = dummy for i in range(cycle): start, end = i*k, (i+1)*k-1 cur = pre.next for i in range(start, end): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp for i in range(k): pre = pre.next return dummy.next 61. 旋转链表题目描述给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题思路先求链表长度，当k&gt;length时，k对length求余，然后将链表后k个移到开头；使用快慢指针的方法找到后面k个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head length = 0 cur = head while cur: cur = cur.next length += 1 k = k % length if k == 0: return head fast, slow = head, head for i in range(k): fast = fast.next while fast.next: fast = fast.next slow = slow.next temp = slow.next slow.next = None fast.next = head # temp 就是结果，直接返回也可 head = temp return head 82. 删除排序链表中的重复元素 II题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2:12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解题思路要删除重复的节点，而头节点就有可能是重复的节点，因此新建头节点，同样的值略过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while head and head.next: if head.val != head.next.val: head = head.next pre = pre.next else: val = head.val while head and head.val == val: head = head.next pre.next = head return dummy.next 83. 删除排序链表中的重复元素题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2:12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路每次迭代判断当前节点和下一节点是否相等，若相等，该节点的下个节点等于下个节点的下个节点，相当于下个节点和当前节点相等，就跳过下个节点。 当当前节点和下一节点不相等时，当前节点往前走，判断下一节点。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head cur = head while cur.next: if cur.val == cur.next.val: cur.next = cur.next.next else: cur = cur.next return head 86. 分隔链表题目描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例:12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路用两个指针，分别保存比x小的及比x大的值，对原链表进行遍历根据值的大小拼接在相应的链表后面，最后在把两个链表拼接在一起就可以了。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) pre = dummy larger = ListNode(0) temp = larger while head: if head.val &lt; x: pre.next = head pre = pre.next else: node = ListNode(head.val) temp.next = node temp = temp.next head = head.next pre.next = larger.next return dummy.next 92. 反转链表 II题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy count = 1 while pre.next and count &lt; m: pre = pre.next count += 1 if count &lt; m: return head mNode = pre.next cur = mNode.next while cur and count &lt; n: Next = cur.next cur.next = pre.next pre.next = cur mNode.next = Next cur = Next count += 1 return dummy.next 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy for i in range(m-1): pre = pre.next cur = pre.next for i in range(n-m): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 109. 有序链表转换二叉搜索树题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路将链表转换为数组，然后构建二叉搜索树。 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ if not head: return None array = [] while head: array.append(head.val) head = head.next return self.helper(array) def helper(self, array): if len(array) == 0: return None mid = len(array)//2 root = TreeNode(array[mid]) root.left = self.helper(array[:mid]) root.right = self.helper(array[mid+1:]) return root 138. 复制带随机指针的链表题目描述给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深度拷贝。 解题思路首先复制label和next指针，然后复制random指针，最后拆分新旧链表。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def copyRandomList(self, head): """ :type head: RandomListNode :rtype: RandomListNode """ if not head: return head pre = head while pre: temp = pre.next pre.next = RandomListNode(pre.label) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next cur = res pre = head while pre: pre.next = pre.next.next if cur.next: cur.next = cur.next.next pre = pre.next cur = cur.next return res 二刷1234567891011121314151617181920212223242526272829303132333435363738394041"""# Definition for a Node.class Node(object): def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""class Solution(object): def copyRandomList(self, head): """ :type head: Node :rtype: Node """ if not head: return head pre = head while pre: temp = pre.next pre.next = Node(pre.val, None, None) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next pre = res while head: head.next = head.next.next if pre.next: pre.next = pre.next.next head = head.next pre = pre.next return res 141. 环形链表题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用快慢指针，如果有环一定相遇。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 142. 环形链表 II题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路快慢指针，找到换之后，一个指针从头遍历。 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: fast = head while fast != slow: fast = fast.next slow = slow.next return fast return None 集合。将访问过的节点保存起来，遍历节点，如果节点在字典中，则说明重复是为环的入口；否则没有环。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None Dict = set() while head: if head in Dict: return head Dict.add(head) head = head.next return None 143. 重排链表题目描述给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2:1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路 使用快慢指针先将链表从中间截断为两个链表，如果链表长度为奇数，则第一条链表长度多1；如1,2,3,4,5，拆分为1,2,3和4,5； 将第二条链表翻转；即4,5翻转为5,4 然后归并合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head or not head.next or not head.next.next: return fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next frontend = head backend = slow.next slow.next = None dummy = ListNode(0) dummy.next = backend cur = backend.next backend.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp backend = dummy.next p1 = frontend p2 = backend while p2: temp1 = p1.next temp2 = p2.next p1.next = p2 p2.next = temp1 p1 = temp1 p2 = temp2 147. 对链表进行插入排序题目描述对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2：12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路如果链表本来就是升序的，则往后遍历；否则如果一个节点的值小于前一个节点，寻找合适的位置插入。12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head while cur.next: if cur.val &lt; cur.next.val: cur = cur.next else: pre = dummy while pre.next and pre.next.val &lt; cur.next.val: pre = pre.next temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None left = self.sortList(leftHead) right = self.sortList(rightHead) return self.merge(left, right) def getmiddle(self, head): if not head or not head.next: return head fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self, left, right): dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 160. 相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1：123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路链表拼接 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None a, b = headA, headB while a or b: if not a: a = headB if not b: b = headA if a == b: return a a, b = a.next, b.next return None 第一次遍历，先计算两个链表的长度；第二次遍历，让长的先走长度差，然后同时移动，判断是否有相同节点。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None countA = countB = 0 a, b = headA, headB while a: a = a.next countA += 1 while b: b = b.next countB += 1 if countA &gt; countB: for i in range(countA-countB): headA = headA.next else: for i in range(countB-countA): headB = headB.next while headA and headB: if headA == headB: return headA headA, headB = headA.next, headB.next return None 206. 反转链表题目描述反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路迭代123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head return self.helper(head, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 234. 回文链表题目描述请判断一个链表是否为回文链表。 示例 1:12输入: 1-&gt;2输出: false 示例 2:12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None dummy = ListNode(0) dummy.next = right cur = right.next right.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp right = dummy.next while right: if right.val != left.val: return False right = right.next left = left.next return True 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True left, right = self.splitLink(head) right = self.reverseLink(right) while right: if right.val != left.val: return False right = right.next left = left.next return True def splitLink(self, head): fast, slow = head, head while fast and fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None return left, right def reverseLink(self, head): if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bosol """ if not head or not head.next: return True res = [] while head: res.append(head.val) head = head.next return res == res[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 哈希表]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是哈希表相关题目题解总结。 [TOC] 哈希表哈希表使用O(N)的空间复杂度存储数据，并且以O(1)的时间复杂度求解问题。 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i 3. 无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路使用字典保存字符最后一次出现的位置，如果这个字符在前面出现过，即这个区间已经有重复的字符了，需要更新左边界，移动到当前遍历字符在字典中保存的位置的下一个位置，同时更新当前字符的位置（右边界）。 123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 left = 0 Dict = &#123;&#125; for right in range(len(s)): if s[right] in Dict: left = max(left, Dict[s[right]]+1) Dict[s[right]] = right res = max(res, right-left+1) return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 36. 有效的数独题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 解题思路遍历每一个不为’.’的位置，将其值保存下来，并将其所在位置暂时替换为无关字符，然后判断其所在行、列和9宫格内是否重复，如果重复则直接返回，否则将其位置重新赋原来的值。1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False for x in range(len(board)): for y in range(len(board[0])): if board[x][y] == '.': continue val = board[x][y] board[x][y] = 'D' if not self.isValid(x, y, board, val): return False else: board[x][y] = val return True def isValid(self, x, y, board, val): for i in range(len(board)): if board[i][y] == val: return False for i in range(len(board[0])): if board[x][i] == val: return False for i in range(3): for j in range(3): if board[(x//3)*3+i][(y//3)*3+j] == val: return False return True 依次判断行、列和九宫格是否有重复的，使用set去重然后与没去重的比较长度。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False return self.isValidRow(board) and self.isValidCol(board) and self.isValidSpace(board) def isValidRow(self, board): for row in range(len(board)): temp = [board[row][col] for col in range(len(board[0])) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidCol(self, board): for col in range(len(board[0])): temp = [board[row][col] for row in range(len(board)) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidSpace(self, board): for i in range(0, len(board), 3): for j in range(0, len(board[0]), 3): temp = [] for row in range(3): for col in range(3): if board[row+i][col+j] != '.': temp.append(board[row+i][col+j]) if len(set(temp)) != len(temp): return False return True 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ for i in range(9): if not self.judge(board[i]): return False for i in range(9): temp = [] for j in range(9): temp.append(board[j][i]) if not self.judge(temp): return False for i in range(0,9,3): for j in range(0,9,3): temp = [] for row in range(3): for col in range(3): temp.append(board[row+i][col+j]) if not self.judge(temp): return False return True def judge(self, nums): Dict = &#123;&#125; for x in nums: if x == '.': continue if x in Dict: return False Dict[x] = 1 return True 37. 解数独题目描述编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。一个数独。答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 ‘.’ 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式的。 解题思路某个位置里放入的数字，必须不在其所在行，列及3x3宫内出现过，所以首先统计每行，列，宫内未出现的数字，则该位置只能填入该位置对应的行列宫都未出现的数字（即三者交集）。然后遍历数独，当遍历到需要’.’时，将该位置可能填入的数字（行列宫交集）逐一尝试，该位置填入数字，并将行列宫中的数字删除，如果填入的数字可以继续填入数字则返回True，否则填错了，将该位置恢复成’.’，并将行列宫中的被删除的数字恢复。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def solveSudoku(self, board): """ :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. """ nums = set([str(j) for j in range(1, 10)]) rows = [set([str(j) for j in range(1, 10)]) for i in range(9)] cols = [set([str(j) for j in range(1, 10)]) for i in range(9)] spaces = [set([str(j) for j in range(1, 10)]) for i in range(9)] for i in range(9): for j in range(9): n = (i//3)*3 + j//3 if board[i][j] != '.': rows[i].remove(board[i][j]) cols[j].remove(board[i][j]) spaces[n].remove(board[i][j]) self.dfs(board, rows, cols, spaces) def dfs(self, board, rows, cols, spaces): for i in range(9): for j in range(9): n = (i//3)*3 + j//3 intersection = rows[i]&amp;cols[j]&amp;spaces[n] if board[i][j] == '.': for item in intersection: board[i][j] = item rows[i].remove(item) cols[j].remove(item) spaces[n].remove(item) if self.dfs(board, rows, cols, spaces): return True board[i][j] = '.' rows[i].add(item) cols[j].add(item) spaces[n].add(item) return False return True 49. 字母异位词分组题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路遍历字符串，对字符串进行排序，使用字典将同样的字符串放在一起。 123456789101112131415161718192021222324class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ if len(strs) == 0: return [] Dict = &#123;&#125; for x in strs: temp = ''.join(sorted(x)) if temp not in Dict: Dict[temp] = [x] else: Dict[temp].append(x) # res = []# for val in Dict.values():# res.append(val) # return res return list(Dict.values()) 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2:12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3:12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 解题思路用字典保存余数及余数对应的结果的长度，当余数存在于字典中时，说明为循环小数，循环起始位字典中保存的位置。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ res = '' if numerator * denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) residue = numerator % denominator if residue == 0: return res res += '.' Dict = &#123;&#125; Dict[residue] = len(res) while residue: numerator = residue * 10 res += str(numerator // denominator) residue = numerator % denominator if residue not in Dict: Dict[residue] = len(res) else: start = Dict[residue] res = res[:start] + '(' + res[start:] + ')' break return res 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 解题思路12345678910111213141516class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 205. 同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1:12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 示例 2:12输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false 示例 3:12输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true 说明:你可以假设 s 和 t 具有相同的长度。 解题思路遍历数组，用哈希表保存s和t中的对应关系，当s[i]不在哈希表的key中，如果t[i]在哈希表的value中，则返回False，如ab和aa的情况，否则将s[i]—t[i]保存到哈希表中，当s[i]在哈希表的key中，检查对应的值是否和t[i]相等，如果不相等，则返回False。遍历完成最后返回True。 123456789101112131415161718192021222324class Solution(object): def isIsomorphic(self, s, t): """ :type s: str :type t: str :rtype: bool """ if s == t: return True if len(s) != len(t): return False Dict = &#123;&#125; for i in range(len(s)): if s[i] not in Dict: if t[i] in Dict.values(): return False Dict[s[i]] = t[i] else: if Dict[s[i]] != t[i]: return False return True 242. 有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1:12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2:12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路水123456789class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ return sorted(s) == sorted(t) 词频统计1234567891011121314151617181920212223class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(s) != len(t): return False scnt = [0] * 26 tcnt = [0] * 26 for i in range(len(s)): scnt[ord(s[i]) - 97] += 1 tcnt[ord(t[i]) - 97] += 1 for i in range(26): if scnt[i] != tcnt[i]: return False return True 274. H指数题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）” 示例:1234输入: citations = [3,0,6,1,5]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 解题思路好难理解。。。1234567891011121314151617class Solution(object): def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ if len(citations) == 0: return 0 maxi = len(citations) for x in sorted(citations):#假设h为N 那么所有的论文引用次数都大于等于N，如果存在引用次数小于N,h- if x &gt;= maxi: break else: maxi -= 1 return maxi 290. 单词模式题目描述给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。 这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。 示例1:12输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true 示例 2:12输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false 示例 3:12输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false 示例 4:12输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路分别将pattern和str分割，如果长度不一致则返回False 使用hash表，遍历pattern，依次保存pattern和str的映射关系 如果某个pattern[i]不存在hash表中，需要首先判断对应的str[i]是否已经在hash表中，如果在说明该str[i]已经被其他pattern占用，返回False; 如果某个pattern[i]已经在hash中，那么只需要判断当前对应的str[i]是否和保存起来的str是否一致即可。 12345678910111213141516171819202122232425class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ pattern = list(pattern) str = str.split() if len(pattern) != len(str): return False Dict = &#123;&#125; for i in range(len(pattern)): if pattern[i] not in Dict: if str[i] in Dict.values(): return False Dict[pattern[i]] = str[i] else: if str[i] != Dict[pattern[i]]: return False return True 299. 猜数字游戏题目描述你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1:12345输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;输出: &quot;1A3B&quot;解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2:12345输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;输出: &quot;1A1B&quot;解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 解题思路用hash表保存secret中数字重现的次数；定义两个变量，allmatch统计secret和guess中都出现的次数，另一个统计Bulls；然后遍历guess，如果当前字符在hash中出现过，说明这个字符在secret和guess都出现过，allmatch+=1，同时判断位置在这secret和guess的位置是否相同，相同Bulls+=1;最后Cows = allmatch - bulls。 12345678910111213141516171819202122232425262728293031class Solution(object): def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ if len(secret) != len(guess) or len(secret) == 0: return "" Dict = &#123;&#125; for c in secret: if c not in Dict: Dict[c] = 1 else: Dict[c] += 1 allmatch = 0 Bulls = 0 for i in range(len(guess)): if guess[i] in Dict and Dict[guess[i]] != 0: Dict[guess[i]] -= 1 allmatch += 1 if secret[i] == guess[i]: Bulls += 1 Cows = allmatch - Bulls return str(Bulls) + 'A' + str(Cows) + 'B' 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路hash统计，values降序，取前k个 123456789101112131415161718192021class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums) &lt; k or k &lt;= 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 Dict = sorted(Dict.items(), key = lambda item:-item[1]) return [Dict[i][0] for i in range(k)] 349. 两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。解题思路 123456789101112131415161718class Solution(object): def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] res = [] for x in nums2: if x in nums1 and x not in res: res.append(x) return res 350. 两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路先用hash表将nums1的数字和对应次数保存起来，遍历nums2，查看当前遍历元素是否在Dict中存在，且次数大于0,如果存在需要将Dict[x] -= 11234567891011121314151617181920212223242526class Solution(object): def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] Dict = &#123;&#125; for x in nums1: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in nums2: if x in Dict and Dict[x] != 0: res.append(x) Dict[x] -= 1 return res 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.keyIndex = &#123;&#125;#记录键、下标对 self.indexKey = &#123;&#125;#记录下标、键对 self.len = 0#记录长度，便于随机返回元素 def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ #插入时，分别对两个哈希表都进行插入，同时len+1 if val not in self.keyIndex: self.len += 1 self.keyIndex[val] = self.len self.indexKey[self.len] = val return True return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ #删除时将index_key中键为len的覆盖到键为key_index[val]，然后删除键为len的；key_index操作类似。最后len-1 if val in self.keyIndex: self.indexKey[self.keyIndex[val]] = self.indexKey[self.len] self.keyIndex[self.indexKey[self.len]] = self.keyIndex[val] self.indexKey.pop(self.len) self.keyIndex.pop(val) self.len -= 1 return True return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return self.indexKey[random.randint(1, self.len)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 389. 找不同题目描述给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例:123456789输入：s = &quot;abcd&quot;t = &quot;abcde&quot;输出：e解释：&apos;e&apos; 是那个被添加的字母。 解题思路123456789101112131415161718192021class Solution(object): def findTheDifference(self, s, t): """ :type s: str :type t: str :rtype: str """ if not t or len(s) &gt;= len(t): return '' s = list(s) for c in t: if c not in s: return c else: s.remove(c) return '']]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-红黑树]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 红黑树定义红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在$O(logn)$时间内做查找，插入和删除，这里的$n$是树中元素的数目。 红黑树性质红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。除二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1：节点是红色或黑色 性质2：根节点是黑色 性质3：所有叶子节点都是黑色（叶子是NIL节点） 性质4：每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 性质5.：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 注意： 性质3中的叶子节点，是只为空(NIL或null)的节点。 性质5确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，因而，红黑树是相对是接近平衡的二叉树。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。 红黑树示例： 红黑树的应用红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。 例如，Java集合中的TreeSet和TreeMap，C++的STL中的Set、Map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 红黑树基本操作左旋如上图所示，当在某个结点pivot上，做左旋操作时，我们假设它的右孩子Y不是NULL，pivot可以为任何不是NULL的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。 右旋如上图所示，当在某个结点pivot上，做右旋操作时，我们假设它的左孩子Y不是NULL，pivot可以为任何不是NULL的右子结点。右旋以Y到pivot之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的右孩子b则成为pivot的左孩子。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-位图]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%8D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 位图所谓bit-map就是用一个bit位来标记某个元素的value，而bit数组的下标是表示该元素，由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。位图通过使用位数组来表示已知范围内的某些元素是否存在，可进行数据的快速查找、判重、删除 举例：假设我们要对0~7内的5个元素（4,7,2,5,3）排序（这里假设这些元素没有重复），可以采用bit-map的方法来达到排序的目的，要表示8个数，我们就只需要8个bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有bit位都置为0，如下图：然后遍历这五个元素，首先第一个是4，那么就把4对应的位置5（从0开始）置1：然后在处理第二个元素7，将第8个位置置1，接着在处理第三个元素，一直到最后一个元素，处理完的bit位状态：现在我们遍历一遍bit区域，将该位是1的位的编号输出（2,3,4,5,7），这样就达到了排序的目的。 举例2：我们有1千万个整数，整数的范围在1到1亿之间。如何快速查找某个整数是否在这1千万个整数中呢？ 使用位图。我们申请一个大小为1亿、数据类型为布尔类型（true或者false）的数组。我们将这1千万个整数作为数组下标，将对应的数组值设置成true。比如，整数5对应下标为5的数组值设置为true，也就是array[5]=true。 当我们查询某个整数K是否在这1千万个整数中的时候，我们只需要将对应的数组值array[K]取出来，看是否等于true。如果等于true，那说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。 问题实例： 已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数8位最多99999999，大概需要99M个bit，大概10几M的内存即可，然后进行遍历将对应的位置1，统计位置上出现1的个数。 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置为0，则置1，如果是1，则置2，如果是2，则保持不变。最后统计位置上的值为1的个数。 实现网页爬虫中的URL去重功能同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？假设需要判重的网页有10亿，那我们可以用一个10倍大小的位图来存储，也就是100亿个二进制位，换算成字节，那就是大约1.2GB。（即布隆过滤器，因为该位图无法覆盖所有的网页，会出现误判冲突，布隆过滤器利用K个哈希函数实现有误判的位图，降低存储空间，提高效率。点击查看布隆过滤器） 应用适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下基本思想：使用bit数组表示某些元素是否存在。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库SQL实战题解]]></title>
    <url>%2F2019%2F07%2F10%2FLeetCode%2F%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E5%AE%9E%E6%88%98%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文为数据库SQL实战刷题笔记，刷题平台为牛客网。题量为61道。网站OJ编译器为sqlite3.7.9。 相关笔记：StudyNotes-MySQL必知必会 1 查找最晚入职员工的所有信息题目描述1234567891011121314查找最晚入职员工的所有信息CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT * FROM employeesWHERE hire_date = (SELECT MAX(hire_date) FROM employees); 123SELECT * FROM employeesORDER BY hire_date DESC LIMIT 0, 1; 2 查找入职员工时间排名倒数第三的员工所有信息题目描述1234567891011121314查找入职员工时间排名倒数第三的员工所有信息CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1; 123SELECT * FROM employees WHERE hire_date = (SELECT hire_date FROM employees ORDER BY hire_date DESC LIMIT 2,1); 3 查找当前薪水详情以及部门编号dept_no题目描述123456789101112131415161718查找各个部门当前(to_date=&apos;9999-01-01&apos;)领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary from_date to_date dept_no 解题思路123456SELECT s.*, d.dept_noFROM salaries as s INNER JOIN dept_manager as d ON s.emp_no = d.emp_noWHERE s.to_date=&apos;9999-01-01&apos; AND d.to_date=&apos;9999-01-01&apos;; 4 查找所有已经分配部门的员工的last_name和first_name题目描述12345678910111213141516171819查找所有已经分配部门的员工的last_name和first_nameCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_no 解题思路1234SELECT e.last_name, e.first_name, d.dept_noFROM employees AS e INNER JOIN dept_emp AS d ON e.emp_no = d.emp_no 5 查找所有员工的last_name和first_name以及对应部门编号dept_no题目描述12345678910111213141516171819查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_no 解题思路 INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。 LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。 RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。 1234SELECT e.last_name, e.first_name, d.dept_noFROM employees AS e LEFT JOIN dept_emp AS d ON e.emp_no = d.emp_no 6 查找所有员工入职时候的薪水情况题目描述12345678910111213141516171819查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary 解题思路 在测试数据中，salaries中的emp_no不唯一（因为号码为emp_no的员工会有多次涨薪的可能，所有在salaries中对应的记录不止一条）。 employees.emp_no唯一，即salaries的数据会多于employees。 123456# 利用INNER JOIN连接两张表SELECT e.emp_no, s.salaryFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC; 123456# 直接用逗号并列查询两张表SELECT e.emp_no, s.salaryFROM employees AS e, salaries AS sWHERE e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC; 7 查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t题目描述1234567891011查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数tCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no t 解题思路 用COUNT函数和GROUP BY语句可以统计同一emp_no值的记录条数。 用AS语句将COUNT(emp_no) 的值转换为t。 COUNT函数不可用WHERE语句，因此使用HAVING语句。 涨幅超过15次，salaries中相应的记录数应该超过16（从第2条记录开始算作第1次涨幅），不过题目为了简单起见，将第1条记录当作第1次涨幅，所以令t&gt;15即可。 注意： 严格来说，下一条salary高于本条才算涨幅，但本题只要出现了一条记录就算一次涨幅，salary相同可以理解为涨幅为0，salary变少理解为涨幅为负。 1234SELECT emp_no, COUNT(*) AS tFROM salariesGROUP BY emp_noHAVING t &gt; 15; 8 找出所有员工当前薪水salary情况题目描述1234567891011找出所有员工当前(to_date=&apos;9999-01-01&apos;)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:salary 解题思路1234SELECT DISTINCT salaryFROM salariesWHERE to_date = &apos;9999-01-01&apos;ORDER BY salary DESC; 9 获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’题目描述1234567891011121314151617获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=&apos;9999-01-01&apos;CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路1234567# 使用联结。SELECT d.dept_no, d.emp_no, s.salaryFROM dept_manager AS d INNER JOIN salaries AS s ON d.emp_no = s.emp_no AND d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;; 123456# 使用逗号并列查询SELECT d.dept_no, d.emp_no, s.salaryFROM dept_manager AS d, salaries AS sWHERE d.emp_no = s.emp_no AND d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;; 10 获取所有非manager的员工emp_no题目描述12345678910111213141516171819获取所有非manager的员工emp_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no 解题思路123SELECT emp_noFROM employeesWHERE emp_no NOT IN (SELECT emp_no FROM dept_manager); 12345SELECT e.emp_noFROM employees AS e LEFT OUTER JOIN dept_manager AS d ON e.emp_no = d.emp_noWHERE dept_no IS NULL; 11 获取所有员工当前的manager题目描述123456789101112131415161718获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=&apos;9999-01-01&apos;。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输入描述:无输出描述:emp_no manager_no 解题思路 要输出自己的经历，部门要相同 de.dept_no = dm.dept_no。 123456SELECT de.emp_no, dm.emp_noFROM dept_emp AS de, dept_manager AS dmWHERE de.dept_no = dm.dept_no AND de.to_date = &apos;9999-01-01&apos; AND dm.to_date = &apos;9999-01-01&apos; AND de.emp_no &lt;&gt; dm.emp_no; 1234567SELECT de.emp_no, dm.emp_noFROM dept_emp AS de INNER JOIN dept_manager AS dm ON de.dept_no = dm.dept_noWHERE de.to_date = &apos;9999-01-01&apos; AND dm.to_date = &apos;9999-01-01&apos; AND de.emp_no &lt;&gt; dm.emp_no; 12 获取所有部门中当前员工薪水最高的相关信息题目描述1234567891011121314151617获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salaryCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路 使用GROUP BY d.dept_no 将每个部门分为一组，用MAX函数选取每组中工资最高者 12345678SELECT d.dept_no, d.emp_no, MAX(s.salary) AS salaryFROM dept_emp AS d INNER JOIN salaries AS s ON d.emp_no = s.emp_noWHERE d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;GROUP BY d.dept_noORDER by d.dept_no; 1234567SELECT d.dept_no, d.emp_no, MAX(s.salary) AS salaryFROM dept_emp AS d, salaries AS sWHERE d.emp_no = s.emp_no AND d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;GROUP BY d.dept_noORDER by d.dept_no; 13 从titles表获取按照title进行分组题目描述12345678910从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title t 解题思路1234SELECT title, COUNT(*) AS tFROM titlesGROUP BY titleHAVING t &gt;= 2; 14 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略题目描述1234567891011从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title t 解题思路1234SELECT title, COUNT(DISTINCT emp_no) AS tFROM titles GROUP BY titleHAVING t &gt;= 2; 15 查找employees表题目描述12345678910111213查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路12345SELECT *FROM employeesWHERE emp_no % 2 = 1 AND last_name != &apos;Mary&apos;ORDER BY hire_date DESC; 16 统计出当前各个title类型对应的员工当前薪水对应的平均工资题目描述12345678910111213141516统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title avg 解题思路1234567SELECT t.title, Avg(s.salary)FROM titles AS t INNER JOIN salaries AS s ON t.emp_no = s.emp_noWHERE t.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;GROUP BY t.title; 123456SELECT t.title, Avg(s.salary)FROM titles AS t, salaries AS sWHERE t.emp_no = s.emp_no AND t.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;GROUP BY t.title; 17 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary题目描述1234567891011获取当前（to_date=&apos;9999-01-01&apos;）薪水第二多的员工的emp_no以及其对应的薪水salaryCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary 解题思路1234SELECT emp_no, salaryFROM salariesWHERE to_date=&apos;9999-01-01&apos;ORDER BY salary DESC LIMIT 1, 1; 18 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary，不准使用order题目描述12345678910111213141516171819查找当前薪水(to_date=&apos;9999-01-01&apos;)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order byCREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary last_name first_name 解题思路12345678SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_noWHERE s.to_date = &apos;9999-01-01&apos; AND s.salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date=&apos;9999-01-01&apos;); 123456SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_noWHERE s.to_date = &apos;9999-01-01&apos; AND s.salary &lt; (SELECT MAX(salary) FROM salaries); 19 查找所有员工的last_name和first_name以及对应的dept_name题目描述1234567891011121314151617181920212223查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_name 解题思路 第一次LEFT JOIN连接employees表与dept_emp表，得到所有员工的last_name和first_name以及对应的dept_no，也包括暂时没有分配部门的员工 第二次LEFT JOIN连接上表与departments表，即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工 123SELECT e.last_name, e.first_name, d.dept_nameFROM (employees AS e LEFT JOIN dept_emp AS de ON e.emp_no = de.emp_no) LEFT JOIN departments AS d ON de.dept_no = d.dept_no; 20 查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth题目描述1234567891011查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growthCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:growth 解题思路 最大to_date的salary 减去最小值to_date的salary 1234SELECT ( (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date DESC LIMIT 1)- (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date LIMIT 1) )AS growth; 最大salary-最小salary，不严禁，有可能最后最大salary不在当前日期取得，最小salary不在最早的日期取得。 123SELECT (MAX(salary)- MIN(salary)) AS growth FROM salariesWHERE emp_no = 10001; 21 查找所有员工自入职以来的薪水涨幅情况题目描述12345678910111213141516171819查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no growth 解题思路 建立两张表，一张存放员工当前工资，另一张存放员工入职时的工资。 1234567SELECT present.emp_no, (present.salary - pass.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.to_date=&apos;9999-01-01&apos;) AS present, (SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.from_date=e.hire_date) AS passWHERE present.emp_no = pass.emp_noORDER BY growth; 123456789# 内层用LEFT JOIN，内层用INNER JOINSELECT present.emp_no, (present.salary - pass.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees AS e LEFT JOIN salaries AS s ON e.emp_no = s.emp_no WHERE s.to_date=&apos;9999-01-01&apos;) AS present INNER JOIN (SELECT s.emp_no, s.salary FROM employees AS e LEFT JOIN salaries AS s ON e.emp_no = s.emp_no WHERE s.from_date=e.hire_date) AS passON present.emp_no = pass.emp_noORDER BY growth; 22 统计各个部门对应员工涨幅的次数总和题目描述123456789101112131415161718192021统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sumCREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no dept_name sum 解题思路 用INNER JOIN联结dept_emp和salaries表，得到所有部门所有员工的记录总数，在联结departmens表，找到dept_no和dept_name的对应关系。 1234SELECT dp.dept_no, dp.dept_name, COUNT(s.salary) AS sumFROM (dept_emp AS de INNER JOIN salaries AS s ON de.emp_no = s.emp_no) INNER JOIN departments AS dp ON de.dept_no = dp.dept_no GROUP BY dp.dept_no; 1234SELECT dp.dept_no, dp.dept_name, COUNT(s.salary) AS sumFROM dept_emp AS de, salaries AS s, departments AS dpWHERE de.emp_no = s.emp_no AND de.dept_no = dp.dept_no GROUP BY dp.dept_no; 23 对所有员工的薪水按照salary进行按照1-N的排名题目描述1234567891011对所有员工的当前(to_date=&apos;9999-01-01&apos;)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary rank 解题思路 复用salaries表进行比较排名，从两张相同的salaries表（分别为s1与s2）进行对比分析。 先将两表限定条件设为to_date = ‘9999-01-01’，挑选出当前所有员工的薪水情况。 s1.salary &lt;= s2.salary，意思是在输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary。 1234567SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rankFROM salaries AS s1, salaries AS s2WHERE s1.to_date = &apos;9999-01-01&apos; AND s2.to_date = &apos;9999-01-01&apos; AND s1.salary &lt;= s2.salaryGROUP BY s1.emp_noORDER BY rank, s1.emp_no; 24 获取所有非manager员工当前的薪水情况题目描述12345678910111213141516171819202122232425262728293031获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date=&apos;9999-01-01&apos;CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路123456SELECT de.dept_no, s.emp_no, s.salaryFROM (employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_no AND s.to_date = &apos;9999-01-01&apos;) INNER JOIN dept_emp AS de ON e.emp_no = de.emp_noWHERE de.emp_no NOT IN (SELECT emp_no FROM dept_manager WHERE to_date=&apos;9999-01-01&apos;); 25 获取员工其当前的薪水比其manager当前薪水还高的相关信息题目描述123456789101112131415161718192021222324252627获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=&apos;9999-01-01&apos;,结果第一列给出员工的emp_no，第二列给出其manager的manager_no，第三列给出该员工当前的薪水emp_salary,第四列给该员工对应的manager当前的薪水manager_salaryCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no manager_no emp_salary manager_salary 解题思路 创建两张表，一张保存员工的工资，另一张保存经理的工资。 找出同一部门，员工比经理工资高的输出。 12345678SELECT s1.emp_no AS emp_no, s2.emp_no AS manager_no, s1.salary AS emp_salary, s2.salary AS manager_salaryFROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries AS s INNER JOIN dept_emp AS de ON s.emp_no = de.emp_no AND s.to_date=&apos;9999-01-01&apos;) AS s1, (SELECT s.salary, s.emp_no, dm.dept_no FROM salaries AS s INNER JOIN dept_manager AS dm ON s.emp_no = dm.emp_no AND s.to_date=&apos;9999-01-01&apos;) AS s2WHERE s1.dept_no = s2.dept_no AND s1.salary &gt; s2.salary; 26 汇总各个部门当前员工的title类型的分配数目题目描述1234567891011121314151617181920汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目countCREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE IF NOT EXISTS `titles` (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:dept_no dept_name title count 解题思路 用 GROUP BY 同时对 de.dept_no 和 t.title 进行分组。 12345SELECT de.dept_no, dp.dept_name, t.title, COUNT(t.title) AS countFROM (dept_emp de INNER JOIN titles t ON de.emp_no = t.emp_no AND de.to_date = &apos;9999-01-01&apos; AND t.to_date = &apos;9999-01-01&apos;) INNER JOIN departments dp ON de.dept_no = dp.dept_no GROUP BY de.dept_no, t.title; 27 给出每个员工每年薪水涨幅超过5000的员工编号emp_no题目描述1234567891011121314给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。提示：在sqlite中获取datetime时间对应的年份函数为strftime(&apos;%Y&apos;, to_date)CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no from_date salary_growth 解题思路 每年的薪资涨幅，转化为strftime(‘%Y’, s2.to_date) - strftime(‘%Y’, s1.to_date) = 1 这种需要“穷举”每两行的关系的题目，需要用那张表的两个副本（s2.emp_no = s1.emp_no是“穷举”操作，因为要考虑差值，就需要所有的两两组合。 1234567SELECT s1.emp_no, s2.from_date, (s2.salary-s1.salary) AS salary_growthFROM salaries s1, salaries s2WHERE s1.emp_no = s2.emp_no AND (strftime(&apos;%Y&apos;, s2.to_date) - strftime(&apos;%Y&apos;, s1.to_date) = 1 OR strftime(&apos;%Y&apos;, s2.from_date) - strftime(&apos;%Y&apos;, s1.from_date) = 1 ) AND salary_growth &gt; 5000ORDER BY salary_growth DESC; 28 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部题目描述12345678910111213141516171819202122232425262728293031323334353637film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT &apos;0&apos;,title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部输入描述:无输出描述:无 解题思路123456789SELECT c.name AS name, COUNT(f.film_id) AS amountFROM film f, film_category fc, category c, (SELECT category_id FROM film_category GROUP BY category_id HAVING COUNT(film_id)&gt;=5) AS ccWHERE f.description LIKE &apos;%robot%&apos; AND f.film_id = fc.film_id AND fc.category_id = c.category_id AND c.category_id = cc.category_id; 29 使用join查询方式找出没有分类的电影id以及名称[题目描述]12345678910111213141516171819202122232425262728293031323334353637film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT &apos;0&apos;,title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);使用join查询方式找出没有分类的电影id以及名称输入描述:无输出描述:无 解题思路 用 LEFT JOIN 连接 film 和 film_category，限定条件为 f.film_id = fc.film_id，即连接电影 id 和电影分类 id，如果电影没有分类，则电影分类 id 显示 null 再用 WHERE 来限定条件 fc.category_id IS NULL 选出没分类的电影 1234SELECT f.film_id, f.titleFROM film f LEFT JOIN film_category fcON f.film_id = fc.film_idWHERE fc.category_id IS NULL; 30 使用子查询的方式找出属于Action分类的所有电影对应的title,description题目描述123456789101112131415161718192021222324252627282930313233343536film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT &apos;0&apos;,title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);使用子查询的方式找出属于Action分类的所有电影对应的title,description输入描述:无输出描述:无 解题思路12345SELECT f.title, f.descriptionFROM (film f INNER JOIN film_category fc ON f.film_id = fc.film_id) INNER JOIN category c ON fc.category_id = c.category_idWHERE c.name = &apos;Action&apos;; 31 获取select * from employees对应的执行计划题目描述12345获取select * from employees对应的执行计划输入描述:无输出描述:无 解题思路 可以用 “EXPLAIN” 关键字短语，用于描述表的细节。 1EXPLAIN SELECT * FROM employees; 32 将employees表的所有员工的last_name和first_name拼接起来作为Name题目描述123456789101112将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:Name 解题思路 MySQL用的 SELECT Concat(last_name, ‘ ‘, first_name) AS Name 本题SQLite数据库只支持用连接符号”||”来连接字符串 12SELECT (last_name||&quot; &quot;||first_name) AS NameFROM employees; 33 创建一个actor表，包含如下列信息[创建一个actor表，包含如下列信息]1234567列表 类型 是否为NULL 含义actor_id smallint(5) not null 主键idfirst_name varchar(45) not null 名字last_name varchar(45) not null 姓氏last_update timestamp not null 最后更新时间，默认是系统的当前时间输入描述:无 解题思路1234567CREATE TABLE actor(actor_id smallint(5) not null,first_name varchar(45) not null,last_name varchar(45) not null,last_update timestamp not null DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)),PRIMARY KEY (actor_id)); 34 批量插入数据题目描述1234567891011对于表actor批量插入如下数据CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))actor_id first_name last_name last_update1 PENELOPE GUINESS 2006-02-15 12:34:332 NICK WAHLBERG 2006-02-15 12:34:33输入描述:无 解题思路 insert into 表名 (列名可选) values(数据1),(数据2) 12INSERT INTO actor(actor_id, first_name, last_name, last_update)values (1,&apos;PENELOPE&apos;,&apos;GUINESS&apos;,&apos;2006-02-15 12:34:33&apos;), (2,&apos;NICK&apos;,&apos;WAHLBERG&apos;,&apos;2006-02-15 12:34:33&apos;); 使用UNION SELECT插入 123INSERT INTO actor(actor_id, first_name, last_name, last_update)SELECT 1, &apos;PENELOPE&apos;, &apos;GUINESS&apos;, &apos;2006-02-15 12:34:33&apos;UNION SELECT 2, &apos;NICK&apos;, &apos;WAHLBERG&apos;, &apos;2006-02-15 12:34:33&apos;; 35 批量插入数据，不使用replace操作题目描述12345678对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))actor_id first_name last_name last_update&apos;3&apos; &apos;ED&apos; &apos;CHASE&apos; &apos;2006-02-15 12:34:33&apos; 解题思路12INSERT OR IGNORE INTO actorVALUES(&apos;3&apos;, &apos;ED&apos;, &apos;CHASE&apos;, &apos;2006-02-15 12:34:33&apos;); 若使用MySQL，则把OR去掉，即INSERT IGNORE INTO。 36 创建一个actor_name表题目描述123456789对于如下表actor，其对应的数据为:actor_id first_name last_name last_update1 PENELOPE GUINESS 2006-02-15 12:34:332 NICK WAHLBERG 2006-02-15 12:34:33创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。 actor_name表结构如下：列表 类型 是否为NULL 含义first_name varchar(45) not null 名字last_name varchar(45) not null 姓氏 解题思路123456CREATE TABLE actor_name(first_name varchar(45) not null,last_name varchar(45) not null);INSERT INTO actor_nameSELECT first_name, last_name FROM actor; 37 对first_name创建唯一索引uniq_idx_firstname题目描述1234567针对如下表actor结构创建索引：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname 解题思路 创建唯一索引 CREATE UNIQUE INDEX。 创建普通索引 CREATE INDEX。 12CREATE UNIQUE INDEX uniq_idx_firstname ON actor(first_name);CREATE INDEX idx_lastname ON actor(last_name); 38 针对actor表创建视图actor_name_view题目描述123456针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;))) 解题思路123CREATE VIEW actor_name_view ASSELECT first_name AS first_name_v, last_name AS last_name_vFROM actor; 也可以直接在视图名后面跟字段名。 1234CREATE VIEW actor_name_view (first_name_v,last_name_v)ASSELECT first_name , last_name FROM actor; 39 针对上面的salaries表emp_no字段创建索引idx_emp_no题目描述12345678针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));create index idx_emp_no on salaries(emp_no); 解题思路 MYSQL中强制索引查询使用：FORCE INDEX(indexname); SQLite中强制索引查询使用：INDEXED BY indexname; 1SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005; 40 在last_update后面新增加一列名字为create_date题目描述1234567存在actor表，包含如下列信息：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)));现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为&apos;0000 00:00:00&apos; 解题思路 题目给的日期格式是错的。 使用ALTER TABLE更新表。 12ALTER TABLE actorADD create_date datetime NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos;; 41 构造一个触发器audit_log题目描述123456789101112构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数据到audit中。CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,NAME TEXT NOT NULL); 解题思路 用 CREATE TRIGGER 语句构造触发器，用 BEFORE或AFTER 来指定在执行后面的SQL语句之前或之后来触发TRIGGER 触发器执行的内容写出 BEGIN与END 之间 可以使用 NEW与OLD 关键字访问触发后或触发前的employees_test表单记录 1234CREATE TRIGGER audit_log AFTER INSERT ON employees_testBEGIN INSERT INTO audit VALUES(NEW.ID, NEW.NAME);END; 42 删除emp_no重复的记录，只保留最小的id对应的记录题目描述123456789101112131415删除emp_no重复的记录，只保留最小的id对应的记录。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values (&apos;1&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;2&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;3&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;4&apos;, &apos;10004&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;5&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;6&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;7&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;); 解题思路 先用 GROUP BY 和 MIN() 选出每个 emp_no 分组中最小的 id. 然后用 DELETE FROM … WHERE … NOT IN … 语句删除 “非每个分组最小id对应的所有记录” 123DELETE FROM titles_test WHERE id NOT IN (SELECT MIN(id) FROM titles_test GROUP BY emp_no); 43 将所有to_date为9999-01-01的全部更新为NULL题目描述123456789101112131415将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values (&apos;1&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;2&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;3&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;4&apos;, &apos;10004&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;5&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;6&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;7&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;); 解题思路1234UPDATE titles_test SET to_date = NULL, from_date = &apos;2001-01-01&apos;WHERE to_date = &apos;9999-01-01&apos;; 44 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005题目描述123456789101112131415将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values (&apos;1&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;2&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;3&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;4&apos;, &apos;10004&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;5&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;6&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;7&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;); 解题思路123UPDATE titles_test SET emp_no=10005WHERE id=5 AND emp_no=10001; 45 将titles_test表名修改为titles_2017题目描述123456789101112131415将titles_test表名修改为titles_2017。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values (&apos;1&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;2&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;3&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;4&apos;, &apos;10004&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;),(&apos;5&apos;, &apos;10001&apos;, &apos;Senior Engineer&apos;, &apos;1986-06-26&apos;, &apos;9999-01-01&apos;),(&apos;6&apos;, &apos;10002&apos;, &apos;Staff&apos;, &apos;1996-08-03&apos;, &apos;9999-01-01&apos;),(&apos;7&apos;, &apos;10003&apos;, &apos;Senior Engineer&apos;, &apos;1995-12-03&apos;, &apos;9999-01-01&apos;); 解题思路1ALTER TABLE titles_test RENAME TO titles_2017; 46 在audit表上创建外键约束，其emp_no对应employees_test表的主键id题目描述12345678910111213在audit表上创建外键约束，其emp_no对应employees_test表的主键id。CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,create_date datetime NOT NULL); 解题思路 MySQL使用ALTER TABLE tablename ADD FOREIGN KEY … REFERENCES。 sqlite只能先删除表，在建立表。 12345DROP TABLE audit;CREATE TABLE audit( EMP_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(EMP_no) REFERENCES employees_test(ID)); 47 如何获取emp_v和employees有相同的数据no题目描述12345678910111213存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;如何获取emp_v和employees有相同的数据？CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT e.* FROM employees e, emp_v evWHERE e.emp_no = ev.emp_no; 123SELECT e.* FROM employees e INNER JOIN emp_v evON e.emp_no = ev.emp_no; 48 将所有获取奖金的员工当前的薪水增加10%题目描述12345678910将所有获取奖金的员工当前的薪水增加10%。create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`)); 解题思路1234UPDATE salariesSET salary = salary + salary * 0.1WHERE emp_no IN (SELECT emp_no FROM emp_bonus) AND to_date=&apos;9999-01-01&apos;; 49 针对库中的所有表生成select count(*)对应的SQL语句题目描述12345678910111213141516171819202122232425262728293031323334353637383940针对库中的所有表生成select count(*)对应的SQL语句CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:cntsselect count(*) from employees;select count(*) from departments;select count(*) from dept_emp;select count(*) from dept_manager;select count(*) from salaries;select count(*) from titles;select count(*) from emp_bonus; 解题思路 列出数据库中所有表名：SELECT name FROM sqlite_master WHERE type=’table’ 12SELECT &quot;select count(*) from &quot; || name || &quot;;&quot; AS cntsFROM sqlite_master WHERE type = &apos;table&apos;; 50 将employees表中的所有员工的last_name和first_name通过(‘)连接起来题目描述123456789101112将employees表中的所有员工的last_name和first_name通过(&apos;)连接起来。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:nameFacello&apos;Georgi 解题思路12SELECT last_name || &quot;&apos;&quot; || first_name AS nameFROM employees; 51 查找字符串’10,A,B’ 中逗号’,’出现的次数cnt题目描述1查找字符串&apos;10,A,B&apos; 中逗号&apos;,&apos;出现的次数cnt。 解题思路 用replace函数将原串中出现的子串用空串替换 再用原串长度减去替换后字符串的长度（使用length）函数获得串长度 最后除以子串的长度 1SELECT (length(&apos;10,A,B&apos;)-length(replace(&apos;10,A,B&apos;, &apos;,&apos;, &apos;&apos;))) / length(&apos;,&apos;) AS cnt; 52 获取Employees中的first_name题目描述123456789101112131415获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式：first_nameChirstianTzvetanBezalelDuangkaew 解题思路 substr(X,Y,Z) 或 substr(X,Y) 函数。其中X是要截取的字符串。Y是字符串的起始位置（注意第一个字符的位置为1，而不为0），取值范围是±(1~length(X))，当Y等于length(X)时，则截取最后一个字符；当Y等于负整数-n时，则从倒数第n个字符处截取。Z是要截取字符串的长度，取值范围是正整数，若Z省略，则从Y处一直截取到字符串末尾；若Z大于剩下的字符串长度，也是截取到字符串末尾为止。 123SELECT first_name FROM employeesORDER BY substr(first_name, -2); 123SELECT first_name FROM employeesORDER BY substr(first_name, length(first_name)-1); 53 按照dept_no进行汇总题目描述123456789101112131415按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employeesCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输出格式:dept_no employeesd001 10001,10002d002 10006d003 10005d004 10003,10004d005 10007,10008,10010d006 10009,10010 解题思路 SQLite的聚合函数group_concat(X, Y)，其中X是要连接的字段，Y是连接时用的符号，可省略，默认为逗号。 1234SELECT dept_no, group_concat(emp_no, &apos;,&apos;) AS employeesFROM dept_empGROUP BY dept_noORDER BY dept_no; 54 查找排除当前最大、最小salary之后的员工的平均工资avg_salary题目描述123456789查找排除当前最大、最小salary之后的员工的平均工资avg_salary。CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:avg_salary69462.5555555556 解题思路12345SELECT Avg(salary) AS avg_salaryFROM salariesWHERE to_date = &apos;9999-01-01&apos; AND salary NOT IN (SELECT MIN(salary) FROM salaries) AND salary NOT IN (SELECT MAX(salary) FROM salaries); 55 分页查询employees表，每5行一页，返回第2页的数据题目描述123456789分页查询employees表，每5行一页，返回第2页的数据CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 解题思路 LIMIT 关键字。注意：在 LIMIT X,Y 中，Y代表返回几条记录，X代表从第几条记录开始返回（第一条记录序号为0） LIMIT 和 OFFSET 关键字。LIMIT 后的数字代表返回几条记录，OFFSET 后的数字代表从第几条记录开始返回 123SELECT * FROM employeesLIMIT 5, 5; 123SELECT * FROM employeesLIMIT 5 OFFSET 5; 56 获取所有员工的emp_no题目描述12345678910111213141516171819202122232425262728获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和recevied，没有分配具体的员工不显示CREATE TABLE `dept_emp` ( `emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:e.emp_no dept_no btype recevied 解题思路 题目缺了一个emp_bonus表，如下。 1234create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null); 123SELECT e.emp_no, de.dept_no, eb.btype, eb.receviedFROM (employees e INNER JOIN dept_emp de ON e.emp_no = de.emp_no)LEFT JOIN emp_bonus eb ON e.emp_no = eb.emp_no; 57 使用含有关键字exists查找未分配具体部门的员工的所有信息题目描述123456789101112131415161718使用含有关键字exists查找未分配具体部门的员工的所有信息。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输出格式:emp_no birth_date first_name last_name gender hire_date10011 1953-11-07 Mary Sluis F 1990-01-22 解题思路123SELECT *FROM employeesWHERE NOT EXISTS (SELECT emp_no FROM dept_emp WHERE emp_no = employees.emp_no); 1234SELECT e.*FROM employees e LEFT JOIN dept_emp deON e.emp_no = de.emp_noWHERE de.emp_no IS NULL; 58 获取employees中的行数据，且这些行也存在于emp_v中题目描述12345678910111213存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。输出格式:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT e.*FROM employees e INNER JOIN emp_v evON e.emp_no = ev.emp_no; 123SELECT e.*FROM employees e, emp_v evWHERE e.emp_no = ev.emp_no; 1SELECT * FROM emp_v 59 获取有奖金的员工相关信息。题目描述123456789101112131415161718192021222324252627获取有奖金的员工相关信息。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`));给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金额bonus。 bonus类型btype为1其奖金为薪水salary的10%，btype为2其奖金为薪水的20%，其他类型均为薪水的30%。 当前薪水表示to_date=&apos;9999-01-01&apos;输出格式:emp_no first_name last_name btype salary bonus 解题思路 使用CASE语句。 1234567SELECT e.emp_no, e.first_name, e.last_name, eb.btype, s.salary, (CASE eb.btype WHEN 1 THEN s.salary * 0.1 WHEN 2 THEN s.salary * 0.2 ELSE s.salary * 0.3 END) AS bonusFROM (employees e INNER JOIN salaries s ON e.emp_no = s.emp_no AND s.to_date=&apos;9999-01-01&apos;)INNER JOIN emp_bonus eb ON e.emp_no = eb.emp_no; 60 统计salary的累计和running_total题目描述12345678910111213141516171819题目描述按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:emp_no salary running_total10001 88958 8895810002 72527 16148510003 43311 20479610004 74057 27885310005 94692 37354510006 43311 41685610007 88070 50492610009 95409 60033510010 94409 69474410011 25828 720572 解题思路 running_total由一个 SELECT 子查询构成。将子查询内复用的 salaries 表记为 s2，主查询的 salaries 表记为 s1，当主查询的 s1.emp_no 确定时，对子查询中不大于 s1.emp_no 的 s2.emp_no 所对应的薪水求和。 1234SELECT s1.emp_no, s1.salary, (SELECT SUM(s2.salary) FROM salaries s2WHERE s2.emp_no &lt;= s1.emp_no AND s2.to_date = &apos;9999-01-01&apos;) AS running_totalFROM salaries s1 WHERE s1.to_date = &apos;9999-01-01&apos; ORDER BY s1.emp_no; 61 对于employees表中，给出奇数行的first_name题目描述1234567891011121314151617对于employees表中，给出奇数行的first_nameCREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:first_nameGeorgiChirstianAnnekeTzvetanSaniyaMary 解题思路 题目隐含了first_name是排序的。 1234SELECT e1.first_nameFROM employees e1WHERE (SELECT COUNT(*) FROM employees e2 WHERE e2.first_name &lt;= e1.first_name) % 2 = 1;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StudyNotes-MySQL必知必会]]></title>
    <url>%2F2019%2F06%2F29%2FStudyNotes%2FMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[第1章 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库 以某种有组织的方式存储的数据集合 保存有组织的数据的容器（通常是一个文件或一组文件） 数据库软件 DBMS-数据库管理系统 使用DBMS访问数据库 1.1.2 表 表 是一种结构化的文件，用来存储某种特定类型的数据 某种特定类型数据的结构化清单 存储在表中的数据是一种类型或一个清单，不应该在同一个表中有两种类型或两个清单 表名用来标识自己，名字是唯一的 相同数据库中不能使用相同的表名，但在不同的数据库中可以使用相同的表名 模式 定义了数据在表中如何存储 用来描述数据库中特定的表以及整个数据库和其中表的关系 关于数据库和表的布局及特性的信息 1.1.3 列和数据类型 列 表由列组成，列中存储着表中某部分的信息 表中的一个字段，所有表都是有一个或者多个列组成的 正确地将数据分解分为多个列很重要 数据类型 所容许的数据的类型，每个表列都有响应的数据类型，限制（或容许）该列中存储的数据 1.1.4 行 行 表中的一个记录 行 = 数据库记录 1.1.5 主键 主键 一列（或一组列），其值能够唯一区分表中的每个行 应该总是定义主键，便于数据操纵和管理 任意两行都不具有相同的主键值 表中任何列都可以作为主键，主要它满足一下条件 每个行都必须具有一个主键值（主键列不允许NULL值） 通常定义在表的一列上，但也可以使用多个列作为主键 好习惯 不更新主键列中的值 不重用主键列的值 不在主键列中使用可能会更改的值 1.2 什么是SQL SQL 结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言 优点 不是某个特定数据库供应商专有的语言，通用性 简单易学 强有力，灵活，可以进行非常复杂和高级的数据库操作 任意两个DBMS实现的SQL都不完全相同，不是完全可移植的，本书针对MySQL 1.3 动手实践 附录B B.1 样例表 - 随身物品推销商使用的订单录入系统 管理供应商 管理产品目录 管理顾客列表 录入顾客订单 表的描述 6个表，表的列出顺序是因为它们之间的依赖关系 vendors表 存储销售产品的供应商，每个供应商为一个记录。供应商列用来匹配产品和供应商 所有表都应该有主键，这个表使用vend_id作为主键，vend_id为一个自动增量字段 表B-1 vendors表的列 列 说明 vend_id 唯一的供应商ID vend_name 供应商名 vend_address 供应商的地址 vend_city 供应商的城市 vend_state 供应商的州 vend_zip 供应商的邮政编码 vend_country 供应商的国家 products表 products表包含产品目录，每行一个产品，每个产品有唯一的ID（prod_id列），通过vend_id（供应商的唯一ID）关联到它的供应商 所有表都应该有主键，这个表使用prod_id列作为主键 为实施引用完整性，应该在vend_id上定义一个外键，关联到vendors的vend_id 表B-2 products表的列 列 说明 prod_id 唯一的产品ID vend_id 产品供应商ID（关联到vendors表中的vend_id） prod_name 产品名 prod_price 产品价格 prod_desc 产品描述 customers表 customers表存储所有顾客的信息，每个顾客有唯一的ID（cust_id列） 所有表都应该有主键，这个表使用cust_id列作为主键，cust_id是一个自动增量的字段 表B-3 customers表的列 列 说明 cust_id 唯一的顾客ID cust_name 顾客名 cust_address 顾客的地址 cust_city 顾客的城市 cust_state 顾客的州 cust_zip 顾客的邮政编码 cust_country 顾客的国家 cust_contact 顾客的联系名 cust_email 顾客的联系email地址 orders表 orders表存储顾客订单（但不是订单细节），每个订单唯一的编号（order_num列），订单用cust_id列（它关联到customer表的顾客唯一ID）与响应的顾客关联 所有表都应该有主键，这个表使用order_num列作为主键，order_num是一个自动增量的字段 为实施引用完整性，应该在cust_id上定义一个外键，关联到customers的cust_id 表B-4 orders表的列 列 说明 order_num 唯一订单号 order_data 订单日期 cust_id 订单顾客ID（关联到customers表的cust_id） orderitems表 orderitems表存储每个订单中的实际物品，每个订单的每个物品占一行，对orders表中的一行，orderitems中有一行或多行，每个订单物品有订单号加订单物品（第一个物品、第二个物品等）唯一标识。订单物品通过order_num列（关联到orders中订单的唯一ID）与它们响应的订单相关联，每个订单项包含订单物品的产品ID（它关联物品到products表） 所有表都应该有主键，这个表使用order_num和order_item作为其主键 为实施引用完整性，应该在order_num上定义一个外键，关联到orders的order_num，在prod_id定义外键，关联到products的prod_id 表B-5 orderitems表的列 列 说明 order_num 订单号（关联到orders表的order_num） order_item 订单物品号（在某个订单中的顺序） prod_id 产品ID（关联到products表的prod_id） quantity 物品数量 item_price 物品价格 productnotes表 productnotes表存储于特定产品有关的注释信息，并非所有产品都有相关的注释，而有的产品可能有许多相关的注释 所有表都应该有主键，这个表使用note_id作为其主键 列note_text必须为FULLTEXT搜索进行索引 由于这个表使用全文本搜索，因此必须指定ENGINE=MyISAM 表B-6 productnotes表的列 列 说明 note_id 唯一注释ID prod_id 产品ID（对应于products表中的prod_id） note_date 增加注释的日期 note_text 注释文本 B.2 创建样例表下载数据：https://www/forta.com/books/0672327120/ 创建一个新数据源 保证选择新数据源 执行create.sql脚本 重复前面的步骤，用populate.sql文件填充各个新表 第2章 MySQL简介2.1 什么是MySQL MySQL 是一种DBMS，数据库软件 广泛使用，原因： 成本 - MySQL是开源的，可以免费使用（甚至可以免费修改） 性能 - MySQL执行很快 可信赖 - 很多公司，站点都用MySQL来处理自己的重要数据 简单 - MySQL很容易安装和使用 2.1.1 客户机-服务器软件 DBMS 分两类，一类为基于共享文件系统的DBMS，另一类为基于客户机-服务器的DBMS MySQL是基于客户机-服务器的数据库 服务器部分是负责所有数据访问和处理的一个软件，运行在数据库服务器上，与数据文件打交道的只有服务器软件，数据添加、删除和更新都由服务器软件完成 客户机是与用户打交道的软件 2.1.2 MySQL版本 DBMS版本 当前版本为5 版本4：InnoDB引擎，增加事物处理（第26章），并（第17章），改进全文本搜索（第18章）的支持 版本4.1：对函数库、子查询（第14章）、集成帮助等的重要增加 版本5：存储过程（第23章）、触发器（第25章）、游标（第24章）、视图（第22章）等 2.2 MySQL工具2.2.1 mysql命令行使用程序 指定登录名：mysql -u ben 指定用户名、主机名、端口和口令：mysql -u ben -p -h myserver -P 9999 完整的参数列表：mysql —help 命令输入在mysql&gt;之后 命令用 ; 或 \g 结束，仅按enter不执行命令 输入help或 -h 获得帮助 获得特定命令的帮助 如help select 输入quit或exit退出命令行实用程序 2.2.2 MySQL Administrator MySQL Administrator（MySQL管理器）是一个图形交互客户机，简化MySQL服务器的管理 key points： Server Information（服务器信息）显示客户机和被连接的服务器的状态和版本信息 Server Control（服务控制）允许停止和启动MySQL以及指定服务器特性 User Administration（用户管理）用来定义MySQL用户、登录和权限 Catalogs（目录）列出可用的数据库并允许创建数据库和表 2.2.3 MySQL Query Browser MySQL Query Browser是一个图形交互客户机，编写和执行MySQL命令 第3章 使用MySQL3.1 连接 MySQL有自己的用户列表，用户间的权限可能不同 MySQL Administrator 的Users视图可直接定义新用户，包括赋予口令和访问权限 主机名+端口+用户名+口令 3.2 选择数据库 使用USE关键字 （关键字：作为MySQL的保留字，不要用关键字命名一个表和列。） USE crashcourse （选择crashcourse数据库，不返回任何结果） 3.3 了解数据库和表 SHOW DATABASES（返回可用数据库的一个列表） SHOW TABLES（返回当前选择的数据库内可用表的列表） SHOW COLUMNS FROM customers； （显示表列） 对每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment） 自动增量：某些表列需要唯一值，在每个行添加到表中时，MySQL自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值。在CREATE语句创建表时定义（第21章） DESCRIBE是SHOW COLUMNS FROM的快捷方式，DESCRIBE customers 与 SHOW COLUMNS FROM customers 等价 SHOW STATUS （显示服务器状态信息） SHOW CREATE DATABASE和SHOW CREATE TABLE （分别用来显示创建特定数据库或表的MySQL语句） SHOW GRANTS （显示授予用户（所有用户或特定用户）的安全权限） SHOW ERRORS和SHOW WARNINGS （显示服务器错误或警告消息） HELP SHOW （显示所有允许的SHOW语句） MySQL新增内容：INFORMATION_SCHEMA，获得和过滤模式信息 第4章 检索数据4.1 SELECT语句 从一个表或多个表中检索信息 使用SELECT时，至少给出两条信息：想选择什么，以及从什么地方选择 4.2 检索单个列123# 从products表中检索一个名为prod_name的列，返回的数据是无序的SELECT prod_nameFROM products; 多条语句用分号分隔，在每一条语句后加分号没有坏处 SQL语句不区分大小写，SELECT=Select，一般对关键字使用大写，对列和表明使用小写，易于阅读和调试 在处理SQL语句时，所有空格被忽略，SQL语句可以在一行给出，也可以分成许多行，多行更容易阅读和调试 4.3 检索多个列 使用相同的SELECT语句，在SELECT后给出多个列名，列名之间必须以逗号分隔，但最后一个列名后不加逗号，否则报错 12SELECT prod_id, prod_name, prod_priceFROM products; SQL语句一般返回原始的、无格式的数据 数据的格式化是一个表示问题，而不是检索问题，表示（对齐和数值）一般在显示该数据的应用程序中规定，一般很少使用实际检索出的原始数据 4.4 检索所有列123# 使用通配符 * SELECT *FROM products; 如果给定一个通配符 * ，则返回表中所有列，列的顺序一般是列在表定义中出现的顺序，但表的模式的变化（如添加和删除列）可能会导致顺序的变化 使用通配符省事，但会降低检索和应用程序的性能 使用通配符优点，可以检索出名字未知的列 4.5 检索不同的行123# 只返回不同的vend_id行SELECT DISTINCT vend_idFROM products; 使用DISTINCT关键字只返回不同的值，放在列名的前面 不能部分使用DISTINCT，DISTINCT应用于所有列而不仅是前置它的列 4.6 限制结果 使用LIMIT语句返回前几行 1234# 返回不多于5行SELECT prod_nameFROM productsLIMIT 5; 指定要检索的开始行和行数 1234# 返回从行5开始的5行SELECT prod_nameFROM productsLIMIT 5, 5; LIMIT 5, 5返回从行5开始的5行，第一个数为开始位置，第二个数为要检索的行数 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数 第一行是行0，LIMIT 1, 1将检索出第二行而不是第一行 LIMIT中指定要检索的行数为检索的最大行数 MySQL5支持LIMIT 4 OFFSET 3 与 LIMIT 3, 4等价，从行3开始取4行 4.7 使用完全限定的表名 完全限定的名字：同时使用表名和列字 12SELECT products.prod_name # 完全限定的列名FROM products； 12SELECT products.prod_name # 完全限定的列名FROM crashcourse.products； # 完全限定的表名 第5章 排序检索数据 SELECT语句的ORDER BY 子句 5.1 排序数据12SELECT prod_nameFROM products; 以上输出数据没有特定的顺序，如果不排序，一般会以它在底层表中出现的顺序显示，这可以是数据最初添加到表中的顺序，但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。 子句，SQL语句由子句构成，有些子句是必需的，而有的是可选的，一个子句通常由一个关键字和所提供的的数据组成，如SELECT语句的FROM子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序。 123SELECT prod_nameFROM productsORDER BY prod_name; 通常ORDER BY子句中使用的列为显示所选择的列，但用非检索列的列排序数据也是完全合法的。 5.2 按多个列排序 按多个列排序，只要指定列名，列名之间用逗号分开即可。 1234# 首先按价格，再按名称排序SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 5.3 指定排序方向 默认是生序排序，无须指定关键字，也可以指定升序关键字ASC 降序排序需要指定DESC关键字。 1234# 降序排序SELECT prod_id, Prod_price, prod_nameFROM productsORDER BY prod_price DESC; 1234# prod_price降序排序, prod_name 升序排序SELECT prod_id, Prod_price, prod_nameFROM productsORDER BY prod_price DESC, prod_name; 在多个列上降序排序，必须对每个列指定DESC关键字。 大小写问题，MySQL认为A和a相同。 ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 12345# 找出价格最高物品的值SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1; ORDER BY在FROM子句之后，LIMIT位于ORDER BY之后，次序不对将报错。 第6章 过滤数据 使用SELECT的WHERE子句指定搜索条件。 6.1 使用WHERE子句 只检索所需数据需要指定搜索条件，搜索条件也称为过滤条件。 在SELECT中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出。 1234# 从products中检索两个列，只返回prod_price值为2.50的行SELECT prod_name, prod_priceFROM productsWHERE prod_price = 2.50; 6.2 WHERE子句操作符 WHERE支持的条件操作符。 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 6.2.1 检查单个值1234# 返回prod_name的值为Fuses的行，不区分大小写，Fuces和fuces匹配SELECT prod_name, prod_priceFROM productsWHERE prod_name = &apos;fuses&apos;; 1234# 列出价格小于10美元的所有产品SELECT prod_name, prod_priceFROM productsWHERE prod_price &lt; 10; 6.2.2 不匹配检查1234# 列出不是由供应商制造的所有产品SELECT vend_id, prod_nameFROM productsWHERE vend_id &lt;&gt; 1003; 何时使用引号：单引号用来限定字符串，如果将值与串类型的列进行比较，则需要限定引号，用来与数值列进行比较的值不用引号。 &lt;&gt; 和 != 等价。 6.2.3 范围值检查 使用BETWEEN操作符，需要两个值，即范围的开始值和结束值，匹配范围内所有的值，包括开始值和结束值。 1234# 检索价格在5美元到10美元的所有产品SELECT prod_name, prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 6.2.4 空值检查 在创建表时，可以指定其中的列可以不包含空值，空值为NULL。 空值NULL与字段包含0，空字符串或仅仅包含空格不同。 IS NULL子句用来检索NULL的列。 1234# 返回没有价格（空prod_price字段，不是价格为0）的所有产品的行SELECT prod_nameFROM productsWHERE prod_price IS NULL; NULL与不匹配：匹配过滤和不匹配过滤时不返回具有NULL值的行。 第7章 数据过滤 组合WHERE子句，NOT和IN操作符。 7.1 组合WHERE子句 以ANF子句或OR子句的方式使用多个WHERE子句。 操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符。 7.1.1 AND操作符1234# 检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格SELECT prod_id, prod_price, prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。 7.1.2 OR操作符 OR操作符与AND不同，它指示检索匹配任一条件的行。 1234# 检索由供应商1002或1003制造的任何产品SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003; OR 用在WHERE子句中的关键字，用来指示检索匹配任一给定条件的行。 7.1.3 计算次序 WHERE可包含任意数目的AND和OR操作符，允许两者结合以进行复杂和高级的过滤。 AND的计算优先级比OR高，使用圆括号明确地分组相应的操作符。 1234# 检索由供应商1002或1003制造的任何产品，并且价格大于等于10美元的行SELECT prod_name, prod_priceFROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10; 在WHERE子句中，任何时候使用AND和OR操作时，都要使用圆括号明确地分组操作符，使用圆括号没有坏处，可以消除歧义。 7.2 IN操作符 圆括号在WHERE子句中还有另外一种用法，IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，IN取合法值的由逗号分隔的清单，全都在圆括号中。 123456# 检索供应商1002和1003制造的所有产品SELECT prod_name, prod_priceFROM productsWHERE vend_id IN (1002, 1003)ORDER BY prod_name;​` IN操作符完成与OR相同的功能。 ​12345# 检索供应商1002和1003制造的所有产品SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003ORDER BY prod_name; IN操作符的优点： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观 计算次数更容易管理 比OR操作符执行更快 最大的优点是可以包含其他SELECT语句，能够更加动态地建立WHERE子句 7.3 NOT操作符 NOT操作符有且只有一个功能，否定它之后所跟的任何条件。 12345# 匹配1002和1003之外的供应商SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002, 1003)ORDER BY prod_name; 与IN操作符联合使用时，NOT使找出与条件列表不匹配的行。 第8章 用通配符进行过滤8.1 LIKE操作符 通配符：用来匹配值的一部分的特殊字符。 搜索模式：由字面值、通配符或两者组合构成的搜索条件。 在搜索子句中使用通配符，必须使用LIKE操作符，LIKE指示后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 8.1.1 百分号（%）通配符 % 表示任何字符出现的任意次数。 1234# 检索任意jet起头的词，%告诉MySQL接受jet之后的任意字符，不管它有多少字符SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &apos;jet%&apos;; 区分大小写：搜索是可以区分大小写的。 通配符可以在搜索模式中任意位置使用，并且可以使用多个通配符。 1234# 匹配任何位置包含文本anvil的值SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &apos;%anvil%&apos;; 1234# 匹配以s起头以e结尾的所有产品SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &apos;s%e&apos;; % 还可以匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意尾空格，尾空格可能会干扰通配符匹配，例如anvil后有一个或多个空格时，则子句WHERE prod_name LIKE &#39;%anvil&#39;将不会匹配它们，因为在最后有空格，一个简单的方法是在搜索模式最后附加一个%，一个更好的方法是使用函数（第11章）去掉首尾空格。 注意NULL，%通配符不能匹配值为NULL的行。 8.1.2 下划线（_）通配符 下划线只匹配单个字符而不是多个字符。 1234# （_）只匹配一个字符SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE &apos;_ ton anvil&apos; 8.2 使用通配符的技巧 通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 技巧： 不要过度使用通配符。 除非有必要，否则不要把它们用在搜索模式的开始处，因为置于开始处是最慢的。 仔细注意通配符的位置。 第9章 用正则表达式进行搜索9.1 正则表达式介绍 正则表达式：用来匹配文本的特殊的串（字符集合）。 更多参考《正则表达式必知必会》。 9.2 使用MySQL正则表达式 MySQL仅支持正则表达式实现的一个很小的子集。 9.2.1 基本字符匹配12345# 检索列prod_name包含1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;1000&apos;ORDER BY prod_name; 12345# .是表示匹配任意一个字符，因此可以匹配1000和2000SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;.000&apos;ORDER BY prod_name; LIKE和REGEXP比较。 12345# 不返回数据SELECT prod_nameFROM productsWHERE prod_name LIKE &apos;1000&apos;ORDER BY prod_name; 12345# 检索列prod_name包含1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;1000&apos;ORDER BY prod_name; LIKE匹配整个列，如果被匹配的文本在列值中出现，LIKE将不会找到它，除非使用通配符。 而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，响应的行将被返回。 匹配不区分大小写，为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;。 9.2.2 进行OR匹配 为检索两个串之一，使用|。 12345# | 表示OR操作，表示匹配其中之一，因此1000和2000都匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;1000|2000&apos;ORDER BY prod_name; 可以给出两个以上的OR条件，例如&#39;1000|2000|3000&#39;将匹配1000或2000或3000。 9.2.3 匹配几个字符之一 使用一组用[]括起来的字符即可。 12345# [123]表示匹配1或2或3，因此，1 ton和2 ton都匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;[123] Ton&apos;ORDER BY prod_name; [] 是另一种形式的OR语句，[123] Ton是[1|2|3] Ton的缩写。 需要用[]来定义OR语句。 12345# 表示&apos;1&apos;或&apos;2&apos;或&apos;3 ton&apos;SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;1|2|3 Ton&apos;ORDER BY prod_name; 需要把字符|括在一个集合里，否则它将应用于整个串。 字符集合也可以被否定，即它将匹配除指定字符外的任何东西，在集合的开始处放置一个^即可，例如123匹配除1、2或3外的任何东西。 9.2.4 匹配范围 集合可用来定义要匹配的一个或多个字符。例如[0123456789]将匹配数字0到9，可使用-来定义一个范围，简化为[0-9]。[a-z]匹配任意字母字符。 12345# [1-5]表示匹配1到5, 5 ton是一个匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;[1-5] ton&apos;ORDER BY prod_name; 9.2.5 匹配特殊字符 加前导\\匹配特殊字符.、[]、|、_。\\_表示查找_，\\. 表示查找.。这种处理称为转义。 12345# 使用 \\. 匹配 . SELECT vend_nameFROM vendorsWHERE vend_name REGEXP &apos;\\.&apos;ORDER BY vend_name; \\也用来引用元字符（具有特殊含义的字符）。 表9-1 空白元字符 元字符 说明 \\f 换页 \\n 换行 \\r 回车 \\t 制表 \\v 纵向制表 为了匹配反斜杠（\）字符本身，需要使用 \\\ 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身，但MySQL要求两个反斜杠实现转义（MySQL解释一个，正则表达式库解释另一个）。 9.2.6 匹配字符类 存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。使用预定义的字符集，称为字符类。表9-2 字符类 类 说明 [:alnum:] 任意字母和数字（同[a-aA-Z0-9]） [:alpha:] 任意字母（同[a-zA-Z]）] [:blank:] 空格和制表（同[\\t]） [:cntrl:] ASCII控制字符（ASCII 0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，但不包含空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 9.2.7 匹配多个实例表9-3 重复元字符 元字符 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1, }） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n, } 不少于指定数目的匹配 {n, m} 匹配数目的范围{m不超过255} 12345# \\(匹配)，[0-9]匹配任意数字，sticks？匹配stick和sticks(s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现)，没有？，匹配stick和sticks会非常困难SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;\\([0-9]) sticks?\\&apos;ORDER BY prod_name; 以下匹配连在一起的4位数字 12345# [:digit:] 匹配任意数字，&#123;4&#125;要求它前面的字符（任意数字）出现4次SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;[[:digit:]]&#123;4&#125;&apos;ORDER BY prod_name; 12345# 与上例等价SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;[0-9][0-9][0-9][0-9]&apos;ORDER BY prod_name; 9.2.8 定位符 匹配特定位置的文本。 表9-4 定位元字符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 12345# 使用^定位符找出以一个数（包括小数点开始的数）开始的所有产品SELECT prod_nameFROM productsWHERE prod_name REGEXP &apos;^[0-9\\.]&apos;ORDER BY prod_name; ^还可以在集合中[]用来否定该集合。 使REGEXP起类似LIKE的作用，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。 可以在不使用数据库表的情况下用SELECT来测试正则表达式，REGEXP总是返回0（不匹配）或者1（匹配）。如 SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;，返回0。 第10章 创建计算字段10.1 计算字段 存储在数据库表中的数据一般不是应用程序所需要的格式，直接从数据库中检索出转换、计算或格式化过的数据，称为计算字段。 计算字段是运行SELECT语句是创建的。 字段，基本上与列的意思相同，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。 客户机与服务器的格式，可在客户机和服务器上完成转换和格式化工作，但在服务器上比客户机中要快得多。 10.2 拼接字段 拼接，将值联结到一起构成单个值。 在SELECT语句中，用Concat()函数来拼接两个列。 MySQL的不同之处，多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。 1234# 返回vend_name(vend_country)字段SELECT Concat(vend_name, &apos;(&apos;, vend_country, &apos;)&apos;)FROM vendorsORDER BY vend_name; 删除数据右侧多于的空格整理数据，使用RTrim。 1234# 拼接前使RTrim()函数删除vend_name和vend_country右侧的空格SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;)FROM vendorsORDER BY vend_name; LTrim()，去掉串左边的空格，Trim()，去掉左右两边的空格。 使用别名，SELECT语句拼接地址字段没有名字，需要使用别名（alias）表示一个字段或值，用AS关键字赋予。 1234# 使用AS vend_title指定计算字段的列名SELECT Concat(vend_name, &apos;(&apos;, vend_country, &apos;)&apos;) AS vend_titleFROM vendorsORDER BY vend_name; 别名的其他用途，在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 别名，有称为导出列（derived column）。 10.3 执行算术计算 对检索出的数据进行算术运算。 1234567# 汇总物品的价格（单价乘以订购数量），expanded_price为一个计算字段SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM orderitemsWHERE order_num = 2005; MySQL支持的基本算术运算符，圆括号可用来区分优先顺序。 表10-1 MySQL算术操作符 操作符 说明 + 加 - 减 * 乘 / 除 测试计算，可以省略FROM子句以便简单地访问和处理表达式，例如 SELECT 3*2 将返回 6，SELECT Trim(&#39; abc &#39;)将返回abc，SELECT Now()返回当前日期和时间。 第11章 使用数据处理函数11.1 函数 能运行在多个系统上的代码称为可移植的。 函数的可移植性不强。 11.2 使用函数 大多数SQL实现支持以下类型的函数。 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。 用于在数值数据上进行算术操作（如返回绝对值，进行代数计算）的数值函数。 用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等的日期和时间函数。 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。 11.2.1 文本处理函数 Upper()函数 1234# 返回vend_name和vend_name大写的一个计算字段SELECT vend_name, Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name; 常用文本处理函数。 表11-1 常用的文本处理函数 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 SOUNDEX，将任何文本串转换为描述其语音表示的字母数字模式的算法，其考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。 例如customers表中有一个顾客Coyote Inc.，其联系名为Y. LEE。但如果这是输入错误，实际应为Y. Lie，按正确的联系名搜索将搜索不到。 1234# 返回空，因为没有叫Y. Lie的SELECT cust_name, cust_contactFROM customersWHERE cust_concact = &apos;Y.Lie&apos;; 1234# 返回Y.LEE，因为Y.LEE和Y.Lie发音相似SELECT cust_name, cust_contactFROM customersWHERE Soundex(cust_concact) = Soundex(&apos;Y.Lie&apos;); 11.2.2 日期和时间处理函数 常用的日期和时间处理函数 表11-2 常用日期和时间处理函数 函数 说明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DatOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期的时间部分 Year() 返回一个日期的年份部分 日期格式必须为yyyy-mm-dd。其他格式也可，但这是首选的，因为它排除了多义性。 使用4位数字的年份更可靠。 1234# 返回order_date为&apos;2005-09-01&apos;的订单SELECT cust_id, order_numFROM ordersWHERE order_date = &apos;2005-09-01&apos;; 存储order_date值为 2005-09-01 11:30:05时，则 WHERE order_date = &#39;2005-09-01&#39;匹配失败。 解决方法是仅将给出的日期和列中的日期部分进行比较，而不是将给出的日期和整个列值进行比较。使用Date(order_date)指示仅提取列的日期部分。 1234# 更可靠的SELECT语句SELECT cust_id, order_numFROM ordersWHERE Date(order_date) = &apos;2005-09-01&apos;; 如果要的是日期，使用Date()。想要的是时间，使用Time()。 检索2005年9月下的所有订单。 123456SELECT cust_id, order_numFROM ordersWHERE Date(order_date) BETWEEN &apos;2005-09-01&apos; AND &apos;2005-09-30&apos;;# 更好的方法WHERE Year(order_date) = 2005 AND Month(order_date) = 9; 11.2.3 数值处理函数 常用数值处理函数 表11-3 常用数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 第12章 汇总数据12.1 聚集函数 聚集函数，运行在行组上，计算和返回单个值的函数。 表12-1 SQL聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 12.1.1 AVG()函数 可以返回所有列的平均值，也可以返回特定列或行的平均值 123# 返回products表中所有产品的平均价格SELECT AVG(prod_price) AS avg_priceFROM products; 1234# 返回特定供应商的产品平均价格SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; AVG只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出，为了获得多个列的平均值，必须使用多个AVG()函数。 AVG函数忽略列值为NULL的行。 12.1.2 COUNT()函数 确定表中行的数目或符合特定条件的行的数目。 两种使用方式： COUNT(*)，对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。 COUNT(column)，对特定列中具有值的行进行计数，忽略NULL值。 123# 对所有行计数SELECT COUNT(*) AS num_custFROM customers; 123# 对只具有电子邮件地址的客户计数SELECT COUNT(cust_email) AS num_custFROM customers; 如果指定列名，则指定列的空值（NULL）被忽略，但如果用的是星号（不指定列名），则不忽略。 12.1.3 MAX()函数 返回列中的最大值 123# 返回products中的最大的价格SELECT MAX(prod_price) AS max_priceFROM products; 对非数值数据使用MAX()函数，允许返回任意列中的最大值，包括文本列。 MAX()函数忽略值为NULL的行。 12.1.4 MIN()函数 返回列中的最小值。 123# 返回products中的最小的价格SELECT MIN(prod_price) AS min_priceFROM products; 对非数值数据使用MIN()函数，允许返回任意列中的最小值，包括文本列。 MIN()函数忽略值为NULL的行。 12.1.5 SUM()函数 返回指定列值的和。 1234# 返回orderitems表包含订单中实际的物品SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num = 20005; SUM()函数也可以合并计算值。 1234# 返回orderitems表中所有物品价格之和SELECT SUM(item_price*quantity) AS total_priceFROM orderitemsWHERE order_num = 20005; 可以执行多个列上的计算。 SUM()函数忽略列值为NULL的行。 12.2 聚焦不同值 以下内容仅在MySQL 5及后期版本可用。 以上5个聚集函数都可以如下使用： 对所有行执行计算，指定ALL参数或不给参数（因为ALL是默认的）。 只包含不同的值，指定DISTINCT参数。 1234# 返回特定供应商的 不同价格 的平均值SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; DISTINCT必须指定列名，COUNT(DISTINCT)会报错，还不能用于计算或表达式。 DISTINCT用于MIN()和MAX()，可行但没有价值。用不用结果一样。 12.3 组合函数123456# 执行了4个聚集计算SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM products; 第13章 分组数据13.1 数据分组 分组，把数据分为多个逻辑组，以便对每个组进行聚集计算。 13.2 创建分组 分组时在SELECT语句的 GROUP BY子句中建立的。 1234# 使用GROUP BY 对每个供应商计算产品数量SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; GROUP BY 可以包含任意数目的列，这使得能对分组进行嵌套。 如果使用了嵌套，数据将在最后规定的分组上进行汇总， 即所有列都一起计算。 GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式，如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名。 除聚集语句外，SELECT语句中的每个列都必须在GROUP BY 子句中给出。 若分组列中药NULL值，NULL值作为一个分组。 GROUP BY在WHERE子句之后，在ORDER BY 子句之前。 使用WITH ROOLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。 123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROOLUP; 13.3 过滤分组 WHERE过滤的是行而不是分组。 使用HAVING过滤分组，WHERE子句可以用HAVING子句替代。 12345# 找出两个以上的订单的分组，使用WHERE不起作用SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中。 123456# 列出具有2个及以上、价格为10及以上的产品的供应商SELECT vend_id, COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;= 10GROUP BY vend_idHAVING COUNT(*) &gt;= 2; 13.4 分组和排序 ORDER BY 与GROUP BY的差别 表13-1 ORDER BY 与GROUP BY ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 一般在使用GROUP BY子句时，应该也给出ORDER BY 子句，这是保证数据正确排序的唯一方法。 123456# 列出总计订单价格大于等于50的订单号和总订单价格SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 13.5 SELECT子句顺序表13-2 SELECT子句及其顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 第14章 使用子查询14.1 子查询 版本要求，MySQL4.1及以上版本。 查询，任何SQL语句都是查询，但此术语一般指SELECT语句。 子查询，嵌套在其他查询中的查询。 14.2 利用子查询进行过滤 把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。 1234567891011SELECT cust_name, cust_contactFROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;)); # 以上语句首先执行了SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;; 在orderitems表里查询prod_id为TNT2的订单号，然后这些订单号以IN操作符传递给外部的WHERE子句。# 然后在orders表里查询具有这些订单号的客户ID，并将客户ID以IN操作符传递给最外层的WHERE子句。# 最后在customers表中查询这些客户ID的信息。 在SELECT语句中，子查询总是从内向外处理。 对于能嵌套的子查询的数目没有限制，但太多嵌套会影响性能。 列必须匹配，SELECT语句应该具有与WHERE子句中相同数目的列。 子查询可以与IN，=，&lt;&gt;等操作符结合使用。 14.3 作为计算字段使用子查询 使用子查询的另一方法是创建计算字段。 123456789# 从customers表中检索客户列表# 对于检索出的每个客户，统计其在orders表中的订单数目SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders)FROM customersORDER BY cust_name; 子查询中的WHERE语句需要使用完全限定列名。orders.cust_id = customers.cust_id。这种类型的子查询称为相关子查询，即涉及外部查询的子查询，必须使用这种语法。否则可能出错。 第15章 联结表15.1 联结 SQL最强大的功能之一，在数据检索查询的执行中联结表。 15.1.1 关系表 关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（关系）互相关联。 外键，某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系。 好处： 信息不重复，不浪费时间和空间。 信息变动，只更新对应表的单个记录，相关表中的数据不用改动。 数据无重复，处理更简单。 有效地存储和方便地处理。 关系数据库的可伸缩性远比非关系数据库要好。 可伸缩性，能够适应不断增加的工作量而不失败。 15.1.2 为什么要使用联结 联结，用来在一条SELECT语句中关联表。 维护引用完整性，仅在关系列中插入合法的数据。 15.2 创建联结123456# prod_name, prod_price在products中，而vend_name在vendors中# 使用WHERE正确联结，需完全限定列名SELECT vend_name, prod_name, prod_priceFROM vendor, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; 在引用的列可能出现二义性时，必须使用完全限定列名。 15.2.1 WHERE子句的重要性 WHERE作为过滤条件，只包含那些匹配给定条件（联结条件）的行。 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 笛卡尔积，由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。又称叉联结。 应该保证所有联结都有WHERE子句，否则将返回比想要的数据多得多的数据 15.2.2 内部联结 基于两个表之间的相等测试，称为等值联结，也称为内部联结。 使用不同语法来明确联结的类型。 12345# 与前面例子完全相同SELECT vend_name, prod_name, prod_priceFROM vendor INNER JOIN productsON vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; ANSI SQL规范首选INNER JOIN 语法。 15.2.3 联结多个表 SQL对一条SELECT语句中可以联结的表的数目没有限制。首先列出所有表，然后定义表之间的关系。 123456# 显示订单编号为20005的订单中的物品SELECT vend_name, prod_name, prod_price, quantityFROM orderitems, products, vendorWHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005; 性能考虑，联结的表越多，性能下降越厉害。 联结表可以替代子查询。 12345678910111213SELECT cust_name, cust_contactFROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &apos;TNT2&apos;));# 等价于SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num AND prod_id = &apos;TNT2&apos;; 第16章 创建高级联结16.1 创建高级联结 给列起别名的语法如下。 123SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) AS vend_titleFROM vendorsORDER BY vend_name; 给表名起别名，可以缩短SQL语句，并允许在单条SELECT语句中多次使用相同的表。 12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiwhere c.cust_id = o.cust_id AND io.order_num = o.order_nu AND prod_id = &apos;TNT2&apos;; 表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机。 16.2 使用不同类型的联结 前文都是内部联结，下面介绍自联结、自然联结和外部联结。 16.2.1 自联结123456789101112131415# 查询生产ID为DTNTR的供应商的其他物品# 使用子查询SELECT prod_id, prod_nameFROM productsWHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = &apos;DTNTR&apos;);# 使用自联结# 使用两次products表，但用不同的别名SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_id AND p2.prod_id = &apos;DTNTR&apos;; 用自联结而不用子查询，虽然结果相同，但自联结速度更快。 16.2.2 自然联结 自然联结排除列多次出现，使每个列只返回一次。 1234567# 通配符只对第一个表使用，所有其他列明确列出，所有没有重复的列被检索出来SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = &apos;FB&apos;; 到目前为止 每个内部联结都是自然联结，一般不会用到不是自然联结的内部联结。 16.2.3 外部联结 外部联结，联结包含了在相关表中没有关联行的行。 1234# 内部联结 检索所有客户及其订单SELECT customers.cust_id, orders.order_numFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_id; 1234# 外部联结 检索所有客户，包括没有订单的客户SELECT customers.cust_id, orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表，RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表。上例使用LEFT OUTER JOIN从FROM 子句的左边表(customers表)中选择所有行。 不支持*=和=*的使用。 16.3 使用带聚集函数的联结1234567# 检索所有客户及每个客户所下的订单数SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 1234567# 使用左外部联结来包含所有客户，包括没有任何下订单的客户SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 16.4 使用联结和联结条件 注意所使用的联结条件，一般使用内部联结。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡尔积。 使用多个联结时，分别测试每个联结，这将使故障排除更为简单。 第17章 组合查询17.1 组合查询 组合查询，执行多条SELECT语句，并将结果作为单个查询结果集返回，这些组合查询又称并或复合查询。 两种情况需要组合查询： 在单个查询中从不同的表返回类似结构的数据。 对单个表执行多个查询，按单个查询返回数据。 组合查询与具有多个WHERE子句条件的单条查询相同。 17.2 创建组合查询 用UNION操作符来组合数条SQL查询。 17.2.1 使用UNION 给出每条SELECT语句，在各条语句之前放上关键字UNION。 1234567891011121314# 使用UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_in IN (1001, 1002);# 使用多条WHERESELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5 OR vend_in IN (1001, 1002); 17.2.2 UNION规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用UNION分隔。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（列出次序可以不同） 列数据类型必须兼容，类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 17.2.3 包含或取消重复的行 UNION从查询结果集中自动去除了重复的行。可以使用UNION ALL不去除重复的行。 17.2.4 对组合结果排序 在使用UNION组合查询时，只能使用一条ORDER BY子句，必须出现在最后一条SELECT语句之后。 123456789# 使用UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_in IN (1001, 1002)ORDER BY vend_id, prod_price; 第18章 全文本搜索18.1 理解全文本搜索 两个最常用的引擎MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。 如果需要全文本搜索功能，在创建表时选择MyISAM引擎。 通配符和正则表达式存在几个重要的限制： 性能，通配符和正则表达式通常要求尝试匹配表中所有行，行增加时非常耗时。 明确控制，很难明确控制匹配什么和不匹配什么。 智能化的结果。 18.2 使用全文本搜索 为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。 在索引之后，SELECT可与Match()和Against()一起使用以执行搜索。 18.2.1 启用全文本搜索支持 在创建表时启用全文本搜索，CRTATE TABLE语句（第21章介绍）接收FULLTEXT子句。 123456789CRTATE TABLE productnotes( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL, PROMARY KEY(note_id), FULLTEXT(note_text)) ENGINE = MyISAM; MySQL根据子句FULLTEXT(note_text)的指示对note_text进行索引。FULLTEXT可以索引单个或者多个列。MySQL自动维护该索引，在增加、更新或删除行时，索引随之自动更新。 可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立刻索引）。 不要在导入数据时使用FULLTEXT，更新索引比较耗时。 18.2.2 进行全文本搜索 使用函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 1234# 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;rabbit&apos;); 传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）。 搜索默认不区分大小写，除非使用BINARY关键字。 1234# 也使用LIKE 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE note_text LIKE &apos;%rabbit%&apos;; LIKE以不那么有用的顺序返回数据，使用全文本搜索以文本匹配的良好程度排序返回数据。全文本搜索的一个重要部分就是对结果排序，具有较高等级的行先返回。 1234# 全文本搜索排序过程，不包含rabbit的行等级为0，包含rabbit的行中词靠前的行等级高SELECT note_text Match(note_text) Against(&apos;rabbit&apos;) AS rankFROM products; 18.2.3 使用查询扩展 查询扩展用来设法放宽所返回的全文本搜索结果的范围。 使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行。 其次，MySQL检查这些匹配行并选择所有有用的词（如何判定什么有用，什么无用）。 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。 利用扩展查询，能找出可能相关的结果，即使它们并不精确包含所查找的词。 查询扩展功能只用于版本4.1.1或更高版本。 1234# 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;anvils&apos; WITH QUERY EXPANSION); 表中的行越多，使用查询扩展返回的结果越好。 18.2.4 布尔文本搜索 MySQL支持全文本搜索的另一种形式，称为布尔方式。 以布尔方式，可以提供如下内容的细节： 要匹配的词； 要排斥的词； 排列提示； 表达式分组； 另外一些内容。 即使没有FULLTEXT索引也可以使用，但性能比较差。 1234# 匹配词heavy，但排除包含任何以rope开始的词的行SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;heavy -rope*&apos; IN BOOLEAN MODE); 表18-1 全文本布尔操作符 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，而且减少等级值 () 把词组成表达式（允许这些子表达式作为一个组被包含、排除、排列等） ~ 取消一个词的排序词 * 词尾的通配符 “ ” 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 1234# 匹配包含词rabbit和bait的行SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;+rabbit +bait&apos; IN BOOLEAN MODE); 1234# 没有指定操作符，匹配包含rabbit和bait中的至少一个词的行SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;rabbit bait&apos; IN BOOLEAN MODE); 1234# 匹配rabbit和carrot，增加前者的等级，降低后者的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;&gt;rabbit &lt;carrot&apos; IN BOOLEAN MODE); 1234# 匹配safe和combination，降低后者的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;+safe +(&lt;combination)&apos; IN BOOLEAN MODE); 18.2.5 全文本搜索的使用说明 在索引全文本数据时，短语被忽略且从索引中排除，短语定义为具有3个及3个以下字符的词（如果需要，这个数目可以更改）。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略，如果需要，可以覆盖这个列表。 许多词出现的频率很高，搜索它们没有用处（返回太多结果），因此，如果一个词出现在50%的行中，则将它作为一个非用词忽略。%50规则不用于 IN BOOLEAN MODE。 如果表中的行数少于3，则全文本搜索不返回结果。 忽略词中的单引号。例如don’t索引为dont 不具有词分隔符的语言不能恰当地返回全文本搜索结果。 仅在MyISAM引擎中支持全文本搜索。 没有邻近操作符。 第19章 插入数据19.1 数据插入 INSERT语句。 插入完整的行。 插入行的一部分。 插入多行。 插入某些查询的结果。 19.2 插入完整的行 指定表名和被插入到新行中的值。 存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。 各个列必须以它们在表定义中出现的次序填充。 1234567891011# 插入一个新客户到customers表INSERT INTO CustomersVALUES(NULL, &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); 简单但不安全，尽量避免使用，高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息，结构变动后各个列可能不能保持相同的次序。 更安全的方法（不过更繁琐），在表名后的括号里明确给出列名。 1234567891011121314151617# 插入一个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); 提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序，即使表的结构改变，仍能正确工作。 总是使用列的列表。 仔细地给出正确数目的VALUES值。 使用给出列名的这种语法，还可以省略列，可以只给某些列提供值。 该列定义为允许NULL值 在表定义中给出默认值，这表示如果不给出值，将使用默认值 如果对表中不允许NULL值且没有默认值的列不给出值，将会报错 提高整体性能，INSERT操作比较耗时，可以在INSERT和INTO之间添加关键字LOW_PRIORITY，指示降低INSERT的优先级。 19.3 插入多个行 使用多条INSERT语句，一次提交它们，每条语句用一个分号结束。 123456789101112131415161718192021222324252627282930313233# 插入多个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL);INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); 或者，只要每条INSERT语句中的列名和次序相同，可以如下组合各语句。 12345678910111213141516171819202122232425# 插入多个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL)，VALUES( &apos;Pep E. LaPew&apos;, &apos;100 Main Street&apos;, &apos;Los Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); 其中单条INSERT语句有多个值，每组值用一对圆括号括起来，用逗号分隔。此技术可以提高数据库处理的性能，因为用单条INSERT语句处理多个插入比使用多条INSERT语句块。 19.4 插入检索出的数据 利用INSERT语句将一条SELEECT语句的结果插入表中，这就是所谓的INSERT SELECT，即由一条INSERT语句和一条SELECT语句组成。 123456789101112131415161718192021# 从custnew表将所有数据导入到customers表中# 为避免重复，可以将INSERT和SELECT中的cust_id列忽略INSERT INTO customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM custnew; INSERT SELECT中的列名，不一定要求列名匹配，使用的是列的位置，SELECT中的第一列（不管其列名）将会用来填充INSERT表列中指定的第一个列。这对于使用不同列名的表中导入数据非常有用。 INSERT SELECT语句可包含WHERE子句过滤插入的数据。 第20章 更新和删除数据20.1 更新数据 UPDATE语句更新（修改）表中的数据。 更新表中特定行，使用WHERE子句 更新表中所有行 UPDATE语句的组成。 要更新的表 列名和它们的新值 确定要更新行的过滤条件 1234# 更新单个列UPDATE customersSET cust_email = &apos;elmer@fudd.com&apos;WHERE cust_id = 10005; UPDATE后更要更新的表名。SET用来指定新值被赋予的列。WHERE指定特定的行，没有WHERE子句，将会更新所有行。 在更新多个列时，只需要使用单个SET命令，每个 “列=值”对之间用逗号分隔。 12345# 更新两个列UPDATE customersSET cust_email = &apos;elmer@fudd.com&apos;, cust_name = &apos;The Fudds&apos;WHERE cust_id = 10005; UPDATE语句可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。 IGNORE关键字，即使发生错误，也继续进行更新，UPDATE IGNORE customers..。 为删除某个列的值，可设置它为NULL值（假如表定义允许NULL值）。 123UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; 20.2 删除数据 DELETE语句删除（去掉）数据。 从表中删除特定的行，使用WHERE子句 从表中删除所有行 123# 删除一行DELETE FROM customersWHERE cust_id = 10006; DELETE不需要列名和通配符。 DELET 删除整行而不是删除列，为了删除指定的列，使用UPDATE语句。 DELETE从表中删除行，不删除表本身。 如果想要删除表中所有的行，不要使用DELETE，可使用TRUNCATE TABLE语句，它完成同样的工作，但速度更快。 20.3 更新和删除的指导原则 除非打算更新和删除所有行，否则不要使用不带WHERE子句的UPDATE或DELETE语句。 保证每个表都有主键，尽可能像WHERE子句那样使用它。 在对UPDATE或DELETE语句使用WHERE子句前，应先使用SELECT进行测试，保证正确过滤。 使用强制引用完整性的数据库。 没有撤销功能。 第21章 创建和操纵表21.1 创建表 创建表的方法。 使用具有交互式管理和创建表的工具 使用MySQL语句操纵，使用CREATE TABLE语句 21.1.1 表创建基础 创建表，必须给出以下信息。 新表的名字，在关键字CREATE TABLE之后给出 表列的名字和定义，用逗号分隔 1234567891011121314# 创建customers表CREATE TABLE customers(cust_id int NOT NULL AUTO_INCREMENT,cust_name char(50) NOT NULL,cust_address char(50) NULL,cust_city char(50) NULL,cust_state char(5) NULL,cust_zip char(10) NULL,cust_conutry char(50) NULL,cust_contact char(50) NULL,cust_email char(255) NULL,PRIMARY KEY (cust_id)) ENGINE = InnoDB; SQL对缩进空格等格式化没有规定，推荐采用某种缩进格式。 创建表时，指定的表名必须不存在，否则出错。如果表存在，一般首先手工删除表，然后在重建它。如果想仅在表不存在时创建，表名后使用IF NOT EXISTS。 21.1.2 使用NULL值 允许NULL值的列允许在插入行时不给出该列的值，不允许NULL值的列在插入或更新行时，该列必须有值。 创建表时，NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。 NULL值是没有值，而不是空串&#39;&#39;，空串是一个有效的值。 21.1.3 主键再介绍 主键值必须唯一，如果使用单个列，则它的值必须唯一，如果使用多个列，则这些列的组合值必须唯一。 多个列组成的主键，以逗号分隔的列表给出各列名。 12345678910# 多个列组成的主键CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULL,prod_id char(10) NOT NULL,quantity int NOT NULL,item_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num, order_item)) ENGINE = InnoDB 主键可以在创建表时定义，也可以在创建表之后定义。 主键中不允许NULL值的列，允许NULL值的列不能作为唯一标识。 21.1.4 使用AUTO_INCREMENT 设置AUTO_INCREMENT 的列，每当增加一行时自动增量。 每个表只允许一个AUTO_INCREMENT 列，而且它必须被索引，可以通过使它成为主键值。 AUTO_INCREMENT 的列可以在插入时指定一个值，只要它是唯一（至今尚未使用过）即可，该值将被用来替代自动生成的值，后续的增量将开始使用该手工插入的值。 确定AUTO_INCREMENT的值，使用SELECT last_insert_id()返回最后一个AUTO_INCREMENT值，然后可以将该值用于其他MySQL语句。 21.1.5 指定默认值 默认值用CREATE TABLE语句的列定义中的DEFALUT关键字指定。 12345678910# 指定quantity的默认值为1CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULL,prod_id char(10) NOT NULL,quantity int NOT NULL DEFAULT 1,item_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num, order_item)) ENGINE = InnoDB; 不允许使用函数作为默认值，它只支持常量。 使用默认值而不是NULL值。 21.1.6 引擎类型 如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。 InnoDB是一个可靠的事物处理引擎，不支持全文本搜索。 MEMORY在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（适合于临时表）。 MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事物管理。 引擎类型可以混用。 外键不跨引擎。 MyISAM最受欢迎。 21.2 更新表 使用ALTER TABLE更新表定义，但是，理想状态下，当表中存储数据以后，该表就不应该别更新。 使用ALTER TABLE更改表结构，需给出以下信息。 在ALTER TABLE之后给出要更改的表名（该表必须存在）。 所做更改的列表。 123# 给表添加一个名为vend_phone的列，必须明确数据类型ALTER TABLE vendorsADD vend_phone CHAR(20); 123# 删除列ALTER TABLE vendorsDROP COLUMN vend_phone; 使用ALTER TABLE 定义外键。 1234567ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num);ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_productsFOREIGN KEY (prod_id) REFERENCES products (prod_id); 复杂的表结构更改需要手动删除过程，步骤： 用新的列布局创建一个新表； 使用INSERT SELECT语句从旧表复制数据到新表，如果有必要，可使用转换函数和计算字段； 检验包含所需数据的新表； 重命名旧表（如果确定，可以删除它）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。 使用ALTER TABLE前应该做一个完整的备份，因为数据表的更改不能撤销。 21.3 删除表 使用DROP TABLE 语句。DROP TABLE customers2，删除表没有确认，也不能撤销。 21.4 重命名表 使用RENAME TABLE语句。 1234567# 重命名一个表RENAME TABLE customers2 TO customers;# 重命名多个表，使用逗号分隔RENAME TABLE backup_customers TO customers, backup_vendors TO vendors, backup_produts TO products; 第22章 使用视图22.1 视图 版本要求，MySQL5及之后版本添加了对视图的支持。 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 1234567891011SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num AND prod_id = &apos;TNT2&apos;; # 假如可以把以上整个查询包装成一个productcustomers的虚拟表，则可以从虚拟表中检索数据# productcustomers是一个视图SELECT cust_name, cust_contactFROM productcustomersWHERE prod_id = &apos;TNT2&apos;; 22.1.1 为什么使用视图 重用SQL语句。 简化复杂的SQL操作。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用于表基本相同的方式利用他们，可以执行SELECT，过滤和排序，联结，甚至是添加和更新数据的操作。 性能问题。视图不包含数据，每次使用视图时，都必须处理查询执行时所需的任一个查询，如果使用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。 22.1.2 视图的规则和限制 与表一样，视图必须唯一命名。 对于可创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常有数据库管理人员授予。 视图可以嵌套。 ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY 将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。 22.2 使用视图 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname，来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图，如果要更新的视图存在，则第2条语句会替换原有视图。 22.2.1 利用视图简化复杂的联结 视图最常用的应用之一是隐藏复杂的SQL。 12345678910111213# 创建名为productcustomers的视图，联结三个表，以返回以订购了任意产品的所有客户的列表CREATE VIEW productcustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num; # 如果执行 SELECT * FROM productcustomers，将列出订购了任意产品的客户# 检索订购了产品TNT2的客户SELECT cust_name, cust_contactFROM productcustomersWHERE prod_id = &apos;TNT2&apos;; 创建可重用的视图是一种好方法。 22.2.2 用视图重新格式化检索出的数据 视图的另一常见用途是重新格式化检索出的数据。 12345# 返回供应商名和位置（来自第10章）SELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) AS vend_titleFROM vendorsORDER BY vend_name; 假如要经常使用这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。 12345678910# 创建视图 返回供应商名和位置CREATE VIEW vendorlocations ASSELECT Concat(RTrim(vend_name), &apos;(&apos;, RTrim(vend_country), &apos;)&apos;) AS vend_titleFROM vendorsORDER BY vend_name;# 检索所有供应商和位置的数据SELECT * FROM vendorlocations; 22.2.3 用视图过滤不想要的数据 视图也可以使用WHERE子句过滤数据。 123456789# 创建视图，排除没有电子邮件地址的用户CREATE VIEW customeremaillist ASSELECT cust_id, cust_name, cust_emailFROM customersWHERE cust_email is NOT NULL;# 检索SELECT * FROM customeremaillist 如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。 22.2.4 使用视图与计算字段 视图对于简化计算字段的使用特别有用。 1234567891011121314151617181920# 检索某个特定订单中的物品，计算每种物品的总价格（来自第10章）SELECT prod_id, quantity, item_price, quantity*item_price AS expand_priceFROM orderitemsWHERE order_num = 20005;# 将其转化为一个视图CREATE VIEW orderitemsexpanded AS SELECT prod_id, quantity, item_price, quantity*item_price AS expand_priceFROM orderitems;# 检索订单20005的详细内容SELECT *FROM orderitemsexpandedWHERE order_num = 20005; 22.2.5 更新视图 视图的数据是否可以更新是视情况而定。 通常，视图是可以更新的，更新一个视图将更新其基表（视图本身没有数据）。 但是，并非所有视图都是可更新的，如果不能正确地确定被更新的基数据，则不允许更新。 如果视图定义中有以下操作，将不能更新： 分组（GROUP BY 和HAVING） 联结 子查询 并 聚集函数（MIN()、COUNT()、SUM() 等） DISTINCT 导出（计算）列 视图主要用于数据检索（SELECT），很少用于更新（INSERT、UPDATE和DELETE）。 第23章 使用存储过程23.1 存储过程 MySQL添加了对存储过程的支持，支持MySQL5及以后的版本。 存储过程，就是为以后的使用而保存的一条或多条MySQL语句的集合，可将其视为批文件。 23.2 为什么要使用存储过程 存储过程的好处： 通过把处理封装在容易使用的单元中，简化复杂的操作。 由于不要求反复建立一系列处理步骤，保证了数据的完整性，所有开发人员和应用程序都使用同一的存储过程，则所使用的代码都是相同的。 防止错误，需要执行的步骤越多，出错的可能性就越大。 简化对变动的管理，如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码。通过对存储过程限制对基础数据的访问保证了安全性。 提高性能，使用存储过程比适用单独的SQL语句要快。 总结：简单，安全，高性能。 存储过程的缺陷： 编写比基本的SQL语句复杂。 MySQL将编写和执行存储过程的安全和访问区分开来，你可能没有创建存储过程的安全访问权限。 不能编写存储过程，但仍然可以使用。 23.3 使用存储过程23.3.1 执行存储过程 调用，CALL，接受存储过程的名字以及需要传递给它的任意参数。 1234# 执行名为productpricing的存储过程，返回产品的最低、最高和平均价格CALL productpricing(@pricelow, @pricehigh, @priceaverage); 存储过程可以显示结果，也可以不显示结果。 23.3.2 创建存储过程123456# 返回平均价格的存储过程，名为productpricing，没有参数CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 因为存储过程的语句结束分隔符也为;，需要临时更改语句结束分隔符。除 \ 符号外，任何字符都可以作为语句分隔符。 1234567891011# 告诉命令行使用 // 作为新的语句结束分隔符DELIMITER //# 返回平均价格的存储过程，名为productpricing，没有参数CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END//# 恢复为原来的语句结束分隔符DELIMITER ; 12# 调用存储过程CALL productpricing(); 23.3.3 删除存储过程 存储过程创建后，被保存在服务器上以供使用，直至被删除。 删除存储过程，DROP PROCEDURE productpricing;。存储过程名后不带()，只给出存储过程名。 仅当存在时删除，DROP PROCEDURE IF EXISTS productpricing。 23.3.4 使用参数 一般地，存储过程并不显示结果，而是把结果返回给你指定的变量。 变量，内存中一个特定的位置，用来临时存储数据。 123456789101112131415161718# 以下是productpricing的修改版本，如果不事先删除此存储过程，则不能再次创建它# 此存储过程接受三个参数，pl存储最低价格，ph存储最高价格，pa存储最高价格CREATE PROCEDURE productpricing(OUT pl DECIMAL(8,2),OUT ph DECIMAL(8,2),OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 每个参数必须具有指定的类型，关键字OUT指出相应的参数用来从存储过程传出一个值，返回给调用者。 IN（传递给存储过程），OUT（从存储过程传出），INTO（对存储过程传入和传出）。 记录集是不允许的类型，不能通过一个参数返回多个行和列。 12345678# 调用此修改过的存储过程，需指定三个变量名CALL productpricing(@pricelow, @pricehigh, @priceavgerage);# 调用时不现实任何数据，返回可以显示的变量，显示产品的平均价格SELECT @priceaverage;# 显示三个值SELECT @pricehigh, @pricelow, @priceaverage; MySQL的所有变量都必须以@开始。 使用IN和OUT参数 1234567891011121314151617181920# 使用IN和OUT参数，ordertotal接受订单号并返回该订单的合计# onumber定义为IN，订单号被传入存储过程# ototal定义为OUT，从存储过程返回合计CREATE PROCEDURE ordertotal( IN onumber INT OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;# 调用这个存储过程# 第一个参数为输入订单号，第二个参数为返回计算出来的合计的变量名CALL ordertotal(20005, @total);# 显示此合计SELECT @total 23.3.5 建立智能存储过程 包含业务规则和智能处理的存储过程。 12345678910111213141516171819202122232425262728293031323334353637# name: ordertotal# parameters: onumber = order number# taxable = 0 if not taxable, 1 if taxable# ototal = order total variableCREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, OUT ototal DECIMAL(8,2))COMMENT &apos;Obtain order total, optionally adding tax&apos; # COMMENT不是必须的，如果给出，将在SHOW PROCEDURE STATUS的结果中显示BEGIN # Declare variable for total DECLARE total DECIMAL(8,2); # Declare tax percentage DECLARE taxrate INT DEFAULT 6; # Get the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO total; # Is this taxable IF taxable THEN # Yes, so add taxrate to the total SELECT total+(total/100*rate) INTO total END IF; # And finaly, save to out variable SELECT total INTO ototal;END;# 调用，通过给中间的参数指定0或1，可以有条件地将营业税加到合计上CALL ordertotal(2005, 0, @total);SELECT @total;CALL ordertotal(2005, 1, @total);SELECT @total; 23.3.6 检查存储过程 显示用来创建一个存储过程，的CREATE语句。SHOW CREATE PROCEDURE ordertotal。 获得包括何时、由谁创建等详细信息的所有存储过程列表，使用SHOW PROCEDURE STATUS。 使用LIKE指定一个过滤模式，列出指定的存储过程，使用SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;。 第24章 使用游标24.1 存储过程 版本MySQL5及之后的版本支持。 使用游标的原因，需要在检索出来的行中前进或后退一行或多行。 游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或作出更改。 MySQL的游标只能用于存储过程（和函数）。 24.2 使用游标 使用前需要声明（定义）游标。 声明后，需要打开游标以供使用。 对于填有数据的游标，根据需要取出（检索）各行。 在结束游标使用时，必须关闭游标。 24.2.1 创建游标 游标用DECLARE语句创建，并定义响应的SELECT语句，根据需要带WHERE和其他子句。 1234567# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 存储过程处理完成后，游标就消息（因为它局限于存储过程），在定义游标之后，可以打开它。 24.2.2 打开和关闭游标 使用OPEN CURSOR语句打开游标。如OPEN ordernumbers。在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。 关闭游标，CLOSE ordernumbers。CLOSE释放游标使用的所有内部内存和资源，游标不需要时应该关闭。 隐含关闭，如果不明确关闭游标，将会在到达END语句时自动关闭。 1234567891011121314# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 关闭游标 CLOSE ordernumbers;END; 24.2.3 使用游标数据 使用FETCH语句分别访问它的每一行，FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行。 从游标中检索单个行。 1234567891011121314151617# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 检索当前行的order_num列（自动从第一行开始）到一个名为o的局部声明的变量中。 FETCH ordernumbers INTO o # 关闭游标 CLOSE ordernumbers;END; 循环检索数据，从第一行到最后一行。 12345678910111213141516171819# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 循环检索 REPEAT FETCH ordernumbers INTO o; UNTIL done END REPEAT; # 关闭游标 CLOSE ordernumbers;END; 需设置变量done为真的停止条件。 123# 定义了CONTINUE HANDLER，指出当SQLSTATE &apos;02000&apos;出现时，SET done 1,# SQLSTATE &apos;02000&apos;是一个未找到条件DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done = 1; DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。 更详细的游标存储过程样例。 123456789101112131415161718192021222324252627282930313233343536373839# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 定义局部变量 DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 定义句柄 DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done = 1; # 创建一个表保存结果 CREATE TABLE IF NOT EXISTS ordertotals( order_num INT, total DECIMAL(8,2)); # 打开游标 OPEN ordernumbers; # 循环检索 REPEAT # 获取订单号 FETCH ordernumbers INTO o; # 获取该订单号的带税的合计，该存储过程在前一章创建 CALL ordertotal(o, 1, @t); # 将订单号和订单合计插入ordertotals结果表中 INSERT INTO ordertotals(order_num, total) VALUES(o, t); UNTIL done END REPEAT; # 关闭游标 CLOSE ordernumbers;END; 此存储过程不返回数据，但它能够创建和填充另一个表。查看该表，SELECT * FROM ordertotals。 第25章 使用触发器25.1 触发器 MySQL5或之后的版本支持触发器。 希望某条语句（或某些语句）在事件发生时自动执行。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE INSERT UPDATE 其他MySQL语句不支持触发器。 25.2 创建触发器 在创建触发器时，需要给出四条信息： 唯一的触发器名 触发器关联的表 触发器应该响应的活动（DELETE、INSERT或UPDATE） 触发器何时执行（处理之前或之后） 触发器在每个表中唯一，在数据库中的两个表可以具有相同名字的触发器。但最好在数据库范围内使用唯一的触发器名。 触发器用CREATE TRIGGER语句创建。 12345# 创建名为newproduct的触发器，将在INSERT语句执行后执行# 指定FOR EACH ROW SELECT，对每个插入行执行# 本文Product added对每个插入行显示一次CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT &apos;Product added&apos;; 只有表才支持触发器，视图不支持（临时表也不支持）。 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器，每个表最多支持6个触发器（每天INSERT、UPDATE和DELETE的之前和之后）。 单个触发器不能与多个事件或多个表关联，如果你需要对一个INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 25.3 删除触发器 使用DROP TRIGGER 语句。如DROP TRIGGER newproduct。 触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。 25.4 使用触发器25.4.1 INSERT触发器 INSERT 触发器在INSERT语句执行之前或之后执行。 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行。 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）。 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 12345678910# 创建一个名为neworder的触发器# 插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中# 触发器从NEW.order_num取得这个值并返回它CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num;# 插入一个新行# orders包含3行，order_date和 cust_id必须给出，order_num由MySQL自动生成INSERT INTO order(order_date, cust_id)VALURES(now(), 10001) 25.4.2 DELETE触发器 DELETE触发器在DELETE语句执行之前或之后执行。 在DELETE触发器代码内，可引用一个名为OLD的虚拟表，访问被删除的行。 OLD中的值全都是只读的，不能更新。 1234567# 在任意订单被删除前将执行此触发器，它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到archive_orders存档表中CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; 使用BEGIN 和 END语句的好处是触发器能容纳多条SQL语句。 25.4.3 UPDATE触发器 UPDATE 触发器在UPDATE语句执行之前或之后执行。 在UPDATE触发器代码内，可引用一个名为OLD的虚拟表访问以前的值，引用一个名为NEW的虚拟表访问被新更新的值。 在BEFORE UPDATE触发器中，NEW中的值也可以被更新（允许更改被插入的值）。 OLD中的值全都是只读的，不能更新。 123# 保证输入的州名是大写，不管输入是大写还是小写CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state) 25.4.4 关于触发器的进一步介绍 创建触发器可能需要特殊的安全访问权限。但是触发器的执行时自动的。 用触发器保证数据的一致性（大小写、格式等）。 触发器可以创建审计跟踪，把更改记录到另一个表非常容易。 触发器不支持CALL语句。 第26章 管理事务处理26.1 事务处理 MyISAM和InnoDB是两种最常使用的引擎，前者不支持明确的事务处理管理，后者支持。 事务处理用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 利用事务管理，可以保证一组操作不会中途停止，它们作为整体执行，或者完全不执行。 如果没有发生错误，整组语句提交给数据库表，如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。 事务（transaction）：一组SQL语句。 回退（rollback）：撤销指定SQL语句的过程。 提交（commit）：将未存储的SQL语句结果写入数据库表。 保留点（savepoint）：事务处理中设置的临时占位符（placeholder），你可以对它发布回退。 26.2 控制事务处理 关键在于将SQL语句分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。 使用START TRANSACTION来标识事务的开始。 26.2.1 使用ROLLBACK 使用ROLLBACK来回退（撤销）MySQL语句。 123456SELECT * FROM ordertotals; # 显示表ordertotals不为空START TRANSACTION; # 开始一个事务处理DELETE FROM ordertotals; # 删除ordertotals中的所有行，注意不是删除表SELECT * FROM ordertotals; # 验证ordertotals确实为空ROLLBACK; # 回退START TRANSACTION之后的所有语句SELECT * FROM ordertotals; # 显示表ordertotals不为空，回退成功 ROLLBACK 只能在一个事务处理内使用（执行一条START TRANSACTION 命令之后）。 事务管理用来管理INSERT、UPDATE和DELETE语句。 不能回退SELECT语句、CREATE和DROP操作。 26.2.2 使用COMMIT 一般的MySQL语句都是隐含提交的，即提交（写或保存）操作都是自动的。 但事务处理块中，提交不会隐含地进行，使用COMMIT语句进行明确的提交。 12345# 使用COMMIT语句仅在不出错时写出更改START TRANSACTION;DELETE FROM orderitems WHERE order_num = 20010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 26.2.3 使用保留点 复杂的事务处理可能需要部分提交或回退。 为了支持回退部分事务处理，必须能在事务处理块中合适位置放置占位符，如果需要回退，可以回退到某个占位符。 创建占位符，使用SAVEPOINT，例如SAVEPOINT delete1;。 每个保留点都标识它的唯一名字。 回退到保留点，ROLLBACK TO delete1;。 保留点越多越好，越灵活。 保留点在事务处理完成后自动释放，也可以用RELEASE SAVEPOINT明确地释放保留点。 26.2.4 更改默认的提交行为 MySQL默认自动提交所有更改。 为只是MySQL不自动提交更改，使用SET autocommit=0;。 第27章 全球化和本地化27.1 字符集和校对顺序 MySQL需要适应不同的字符集，适应不同的排序和检索数据的方法。 字符集：字母和符号的结合。 编码：某个字符集成员的内部表示。 校对：规定字符如何比较的指令。 使用何种字符集合校对的决定在服务器、数据库和表级进行。 27.2 使用字符集和校对顺序 查看所支持的字符集完整列表，SHOW CHARACTER SET;。 查看所支持校对的完整列表，SHOW COLLATION。 可以在安装时定义一个默认的字符集和校对，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，使用语句，SHOW VARIABLES LIKE &#39;character%&#39;和SHOW VARIABLES LIKE &#39;collation%&#39;。 给表指定字符集和校对，使用带子句的CREATE TABLE。 123456CREATE TABLE mytable(column1 INT,column2 VARCHAR(10)) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 除了可以给表指定字符集和校对，还可以对每个列设置它们。 12345678CREATE TABLE mytable(column1 INT,column2 VARCHAR(10),column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci;) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 校对在用ORDER BY子句检索出来的数据排序时起重要的作用。 123# 使用与创建表时不同的校对顺序排序特定的SELECT语句SELECT * FROM customersORDER BY lastname, firstname COLLATE latin1_general_cs; 第28章 安全管理28.1访问控制 安全基础：用户应该对他们需要的数据具有恰当的访问权，既不能多也不能少。用户不能对过多的数据具有过多的访问权。 访问控制：给用户提供他们所需的访问权，且仅提供他们所需的访问权。 不要在日常操作中使用root。 28.2 管理用户 获取所有用户账户列表。 123# mysql数据库有一个名为user的表，它包含所有用户账号USE mysql;SELECT user FROM user; 28.2.1 创建用户账户 创建新用户。 12# 创建一个新用户，用户名ben，口令p@$$wordCREATE USER ben IDENTIFIED BY &apos;p@$$word&apos;; IDENTIFIED BY为纯文本口令，为了作为散列指定加密口令，使用IDENTIFIED BY PASSWORD。 重命名用户名。使用RENAME USER ben TO bforta;。 28.2.2 删除用户账户 使用DROP USER语句，如DROP USER bforta;。 28.2.3 设置访问权限 新创建的用户没有访问权限。 查看赋予用户的权限，SHOW GRANTS FOR bforta;。 用户定义为user@host。默认主机名为%。 为设置权限，使用GRANT语句，需给出以下信息： 要授予的权限。 被授予访问权限的数据库或表。 用户名。 12345# 允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECTGRANT SELECT ON crashcourse.* TO bforta;# 查看添加的权限SHOW GRANTS FOR bforta; 撤销特定的全效，使用REVOKE语句。REVOKE SELECT ON crashcourse.* FROM bforta;，撤销了bforta的SELECT访问权限。 GRANT 和REVOKE可在几个层次上控制访问权限。 整个服务器，使用GRANT ALL 和 REVOKE ALL。 整个数据库，使用ON database.*。 特定的表，使用ON database.table。 特定的列。 特定的存储过程。 28.2.4 更改口令 使用SET PASSWORD，新口令必须使用Password加密：SET PASSWORD FOR bforta = Password(&#39;n3w p@$$word&#39;)。 设置自己的口令：SET PASSWORD = Password(&#39;n3w p@$$word&#39;)。 第29章 数据库维护29.1 备份数据 使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。 可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据。 可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。 29.2 进行数据库维护 ANALYZE TABLE，用来检查表键是否正确。 CHECK TABLE，用来针对许多问题对表进行检查。 29.3 诊断启动问题 服务器启动问题通常在对MySQL匹配或服务器本身进行更改时出现。 排除系统启动问题时，首先应该尽量用手动启动服务器。 mysql命令行选项。 —help显示帮助。 —safe -mode装载减去某些最佳配置的服务器。 —verbose显示全文本信息。 —version显示版本信息。 29.4 查看日志文件 错误日志。—log-error 查询日志。—log 二进制日志。—log- bin 缓慢查询日志。—log-slow-queries 第30章 改善性能30.1 改善性能 运行在专用服务器上。 调整内存分配、缓冲区大小。 显示所有活动进程，KILL命令终结某个特定的进程。 使用联结、并、子查询等方法编写SELECT语句。 使用存储过程。 使用正确的数据类型。 不要检索比需求还要多的数据，尽量不要用SELECT *。 使用DELAYED关键字。 导入数据时，应该关闭自动提交。 索引数据库表以改善数据检索的性能。 使用多条SELECT语句和联结它们的UNION语句来替代一系列复杂的OR语句。 LIKE很慢，最好使用FULLTEXT。 每条规则在某些条件下都会被打破。]]></content>
      <categories>
        <category>StudyNotes</category>
      </categories>
      <tags>
        <tag>StudyNotes</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-赫夫曼树及赫夫曼编码]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 赫夫曼树先看如下两棵树： 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。 二叉树 a 中， 根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。 树的路径长度就是从树根到每一结点的路径长度之和 。 二 叉树 a 的树路径长度就为 1+1+2+2+3+3+4+4=20。二叉树 b 的树路径长度就为1+2+3+3+2+1+2+2=16。 考虑到带权的结点，结点的带权的路径长度为该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值$\{w_1,w_2,…,w_n\}$，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 $W_k$，每个叶子的路径长度为 $l_k$，则其中带权路径长度(WPL)最小的二叉树称做赫夫曼树，也称为最优二叉树。 二叉树 a 的 $WPL=5 1+15 2+40 3+30 4+10 * 4 = 315 $ 二叉树 b 的 $WPL=5 3+ 15 3+40 2+30 2+ 10 * 2 = 220 $ 2 赫夫曼树构造方法 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即 : A5，E10 , B15 , D30, C40。 取头两个最小权值的结点作为一个新节点 N1的两个子结点， 注意相对较小的 是左孩子，这里就是 A 为 N1 的左孩子， E 为 N1的右孩子，如图 6-12-5 所 示。新结点的权值为两个叶子权值的和 5+10=15。 将 N1替换 A 与 E，插入有序序列中， 保持从小到大排列。 即: N1-15, B-15 , D-30, C-40。 重复步骤 2. 将 N1 与 B 作为一个新节点 N2的两个子结点。 如图 6-12-6 所 示。 N2 的权值=15+15=30。 将 N2 替换 N1 与 B ，插入有序序列中， 保持从小到大排列。 即: N2-30 , D-30, C-40。 重复步骤 2. 将 N2 与 D 作为一个新节点 N3 的两个子结点。 如图 6-12-7 所示。 N3 的权值=30+30=60。 将 N3替换 N2与 D，插入有序序列中，保持从小到大排列。即 : C-40 , N3-60。 重复步骤 2。将 C 与 N3 作为一个新节点 T 的两个子结点，如图 6-12-8 所示。 由于 T 即是根结点，完成赫夫曼树的构造。 构造赫夫曼树的赫夫曼算法描述： 根据给定的 n 个权值$\{w_1,w_2,…,w_n\}$构成 n 棵二叉树的集合 $F = \{T_1,T_2,…,T_n\}$， 其中每棵二叉树 $T_i $中只有一个带权为 $w_i$根结点，其左右子树均为空。 在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且 置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。 重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。 3 赫夫曼编码用于压缩和解压缩文件，把要压缩的文本进行重新编码，以减少不必要的空间。比如我们有一段文字内容为 “BADCADFEED” 要网络传输给别人，显然用二进制 的数字 (0 和 1) 来表示是很自然的想法。我们现在这段文字只有六个字母 ABCDEF，那么我们可以用相应的二进制数据表示： 这样真正传输的数据就是编码后的 “001000011010000011101100100011“， 对 方接收时可以按照 3 位划分来译码。效率低下。 根据不同词频使用赫夫曼树重新编码。 假设六个字母的频率为 A 27 , B 8, C 15 , D 15 , E 30, F 5 ，合起来正好是 100%。 那就意味着，我们完全可以重新按照赫夫曼树来规划它们。 以下左图为按照第2节的赫夫曼树构造方法得到的赫夫曼树，右图为将所有左分支改为0，右分支改为1后的赫夫曼树。 对着六个字母重新编码如下： 我们将文字内容为 “BADCADFEED” 再次编码，对比可以看到结果串变小了 。 原编码二进制串 :001000011010000011101100100011(共30个字符) 新编码二进制率: 1001010010101001000111100(共 25 个字符) 数据被压缩了。 4 赫夫曼解码前缀编码：编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。 在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。 当我们接收到 1001010010101001000111100 时，按约定好的赫夫曼树可知， 1001 得到第一个字母是 B，接下来的01意味着第二个字符是 A，如图 6-12-10 所示， 其余的也相应的可以得到，从而成功解码。 5 赫夫曼编码定义一般地，设需要编码的字符集为$\{d_1,d_2,…,d_n\}$，各个字符在电文中出现的次数或频率集合为$\{w_1,w_2,…,w_n\}$ ，以 $d_1,d_2,…,d_n$作为叶子结点，以 $w_1,w_2,…,w_n$ 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1， 则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1—&gt;0k+2—&gt;1n-1 —&gt; n-k-20 — &gt; n-k-1 k-1 —&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是字符串相关题目题解总结。 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑&#39;*&#39;：如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符&#39;*&#39;考虑进去，它可以匹配任意次的字符，当然出现0次也可以：而当模式中的第二个字符是*时：如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 模式后移2字符，相当于x*被忽略； 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符’.’的情况。 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为’.’的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) —&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。 Python 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False Java12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array.length == 0) return false; int row = array.length - 1; int col = 0; while(row &gt;= 0 &amp;&amp; col &lt; array[0].length) &#123; if(array[row][col] == target) return true; else if (array[row][col] &gt; target) row -= 1; else col += 1; &#125; return false; &#125;&#125; 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1. Python 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 Java 1234567891011121314151617181920212223import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; if(array.length == 1) return array[0]; int left = 0; int right = array.length-1; while(left &lt;= right) &#123; int mid = (left+right)/2; if(array[mid] &lt; array[mid-1]) return array[mid]; else if (array[mid] &gt; array[right]) left = mid + 1; else right = mid - 1; &#125; return 0; &#125;&#125; 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here return self.Msort(data, 0, len(data)-1) %1000000007 def Msort(self, data, left, right): if left &gt;= right: return 0 mid = left + (right-left) // 2 l = self.Msort(data, left, mid) r = self.Msort(data, mid+1, right) return l + r + self.merge(data, left, mid, right) def merge(self, data, left, mid, right): res = 0 i, j = left, mid+1 temp = [] while i &lt;= mid and j &lt;= right: if data[i] &lt; data[j]: temp.append(data[i]) i += 1 else: res += (mid-i+1) temp.append(data[j]) j += 1 temp += data[i:mid+1] if i!=mid+1 else data[j:right+1] data[left:right+1] = temp[:] return res 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data) &lt;= 1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data, temp, 0, len(data) - 1) % 1000000007 def MSort(self, data, temp, low, high): if low &gt;= high: temp[low] = data[low] return 0 mid = (low + high) // 2 left = self.MSort(temp, data, low, mid) right = self.MSort(temp, data, mid + 1, high) return left + right + self.merge(data, temp, low, mid, high) def merge(self, data, temp, low, mid, high): count = 0 i = low j = mid + 1 index = low while i &lt;= mid and j &lt;= high: if data[i] &lt;= data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid - i + 1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = (left+right)//2 if data[mid] == k: count = 0 for i in range(left, right+1): if data[i] == k: count += 1 return count elif data[mid] &gt; k: right = mid-1 else: left = mid+1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False seen = [] for x in numbers: if x not in seen: seen.append(x) else: duplication[0] = x return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习小结]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一 基本概念1 完整机器学习项目的流程 明确要解决的问题，并将问题抽象成数学问题。主要是明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题。 获取数据。我们知道数据决定了机器学习结果的上限，而算法模型只是尽可能地逼近这个上限。数据要有代表性，否则可能会出现过拟合。 特征预处理与特征选择。比如对于分类问题，数据偏斜不能太严重，不同类型的数据数量最好不能有数个数量级的差距，不平衡数据后面要进行处理，主要包括欠采样，过采样和调整权值。还有可能需要对数据进行归一化，标准化，离散化，缺失值处理等，对特征筛选，选出显著特征，运用相关系数，卡方检验，平均互信息等方法。 训练模型与调优。 模型诊断。比如使用交叉验证，绘制学习曲线判断模型是否过拟合，欠拟合了。 过拟合的基本调优思路是增加数据量，降低模型复杂度；欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。以及通过观察误差样本，分析误差产生的原因，是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题。 上线运行与维护。这时不仅需要考虑准确程度，误差等情况，还需要考虑模型的时间和空间复杂度以及稳定性是否可以接受。 Note： 相关系数，卡方检验，平均互信息都是用于检验两个变量独立性的方法，用于去除相关变量。 2 有监督学习和无监督学习 有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类或预测。如逻辑斯蒂回归，SVM，随机森林等。 无监督学习：对未标记的样本进行学习，以发现这些样本中的内在性质及结构知识。如聚类，密度估计等 Note： 半监督学习：训练数据同时包含有标记样本和未标记样本数据，让学习器不依赖外界交互，自动地利用未标记样本来提升学习性能。 强化学习：给定数据，学习如何选择一系列行动，以最大化长期受益。例如马尔科夫决策过程，动态规划。 3 判别式模型和生成式模型 判别模型：由数据直接学习决策函数 $Y=f(X)$ 或条件概率分布 $P(Y|X)$ 作为预测模型。 生成模型：由数据学习联合概率分布 $P(X,Y)$，然后求出条件概率分布 $P(Y|X)$ 作为预测模型：P(Y | X)=\frac{P(X, Y)}{P(X)} 由生成模型可以得到判别模型，但是由判别模型得不到生成模型。 判别模型：K近邻，SVM，决策树，逻辑斯蒂回归，最大熵模型，提升方法和条件随机场等。 生成模型：朴素贝叶斯，隐马尔可夫模型，高斯混合模型，文档主题生成模型，限制玻尔兹曼机。 优缺点：生成模型优点：因为结果给出的是联合分布，不仅能计算条件分布，还可以给出其它信息（比如边缘分布）。收敛速度比较快，当样本数量较多时，可以更快地收敛于真实模型。能够应付隐变量存在的情况，如高斯混合模型（Gaussian Mixture Model）。缺点：需要更多的样本和计算，尤其是为了更准确估计类别条件分布，需要增加样本的数目。 判别模型优点：节省计算资源，需要的样本数量少于生成模型。准确率比生成模型高。由于直接预测结果的概率，而不需要求解每一个类别的条件概率，所以允许对数据进行抽象（比如降维、构造等）。缺点：生成模型的优点它都没有。 4 通俗易懂解释机器学习机器学习就像婴儿学走路。每次他们摔倒，他们就会学到（无知觉地）并且明白，他们的腿要伸直，而不能弯着。他们下一次在摔倒，摔疼了，摔哭了，但是它们学会了“不要用那种姿势站着”，为了避免摔疼，他们更加努力尝试，为了站稳，他们还扶着门或者墙壁或者任何靠近他们的东西。这同样也是一起机器如何在环境中学习和发展它的直觉的。 5 给定一个数据集，如何选择算法 机器学习算法的选择取决于学习任务和数据的类型，是分类问题还是回归问题（分类就先从常用的分类模型里选择），如果给定的一个数据集是线性的，线性回归是最好的选择，如果是图像或者音频，那么神经网络可以构建一个稳健的模型。如果该数据是非线性互相作用的的，可以用boosting或bagging算法。如果业务需求是要构建一个可以部署的模型，我们可以用回归或决策树模型（容易解释和说明），而不是黑盒算法如SVM，GBM等。 总之，没有一个一劳永逸的算法。我们必须有足够的细心，去了解到底要用哪个算法。 6 线性分类器与非分类器的区别以及优劣 线性和非线性是针对模型参数和输入特征来讲的，比如输入x，模型y=ax+b为线性模型，模型y=ax+bx^2则是非线性模型。 线性分类器可解释性好，计算复杂度较低，不足之处是模型的拟合效果相对弱些。 非线性分类器拟合效果较强，不足之处是数据量小时容易过拟合，计算复杂度高，可解释性不好。 Note 常见的线性分类器有：贝叶斯分类，单层感知机，线性回归，逻辑斯蒂回归。 常见的非线性分类器有：决策树，随机森林，GBDT，多层感知机。 SVM两种都有，看使用和核函数是线性核还是高斯核。 7 有隐含关联的事件举例美国的太太们常叮嘱她们的丈夫下班后为小孩买尿布，而丈夫们在买尿布后又随手带回了两瓶啤酒。这一消费行为导致了这两件商品经常被同时购买，所以，沃尔玛索性就将它们放在了一块，既方便了顾客，更提高了产品销量。这说明数据能告诉我们消费者的潜在需求，这可能是人很难直接发现的。 8 TensorFlow简介TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算，TensorFlow为张量从流图的一端流动到另一端计算过程。TensorFlow是将复杂的数据结构传输至人工智能神经网中进行分析和处理过程的系统。 9 数据流图（Data Flow Graph）数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 10 TensorFlow的优缺点 优点：高度的灵活性，真正的可移植性（Portability），自动求微分，多语言支持，其核心代码是c++编写的，执行效率比较高，同时有其他语言的接口。 缺点：使用Python时效率比较低，每一个mini-batch要从Python中feed到网络中，这个过程在mini-batch的数据量很小或者运算时间很短时，可能会带来影响比较大的延迟。 11 病态问题 训练完的模型，测试样本稍作修改就会得到差别较大的结果，就是病态问题。 模型对未知数据的预测能力很差，即泛化误差大。 12 VC维 VC维是模型的复杂程度，模型假设空间越大，VC维越高。某种程度上，VC维给机器学习科学性提供了理论支撑。 测试集合的loss是否和训练集合的loss接近？VC维越小，理论越接近，越不容易过拟合。 训练数据的loss是否可以足够小？VC维越大，loss理论越小，越不容易欠拟合。 我们对模型添加的正则化可以对模型的复杂度（VC维）进行控制，平衡这两部分。 13 机器学习的各种模型与各自的损失函数一一对应 可以把机器学习视作表达和优化，其中表达的部分，各种模型会有各种不同的形态（线性回归，逻辑回归，SVM，树模型） 当确定了用某个模型（比如逻辑斯蒂回归）去解决问题，你需要知道当前模型要达到更好的效果需要怎么优化，这个时候就要借助损失函数了。 14 超参数和参数的区别 超参数是为了定义模型，需要提前敲定的东西（比如多项式拟合的最高次数，SVM选择的核函数）。 参数是你确定了超参数之后（比如用最高3次的多项式回归），学习到的参数（比如多项式回归的系数）。 15 最小二乘法最小二乘法的主要思想：计算未知参数，使得理论值和观测值之差的平方和达到最小。 \min _{\vec{x}}\left\|\vec{y}_{m}(\vec{x})-\vec{y}\right\|_{2}16 协方差和相关性的区别 协方差可以理解为两个变量在变化过程中是同方向变化还是反方向变化，以及同向或反向变化的程度如何。 相关性是剔除了量纲影响、标准化后的协方差。它也可以反映两个变量变化是同向还是反向的，它消除了两个变量变化幅度的影响，可以单纯反映两个变量每单位变化时的相似程度。\Sigma_{i j}=\operatorname{cov}\left(X_{i}, X_{j}\right)=\mathrm{E}\left[\left(X_{i}-\mu_{i}\right)\left(X_{j}-\mu_{j}\right)\right]=\mathrm{E}\left[X_{i} X_{j}\right]-\mu_{i} \mu_{j}\rho_{X, Y}=\frac{\operatorname{cov}(X, Y)}{\sigma_{X} \sigma_{Y}} 17 特征比数据量还大时，选择什么样的分类器线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分。 18 对于维度极低的特征，选择线性还是非线性分类器？非线性分类器，低维空间可能很多特征都跑到一起了，导致线性不可分。 19 你正在一个时间序列数据集上工作，经理要求你建立一个高精度的模型，你开始用决策树算法，因为你知道它在所有类型的数据集上的表现都不错，后来，你尝试了时间序列回归模型，并得到了比决策树模型更高的精度，这种情况会发生吗，为什么？会发生，因为时间序列数据有线性关系，而决策树算法室已知的检测非线性交互最好的算法，为什么决策树没能提供好的预测是因为它不能像回归模型那样做到对线性关系那么好的映射。因此，我们知道了如果有一个满足线性假设的数据集，一个线性回归模型能提供强大的预测。 20分类（Classification）和回归（Prediction）的主要步骤及区别联系 分类：输入样本数据，输出对应的类别，将样本中每个数据对应一个已知属性。 回归：两种或者两种以上的变量之间相互依赖的函数模型，预测给定自变量对应的因变量的值。 分类算法分为两步： 学习步：通过训练样本数据集，建立分类规则 分类步：用已知的测试样本集评估分类规则的准确率，若准确率可接受，则是使用该规则对除样本以外的数据(待测样本集)进行预测。 回归算法分两步： 我们先要基于一定数量的样本来训练出一个训练模型； 为了判断这个模型训练的如何，我们还要对其进行检测一下； 如果测试的样本数据与我们想象中的差别太大，那么我们就要重新进行训练这个预测模型，但是如果我们的预测模型符合我们的预先的期望，那么我们就可以用这个模型进行预测的操作。 区别 特征：分类vs. 回归预测 输出类型：离散数据vs. 连续数据 目的：寻找决策边界 vs. 找到最优拟合线 评价方法：精度、混淆矩阵 vs. SEE(sum of square errors)或MSE 联系 分类算法可以预测连续值，但是连续值是以类标签的概率的形式。 回归算法可以预测离散值，但离散值以整数形式表示。 二 模型评估1 模型评估定义模型评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列预测等不同类型的机器学习问题，评估指标的选择也有所不同。 2 准确率的局限性准确率是指分类正确的样本占总样本个数的比例，即 $accuracy=n_{correct} / n_{total}$ ，其中 $n_{correct}$ 为被正确分类的样本个数，$n_{total}$ 为总样本的个数。 准确率是分类问题中最简单也是最直观的评价指标，但存在明显的缺陷。比如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。为了解决这个问题，可以使用更为有效的平均准确率（每个类别下的样本准确率的算术平均）作为模型评估的指标。 3 精确率与召回率的权衡。精确率是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例。召回率是指分类正确的正样本个数占真正的正样本个数的比例。 Precision值和Recall值是既矛盾又统一的两个指标，为了提高Precision值，分类器需要尽量在“更有把握”时才把样本预测为正样本，但此时往往会因为过于保守而漏掉很多“没有把握”的正样本，导致Recall值降低。 为了综合评估一个排序模型的好坏，不仅要看模型在不同TopN下的Precision@N和Recall@N，而且最好绘制出模型的P-R（PrecisionRecall）曲线。P-R曲线的横轴是召回率，纵轴是精确率。对于一个排序模型来说，其P-R曲线上的一个点代表着，在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本，此时返回结果对应的召回率和精确率。整条P-R曲线是通过将阈值从高到低移动而生成的。 F1score和ROC曲线也能综合地反映一个排序模型的性能。F1score是精准率和召回率的调和平均值，定义为 \mathrm{Fl}=\frac{2 \times \text { precision } \times \text { recall}}{\text {precision}+\text {recall}}4 什么是ROC曲线ROC曲线是Receiver Operating Characteristic Curve的简称，中文名为“受试者工作特征曲线”。ROC曲线源于军事领域，而后在医学领域应用甚广，“受试者工作特征曲线”这一名称也正是来自于医学领域。ROC曲线的横坐标为假阳性率（False Positive Rate，FPR）；纵坐标为真阳性率（True Positive Rate，TPR）。FPR和TPR的计算方法分别为FPR=FP/N,TPR=TP/P，上式中，P是真实的正样本的数量，N是真实的负样本的数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被分类器预测为正样本的个数。 只看定义确实有点绕，为了更直观地说明这个问题，我们举一个医院诊断病人的例子。假设有10位疑似癌症患者，其中有3位很不幸确实患了癌症（P=3），另外7位不是癌症患者（N=7）。医院对这10位疑似患者做了诊断，诊断出3位癌症患者，其中有2位确实是真正的患者（TP=2）。那么真阳性率TPR=TP/P=2/3。对于7位非癌症患者来说，有一位很不幸被误诊为癌症患者（FP=1），那么假阳性率FPR=FP/N=1/7。对于“该医院”这个分类器来说，这组分类结果就对应ROC曲线上的一个点（1/7，2/3）。 5 如何绘制ROC曲线首先，根据样本标签统计出正负样本的数量，假设正样本数量为P，负样本数量为N；接下来，把横轴的刻度间隔设置为1/N，纵轴的刻度间隔设置为1/P；再根据模型输出的预测概率对样本进行排序（从高到低）；依次遍历样本，同时从零点开始绘制ROC曲线，每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线，每遇到一个负样本就沿横轴方向绘制一个刻度间隔的曲线，直到遍历完所有样本，曲线最终停在（1,1）这个点，整个ROC曲线绘制完成。 6 如何计算AUCAUC指的是ROC曲线下的面积大小，该值能够量化地反映基于ROC曲线衡量出的模型性能。计算AUC值只需要沿着ROC横轴做积分就可以了。由于ROC曲线一般都处于y=x这条直线的上方（如果不是的话，只要把模型预测的概率反转成1−p就可以得到一个更好的分类器），所以AUC的取值一般在0.5～1之间。AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。 更优雅的解释，auc是指随机给定一个正样本和一个负样本，分类器输出该正样本为正的概率值比分类器输出该负样本为正的概率值要大的可能性。 7 ROC曲线相比P-R曲线有什么特点相比P-R曲线，ROC曲线有一个特点，当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。这个特点让ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能。这有什么实际意义呢？在很多实际问题中，正负样本数量往往很不均衡。比如，计算广告领域经常涉及转化率模型，正样本的数量往往是负样本数量的1/1000甚至1/10000。若选择不同的测试集，P-R曲线的变化就会非常大，而ROC曲线则能够更加稳定地反映模型本身的好坏。所以，ROC曲线的适用场景更多，被广泛用于排序、推荐、广告等领域。但需要注意的是，选择P-R曲线还是ROC曲线是因实际问题而异的，如果研究者希望更多地看到模型在特定数据集上的表现，P-R曲线则能够更直观地反映其性能。 8 平方根误差的“意外”。我们希望构建一个回归模型来预测某部美剧的流量趋势，但无论采用哪种回归模型，得到的RMSE指标都非常高。然而事实是，模型在95%的时间区间内的预测误差都小于1%，取得了相当不错的预测结果。那么，造成RMSE指标居高不下的最可能的原因是什么？ RMSE的计算公式为 R M S E=\sqrt{\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}}{n}}其中，$y_i$是第$i$个样本点的真实值，$\hat{y}_{i}$是第$i$个样本点的预测值，$n$是样本点的个数。一般情况下，RMSE能够很好地反映回归模型预测值与真实值的偏离程度。但在实际问题中，如果存在个别偏离程度非常大的离群点（Outlier）时，即使离群点数量非常少，也会让RMSE指标变得很差。回到问题中来，模型在95%的时间区间内的预测误差都小于1%，这说明，在大部分时间区间内，模型的预测效果都是非常优秀的。然而，RMSE却一直很差，这很可能是由于在其他的5%时间区间内存在非常严重的离群点。 解决方案：第一，如果我们认定这些离群点是“噪声点”的话，就需要在数据预处理的阶段把这些噪声点过滤掉。第二，如果不认为这些离群点是“噪声点”的话，就需要进一步提高模型的预测能力，将离群点产生的机制建模进去。第三，可以找一个更合适的指标来评估该模型。关于评估指标，其实是存在比RMSE的鲁棒性更好的指标，比如平均绝对百分比误差（Mean Absolute Percent Error，MAPE），它定义为 M A P E=\sum_{i=1}^{n}\left|\frac{y_{i}-\hat{y}_{i}}{y_{i}}\right| \times \frac{100}{n}相比RMSE，MAPE相当于把每个点的误差进行了归一化，降低了个别离群点带来的绝对误差的影响。 9 余弦距离的定义在机器学习问题中，通常将特征表示为向量的形式，所以在分析两个特征向量之间的相似性时，常使用余弦相似度来表示。余弦相似度的取值范围是$[−1,1]$，相同的两个向量之间的相似度为1。如果希望得到类似于距离的表示，将1减去余弦相似度即为余弦距离。因此，余弦距离的取值范围为$[0,2]$，相同的两个向量余弦距离为0。 10 为什么在一些场景中要使用余弦相似度而不是欧氏距离？对于两个向量A和B，其余弦相似度定义为 \cos (\theta)=\frac{A \cdot B}{\|A\|\|B\|}=\frac{\sum_{i=1}^{n} A_{i} \times B_{i}}{\sqrt{\sum_{i=1}^{n}\left(A_{i}\right)^{2}} \times \sqrt{\sum_{i=1}^{n}\left(B_{i}\right)^{2}}}即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，其取值范围是[−1,1]。当一对文本相似度的长度差距很大、但内容相近时，如果使用词频或词向量作为特征，它们在特征空间中的的欧氏距离通常很大；而如果使用余弦相似度的话，它们之间的夹角可能很小，因而相似度高。此外，在文本、图像、视频等领域，研究的对象的特征维度往往很高，余弦相似度在高维情况下依然保持“相同时为1，正交时为0，相反时为−1”的性质，而欧氏距离的数值则受维度的影响，范围不固定，并且含义也比较模糊。 总体来说，欧氏距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。例如，统计两部剧的用户观看行为，用户A的观看向量为(0,1)，用户B为(1,0)；此时二者的余弦距离很大，而欧氏距离很小；我们分析两个用户对于不同视频的偏好，更关注相对差异，显然应当使用余弦距离。而当我们分析用户活跃度，以登陆次数(单位：次)和平均观看时长(单位：分钟)作为特征时，余弦距离会认为(1,10)、(10,100)两个用户距离很近；但显然这两个用户活跃度是有着极大差异的，此时我们更关注数值绝对差异，应当使用欧氏距离。 11 余弦距离是否是一个严格定义的距离?距离的定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得三条距离公理（正定性，对称性，三角不等式）成立，则该实数可称为这对元素之间的距离。 余弦距离满足正定性和对称性，但是不满足三角不等式，因此它并不是严格定义的距离。具体来说，对于向量A和B，三条距离公理的证明过程如下: 正定性根据余弦距离的定义，有 \operatorname{dist}(A, B)=1-\cos \theta=\frac{\|A\|_{2}\|B\|_{2}-A B}{\|A\|_{2}\|B\|_{2}}考虑到 $|A|_{2}|B|_{2}-A B \geqslant 0$ ，因此有 $\operatorname{dist}(A, B) \geqslant 0$ 恒成立。特别地，$\operatorname{dist}(A, B)=0 \Leftrightarrow|A|_{2}|B|_{2}=A B \Leftrightarrow A=B$因此余弦距离满足正定性。 对称性根据余弦距离的定义，有 \operatorname{dist}(A, B)=\frac{\|A\|_{2}\|B\|_{2}-A B}{\|A\|_{2}\|B\|_{2}}=\frac{\|B\|_{2}\|A\|_{2}-A B}{\|B\|_{2}\|A\|_{2}}=\operatorname{dist}(B, A)因此余弦距离满足对称性。 三角不等式该性质并不成立，下面给出一个反例。给定A=(1,0)，B=(1,1)，C=(0,1)，则有 \operatorname{dist}(A, B)=1-\frac{\sqrt{2}}{2} \operatorname{dist}(B, C)=1-\frac{\sqrt{2}}{2} \quad \operatorname{dist}(A, C)=1因此 \operatorname{dist}(A, B)+\operatorname{dist}(B, C)=2-\sqrt{2}]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 排序算法]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 排序假设含有n个记录的序列为${r_1,r_2,…,r_n}$，其相应的关键字分别为$(k_1,k_2,…,k_n)$，需确定$1,2,…,n$的一种排列$p_1,p_2,…,p_n$,使其相应的关键字满足$K_{p1} \leq k_{p2} \leq … \leq k_{pn}$关系，即使得序列成为一个按关键字有序的序列$r_{p1},r_{p2},…,r_{pn}$，这样的操作就称为排序。 1.1 排序的稳定性假设$k_i = k_j (1 \leq i \leq n，1 \leq j \leq n，i \neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i＜j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。 1.2 内排序与外排序内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要内外存之间多次交换数据才能进行。 对于内排序来说，排序算法的性能主要受3个方面影响： 时间性能：内排序中主要进行两种操作，比较和移动。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间：辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性：算法本身的复杂度，而不是指算法的时间复杂度。 内排序按主要操作分类：插入排序交换排序选择排序归并排序 排序按复杂度分类简单算法：冒泡排序，简单选择排序，直接插入排序改进算法：希尔排序，堆排序，归并排序，快速排序 2 常见排序算法2.1 冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 2.1.1 冒泡排序初级版让每一个关键字，都和他后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。123456789def BubbleSort0(L): for i in range(len(L)): for j in range(i+1,len(L)): if L[i]&gt;L[j]: L[i],L[j] = L[j],L[i] return Lif __name__ == '__main__': result = BubbleSort0([9,1,5,8,3,7,4,6,2]) print(result) 2.1.2 冒泡排序正宗版123456789def BubbleSort(L): for i in range(len(L)): for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.3 冒泡排序优化当i=2时，我们已经对9与8,8与7，。。。，3与2作了比较，没有任何数据交换，说明此序列已经有序，不需要再继续后面的循环判断工作了。增加标记变量flag来实现这一算法的改进。 12345678910111213def BubbleSort(L): flag = True for i in range(len(L)): if flag: flag = False for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] flag = True return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.4 冒泡排序的算法复杂度：最好情况：要排序的表本身就是有序的，需要$n-1$次比较，没有数据交换，时间复杂度为$O(n)$。最坏情况：待排序表示逆序的情况，需要比较$1+2+3+…+(n-1) = n(n-1)/2$次，并做等数量级的记录移动，总时间复杂度为$O(n^2)$。冒泡排序是稳定的。 2.2 简单选择排序通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i,(1≤i≤n)$个记录交换之。123456789101112def SelectSort(L): for i in range(len(L)): min = i for j in range(i+1,len(L)): if L[j] &lt; L[min]: min = j if min != i: L[i],L[min] = L[min],L[i] return Lif __name__ == '__main__': result = SelectSort([9,1,5,8,3,7,4,6,2]) print(result) 2.2.1 简单选择排序复杂度分析简单选择排序最大的特点是交换移动数据次数相当少。无论最好最差的情况，其比较次数都是一样多，第$i$躺排序需要进行$n-i$次关键字的比较，需要比较$(n-1)+(n-2)+…+1 = n(n-1)/2$次;而对于交换次数而言，最好的时候交换0次，最坏时候交换n-1次。总的时间复杂度仍为$O(n^2)$。性能略优于冒泡排序，简单选择排序是稳定的。 2.3 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。12345678910111213def InsertSort(L): for i in range(1,len(L)): if L[i] &lt; L[i-1]: temp = L[i]#设置哨兵 k = i while temp &lt; L[k-1] and k &gt;= 1: L[k] = L[k-1]#记录后移 k -= 1 L[k] = temp#插入到正确位置 return Lif __name__ == '__main__': result = InsertSort([9,1,5,8,3,7,4,6,2]) print(result) 2.3.1 直接插入排序复杂度分析 空间复杂度：只需要一个记录的辅助空间，$O(1)$ 最好时间复杂度：待排序表是有序时，n-1次比较，0次移动，复杂度为$O(n)$ 最坏时间复杂度：待排序表示逆序时，需要比较$2+3+…+n=(n+2)(n-1)/2$次，移动$(n+4)(n-1)/2$次。 平均比较和移动次数$n^2/4$次。总的时间复杂度为$O(n^2)$，直接插入排序法比冒泡和简单选择排序的性能要好一些。 直接插入排序是稳定的。 2.4 希尔排序希尔排序算法是突破$O(n^2)$这个时间复杂度的第一批算法。采用跳跃分割的策略：将相距某个“增量”的记录组成一个字序列，这样才能保证在子序列内分别进行插入排序后得到的结果就是基本有序而不是局部有序。 123456789101112131415def ShellSort(L): increment = len(L) // 2 while increment &gt; 0: for i in range(increment,len(L)): temp = L[i] k = i - increment while temp &lt; L[k] and k &gt;= 0: L[k+increment] = L[k] k -= increment L[k+increment] = temp increment = increment // 2 return Lif __name__ == '__main__': result = ShellSort([9,1,5,8,3,7,4,6,2]) print(result) 2.4.1 希尔排序复杂度分析增量的选取很关键，迄今为止还没有人找到一种最好的增量序列。增量序列的最后一个增量值必须等于1才行，由于记录是跳跃式的移动，希尔排序并不是一种稳定的算法。时间复杂度为$O(n^{3/2})$。优于直接排序的$O(n^2)$。 2.5 堆排序堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如果按照层序遍历的方式给结点从1进行编号，则结点之间满足以下关系： 2.5.1 堆排序算法堆排序就是利用堆（假设利用大顶堆求升序）进行排序的方法，他的基本思想是：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的$n-1$个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。1234567891011121314151617181920212223def HeapSort(L): for i in range(len(L)//2,-1,-1): HeapAdjust(L,i,len(L)) for j in range(1,len(L))[::-1]: L[j],L[0] = L[0],L[j] HeapAdjust(L,0,j) return Ldef HeapAdjust(L,parent,length): temp = L[parent] child = 2*parent+1 while child &lt; length: if child+1&lt;length and L[child]&lt;L[child+1]: child += 1 if temp &gt;= L[child]: break L[parent] = L[child] parent = child child = 2*parent+1 L[parent] = tempif __name__ == '__main__': result = HeapSort([9,1,5,8,3,7,4,6,2]) print(result) 2.5.2 堆排序复杂度分析运行时间主要消耗在初始构建堆和重建堆的反复筛选。 构建堆的时间复杂度为$O(n)$ 重建堆的时间复杂度为$O(nlogn)$ 总的时间复杂度为$O(nlogn)$ 空间复杂度，只需要一个用来交换的暂存单元，$O(1)$。 堆排序是不稳定的。 2.6 归并排序归并排序的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到[n//2]个长度为2或1的有序子序列；再两两合并，…，如此重复，直至得到一个长度为n的有序序列为止，这种方法称为2路归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940def MergeSort(L): temp = [0]*len(L) MSort(L,temp,0,len(L)-1) return Ldef MSort(L,temp,left,right): if left &gt;= right: return mid = (left+right)//2 MSort(L,temp,left,mid) MSort(L,temp,mid+1,right) Merge(L,temp,left,mid,right)def Merge(L,temp,left,mid,right): l,r = left,mid+1 k = 0 while l &lt;= mid and r &lt;= right: if L[l]&lt;L[r]: temp[k] = L[l] l += 1 else: temp[k] = L[r] r += 1 k += 1 while l &lt;= mid: temp[k] = L[l] l+=1 k+=1 while r &lt;= right: temp[k] = L[r] r += 1 k += 1 k = 0 while left &lt;= right: L[left] = temp[k] left += 1 k += 1 if __name__ == '__main__': result = MergeSort([9,1,5,8,3,7,4,6,2]) print(result) 2.6.1 归并排序复杂度分析一趟归并需要将待排序序列中的所有记录扫描一遍，耗费$O(n)$时间，而由完全二叉树的深度可知，整个归并排序需要进行$[log2^n]$次，因此总的时间复杂度为$O(nlogn)$，而且这是归并排序算法中最好、最坏、平均的时间性能。由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$log2^n$的栈空间，因此空间复杂度为$O(n+logn)$。由于Merge函数中有$if L[l]&lt;L[r]$语句，说明需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。归并排序是一种比较占用内存，但效率高且稳定的算法。 2.7 快速排序快速排序的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 12345678910111213141516171819202122def QuickSort(L): QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) Partition 函数要做的，就是先选取当中的一个关键字，比如选择第一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴( pivot) 。 2.7.1 快速排序复杂度分析快速排序的时间性能取决于快速排序递归的深度。 在最优情况下,Partition每次划分都很均匀，如果排序n个关键字，其递归树的深度就为$[logn]+1$，仅需递归$logn$次，需要时间为$T(n)$的话，第一次Partition应该是对整个数组扫描一遍，做n次比较。然后获得的枢轴将数组一份为二，那么各自还需要$T(n/2)$的时间。 在最优的情况下，快速排序算法的时间复杂度为$O(nlogn) $。 最坏时间复杂度为$O(n^2)$。 空间复杂度主要是递归造成的栈空间的使用: 最好情况，递归树的深度为$logn$ ，其空间复杂度也就为$O(logn)$ 最坏情况，需要进行$n - 1$ 递归调用，其空间复杂度为$O(n)$ 平均情况， 空间复杂度也为$O (logn) $。 由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 2.7.2 快速排序优化2.7.2.1 优化选取枢轴三数取中：即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数。三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey ， 123456789101112131415161718192021222324252627282930def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.2 优化不必要的交换1234567891011121314151617181920212223242526272829303132def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] temp = pivotkey while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low] = L[high] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[high] = L[low] L[low] = temp return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.3 优化小数组时的排序方案2.7.2.4 优化递归操作2.8 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 2.8.1 桶排序复杂度分析假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有$n/m$个数字。如果 对每个桶中的数字采用快速排序，那么整个算法的复杂度是$O(n + m n/mlog(n/m)) = O(n + nlogn - nlogm) $ 当m接近n的时候，桶排序复杂度接近$O(n)$。前面说的几大排序算法 ，大部分时间复杂度都是$O(n^2)$，也有部分排序算法时间复杂度是$O(nlogn)$。而桶式排序却能实现$O(n)$的时间复杂度。但桶排序的缺点是： 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 其次待排序的元素都要在一定的范围内。 桶式排序是一种分配排序。分配排序的特点是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 参考 2.8.2 桶排序实现桶排序求前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路 使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路 桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result) 3 总结 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
