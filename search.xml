<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[建筑物能源之星分数预测]]></title>
    <url>%2F2019%2F05%2F14%2FProject%20Experience-Building%20Energy%20Star%20Score%20Prediction%2F</url>
    <content type="text"><![CDATA[项目来源这是在Github 上找到的一个美国数据科学家在申请工作时的”作业”，英文作业链接。 项目目标 使用提供的建筑能源数据开发一个模型，该模型可以预测建筑物的能源之星得分（building’s Energy Star score）； 解释结果以找到最能预测得分的变量。 这是一个有监督的回归机器学习任务：给定一组包含目标（在本项目中为ENERGY STAR Score能源之星分数）的数据，我们希望训练一个可以学习将特征（也称为解释变量）映射到目标的模型。 监督学习：数据集中同时存在特征和目标变量； 回归任务：目标变量时连续值，在本项目中为0~100。 在训练过程中，我们希望模型学习特征和分数之间的关系；然后，为了测试模型的学习效果，我们在一个没有分数的测试集上进行评估！ 机器学习工作流程虽然每一个机器学习任务的实现细节可能会有所不同，但一般有以下几个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 尽可能地解释模型结果 得出结论并撰写详尽记录的报告 提前设置步骤让我们可以看到一步流入另一步。但是，机器学习过程是一个迭代过程，因此我们并不总是以线性方式遵循这些步骤。我们可能会根据下一步的结果重新审视上一步。例如： 虽然我们可以在构建任何模型之前执行特征选择，但我们可以使用建模结果返回并选择一组不同的特征； 或者，建模可能会出现意想不到的结果，这意味着我们希望从另一个角度探索我们的数据； 一般来说，你必须先完成一步才能继续下一步，但不要觉得一旦你第一次完成一步，你就不能回头做出改进，你可以在任何时候返回前面的步骤做响应的修改。 0 导入库文件使用标准的数据科学和机器学习库:numpy、panda和scikit-learn，同时使用matplotlib和seaborn进行可视化。 123456789101112131415161718192021222324# 用于数值计算的 Pandas和numpyimport pandas as pdimport numpy as np# 不显示在切片副本上的警告pd.options.mode.chained_assignment = None# Matplotlib可视化import matplotlib.pyplot as plt%matplotlib inline# 设置默认字体plt.rcParams['font.size'] = 24# 用于设置图形大小的内部ipython工具from IPython.core.pylabtools import figsize# Seaborn可视化import seaborn as sns# 缩放因子sns.set(font_scale = 2)# 将数据划分为训练集和测试集from sklearn.model_selection import train_test_split 1 数据清理和格式化1.1 导入并检查数据将数据加载到pandas数据帧中，这是数据科学最有用的数据结构之一。 将其视为Python中的电子表格，我们可以轻松地操作，清理和可视化。Pandas官方文档。 123456# 读取数据data = pd.read_csv('dataset/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv')# 显示数据大小print('datashape:',data.shape)# 显示表头data.head() datashape: (11746, 60) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Order Property Id Property Name Parent Property Id Parent Property Name BBL - 10 digits NYC Borough, Block and Lot (BBL) self-reported NYC Building Identification Number (BIN) Address 1 (self-reported) Address 2 … Source EUI (kBtu/ft²) Release Date Water Required? DOF Benchmarking Submission Status Latitude Longitude Community Board Council District Census Tract NTA 0 1 13286 201/205 13286 201/205 1013160001 1013160001 1037549 201/205 East 42nd st. Not Available … 619.4 05/01/2017 05:32:03 PM No In Compliance 40.750791 -73.973963 6.0 4.0 88.0 Turtle Bay-East Midtown … 1 2 28400 NYP Columbia (West Campus) 28400 NYP Columbia (West Campus) 1021380040 1-02138-0040 1084198; 1084387;1084385; 1084386; 1084388; 10… 622 168th Street Not Available … 404.3 04/27/2017 11:23:27 AM No In Compliance 40.841402 -73.942568 12.0 10.0 251.0 Washington Heights South … 2 3 4778226 MSCHoNY North 28400 NYP Columbia (West Campus) 1021380030 1-02138-0030 1063380 3975 Broadway Not Available … Not Available 04/27/2017 11:23:27 AM No In Compliance 40.840427 -73.940249 12.0 10.0 251.0 Washington Heights South … 3 4 4778267 Herbert Irving Pavilion &amp; Millstein Hospital 28400 NYP Columbia (West Campus) 1021390001 1-02139-0001 1087281; 1076746 161 Fort Washington Ave 177 Fort Washington Ave … Not Available 04/27/2017 11:23:27 AM No In Compliance 40.840746 -73.942854 12.0 10.0 255.0 Washington Heights South … 4 5 4778288 Neuro Institute 28400 NYP Columbia (West Campus) 1021390085 1-02139-0085 1063403 710 West 168th Street Not Available … Not Available 04/27/2017 11:23:27 AM No In Compliance 40.841559 -73.942528 12.0 10.0 255.0 Washington Heights South … 5 rows × 60 columns 原始数据中有看一下原始数据11746行，60列，我们的目标是预测ENERGY STAR Score列中的数字，其他列作为特征。 根据数据集的文件名为Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv,这里面有一个Local_Law_84，根据Local_Law_84进行搜索，得到两个比较关键的资料： Local_Law_84网站 基准化公开数据定义 第一个网站告诉我们，当地Local_Law_84是纽约市的一项要求，规定所有超过50,000𝑓𝑡2的建筑物必须每年报告一组与能源相关的数字。pdf文档说明每列代表的含义，虽然我们不需要研究每一列，但至少要理解我们想要预测的目标是个好主意。以下是ENERGY STAR Score能源之星分数的定义： 基于报告年度自我报告的能源使用情况，在投资组合管理器中计算的指定建筑类型的的分数：范围在1到100。 这看起来非常简单：能源之星得分是一种根据能源效率对建筑物进行排名的方法，其中最差的是1，最好是100。它是相对百分位排名，这意味着建筑物相对于彼此进行评分，并且应该在整个值范围内显示均匀分布。 1.2 数据类型和缺失值处理dataframe.info方法是一种通过显示每列的数据类型和非缺失值的数量来评估数据的快速方法。 从查看数据帧开始，可能会出现问题，因为缺失值被编码为“Not Available”而不是np.nan（不是数字）（因为csv文件某些列同时包含数字和字符两种类型）。 这意味着具有数字的列将不会表示为数字，因为pandas会将具有字符串值的列转换为字符串的列。 12# 查看数据列的数据类型和非缺失值数量data.info() &lt;class &apos;pandas.core.frame.DataFrame&apos;&gt; RangeIndex: 11746 entries, 0 to 11745 Data columns (total 60 columns): Order 11746 non-null int64 Property Id 11746 non-null int64 Property Name 11746 non-null object Parent Property Id 11746 non-null object Parent Property Name 11746 non-null object BBL - 10 digits 11735 non-null object NYC Borough, Block and Lot (BBL) self-reported 11746 non-null object NYC Building Identification Number (BIN) 11746 non-null object Address 1 (self-reported) 11746 non-null object Address 2 11746 non-null object Postal Code 11746 non-null object Street Number 11622 non-null object Street Name 11624 non-null object Borough 11628 non-null object DOF Gross Floor Area 11628 non-null float64 Primary Property Type - Self Selected 11746 non-null object List of All Property Use Types at Property 11746 non-null object Largest Property Use Type 11746 non-null object Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object 2nd Largest Property Use Type 11746 non-null object 2nd Largest Property Use - Gross Floor Area (ft²) 11746 non-null object 3rd Largest Property Use Type 11746 non-null object 3rd Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object Year Built 11746 non-null int64 Number of Buildings - Self-reported 11746 non-null int64 Occupancy 11746 non-null int64 Metered Areas (Energy) 11746 non-null object Metered Areas (Water) 11746 non-null object ENERGY STAR Score 11746 non-null object Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site Electricity Intensity (kWh/ft²) 11746 non-null object Weather Normalized Site Natural Gas Intensity (therms/ft²) 11746 non-null object Weather Normalized Source EUI (kBtu/ft²) 11746 non-null object Fuel Oil #1 Use (kBtu) 11746 non-null object Fuel Oil #2 Use (kBtu) 11746 non-null object Fuel Oil #4 Use (kBtu) 11746 non-null object Fuel Oil #5 &amp; 6 Use (kBtu) 11746 non-null object Diesel #2 Use (kBtu) 11746 non-null object District Steam Use (kBtu) 11746 non-null object Natural Gas Use (kBtu) 11746 non-null object Weather Normalized Site Natural Gas Use (therms) 11746 non-null object Electricity Use - Grid Purchase (kBtu) 11746 non-null object Weather Normalized Site Electricity (kWh) 11746 non-null object Total GHG Emissions (Metric Tons CO2e) 11746 non-null object Direct GHG Emissions (Metric Tons CO2e) 11746 non-null object Indirect GHG Emissions (Metric Tons CO2e) 11746 non-null object Property GFA - Self-Reported (ft²) 11746 non-null int64 Water Use (All Water Sources) (kgal) 11746 non-null object Water Intensity (All Water Sources) (gal/ft²) 11746 non-null object Source EUI (kBtu/ft²) 11746 non-null object Release Date 11746 non-null object Water Required? 11628 non-null object DOF Benchmarking Submission Status 11716 non-null object Latitude 9483 non-null float64 Longitude 9483 non-null float64 Community Board 9483 non-null float64 Council District 9483 non-null float64 Census Tract 9483 non-null float64 NTA 9483 non-null object dtypes: float64(6), int64(6), object(48) memory usage: 5.4+ MB 果然，有许多列的数字已被标记为对象数据类型（object）。 在我们进行数值分析之前，必须将它们转换为float数据类型。 1.3 将数据转换为正确的数据类型将带有数字的列转换为数字数据类型，方法是将“Not Available”条目替换为可以解释为浮点数的np.nan。 然后我们将包含数值（例如$ft^2$或$kWh$）的列转换为数值数据类型。 1234567# 用np.nan替换所有的Not Available”data = data.replace(&#123;'Not Available': np.nan&#125;)# 将应该为数值类型的列转换为数值类型for col in list(data.columns): if ('ft²' in col or 'kBtu' in col or 'Metric Tons CO2e' in col or 'kWh' in col or 'therms' in col or 'gal' in col or 'Score' in col): data[col] = data[col].astype(float) 12# 每一列的统计信息data.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Order Property Id DOF Gross Floor Area Largest Property Use Type - Gross Floor Area (ft²) 2nd Largest Property Use - Gross Floor Area (ft²) 3rd Largest Property Use Type - Gross Floor Area (ft²) Year Built Number of Buildings - Self-reported Occupancy ENERGY STAR Score … Indirect GHG Emissions (Metric Tons CO2e) Property GFA - Self-Reported (ft²) Water Use (All Water Sources) (kgal) Water Intensity (All Water Sources) (gal/ft²) Source EUI (kBtu/ft²) Latitude Longitude Community Board Council District Census Tract count 11746.000000 1.174600e+04 1.162800e+04 1.174400e+04 3741.000000 1484.000000 11746.000000 11746.000000 11746.000000 9642.000000 … 1.168100e+04 1.174600e+04 7.762000e+03 7762.000000 11583.000000 9483.000000 9483.000000 9483.000000 9483.000000 9483.000000 mean 7185.759578 3.642958e+06 1.732695e+05 1.605524e+05 22778.682010 12016.825270 1948.738379 1.289971 98.762557 59.854594 … 2.076339e+03 1.673739e+05 1.591798e+04 136.172432 385.908029 40.754379 -73.957057 7.140673 15.771275 4977.596647 std 4323.859984 1.049070e+06 3.367055e+05 3.095746e+05 55094.441422 27959.755486 30.576386 4.017484 7.501603 29.993586 … 5.931295e+04 3.189238e+05 1.529524e+05 1730.726938 9312.736225 0.080120 0.046337 3.954129 15.674375 13520.422990 min 1.000000 7.365000e+03 5.002800e+04 5.400000e+01 0.000000 0.000000 1600.000000 0.000000 0.000000 1.000000 … -2.313430e+04 0.000000e+00 0.000000e+00 0.000000 0.000000 40.516065 -74.243582 1.000000 1.000000 1.000000 25% 3428.250000 2.747222e+06 6.524000e+04 6.520100e+04 4000.000000 1720.750000 1927.000000 1.000000 100.000000 37.000000 … 9.480000e+01 6.699400e+04 2.595400e+03 27.150000 99.400000 40.707226 -73.984662 4.000000 4.000000 100.000000 50% 6986.500000 3.236404e+06 9.313850e+04 9.132400e+04 8654.000000 5000.000000 1941.000000 1.000000 100.000000 65.000000 … 1.718000e+02 9.408000e+04 4.692500e+03 45.095000 124.900000 40.759130 -73.962810 7.000000 9.000000 201.000000 75% 11054.500000 4.409092e+06 1.596140e+05 1.532550e+05 20000.000000 12000.000000 1966.000000 1.000000 100.000000 85.000000 … 4.249000e+02 1.584140e+05 8.031875e+03 70.805000 162.750000 40.817623 -73.932443 9.000000 33.000000 531.500000 max 14993.000000 5.991312e+06 1.354011e+07 1.421712e+07 962428.000000 591640.000000 2019.000000 161.000000 100.000000 100.000000 … 4.764375e+06 1.421712e+07 6.594604e+06 96305.690000 912801.100000 40.912869 -73.715543 56.000000 51.000000 155101.000000 8 rows × 37 columns 1.4 缺失值处理现在我们有了正确的列数据类型，我们可以通过查看每列中缺失值的百分比来开始分析。 当我们进行探索性数据分析时，需要计算缺失值的数量以及每列缺少的总值的百分比。处理方式参考Stack Overflow forum的函数。 1234567891011121314151617181920212223242526272829# 计算每一列中缺失值占比def missing_values_table(df): # 计算总的缺失值 mis_val = df.isnull().sum() # 计算缺失值的百分比 mis_val_percent = 100 * df.isnull().sum() / len(df) # 保存缺失值信息的表格 mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # 列重命名 mis_val_table_ren_columns = mis_val_table.rename( columns = &#123;0 : 'Missing Values', 1 : '% of Total Values'&#125;) # 缺失值比例按列降序 mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) # 打印总结信息 print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n" "There are " + str(mis_val_table_ren_columns.shape[0]) + " columns that have missing values.") # 返回各列缺失值占比信息 return mis_val_table_ren_columns# 调用函数missing_values_table(data) Your selected dataframe has 60 columns. There are 46 columns that have missing values. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Missing Values % of Total Values Fuel Oil #1 Use (kBtu) 11737 99.9 Diesel #2 Use (kBtu) 11730 99.9 Address 2 11539 98.2 Fuel Oil #5 &amp; 6 Use (kBtu) 11152 94.9 District Steam Use (kBtu) 10810 92.0 Fuel Oil #4 Use (kBtu) 10425 88.8 3rd Largest Property Use Type - Gross Floor Area (ft²) 10262 87.4 3rd Largest Property Use Type 10262 87.4 Fuel Oil #2 Use (kBtu) 9165 78.0 2nd Largest Property Use Type 8005 68.2 2nd Largest Property Use - Gross Floor Area (ft²) 8005 68.2 Metered Areas (Water) 4609 39.2 Water Intensity (All Water Sources) (gal/ft²) 3984 33.9 Water Use (All Water Sources) (kgal) 3984 33.9 Latitude 2263 19.3 Longitude 2263 19.3 Community Board 2263 19.3 Council District 2263 19.3 Census Tract 2263 19.3 NTA 2263 19.3 ENERGY STAR Score 2104 17.9 Weather Normalized Site Natural Gas Intensity (therms/ft²) 1963 16.7 Weather Normalized Site Natural Gas Use (therms) 1962 16.7 Weather Normalized Source EUI (kBtu/ft²) 1465 12.5 Weather Normalized Site EUI (kBtu/ft²) 1465 12.5 Natural Gas Use (kBtu) 1442 12.3 Weather Normalized Site Electricity Intensity (kWh/ft²) 787 6.7 Weather Normalized Site Electricity (kWh) 786 6.7 Electricity Use - Grid Purchase (kBtu) 244 2.1 Site EUI (kBtu/ft²) 163 1.4 Source EUI (kBtu/ft²) 163 1.4 NYC Building Identification Number (BIN) 162 1.4 Street Number 124 1.1 Street Name 122 1.0 Borough 118 1.0 DOF Gross Floor Area 118 1.0 Water Required? 118 1.0 Direct GHG Emissions (Metric Tons CO2e) 83 0.7 Total GHG Emissions (Metric Tons CO2e) 74 0.6 Indirect GHG Emissions (Metric Tons CO2e) 65 0.6 Metered Areas (Energy) 57 0.5 DOF Benchmarking Submission Status 30 0.3 NYC Borough, Block and Lot (BBL) self-reported 11 0.1 BBL - 10 digits 11 0.1 Largest Property Use Type 2 0.0 Largest Property Use Type - Gross Floor Area (ft²) 2 0.0 根据前面的data.shape可知数据集里一共有11746个实例。我们可以看到我们的目标ENERGY STAR Score能源之星得分有2104个缺失值，占比17.9%，非缺失值有9642个。 虽然我们尽量不能丢失信息，但如果列的丢失值占比很高，那么它可能对结果预测没什么帮助。要保留哪些列在这里有一些讨论，本项目中，我们将删除缺失值超过50％的列。一般来说，要特别小心丢弃任何特征，因为即使有一些缺失值，该特征仍然有可能对于预测目标值有帮助。 1234567# 获得缺失值大于50%的列missing_df = missing_values_table(data)missing_columns = list(missing_df[missing_df['% of Total Values'] &gt; 50].index)print('We will remove %d columns.' % len(missing_columns))# 删除缺失值大于50%的列data = data.drop(columns = list(missing_columns)) Your selected dataframe has 60 columns. There are 46 columns that have missing values. We will remove 11 columns. 其他的具有缺失值的列将用合适的缺失值填充方法补全。 2 探索性数据分析探索性数据分析(EDA)是一个开放式流程，我们绘图并计算统计数据，以便探索我们的数据。 目的是找到异常，模式，趋势或关系。 这些可能是有趣的（例如，找到两个变量之间的相关性），或者它们可用于通知建模决策，例如使用哪些特征。 简而言之，探索性数据分析的目标是确定我们的数据可以告诉我们什么！ 探索性数据分析通常从数据整体开始，然后在我们找到要检查的区域时缩小到数据集的特定部分。 要开始探索性数据分析，我们将关注目标变量，即Energy Star Score能源之星得分，因为这是我们的机器学习模型的目标。 为简单起见，我们可以将列重命名为score得分，然后开始探索此值。 2.1 单变量分析单变量图显示单个变量的分布，例如直方图。 1234567891011figsize(8, 8)# 将Energy Star Score 重命名为scoredata = data.rename(columns= &#123;'ENERGY STAR Score': 'score'&#125;)# score直方图plt.style.use('fivethirtyeight')plt.hist(data['score'].dropna(), bins = 100, edgecolor = 'k')plt.xlabel('Score')plt.ylabel('Number of Buildings')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &apos;Energy Star Score Distribution&apos;) 由于能源之星得分是百分位数，我们预计会看到完全平坦的分布，每个得分占分布的1％（约90个建筑物）。然而，这绝对不是这种情况，因为我们可以看到两个最常见的分数，1和100，构成总分数的不相称的数字。即在两端出现了异常值。 如果我们回到分数的定义，我们会看到它是基于自我报告的能量使用情况。这造成了一个问题，因为建筑物所有者可能想要报告较低的用电量以人为地提高他们的建筑物的分数。这就像给学生一个基于自我报告的考试成绩的成绩。这种行为可以解释高比例的建筑物满分为100，但不能解释为什么这么多建筑物在最底层得分！ 为了对比能源之星得分，我们可以看一下能源使用强度（EUI），它是总能源消耗除以建筑物的平方英尺。在这里，能源使用量不是自我报告的，因此这可以更加客观地衡量建筑物的能源效率。此外，这不是百分位数，因此绝对值很重要，我们希望它们大致正态分布，可能在低端或高端有一些异常值。 123456# Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &apos;Site EUI distribution&apos;) 这表明我们还有另一个问题：异常值！ 由于存在一些分数非常高的建筑物，因此图表非常偏斜。 因此我们需要首先处理异常值。我们来看看EUI这个特征的统计数据。 1data['Site EUI (kBtu/ft²)'].describe() count 11583.000000 mean 280.071484 std 8607.178877 min 0.000000 25% 61.800000 50% 78.500000 75% 97.600000 max 869265.000000 Name: Site EUI (kBtu/ft²), dtype: float64 12# 我们看一下EUI特征最大的10个值data['Site EUI (kBtu/ft²)'].dropna().sort_values().tail(10) 3173 51328.8 3170 51831.2 3383 78360.1 8269 84969.6 3263 95560.2 8268 103562.7 8174 112173.6 3898 126307.4 7 143974.4 8068 869265.0 Name: Site EUI (kBtu/ft²), dtype: float64 其中一栋建筑的EUI远高于其他的，我们看一下这个建筑。 1data.loc[data['Site EUI (kBtu/ft²)'] == 869265.0, :] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Order Property Id Property Name Parent Property Id Parent Property Name BBL - 10 digits NYC Borough, Block and Lot (BBL) self-reported NYC Building Identification Number (BIN) Address 1 (self-reported) Postal Code … Source EUI (kBtu/ft²) Release Date Water Required? DOF Benchmarking Submission Status Latitude Longitude Community Board Council District Census Tract NTA 8068 9984 4414323 234 Skillman Not Applicable: Standalone Property Not Applicable: Standalone Property 3028937502 3028937502 3390250 , 3338313 234 Skillman avenue 11211 … 912801.1 05/01/2017 11:34:14 PM NaN In Compliance 40.716233 -73.94141 1.0 34.0 477.0 East Williamsburg … 1 rows × 49 columns 异常值可能由于多种原因发生： 拼写错误 测量设备故障 不正确的单位 或者它们可能是合法的但是极端值。 异常值可以删除，因为它们并不表示数据的实际分布。 2.2 删除异常值当我们删除异常值时，我们要小心，我们不能因为异常值就直接删除。 它们可能是我们应该进一步调查的实际现象的结果。 当删除异常值时，可以尝试使用极端异常值的定义来处理，这样可以尽可能保守： 在低端，极端异常值低于 $\text{First Quartile} -3 * \text{Interquartile Range}$ 在高端，极端异常值高于 $\text{Third Quartile} + 3 * \text{Interquartile Range}$ 在这种情况下，我将只删除单个外围点并查看分布情况。 12345678910# 计算第一和第三分位点first_quartile = data['Site EUI (kBtu/ft²)'].describe()['25%']third_quartile = data['Site EUI (kBtu/ft²)'].describe()['75%']# 计算四分位范围：即第一第三分位之间的范围iqr = third_quartile - first_quartile# 去除异常值data = data[(data['Site EUI (kBtu/ft²)'] &gt; (first_quartile - 3 * iqr)) &amp; (data['Site EUI (kBtu/ft²)'] &lt; (third_quartile + 3 * iqr))] 123456# 重画Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &apos;Site EUI distribution&apos;) 删除异常值后，这个直方图分布看起来比较正常，并且接近正态分布，右侧有一条长尾（它有一个正偏斜）。 虽然这可能是一个更客观的衡量标准，但我们的目标仍然是预测能源之星得分，因此我们将回过头来研究该变量。 即使能源之星分数不是一个好的衡量标准，我们仍然需要预测它，这就是我们要做的事情！ 在回到公司的最终报告中，我将指出这可能不是一个客观的衡量标准，并且使用不同的指标来确定建筑物的效率是个好主意。 此外，看看分数为1和100的建筑物可能会很有趣，看看它们是否有任何共同之处。 2.3 寻找关系为了查看分类变量 - categorical variables对分数的影响，我们可以通过分类变量的值来绘制密度图。 密度图还显示单个变量的分布，可以认为是平滑的直方图。 如果我们通过为分类变量密度曲线着色，这将向我们展示分布如何基于类别变化的。 我们将制作的第一个图表显示了Largest Property Use Type建筑类型的分布。 为了不使图形混乱，我们将图形限制为在数据集中具有超过100个观测值的建筑类型。 “具有超过100个观测值的建筑类型” 这句话是什么意思呢？ 有的建筑是住宅楼，有的是酒店，有的是写字楼办公楼，有的是医院等等。 如果用作住宅楼的建筑和用作办公楼的建筑都超过100栋了，那我们就把这两种类型的建筑物的得分分布画出来。例如下图中的红色曲线就代表Office这个类型的建筑物的能源之星得分分布 1234# 统计每个属性值的个数types = data.dropna(subset=['score'])types = types['Largest Property Use Type'].value_counts()types Multifamily Housing 7464 Office 1157 Hotel 202 Non-Refrigerated Warehouse 156 K-12 School 97 Residence Hall/Dormitory 96 Senior Care Community 85 Distribution Center 61 Retail Store 57 Medical Office 23 Hospital (General Medical &amp; Surgical) 15 Financial Office 12 Supermarket/Grocery Store 10 Worship Facility 9 Refrigerated Warehouse 8 Wholesale Club/Supercenter 3 Parking 3 Courthouse 2 Bank Branch 1 Name: Largest Property Use Type, dtype: int64 可以看到，属性值大于100个的有四个： Multifamily Housing Office Hotel Non-Refrigerated Warehouse 12345678910111213141516# 取出属性值个数大于100个的属性types = list(types[types.values &gt; 100].index)# 建筑类型的密度图figsize(12,10)# 绘制每一种建筑类型for b_type in types: # 选出建筑类型 subset = data[data['Largest Property Use Type'] == b_type] # 绘制对应建筑类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = b_type, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Building Type', size = 28) C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &apos;Density Plot of Energy Star Scores by Building Type&apos;) 从该图中，我们可以看到建筑类型确实对分数有影响（图上的负分数是核密度估计过程的人工产物）。 虽然我最初将重点放在用于预测分数的数字列上，但此图表告诉我们应该包含属性类型，因为此信息可用于确定分数。 由于建筑类型是一个分类变量，因此在将其输入机器学习模型之前，必须对其进行独热编码。 为检查另一个分类变量，行政区Borough，我们可以制作类似的图表。 1234# 统计每个属性值的个数boroughs = data.dropna(subset = ['score'])boroughs = boroughs['Borough'].value_counts()boroughs Manhattan 3985 Brooklyn 1947 Queens 1707 Bronx 1655 Staten Island 119 Name: Borough, dtype: int64 12345678910111213141516# 取出属性值个数大于100个的属性boroughs = list(boroughs[boroughs.values &gt; 100].index)# Borough类型的密度图figsize(12,10)# 绘制每一种Borough类型for borough in boroughs: # 选出Borough类型 subset = data[data['Borough'] == borough] # 绘制对应Borough类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = borough, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Borough', size = 28) Text(0.5, 1.0, &apos;Density Plot of Energy Star Scores by Borough&apos;) 建筑的Borough似乎没有像建筑type那样在分数分布上产生显着差异。 尽管如此，将Borough纳入分类变量可能是有意义的。 2.4 特征变量和目标变量的关系为了量化特征（变量）和目标之间的相关性，我们可以计算Pearson相关系数。 这是两个变量之间线性关系的强度和方向的度量：值-1表示两个变量完全负线性相关，值+1表示两个变量完全正线性相关。 尽管特征和目标之间可能存在非线性关系，并且相关系数不考虑特征之间的相互作用，但线性关系是开始探索数据趋势的好方法。 然后，我们可以使用这些值来选择要在我们的模型中使用的特征。 下面的代码计算所有变量和目标变量score之间的相关系数。 12345678910# 计算所有变量和score的相关系数correlations_data = data.corr()['score'].sort_values()# 最负相关的15个特征print(correlations_data.head(15))print('===================================')# 最正相关的15个特征print(correlations_data.tail(15)) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Weather Normalized Site Natural Gas Intensity (therms/ft²) -0.346046 Direct GHG Emissions (Metric Tons CO2e) -0.147792 Weather Normalized Site Natural Gas Use (therms) -0.135211 Natural Gas Use (kBtu) -0.133648 Year Built -0.121249 Total GHG Emissions (Metric Tons CO2e) -0.113136 Electricity Use - Grid Purchase (kBtu) -0.050639 Weather Normalized Site Electricity (kWh) -0.048207 Latitude -0.048196 Property Id -0.046605 Name: score, dtype: float64 =================================== Property Id -0.046605 Indirect GHG Emissions (Metric Tons CO2e) -0.043982 Longitude -0.037455 Occupancy -0.033215 Number of Buildings - Self-reported -0.022407 Water Use (All Water Sources) (kgal) -0.013681 Water Intensity (All Water Sources) (gal/ft²) -0.012148 Census Tract -0.002299 DOF Gross Floor Area 0.013001 Property GFA - Self-Reported (ft²) 0.017360 Largest Property Use Type - Gross Floor Area (ft²) 0.018330 Order 0.036827 Community Board 0.056612 Council District 0.061639 score 1.000000 Name: score, dtype: float64 可以看到，有几个特征与目标变量score存在强负相关关系，与score最负相关的是： Energy Use Intensity (EUI) Site EUI (kBtu/ft²) Weather Normalized Site EUI (kBtu/ft²)（这些只在计算方式上略有不同）。 EUI是建筑使用的能量除以建筑物的平方英尺，并且用于衡量建筑物的效率，其中得分越低越好。 直观地说，这些相关性是有意义的：随着EUI的增加，能源之星得分score趋于下降。 为了考虑可能的非线性关系，我们可以采用特征的平方根和自然对数变换，然后用分数计算相关系数。 为了尝试捕获行政区Borough或建筑type之间的任何可能的关系（这两个特征是类别变量）和分数，我们将对这些特征进行独热编码。 在下面的代码中，我们采用以下策略： 对数值特征：进行平方根和对数变换； 对两个类别变量（Borough和type）进行独热编码； 最后计算所有特征与score之间的相关性，并显示前15个 最积极的和前15个最负相关。 1234567891011121314151617181920212223242526# 选择数值特征numeric_subset = data.select_dtypes('number')# 创建平方根和对数列for col in numeric_subset.columns: # 跳过 Energy Star Score 列 if col == 'score': next else: numeric_subset['sqrt_' + col] = np.sqrt(numeric_subset[col]) numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 独热编码categorical_subset = pd.get_dummies(categorical_subset)# 使用concat对两个数据帧进行拼接，axis=1列绑定features = pd.concat([numeric_subset, categorical_subset], axis = 1)# 去掉没有评分的建筑物features = features.dropna(subset = ['score'])# 计算特征与score之间的相关性correlations = features.corr()['score'].dropna().sort_values() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: divide by zero encountered in log # This is added back by InteractiveShellApp.init_path() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:10: RuntimeWarning: invalid value encountered in sqrt # Remove the CWD from sys.path while we load stuff. C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: invalid value encountered in log # This is added back by InteractiveShellApp.init_path() 12# 显示最负相关的15个特征correlations.head(15) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 sqrt_Site EUI (kBtu/ft²) -0.699817 sqrt_Weather Normalized Site EUI (kBtu/ft²) -0.689019 sqrt_Weather Normalized Source EUI (kBtu/ft²) -0.671044 sqrt_Source EUI (kBtu/ft²) -0.669396 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 log_Source EUI (kBtu/ft²) -0.622892 log_Weather Normalized Source EUI (kBtu/ft²) -0.620329 log_Site EUI (kBtu/ft²) -0.612039 log_Weather Normalized Site EUI (kBtu/ft²) -0.601332 log_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.424246 sqrt_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.406669 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Name: score, dtype: float64 12# # 显示最正相关的15个特征correlations.tail(15) sqrt_Order 0.028662 Borough_Queens 0.029545 Largest Property Use Type_Supermarket/Grocery Store 0.030038 Largest Property Use Type_Residence Hall/Dormitory 0.035407 Order 0.036827 Largest Property Use Type_Hospital (General Medical &amp; Surgical) 0.048410 Borough_Brooklyn 0.050486 log_Community Board 0.055495 Community Board 0.056612 sqrt_Community Board 0.058029 sqrt_Council District 0.060623 log_Council District 0.061101 Council District 0.061639 Largest Property Use Type_Office 0.158484 score 1.000000 Name: score, dtype: float64 在进行非线性转换特征之后： 最强的特征仍然是与能量使用强度（EUI）相关的特征。 对数和平方根变换似乎没有产生任何更强的特征。 尽管我们确实看到建筑类型的办公室（Largest Property Use Type_Office ）与score略微正相关，但没有强烈的正线性关系。此变量是建筑类型的分类变量的独热编码表示。 我们可以使用这些相关性来执行特征选择。 现在，让我们绘制数据集中最重要的相关性（就绝对值而言），即Site EUI (kBtu/ft²)。 我们可以通过建筑类型为图形着色，以显示它如何影响关系。 2.5 双变量分析为了可视化两个变量之间的关系，我们使用散点图。我们还可以使用标记的颜色或大小等方面包含其他变量。在这里，我们将绘制两个数值变量，并使用颜色表示第三个分类变量。 12345678910111213141516figsize(12, 10)# 提取建筑类型特征features['Largest Property Use Type'] = data.dropna(subset=['score'])['Largest Property Use Type']# 限制只取观测值大于100的建筑类型 (从前面的代码)features = features[features['Largest Property Use Type'].isin(types)]# 利用seaborn画score和Site EUI的回归散点图sns.lmplot('Site EUI (kBtu/ft²)', 'score', hue = 'Largest Property Use Type', data = features, scatter_kws = &#123;'alpha': 0.8, 's': 60&#125;, fit_reg = False, size = 12, aspect = 1.2);plt.xlabel('Site EUI', size = 28)plt.ylabel('Energy Star Score', size = 28)plt.title('Energy Star Score vs Site EUI', size = 36) C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\regression.py:546: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(msg, UserWarning) Text(0.5, 1.0, &apos;Energy Star Score vs Site EUI&apos;) Site EUI与score之间存在明显的负相关关系。 这种关系不是完全线性的（相似系数为-0.7，但看起来这个特征对预测建筑物的score很重要。 2.6 多变量分析（pairs plot）我们还可以在几个不同的变量之间建立Pairs Plot。 Pairs Plot是一次检查多个变量的好方法，因为它显示了对角线上的变量对和单个变量直方图之间的散点图。 使用seaborn PairGrid函数，我们可以将不同的图绘制到网格中: 上三角：散点图 对角线：直方图 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计。 123456789101112131415161718192021222324252627282930313233343536373839# 提取需要绘制的变量plot_data = features[['score', 'Site EUI (kBtu/ft²)', 'Weather Normalized Source EUI (kBtu/ft²)', 'log_Total GHG Emissions (Metric Tons CO2e)']]# 使用nan代替infplot_data = plot_data.replace(&#123;np.inf: np.nan, -np.inf:np.nan&#125;)# 重命名列plot_data = plot_data.rename(columns = &#123;'Site EUI (kBtu/ft²)': 'Site EUI', 'Weather Normalized Source EUI (kBtu/ft²)': 'Weather Norm EUI', 'log_Total GHG Emissions (Metric Tons CO2e)': 'log GHG Emissions'&#125;)# 删除缺失值plot_data = plot_data.dropna()# 用于计算两个特征的相关系数的函数def corr_func(x, y, **kwargs): # 计算皮尔逊积矩相关系数 r = np.corrcoef(x, y)[0][1] ax = plt.gca() ax.annotate("r = &#123;:.2f&#125;".format(r), xy=(.2, .8), xycoords=ax.transAxes, size = 20)# 创建绘图网格矩阵grid = sns.PairGrid(data = plot_data, size = 3)# 上三角：散点图grid.map_upper(plt.scatter, color = 'red', alpha = 0.6)# 对角线：直方图grid.map_diag(plt.hist, color = 'red', edgecolor = 'black')# 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计grid.map_lower(corr_func);grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds)# 整张图的标题plt.suptitle('Pairs Plot of Energy Data', size = 36, y = 1.02); C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\axisgrid.py:1241: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(UserWarning(msg)) 为了解释图中的关系，我们可以查找一行中的变量与一列中的变量相交的位置。 例如， 要查找score与log of GHG Emissions之间的关系，我们会查看score列和 log of GHG Emissions行。在交叉点（左下图），我们看到得分与该变量的相关系数为-0.35。如果我们查看对应的右上角图，我们可以看到这种关系的散点图。 同样，要查看Weather EUorm EUI与score的相关性，我们查看Weather EUorm EUI行和score列，可以看到相关系数为-0.67。 3 特征工程和特征选择现在我们已经探索了数据中的趋势和关系，我们可以为我们的模型设计一组功能。 我们可以使用EDA的结果来进行特征工程。 特别是，我们从EDA学到了以下知识，可以帮助我们设计/选择特征： 分数score分布因建筑类型type而异，并且在较小程度上因行政区Borough而异。 因此我们不仅需要关注数值特征，还应该在模型中包含这两个类别特征； 对特征进行对数或平方根变换不会导致特征与分数之间的线性相关性显着增加。 在我们进一步讨论之前，我们应该理解特征工程和特征选择，这些定义是非正式的，并且有相当大的重叠，但我喜欢将它们视为两个独立的过程： 特征工程: 获取原始数据并提取或创建新特征的过程，这些特征允许机器学习模型学习这些特征与目标之间的映射。 这可能意味着对变量进行转换，例如我们对数值特征进行对数和平方根转换，或者对类别变量使用独热编码，以便可以在模型中使用它们。 通常，我认为特征工程是添加从原始数据派生的附加特征。 特征选择: 选择数据中最相关特征的过程。 “最相关”可能取决于许多因素，但它可能与目标的最高相关性或具有最大差异的特征most variance。 在特征选择中，我们会删除对模型学习无用的特征。 这可以帮助模型更好地概括新数据并产生更可解释的模型。 一般来说，我认为特征选择是减去特征，所以我们只留下最重要的特征。 特征工程和选择是迭代过程，通常需要多次尝试才能得到较好的结果。 通常，我们将使用建模结果（例如来自随机森林的特征重要性排序）返回并重做特征选择，或者需要创建新特征的关系。 此外，这些过程通常包含领域知识和数据统计质量的混合。 特征工程和选择 对于获得一个高精度的机器学习模型至关重要。 它可能需要耗费很长时间，但通常比用于模型的算法和超参数选择更重要。 如果我们不为模型提供正确的数据，那么我们将其视为失败，我们不应期望它能够学习！ 在本项目中，我们将采用以下步骤进行特征工程： 仅选择数值变量和两个分类变量（行政区borough和建筑物类型property use type） 对数值变量进行对数变换 对类别变量进行One-hot编码 对于特征选择，我们将执行以下操作： 删除共线性特征 当我们进行特征选择时，我们将讨论共线性（也称为多重共线性）！ 以下代码选择数值特征，并进行对数变换，选择类别特征进行独热编码，并将特征拼接在一起。 1234567891011121314151617181920212223# 复制原始数据features = data.copy# 选择数值特征numeric_subset = data.select_dtypes('number')# 对每一个数值特征进行对数变换for col in numeric_subset.columns: # score为要预测的目标变量，跳过 if col == 'score': next else: numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 进行独热编码categorical_subset = pd.get_dummies(categorical_subset)# 列拼接，axis = 1features = pd.concat([numeric_subset, categorical_subset], axis = 1)features.shape C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: divide by zero encountered in log del sys.path[0] C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: invalid value encountered in log del sys.path[0] (11319, 110) 此时，我们有11319个观测（建筑物），具有109个不同的特征（其中一列是分数score）。 并非所有这些特征对于预测分数有帮助，其中一些特征也许是多余的，因为它们具有高度相关性。 我们将在下面讨论第二个问题。 3.1 删除共线性特征高共线特征在它们之间具有显着的相关系数。 例如，在我们的数据集中，Site EUI和Weather Normalized Site EUI高度相关，因为它们只是略微不同的计算能源使用强度的方法。 12345plot_data = data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna()plt.plot(plot_data['Site EUI (kBtu/ft²)'], plot_data['Weather Normalized Site EUI (kBtu/ft²)'], 'bo')plt.xlabel('Site EUI')plt.ylabel('Weather Norm EUI')plt.title('Weather Norm EUI vs Site EUI, R = %0.4f' % np.corrcoef(data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna(), rowvar=False)[0][1]); 高度共线性的特征可能是多余的，我们只需保留其中一个特征即可为模型提供必要的信息。 删除共线性特征是一种通过减少特征数量来降低模型复杂性的方法，可以提高模型泛化能力。 它还可以帮助我们解释模型，因为我们只需要考虑单一变量，例如EUI，而不是 EUI 和 weather normalized EUI 如何影响分数。 有许多方法可以消除共线特征，例如使用方差膨胀因子。 我们将使用更简单的度量，并删除具有高于某个阈值的相关系数的特征（不是分数，因为我们需要与分数高度相关的特征！）有关删除共线性特征的更全面的讨论， 可以看Kaggle的这个notebook。 以下代码通过删除所比较的两个特征之一，根据我们为相关系数选择的阈值来移除共线性特征。 它还会打印它删除的相关性，以便我们可以看到调整阈值的效果。 我们将使用0.6的阈值，如果特征之间的相关系数超过该值，则删除一对特征中的一个。 代码改编自Stack Overflow的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def remove_collinear_features(x, threshold): ''' Objective: Remove collinear features in a dataframe with a correlation coefficient greater than the threshold. Removing collinear features can help a model to generalize and improves the interpretability of the model. Inputs: threshold: any features with correlations greater than this value are removed Output: dataframe that contains only the non-highly-collinear features ''' # 不要删除与目标变量score之间的相关性 y = x['score'] x = x.drop(columns = ['score']) # 计算相关性矩阵 corr_matrix = x.corr() iters = range(len(corr_matrix.columns) - 1) drop_cols = [] # 遍历相关性矩阵并进行比较 for i in iters: for j in range(i): item = corr_matrix.iloc[j:(j+1), (i+1):(i+2)] col = item.columns row = item.index val = abs(item.values) # 如果有相关性超过阈值 if val &gt;= threshold: # Print the correlated features and the correlation value print(col.values[0], "|", row.values[0], "|", round(val[0][0], 2)) drop_cols.append(col.values[0]) # 删除每对相关特征中的一个 drops = set(drop_cols) x = x.drop(columns = drops) # 删除具有明显相关性的特征，知识计算方式不同 x = x.drop(columns = ['Weather Normalized Site EUI (kBtu/ft²)', 'Water Use (All Water Sources) (kgal)', 'log_Water Use (All Water Sources) (kgal)', 'Largest Property Use Type - Gross Floor Area (ft²)']) # 将目标变量添加回数据帧 x['score'] = y return x 12# 删除相关系数大于指定阈值的特征features = remove_collinear_features(features, 0.6) Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.83 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.81 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.85 Natural Gas Use (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Weather Normalized Site Natural Gas Use (therms) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Electricity Use - Grid Purchase (kBtu) | DOF Gross Floor Area | 0.63 Electricity Use - Grid Purchase (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 Weather Normalized Site Electricity (kWh) | DOF Gross Floor Area | 0.66 Weather Normalized Site Electricity (kWh) | Largest Property Use Type - Gross Floor Area (ft²) | 0.66 Total GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.75 Total GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.79 Total GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.92 Direct GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.97 Direct GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.96 Indirect GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.61 Indirect GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.64 Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.87 Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.86 Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.99 Property GFA - Self-Reported (ft²) | Natural Gas Use (kBtu) | 0.6 Property GFA - Self-Reported (ft²) | Weather Normalized Site Natural Gas Use (therms) | 0.6 Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.7 Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.7 Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.81 Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.81 Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.79 Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 1.0 Council District | Order | 0.86 Council District | Latitude | 0.68 log_Order | Order | 0.88 log_Order | Council District | 0.64 log_Property Id | Property Id | 0.93 log_DOF Gross Floor Area | DOF Gross Floor Area | 0.69 log_DOF Gross Floor Area | Largest Property Use Type - Gross Floor Area (ft²) | 0.63 log_DOF Gross Floor Area | Electricity Use - Grid Purchase (kBtu) | 0.62 log_DOF Gross Floor Area | Weather Normalized Site Electricity (kWh) | 0.62 log_DOF Gross Floor Area | Total GHG Emissions (Metric Tons CO2e) | 0.65 log_DOF Gross Floor Area | Property GFA - Self-Reported (ft²) | 0.65 log_Largest Property Use Type - Gross Floor Area (ft²) | DOF Gross Floor Area | 0.61 log_Largest Property Use Type - Gross Floor Area (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.68 log_Largest Property Use Type - Gross Floor Area (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Largest Property Use Type - Gross Floor Area (ft²) | Property GFA - Self-Reported (ft²) | 0.68 log_Year Built | Year Built | 1.0 log_Number of Buildings - Self-reported | Number of Buildings - Self-reported | 0.73 log_Occupancy | Occupancy | 0.93 log_Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.71 log_Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.68 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.93 log_Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.65 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.91 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.9 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.76 log_Natural Gas Use (kBtu) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Natural Gas Use (kBtu) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Weather Normalized Site Natural Gas Use (therms) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Weather Normalized Site Natural Gas Use (therms) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Electricity Use - Grid Purchase (kBtu) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity (kWh) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | log_DOF Gross Floor Area | 0.74 log_Electricity Use - Grid Purchase (kBtu) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Electricity Use - Grid Purchase (kBtu) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Weather Normalized Site Electricity (kWh) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity (kWh) | 0.62 log_Weather Normalized Site Electricity (kWh) | log_DOF Gross Floor Area | 0.75 log_Weather Normalized Site Electricity (kWh) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.74 log_Weather Normalized Site Electricity (kWh) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Total GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Total GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.73 log_Total GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.76 log_Total GHG Emissions (Metric Tons CO2e) | log_Site EUI (kBtu/ft²) | 0.6 log_Total GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Source EUI (kBtu/ft²) | 0.67 log_Total GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.84 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.68 log_Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.74 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.77 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity (kWh) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Total GHG Emissions (Metric Tons CO2e) | 0.84 log_Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.61 log_Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 log_Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.61 log_Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.61 log_Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.64 log_Property GFA - Self-Reported (ft²) | Property GFA - Self-Reported (ft²) | 0.69 log_Property GFA - Self-Reported (ft²) | log_DOF Gross Floor Area | 0.92 log_Property GFA - Self-Reported (ft²) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.98 log_Property GFA - Self-Reported (ft²) | log_Electricity Use - Grid Purchase (kBtu) | 0.75 log_Property GFA - Self-Reported (ft²) | log_Weather Normalized Site Electricity (kWh) | 0.76 log_Property GFA - Self-Reported (ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.77 log_Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.77 log_Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.66 log_Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.9 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.89 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.78 log_Source EUI (kBtu/ft²) | log_Weather Normalized Source EUI (kBtu/ft²) | 1.0 log_Source EUI (kBtu/ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.67 log_Latitude | Latitude | 1.0 log_Latitude | Council District | 0.68 log_Community Board | Community Board | 0.92 log_Council District C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:33: RuntimeWarning: invalid value encountered in greater_equal | Order | 0.92 log_Council District | Council District | 0.91 log_Council District | log_Order | 0.79 log_Census Tract | Census Tract | 0.78 Borough_Bronx | Latitude | 0.62 Borough_Bronx | Longitude | 0.69 Borough_Bronx | log_Latitude | 0.62 Borough_Brooklyn | Latitude | 0.74 Borough_Brooklyn | Council District | 0.89 Borough_Brooklyn | log_Latitude | 0.74 Borough_Brooklyn | log_Council District | 0.75 Borough_Manhattan | Order | 0.81 Borough_Manhattan | Council District | 0.78 Borough_Manhattan | log_Order | 0.63 Borough_Manhattan | log_Council District | 0.84 Borough_Queens | Order | 0.62 Largest Property Use Type_Office | Largest Property Use Type_Multifamily Housing | 0.63 12features = features.dropna(axis=1, how = 'all')features.shape (11319, 65) 我们的最终数据集有64个特征（其中一列是目标score）。 这仍然不少，但主要是因为我们有一个独热编码的分类变量。 诸如线性回归之类的模型可能存在大量特征， 但诸如随机森林之类的模型执行隐式特征选择并自动确定在训练期间哪些特征是重要的。 还有其他特征选择步骤，但是现在我们将保留我们拥有的所有特征用于训练模型并检验模型的性能。 其他选择选择方法还有很多特征选择的方法，比如主成分分析（PCA），其将特征降低为若干个最大方差的维度，或独立成分分析（ICA），其旨在在一组特征中找到独立源。 然而，虽然这些方法在减少特征数量方面是有效的，但它们创造了没有物理意义的新特征，因此几乎不可能解释模型。 这些方法对于处理高维数据非常有用，更多相关内容。 3.2 训练集和测试集的划分在机器学习中，我们通常需要将我们的数据分为两组： 训练集：有特征和目标值的，用于学习特征和目标之间的映射。 测试集：用于验证模型的效果，该模型从未在测试集上看到过目标值，而是必须使用这些特征进行预测。当我们知道测试集的真实答案时，我们可以将测试预测值与真实值进行比较，以估计我们的模型在现实世界中部署时的表现。 本项目中，我们将首先提取所有没有Energy Star Score能源之星得分的建筑物（我们不知道这些建筑物的真实答案，因此它们对训练或测试没有帮助）。然后，我们将有分数的建筑物分成70&amp;的训练集和30%的测试集。 使用scikit-learn将数据随机拆分为训练和测试集很简单。我们可以设置拆分的random_state以确保一致的结果。 123456# 将数据按照有无score分类no_score = features[features['score'].isna()]score = features[features['score'].notnull()]print(no_score.shape)print(score.shape) (1858, 65) (9461, 65) 1234567891011121314# 将特征和目标变量拆分features = score.drop(columns='score')targets = pd.DataFrame(score['score'])# 为了方便后续的填充，用np.nan替换np.inf和-np.inffeatures = features.replace(&#123;np.inf: np.nan, -np.inf: np.nan&#125;)# 划分70%的训练集和30%的测试集X, X_test, y, y_test = train_test_split(features, targets, test_size = 0.3, random_state = 42)print(X.shape)print(y.shape)print(X_test.shape)print(y_test.shape) (6622, 64) (6622, 1) (2839, 64) (2839, 1) 我们有1858座没有分数的建筑；有分数的建筑中，6622座用作训练集，2839座用作测试集中，接下来建立一个naive 的 baseline以在后续模型中不断优化。 3.3 建立一个baseline在我们开始建立机器学习模型之前建立一个naive的基线是很重要的。 如果我们构建的模型不能胜过naive的猜测，那么我们可能不得不承认机器学习不适合这个问题。 这可能是因为我们没有使用正确的模型，需要更多的数据，或者因为有一个更简单的解决方案，不需要机器学习。 建立基线至关重要，因此我们最终可能不会去建立机器学习模型，只是意识到我们无法真正解决问题。 对于回归任务，良好的基线是使用训练集上目标的中值作为所有所有测试集样本的预测值。这很容易实现，并为我们的模型设置了相对较低的标准：如果它们不能比猜测的中值更好，那么我们需要重新思考我们的方法。 度量标准：平均绝对误差机器学习任务中使用了许多指标，很难知道选择哪一个指标。 大多数情况下，它将取决于特定问题，如果有一个特定的目标来优化。 Andrew Ng建议使用单个实值性能指标来比较模型，因为它简化了评估过程。 我们应该使用一个数字，而不是计算多个指标并尝试确定每个指标的重要程度。 在这种情况下，因为我们进行回归，所以平均绝对误差是适当的度量。 这也是可以解释的，因为它表示我们的估计的平均分数数量，并且与目标值的单位相同 下面的函数计算真实值和预测值之间的平均绝对误差。 123# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred)) 现在我们可以做中值猜测并用于测试集。 1234baseline_guess = np.median(y)print('The baseline guess is a score of %0.2f' % baseline_guess)print("Baseline Performance on the test set: MAE = %0.4f" % mae(y_test, baseline_guess)) The baseline guess is a score of 66.00 Baseline Performance on the test set: MAE = 24.5164 这表明我们对测试集的平均估计偏差约25%。 因为分数在1到100之间，因此这意味着来自baseline的平均误差约25%。猜测训练集中值的naive方法为我们的后续的模型提供了一个低基线！ 3.4 小结到目前为止，我们完成了开头所说机器学习工作流程的前三个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 我们还完成了建立基线指标的关键任务，以便我们确定我们的模型是否比猜测更好！ 以上我们了解了流程中的每个部分是如何流入下一个部分的： 清理数据并将其转换为正确的格式允许我们执行探索性数据分析(EDA)； EDA的结果辅助我们进行特征工程和选择。 这三个步骤通常按此顺序执行，但我们可能会稍后再回来，根据我们的建模结果进行更多的EDA或特征工程。数据科学是一个迭代过程，我们一直在寻找改进以前工作的方法。这意味着我们不必第一次完成任务（尽管我们可以尽力），因为一旦我们对问题有了更多的了解，总有机会重新审视我们的决策。 接下来，我们将重点实现几种机器学习方法，选择最佳模型，并使用交叉验证的超参数调整方法优化我们的问题。 同时，把我们处理过的数据集保存起来，以便在后续步骤中再次使用。 123456# 保存没有分数的数据集，训练集，测试集no_score.to_csv('dataset/no_score.csv', index = False)X.to_csv('dataset/training_features.csv', index = False)X_test.to_csv('dataset/testing_features.csv', index = False)y.to_csv('dataset/training_labels.csv', index = False)y_test.to_csv('dataset/testing_labels.csv', index = False) 4 评估和比较机器学习模型4.1 导入库文件在本项目中，我们使用各种标准的数据科学和机器学习库。 1234567891011# 缺失值填充和最大最小归一化处理from sklearn.preprocessing import Imputer, MinMaxScaler# 机器学习模型from sklearn.linear_model import LinearRegressionfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.svm import SVRfrom sklearn.neighbors import KNeighborsRegressor# 超参数调整from sklearn.model_selection import RandomizedSearchCV, GridSearchCV 4.2 导入数据读取前面部分处理好的数据。 1234567891011# 使用数据帧读取数据train_features = pd.read_csv('dataset/training_features.csv')train_labels = pd.read_csv('dataset/training_labels.csv')test_features = pd.read_csv('dataset/testing_features.csv')test_labels = pd.read_csv('dataset/testing_labels.csv')# 数据维度print('Training Feature Size:', train_features.shape)print('Training Labels Size:', train_labels.shape)print('Testing Feature Size:', test_features.shape)print('Testing Labels Size:', test_labels.shape) Training Feature Size: (6622, 64) Training Labels Size: (6622, 1) Testing Feature Size: (2839, 64) Testing Labels Size: (2839, 1) 这是格式化后的数据。 在前文，我们对数值特征进行了对数变换，对两个类别特征进行独热编码，并通过删除高共线特征来选择特征子集。 1train_features.head(12) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Order Property Id DOF Gross Floor Area Year Built Number of Buildings - Self-reported Occupancy Site EUI (kBtu/ft²) Weather Normalized Site Electricity Intensity (kWh/ft²) Weather Normalized Site Natural Gas Intensity (therms/ft²) Water Intensity (All Water Sources) (gal/ft²) … Largest Property Use Type_Restaurant Largest Property Use Type_Retail Store Largest Property Use Type_Self-Storage Facility Largest Property Use Type_Senior Care Community Largest Property Use Type_Social/Meeting Hall Largest Property Use Type_Strip Mall Largest Property Use Type_Supermarket/Grocery Store Largest Property Use Type_Urgent Care/Clinic/Other Outpatient Largest Property Use Type_Wholesale Club/Supercenter Largest Property Use Type_Worship Facility 0 13276 5849784 90300.0 1950 1 100 126.0 5.2 1.2 99.41 … 0 0 0 0 0 0 0 0 0 0 1 7377 4398442 52000.0 1926 1 100 95.4 4.7 0.9 NaN … 0 0 0 0 0 0 0 0 0 0 2 9479 4665374 104700.0 1954 1 100 40.4 3.8 0.3 NaN … 0 0 0 0 0 0 0 0 0 0 3 14774 3393340 129333.0 1992 1 100 157.1 16.9 1.1 NaN … 0 0 0 1 0 0 0 0 0 0 4 3286 2704325 109896.0 1927 1 100 62.3 3.5 0.0 28.65 … 0 0 0 0 0 0 0 0 0 0 5 1060 2430725 182655.0 1929 1 90 52.9 9.7 0.2 4.80 … 0 0 0 0 0 0 0 0 0 0 6 10846 5737475 65400.0 1942 1 100 66.8 3.0 0.6 67.14 … 0 0 0 0 0 0 0 0 0 0 7 4280 2670505 113150.0 1938 1 100 78.4 5.7 NaN 30.73 … 0 0 0 0 0 0 0 0 0 0 8 12974 2964670 137700.0 1959 1 100 63.0 3.4 0.5 41.96 … 0 0 0 0 0 0 0 0 0 0 9 13244 4414693 63693.0 1941 1 100 97.8 4.3 0.8 86.88 … 0 0 0 0 0 0 0 0 0 0 10 3903 2669664 82644.0 1922 1 100 55.4 4.5 0.0 NaN … 0 0 0 0 0 0 0 0 0 0 11 8336 2809354 51317.0 1925 1 100 118.7 3.6 1.1 NaN … 0 0 0 0 0 0 0 0 0 0 12 rows × 64 columns training_labels包含能源之星分数，这是我们机器学习问题的目标。 能源之星评分是对建筑物能效的比较测量。 这是能源之星得分的分布。 1234567figsize(8, 8)# score的直方图分布plt.hist(train_labels['score'].dropna(), bins = 100);plt.xlabel('Score')plt.ylabel('Number of Building')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &apos;Energy Star Score Distribution&apos;) 4.3 评估和比较机器学习模型在本节中，我们将为我们的监督回归任务构建、训练及评估几种机器学习方法。 目标是确定哪个模型最有希望进一步开发（例如超参数调整）。 我们使用平均绝对误差作为指标来比较模型。 从3.3节可知随机猜测得分中值的基线模型平均偏离25分。 4.3.1 填充缺失值通常机器学习模型无法处理缺失值，这意味着我们必须找到一种方法来填充或忽略任何缺少值的特征。由于我们在1.4节已经删除了缺失值超过50%的特征，因此我们将重点填充剩下特征的缺失值)。有许多填充方法，但在这里我们将使用相对简单的方法用列的中位数替换缺失值。 （这是关于缺失值填充的更全面的讨论） 在下面的代码中，我们创建一个Scikit-learn Imputer对象，用列的中值填充缺失值。请注意，我们只在训练数据上使用Imputer.fit，但在测试数据集没有使用。然后我们使用Imputer.transform同时处理训练数据集和测试数据集。这意味着测试集中的缺失值用训练集中相应列的中值填充。我们必须现在这么做而不是部署时，我们必须根据训练数据集将测试集的缺失值填充。这是避免数据泄漏问题的一种方法，数据泄露指来自测试集的信息“泄漏”到训练过程中。 123456789# 使用中位数填充策略创建一个imputer对象imputer = Imputer(strategy = 'median')# imputer对象作用于训练集imputer.fit(train_features)# 转换训练数据和测试数据X = imputer.transform(train_features)X_test = imputer.transform(test_features) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\utils\deprecation.py:58: DeprecationWarning: Class Imputer is deprecated; Imputer was deprecated in version 0.20 and will be removed in 0.22. Import impute.SimpleImputer from sklearn instead. warnings.warn(msg, category=DeprecationWarning) 12print('Missing values in training features: ', np.sum(np.isnan(X)))print('Missing values in testing features: ', np.sum(np.isnan(X_test))) Missing values in training features: 0 Missing values in testing features: 0 123# 保证所有数字都是有限值print(np.where(~np.isfinite(X)))print(np.where(~np.isfinite(X_test))) (array([], dtype=int64), array([], dtype=int64)) (array([], dtype=int64), array([], dtype=int64)) 在填充之后，所有特征都是实值的。 对于更复杂的缺失值处理方法（尽管中值通常很有效），请查看本文 4.3.2 特征缩放在我们构建模型之前要采取的最后一步是特征缩放。这是必要的，因为特征之间具有不同的单位度量，我们希望对特征进行标准化，以使单位不影响算法的结果。 线性回归和随机森林不需要特征缩放 但是其他方法（例如支持向量机和kNN）需要进行特征缩放，因为它们考虑了样本之间的欧几里德距离。因此，在比较多个算法时，最佳做法是进行特征缩放。 有两种常用的特征缩放方法： 对于每个值，减去特征的平均值并除以特征的标准偏差。这称为标准化，并且导致每个特征具有0均值和1标准差。 对于每个值，减去特征的最小值并除以最大值减去最小值（范围）。这确保了特征的所有取值都在0和1之间，这称为归一化。 这是一篇关于规范化和标准化的好文章。 与缺失值处理一样，当我们进行特征缩放时，我们只使用训练集计算缩放对象。当我们转换特征时，我们将转换训练集和测试集。 123456789# 创建（0,1）之间的缩放对象scaler = MinMaxScaler(feature_range=(0, 1))# 拟合训练集scaler.fit(X)# 对训练集和测试集进行变换X = scaler.transform(X)X_test = scaler.transform(X_test) 123# 将y转换为一维数组y = np.array(train_labels).reshape((-1, ))y_test = np.array(test_labels).reshape((-1, )) 1y.shape (6622,) 4.4 评估模型我们将使用Scikit-Learn库比较五种不同的机器学习模型： 线性回归 支持向量机回归 随机森林回归 梯度提升回归 K-Nearest Neighbors回归 在本节，我专注于模型实现过程，而不是解释这些模型是如何工作的。除了动手机器学习之外，阅读机器学习模型的另一个重要资源（这是免费的在线）是统计学习简介。 为了比较模型，我们将主要使用模型超参数的Scikit-Learn默认值。通常这些将表现得很好，但应该在实际使用模型之前进行优化。首先，我们只想确定每个模型的基线性能，然后我们可以选择性能最佳的模型，再使用超参数调整进一步优化。请记住，默认的超参数将启动并运行模型，但几乎总是应该使用某种搜索来调整以找到问题的最佳设置！ 以下是Scikit-learn文档中有关默认值的内容： __Sensible defaults__: Whenever an operation requires a user-defined parameter,an appropriate default value is defined by the library. The default value should cause the operation to be performed in a sensible way (giving a baseline solution for the task at hand.) 关于scikit-learn的最大的特点是所有模型都以相同的方式实现：一旦你知道如何构建一个模型，你就可以实现一系列极其多样化的模型。在这里，我们将用几行代码实现多个模型。 123456789101112131415# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred))# 模型训练和预测过程，输入任意模型，输出maedef fit_and_evaluate(model): # 训练模型 model.fit(X, y) # 预测和评估 model_pred = model.predict(X_test) model_mae = mae(y_test, model_pred) # 返回误差指标 return model_mae 12345# 线性回归lr = LinearRegression()lr_mae = fit_and_evaluate(lr)print('Linear Regression Performance on the test set: MAE = %0.4f' % lr_mae) Linear Regression Performance on the test set: MAE = 13.4651 12345# 支持向量回归svm = SVR(C = 1000, gamma = 0.1)svm_mae = fit_and_evaluate(svm)print('Support Vector Machine Regression Performance on the test set: MAE = %0.4f' % svm_mae) Support Vector Machine Regression Performance on the test set: MAE = 10.9337 12345# 随机森林random_forest = RandomForestRegressor(random_state=60)random_forest_mae = fit_and_evaluate(random_forest)print('Random Forest Regression Performance on the test set: MAE = %0.4f' % random_forest_mae) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\ensemble\forest.py:246: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22. &quot;10 in version 0.20 to 100 in 0.22.&quot;, FutureWarning) Random Forest Regression Performance on the test set: MAE = 10.0073 12345# 梯度提升回归gradient_boosted = GradientBoostingRegressor(random_state=60)gradient_boosted_mae = fit_and_evaluate(gradient_boosted)print('Gradient Boosted Regression Performance on the test set: MAE = %0.4f' % gradient_boosted_mae) Gradient Boosted Regression Performance on the test set: MAE = 10.0144 12345# k近邻回归knn = KNeighborsRegressor(n_neighbors=10)knn_mae = fit_and_evaluate(knn)print('K-Nearest Neighbors Regression Performance on the test set: MAE = %0.4f' % knn_mae) K-Nearest Neighbors Regression Performance on the test set: MAE = 13.0131 123456789101112131415161718# 可视化比较不同模型的结果figsize(8, 4)# 保存结果的数据帧model_comparison = pd.DataFrame(&#123;'model': ['Linear Regression', 'Support Vector Machine', 'Random Forest', 'Gradient Boosted', 'K-Nearest Neighbors'], 'mae': [lr_mae, svm_mae, random_forest_mae, gradient_boosted_mae, knn_mae]&#125;)# 直方图model_comparison.sort_values('mae', ascending = False).plot(x = 'model', y = 'mae', kind = 'barh', color = 'red', edgecolor = 'black')plt.ylabel('')plt.yticks(size = 14)plt.xlabel('Mean Absolute Error')plt.xticks(size = 14)plt.title('Model Comparison on Test MAE', size = 20) Text(0.5, 1.0, &apos;Model Comparison on Test MAE&apos;) 根据模型结果比较（每次结果会略有变化），随机森林表现最佳，其次是梯度提升回归。 然而这不是最公平的比较，因为我们主要使用默认的超参数。特别是使用支持向量回归器，超参数对性能有显着影响。 （随机森林和梯度提升方法非常适合开始，因为性能较少依赖于模型设置）。 尽管如此，从这些结果中，我们可以得出结论，机器学习是适用的，因为所有模型都明显优于基线（3.3节25%的mae）！ 接下来，我将专注于使用超参数调整来优化最佳模型。鉴于此处的结果，我将专注于使用Gradient Boosting Regressor。因为Gradient Boosted Trees的Scikit-Learn实现，在过去的几年中赢得了许多Kaggle比赛。 Scikit-Learn版本通常比XGBoost版本慢，但在这里我们将坚持使用Scikit-Learn，因为语法更为熟悉。这是XGBoost包中使用实现的指南。 5 模型优化在机器学习中，优化模型意味着为特定问题找到最佳的超参数集。 5.1 超参数首先，我们需要了解哪些模型超参数与模型参数的对比： 模型超参数被认为是机器学习算法的设置，在训练之前由数据科学家调整。例如，随机森林中的树的数量，或者K Nearest Neighbors Regression中使用的近邻数量。 模型参数是模型在训练期间学习的内容，例如线性回归中的权重。 我们通过选择超参数来控制模型，这些选择会对模型的最终性能产生重大影响（尽管通常不会像获取更多数据或特征工程那么有效）。 调整模型超参数可以控制模型欠拟合与过拟合的平衡。 我们可以尝试通过更复杂的模型来校正欠拟合，例如在随机森林中使用更多树或在深度神经网络中使用更多层。不合适的模型具有高偏差，并且当我们的模型没有足够的容量（自由度）来学习特征和目标之间的关系时发生。 我们可以通过限制模型的复杂性和应用正则化来尝试纠正过拟合。这可能意味着降低多项式回归的阶数，或将dropout 层添加到深度神经网络。过拟合的模型具有高方差并且实际上记忆了训练集。 欠拟合和过拟合都会导致测试集上的泛化性能变差。 选择超参数的问题在于，没有任何超参数可以在所有问题中发挥最佳效果。因此，对于每个新数据集，我们必须找到最佳设置。这可能是一个耗时的过程，但幸运的是，在Scikit-Learn中执行此过程的方法有多种选择。更好的是，新的库，例如epistasis labs的TPOT，旨在自动完成此过程！本项目中，我们将坚持在Scikit-Learn中手动完成，但请继续关注自动模型选择的文章！ 5.2 使用随机搜索和交叉验证进行超参数调整我们可以通过随机搜索和交叉验证为模型选择最佳超参数。 随机搜索是指我们选择超参数来评估模型的方法： 我们定义一系列选项，然后随机选择要尝试的组合。这与网格搜索形成对比，网格搜索评估我们指定的每个组合。 通常，当我们对最佳模型超参数的知识有限时，随机搜索会更好，我们可以使用随机搜索缩小选项范围，然后使用更有限的选项范围进行网格搜索。 交叉验证是用于评估超参数性能的方法： 我们使用K-Fold交叉验证，而不是将数据集拆分为单独训练集的和验证集，以减少我们可以使用的训练数据量。 将训练数据划分为K个部分，然后遍历迭代过程，其中我们首先在K-1个数据集上训练，然后评估在第k个数据集的性能。 重复这个过程K次，所以最终我们将测试训练数据中的每个例子，关键是每次迭代我们都在测试我们没有训练过的数据。 在K折交叉验证结束时，我们将每次K次迭代的平均误差作为最终性能度量，然后在所有训练数据上训练模型。然后，我们记录的性能用于比较超参数的不同组合。 使用k = 5的k折交叉验证图片如下所示： 在这里，我们将使用交叉验证实现随机搜索，以选择梯度梯度回归模型的最佳超参数。 我们首先定义一个网格然后执行迭代过程：从网格中随机抽样一组超参数，使用4折交叉验证评估超参数，然后选择具有最佳性能的超参数。 当然我们实际上并没有自己做这个迭代，我们让Scikit-Learn和RandomizedSearchCV为我们完成这个过程！ 12345678910111213141516171819202122232425# 损失函数 均方差"ls", 绝对损失"lad", Huber损失"huber"loss = ['ls', 'lad', 'huber']# 提升过程使用的树的数量n_estimators = [100, 500, 900, 1100, 1500]# 每棵树的最大深度max_depth = [2, 3, 5, 10, 15]# 每个叶子节点的最少样本min_samples_leaf = [1, 2, 4, 6, 8]# 拆分节点的最小样本数min_samples_split = [2, 4, 6, 10]# 分割时要考虑的最大特征的数量max_features = ['auto', 'sqrt', 'log2', None]# 定义要进行超参数搜索的网络hyperparameter_grid = &#123;'loss': loss, 'n_estimators': n_estimators, 'max_depth': max_depth, 'min_samples_leaf': min_samples_leaf, 'min_samples_split': min_samples_split, 'max_features': max_features&#125; 我们选择了6个不同的超参数来调整GBDT回归。 这些都将以不同的方式影响模型，这些方法很难提前确定，找到特定问题的最佳组合的唯一方法是测试它们！ 要了解超参数，可以查看Scikit-Learn文档。现在，只要知道我们正在努力寻找超参数的最佳组合，并且因为没有理论告诉我们哪种方法效果最好，我们只需要评估它们，就像运行实验一样！ 在下面的代码中，我们创建了随机搜索对象，传递以下参数： estimator: 模型 param_distributions: 我们定义的超参数网络分布 cv ：用于k-fold交叉验证的folds 数量 n_iter: 不同的参数组合的数量 scoring: 评估候选参数时使用的指标 n_jobs: 并行运行时核的数量（-1 时全部使用） verbose: 显示信息的数量（1显示有限信息） return_train_score: 每一个cross-validation fold 返回的分数 random_state: 固定使用的随机数生成器，因此每次运行都会得到相同的结果 随机搜索对象的训练方式与任何scikit-learn模型相同。训练之后，我们可以比较所有不同的超参数组合，找到效果最好的组合。 1234567891011# 建立一个模型用于超参数搜索model = GradientBoostingRegressor(random_state = 42)# 配置具有4折交叉验证的随机搜索random_cv = RandomizedSearchCV(estimator=model, param_distributions=hyperparameter_grid, cv=4, n_iter=25, scoring = 'neg_mean_absolute_error', n_jobs = -1, verbose = 1, return_train_score = True, random_state=42) 12# 拟合训练数据random_cv.fit(X, y) Fitting 4 folds for each of 25 candidates, totalling 100 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 13.5min [Parallel(n_jobs=-1)]: Done 100 out of 100 | elapsed: 21.9min finished RandomizedSearchCV(cv=4, error_score=&apos;raise-deprecating&apos;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&apos;friedman_mse&apos;, init=None, learning_rate=0.1, loss=&apos;ls&apos;, max_depth=3, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_sampl...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&apos;warn&apos;, n_iter=25, n_jobs=-1, param_distributions={&apos;loss&apos;: [&apos;ls&apos;, &apos;lad&apos;, &apos;huber&apos;], &apos;n_estimators&apos;: [100, 500, 900, 1100, 1500], &apos;max_depth&apos;: [2, 3, 5, 10, 15], &apos;min_samples_leaf&apos;: [1, 2, 4, 6, 8], &apos;min_samples_split&apos;: [2, 4, 6, 10], &apos;max_features&apos;: [&apos;auto&apos;, &apos;sqrt&apos;, &apos;log2&apos;, None]}, pre_dispatch=&apos;2*n_jobs&apos;, random_state=42, refit=True, return_train_score=True, scoring=&apos;neg_mean_absolute_error&apos;, verbose=1) Scikit-learn使用负平均绝对误差进行评估，因为它希望度量最大化。 因此，更好的分数将更接近0.我们可以将随机搜索的结果导入数据帧，并按性能进行排序。 123# 获取cv的结果并按性能排序random_result = pd.DataFrame(random_cv.cv_results_).sort_values('mean_test_score', ascending = False)random_result.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean_fit_time std_fit_time mean_score_time std_score_time param_n_estimators param_min_samples_split param_min_samples_leaf param_max_features param_max_depth param_loss … split3_test_score mean_test_score std_test_score rank_test_score split0_train_score split1_train_score split2_train_score split3_train_score mean_train_score std_train_score 12 28.192530 0.608962 0.045237 0.004876 500 6 6 None 5 lad … -9.037550 -8.999278 0.210556 1 -7.027368 -6.837958 -6.869084 -6.840749 -6.893790 0.078077 3 31.418641 0.792474 0.051468 0.005586 500 6 8 None 5 huber … -9.075047 -9.041601 0.176957 2 -4.482073 -4.326121 -4.823009 -4.229809 -4.465253 0.225313 9 17.848252 0.695412 0.049220 0.012429 500 4 2 auto 3 huber … -9.153004 -9.192167 0.148852 3 -7.007604 -7.088986 -6.913108 -6.940327 -6.987506 0.067939 0 4.366013 0.062413 0.019738 0.008490 100 2 6 auto 5 ls … -9.201235 -9.196321 0.162799 4 -7.302003 -7.312645 -7.173397 -7.386171 -7.293554 0.076569 7 14.755623 0.805518 0.044799 0.021501 500 4 6 auto 3 ls … -9.358627 -9.350987 0.215296 5 -7.089709 -7.103749 -7.021418 -7.080088 -7.073741 0.031358 10 148.541339 4.555165 0.209970 0.022747 1100 10 6 None 10 huber … -9.475944 -9.376750 0.128046 6 -0.378166 -0.459465 -0.393491 -0.370483 -0.400401 0.035092 19 40.463317 0.364893 0.069956 0.015818 1100 6 2 auto 3 lad … -9.291753 -9.382266 0.064885 7 -8.311796 -8.658903 -7.820534 -8.017995 -8.202307 0.316303 2 96.562840 2.933418 0.103937 0.006517 500 4 2 auto 10 huber … -9.429866 -9.422145 0.101949 8 -0.164859 -0.193613 -0.164415 -0.141062 -0.165987 0.018629 16 43.709564 0.503777 0.105925 0.024294 1500 4 6 None 3 ls … -9.427920 -9.447940 0.212403 9 -4.821677 -4.876202 -4.776650 -4.729506 -4.801009 0.054284 21 12.055894 0.548898 0.073206 0.012656 500 6 4 log2 5 huber … -9.409179 -9.460643 0.174556 10 -5.684121 -5.742441 -5.571781 -5.666476 -5.666205 0.061337 10 rows × 24 columns 1random_cv.best_estimator_ GradientBoostingRegressor(alpha=0.9, criterion=&apos;friedman_mse&apos;, init=None, learning_rate=0.1, loss=&apos;lad&apos;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=500, n_iter_no_change=None, presort=&apos;auto&apos;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 最佳梯度增强模型具有以下超参数: loss = lad n_estimators = 500 max_depth = 5 min_samples_leaf = 6 min_samples_split = 6 max_features = None (这意味着最大特征数量等于数据集中特征的数量) 使用随机搜索是缩小可能的超参数的好方法。最初，我们不知道哪种组合效果最好，但这至少缩小了选项的范围。 我们可以使用随机搜索结果来通过创建具有超参数的网格来通知网格搜索，这些参数接近于在随机搜索期间最有效的参数。接下来将重点放在单个树中的树数量（n_estimators）。通过仅改变一个超参数，我们可以直接观察它如何影响性能。在这种情况情况下，我们预计会看到对过拟合的影响。 在这里，我们将使用网格搜索，网格只有n_estimators超参数。我们将评估树的个数，然后绘制训练和测试性能，以了解增加树数量对模型的影响。我们将其他超参数固定为从随机搜索返回的最佳值，以直接查看树的数量对模型的影响。 12345678910111213# 创建一系列树的数量trees_grid = &#123;'n_estimators': [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]&#125;model = GradientBoostingRegressor(loss = 'lad', max_depth = 5, min_samples_leaf = 6, min_samples_split = 6, max_features = None, random_state = 42)# 对树的数量进行网络搜索grid_search = GridSearchCV(estimator = model, param_grid=trees_grid, cv = 4, scoring = 'neg_mean_absolute_error', verbose = 1, n_jobs = -1, return_train_score = True) 12# 拟合训练数据grid_search.fit(X, y) Fitting 4 folds for each of 15 candidates, totalling 60 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 3.4min [Parallel(n_jobs=-1)]: Done 60 out of 60 | elapsed: 6.2min finished GridSearchCV(cv=4, error_score=&apos;raise-deprecating&apos;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&apos;friedman_mse&apos;, init=None, learning_rate=0.1, loss=&apos;lad&apos;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samp...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&apos;warn&apos;, n_jobs=-1, param_grid={&apos;n_estimators&apos;: [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]}, pre_dispatch=&apos;2*n_jobs&apos;, refit=True, return_train_score=True, scoring=&apos;neg_mean_absolute_error&apos;, verbose=1) 123456789101112# 获取结果results = pd.DataFrame(grid_search.cv_results_)# 绘制不同树的数量的训练和测试误差figsize(8, 8)plt.style.use('fivethirtyeight')plt.plot(results['param_n_estimators'], -1 * results['mean_test_score'], label = 'Testing Error')plt.plot(results['param_n_estimators'], -1 * results['mean_train_score'], label = 'Training Error')plt.xlabel('Number of Trees')plt.ylabel('Mean Abosolute Error')plt.legend();plt.title('Performance vs Number of Trees') Text(0.5, 1.0, &apos;Performance vs Number of Trees&apos;) 1results.sort_values('mean_test_score', ascending = False).head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } mean_fit_time std_fit_time mean_score_time std_score_time param_n_estimators params split0_test_score split1_test_score split2_test_score split3_test_score mean_test_score std_test_score rank_test_score split0_train_score split1_train_score split2_train_score split3_train_score mean_train_score std_train_score 14 47.416784 0.998062 0.075453 0.009229 800 {‘n_estimators’: 800} -8.825290 -8.758299 -9.296941 -9.047485 -8.981946 0.210990 1 -6.739448 -6.648109 -6.486269 -6.530287 -6.601028 0.099437 13 42.438601 1.069725 0.075953 0.005428 750 {‘n_estimators’: 750} -8.830566 -8.751699 -9.298411 -9.049730 -8.982544 0.212523 2 -6.772908 -6.660453 -6.520818 -6.579989 -6.633542 0.094501 12 42.857592 0.706954 0.066710 0.008312 700 {‘n_estimators’: 700} -8.836049 -8.755862 -9.312990 -9.053755 -8.989605 0.216159 3 -6.812928 -6.695770 -6.611240 -6.624919 -6.686214 0.079884 9 27.753509 0.350437 0.042475 0.004150 550 {‘n_estimators’: 550} -8.853730 -8.756938 -9.325492 -9.042721 -8.994663 0.216865 4 -7.003413 -6.781878 -6.809121 -6.745712 -6.835031 0.099783 11 35.953674 0.654295 0.057465 0.004970 650 {‘n_estimators’: 650} -8.851136 -8.755401 -9.325190 -9.052215 -8.995928 0.218168 5 -6.864375 -6.721452 -6.708191 -6.666758 -6.740194 0.074480 从上图来看，很明显我们的模型过拟合了！训练误差明显低于测试误差，这表明模型正在很好地学习训练数据，但是无法泛化到测试数据。随着树数量的增加，对训练集的拟合效果变好，测试和训练误差都会减少，但训练误差会更快地减少。 训练误差和测试误差之间始终存在显著的差异（训练误差始终较低），我们希望通过获取更多训练数据或降低模型的复杂性来尝试降低过拟合，例如可以进行超参数调整或正则化。对于GDBT回归，可以减少树的数量，减少每棵树的最大深度，以及增加叶节点中的最小样本数。对于任何想要进一步了解GDBT回归的人来说，这是一篇很棒的文章。目前，我们将使用具有最佳性能的模型，并接受它可能对训练集过拟合的事实。 根据交叉验证结果，使用800棵树的最佳模型的交叉验证误差在9以下。这表明Energy Star Score能源之星得分的平均交叉验证估计在真实答案的9分之内，即使模型过拟合了，但仍然是一个不错的结果。 6 使用最佳模型评估测试集我们将使用超参数调整中的最佳模型来对测试集进行预测。 请记住，我们的模型以前从未见过测试集，所以这个性能应该是模型在现实世界中部署时的表现的一个很好的指标。 为了比较，我们还可以查看使用默认参数的模型的性能并和最佳模型进行比较。 下面的代码创建最终模型，训练它（带有时间），并评估测试集。 1234567# 默认模型default_model = GradientBoostingRegressor(random_state = 42)# 选择最优模型final_model = grid_search.best_estimator_final_model GradientBoostingRegressor(alpha=0.9, criterion=&apos;friedman_mse&apos;, init=None, learning_rate=0.1, loss=&apos;lad&apos;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&apos;auto&apos;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 12%%timeit -n 1 -r 5default_model.fit(X, y) 1.36 s ± 117 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12%%timeit -n 1 -r 5final_model.fit(X, y) 18.6 s ± 471 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12345default_pred = default_model.predict(X_test)final_pred = final_model.predict(X_test)print('Default model performance on the test set: MAE = %0.4f.' % mae(y_test, default_pred))print('Final model performance on the test set: MAE = %0.4f.' % mae(y_test, final_pred)) Default model performance on the test set: MAE = 10.0130. Final model performance on the test set: MAE = 9.0453. 最终的模型比基线模型的性能提高了大约10％，但代价是显著增加了运行时间。 机器学习通常是一个需要权衡的领域： 偏差与方差 准确性与可解释性 准确性与运行时间 以及使用哪种模型 最终决定取决于具体情况。 这里，运行时间的增加不是障碍，因为虽然相对差异很大，但训练时间的绝对量值并不显着。 在不同的情况下，权衡可能不一样，因此我们需要考虑我们正在优化的内容以及我们必须使用的限制。 为直观地了解预测效果，我们可以绘制下面两个值的分布：测试集上的真实值和最终模型的预测值 123456789figsize(8, 8)# 测试集上的真实值和预测值的密度图sns.kdeplot(final_pred, label = 'Predictions')sns.kdeplot(y_test, label = 'True Values')plt.xlabel('Energy Star Score')plt.ylabel('Density')plt.title('Test Values and Predictions') C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &apos;Test Values and Predictions&apos;) 虽然预测值的密度更接近测试值的中值而不是100的实际峰值，但分布看起来几乎相同。看来模型在预测极值时可能不太准确 而是预测值更接近中位数。 接下来，我们画一下预测值与真实值残差的直方图。 理想情况下，我们希望残差是正态分布的，这意味着模型在两个方向（高和低）上都是预测误差情况是一样的。 1234567891011figsize(6, 6)# 计算残差residuals = final_pred - y_test# 残差的直方图plt.hist(residuals, color = 'red', bins = 20, edgecolor = 'black')plt.xlabel('Error')plt.ylabel('Count')plt.title('Distribution of Residuals') Text(0.5, 1.0, &apos;Distribution of Residuals&apos;) 残差接近正态分布，低端有一些明显的异常值。 这些表明模型估计远低于真实值。 6.1 小结以上我们完成了机器学习的4到6三个步骤： 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 结果表明机器学习适用于我们的问题，最终模型能够将建筑物的能源之星得分预测到9.1分以内（尽管存在过拟合现象）。我们还看到： 超参数调整能够略微改善模型的性能，但同时会消耗大量的时间。这表明，正确的特征工程和收集更多数据（如果可能！）比微调模型有更大的回报。我们还观察了运行时间与精度之间的权衡，这是我们在设计机器学习模型时必须考虑的众多因素之一。 我们知道我们的模型是准确的，但是我们需要知道为什么它能做出正确预测！机器学习过程的下一步至关重要：尝试理解模型如何进行预测，即尽可能地解释模型结果。实现高精度是很好的，但如果我们能够找出模型能够准确预测的原因，那么我们也可以使用这些信息来更好地理解问题。例如，模型依靠什么特征来推断能源之星得分？可以使用此模型进行特征选择，并实现更易于解释的更简单模型吗？ 在接下来的部分，我们将尝试回答这些问题并从项目中得出最终结论！ 7 解释模型本节，我们将查看我们构建的黑盒子模型。我们知道这是准确的，因为它可以预测能源之星得分在真实值的相对误差在9分之内，但它究竟是如何做出预测的呢？ 我们将研究一些尝试理解GBDT回归然后得出结论。 123456# 引入树模型from sklearn import tree# LIME 用于解释预测import lime import lime.lime_tabular 7.1 重新构建最终模型123456# 使用超参数搜索的结果重构模型model = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)model.fit(X, y) GradientBoostingRegressor(alpha=0.9, criterion=&apos;friedman_mse&apos;, init=None, learning_rate=0.1, loss=&apos;lad&apos;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&apos;auto&apos;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 1234# 在测试集上做预测model_pred = model.predict(X_test)print('Final Model Performance on the test set: MAE = %0.4f' % mae(y_test, model_pred)) Final Model Performance on the test set: MAE = 9.0453 7.2 解释模型机器学习经常被批评为一个黑盒子： 我们把数据丢进去，它给了我们预测答案。 虽然这些答案通常非常准确，但该模型并未告诉我们它是如何实际做出预测的。 这在某种程度上是正确的，但我们可以通过多种方式尝试并发现模型如何“思考”，例如局部可理解的与模型无关的解释器(Locally Interpretable Model-agnostic Explainer, LIME)。 这种方法试图通过学习围绕预测的线性回归来解释模型预测，这是一个易于解释的模型！ 我们将探索几种解释模型的方法： 特征重要性 局部可理解的与模型无关的解释器（LIME） 检查整体中的单个决策树 7.2 特征重要性我们可以解释决策树集成的基本方法之一是通过特征重要性。 这些可以解释为最能预测目标的特征。 虽然特征重要性的实际细节非常复杂(这里是相关讨论)，我们可以使用相对值来比较特征并确定哪些与我们的问题最相关。 在scikit-learn中，从经过训练的树集成中提取特征重要性非常容易。 我们将特征重要性存储在数据帧中以分析和可视化它们。 12345678# 提取特征重要性，保存到数据帧中feature_results = pd.DataFrame(&#123;'feature': list(train_features.columns), 'importance': model.feature_importances_&#125;)# 显示最重要的10个特征feature_results = feature_results.sort_values('importance', ascending = False).reset_index(drop=True)feature_results.head(10) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } feature importance 0 Site EUI (kBtu/ft²) 0.443737 1 Weather Normalized Site Electricity Intensity … 0.249489 2 Water Intensity (All Water Sources) (gal/ft²) 0.054552 3 log_Water Intensity (All Water Sources) (gal/ft²) 0.032452 4 Property Id 0.027158 5 DOF Gross Floor Area 0.025096 6 Largest Property Use Type_Multifamily Housing 0.021317 7 Year Built 0.020704 8 log_Direct GHG Emissions (Metric Tons CO2e) 0.019706 9 Largest Property Use Type_Non-Refrigerated War… 0.019264 Site EUI (kBtu/ft²) 和Weather Normalized Site Electricity Intensity (kWh/ft²)是两个相对最重要的两个特征。之后，相对重要性大幅下降，这表明我们可能不需要保留所有特征来创建具有几乎相同性能的模型。 让我们可视化特征重要性。 12345678figsize(12, 10)# 将最重要的10个特征画成直方图feature_results.loc[:9, :].plot(x = 'feature', y = 'importance', edgecolor = 'k', kind = 'barh', color = 'blue')plt.xlabel('Relative Importance', size = 20)plt.ylabel('')plt.title('Feature Importance from Random Forest', size = 30) Text(0.5, 1.0, &apos;Feature Importance from Random Forest&apos;) 利用特征重要性进行特征选择: 鉴于并非每个特征对于影响分数都很重要，如果我们将随机森林中最重要特征的子集用于更简单的模型（如线性回归），会发生什么？ 线性回归确实优于基线，但与模型复杂模型相比表现不佳。 让我们尝试仅在线性回归中的使用10个最重要的特征来查看性能是否得到改善。 我们还可以限制这些功能并重新评估随机森林。 123456789101112# 提取重要的10个特征名称most_important_features = feature_results['feature'][:10]# 寻找对应特征的indexindices = [list(train_features.columns).index(x) for x in most_important_features]# 仅保留最重要的10个特征X_reduced = X[:, indices]X_test_reduced = X_test[:, indices]print('Most important training features shape: ', X_reduced.shape)print('Most important testing features shape: ', X_test_reduced.shape) Most important training features shape: (6622, 10) Most important testing features shape: (2839, 10) 12345678910111213lr = LinearRegression()# 拟合所有特征lr.fit(X, y)lr_full_pred = lr.predict(X_test)# 仅拟合最重要的10个特征lr.fit(X_reduced, y)lr_reduced_pred = lr.predict(X_test_reduced)# 结果对比print('Linear Regression Full Results: MAE = %0.4f.' % mae(y_test, lr_full_pred))print('Linear Regression Reduced Results: MAE = %0.4f.' % mae(y_test, lr_reduced_pred)) Linear Regression Full Results: MAE = 13.4651. Linear Regression Reduced Results: MAE = 14.4016. 可以看到，减少特征并没有改善线性回归结果！ 事实证明，低重要性特征中的额外信息确实可以提高性能。 让我们再看看在梯度提升回归中使用减少的特征集。 性能如何受到影响？ 12345678910# 使用一样的超参数建立梯度提升模型model_reduced = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)# 拟合并预测model_reduced.fit(X_reduced, y)model_reduced_pred = model_reduced.predict(X_test_reduced)print('Gradient Boosted Reduced Results: MAE = %0.4f' % mae(y_test, model_reduced_pred)) Gradient Boosted Reduced Results: MAE = 9.5251 随着特征的减少，模型结果略差，我们将为最终模型保留所有特征。 减少特征数量是因为我们总是希望构建最简约的模型： 即具有足够性能的最简单模型。 使用较少特征的模型将更快地训练并且通常更容易解释。 在这种情况下，保留所有特征并不是主要问题，因为训练时间在本项目中并不重要，我们仍然可以使用许多特征进行解释。 7.3 局部可理解的与模型无关的解释器（LIME）我们将使用LIME来解释模型所做的个别预测。 LIME是一项相对较新的工作，旨在通过用线性模型近似一个预测周围的区域来展示机器学习模型的思考方式。 我们将试图解释模型在两个例子上得到的预测结果：其中一个例子得到的预测结果非常差，另一个例子得到的预测结果非常好。 我们将限制使用的10个最重要的特征来帮助解释。 虽然在10个最重要的特征上训练的模型稍微不准确，但我们通常必须权衡可解释性的准确性！ 123456# 计算残差residuals = abs(model_reduced_pred - y_test)# 提取最差和最好的预测wrong = X_test_reduced[np.argmax(residuals), :]right = X_test_reduced[np.argmin(residuals), :] 12345# 创建lime解释器explainer = lime.lime_tabular.LimeTabularExplainer(training_data = X_reduced, mode = 'regression', training_labels = y, feature_names = list(most_important_features)) 1234567891011# 为错误示例显示预测值和真实值print('Prediction: %0.4f' % model_reduced.predict(wrong.reshape(1, -1)))print('Actual Value: %0.4f' % y_test[np.argmax(residuals)])# 解释错误预测wrong_exp = explainer.explain_instance(data_row = wrong, predict_fn = model_reduced.predict)# 绘制预测解释wrong_exp.as_pyplot_figure()plt.title('Explanation of Prediction', size = 28);plt.xlabel('Effect on Prediction', size = 22); Prediction: 14.1601 Actual Value: 96.0000 C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\linear_model\ridge.py:125: LinAlgWarning: scipy.linalg.solve Ill-conditioned matrix detected. Result is not guaranteed to be accurate. Reciprocal condition number3.113013e-27 overwrite_a=True).T 1wrong_exp.show_in_notebook(show_predicted_value=False) var lime =/**/ (function(modules) { // webpackBootstrap/**/ // The module cache/**/ var installedModules = {};/**//**/ // The require function/**/ function webpack_require(moduleId) {/**//**/ // Check if module is in cache/**/ if(installedModules[moduleId])/**/ return installedModules[moduleId].exports;/**//**/ // Create a new module (and put it into the cache)/**/ var module = installedModules[moduleId] = {/**/ exports: {},/**/ id: moduleId,/**/ loaded: false/**/ };/**//**/ // Execute the module function/**/ modules[moduleId].call(module.exports, module, module.exports, webpack_require);/**//**/ // Flag the module as loaded/**/ module.loaded = true;/**//**/ // Return the exports of the module/**/ return module.exports;/**/ }/**//**//**/ // expose the modules object (webpack_modules)/**/ webpack_require.m = modules;/**//**/ // expose the module cache/**/ webpack_require.c = installedModules;/**//**/ // webpack_public_path/**/ webpack_require.p = “”;/**//**/ // Load entry module and return exports/**/ return webpack_require(0);/**/ })/**//**/ ([/ 0 /// (function(module, exports, webpack_require) { / WEBPACK VAR INJECTION /(function(global) {‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); exports.PredictedValue = exports.PredictProba = exports.Barchart = exports.Explanation = undefined; var _explanation = webpack_require__(1); var _explanation2 = _interopRequireDefault(_explanation); var _bar_chart = webpack_require(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _predict_proba = webpack_require(6); var _predict_proba2 = _interopRequireDefault(_predict_proba); var _predicted_value = webpack_require(7); var _predicted_value2 = _interopRequireDefault(_predicted_value); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } if (!global._babelPolyfill) { webpack_require__(8); } webpack_require(339); exports.Explanation = _explanation2.default; exports.Barchart = _bar_chart2.default; exports.PredictProba = _predict_proba2.default; exports.PredictedValue = _predicted_value2.default; //require(‘style-loader’); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))// }),/ 1 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arrSymbol.iterator, _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[“return”]) _i“return”; } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(“Invalid attempt to destructure non-iterable instance”); } }; }(); var _d2 = webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _bar_chart = webpack_require(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var Explanation = function () { function Explanation(class_names) { _classCallCheck(this, Explanation); this.names = class_names; if (class_names.length &lt; 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } } // exp: [(feature-name, weight), …] // label: int // div: d3 selection Explanation.prototype.show = function show(exp, label, div) { var svg = div.append(‘svg’).style(‘width’, ‘100%’); var colors = [‘#5F9EA0’, this.colors_i(label)]; var names = [‘NOT ‘ + this.names[label], this.names[label]]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; names = this.names; } var plot = new _bar_chart2.default(svg, exp, true, names, colors, true, 10); svg.style(‘height’, plot.svg_height + ‘px’); }; // exp has all ocurrences of words, with start index and weight: // exp = [(‘word’, 132, -0.13), (‘word3’, 111, 1.3) Explanation.prototype.show_raw_text = function show_raw_text(exp, label, raw, div) { var opacity = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true; //let colors=[‘#5F9EA0’, this.colors(this.exp[‘class’])]; var colors = [‘#5F9EA0’, this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var word_lists = [[], []]; var max_weight = -1; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = expSymbol.iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var _step$value = _slicedToArray(_step.value, 3), word = _step$value[0], start = _step$value[1], weight = _step$value[2]; if (weight &gt; 0) { word_lists[1].push([start, start + word.length, weight]); } else { word_lists[0].push([start, start + word.length, -weight]); } max_weight = Math.max(max_weight, Math.abs(weight)); } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } if (!opacity) { max_weight = 0; } this.display_raw_text(div, raw, word_lists, colors, max_weight, true); }; // exp is list of (feature_name, value, weight) Explanation.prototype.show_raw_tabular = function show_raw_tabular(exp, label, div) { div.classed(‘lime’, true).classed(‘table_div’, true); var colors = [‘#5F9EA0’, this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var table = div.append(‘table’); var thead = table.append(‘tr’); thead.append(‘td’).text(‘Feature’); thead.append(‘td’).text(‘Value’); thead.style(‘color’, ‘black’).style(‘font-size’, ‘20px’); var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = expSymbol.iterator, _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var _step2$value = _slicedToArray(_step2.value, 3), fname = _step2$value[0], value = _step2$value[1], weight = _step2$value[2]; var tr = table.append(‘tr’); tr.style(‘border-style’, ‘hidden’); tr.append(‘td’).text(fname); tr.append(‘td’).text(value); if (weight &gt; 0) { tr.style(‘background-color’, colors[1]); } else if (weight &lt; 0) { tr.style(‘background-color’, colors[0]); } else { tr.style(‘color’, ‘black’); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } }; Explanation.prototype.hexToRgb = function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }; Explanation.prototype.applyAlpha = function applyAlpha(hex, alpha) { var components = this.hexToRgb(hex); return ‘rgba(‘ + components.r + “,” + components.g + “,” + components.b + “,” + alpha.toFixed(3) + “)”; }; // sord_lists is an array of arrays, of length (colors). if with_positions is true, // word_lists is an array of [start,end] positions instead Explanation.prototype.display_raw_text = function display_raw_text(div, raw_text) { var word_lists = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : []; var colors = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : []; var max_weight = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : 1; var positions = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; div.classed(‘lime’, true).classed(‘text_div’, true); div.append(‘h3’).text(‘Text with highlighted words’); var highlight_tag = ‘span’; var text_span = div.append(‘span’).style(‘white-space’, ‘pre-wrap’).text(raw_text); var position_lists = word_lists; if (!positions) { position_lists = this.wordlists_to_positions(word_lists, raw_text); } var objects = []; var _iteratorNormalCompletion3 = true; var _didIteratorError3 = false; var _iteratorError3 = undefined; try { var _loop = function _loop() { var i = _step3.value; position_lists[i].map(function (x) { return objects.push({ ‘label’: i, ‘start’: x[0], ‘end’: x[1], ‘alpha’: max_weight === 0 ? 1 : x[2] / max_weight }); }); }; for (var _iterator3 = (0, _lodash.range)(position_lists.length)Symbol.iterator, _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) { _loop(); } } catch (err) { _didIteratorError3 = true; _iteratorError3 = err; } finally { try { if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) { _iterator3.return(); } } finally { if (_didIteratorError3) { throw _iteratorError3; } } } objects = (0, _lodash.sortBy)(objects, function (x) { return x[‘start’]; }); var node = text_span.node().childNodes[0]; var subtract = 0; var _iteratorNormalCompletion4 = true; var _didIteratorError4 = false; var _iteratorError4 = undefined; try { for (var _iterator4 = objectsSymbol.iterator, _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) { var obj = _step4.value; var word = raw_text.slice(obj.start, obj.end); var start = obj.start - subtract; var end = obj.end - subtract; var match = document.createElement(highlight_tag); match.appendChild(document.createTextNode(word)); match.style.backgroundColor = this.applyAlpha(colors[obj.label], obj.alpha); var after = node.splitText(start); after.nodeValue = after.nodeValue.substring(word.length); node.parentNode.insertBefore(match, after); subtract += end; node = after; } } catch (err) { _didIteratorError4 = true; _iteratorError4 = err; } finally { try { if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) { _iterator4.return(); } } finally { if (_didIteratorError4) { throw _iteratorError4; } } } }; Explanation.prototype.wordlists_to_positions = function wordlists_to_positions(word_lists, raw_text) { var ret = []; var _iteratorNormalCompletion5 = true; var _didIteratorError5 = false; var _iteratorError5 = undefined; try { for (var _iterator5 = word_listsSymbol.iterator, _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) { var words = _step5.value; if (words.length === 0) { ret.push([]); continue; } var re = new RegExp(“\b(“ + words.join(‘|’) + “)\b”, ‘gm’); var temp = void 0; var list = []; while ((temp = re.exec(raw_text)) !== null) { list.push([temp.index, temp.index + temp[0].length]); } ret.push(list); } } catch (err) { _didIteratorError5 = true; _iteratorError5 = err; } finally { try { if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) { _iterator5.return(); } } finally { if (_didIteratorError5) { throw _iteratorError5; } } } return ret; }; return Explanation; }(); exports.default = Explanation;// }),/ 2 /// (function(module, exports, webpack_require) { var WEBPACK_AMD_DEFINE_FACTORY, WEBPACK_AMD_DEFINE_RESULT;!function() { var d3 = { version: “3.5.17” }; var d3_arraySlice = [].slice, d3_array = function(list) { return d3_arraySlice.call(list); }; var d3_document = this.document; function d3_documentElement(node) { return node &amp;&amp; (node.ownerDocument || node.document || node).documentElement; } function d3_window(node) { return node &amp;&amp; (node.ownerDocument &amp;&amp; node.ownerDocument.defaultView || node.document &amp;&amp; node || node.defaultView); } if (d3_document) { try { d3_array(d3_document.documentElement.childNodes)[0].nodeType; } catch (e) { d3_array = function(list) { var i = list.length, array = new Array(i); while (i–) array[i] = list[i]; return array; }; } } if (!Date.now) Date.now = function() { return +new Date(); }; if (d3_document) { try { d3_document.createElement(“DIV”).style.setProperty(“opacity”, 0, “”); } catch (error) { var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty; d3_element_prototype.setAttribute = function(name, value) { d3_element_setAttribute.call(this, name, value + “”); }; d3_element_prototype.setAttributeNS = function(space, local, value) { d3_element_setAttributeNS.call(this, space, local, value + “”); }; d3_style_prototype.setProperty = function(name, value, priority) { d3_style_setProperty.call(this, name, value + “”, priority); }; } } d3.ascending = d3_ascending; function d3_ascending(a, b) { return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN; } d3.descending = function(a, b) { return b &lt; a ? -1 : b &gt; a ? 1 : b &gt;= a ? 0 : NaN; }; d3.min = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; a &gt; b) a = b; } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; a &gt; b) a = b; } return a; }; d3.max = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt; a) a = b; } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt; a) a = b; } return a; }; d3.extent = function(array, f) { var i = -1, n = array.length, a, b, c; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = c = b; break; } while (++i &lt; n) if ((b = array[i]) != null) { if (a &gt; b) a = b; if (c &lt; b) c = b; } } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = c = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null) { if (a &gt; b) a = b; if (c &lt; b) c = b; } } return [ a, c ]; }; function d3_number(x) { return x === null ? NaN : +x; } function d3_numeric(x) { return !isNaN(x); } d3.sum = function(array, f) { var s = 0, n = array.length, a, i = -1; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = +array[i])) s += a; } else { while (++i &lt; n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a; } return s; }; d3.mean = function(array, f) { var s = 0, n = array.length, a, i = -1, j = n; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = d3_number(array[i]))) s += a; else –j; } else { while (++i &lt; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else –j; } if (j) return s / j; }; d3.quantile = function(values, p) { var H = (values.length - 1) p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h; return e ? v + e (values[h] - v) : v; }; d3.median = function(array, f) { var numbers = [], n = array.length, a, i = -1; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a); } else { while (++i &lt; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a); } if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5); }; d3.variance = function(array, f) { var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0; if (arguments.length === 1) { while (++i &lt; n) { if (d3_numeric(a = d3_number(array[i]))) { d = a - m; m += d / ++j; s += d (a - m); } } } else { while (++i &lt; n) { if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) { d = a - m; m += d / ++j; s += d (a - m); } } } if (j &gt; 1) return s / (j - 1); }; d3.deviation = function() { var v = d3.variance.apply(this, arguments); return v ? Math.sqrt(v) : v; }; function d3_bisector(compare) { return { left: function(a, x, lo, hi) { if (arguments.length &lt; 3) lo = 0; if (arguments.length &lt; 4) hi = a.length; while (lo &lt; hi) { var mid = lo + hi &gt;&gt;&gt; 1; if (compare(a[mid], x) &lt; 0) lo = mid + 1; else hi = mid; } return lo; }, right: function(a, x, lo, hi) { if (arguments.length &lt; 3) lo = 0; if (arguments.length &lt; 4) hi = a.length; while (lo &lt; hi) { var mid = lo + hi &gt;&gt;&gt; 1; if (compare(a[mid], x) &gt; 0) hi = mid; else lo = mid + 1; } return lo; } }; } var d3_bisect = d3_bisector(d3_ascending); d3.bisectLeft = d3_bisect.left; d3.bisect = d3.bisectRight = d3_bisect.right; d3.bisector = function(f) { return d3_bisector(f.length === 1 ? function(d, x) { return d3_ascending(f(d), x); } : f); }; d3.shuffle = function(array, i0, i1) { if ((m = arguments.length) &lt; 3) { i1 = array.length; if (m &lt; 2) i0 = 0; } var m = i1 - i0, t, i; while (m) { i = Math.random() m– | 0; t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t; } return array; }; d3.permute = function(array, indexes) { var i = indexes.length, permutes = new Array(i); while (i–) permutes[i] = array[indexes[i]]; return permutes; }; d3.pairs = function(array) { var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n &lt; 0 ? 0 : n); while (i &lt; n) pairs[i] = [ p0 = p1, p1 = array[++i] ]; return pairs; }; d3.transpose = function(matrix) { if (!(n = matrix.length)) return []; for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i &lt; m; ) { for (var j = -1, n, row = transpose[i] = new Array(n); ++j &lt; n; ) { row[j] = matrix[j][i]; } } return transpose; }; function d3_transposeLength(d) { return d.length; } d3.zip = function() { return d3.transpose(arguments); }; d3.keys = function(map) { var keys = []; for (var key in map) keys.push(key); return keys; }; d3.values = function(map) { var values = []; for (var key in map) values.push(map[key]); return values; }; d3.entries = function(map) { var entries = []; for (var key in map) entries.push({ key: key, value: map[key] }); return entries; }; d3.merge = function(arrays) { var n = arrays.length, m, i = -1, j = 0, merged, array; while (++i &lt; n) j += arrays[i].length; merged = new Array(j); while (–n &gt;= 0) { array = arrays[n]; m = array.length; while (–m &gt;= 0) { merged[–j] = array[m]; } } return merged; }; var abs = Math.abs; d3.range = function(start, stop, step) { if (arguments.length &lt; 3) { step = 1; if (arguments.length &lt; 2) { stop = start; start = 0; } } if ((stop - start) / step === Infinity) throw new Error(“infinite range”); var range = [], k = d3_range_integerScale(abs(step)), i = -1, j; start = k, stop = k, step = k; if (step &lt; 0) while ((j = start + step ++i) &gt; stop) range.push(j / k); else while ((j = start + step ++i) &lt; stop) range.push(j / k); return range; }; function d3_range_integerScale(x) { var k = 1; while (x k % 1) k = 10; return k; } function d3_class(ctor, properties) { for (var key in properties) { Object.defineProperty(ctor.prototype, key, { value: properties[key], enumerable: false }); } } d3.map = function(object, f) { var map = new d3_Map(); if (object instanceof d3_Map) { object.forEach(function(key, value) { map.set(key, value); }); } else if (Array.isArray(object)) { var i = -1, n = object.length, o; if (arguments.length === 1) while (++i &lt; n) map.set(i, object[i]); else while (++i &lt; n) map.set(f.call(object, o = object[i], i), o); } else { for (var key in object) map.set(key, object[key]); } return map; }; function d3_Map() { this._ = Object.create(null); } var d3_map_proto = “proto“, d3_map_zero = “\x00”; d3_class(d3_Map, { has: d3_map_has, get: function(key) { return this._[d3_map_escape(key)]; }, set: function(key, value) { return this._[d3_map_escape(key)] = value; }, remove: d3_map_remove, keys: d3_map_keys, values: function() { var values = []; for (var key in this.) values.push(this.[key]); return values; }, entries: function() { var entries = []; for (var key in this._) entries.push({ key: d3_map_unescape(key), value: this._[key] }); return entries; }, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]); } }); function d3_map_escape(key) { return (key += “”) === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key; } function d3_map_unescape(key) { return (key += “”)[0] === d3_map_zero ? key.slice(1) : key; } function d3_map_has(key) { return d3_map_escape(key) in this._; } function d3_map_remove(key) { return (key = d3_map_escape(key)) in this._ &amp;&amp; delete this._[key]; } function d3_map_keys() { var keys = []; for (var key in this._) keys.push(d3_map_unescape(key)); return keys; } function d3_map_size() { var size = 0; for (var key in this._) ++size; return size; } function d3_map_empty() { for (var key in this._) return false; return true; } d3.nest = function() { var nest = {}, keys = [], sortKeys = [], sortValues, rollup; function map(mapType, array, depth) { if (depth &gt;= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array; var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values; while (++i &lt; n) { if (values = valuesByKey.get(keyValue = key(object = array[i]))) { values.push(object); } else { valuesByKey.set(keyValue, [ object ]); } } if (mapType) { object = mapType(); setter = function(keyValue, values) { object.set(keyValue, map(mapType, values, depth)); }; } else { object = {}; setter = function(keyValue, values) { object[keyValue] = map(mapType, values, depth); }; } valuesByKey.forEach(setter); return object; } function entries(map, depth) { if (depth &gt;= keys.length) return map; var array = [], sortKey = sortKeys[depth++]; map.forEach(function(key, keyMap) { array.push({ key: key, values: entries(keyMap, depth) }); }); return sortKey ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array; } nest.map = function(array, mapType) { return map(mapType, array, 0); }; nest.entries = function(array) { return entries(map(d3.map, array, 0), 0); }; nest.key = function(d) { keys.push(d); return nest; }; nest.sortKeys = function(order) { sortKeys[keys.length - 1] = order; return nest; }; nest.sortValues = function(order) { sortValues = order; return nest; }; nest.rollup = function(f) { rollup = f; return nest; }; return nest; }; d3.set = function(array) { var set = new d3_Set(); if (array) for (var i = 0, n = array.length; i &lt; n; ++i) set.add(array[i]); return set; }; function d3_Set() { this._ = Object.create(null); } d3_class(d3_Set, { has: d3_map_has, add: function(key) { this._[d3_map_escape(key += “”)] = true; return key; }, remove: d3_map_remove, values: d3_map_keys, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key)); } }); d3.behavior = {}; function d3_identity(d) { return d; } d3.rebind = function(target, source) { var i = 1, n = arguments.length, method; while (++i &lt; n) target[method = arguments[i]] = d3_rebind(target, source, source[method]); return target; }; function d3_rebind(target, source, method) { return function() { var value = method.apply(source, arguments); return value === source ? target : value; }; } function d3_vendorSymbol(object, name) { if (name in object) return name; name = name.charAt(0).toUpperCase() + name.slice(1); for (var i = 0, n = d3_vendorPrefixes.length; i &lt; n; ++i) { var prefixName = d3_vendorPrefixes[i] + name; if (prefixName in object) return prefixName; } } var d3_vendorPrefixes = [ “webkit”, “ms”, “moz”, “Moz”, “o”, “O” ]; function d3_noop() {} d3.dispatch = function() { var dispatch = new d3_dispatch(), i = -1, n = arguments.length; while (++i &lt; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); return dispatch; }; function d3_dispatch() {} d3_dispatch.prototype.on = function(type, listener) { var i = type.indexOf(“.”), name = “”; if (i &gt;= 0) { name = type.slice(i + 1); type = type.slice(0, i); } if (type) return arguments.length &lt; 2 ? this[type].on(name) : this[type].on(name, listener); if (arguments.length === 2) { if (listener == null) for (type in this) { if (this.hasOwnProperty(type)) this[type].on(name, null); } return this; } }; function d3_dispatch_event(dispatch) { var listeners = [], listenerByName = new d3_Map(); function event() { var z = listeners, i = -1, n = z.length, l; while (++i &lt; n) if (l = z[i].on) l.apply(this, arguments); return dispatch; } event.on = function(name, listener) { var l = listenerByName.get(name), i; if (arguments.length &lt; 2) return l &amp;&amp; l.on; if (l) { l.on = null; listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)); listenerByName.remove(name); } if (listener) listeners.push(listenerByName.set(name, { on: listener })); return dispatch; }; return event; } d3.event = null; function d3_eventPreventDefault() { d3.event.preventDefault(); } function d3_eventSource() { var e = d3.event, s; while (s = e.sourceEvent) e = s; return e; } function d3_eventDispatch(target) { var dispatch = new d3_dispatch(), i = 0, n = arguments.length; while (++i &lt; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); dispatch.of = function(thiz, argumentz) { return function(e1) { try { var e0 = e1.sourceEvent = d3.event; e1.target = target; d3.event = e1; dispatch[e1.type].apply(thiz, argumentz); } finally { d3.event = e0; } }; }; return dispatch; } d3.requote = function(s) { return s.replace(d3_requote_re, “\$&amp;”); }; var d3_requote_re = /[\\^\$\+\?|[]().{}]/g; var d3_subclass = {}.proto ? function(object, prototype) { object.proto = prototype; } : function(object, prototype) { for (var property in prototype) object[property] = prototype[property]; }; function d3_selection(groups) { d3_subclass(groups, d3_selectionPrototype); return groups; } var d3_select = function(s, n) { return n.querySelector(s); }, d3_selectAll = function(s, n) { return n.querySelectorAll(s); }, d3_selectMatches = function(n, s) { var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, “matchesSelector”)]; d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); }; return d3_selectMatches(n, s); }; if (typeof Sizzle === “function”) { d3_select = function(s, n) { return Sizzle(s, n)[0] || null; }; d3_selectAll = Sizzle; d3_selectMatches = Sizzle.matchesSelector; } d3.selection = function() { return d3.select(d3_document.documentElement); }; var d3_selectionPrototype = d3.selection.prototype = []; d3_selectionPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, group, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroup.push(subnode = selector.call(node, node.data, i, j)); if (subnode &amp;&amp; “data“ in node) subnode.data = node.data; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; function d3_selection_selector(selector) { return typeof selector === “function” ? selector : function() { return d3_select(selector, this); }; } d3_selectionPrototype.selectAll = function(selector) { var subgroups = [], subgroup, node; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroups.push(subgroup = d3_array(selector.call(node, node.data, i, j))); subgroup.parentNode = node; } } } return d3_selection(subgroups); }; function d3_selection_selectorAll(selector) { return typeof selector === “function” ? selector : function() { return d3_selectAll(selector, this); }; } var d3_nsXhtml = “http://www.w3.org/1999/xhtml&quot;; var d3_nsPrefix = { svg: “http://www.w3.org/2000/svg&quot;, xhtml: d3_nsXhtml, xlink: “http://www.w3.org/1999/xlink&quot;, xml: “http://www.w3.org/XML/1998/namespace&quot;, xmlns: “http://www.w3.org/2000/xmlns/&quot; }; d3.ns = { prefix: d3_nsPrefix, qualify: function(name) { var i = name.indexOf(“:”), prefix = name; if (i &gt;= 0 &amp;&amp; (prefix = name.slice(0, i)) !== “xmlns”) name = name.slice(i + 1); return d3_nsPrefix.hasOwnProperty(prefix) ? { space: d3_nsPrefix[prefix], local: name } : name; } }; d3_selectionPrototype.attr = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) { var node = this.node(); name = d3.ns.qualify(name); return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name); } for (value in name) this.each(d3_selection_attr(value, name[value])); return this; } return this.each(d3_selection_attr(name, value)); }; function d3_selection_attr(name, value) { name = d3.ns.qualify(name); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrConstant() { this.setAttribute(name, value); } function attrConstantNS() { this.setAttributeNS(name.space, name.local, value); } function attrFunction() { var x = value.apply(this, arguments); if (x == null) this.removeAttribute(name); else this.setAttribute(name, x); } function attrFunctionNS() { var x = value.apply(this, arguments); if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x); } return value == null ? name.local ? attrNullNS : attrNull : typeof value === “function” ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant; } function d3_collapse(s) { return s.trim().replace(/\s+/g, “ “); } d3_selectionPrototype.classed = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) { var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1; if (value = node.classList) { while (++i &lt; n) if (!value.contains(name[i])) return false; } else { value = node.getAttribute(“class”); while (++i &lt; n) if (!d3_selection_classedRe(name[i]).test(value)) return false; } return true; } for (value in name) this.each(d3_selection_classed(value, name[value])); return this; } return this.each(d3_selection_classed(name, value)); }; function d3_selection_classedRe(name) { return new RegExp(“(?:^|\s+)” + d3.requote(name) + “(?:\s+|$)”, “g”); } function d3_selection_classes(name) { return (name + “”).trim().split(/^|\s+/); } function d3_selection_classed(name, value) { name = d3_selection_classes(name).map(d3_selection_classedName); var n = name.length; function classedConstant() { var i = -1; while (++i &lt; n) namei; } function classedFunction() { var i = -1, x = value.apply(this, arguments); while (++i &lt; n) namei; } return typeof value === “function” ? classedFunction : classedConstant; } function d3_selection_classedName(name) { var re = d3_selection_classedRe(name); return function(node, value) { if (c = node.classList) return value ? c.add(name) : c.remove(name); var c = node.getAttribute(“class”) || “”; if (value) { re.lastIndex = 0; if (!re.test(c)) node.setAttribute(“class”, d3_collapse(c + “ “ + name)); } else { node.setAttribute(“class”, d3_collapse(c.replace(re, “ “))); } }; } d3_selectionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n &lt; 3) { if (typeof name !== “string”) { if (n &lt; 2) value = “”; for (priority in name) this.each(d3_selection_style(priority, name[priority], value)); return this; } if (n &lt; 2) { var node = this.node(); return d3_window(node).getComputedStyle(node, null).getPropertyValue(name); } priority = “”; } return this.each(d3_selection_style(name, value, priority)); }; function d3_selection_style(name, value, priority) { function styleNull() { this.style.removeProperty(name); } function styleConstant() { this.style.setProperty(name, value, priority); } function styleFunction() { var x = value.apply(this, arguments); if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority); } return value == null ? styleNull : typeof value === “function” ? styleFunction : styleConstant; } d3_selectionPrototype.property = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) return this.node()[name]; for (value in name) this.each(d3_selection_property(value, name[value])); return this; } return this.each(d3_selection_property(name, value)); }; function d3_selection_property(name, value) { function propertyNull() { delete this[name]; } function propertyConstant() { this[name] = value; } function propertyFunction() { var x = value.apply(this, arguments); if (x == null) delete this[name]; else this[name] = x; } return value == null ? propertyNull : typeof value === “function” ? propertyFunction : propertyConstant; } d3_selectionPrototype.text = function(value) { return arguments.length ? this.each(typeof value === “function” ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? “” : v; } : value == null ? function() { this.textContent = “”; } : function() { this.textContent = value; }) : this.node().textContent; }; d3_selectionPrototype.html = function(value) { return arguments.length ? this.each(typeof value === “function” ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? “” : v; } : value == null ? function() { this.innerHTML = “”; } : function() { this.innerHTML = value; }) : this.node().innerHTML; }; d3_selectionPrototype.append = function(name) { name = d3_selection_creator(name); return this.select(function() { return this.appendChild(name.apply(this, arguments)); }); }; function d3_selection_creator(name) { function create() { var document = this.ownerDocument, namespace = this.namespaceURI; return namespace === d3_nsXhtml &amp;&amp; document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name); } function createNS() { return this.ownerDocument.createElementNS(name.space, name.local); } return typeof name === “function” ? name : (name = d3.ns.qualify(name)).local ? createNS : create; } d3_selectionPrototype.insert = function(name, before) { name = d3_selection_creator(name); before = d3_selection_selector(before); return this.select(function() { return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null); }); }; d3_selectionPrototype.remove = function() { return this.each(d3_selectionRemove); }; function d3_selectionRemove() { var parent = this.parentNode; if (parent) parent.removeChild(this); } d3_selectionPrototype.data = function(value, key) { var i = -1, n = this.length, group, node; if (!arguments.length) { value = new Array(n = (group = this[0]).length); while (++i &lt; n) { if (node = group[i]) { value[i] = node.data; } } return value; } function bind(group, groupData) { var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData; if (key) { var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue; for (i = -1; ++i &lt; n; ) { if (node = group[i]) { if (nodeByKeyValue.has(keyValue = key.call(node, node.data, i))) { exitNodes[i] = node; } else { nodeByKeyValue.set(keyValue, node); } keyValues[i] = keyValue; } } for (i = -1; ++i &lt; m; ) { if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) { enterNodes[i] = d3_selection_dataNode(nodeData); } else if (node !== true) { updateNodes[i] = node; node.data = nodeData; } nodeByKeyValue.set(keyValue, true); } for (i = -1; ++i &lt; n; ) { if (i in keyValues &amp;&amp; nodeByKeyValue.get(keyValues[i]) !== true) { exitNodes[i] = group[i]; } } } else { for (i = -1; ++i &lt; n0; ) { node = group[i]; nodeData = groupData[i]; if (node) { node.data = nodeData; updateNodes[i] = node; } else { enterNodes[i] = d3_selection_dataNode(nodeData); } } for (;i &lt; m; ++i) { enterNodes[i] = d3_selection_dataNode(groupData[i]); } for (;i &lt; n; ++i) { exitNodes[i] = group[i]; } } enterNodes.update = updateNodes; enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode; enter.push(enterNodes); update.push(updateNodes); exit.push(exitNodes); } var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]); if (typeof value === “function”) { while (++i &lt; n) { bind(group = this[i], value.call(group, group.parentNode.data, i)); } } else { while (++i &lt; n) { bind(group = this[i], value); } } update.enter = function() { return enter; }; update.exit = function() { return exit; }; return update; }; function d3_selection_dataNode(data) { return { data: data }; } d3_selectionPrototype.datum = function(value) { return arguments.length ? this.property(“data“, value) : this.property(“data“); }; d3_selectionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== “function”) filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = 0, n = group.length; i &lt; n; i++) { if ((node = group[i]) &amp;&amp; filter.call(node, node.data, i, j)) { subgroup.push(node); } } } return d3_selection(subgroups); }; function d3_selection_filter(selector) { return function() { return d3_selectMatches(this, selector); }; } d3_selectionPrototype.order = function() { for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = group.length - 1, next = group[i], node; –i &gt;= 0; ) { if (node = group[i]) { if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next); next = node; } } } return this; }; d3_selectionPrototype.sort = function(comparator) { comparator = d3_selection_sortComparator.apply(this, arguments); for (var j = -1, m = this.length; ++j &lt; m; ) this[j].sort(comparator); return this.order(); }; function d3_selection_sortComparator(comparator) { if (!arguments.length) comparator = d3_ascending; return function(a, b) { return a &amp;&amp; b ? comparator(a.data, b.data) : !a - !b; }; } d3_selectionPrototype.each = function(callback) { return d3_selection_each(this, function(node, i, j) { callback.call(node, node.data, i, j); }); }; function d3_selection_each(groups, callback) { for (var j = 0, m = groups.length; j &lt; m; j++) { for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; i++) { if (node = group[i]) callback(node, i, j); } } return groups; } d3_selectionPrototype.call = function(callback) { var args = d3_array(arguments); callback.apply(args[0] = this, args); return this; }; d3_selectionPrototype.empty = function() { return !this.node(); }; d3_selectionPrototype.node = function() { for (var j = 0, m = this.length; j &lt; m; j++) { for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { var node = group[i]; if (node) return node; } } return null; }; d3_selectionPrototype.size = function() { var n = 0; d3_selection_each(this, function() { ++n; }); return n; }; function d3_selection_enter(selection) { d3_subclass(selection, d3_selection_enterPrototype); return selection; } var d3_selection_enterPrototype = []; d3.selection.enter = d3_selection_enter; d3.selection.enter.prototype = d3_selection_enterPrototype; d3_selection_enterPrototype.append = d3_selectionPrototype.append; d3_selection_enterPrototype.empty = d3_selectionPrototype.empty; d3_selection_enterPrototype.node = d3_selectionPrototype.node; d3_selection_enterPrototype.call = d3_selectionPrototype.call; d3_selection_enterPrototype.size = d3_selectionPrototype.size; d3_selection_enterPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, upgroup, group, node; for (var j = -1, m = this.length; ++j &lt; m; ) { upgroup = (group = this[j]).update; subgroups.push(subgroup = []); subgroup.parentNode = group.parentNode; for (var i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.data, i, j)); subnode.data = node.data; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; d3_selection_enterPrototype.insert = function(name, before) { if (arguments.length &lt; 2) before = d3_selection_enterInsertBefore(this); return d3_selectionPrototype.insert.call(this, name, before); }; function d3_selection_enterInsertBefore(enter) { var i0, j0; return function(d, i, j) { var group = enter[j].update, n = group.length, node; if (j != j0) j0 = j, i0 = 0; if (i &gt;= i0) i0 = i + 1; while (!(node = group[i0]) &amp;&amp; ++i0 &lt; n) ; return node; }; } d3.select = function(node) { var group; if (typeof node === “string”) { group = [ d3_select(node, d3_document) ]; group.parentNode = d3_document.documentElement; } else { group = [ node ]; group.parentNode = d3_documentElement(node); } return d3_selection([ group ]); }; d3.selectAll = function(nodes) { var group; if (typeof nodes === “string”) { group = d3_array(d3_selectAll(nodes, d3_document)); group.parentNode = d3_document.documentElement; } else { group = d3_array(nodes); group.parentNode = null; } return d3_selection([ group ]); }; d3_selectionPrototype.on = function(type, listener, capture) { var n = arguments.length; if (n &lt; 3) { if (typeof type !== “string”) { if (n &lt; 2) listener = false; for (capture in type) this.each(d3_selection_on(capture, type[capture], listener)); return this; } if (n &lt; 2) return (n = this.node()[“on” + type]) &amp;&amp; n._; capture = false; } return this.each(d3_selection_on(type, listener, capture)); }; function d3_selection_on(type, listener, capture) { var name = “on” + type, i = type.indexOf(“.”), wrap = d3_selection_onListener; if (i &gt; 0) type = type.slice(0, i); var filter = d3_selection_onFilters.get(type); if (filter) type = filter, wrap = d3_selection_onFilter; function onRemove() { var l = this[name]; if (l) { this.removeEventListener(type, l, l.$); delete this[name]; } } function onAdd() { var l = wrap(listener, d3_array(arguments)); onRemove.call(this); this.addEventListener(type, this[name] = l, l.$ = capture); l._ = listener; } function removeAll() { var re = new RegExp(“^on([^.]+)” + d3.requote(type) + “$”), match; for (var name in this) { if (match = name.match(re)) { var l = this[name]; this.removeEventListener(match[1], l, l.$); delete this[name]; } } } return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll; } var d3_selection_onFilters = d3.map({ mouseenter: “mouseover”, mouseleave: “mouseout” }); if (d3_document) { d3_selection_onFilters.forEach(function(k) { if (“on” + k in d3_document) d3_selection_onFilters.remove(k); }); } function d3_selection_onListener(listener, argumentz) { return function(e) { var o = d3.event; d3.event = e; argumentz[0] = this.data__; try { listener.apply(this, argumentz); } finally { d3.event = o; } }; } function d3_selection_onFilter(listener, argumentz) { var l = d3_selection_onListener(listener, argumentz); return function(e) { var target = this, related = e.relatedTarget; if (!related || related !== target &amp;&amp; !(related.compareDocumentPosition(target) &amp; 8)) { l.call(target, e); } }; } var d3_event_dragSelect, d3_event_dragId = 0; function d3_event_dragSuppress(node) { var name = “.dragsuppress-“ + ++d3_event_dragId, click = “click” + name, w = d3.select(d3_window(node)).on(“touchmove” + name, d3_eventPreventDefault).on(“dragstart” + name, d3_eventPreventDefault).on(“selectstart” + name, d3_eventPreventDefault); if (d3_event_dragSelect == null) { d3_event_dragSelect = “onselectstart” in node ? false : d3_vendorSymbol(node.style, “userSelect”); } if (d3_event_dragSelect) { var style = d3_documentElement(node).style, select = style[d3_event_dragSelect]; style[d3_event_dragSelect] = “none”; } return function(suppressClick) { w.on(name, null); if (d3_event_dragSelect) style[d3_event_dragSelect] = select; if (suppressClick) { var off = function() { w.on(click, null); }; w.on(click, function() { d3_eventPreventDefault(); off(); }, true); setTimeout(off, 0); } }; } d3.mouse = function(container) { return d3_mousePoint(container, d3_eventSource()); }; var d3_mouse_bug44083 = this.navigator &amp;&amp; /WebKit/.test(this.navigator.userAgent) ? -1 : 0; function d3_mousePoint(container, e) { if (e.changedTouches) e = e.changedTouches[0]; var svg = container.ownerSVGElement || container; if (svg.createSVGPoint) { var point = svg.createSVGPoint(); if (d3_mouse_bug44083 &lt; 0) { var window = d3_window(container); if (window.scrollX || window.scrollY) { svg = d3.select(“body”).append(“svg”).style({ position: “absolute”, top: 0, left: 0, margin: 0, padding: 0, border: “none” }, “important”); var ctm = svg[0][0].getScreenCTM(); d3_mouse_bug44083 = !(ctm.f || ctm.e); svg.remove(); } } if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, point.y = e.clientY; point = point.matrixTransform(container.getScreenCTM().inverse()); return [ point.x, point.y ]; } var rect = container.getBoundingClientRect(); return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ]; } d3.touch = function(container, touches, identifier) { if (arguments.length &lt; 3) identifier = touches, touches = d3_eventSource().changedTouches; if (touches) for (var i = 0, n = touches.length, touch; i &lt; n; ++i) { if ((touch = touches[i]).identifier === identifier) { return d3_mousePoint(container, touch); } } }; d3.behavior.drag = function() { var event = d3_eventDispatch(drag, “drag”, “dragstart”, “dragend”), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, “mousemove”, “mouseup”), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, “touchmove”, “touchend”); function drag() { this.on(“mousedown.drag”, mousedown).on(“touchstart.drag”, touchstart); } function dragstart(id, position, subject, move, end) { return function() { var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = “.drag” + (dragId == null ? “” : “-“ + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId); if (origin) { dragOffset = origin.apply(that, arguments); dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ]; } else { dragOffset = [ 0, 0 ]; } dispatch({ type: “dragstart” }); function moved() { var position1 = position(parent, dragId), dx, dy; if (!position1) return; dx = position1[0] - position0[0]; dy = position1[1] - position0[1]; dragged |= dx | dy; position0 = position1; dispatch({ type: “drag”, x: position1[0] + dragOffset[0], y: position1[1] + dragOffset[1], dx: dx, dy: dy }); } function ended() { if (!position(parent, dragId)) return; dragSubject.on(move + dragName, null).on(end + dragName, null); dragRestore(dragged); dispatch({ type: “dragend” }); } }; } drag.origin = function(x) { if (!arguments.length) return origin; origin = x; return drag; }; return d3.rebind(drag, event, “on”); }; function d3_behavior_dragTouchId() { return d3.event.changedTouches[0].identifier; } d3.touches = function(container, touches) { if (arguments.length &lt; 2) touches = d3_eventSource().touches; return touches ? d3_array(touches).map(function(touch) { var point = d3_mousePoint(container, touch); point.identifier = touch.identifier; return point; }) : []; }; var ε = 1e-6, ε2 = ε ε, π = Math.PI, τ = 2 π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π; function d3_sgn(x) { return x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0; } function d3_cross2d(a, b, c) { return (b[0] - a[0]) (c[1] - a[1]) - (b[1] - a[1]) (c[0] - a[0]); } function d3_acos(x) { return x &gt; 1 ? 0 : x &lt; -1 ? π : Math.acos(x); } function d3_asin(x) { return x &gt; 1 ? halfπ : x &lt; -1 ? -halfπ : Math.asin(x); } function d3_sinh(x) { return ((x = Math.exp(x)) - 1 / x) / 2; } function d3_cosh(x) { return ((x = Math.exp(x)) + 1 / x) / 2; } function d3_tanh(x) { return ((x = Math.exp(2 x)) - 1) / (x + 1); } function d3_haversin(x) { return (x = Math.sin(x / 2)) x; } var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4; d3.interpolateZoom = function(p0, p1) { var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx dx + dy dy, i, S; if (d2 &lt; ε2) { S = Math.log(w1 / w0) / ρ; i = function(t) { return [ ux0 + t dx, uy0 + t dy, w0 Math.exp(ρ t S) ]; }; } else { var d1 = Math.sqrt(d2), b0 = (w1 w1 - w0 w0 + ρ4 d2) / (2 w0 ρ2 d1), b1 = (w1 w1 - w0 w0 - ρ4 d2) / (2 w1 ρ2 d1), r0 = Math.log(Math.sqrt(b0 b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 b1 + 1) - b1); S = (r1 - r0) / ρ; i = function(t) { var s = t S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 d1) (coshr0 d3_tanh(ρ s + r0) - d3_sinh(r0)); return [ ux0 + u dx, uy0 + u dy, w0 coshr0 / d3_cosh(ρ s + r0) ]; }; } i.duration = S 1e3; return i; }; d3.behavior.zoom = function() { var view = { x: 0, y: 0, k: 1 }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = “mousedown.zoom”, mousemove = “mousemove.zoom”, mouseup = “mouseup.zoom”, mousewheelTimer, touchstart = “touchstart.zoom”, touchtime, event = d3_eventDispatch(zoom, “zoomstart”, “zoom”, “zoomend”), x0, x1, y0, y1; if (!d3_behavior_zoomWheel) { d3_behavior_zoomWheel = “onwheel” in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY (d3.event.deltaMode ? 120 : 1); }, “wheel”) : “onmousewheel” in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, “mousewheel”) : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, “MozMousePixelScroll”); } function zoom(g) { g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + “.zoom”, mousewheeled).on(“dblclick.zoom”, dblclicked).on(touchstart, touchstarted); } zoom.event = function(g) { g.each(function() { var dispatch = event.of(this, arguments), view1 = view; if (d3_transitionInheritId) { d3.select(this).transition().each(“start.zoom”, function() { view = this.chart || { x: 0, y: 0, k: 1 }; zoomstarted(dispatch); }).tween(“zoom:zoom”, function() { var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]); return function(t) { var l = i(t), k = dx / l[2]; this.chart = view = { x: cx - l[0] k, y: cy - l[1] k, k: k }; zoomed(dispatch); }; }).each(“interrupt.zoom”, function() { zoomended(dispatch); }).each(“end.zoom”, function() { zoomended(dispatch); }); } else { this.chart = view; zoomstarted(dispatch); zoomed(dispatch); zoomended(dispatch); } }); }; zoom.translate = function() { if (!arguments.length) return [ view.x, view.y ]; view = { x: +[0], y: +[1], k: view.k }; rescale(); return zoom; }; zoom.scale = function() { if (!arguments.length) return view.k; view = { x: view.x, y: view.y, k: null }; scaleTo(+); rescale(); return zoom; }; zoom.scaleExtent = function() { if (!arguments.length) return scaleExtent; scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +[0], +[1] ]; return zoom; }; zoom.center = function(_) { if (!arguments.length) return center; center = _ &amp;&amp; [ +[0], +[1] ]; return zoom; }; zoom.size = function(_) { if (!arguments.length) return size; size = _ &amp;&amp; [ +[0], +[1] ]; return zoom; }; zoom.duration = function() { if (!arguments.length) return duration; duration = +; return zoom; }; zoom.x = function(z) { if (!arguments.length) return x1; x1 = z; x0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; zoom.y = function(z) { if (!arguments.length) return y1; y1 = z; y0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; function location(p) { return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ]; } function point(l) { return [ l[0] view.k + view.x, l[1] view.k + view.y ]; } function scaleTo(s) { view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s)); } function translateTo(p, l) { l = point(l); view.x += p[0] - l[0]; view.y += p[1] - l[1]; } function zoomTo(that, p, l, k) { that.chart = { x: view.x, y: view.y, k: view.k }; scaleTo(Math.pow(2, k)); translateTo(center0 = p, l); that = d3.select(that); if (duration &gt; 0) that = that.transition().duration(duration); that.call(zoom.event); } function rescale() { if (x1) x1.domain(x0.range().map(function(x) { return (x - view.x) / view.k; }).map(x0.invert)); if (y1) y1.domain(y0.range().map(function(y) { return (y - view.y) / view.k; }).map(y0.invert)); } function zoomstarted(dispatch) { if (!zooming++) dispatch({ type: “zoomstart” }); } function zoomed(dispatch) { rescale(); dispatch({ type: “zoom”, scale: view.k, translate: [ view.x, view.y ] }); } function zoomended(dispatch) { if (!–zooming) dispatch({ type: “zoomend” }), center0 = null; } function mousedowned() { var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that); d3_selection_interrupt.call(that); zoomstarted(dispatch); function moved() { dragged = 1; translateTo(d3.mouse(that), location0); zoomed(dispatch); } function ended() { subject.on(mousemove, null).on(mouseup, null); dragRestore(dragged); zoomended(dispatch); } } function touchstarted() { var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = “.zoom-“ + d3.event.changedTouches[0].identifier, touchmove = “touchmove” + zoomName, touchend = “touchend” + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that); started(); zoomstarted(dispatch); subject.on(mousedown, null).on(touchstart, started); function relocate() { var touches = d3.touches(that); scale0 = view.k; touches.forEach(function(t) { if (t.identifier in locations0) locations0[t.identifier] = location(t); }); return touches; } function started() { var target = d3.event.target; d3.select(target).on(touchmove, moved).on(touchend, ended); targets.push(target); var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i &lt; n; ++i) { locations0[changed[i].identifier] = null; } var touches = relocate(), now = Date.now(); if (touches.length === 1) { if (now - touchtime &lt; 500) { var p = touches[0]; zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1); d3_eventPreventDefault(); } touchtime = now; } else if (touches.length &gt; 1) { var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1]; distance0 = dx dx + dy dy; } } function moved() { var touches = d3.touches(that), p0, l0, p1, l1; d3_selection_interrupt.call(that); for (var i = 0, n = touches.length; i &lt; n; ++i, l1 = null) { p1 = touches[i]; if (l1 = locations0[p1.identifier]) { if (l0) break; p0 = p1, l0 = l1; } } if (l1) { var distance1 = (distance1 = p1[0] - p0[0]) distance1 + (distance1 = p1[1] - p0[1]) distance1, scale1 = distance0 &amp;&amp; Math.sqrt(distance1 / distance0); p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ]; l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ]; scaleTo(scale1 scale0); } touchtime = null; translateTo(p0, l0); zoomed(dispatch); } function ended() { if (d3.event.touches.length) { var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i &lt; n; ++i) { delete locations0[changed[i].identifier]; } for (var identifier in locations0) { return void relocate(); } } d3.selectAll(targets).on(zoomName, null); subject.on(mousedown, mousedowned).on(touchstart, touchstarted); dragRestore(); zoomended(dispatch); } } function mousewheeled() { var dispatch = event.of(this, arguments); if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch); mousewheelTimer = setTimeout(function() { mousewheelTimer = null; zoomended(dispatch); }, 50); d3_eventPreventDefault(); scaleTo(Math.pow(2, d3_behavior_zoomDelta() .002) view.k); translateTo(center0, translate0); zoomed(dispatch); } function dblclicked() { var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2; zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1); } return d3.rebind(zoom, event, “on”); }; var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel; d3.color = d3_color; function d3_color() {} d3_color.prototype.toString = function() { return this.rgb() + “”; }; d3.hsl = d3_hsl; function d3_hsl(h, s, l) { return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length &lt; 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(“” + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l); } var d3_hslPrototype = d3_hsl.prototype = new d3_color(); d3_hslPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, this.l / k); }; d3_hslPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, k this.l); }; d3_hslPrototype.rgb = function() { return d3_hsl_rgb(this.h, this.s, this.l); }; function d3_hsl_rgb(h, s, l) { var m1, m2; h = isNaN(h) ? 0 : (h %= 360) &lt; 0 ? h + 360 : h; s = isNaN(s) ? 0 : s &lt; 0 ? 0 : s &gt; 1 ? 1 : s; l = l &lt; 0 ? 0 : l &gt; 1 ? 1 : l; m2 = l &lt;= .5 ? l (1 + s) : l + s - l s; m1 = 2 l - m2; function v(h) { if (h &gt; 360) h -= 360; else if (h &lt; 0) h += 360; if (h &lt; 60) return m1 + (m2 - m1) h / 60; if (h &lt; 180) return m2; if (h &lt; 240) return m1 + (m2 - m1) (240 - h) / 60; return m1; } function vv(h) { return Math.round(v(h) 255); } return new d3_rgb(vv(h + 120), vv(h), vv(h - 120)); } d3.hcl = d3_hcl; function d3_hcl(h, c, l) { return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length &lt; 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l); } var d3_hclPrototype = d3_hcl.prototype = new d3_color(); d3_hclPrototype.brighter = function(k) { return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K (arguments.length ? k : 1))); }; d3_hclPrototype.darker = function(k) { return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K (arguments.length ? k : 1))); }; d3_hclPrototype.rgb = function() { return d3_hcl_lab(this.h, this.c, this.l).rgb(); }; function d3_hcl_lab(h, c, l) { if (isNaN(h)) h = 0; if (isNaN(c)) c = 0; return new d3_lab(l, Math.cos(h = d3_radians) c, Math.sin(h) c); } d3.lab = d3_lab; function d3_lab(l, a, b) { return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length &lt; 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b); } var d3_lab_K = 18; var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883; var d3_labPrototype = d3_lab.prototype = new d3_color(); d3_labPrototype.brighter = function(k) { return new d3_lab(Math.min(100, this.l + d3_lab_K (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.darker = function(k) { return new d3_lab(Math.max(0, this.l - d3_lab_K (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.rgb = function() { return d3_lab_rgb(this.l, this.a, this.b); }; function d3_lab_rgb(l, a, b) { var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200; x = d3_lab_xyz(x) d3_lab_X; y = d3_lab_xyz(y) d3_lab_Y; z = d3_lab_xyz(z) d3_lab_Z; return new d3_rgb(d3_xyz_rgb(3.2404542 x - 1.5371385 y - .4985314 z), d3_xyz_rgb(-.969266 x + 1.8760108 y + .041556 z), d3_xyz_rgb(.0556434 x - .2040259 y + 1.0572252 z)); } function d3_lab_hcl(l, a, b) { return l &gt; 0 ? new d3_hcl(Math.atan2(b, a) d3_degrees, Math.sqrt(a a + b b), l) : new d3_hcl(NaN, NaN, l); } function d3_lab_xyz(x) { return x &gt; .206893034 ? x x x : (x - 4 / 29) / 7.787037; } function d3_xyz_lab(x) { return x &gt; .008856 ? Math.pow(x, 1 / 3) : 7.787037 x + 4 / 29; } function d3_xyz_rgb(r) { return Math.round(255 (r &lt;= .00304 ? 12.92 r : 1.055 Math.pow(r, 1 / 2.4) - .055)); } d3.rgb = d3_rgb; function d3_rgb(r, g, b) { return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length &lt; 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(“” + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b); } function d3_rgbNumber(value) { return new d3_rgb(value &gt;&gt; 16, value &gt;&gt; 8 &amp; 255, value &amp; 255); } function d3_rgbString(value) { return d3_rgbNumber(value) + “”; } var d3_rgbPrototype = d3_rgb.prototype = new d3_color(); d3_rgbPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); var r = this.r, g = this.g, b = this.b, i = 30; if (!r &amp;&amp; !g &amp;&amp; !b) return new d3_rgb(i, i, i); if (r &amp;&amp; r &lt; i) r = i; if (g &amp;&amp; g &lt; i) g = i; if (b &amp;&amp; b &lt; i) b = i; return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k)); }; d3_rgbPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_rgb(k this.r, k this.g, k this.b); }; d3_rgbPrototype.hsl = function() { return d3_rgb_hsl(this.r, this.g, this.b); }; d3_rgbPrototype.toString = function() { return “#” + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b); }; function d3_rgb_hex(v) { return v &lt; 16 ? “0” + Math.max(0, v).toString(16) : Math.min(255, v).toString(16); } function d3_rgb_parse(format, rgb, hsl) { var r = 0, g = 0, b = 0, m1, m2, color; m1 = /([a-z]+)((.))/.exec(format = format.toLowerCase()); if (m1) { m2 = m1[2].split(“,”); switch (m1[1]) { case “hsl”: { return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100); } case “rgb”: { return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2])); } } } if (color = d3_rgb_names.get(format)) { return rgb(color.r, color.g, color.b); } if (format != null &amp;&amp; format.charAt(0) === “#” &amp;&amp; !isNaN(color = parseInt(format.slice(1), 16))) { if (format.length === 4) { r = (color &amp; 3840) &gt;&gt; 4; r = r &gt;&gt; 4 | r; g = color &amp; 240; g = g &gt;&gt; 4 | g; b = color &amp; 15; b = b &lt;&lt; 4 | b; } else if (format.length === 7) { r = (color &amp; 16711680) &gt;&gt; 16; g = (color &amp; 65280) &gt;&gt; 8; b = color &amp; 255; } } return rgb(r, g, b); } function d3_rgb_hsl(r, g, b) { var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2; if (d) { s = l &lt; .5 ? d / (max + min) : d / (2 - max - min); if (r == max) h = (g - b) / d + (g &lt; b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4; h = 60; } else { h = NaN; s = l &gt; 0 &amp;&amp; l &lt; 1 ? 0 : h; } return new d3_hsl(h, s, l); } function d3_rgb_lab(r, g, b) { r = d3_rgb_xyz(r); g = d3_rgb_xyz(g); b = d3_rgb_xyz(b); var x = d3_xyz_lab((.4124564 r + .3575761 g + .1804375 b) / d3_lab_X), y = d3_xyz_lab((.2126729 r + .7151522 g + .072175 b) / d3_lab_Y), z = d3_xyz_lab((.0193339 r + .119192 g + .9503041 b) / d3_lab_Z); return d3_lab(116 y - 16, 500 (x - y), 200 (y - z)); } function d3_rgb_xyz(r) { return (r /= 255) &lt;= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4); } function d3_rgb_parseNumber(c) { var f = parseFloat(c); return c.charAt(c.length - 1) === “%” ? Math.round(f 2.55) : f; } var d3_rgb_names = d3.map({ aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }); d3_rgb_names.forEach(function(key, value) { d3_rgb_names.set(key, d3_rgbNumber(value)); }); function d3_functor(v) { return typeof v === “function” ? v : function() { return v; }; } d3.functor = d3_functor; d3.xhr = d3_xhrType(d3_identity); function d3_xhrType(response) { return function(url, mimeType, callback) { if (arguments.length === 2 &amp;&amp; typeof mimeType === “function”) callback = mimeType, mimeType = null; return d3_xhr(url, mimeType, response, callback); }; } function d3_xhr(url, mimeType, response, callback) { var xhr = {}, dispatch = d3.dispatch(“beforesend”, “progress”, “load”, “error”), headers = {}, request = new XMLHttpRequest(), responseType = null; if (this.XDomainRequest &amp;&amp; !(“withCredentials” in request) &amp;&amp; /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest(); “onload” in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() { request.readyState &gt; 3 &amp;&amp; respond(); }; function respond() { var status = request.status, result; if (!status &amp;&amp; d3_xhrHasResponse(request) || status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304) { try { result = response.call(xhr, request); } catch (e) { dispatch.error.call(xhr, e); return; } dispatch.load.call(xhr, result); } else { dispatch.error.call(xhr, request); } } request.onprogress = function(event) { var o = d3.event; d3.event = event; try { dispatch.progress.call(xhr, request); } finally { d3.event = o; } }; xhr.header = function(name, value) { name = (name + “”).toLowerCase(); if (arguments.length &lt; 2) return headers[name]; if (value == null) delete headers[name]; else headers[name] = value + “”; return xhr; }; xhr.mimeType = function(value) { if (!arguments.length) return mimeType; mimeType = value == null ? null : value + “”; return xhr; }; xhr.responseType = function(value) { if (!arguments.length) return responseType; responseType = value; return xhr; }; xhr.response = function(value) { response = value; return xhr; }; [ “get”, “post” ].forEach(function(method) { xhr[method] = function() { return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments))); }; }); xhr.send = function(method, data, callback) { if (arguments.length === 2 &amp;&amp; typeof data === “function”) callback = data, data = null; request.open(method, url, true); if (mimeType != null &amp;&amp; !(“accept” in headers)) headers[“accept”] = mimeType + “,/“; if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]); if (mimeType != null &amp;&amp; request.overrideMimeType) request.overrideMimeType(mimeType); if (responseType != null) request.responseType = responseType; if (callback != null) xhr.on(“error”, callback).on(“load”, function(request) { callback(null, request); }); dispatch.beforesend.call(xhr, request); request.send(data == null ? null : data); return xhr; }; xhr.abort = function() { request.abort(); return xhr; }; d3.rebind(xhr, dispatch, “on”); return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback)); } function d3_xhr_fixCallback(callback) { return callback.length === 1 ? function(error, request) { callback(error == null ? request : null); } : callback; } function d3_xhrHasResponse(request) { var type = request.responseType; return type &amp;&amp; type !== “text” ? request.response : request.responseText; } d3.dsv = function(delimiter, mimeType) { var reFormat = new RegExp(‘[“‘ + delimiter + “\n]”), delimiterCode = delimiter.charCodeAt(0); function dsv(url, row, callback) { if (arguments.length &lt; 3) callback = row, row = null; var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback); xhr.row = function(_) { return arguments.length ? xhr.response((row = ) == null ? response : typedResponse()) : row; }; return xhr; } function response(request) { return dsv.parse(request.responseText); } function typedResponse(f) { return function(request) { return dsv.parse(request.responseText, f); }; } dsv.parse = function(text, f) { var o; return dsv.parseRows(text, function(row, i) { if (o) return o(row, i - 1); var a = new Function(“d”, “return {“ + row.map(function(name, i) { return JSON.stringify(name) + “: d[“ + i + “]”; }).join(“,”) + “}”); o = f ? function(row, i) { return f(a(row), i); } : a; }); }; dsv.parseRows = function(text, f) { var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol; function token() { if (I &gt;= N) return EOF; if (eol) return eol = false, EOL; var j = I; if (text.charCodeAt(j) === 34) { var i = j; while (i++ &lt; N) { if (text.charCodeAt(i) === 34) { if (text.charCodeAt(i + 1) !== 34) break; ++i; } } I = i + 2; var c = text.charCodeAt(i + 1); if (c === 13) { eol = true; if (text.charCodeAt(i + 2) === 10) ++I; } else if (c === 10) { eol = true; } return text.slice(j + 1, i).replace(/“”/g, ‘“‘); } while (I &lt; N) { var c = text.charCodeAt(I++), k = 1; if (c === 10) eol = true; else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } else if (c !== delimiterCode) continue; return text.slice(j, I - k); } return text.slice(j); } while ((t = token()) !== EOF) { var a = []; while (t !== EOL &amp;&amp; t !== EOF) { a.push(t); t = token(); } if (f &amp;&amp; (a = f(a, n++)) == null) continue; rows.push(a); } return rows; }; dsv.format = function(rows) { if (Array.isArray(rows[0])) return dsv.formatRows(rows); var fieldSet = new d3_Set(), fields = []; rows.forEach(function(row) { for (var field in row) { if (!fieldSet.has(field)) { fields.push(fieldSet.add(field)); } } }); return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) { return fields.map(function(field) { return formatValue(row[field]); }).join(delimiter); })).join(“\n”); }; dsv.formatRows = function(rows) { return rows.map(formatRow).join(“\n”); }; function formatRow(row) { return row.map(formatValue).join(delimiter); } function formatValue(text) { return reFormat.test(text) ? ‘“‘ + text.replace(/\”/g, ‘“”‘) + ‘“‘ : text; } return dsv; }; d3.csv = d3.dsv(“,”, “text/csv”); d3.tsv = d3.dsv(“ “, “text/tab-separated-values”); var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, “requestAnimationFrame”)] || function(callback) { setTimeout(callback, 17); }; d3.timer = function() { d3_timer.apply(this, arguments); }; function d3_timer(callback, delay, then) { var n = arguments.length; if (n &lt; 2) delay = 0; if (n &lt; 3) then = Date.now(); var time = then + delay, timer = { c: callback, t: time, n: null }; if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer; d3_timer_queueTail = timer; if (!d3_timer_interval) { d3_timer_timeout = clearTimeout(d3_timer_timeout); d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } return timer; } function d3_timer_step() { var now = d3_timer_mark(), delay = d3_timer_sweep() - now; if (delay &gt; 24) { if (isFinite(delay)) { clearTimeout(d3_timer_timeout); d3_timer_timeout = setTimeout(d3_timer_step, delay); } d3_timer_interval = 0; } else { d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } } d3.timer.flush = function() { d3_timer_mark(); d3_timer_sweep(); }; function d3_timer_mark() { var now = Date.now(), timer = d3_timer_queueHead; while (timer) { if (now &gt;= timer.t &amp;&amp; timer.c(now - timer.t)) timer.c = null; timer = timer.n; } return now; } function d3_timer_sweep() { var t0, t1 = d3_timer_queueHead, time = Infinity; while (t1) { if (t1.c) { if (t1.t &lt; time) time = t1.t; t1 = (t0 = t1).n; } else { t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n; } } d3_timer_queueTail = t0; return time; } function d3_format_precision(x, p) { return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1); } d3.round = function(x, n) { return n ? Math.round(x (n = Math.pow(10, n))) / n : Math.round(x); }; var d3_formatPrefixes = [ “y”, “z”, “a”, “f”, “p”, “n”, “µ”, “m”, “”, “k”, “M”, “G”, “T”, “P”, “E”, “Z”, “Y” ].map(d3_formatPrefix); d3.formatPrefix = function(value, precision) { var i = 0; if (value = +value) { if (value &lt; 0) value = -1; if (precision) value = d3.round(value, d3_format_precision(value, precision)); i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10); i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) 3)); } return d3_formatPrefixes[8 + i / 3]; }; function d3_formatPrefix(d, i) { var k = Math.pow(10, abs(8 - i) 3); return { scale: i &gt; 8 ? function(d) { return d / k; } : function(d) { return d k; }, symbol: d }; } function d3_locale_numberFormat(locale) { var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping &amp;&amp; locale_thousands ? function(value, width) { var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0; while (i &gt; 0 &amp;&amp; g &gt; 0) { if (length + g + 1 &gt; width) g = Math.max(1, width - length); t.push(value.substring(i -= g, i + g)); if ((length += g + 1) &gt; width) break; g = locale_grouping[j = (j + 1) % locale_grouping.length]; } return t.reverse().join(locale_thousands); } : d3_identity; return function(specifier) { var match = d3_format_re.exec(specifier), fill = match[1] || “ “, align = match[2] || “&gt;”, sign = match[3] || “-“, symbol = match[4] || “”, zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = “”, suffix = “”, integer = false, exponent = true; if (precision) precision = +precision.substring(1); if (zfill || fill === “0” &amp;&amp; align === “=”) { zfill = fill = “0”; align = “=”; } switch (type) { case “n”: comma = true; type = “g”; break; case “%”: scale = 100; suffix = “%”; type = “f”; break; case “p”: scale = 100; suffix = “%”; type = “r”; break; case “b”: case “o”: case “x”: case “X”: if (symbol === “#”) prefix = “0” + type.toLowerCase(); case “c”: exponent = false; case “d”: integer = true; precision = 0; break; case “s”: scale = -1; type = “r”; break; } if (symbol === “$”) prefix = locale_currency[0], suffix = locale_currency[1]; if (type == “r” &amp;&amp; !precision) type = “g”; if (precision != null) { if (type == “g”) precision = Math.max(1, Math.min(21, precision)); else if (type == “e” || type == “f”) precision = Math.max(0, Math.min(20, precision)); } type = d3_format_types.get(type) || d3_format_typeDefault; var zcomma = zfill &amp;&amp; comma; return function(value) { var fullSuffix = suffix; if (integer &amp;&amp; value % 1) return “”; var negative = value &lt; 0 || value === 0 &amp;&amp; 1 / value &lt; 0 ? (value = -value, “-“) : sign === “-“ ? “” : sign; if (scale &lt; 0) { var unit = d3.formatPrefix(value, precision); value = unit.scale(value); fullSuffix = unit.symbol + suffix; } else { value = scale; } value = type(value, precision); var i = value.lastIndexOf(“.”), before, after; if (i &lt; 0) { var j = exponent ? value.lastIndexOf(“e”) : -1; if (j &lt; 0) before = value, after = “”; else before = value.substring(0, j), after = value.substring(j); } else { before = value.substring(0, i); after = locale_decimal + value.substring(i + 1); } if (!zfill &amp;&amp; comma) before = formatGroup(before, Infinity); var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length &lt; width ? new Array(length = width - length + 1).join(fill) : “”; if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity); negative += prefix; value = before + after; return (align === “&lt;” ? negative + value + padding : align === “&gt;” ? padding + negative + value : align === “^” ? padding.substring(0, length &gt;&gt;= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix; }; }; } var d3_format_re = /(?:([^{])?([&lt;&gt;=^]))?([+- ])?([$#])?(0)?(\d+)?(,)?(.-?\d+)?([a-z%])?/i; var d3_format_types = d3.map({ b: function(x) { return x.toString(2); }, c: function(x) { return String.fromCharCode(x); }, o: function(x) { return x.toString(8); }, x: function(x) { return x.toString(16); }, X: function(x) { return x.toString(16).toUpperCase(); }, g: function(x, p) { return x.toPrecision(p); }, e: function(x, p) { return x.toExponential(p); }, f: function(x, p) { return x.toFixed(p); }, r: function(x, p) { return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x (1 + 1e-15), p)))); } }); function d3_format_typeDefault(x) { return x + “”; } var d3_time = d3.time = {}, d3_date = Date; function d3_date_utc() { this._ = new Date(arguments.length &gt; 1 ? Date.UTC.apply(this, arguments) : arguments[0]); } d3_date_utc.prototype = { getDate: function() { return this..getUTCDate(); }, getDay: function() { return this..getUTCDay(); }, getFullYear: function() { return this..getUTCFullYear(); }, getHours: function() { return this..getUTCHours(); }, getMilliseconds: function() { return this..getUTCMilliseconds(); }, getMinutes: function() { return this..getUTCMinutes(); }, getMonth: function() { return this..getUTCMonth(); }, getSeconds: function() { return this..getUTCSeconds(); }, getTime: function() { return this..getTime(); }, getTimezoneOffset: function() { return 0; }, valueOf: function() { return this..valueOf(); }, setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); }, setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); }, setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); }, setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); }, setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); }, setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); }, setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); }, setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); }, setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); } }; var d3_time_prototype = Date.prototype; function d3_time_interval(local, step, number) { function round(date) { var d0 = local(date), d1 = offset(d0, 1); return date - d0 &lt; d1 - date ? d0 : d1; } function ceil(date) { step(date = local(new d3_date(date - 1)), 1); return date; } function offset(date, k) { step(date = new d3_date(+date), k); return date; } function range(t0, t1, dt) { var time = ceil(t0), times = []; if (dt &gt; 1) { while (time &lt; t1) { if (!(number(time) % dt)) times.push(new Date(+time)); step(time, 1); } } else { while (time &lt; t1) times.push(new Date(+time)), step(time, 1); } return times; } function range_utc(t0, t1, dt) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = t0; return range(utc, t1, dt); } finally { d3_date = Date; } } local.floor = local; local.round = round; local.ceil = ceil; local.offset = offset; local.range = range; var utc = local.utc = d3_time_interval_utc(local); utc.floor = utc; utc.round = d3_time_interval_utc(round); utc.ceil = d3_time_interval_utc(ceil); utc.offset = d3_time_interval_utc(offset); utc.range = range_utc; return local; } function d3_time_interval_utc(method) { return function(date, k) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = date; return method(utc, k)._; } finally { d3_date = Date; } }; } d3_time.year = d3_time_interval(function(date) { date = d3_time.day(date); date.setMonth(0, 1); return date; }, function(date, offset) { date.setFullYear(date.getFullYear() + offset); }, function(date) { return date.getFullYear(); }); d3_time.years = d3_time.year.range; d3_time.years.utc = d3_time.year.utc.range; d3_time.day = d3_time_interval(function(date) { var day = new d3_date(2e3, 0); day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()); return day; }, function(date, offset) { date.setDate(date.getDate() + offset); }, function(date) { return date.getDate() - 1; }); d3_time.days = d3_time.day.range; d3_time.days.utc = d3_time.day.utc.range; d3_time.dayOfYear = function(date) { var year = d3_time.year(date); return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) 6e4) / 864e5); }; [ “sunday”, “monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday” ].forEach(function(day, i) { i = 7 - i; var interval = d3_time[day] = d3_time_interval(function(date) { (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7); return date; }, function(date, offset) { date.setDate(date.getDate() + Math.floor(offset) 7); }, function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i); }); d3_time[day + “s”] = interval.range; d3_time[day + “s”].utc = interval.utc.range; d3_time[day + “OfYear”] = function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7); }; }); d3_time.week = d3_time.sunday; d3_time.weeks = d3_time.sunday.range; d3_time.weeks.utc = d3_time.sunday.utc.range; d3_time.weekOfYear = d3_time.sundayOfYear; function d3_locale_timeFormat(locale) { var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths; function d3_time_format(template) { var n = template.length; function format(date) { var string = [], i = -1, j = 0, c, p, f; while (++i &lt; n) { if (template.charCodeAt(i) === 37) { string.push(template.slice(j, i)); if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i); if (f = d3_time_formats[c]) c = f(date, p == null ? c === “e” ? “ “ : “0” : p); string.push(c); j = i + 1; } } string.push(template.slice(j, i)); return string.join(“”); } format.parse = function(string) { var d = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, i = d3_time_parse(d, template, string, 0); if (i != string.length) return null; if (“p” in d) d.H = d.H % 12 + d.p 12; var localZ = d.Z != null &amp;&amp; d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)(); if (“j” in d) date.setFullYear(d.y, 0, d.j); else if (“W” in d || “U” in d) { if (!(“w” in d)) d.w = “W” in d ? 1 : 0; date.setFullYear(d.y, 0, 1); date.setFullYear(d.y, 0, “W” in d ? (d.w + 6) % 7 + d.W 7 - (date.getDay() + 5) % 7 : d.w + d.U 7 - (date.getDay() + 6) % 7); } else date.setFullYear(d.y, d.m, d.d); date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L); return localZ ? date._ : date; }; format.toString = function() { return template; }; return format; } function d3_time_parse(date, template, string, j) { var c, p, t, i = 0, n = template.length, m = string.length; while (i &lt; n) { if (j &gt;= m) return -1; c = template.charCodeAt(i++); if (c === 37) { t = template.charAt(i++); p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t]; if (!p || (j = p(date, string, j)) &lt; 0) return -1; } else if (c != string.charCodeAt(j++)) { return -1; } } return j; } d3_time_format.utc = function(template) { var local = d3_time_format(template); function format(date) { try { d3_date = d3_date_utc; var utc = new d3_date(); utc._ = date; return local(utc); } finally { d3_date = Date; } } format.parse = function(string) { try { d3_date = d3_date_utc; var date = local.parse(string); return date &amp;&amp; date._; } finally { d3_date = Date; } }; format.toString = local.toString; return format; }; d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti; var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths); locale_periods.forEach(function(p, i) { d3_time_periodLookup.set(p.toLowerCase(), i); }); var d3_time_formats = { a: function(d) { return locale_shortDays[d.getDay()]; }, A: function(d) { return locale_days[d.getDay()]; }, b: function(d) { return locale_shortMonths[d.getMonth()]; }, B: function(d) { return locale_months[d.getMonth()]; }, c: d3_time_format(locale_dateTime), d: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, e: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, H: function(d, p) { return d3_time_formatPad(d.getHours(), p, 2); }, I: function(d, p) { return d3_time_formatPad(d.getHours() % 12 || 12, p, 2); }, j: function(d, p) { return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3); }, L: function(d, p) { return d3_time_formatPad(d.getMilliseconds(), p, 3); }, m: function(d, p) { return d3_time_formatPad(d.getMonth() + 1, p, 2); }, M: function(d, p) { return d3_time_formatPad(d.getMinutes(), p, 2); }, p: function(d) { return locale_periods[+(d.getHours() &gt;= 12)]; }, S: function(d, p) { return d3_time_formatPad(d.getSeconds(), p, 2); }, U: function(d, p) { return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2); }, w: function(d) { return d.getDay(); }, W: function(d, p) { return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2); }, x: d3_time_format(locale_date), X: d3_time_format(locale_time), y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 100, p, 2); }, Y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 1e4, p, 4); }, Z: d3_time_zone, “%”: function() { return “%”; } }; var d3_time_parsers = { a: d3_time_parseWeekdayAbbrev, A: d3_time_parseWeekday, b: d3_time_parseMonthAbbrev, B: d3_time_parseMonth, c: d3_time_parseLocaleFull, d: d3_time_parseDay, e: d3_time_parseDay, H: d3_time_parseHour24, I: d3_time_parseHour24, j: d3_time_parseDayOfYear, L: d3_time_parseMilliseconds, m: d3_time_parseMonthNumber, M: d3_time_parseMinutes, p: d3_time_parseAmPm, S: d3_time_parseSeconds, U: d3_time_parseWeekNumberSunday, w: d3_time_parseWeekdayNumber, W: d3_time_parseWeekNumberMonday, x: d3_time_parseLocaleDate, X: d3_time_parseLocaleTime, y: d3_time_parseYear, Y: d3_time_parseFullYear, Z: d3_time_parseZone, “%”: d3_time_parseLiteralPercent }; function d3_time_parseWeekdayAbbrev(date, string, i) { d3_time_dayAbbrevRe.lastIndex = 0; var n = d3_time_dayAbbrevRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseWeekday(date, string, i) { d3_time_dayRe.lastIndex = 0; var n = d3_time_dayRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonthAbbrev(date, string, i) { d3_time_monthAbbrevRe.lastIndex = 0; var n = d3_time_monthAbbrevRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonth(date, string, i) { d3_time_monthRe.lastIndex = 0; var n = d3_time_monthRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseLocaleFull(date, string, i) { return d3_time_parse(date, d3_time_formats.c.toString(), string, i); } function d3_time_parseLocaleDate(date, string, i) { return d3_time_parse(date, d3_time_formats.x.toString(), string, i); } function d3_time_parseLocaleTime(date, string, i) { return d3_time_parse(date, d3_time_formats.X.toString(), string, i); } function d3_time_parseAmPm(date, string, i) { var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase()); return n == null ? -1 : (date.p = n, i); } return d3_time_format; } var d3_time_formatPads = { “-“: “”, _: “ “, “0”: “0” }, d3_time_numberRe = /^\s\d+/, d3_time_percentRe = /^%/; function d3_time_formatPad(value, fill, width) { var sign = value &lt; 0 ? “-“ : “”, string = (sign ? -value : value) + “”, length = string.length; return sign + (length &lt; width ? new Array(width - length + 1).join(fill) + string : string); } function d3_time_formatRe(names) { return new RegExp(“^(?:” + names.map(d3.requote).join(“|”) + “)”, “i”); } function d3_time_formatLookup(names) { var map = new d3_Map(), i = -1, n = names.length; while (++i &lt; n) map.set(names[i].toLowerCase(), i); return map; } function d3_time_parseWeekdayNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 1)); return n ? (date.w = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberSunday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.U = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberMonday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.W = +n[0], i + n[0].length) : -1; } function d3_time_parseFullYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 4)); return n ? (date.y = +n[0], i + n[0].length) : -1; } function d3_time_parseYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1; } function d3_time_parseZone(date, string, i) { return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1; } function d3_time_expandYear(d) { return d + (d &gt; 68 ? 1900 : 2e3); } function d3_time_parseMonthNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.m = n[0] - 1, i + n[0].length) : -1; } function d3_time_parseDay(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.d = +n[0], i + n[0].length) : -1; } function d3_time_parseDayOfYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.j = +n[0], i + n[0].length) : -1; } function d3_time_parseHour24(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.H = +n[0], i + n[0].length) : -1; } function d3_time_parseMinutes(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.M = +n[0], i + n[0].length) : -1; } function d3_time_parseSeconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.S = +n[0], i + n[0].length) : -1; } function d3_time_parseMilliseconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.L = +n[0], i + n[0].length) : -1; } function d3_time_zone(d) { var z = d.getTimezoneOffset(), zs = z &gt; 0 ? “-“ : “+”, zh = abs(z) / 60 | 0, zm = abs(z) % 60; return zs + d3_time_formatPad(zh, “0”, 2) + d3_time_formatPad(zm, “0”, 2); } function d3_time_parseLiteralPercent(date, string, i) { d3_time_percentRe.lastIndex = 0; var n = d3_time_percentRe.exec(string.slice(i, i + 1)); return n ? i + n[0].length : -1; } function d3_time_formatMulti(formats) { var n = formats.length, i = -1; while (++i &lt; n) formats[i][0] = this(formats[i][0]); return function(date) { var i = 0, f = formats[i]; while (!f1) f = formats[++i]; return f0; }; } d3.locale = function(locale) { return { numberFormat: d3_locale_numberFormat(locale), timeFormat: d3_locale_timeFormat(locale) }; }; var d3_locale_enUS = d3.locale({ decimal: “.”, thousands: “,”, grouping: [ 3 ], currency: [ “$”, “” ], dateTime: “%a %b %e %X %Y”, date: “%m/%d/%Y”, time: “%H:%M:%S”, periods: [ “AM”, “PM” ], days: [ “Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” ], shortDays: [ “Sun”, “Mon”, “Tue”, “Wed”, “Thu”, “Fri”, “Sat” ], months: [ “January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December” ], shortMonths: [ “Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec” ] }); d3.format = d3_locale_enUS.numberFormat; d3.geo = {}; function d3_adder() {} d3_adder.prototype = { s: 0, t: 0, add: function(y) { d3_adderSum(y, this.t, d3_adderTemp); d3_adderSum(d3_adderTemp.s, this.s, this); if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t; }, reset: function() { this.s = this.t = 0; }, valueOf: function() { return this.s; } }; var d3_adderTemp = new d3_adder(); function d3_adderSum(a, b, o) { var x = o.s = a + b, bv = x - a, av = x - bv; o.t = a - av + (b - bv); } d3.geo.stream = function(object, listener) { if (object &amp;&amp; d3_geo_streamObjectType.hasOwnProperty(object.type)) { d3_geo_streamObjectTypeobject.type; } else { d3_geo_streamGeometry(object, listener); } }; function d3_geo_streamGeometry(geometry, listener) { if (geometry &amp;&amp; d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) { d3_geo_streamGeometryTypegeometry.type; } } var d3_geo_streamObjectType = { Feature: function(feature, listener) { d3_geo_streamGeometry(feature.geometry, listener); }, FeatureCollection: function(object, listener) { var features = object.features, i = -1, n = features.length; while (++i &lt; n) d3_geo_streamGeometry(features[i].geometry, listener); } }; var d3_geo_streamGeometryType = { Sphere: function(object, listener) { listener.sphere(); }, Point: function(object, listener) { object = object.coordinates; listener.point(object[0], object[1], object[2]); }, MultiPoint: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) object = coordinates[i], listener.point(object[0], object[1], object[2]); }, LineString: function(object, listener) { d3_geo_streamLine(object.coordinates, listener, 0); }, MultiLineString: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) d3_geo_streamLine(coordinates[i], listener, 0); }, Polygon: function(object, listener) { d3_geo_streamPolygon(object.coordinates, listener); }, MultiPolygon: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) d3_geo_streamPolygon(coordinates[i], listener); }, GeometryCollection: function(object, listener) { var geometries = object.geometries, i = -1, n = geometries.length; while (++i &lt; n) d3_geo_streamGeometry(geometries[i], listener); } }; function d3_geo_streamLine(coordinates, listener, closed) { var i = -1, n = coordinates.length - closed, coordinate; listener.lineStart(); while (++i &lt; n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]); listener.lineEnd(); } function d3_geo_streamPolygon(coordinates, listener) { var i = -1, n = coordinates.length; listener.polygonStart(); while (++i &lt; n) d3_geo_streamLine(coordinates[i], listener, 1); listener.polygonEnd(); } d3.geo.area = function(object) { d3_geo_areaSum = 0; d3.geo.stream(object, d3_geo_area); return d3_geo_areaSum; }; var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder(); var d3_geo_area = { sphere: function() { d3_geo_areaSum += 4 π; }, point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_areaRingSum.reset(); d3_geo_area.lineStart = d3_geo_areaRingStart; }, polygonEnd: function() { var area = 2 d3_geo_areaRingSum; d3_geo_areaSum += area &lt; 0 ? 4 π + area : area; d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop; } }; function d3_geo_areaRingStart() { var λ00, φ00, λ0, cosφ0, sinφ0; d3_geo_area.point = function(λ, φ) { d3_geo_area.point = nextPoint; λ0 = (λ00 = λ) d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ); }; function nextPoint(λ, φ) { λ = d3_radians; φ = φ d3_radians / 2 + π / 4; var dλ = λ - λ0, sdλ = dλ &gt;= 0 ? 1 : -1, adλ = sdλ dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 sinφ, u = cosφ0 cosφ + k Math.cos(adλ), v = k sdλ Math.sin(adλ); d3_geo_areaRingSum.add(Math.atan2(v, u)); λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ; } d3_geo_area.lineEnd = function() { nextPoint(λ00, φ00); }; } function d3_geo_cartesian(spherical) { var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ); return [ cosφ Math.cos(λ), cosφ Math.sin(λ), Math.sin(φ) ]; } function d3_geo_cartesianDot(a, b) { return a[0] b[0] + a[1] b[1] + a[2] b[2]; } function d3_geo_cartesianCross(a, b) { return [ a[1] b[2] - a[2] b[1], a[2] b[0] - a[0] b[2], a[0] b[1] - a[1] b[0] ]; } function d3_geo_cartesianAdd(a, b) { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; } function d3_geo_cartesianScale(vector, k) { return [ vector[0] k, vector[1] k, vector[2] k ]; } function d3_geo_cartesianNormalize(d) { var l = Math.sqrt(d[0] d[0] + d[1] d[1] + d[2] d[2]); d[0] /= l; d[1] /= l; d[2] /= l; } function d3_geo_spherical(cartesian) { return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ]; } function d3_geo_sphericalEqual(a, b) { return abs(a[0] - b[0]) &lt; ε &amp;&amp; abs(a[1] - b[1]) &lt; ε; } d3.geo.bounds = function() { var λ0, φ0, λ1, φ1, λ_, λ, φ, p0, dλSum, ranges, range; var bound = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { bound.point = ringPoint; bound.lineStart = ringStart; bound.lineEnd = ringEnd; dλSum = 0; d3_geo_area.polygonStart(); }, polygonEnd: function() { d3_geo_area.polygonEnd(); bound.point = point; bound.lineStart = lineStart; bound.lineEnd = lineEnd; if (d3_geo_areaRingSum &lt; 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum &gt; ε) φ1 = 90; else if (dλSum &lt; -ε) φ0 = -90; range[0] = λ0, range[1] = λ1; } }; function point(λ, φ) { ranges.push(range = [ λ0 = λ, λ1 = λ ]); if (φ &lt; φ0) φ0 = φ; if (φ &gt; φ1) φ1 = φ; } function linePoint(λ, φ) { var p = d3_geo_cartesian([ λ d3_radians, φ d3_radians ]); if (p0) { var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal); d3_geo_cartesianNormalize(inflection); inflection = d3_geo_spherical(inflection); var dλ = λ - λ_, s = dλ &gt; 0 ? 1 : -1, λi = inflection[0] d3_degrees s, antimeridian = abs(dλ) &gt; 180; if (antimeridian ^ (s λ_ &lt; λi &amp;&amp; λi &lt; s λ)) { var φi = inflection[1] d3_degrees; if (φi &gt; φ1) φ1 = φi; } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s λ_ &lt; λi &amp;&amp; λi &lt; s λ)) { var φi = -inflection[1] d3_degrees; if (φi &lt; φ0) φ0 = φi; } else { if (φ &lt; φ0) φ0 = φ; if (φ &gt; φ1) φ1 = φ; } if (antimeridian) { if (λ &lt; λ) { if (angle(λ0, λ) &gt; angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) &gt; angle(λ0, λ1)) λ0 = λ; } } else { if (λ1 &gt;= λ0) { if (λ &lt; λ0) λ0 = λ; if (λ &gt; λ1) λ1 = λ; } else { if (λ &gt; λ) { if (angle(λ0, λ) &gt; angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) &gt; angle(λ0, λ1)) λ0 = λ; } } } } else { point(λ, φ); } p0 = p, λ_ = λ; } function lineStart() { bound.point = linePoint; } function lineEnd() { range[0] = λ0, range[1] = λ1; bound.point = point; p0 = null; } function ringPoint(λ, φ) { if (p0) { var dλ = λ - λ_; dλSum += abs(dλ) &gt; 180 ? dλ + (dλ &gt; 0 ? 360 : -360) : dλ; } else λ = λ, φ = φ; d3_geo_area.point(λ, φ); linePoint(λ, φ); } function ringStart() { d3_geo_area.lineStart(); } function ringEnd() { ringPoint(λ, φ); d3_geo_area.lineEnd(); if (abs(dλSum) &gt; ε) λ0 = -(λ1 = 180); range[0] = λ0, range[1] = λ1; p0 = null; } function angle(λ0, λ1) { return (λ1 -= λ0) &lt; 0 ? λ1 + 360 : λ1; } function compareRanges(a, b) { return a[0] - b[0]; } function withinRange(x, range) { return range[0] &lt;= range[1] ? range[0] &lt;= x &amp;&amp; x &lt;= range[1] : x &lt; range[0] || range[1] &lt; x; } return function(feature) { φ1 = λ1 = -(λ0 = φ0 = Infinity); ranges = []; d3.geo.stream(feature, bound); var n = ranges.length; if (n) { ranges.sort(compareRanges); for (var i = 1, a = ranges[0], b, merged = [ a ]; i &lt; n; ++i) { b = ranges[i]; if (withinRange(b[0], a) || withinRange(b[1], a)) { if (angle(a[0], b[1]) &gt; angle(a[0], a[1])) a[1] = b[1]; if (angle(b[0], a[1]) &gt; angle(a[0], a[1])) a[0] = b[0]; } else { merged.push(a = b); } } var best = -Infinity, dλ; for (var n = merged.length - 1, i = 0, a = merged[n], b; i &lt;= n; a = b, ++i) { b = merged[i]; if ((dλ = angle(a[1], b[0])) &gt; best) best = dλ, λ0 = b[0], λ1 = a[1]; } } ranges = range = null; return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ]; }; }(); d3.geo.centroid = function(object) { d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0; d3.geo.stream(object, d3_geo_centroid); var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x x + y y + z z; if (m &lt; ε2) { x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1; if (d3_geo_centroidW1 &lt; ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0; m = x x + y y + z z; if (m &lt; ε2) return [ NaN, NaN ]; } return [ Math.atan2(y, x) d3_degrees, d3_asin(z / Math.sqrt(m)) d3_degrees ]; }; var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2; var d3_geo_centroid = { sphere: d3_noop, point: d3_geo_centroidPoint, lineStart: d3_geo_centroidLineStart, lineEnd: d3_geo_centroidLineEnd, polygonStart: function() { d3_geo_centroid.lineStart = d3_geo_centroidRingStart; }, polygonEnd: function() { d3_geo_centroid.lineStart = d3_geo_centroidLineStart; } }; function d3_geo_centroidPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); d3_geo_centroidPointXYZ(cosφ Math.cos(λ), cosφ Math.sin(λ), Math.sin(φ)); } function d3_geo_centroidPointXYZ(x, y, z) { ++d3_geo_centroidW0; d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0; d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0; d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0; } function d3_geo_centroidLineStart() { var x0, y0, z0; d3_geo_centroid.point = function(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); x0 = cosφ Math.cos(λ); y0 = cosφ Math.sin(λ); z0 = Math.sin(φ); d3_geo_centroid.point = nextPoint; d3_geo_centroidPointXYZ(x0, y0, z0); }; function nextPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians), x = cosφ Math.cos(λ), y = cosφ Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 z - z0 y) w + (w = z0 x - x0 z) w + (w = x0 y - y0 x) w), x0 x + y0 y + z0 z); d3_geo_centroidW1 += w; d3_geo_centroidX1 += w (x0 + (x0 = x)); d3_geo_centroidY1 += w (y0 + (y0 = y)); d3_geo_centroidZ1 += w (z0 + (z0 = z)); d3_geo_centroidPointXYZ(x0, y0, z0); } } function d3_geo_centroidLineEnd() { d3_geo_centroid.point = d3_geo_centroidPoint; } function d3_geo_centroidRingStart() { var λ00, φ00, x0, y0, z0; d3_geo_centroid.point = function(λ, φ) { λ00 = λ, φ00 = φ; d3_geo_centroid.point = nextPoint; λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); x0 = cosφ Math.cos(λ); y0 = cosφ Math.sin(λ); z0 = Math.sin(φ); d3_geo_centroidPointXYZ(x0, y0, z0); }; d3_geo_centroid.lineEnd = function() { nextPoint(λ00, φ00); d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd; d3_geo_centroid.point = d3_geo_centroidPoint; }; function nextPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians), x = cosφ Math.cos(λ), y = cosφ Math.sin(λ), z = Math.sin(φ), cx = y0 z - z0 y, cy = z0 x - x0 z, cz = x0 y - y0 x, m = Math.sqrt(cx cx + cy cy + cz cz), u = x0 x + y0 y + z0 z, v = m &amp;&amp; -d3_acos(u) / m, w = Math.atan2(m, u); d3_geo_centroidX2 += v cx; d3_geo_centroidY2 += v cy; d3_geo_centroidZ2 += v cz; d3_geo_centroidW1 += w; d3_geo_centroidX1 += w (x0 + (x0 = x)); d3_geo_centroidY1 += w (y0 + (y0 = y)); d3_geo_centroidZ1 += w (z0 + (z0 = z)); d3_geo_centroidPointXYZ(x0, y0, z0); } } function d3_geo_compose(a, b) { function compose(x, y) { return x = a(x, y), b(x[0], x[1]); } if (a.invert &amp;&amp; b.invert) compose.invert = function(x, y) { return x = b.invert(x, y), x &amp;&amp; a.invert(x[0], x[1]); }; return compose; } function d3_true() { return true; } function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) { var subject = [], clip = []; segments.forEach(function(segment) { if ((n = segment.length - 1) &lt;= 0) return; var n, p0 = segment[0], p1 = segment[n]; if (d3_geo_sphericalEqual(p0, p1)) { listener.lineStart(); for (var i = 0; i &lt; n; ++i) listener.point((p0 = segment[i])[0], p0[1]); listener.lineEnd(); return; } var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false); a.o = b; subject.push(a); clip.push(b); a = new d3_geo_clipPolygonIntersection(p1, segment, null, false); b = new d3_geo_clipPolygonIntersection(p1, null, a, true); a.o = b; subject.push(a); clip.push(b); }); clip.sort(compare); d3_geo_clipPolygonLinkCircular(subject); d3_geo_clipPolygonLinkCircular(clip); if (!subject.length) return; for (var i = 0, entry = clipStartInside, n = clip.length; i &lt; n; ++i) { clip[i].e = entry = !entry; } var start = subject[0], points, point; while (1) { var current = start, isSubject = true; while (current.v) if ((current = current.n) === start) return; points = current.z; listener.lineStart(); do { current.v = current.o.v = true; if (current.e) { if (isSubject) { for (var i = 0, n = points.length; i &lt; n; ++i) listener.point((point = points[i])[0], point[1]); } else { interpolate(current.x, current.n.x, 1, listener); } current = current.n; } else { if (isSubject) { points = current.p.z; for (var i = points.length - 1; i &gt;= 0; –i) listener.point((point = points[i])[0], point[1]); } else { interpolate(current.x, current.p.x, -1, listener); } current = current.p; } current = current.o; points = current.z; isSubject = !isSubject; } while (!current.v); listener.lineEnd(); } } function d3_geo_clipPolygonLinkCircular(array) { if (!(n = array.length)) return; var n, i = 0, a = array[0], b; while (++i &lt; n) { a.n = b = array[i]; b.p = a; a = b; } a.n = b = array[0]; b.p = a; } function d3_geo_clipPolygonIntersection(point, points, other, entry) { this.x = point; this.z = points; this.o = other; this.e = entry; this.v = false; this.n = this.p = null; } function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) { return function(rotate, listener) { var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]); var clip = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { clip.point = pointRing; clip.lineStart = ringStart; clip.lineEnd = ringEnd; segments = []; polygon = []; }, polygonEnd: function() { clip.point = point; clip.lineStart = lineStart; clip.lineEnd = lineEnd; segments = d3.merge(segments); var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon); if (segments.length) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener); } else if (clipStartInside) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); } if (polygonStarted) listener.polygonEnd(), polygonStarted = false; segments = polygon = null; }, sphere: function() { listener.polygonStart(); listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); listener.polygonEnd(); } }; function point(λ, φ) { var point = rotate(λ, φ); if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ); } function pointLine(λ, φ) { var point = rotate(λ, φ); line.point(point[0], point[1]); } function lineStart() { clip.point = pointLine; line.lineStart(); } function lineEnd() { clip.point = point; line.lineEnd(); } var segments; var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring; function pointRing(λ, φ) { ring.push([ λ, φ ]); var point = rotate(λ, φ); ringListener.point(point[0], point[1]); } function ringStart() { ringListener.lineStart(); ring = []; } function ringEnd() { pointRing(ring[0][0], ring[0][1]); ringListener.lineEnd(); var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length; ring.pop(); polygon.push(ring); ring = null; if (!n) return; if (clean &amp; 1) { segment = ringSegments[0]; var n = segment.length - 1, i = -1, point; if (n &gt; 0) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; listener.lineStart(); while (++i &lt; n) listener.point((point = segment[i])[0], point[1]); listener.lineEnd(); } return; } if (n &gt; 1 &amp;&amp; clean &amp; 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift())); segments.push(ringSegments.filter(d3_geo_clipSegmentLength1)); } return clip; }; } function d3_geo_clipSegmentLength1(segment) { return segment.length &gt; 1; } function d3_geo_clipBufferListener() { var lines = [], line; return { lineStart: function() { lines.push(line = []); }, point: function(λ, φ) { line.push([ λ, φ ]); }, lineEnd: d3_noop, buffer: function() { var buffer = lines; lines = []; line = null; return buffer; }, rejoin: function() { if (lines.length &gt; 1) lines.push(lines.pop().concat(lines.shift())); } }; } function d3_geo_clipSort(a, b) { return ((a = a.x)[0] &lt; 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] &lt; 0 ? b[1] - halfπ - ε : halfπ - b[1]); } var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]); function d3_geo_clipAntimeridianLine(listener) { var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean; return { lineStart: function() { listener.lineStart(); clean = 1; }, point: function(λ1, φ1) { var sλ1 = λ1 &gt; 0 ? π : -π, dλ = abs(λ1 - λ0); if (abs(dλ - π) &lt; ε) { listener.point(λ0, φ0 = (φ0 + φ1) / 2 &gt; 0 ? halfπ : -halfπ); listener.point(sλ0, φ0); listener.lineEnd(); listener.lineStart(); listener.point(sλ1, φ0); listener.point(λ1, φ0); clean = 0; } else if (sλ0 !== sλ1 &amp;&amp; dλ &gt;= π) { if (abs(λ0 - sλ0) &lt; ε) λ0 -= sλ0 ε; if (abs(λ1 - sλ1) &lt; ε) λ1 -= sλ1 ε; φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1); listener.point(sλ0, φ0); listener.lineEnd(); listener.lineStart(); listener.point(sλ1, φ0); clean = 0; } listener.point(λ0 = λ1, φ0 = φ1); sλ0 = sλ1; }, lineEnd: function() { listener.lineEnd(); λ0 = φ0 = NaN; }, clean: function() { return 2 - clean; } }; } function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) { var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1); return abs(sinλ0_λ1) &gt; ε ? Math.atan((Math.sin(φ0) (cosφ1 = Math.cos(φ1)) Math.sin(λ1) - Math.sin(φ1) (cosφ0 = Math.cos(φ0)) Math.sin(λ0)) / (cosφ0 cosφ1 sinλ0_λ1)) : (φ0 + φ1) / 2; } function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) { var φ; if (from == null) { φ = direction halfπ; listener.point(-π, φ); listener.point(0, φ); listener.point(π, φ); listener.point(π, 0); listener.point(π, -φ); listener.point(0, -φ); listener.point(-π, -φ); listener.point(-π, 0); listener.point(-π, φ); } else if (abs(from[0] - to[0]) &gt; ε) { var s = from[0] &lt; to[0] ? π : -π; φ = direction s / 2; listener.point(-s, φ); listener.point(0, φ); listener.point(s, φ); } else { listener.point(to[0], to[1]); } } function d3_geo_pointInPolygon(point, polygon) { var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0; d3_geo_areaRingSum.reset(); for (var i = 0, n = polygon.length; i &lt; n; ++i) { var ring = polygon[i], m = ring.length; if (!m) continue; var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1; while (true) { if (j === m) j = 0; point = ring[j]; var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ &gt;= 0 ? 1 : -1, adλ = sdλ dλ, antimeridian = adλ &gt; π, k = sinφ0 sinφ; d3_geo_areaRingSum.add(Math.atan2(k sdλ Math.sin(adλ), cosφ0 cosφ + k Math.cos(adλ))); polarAngle += antimeridian ? dλ + sdλ τ : dλ; if (antimeridian ^ λ0 &gt;= meridian ^ λ &gt;= meridian) { var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point)); d3_geo_cartesianNormalize(arc); var intersection = d3_geo_cartesianCross(meridianNormal, arc); d3_geo_cartesianNormalize(intersection); var φarc = (antimeridian ^ dλ &gt;= 0 ? -1 : 1) d3_asin(intersection[2]); if (parallel &gt; φarc || parallel === φarc &amp;&amp; (arc[0] || arc[1])) { winding += antimeridian ^ dλ &gt;= 0 ? 1 : -1; } } if (!j++) break; λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point; } } return (polarAngle &lt; -ε || polarAngle &lt; ε &amp;&amp; d3_geo_areaRingSum &lt; -ε) ^ winding &amp; 1; } function d3_geo_clipCircle(radius) { var cr = Math.cos(radius), smallRadius = cr &gt; 0, notHemisphere = abs(cr) &gt; ε, interpolate = d3_geo_circleInterpolate(radius, 6 d3_radians); return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]); function visible(λ, φ) { return Math.cos(λ) Math.cos(φ) &gt; cr; } function clipLine(listener) { var point0, c0, v0, v00, clean; return { lineStart: function() { v00 = v0 = false; clean = 1; }, point: function(λ, φ) { var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ &lt; 0 ? π : -π), φ) : 0; if (!point0 &amp;&amp; (v00 = v0 = v)) listener.lineStart(); if (v !== v0) { point2 = intersect(point0, point1); if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) { point1[0] += ε; point1[1] += ε; v = visible(point1[0], point1[1]); } } if (v !== v0) { clean = 0; if (v) { listener.lineStart(); point2 = intersect(point1, point0); listener.point(point2[0], point2[1]); } else { point2 = intersect(point0, point1); listener.point(point2[0], point2[1]); listener.lineEnd(); } point0 = point2; } else if (notHemisphere &amp;&amp; point0 &amp;&amp; smallRadius ^ v) { var t; if (!(c &amp; c0) &amp;&amp; (t = intersect(point1, point0, true))) { clean = 0; if (smallRadius) { listener.lineStart(); listener.point(t[0][0], t[0][1]); listener.point(t[1][0], t[1][1]); listener.lineEnd(); } else { listener.point(t[1][0], t[1][1]); listener.lineEnd(); listener.lineStart(); listener.point(t[0][0], t[0][1]); } } } if (v &amp;&amp; (!point0 || !d3_geo_sphericalEqual(point0, point1))) { listener.point(point1[0], point1[1]); } point0 = point1, v0 = v, c0 = c; }, lineEnd: function() { if (v0) listener.lineEnd(); point0 = null; }, clean: function() { return clean | (v00 &amp;&amp; v0) &lt;&lt; 1; } }; } function intersect(a, b, two) { var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b); var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 n1n2; if (!determinant) return !two &amp;&amp; a; var c1 = cr n2n2 / determinant, c2 = -cr n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2); d3_geo_cartesianAdd(A, B); var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w w - uu (d3_geo_cartesianDot(A, A) - 1); if (t2 &lt; 0) return; var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu); d3_geo_cartesianAdd(q, A); q = d3_geo_spherical(q); if (!two) return q; var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z; if (λ1 &lt; λ0) z = λ0, λ0 = λ1, λ1 = z; var δλ = λ1 - λ0, polar = abs(δλ - π) &lt; ε, meridian = polar || δλ &lt; ε; if (!polar &amp;&amp; φ1 &lt; φ0) z = φ0, φ0 = φ1, φ1 = z; if (meridian ? polar ? φ0 + φ1 &gt; 0 ^ q[1] &lt; (abs(q[0] - λ0) &lt; ε ? φ0 : φ1) : φ0 &lt;= q[1] &amp;&amp; q[1] &lt;= φ1 : δλ &gt; π ^ (λ0 &lt;= q[0] &amp;&amp; q[0] &lt;= λ1)) { var q1 = d3_geo_cartesianScale(u, (-w + t) / uu); d3_geo_cartesianAdd(q1, A); return [ q, d3_geo_spherical(q1) ]; } } function code(λ, φ) { var r = smallRadius ? radius : π - radius, code = 0; if (λ &lt; -r) code |= 1; else if (λ &gt; r) code |= 2; if (φ &lt; -r) code |= 4; else if (φ &gt; r) code |= 8; return code; } } function d3_geom_clipLine(x0, y0, x1, y1) { return function(line) { var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r; r = x0 - ax; if (!dx &amp;&amp; r &gt; 0) return; r /= dx; if (dx &lt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } else if (dx &gt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } r = x1 - ax; if (!dx &amp;&amp; r &lt; 0) return; r /= dx; if (dx &lt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } else if (dx &gt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } r = y0 - ay; if (!dy &amp;&amp; r &gt; 0) return; r /= dy; if (dy &lt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } else if (dy &gt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } r = y1 - ay; if (!dy &amp;&amp; r &lt; 0) return; r /= dy; if (dy &lt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } else if (dy &gt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } if (t0 &gt; 0) line.a = { x: ax + t0 dx, y: ay + t0 dy }; if (t1 &lt; 1) line.b = { x: ax + t1 dx, y: ay + t1 dy }; return line; }; } var d3_geo_clipExtentMAX = 1e9; d3.geo.clipExtent = function() { var x0, y0, x1, y1, stream, clip, clipExtent = { stream: function(output) { if (stream) stream.valid = false; stream = clip(output); stream.valid = true; return stream; }, extent: function(_) { if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ]; clip = d3_geo_clipExtent(x0 = +[0][0], y0 = +[0][1], x1 = +[1][0], y1 = +[1][1]); if (stream) stream.valid = false, stream = null; return clipExtent; } }; return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]); }; function d3_geo_clipExtent(x0, y0, x1, y1) { return function(listener) { var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring; var clip = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { listener = bufferListener; segments = []; polygon = []; clean = true; }, polygonEnd: function() { listener = listener_; segments = d3.merge(segments); var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean &amp;&amp; clipStartInside, visible = segments.length; if (inside || visible) { listener.polygonStart(); if (inside) { listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); } if (visible) { d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener); } listener.polygonEnd(); } segments = polygon = ring = null; } }; function insidePolygon(p) { var wn = 0, n = polygon.length, y = p[1]; for (var i = 0; i &lt; n; ++i) { for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j &lt; m; ++j) { b = v[j]; if (a[1] &lt;= y) { if (b[1] &gt; y &amp;&amp; d3_cross2d(a, b, p) &gt; 0) ++wn; } else { if (b[1] &lt;= y &amp;&amp; d3_cross2d(a, b, p) &lt; 0) –wn; } a = b; } } return wn !== 0; } function interpolate(from, to, direction, listener) { var a = 0, a1 = 0; if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) &lt; 0 ^ direction &gt; 0) { do { listener.point(a === 0 || a === 3 ? x0 : x1, a &gt; 1 ? y1 : y0); } while ((a = (a + direction + 4) % 4) !== a1); } else { listener.point(to[0], to[1]); } } function pointVisible(x, y) { return x0 &lt;= x &amp;&amp; x &lt;= x1 &amp;&amp; y0 &lt;= y &amp;&amp; y &lt;= y1; } function point(x, y) { if (pointVisible(x, y)) listener.point(x, y); } var x__, y__, v__, x_, y_, v_, first, clean; function lineStart() { clip.point = linePoint; if (polygon) polygon.push(ring = []); first = true; v_ = false; x_ = y_ = NaN; } function lineEnd() { if (segments) { linePoint(x__, y__); if (v__ &amp;&amp; v_) bufferListener.rejoin(); segments.push(bufferListener.buffer()); } clip.point = point; if (v_) listener.lineEnd(); } function linePoint(x, y) { x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x)); y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y)); var v = pointVisible(x, y); if (polygon) ring.push([ x, y ]); if (first) { x__ = x, y__ = y, v__ = v; first = false; if (v) { listener.lineStart(); listener.point(x, y); } } else { if (v &amp;&amp; v_) listener.point(x, y); else { var l = { a: { x: x_, y: y_ }, b: { x: x, y: y } }; if (clipLine(l)) { if (!v_) { listener.lineStart(); listener.point(l.a.x, l.a.y); } listener.point(l.b.x, l.b.y); if (!v) listener.lineEnd(); clean = false; } else if (v) { listener.lineStart(); listener.point(x, y); clean = false; } } } x_ = x, y_ = y, v_ = v; } return clip; }; function corner(p, direction) { return abs(p[0] - x0) &lt; ε ? direction &gt; 0 ? 0 : 3 : abs(p[0] - x1) &lt; ε ? direction &gt; 0 ? 2 : 1 : abs(p[1] - y0) &lt; ε ? direction &gt; 0 ? 1 : 0 : direction &gt; 0 ? 3 : 2; } function compare(a, b) { return comparePoints(a.x, b.x); } function comparePoints(a, b) { var ca = corner(a, 1), cb = corner(b, 1); return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0]; } } function d3_geo_conic(projectAt) { var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1); p.parallels = function(_) { if (!arguments.length) return [ φ0 / π 180, φ1 / π 180 ]; return m(φ0 = _[0] π / 180, φ1 = _[1] π / 180); }; return p; } function d3_geo_conicEqualArea(φ0, φ1) { var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 (2 n - sinφ0), ρ0 = Math.sqrt(C) / n; function forward(λ, φ) { var ρ = Math.sqrt(C - 2 n Math.sin(φ)) / n; return [ ρ Math.sin(λ = n), ρ0 - ρ Math.cos(λ) ]; } forward.invert = function(x, y) { var ρ0_y = ρ0 - y; return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x x + ρ0_y ρ0_y) n n) / (2 n)) ]; }; return forward; } (d3.geo.conicEqualArea = function() { return d3_geo_conic(d3_geo_conicEqualArea); }).raw = d3_geo_conicEqualArea; d3.geo.albers = function() { return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070); }; d3.geo.albersUsa = function() { var lower48 = d3.geo.albers(); var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]); var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]); var point, pointStream = { point: function(x, y) { point = [ x, y ]; } }, lower48Point, alaskaPoint, hawaiiPoint; function albersUsa(coordinates) { var x = coordinates[0], y = coordinates[1]; point = null; (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y); return point; } albersUsa.invert = function(coordinates) { var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k; return (y &gt;= .12 &amp;&amp; y &lt; .234 &amp;&amp; x &gt;= -.425 &amp;&amp; x &lt; -.214 ? alaska : y &gt;= .166 &amp;&amp; y &lt; .234 &amp;&amp; x &gt;= -.214 &amp;&amp; x &lt; -.115 ? hawaii : lower48).invert(coordinates); }; albersUsa.stream = function(stream) { var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream); return { point: function(x, y) { lower48Stream.point(x, y); alaskaStream.point(x, y); hawaiiStream.point(x, y); }, sphere: function() { lower48Stream.sphere(); alaskaStream.sphere(); hawaiiStream.sphere(); }, lineStart: function() { lower48Stream.lineStart(); alaskaStream.lineStart(); hawaiiStream.lineStart(); }, lineEnd: function() { lower48Stream.lineEnd(); alaskaStream.lineEnd(); hawaiiStream.lineEnd(); }, polygonStart: function() { lower48Stream.polygonStart(); alaskaStream.polygonStart(); hawaiiStream.polygonStart(); }, polygonEnd: function() { lower48Stream.polygonEnd(); alaskaStream.polygonEnd(); hawaiiStream.polygonEnd(); } }; }; albersUsa.precision = function() { if (!arguments.length) return lower48.precision(); lower48.precision(); alaska.precision(); hawaii.precision(); return albersUsa; }; albersUsa.scale = function() { if (!arguments.length) return lower48.scale(); lower48.scale(); alaska.scale(_ .35); hawaii.scale(); return albersUsa.translate(lower48.translate()); }; albersUsa.translate = function() { if (!arguments.length) return lower48.translate(); var k = lower48.scale(), x = +[0], y = +[1]; lower48Point = lower48.translate(_).clipExtent([ [ x - .455 k, y - .238 k ], [ x + .455 k, y + .238 k ] ]).stream(pointStream).point; alaskaPoint = alaska.translate([ x - .307 k, y + .201 k ]).clipExtent([ [ x - .425 k + ε, y + .12 k + ε ], [ x - .214 k - ε, y + .234 k - ε ] ]).stream(pointStream).point; hawaiiPoint = hawaii.translate([ x - .205 k, y + .212 k ]).clipExtent([ [ x - .214 k + ε, y + .166 k + ε ], [ x - .115 k - ε, y + .234 k - ε ] ]).stream(pointStream).point; return albersUsa; }; return albersUsa.scale(1070); }; var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = { point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_pathAreaPolygon = 0; d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart; }, polygonEnd: function() { d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop; d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2); } }; function d3_geo_pathAreaRingStart() { var x00, y00, x0, y0; d3_geo_pathArea.point = function(x, y) { d3_geo_pathArea.point = nextPoint; x00 = x0 = x, y00 = y0 = y; }; function nextPoint(x, y) { d3_geo_pathAreaPolygon += y0 x - x0 y; x0 = x, y0 = y; } d3_geo_pathArea.lineEnd = function() { nextPoint(x00, y00); }; } var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1; var d3_geo_pathBounds = { point: d3_geo_pathBoundsPoint, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop }; function d3_geo_pathBoundsPoint(x, y) { if (x &lt; d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x; if (x &gt; d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x; if (y &lt; d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y; if (y &gt; d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y; } function d3_geo_pathBuffer() { var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = []; var stream = { point: point, lineStart: function() { stream.point = pointLineStart; }, lineEnd: lineEnd, polygonStart: function() { stream.lineEnd = lineEndPolygon; }, polygonEnd: function() { stream.lineEnd = lineEnd; stream.point = point; }, pointRadius: function(_) { pointCircle = d3_geo_pathBufferCircle(_); return stream; }, result: function() { if (buffer.length) { var result = buffer.join(“”); buffer = []; return result; } } }; function point(x, y) { buffer.push(“M”, x, “,”, y, pointCircle); } function pointLineStart(x, y) { buffer.push(“M”, x, “,”, y); stream.point = pointLine; } function pointLine(x, y) { buffer.push(“L”, x, “,”, y); } function lineEnd() { stream.point = point; } function lineEndPolygon() { buffer.push(“Z”); } return stream; } function d3_geo_pathBufferCircle(radius) { return “m0,” + radius + “a” + radius + “,” + radius + “ 0 1,1 0,” + -2 radius + “a” + radius + “,” + radius + “ 0 1,1 0,” + 2 radius + “z”; } var d3_geo_pathCentroid = { point: d3_geo_pathCentroidPoint, lineStart: d3_geo_pathCentroidLineStart, lineEnd: d3_geo_pathCentroidLineEnd, polygonStart: function() { d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart; }, polygonEnd: function() { d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint; d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart; d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd; } }; function d3_geo_pathCentroidPoint(x, y) { d3_geo_centroidX0 += x; d3_geo_centroidY0 += y; ++d3_geo_centroidZ0; } function d3_geo_pathCentroidLineStart() { var x0, y0; d3_geo_pathCentroid.point = function(x, y) { d3_geo_pathCentroid.point = nextPoint; d3_geo_pathCentroidPoint(x0 = x, y0 = y); }; function nextPoint(x, y) { var dx = x - x0, dy = y - y0, z = Math.sqrt(dx dx + dy dy); d3_geo_centroidX1 += z (x0 + x) / 2; d3_geo_centroidY1 += z (y0 + y) / 2; d3_geo_centroidZ1 += z; d3_geo_pathCentroidPoint(x0 = x, y0 = y); } } function d3_geo_pathCentroidLineEnd() { d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint; } function d3_geo_pathCentroidRingStart() { var x00, y00, x0, y0; d3_geo_pathCentroid.point = function(x, y) { d3_geo_pathCentroid.point = nextPoint; d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y); }; function nextPoint(x, y) { var dx = x - x0, dy = y - y0, z = Math.sqrt(dx dx + dy dy); d3_geo_centroidX1 += z (x0 + x) / 2; d3_geo_centroidY1 += z (y0 + y) / 2; d3_geo_centroidZ1 += z; z = y0 x - x0 y; d3_geo_centroidX2 += z (x0 + x); d3_geo_centroidY2 += z (y0 + y); d3_geo_centroidZ2 += z 3; d3_geo_pathCentroidPoint(x0 = x, y0 = y); } d3_geo_pathCentroid.lineEnd = function() { nextPoint(x00, y00); }; } function d3_geo_pathContext(context) { var pointRadius = 4.5; var stream = { point: point, lineStart: function() { stream.point = pointLineStart; }, lineEnd: lineEnd, polygonStart: function() { stream.lineEnd = lineEndPolygon; }, polygonEnd: function() { stream.lineEnd = lineEnd; stream.point = point; }, pointRadius: function(_) { pointRadius = _; return stream; }, result: d3_noop }; function point(x, y) { context.moveTo(x + pointRadius, y); context.arc(x, y, pointRadius, 0, τ); } function pointLineStart(x, y) { context.moveTo(x, y); stream.point = pointLine; } function pointLine(x, y) { context.lineTo(x, y); } function lineEnd() { stream.point = point; } function lineEndPolygon() { context.closePath(); } return stream; } function d3_geo_resample(project) { var δ2 = .5, cosMinDistance = Math.cos(30 d3_radians), maxDepth = 16; function resample(stream) { return (maxDepth ? resampleRecursive : resampleNone)(stream); } function resampleNone(stream) { return d3_geo_transformPoint(stream, function(x, y) { x = project(x, y); stream.point(x[0], x[1]); }); } function resampleRecursive(stream) { var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0; var resample = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { stream.polygonStart(); resample.lineStart = ringStart; }, polygonEnd: function() { stream.polygonEnd(); resample.lineStart = lineStart; } }; function point(x, y) { x = project(x, y); stream.point(x[0], x[1]); } function lineStart() { x0 = NaN; resample.point = linePoint; stream.lineStart(); } function linePoint(λ, φ) { var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ); resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream); stream.point(x0, y0); } function lineEnd() { resample.point = point; stream.lineEnd(); } function ringStart() { lineStart(); resample.point = ringPoint; resample.lineEnd = ringEnd; } function ringPoint(λ, φ) { linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0; resample.point = linePoint; } function ringEnd() { resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream); resample.lineEnd = lineEnd; lineEnd(); } return resample; } function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) { var dx = x1 - x0, dy = y1 - y0, d2 = dx dx + dy dy; if (d2 &gt; 4 δ2 &amp;&amp; depth–) { var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a a + b b + c c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) &lt; ε || abs(λ0 - λ1) &lt; ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy dx2 - dx dy2; if (dz dz / d2 &gt; δ2 || abs((dx dx2 + dy dy2) / d2 - .5) &gt; .3 || a0 a1 + b0 b1 + c0 c1 &lt; cosMinDistance) { resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream); stream.point(x2, y2); resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream); } } } resample.precision = function(_) { if (!arguments.length) return Math.sqrt(δ2); maxDepth = (δ2 = _ _) &gt; 0 &amp;&amp; 16; return resample; }; return resample; } d3.geo.path = function() { var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream; function path(object) { if (object) { if (typeof pointRadius === “function”) contextStream.pointRadius(+pointRadius.apply(this, arguments)); if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream); d3.geo.stream(object, cacheStream); } return contextStream.result(); } path.area = function(object) { d3_geo_pathAreaSum = 0; d3.geo.stream(object, projectStream(d3_geo_pathArea)); return d3_geo_pathAreaSum; }; path.centroid = function(object) { d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0; d3.geo.stream(object, projectStream(d3_geo_pathCentroid)); return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ]; }; path.bounds = function(object) { d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity); d3.geo.stream(object, projectStream(d3_geo_pathBounds)); return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ]; }; path.projection = function(_) { if (!arguments.length) return projection; projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity; return reset(); }; path.context = function(_) { if (!arguments.length) return context; contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(); if (typeof pointRadius !== “function”) contextStream.pointRadius(pointRadius); return reset(); }; path.pointRadius = function() { if (!arguments.length) return pointRadius; pointRadius = typeof _ === “function” ? _ : (contextStream.pointRadius(+), +); return path; }; function reset() { cacheStream = null; return path; } return path.projection(d3.geo.albersUsa()).context(null); }; function d3_geo_pathProjectStream(project) { var resample = d3_geo_resample(function(x, y) { return project([ x d3_degrees, y d3_degrees ]); }); return function(stream) { return d3_geo_projectionRadians(resample(stream)); }; } d3.geo.transform = function(methods) { return { stream: function(stream) { var transform = new d3_geo_transform(stream); for (var k in methods) transform[k] = methods[k]; return transform; } }; }; function d3_geo_transform(stream) { this.stream = stream; } d3_geo_transform.prototype = { point: function(x, y) { this.stream.point(x, y); }, sphere: function() { this.stream.sphere(); }, lineStart: function() { this.stream.lineStart(); }, lineEnd: function() { this.stream.lineEnd(); }, polygonStart: function() { this.stream.polygonStart(); }, polygonEnd: function() { this.stream.polygonEnd(); } }; function d3_geo_transformPoint(stream, point) { return { point: point, sphere: function() { stream.sphere(); }, lineStart: function() { stream.lineStart(); }, lineEnd: function() { stream.lineEnd(); }, polygonStart: function() { stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); } }; } d3.geo.projection = d3_geo_projection; d3.geo.projectionMutator = d3_geo_projectionMutator; function d3_geo_projection(project) { return d3_geo_projectionMutator(function() { return project; })(); } function d3_geo_projectionMutator(projectAt) { var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) { x = project(x, y); return [ x[0] k + δx, δy - x[1] k ]; }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream; function projection(point) { point = projectRotate(point[0] d3_radians, point[1] d3_radians); return [ point[0] k + δx, δy - point[1] k ]; } function invert(point) { point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k); return point &amp;&amp; [ point[0] d3_degrees, point[1] d3_degrees ]; } projection.stream = function(output) { if (stream) stream.valid = false; stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output)))); stream.valid = true; return stream; }; projection.clipAngle = function(_) { if (!arguments.length) return clipAngle; preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) d3_radians); return invalidate(); }; projection.clipExtent = function(_) { if (!arguments.length) return clipExtent; clipExtent = _; postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity; return invalidate(); }; projection.scale = function() { if (!arguments.length) return k; k = +; return reset(); }; projection.translate = function() { if (!arguments.length) return [ x, y ]; x = +[0]; y = +[1]; return reset(); }; projection.center = function() { if (!arguments.length) return [ λ d3_degrees, φ d3_degrees ]; λ = _[0] % 360 d3_radians; φ = _[1] % 360 d3_radians; return reset(); }; projection.rotate = function(_) { if (!arguments.length) return [ δλ d3_degrees, δφ d3_degrees, δγ d3_degrees ]; δλ = _[0] % 360 d3_radians; δφ = _[1] % 360 d3_radians; δγ = _.length &gt; 2 ? _[2] % 360 d3_radians : 0; return reset(); }; d3.rebind(projection, projectResample, “precision”); function reset() { projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project); var center = project(λ, φ); δx = x - center[0] k; δy = y + center[1] k; return invalidate(); } function invalidate() { if (stream) stream.valid = false, stream = null; return projection; } return function() { project = projectAt.apply(this, arguments); projection.invert = project.invert &amp;&amp; invert; return reset(); }; } function d3_geo_projectionRadians(stream) { return d3_geo_transformPoint(stream, function(x, y) { stream.point(x d3_radians, y d3_radians); }); } function d3_geo_equirectangular(λ, φ) { return [ λ, φ ]; } (d3.geo.equirectangular = function() { return d3_geo_projection(d3_geo_equirectangular); }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular; d3.geo.rotation = function(rotate) { rotate = d3_geo_rotation(rotate[0] % 360 d3_radians, rotate[1] d3_radians, rotate.length &gt; 2 ? rotate[2] d3_radians : 0); function forward(coordinates) { coordinates = rotate(coordinates[0] d3_radians, coordinates[1] d3_radians); return coordinates[0] = d3_degrees, coordinates[1] = d3_degrees, coordinates; } forward.invert = function(coordinates) { coordinates = rotate.invert(coordinates[0] d3_radians, coordinates[1] d3_radians); return coordinates[0] = d3_degrees, coordinates[1] = d3_degrees, coordinates; }; return forward; }; function d3_geo_identityRotation(λ, φ) { return [ λ &gt; π ? λ - τ : λ &lt; -π ? λ + τ : λ, φ ]; } d3_geo_identityRotation.invert = d3_geo_equirectangular; function d3_geo_rotation(δλ, δφ, δγ) { return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation; } function d3_geo_forwardRotationλ(δλ) { return function(λ, φ) { return λ += δλ, [ λ &gt; π ? λ - τ : λ &lt; -π ? λ + τ : λ, φ ]; }; } function d3_geo_rotationλ(δλ) { var rotation = d3_geo_forwardRotationλ(δλ); rotation.invert = d3_geo_forwardRotationλ(-δλ); return rotation; } function d3_geo_rotationφγ(δφ, δγ) { var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ); function rotation(λ, φ) { var cosφ = Math.cos(φ), x = Math.cos(λ) cosφ, y = Math.sin(λ) cosφ, z = Math.sin(φ), k = z cosδφ + x sinδφ; return [ Math.atan2(y cosδγ - k sinδγ, x cosδφ - z sinδφ), d3_asin(k cosδγ + y sinδγ) ]; } rotation.invert = function(λ, φ) { var cosφ = Math.cos(φ), x = Math.cos(λ) cosφ, y = Math.sin(λ) cosφ, z = Math.sin(φ), k = z cosδγ - y sinδγ; return [ Math.atan2(y cosδγ + z sinδγ, x cosδφ + k sinδφ), d3_asin(k cosδφ - x sinδφ) ]; }; return rotation; } d3.geo.circle = function() { var origin = [ 0, 0 ], angle, precision = 6, interpolate; function circle() { var center = typeof origin === “function” ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] d3_radians, -center[1] d3_radians, 0).invert, ring = []; interpolate(null, null, 1, { point: function(x, y) { ring.push(x = rotate(x, y)); x[0] = d3_degrees, x[1] = d3_degrees; } }); return { type: “Polygon”, coordinates: [ ring ] }; } circle.origin = function(x) { if (!arguments.length) return origin; origin = x; return circle; }; circle.angle = function(x) { if (!arguments.length) return angle; interpolate = d3_geo_circleInterpolate((angle = +x) d3_radians, precision d3_radians); return circle; }; circle.precision = function(_) { if (!arguments.length) return precision; interpolate = d3_geo_circleInterpolate(angle d3_radians, (precision = +_) d3_radians); return circle; }; return circle.angle(90); }; function d3_geo_circleInterpolate(radius, precision) { var cr = Math.cos(radius), sr = Math.sin(radius); return function(from, to, direction, listener) { var step = direction precision; if (from != null) { from = d3_geo_circleAngle(cr, from); to = d3_geo_circleAngle(cr, to); if (direction &gt; 0 ? from &lt; to : from &gt; to) from += direction τ; } else { from = radius + direction τ; to = radius - .5 step; } for (var point, t = from; direction &gt; 0 ? t &gt; to : t &lt; to; t -= step) { listener.point((point = d3_geo_spherical([ cr, -sr Math.cos(t), -sr Math.sin(t) ]))[0], point[1]); } }; } function d3_geo_circleAngle(cr, point) { var a = d3_geo_cartesian(point); a[0] -= cr; d3_geo_cartesianNormalize(a); var angle = d3_acos(-a[1]); return ((-a[2] &lt; 0 ? -angle : angle) + 2 Math.PI - ε) % (2 Math.PI); } d3.geo.distance = function(a, b) { var Δλ = (b[0] - a[0]) d3_radians, φ0 = a[1] d3_radians, φ1 = b[1] d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t; return Math.atan2(Math.sqrt((t = cosφ1 sinΔλ) t + (t = cosφ0 sinφ1 - sinφ0 cosφ1 cosΔλ) t), sinφ0 sinφ1 + cosφ0 cosφ1 cosΔλ); }; d3.geo.graticule = function() { var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5; function graticule() { return { type: “MultiLineString”, coordinates: lines() }; } function lines() { return d3.range(Math.ceil(X0 / DX) DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) dx, x1, dx).filter(function(x) { return abs(x % DX) &gt; ε; }).map(x)).concat(d3.range(Math.ceil(y0 / dy) dy, y1, dy).filter(function(y) { return abs(y % DY) &gt; ε; }).map(y)); } graticule.lines = function() { return lines().map(function(coordinates) { return { type: “LineString”, coordinates: coordinates }; }); }; graticule.outline = function() { return { type: “Polygon”, coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ] }; }; graticule.extent = function() { if (!arguments.length) return graticule.minorExtent(); return graticule.majorExtent().minorExtent(); }; graticule.majorExtent = function() { if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ]; X0 = +[0][0], X1 = +[1][0]; Y0 = +[0][1], Y1 = +[1][1]; if (X0 &gt; X1) _ = X0, X0 = X1, X1 = _; if (Y0 &gt; Y1) _ = Y0, Y0 = Y1, Y1 = ; return graticule.precision(precision); }; graticule.minorExtent = function() { if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ]; x0 = +[0][0], x1 = +[1][0]; y0 = +[0][1], y1 = +[1][1]; if (x0 &gt; x1) _ = x0, x0 = x1, x1 = _; if (y0 &gt; y1) _ = y0, y0 = y1, y1 = ; return graticule.precision(precision); }; graticule.step = function() { if (!arguments.length) return graticule.minorStep(); return graticule.majorStep().minorStep(); }; graticule.majorStep = function() { if (!arguments.length) return [ DX, DY ]; DX = +[0], DY = +[1]; return graticule; }; graticule.minorStep = function() { if (!arguments.length) return [ dx, dy ]; dx = +[0], dy = +[1]; return graticule; }; graticule.precision = function() { if (!arguments.length) return precision; precision = +; x = d3_geo_graticuleX(y0, y1, 90); y = d3_geo_graticuleY(x0, x1, precision); X = d3_geo_graticuleX(Y0, Y1, 90); Y = d3_geo_graticuleY(X0, X1, precision); return graticule; }; return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]); }; function d3_geo_graticuleX(y0, y1, dy) { var y = d3.range(y0, y1 - ε, dy).concat(y1); return function(x) { return y.map(function(y) { return [ x, y ]; }); }; } function d3_geo_graticuleY(x0, x1, dx) { var x = d3.range(x0, x1 - ε, dx).concat(x1); return function(y) { return x.map(function(x) { return [ x, y ]; }); }; } function d3_source(d) { return d.source; } function d3_target(d) { return d.target; } d3.geo.greatArc = function() { var source = d3_source, source_, target = d3_target, target_; function greatArc() { return { type: “LineString”, coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ] }; } greatArc.distance = function() { return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)); }; greatArc.source = function(_) { if (!arguments.length) return source; source = , source = typeof _ === “function” ? null : ; return greatArc; }; greatArc.target = function() { if (!arguments.length) return target; target = , target = typeof _ === “function” ? null : _; return greatArc; }; greatArc.precision = function() { return arguments.length ? greatArc : 0; }; return greatArc; }; d3.geo.interpolate = function(source, target) { return d3_geo_interpolate(source[0] d3_radians, source[1] d3_radians, target[0] d3_radians, target[1] d3_radians); }; function d3_geo_interpolate(x0, y0, x1, y1) { var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 Math.cos(x0), ky0 = cy0 Math.sin(x0), kx1 = cy1 Math.cos(x1), ky1 = cy1 Math.sin(x1), d = 2 Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 cy1 d3_haversin(x1 - x0))), k = 1 / Math.sin(d); var interpolate = d ? function(t) { var B = Math.sin(t = d) k, A = Math.sin(d - t) k, x = A kx0 + B kx1, y = A ky0 + B ky1, z = A sy0 + B sy1; return [ Math.atan2(y, x) d3_degrees, Math.atan2(z, Math.sqrt(x x + y y)) d3_degrees ]; } : function() { return [ x0 d3_degrees, y0 d3_degrees ]; }; interpolate.distance = d; return interpolate; } d3.geo.length = function(object) { d3_geo_lengthSum = 0; d3.geo.stream(object, d3_geo_length); return d3_geo_lengthSum; }; var d3_geo_lengthSum; var d3_geo_length = { sphere: d3_noop, point: d3_noop, lineStart: d3_geo_lengthLineStart, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop }; function d3_geo_lengthLineStart() { var λ0, sinφ0, cosφ0; d3_geo_length.point = function(λ, φ) { λ0 = λ d3_radians, sinφ0 = Math.sin(φ = d3_radians), cosφ0 = Math.cos(φ); d3_geo_length.point = nextPoint; }; d3_geo_length.lineEnd = function() { d3_geo_length.point = d3_geo_length.lineEnd = d3_noop; }; function nextPoint(λ, φ) { var sinφ = Math.sin(φ = d3_radians), cosφ = Math.cos(φ), t = abs((λ = d3_radians) - λ0), cosΔλ = Math.cos(t); d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ Math.sin(t)) t + (t = cosφ0 sinφ - sinφ0 cosφ cosΔλ) t), sinφ0 sinφ + cosφ0 cosφ cosΔλ); λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ; } } function d3_geo_azimuthal(scale, angle) { function azimuthal(λ, φ) { var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ cosφ); return [ k cosφ Math.sin(λ), k Math.sin(φ) ]; } azimuthal.invert = function(x, y) { var ρ = Math.sqrt(x x + y y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c); return [ Math.atan2(x sinc, ρ cosc), Math.asin(ρ &amp;&amp; y sinc / ρ) ]; }; return azimuthal; } var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) { return Math.sqrt(2 / (1 + cosλcosφ)); }, function(ρ) { return 2 Math.asin(ρ / 2); }); (d3.geo.azimuthalEqualArea = function() { return d3_geo_projection(d3_geo_azimuthalEqualArea); }).raw = d3_geo_azimuthalEqualArea; var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) { var c = Math.acos(cosλcosφ); return c &amp;&amp; c / Math.sin(c); }, d3_identity); (d3.geo.azimuthalEquidistant = function() { return d3_geo_projection(d3_geo_azimuthalEquidistant); }).raw = d3_geo_azimuthalEquidistant; function d3_geo_conicConformal(φ0, φ1) { var cosφ0 = Math.cos(φ0), t = function(φ) { return Math.tan(π / 4 + φ / 2); }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 Math.pow(t(φ0), n) / n; if (!n) return d3_geo_mercator; function forward(λ, φ) { if (F &gt; 0) { if (φ &lt; -halfπ + ε) φ = -halfπ + ε; } else { if (φ &gt; halfπ - ε) φ = halfπ - ε; } var ρ = F / Math.pow(t(φ), n); return [ ρ Math.sin(n λ), F - ρ Math.cos(n λ) ]; } forward.invert = function(x, y) { var ρ0_y = F - y, ρ = d3_sgn(n) Math.sqrt(x x + ρ0_y ρ0_y); return [ Math.atan2(x, ρ0_y) / n, 2 Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ]; }; return forward; } (d3.geo.conicConformal = function() { return d3_geo_conic(d3_geo_conicConformal); }).raw = d3_geo_conicConformal; function d3_geo_conicEquidistant(φ0, φ1) { var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0; if (abs(n) &lt; ε) return d3_geo_equirectangular; function forward(λ, φ) { var ρ = G - φ; return [ ρ Math.sin(n λ), G - ρ Math.cos(n λ) ]; } forward.invert = function(x, y) { var ρ0_y = G - y; return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) Math.sqrt(x x + ρ0_y ρ0_y) ]; }; return forward; } (d3.geo.conicEquidistant = function() { return d3_geo_conic(d3_geo_conicEquidistant); }).raw = d3_geo_conicEquidistant; var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) { return 1 / cosλcosφ; }, Math.atan); (d3.geo.gnomonic = function() { return d3_geo_projection(d3_geo_gnomonic); }).raw = d3_geo_gnomonic; function d3_geo_mercator(λ, φ) { return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ]; } d3_geo_mercator.invert = function(x, y) { return [ x, 2 Math.atan(Math.exp(y)) - halfπ ]; }; function d3_geo_mercatorProjection(project) { var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto; m.scale = function() { var v = scale.apply(m, arguments); return v === m ? clipAuto ? m.clipExtent(null) : m : v; }; m.translate = function() { var v = translate.apply(m, arguments); return v === m ? clipAuto ? m.clipExtent(null) : m : v; }; m.clipExtent = function(_) { var v = clipExtent.apply(m, arguments); if (v === m) { if (clipAuto = _ == null) { var k = π scale(), t = translate(); clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]); } } else if (clipAuto) { v = null; } return v; }; return m.clipExtent(null); } (d3.geo.mercator = function() { return d3_geo_mercatorProjection(d3_geo_mercator); }).raw = d3_geo_mercator; var d3_geo_orthographic = d3_geo_azimuthal(function() { return 1; }, Math.asin); (d3.geo.orthographic = function() { return d3_geo_projection(d3_geo_orthographic); }).raw = d3_geo_orthographic; var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) { return 1 / (1 + cosλcosφ); }, function(ρ) { return 2 Math.atan(ρ); }); (d3.geo.stereographic = function() { return d3_geo_projection(d3_geo_stereographic); }).raw = d3_geo_stereographic; function d3_geo_transverseMercator(λ, φ) { return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ]; } d3_geo_transverseMercator.invert = function(x, y) { return [ -y, 2 Math.atan(Math.exp(x)) - halfπ ]; }; (d3.geo.transverseMercator = function() { var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate; projection.center = function(_) { return _ ? center([ -_[1], [0] ]) : ( = center(), [ [1], -[0] ]); }; projection.rotate = function(_) { return _ ? rotate([ _[0], _[1], _.length &gt; 2 ? [2] + 90 : 90 ]) : ( = rotate(), [ _[0], _[1], _[2] - 90 ]); }; return rotate([ 0, 0, 90 ]); }).raw = d3_geo_transverseMercator; d3.geom = {}; function d3_geom_pointX(d) { return d[0]; } function d3_geom_pointY(d) { return d[1]; } d3.geom.hull = function(vertices) { var x = d3_geom_pointX, y = d3_geom_pointY; if (arguments.length) return hull(vertices); function hull(data) { if (data.length &lt; 3) return []; var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = []; for (i = 0; i &lt; n; i++) { points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]); } points.sort(d3_geom_hullOrder); for (i = 0; i &lt; n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]); var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints); var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = []; for (i = upper.length - 1; i &gt;= 0; –i) polygon.push(data[points[upper[i]][2]]); for (i = +skipLeft; i &lt; lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]); return polygon; } hull.x = function(_) { return arguments.length ? (x = , hull) : x; }; hull.y = function() { return arguments.length ? (y = _, hull) : y; }; return hull; }; function d3_geom_hullUpper(points) { var n = points.length, hull = [ 0, 1 ], hs = 2; for (var i = 2; i &lt; n; i++) { while (hs &gt; 1 &amp;&amp; d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) &lt;= 0) –hs; hull[hs++] = i; } return hull.slice(0, hs); } function d3_geom_hullOrder(a, b) { return a[0] - b[0] || a[1] - b[1]; } d3.geom.polygon = function(coordinates) { d3_subclass(coordinates, d3_geom_polygonPrototype); return coordinates; }; var d3_geom_polygonPrototype = d3.geom.polygon.prototype = []; d3_geom_polygonPrototype.area = function() { var i = -1, n = this.length, a, b = this[n - 1], area = 0; while (++i &lt; n) { a = b; b = this[i]; area += a[1] b[0] - a[0] b[1]; } return area .5; }; d3_geom_polygonPrototype.centroid = function(k) { var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c; if (!arguments.length) k = -1 / (6 this.area()); while (++i &lt; n) { a = b; b = this[i]; c = a[0] b[1] - b[0] a[1]; x += (a[0] + b[0]) c; y += (a[1] + b[1]) c; } return [ x k, y k ]; }; d3_geom_polygonPrototype.clip = function(subject) { var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d; while (++i &lt; n) { input = subject.slice(); subject.length = 0; b = this[i]; c = input[(m = input.length - closed) - 1]; j = -1; while (++j &lt; m) { d = input[j]; if (d3_geom_polygonInside(d, a, b)) { if (!d3_geom_polygonInside(c, a, b)) { subject.push(d3_geom_polygonIntersect(c, d, a, b)); } subject.push(d); } else if (d3_geom_polygonInside(c, a, b)) { subject.push(d3_geom_polygonIntersect(c, d, a, b)); } c = d; } if (closed) subject.push(subject[0]); a = b; } return subject; }; function d3_geom_polygonInside(p, a, b) { return (b[0] - a[0]) (p[1] - a[1]) &lt; (b[1] - a[1]) (p[0] - a[0]); } function d3_geom_polygonIntersect(c, d, a, b) { var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 (y1 - y3) - y43 (x1 - x3)) / (y43 x21 - x43 y21); return [ x1 + ua x21, y1 + ua y21 ]; } function d3_geom_polygonClosed(coordinates) { var a = coordinates[0], b = coordinates[coordinates.length - 1]; return !(a[0] - b[0] || a[1] - b[1]); } var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = []; function d3_geom_voronoiBeach() { d3_geom_voronoiRedBlackNode(this); this.edge = this.site = this.circle = null; } function d3_geom_voronoiCreateBeach(site) { var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach(); beach.site = site; return beach; } function d3_geom_voronoiDetachBeach(beach) { d3_geom_voronoiDetachCircle(beach); d3_geom_voronoiBeaches.remove(beach); d3_geom_voronoiBeachPool.push(beach); d3_geom_voronoiRedBlackNode(beach); } function d3_geom_voronoiRemoveBeach(beach) { var circle = beach.circle, x = circle.x, y = circle.cy, vertex = { x: x, y: y }, previous = beach.P, next = beach.N, disappearing = [ beach ]; d3_geom_voronoiDetachBeach(beach); var lArc = previous; while (lArc.circle &amp;&amp; abs(x - lArc.circle.x) &lt; ε &amp;&amp; abs(y - lArc.circle.cy) &lt; ε) { previous = lArc.P; disappearing.unshift(lArc); d3_geom_voronoiDetachBeach(lArc); lArc = previous; } disappearing.unshift(lArc); d3_geom_voronoiDetachCircle(lArc); var rArc = next; while (rArc.circle &amp;&amp; abs(x - rArc.circle.x) &lt; ε &amp;&amp; abs(y - rArc.circle.cy) &lt; ε) { next = rArc.N; disappearing.push(rArc); d3_geom_voronoiDetachBeach(rArc); rArc = next; } disappearing.push(rArc); d3_geom_voronoiDetachCircle(rArc); var nArcs = disappearing.length, iArc; for (iArc = 1; iArc &lt; nArcs; ++iArc) { rArc = disappearing[iArc]; lArc = disappearing[iArc - 1]; d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex); } lArc = disappearing[0]; rArc = disappearing[nArcs - 1]; rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); } function d3_geom_voronoiAddBeach(site) { var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._; while (node) { dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x; if (dxl &gt; ε) node = node.L; else { dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix); if (dxr &gt; ε) { if (!node.R) { lArc = node; break; } node = node.R; } else { if (dxl &gt; -ε) { lArc = node.P; rArc = node; } else if (dxr &gt; -ε) { lArc = node; rArc = node.N; } else { lArc = rArc = node; } break; } } } var newArc = d3_geom_voronoiCreateBeach(site); d3_geom_voronoiBeaches.insert(lArc, newArc); if (!lArc &amp;&amp; !rArc) return; if (lArc === rArc) { d3_geom_voronoiDetachCircle(lArc); rArc = d3_geom_voronoiCreateBeach(lArc.site); d3_geom_voronoiBeaches.insert(newArc, rArc); newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); return; } if (!rArc) { newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site); return; } d3_geom_voronoiDetachCircle(lArc); d3_geom_voronoiDetachCircle(rArc); var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 (bx cy - by cx), hb = bx bx + by by, hc = cx cx + cy cy, vertex = { x: (cy hb - by hc) / d + ax, y: (bx hc - cx hb) / d + ay }; d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex); newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex); rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); } function d3_geom_voronoiLeftBreakPoint(arc, directrix) { var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix; if (!pby2) return rfocx; var lArc = arc.P; if (!lArc) return -Infinity; site = lArc.site; var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix; if (!plby2) return lfocx; var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2; if (aby2) return (-b + Math.sqrt(b b - 2 aby2 (hl hl / (-2 plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx; return (rfocx + lfocx) / 2; } function d3_geom_voronoiRightBreakPoint(arc, directrix) { var rArc = arc.N; if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix); var site = arc.site; return site.y === directrix ? site.x : Infinity; } function d3_geom_voronoiCell(site) { this.site = site; this.edges = []; } d3_geom_voronoiCell.prototype.prepare = function() { var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge; while (iHalfEdge–) { edge = halfEdges[iHalfEdge].edge; if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1); } halfEdges.sort(d3_geom_voronoiHalfEdgeOrder); return halfEdges.length; }; function d3_geom_voronoiCloseCells(extent) { var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end; while (iCell–) { cell = cells[iCell]; if (!cell || !cell.prepare()) continue; halfEdges = cell.edges; nHalfEdges = halfEdges.length; iHalfEdge = 0; while (iHalfEdge &lt; nHalfEdges) { end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y; start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y; if (abs(x3 - x2) &gt; ε || abs(y3 - y2) &gt; ε) { halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) &lt; ε &amp;&amp; y1 - y3 &gt; ε ? { x: x0, y: abs(x2 - x0) &lt; ε ? y2 : y1 } : abs(y3 - y1) &lt; ε &amp;&amp; x1 - x3 &gt; ε ? { x: abs(y2 - y1) &lt; ε ? x2 : x1, y: y1 } : abs(x3 - x1) &lt; ε &amp;&amp; y3 - y0 &gt; ε ? { x: x1, y: abs(x2 - x1) &lt; ε ? y2 : y0 } : abs(y3 - y0) &lt; ε &amp;&amp; x3 - x0 &gt; ε ? { x: abs(y2 - y0) &lt; ε ? x2 : x0, y: y0 } : null), cell.site, null)); ++nHalfEdges; } } } } function d3_geom_voronoiHalfEdgeOrder(a, b) { return b.angle - a.angle; } function d3_geom_voronoiCircle() { d3_geom_voronoiRedBlackNode(this); this.x = this.y = this.arc = this.site = this.cy = null; } function d3_geom_voronoiAttachCircle(arc) { var lArc = arc.P, rArc = arc.N; if (!lArc || !rArc) return; var lSite = lArc.site, cSite = arc.site, rSite = rArc.site; if (lSite === rSite) return; var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by; var d = 2 (ax cy - ay cx); if (d &gt;= -ε2) return; var ha = ax ax + ay ay, hc = cx cx + cy cy, x = (cy ha - ay hc) / d, y = (ax hc - cx ha) / d, cy = y + by; var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle(); circle.arc = arc; circle.site = cSite; circle.x = x + bx; circle.y = cy + Math.sqrt(x x + y y); circle.cy = cy; arc.circle = circle; var before = null, node = d3_geom_voronoiCircles._; while (node) { if (circle.y &lt; node.y || circle.y === node.y &amp;&amp; circle.x &lt;= node.x) { if (node.L) node = node.L; else { before = node.P; break; } } else { if (node.R) node = node.R; else { before = node; break; } } } d3_geom_voronoiCircles.insert(before, circle); if (!before) d3_geom_voronoiFirstCircle = circle; } function d3_geom_voronoiDetachCircle(arc) { var circle = arc.circle; if (circle) { if (!circle.P) d3_geom_voronoiFirstCircle = circle.N; d3_geom_voronoiCircles.remove(circle); d3_geom_voronoiCirclePool.push(circle); d3_geom_voronoiRedBlackNode(circle); arc.circle = null; } } function d3_geom_voronoiClipEdges(extent) { var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e; while (i–) { e = edges[i]; if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) &lt; ε &amp;&amp; abs(e.a.y - e.b.y) &lt; ε) { e.a = e.b = null; edges.splice(i, 1); } } } function d3_geom_voronoiConnectEdge(edge, extent) { var vb = edge.b; if (vb) return true; var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb; if (ry === ly) { if (fx &lt; x0 || fx &gt;= x1) return; if (lx &gt; rx) { if (!va) va = { x: fx, y: y0 }; else if (va.y &gt;= y1) return; vb = { x: fx, y: y1 }; } else { if (!va) va = { x: fx, y: y1 }; else if (va.y &lt; y0) return; vb = { x: fx, y: y0 }; } } else { fm = (lx - rx) / (ry - ly); fb = fy - fm fx; if (fm &lt; -1 || fm &gt; 1) { if (lx &gt; rx) { if (!va) va = { x: (y0 - fb) / fm, y: y0 }; else if (va.y &gt;= y1) return; vb = { x: (y1 - fb) / fm, y: y1 }; } else { if (!va) va = { x: (y1 - fb) / fm, y: y1 }; else if (va.y &lt; y0) return; vb = { x: (y0 - fb) / fm, y: y0 }; } } else { if (ly &lt; ry) { if (!va) va = { x: x0, y: fm x0 + fb }; else if (va.x &gt;= x1) return; vb = { x: x1, y: fm x1 + fb }; } else { if (!va) va = { x: x1, y: fm x1 + fb }; else if (va.x &lt; x0) return; vb = { x: x0, y: fm x0 + fb }; } } } edge.a = va; edge.b = vb; return true; } function d3_geom_voronoiEdge(lSite, rSite) { this.l = lSite; this.r = rSite; this.a = this.b = null; } function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) { var edge = new d3_geom_voronoiEdge(lSite, rSite); d3_geom_voronoiEdges.push(edge); if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va); if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb); d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite)); d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite)); return edge; } function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) { var edge = new d3_geom_voronoiEdge(lSite, null); edge.a = va; edge.b = vb; d3_geom_voronoiEdges.push(edge); return edge; } function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) { if (!edge.a &amp;&amp; !edge.b) { edge.a = vertex; edge.l = lSite; edge.r = rSite; } else if (edge.l === rSite) { edge.b = vertex; } else { edge.a = vertex; } } function d3_geom_voronoiHalfEdge(edge, lSite, rSite) { var va = edge.a, vb = edge.b; this.edge = edge; this.site = lSite; this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y); } d3_geom_voronoiHalfEdge.prototype = { start: function() { return this.edge.l === this.site ? this.edge.a : this.edge.b; }, end: function() { return this.edge.l === this.site ? this.edge.b : this.edge.a; } }; function d3_geom_voronoiRedBlackTree() { this._ = null; } function d3_geom_voronoiRedBlackNode(node) { node.U = node.C = node.L = node.R = node.P = node.N = null; } d3_geom_voronoiRedBlackTree.prototype = { insert: function(after, node) { var parent, grandpa, uncle; if (after) { node.P = after; node.N = after.N; if (after.N) after.N.P = node; after.N = node; if (after.R) { after = after.R; while (after.L) after = after.L; after.L = node; } else { after.R = node; } parent = after; } else if (this._) { after = d3_geom_voronoiRedBlackFirst(this.); node.P = null; node.N = after; after.P = after.L = node; parent = after; } else { node.P = node.N = null; this. = node; parent = null; } node.L = node.R = null; node.U = parent; node.C = true; after = node; while (parent &amp;&amp; parent.C) { grandpa = parent.U; if (parent === grandpa.L) { uncle = grandpa.R; if (uncle &amp;&amp; uncle.C) { parent.C = uncle.C = false; grandpa.C = true; after = grandpa; } else { if (after === parent.R) { d3_geom_voronoiRedBlackRotateLeft(this, parent); after = parent; parent = after.U; } parent.C = false; grandpa.C = true; d3_geom_voronoiRedBlackRotateRight(this, grandpa); } } else { uncle = grandpa.L; if (uncle &amp;&amp; uncle.C) { parent.C = uncle.C = false; grandpa.C = true; after = grandpa; } else { if (after === parent.L) { d3_geom_voronoiRedBlackRotateRight(this, parent); after = parent; parent = after.U; } parent.C = false; grandpa.C = true; d3_geom_voronoiRedBlackRotateLeft(this, grandpa); } } parent = after.U; } this._.C = false; }, remove: function(node) { if (node.N) node.N.P = node.P; if (node.P) node.P.N = node.N; node.N = node.P = null; var parent = node.U, sibling, left = node.L, right = node.R, next, red; if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right); if (parent) { if (parent.L === node) parent.L = next; else parent.R = next; } else { this._ = next; } if (left &amp;&amp; right) { red = next.C; next.C = node.C; next.L = left; left.U = next; if (next !== right) { parent = next.U; next.U = node.U; node = next.R; parent.L = node; next.R = right; right.U = next; } else { next.U = parent; parent = next; node = next.R; } } else { red = node.C; node = next; } if (node) node.U = parent; if (red) return; if (node &amp;&amp; node.C) { node.C = false; return; } do { if (node === this._) break; if (node === parent.L) { sibling = parent.R; if (sibling.C) { sibling.C = false; parent.C = true; d3_geom_voronoiRedBlackRotateLeft(this, parent); sibling = parent.R; } if (sibling.L &amp;&amp; sibling.L.C || sibling.R &amp;&amp; sibling.R.C) { if (!sibling.R || !sibling.R.C) { sibling.L.C = false; sibling.C = true; d3_geom_voronoiRedBlackRotateRight(this, sibling); sibling = parent.R; } sibling.C = parent.C; parent.C = sibling.R.C = false; d3_geom_voronoiRedBlackRotateLeft(this, parent); node = this._; break; } } else { sibling = parent.L; if (sibling.C) { sibling.C = false; parent.C = true; d3_geom_voronoiRedBlackRotateRight(this, parent); sibling = parent.L; } if (sibling.L &amp;&amp; sibling.L.C || sibling.R &amp;&amp; sibling.R.C) { if (!sibling.L || !sibling.L.C) { sibling.R.C = false; sibling.C = true; d3_geom_voronoiRedBlackRotateLeft(this, sibling); sibling = parent.L; } sibling.C = parent.C; parent.C = sibling.L.C = false; d3_geom_voronoiRedBlackRotateRight(this, parent); node = this._; break; } } sibling.C = true; node = parent; parent = parent.U; } while (!node.C); if (node) node.C = false; } }; function d3_geom_voronoiRedBlackRotateLeft(tree, node) { var p = node, q = node.R, parent = p.U; if (parent) { if (parent.L === p) parent.L = q; else parent.R = q; } else { tree._ = q; } q.U = parent; p.U = q; p.R = q.L; if (p.R) p.R.U = p; q.L = p; } function d3_geom_voronoiRedBlackRotateRight(tree, node) { var p = node, q = node.L, parent = p.U; if (parent) { if (parent.L === p) parent.L = q; else parent.R = q; } else { tree._ = q; } q.U = parent; p.U = q; p.L = q.R; if (p.L) p.L.U = p; q.R = p; } function d3_geom_voronoiRedBlackFirst(node) { while (node.L) node = node.L; return node; } function d3_geom_voronoi(sites, bbox) { var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle; d3_geom_voronoiEdges = []; d3_geom_voronoiCells = new Array(sites.length); d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree(); d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree(); while (true) { circle = d3_geom_voronoiFirstCircle; if (site &amp;&amp; (!circle || site.y &lt; circle.y || site.y === circle.y &amp;&amp; site.x &lt; circle.x)) { if (site.x !== x0 || site.y !== y0) { d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site); d3_geom_voronoiAddBeach(site); x0 = site.x, y0 = site.y; } site = sites.pop(); } else if (circle) { d3_geom_voronoiRemoveBeach(circle.arc); } else { break; } } if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox); var diagram = { cells: d3_geom_voronoiCells, edges: d3_geom_voronoiEdges }; d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null; return diagram; } function d3_geom_voronoiVertexOrder(a, b) { return b.y - a.y || b.x - a.x; } d3.geom.voronoi = function(points) { var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent; if (points) return voronoi(points); function voronoi(data) { var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1]; d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) { var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [ s.x, s.y ]; }) : site.x &gt;= x0 &amp;&amp; site.x &lt;= x1 &amp;&amp; site.y &gt;= y0 &amp;&amp; site.y &lt;= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : []; polygon.point = data[i]; }); return polygons; } function sites(data) { return data.map(function(d, i) { return { x: Math.round(fx(d, i) / ε) ε, y: Math.round(fy(d, i) / ε) ε, i: i }; }); } voronoi.links = function(data) { return d3_geom_voronoi(sites(data)).edges.filter(function(edge) { return edge.l &amp;&amp; edge.r; }).map(function(edge) { return { source: data[edge.l.i], target: data[edge.r.i] }; }); }; voronoi.triangles = function(data) { var triangles = []; d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) { var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l; while (++j &lt; m) { e0 = e1; s0 = s1; e1 = edges[j].edge; s1 = e1.l === site ? e1.r : e1.l; if (i &lt; s0.i &amp;&amp; i &lt; s1.i &amp;&amp; d3_geom_voronoiTriangleArea(site, s0, s1) &lt; 0) { triangles.push([ data[i], data[s0.i], data[s1.i] ]); } } }); return triangles; }; voronoi.x = function(_) { return arguments.length ? (fx = d3_functor(x = ), voronoi) : x; }; voronoi.y = function() { return arguments.length ? (fy = d3_functor(y = ), voronoi) : y; }; voronoi.clipExtent = function() { if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent; clipExtent = _ == null ? d3_geom_voronoiClipExtent : ; return voronoi; }; voronoi.size = function() { if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent &amp;&amp; clipExtent[1]; return voronoi.clipExtent(_ &amp;&amp; [ [ 0, 0 ], _ ]); }; return voronoi; }; var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ]; function d3_geom_voronoiTriangleArea(a, b, c) { return (a.x - c.x) (b.y - a.y) - (a.x - b.x) (c.y - a.y); } d3.geom.delaunay = function(vertices) { return d3.geom.voronoi().triangles(vertices); }; d3.geom.quadtree = function(points, x1, y1, x2, y2) { var x = d3_geom_pointX, y = d3_geom_pointY, compat; if (compat = arguments.length) { x = d3_geom_quadtreeCompatX; y = d3_geom_quadtreeCompatY; if (compat === 3) { y2 = y1; x2 = x1; y1 = x1 = 0; } return quadtree(points); } function quadtree(data) { var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_; if (x1 != null) { x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2; } else { x2_ = y2_ = -(x1_ = y1_ = Infinity); xs = [], ys = []; n = data.length; if (compat) for (i = 0; i &lt; n; ++i) { d = data[i]; if (d.x &lt; x1_) x1_ = d.x; if (d.y &lt; y1_) y1_ = d.y; if (d.x &gt; x2_) x2_ = d.x; if (d.y &gt; y2_) y2_ = d.y; xs.push(d.x); ys.push(d.y); } else for (i = 0; i &lt; n; ++i) { var x_ = +fx(d = data[i], i), y_ = +fy(d, i); if (x_ &lt; x1_) x1_ = x_; if (y_ &lt; y1_) y1_ = y_; if (x_ &gt; x2_) x2_ = x_; if (y_ &gt; y2_) y2_ = y_; xs.push(x_); ys.push(y_); } } var dx = x2_ - x1_, dy = y2_ - y1_; if (dx &gt; dy) y2_ = y1_ + dx; else x2_ = x1_ + dy; function insert(n, d, x, y, x1, y1, x2, y2) { if (isNaN(x) || isNaN(y)) return; if (n.leaf) { var nx = n.x, ny = n.y; if (nx != null) { if (abs(nx - x) + abs(ny - y) &lt; .01) { insertChild(n, d, x, y, x1, y1, x2, y2); } else { var nPoint = n.point; n.x = n.y = n.point = null; insertChild(n, nPoint, nx, ny, x1, y1, x2, y2); insertChild(n, d, x, y, x1, y1, x2, y2); } } else { n.x = x, n.y = y, n.point = d; } } else { insertChild(n, d, x, y, x1, y1, x2, y2); } } function insertChild(n, d, x, y, x1, y1, x2, y2) { var xm = (x1 + x2) .5, ym = (y1 + y2) .5, right = x &gt;= xm, below = y &gt;= ym, i = below &lt;&lt; 1 | right; n.leaf = false; n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode()); if (right) x1 = xm; else x2 = xm; if (below) y1 = ym; else y2 = ym; insert(n, d, x, y, x1, y1, x2, y2); } var root = d3_geom_quadtreeNode(); root.add = function(d) { insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_); }; root.visit = function(f) { d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_); }; root.find = function(point) { return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_); }; i = -1; if (x1 == null) { while (++i &lt; n) { insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_); } –i; } else data.forEach(root.add); xs = ys = data = d = null; return root; } quadtree.x = function(_) { return arguments.length ? (x = , quadtree) : x; }; quadtree.y = function() { return arguments.length ? (y = , quadtree) : y; }; quadtree.extent = function() { if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ]; if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +[0][0], y1 = +[0][1], x2 = +[1][0], y2 = +[1][1]; return quadtree; }; quadtree.size = function() { if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ]; if ( == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +[0], y2 = +[1]; return quadtree; }; return quadtree; }; function d3_geom_quadtreeCompatX(d) { return d.x; } function d3_geom_quadtreeCompatY(d) { return d.y; } function d3_geom_quadtreeNode() { return { leaf: true, nodes: [], point: null, x: null, y: null }; } function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) { if (!f(node, x1, y1, x2, y2)) { var sx = (x1 + x2) .5, sy = (y1 + y2) .5, children = node.nodes; if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy); if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy); if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2); if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2); } } function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) { var minDistance2 = Infinity, closestPoint; (function find(node, x1, y1, x2, y2) { if (x1 &gt; x3 || y1 &gt; y3 || x2 &lt; x0 || y2 &lt; y0) return; if (point = node.point) { var point, dx = x - node.x, dy = y - node.y, distance2 = dx dx + dy dy; if (distance2 &lt; minDistance2) { var distance = Math.sqrt(minDistance2 = distance2); x0 = x - distance, y0 = y - distance; x3 = x + distance, y3 = y + distance; closestPoint = point; } } var children = node.nodes, xm = (x1 + x2) .5, ym = (y1 + y2) .5, right = x &gt;= xm, below = y &gt;= ym; for (var i = below &lt;&lt; 1 | right, j = i + 4; i &lt; j; ++i) { if (node = children[i &amp; 3]) switch (i &amp; 3) { case 0: find(node, x1, y1, xm, ym); break; case 1: find(node, xm, y1, x2, ym); break; case 2: find(node, x1, ym, xm, y2); break; case 3: find(node, xm, ym, x2, y2); break; } } })(root, x0, y0, x3, y3); return closestPoint; } d3.interpolateRgb = d3_interpolateRgb; function d3_interpolateRgb(a, b) { a = d3.rgb(a); b = d3.rgb(b); var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab; return function(t) { return “#” + d3_rgb_hex(Math.round(ar + br t)) + d3_rgb_hex(Math.round(ag + bg t)) + d3_rgb_hex(Math.round(ab + bb t)); }; } d3.interpolateObject = d3_interpolateObject; function d3_interpolateObject(a, b) { var i = {}, c = {}, k; for (k in a) { if (k in b) { i[k] = d3_interpolate(a[k], b[k]); } else { c[k] = a[k]; } } for (k in b) { if (!(k in a)) { c[k] = b[k]; } } return function(t) { for (k in i) c[k] = ik; return c; }; } d3.interpolateNumber = d3_interpolateNumber; function d3_interpolateNumber(a, b) { a = +a, b = +b; return function(t) { return a (1 - t) + b t; }; } d3.interpolateString = d3_interpolateString; function d3_interpolateString(a, b) { var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = []; a = a + “”, b = b + “”; while ((am = d3_interpolate_numberA.exec(a)) &amp;&amp; (bm = d3_interpolate_numberB.exec(b))) { if ((bs = bm.index) &gt; bi) { bs = b.slice(bi, bs); if (s[i]) s[i] += bs; else s[++i] = bs; } if ((am = am[0]) === (bm = bm[0])) { if (s[i]) s[i] += bm; else s[++i] = bm; } else { s[++i] = null; q.push({ i: i, x: d3_interpolateNumber(am, bm) }); } bi = d3_interpolate_numberB.lastIndex; } if (bi &lt; b.length) { bs = b.slice(bi); if (s[i]) s[i] += bs; else s[++i] = bs; } return s.length &lt; 2 ? q[0] ? (b = q[0].x, function(t) { return b(t) + “”; }) : function() { return b; } : (b = q.length, function(t) { for (var i = 0, o; i &lt; b; ++i) s[(o = q[i]).i] = o.x(t); return s.join(“”); }); } var d3_interpolate_numberA = /[-+]?(?:\d+.?\d|.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, “g”); d3.interpolate = d3_interpolate; function d3_interpolate(a, b) { var i = d3.interpolators.length, f; while (–i &gt;= 0 &amp;&amp; !(f = d3.interpolatorsi)) ; return f; } d3.interpolators = [ function(a, b) { var t = typeof b; return (t === “string” ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb(|hsl()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === “object” &amp;&amp; isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b); } ]; d3.interpolateArray = d3_interpolateArray; function d3_interpolateArray(a, b) { var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i; for (i = 0; i &lt; n0; ++i) x.push(d3_interpolate(a[i], b[i])); for (;i &lt; na; ++i) c[i] = a[i]; for (;i &lt; nb; ++i) c[i] = b[i]; return function(t) { for (i = 0; i &lt; n0; ++i) c[i] = xi; return c; }; } var d3_ease_default = function() { return d3_identity; }; var d3_ease = d3.map({ linear: d3_ease_default, poly: d3_ease_poly, quad: function() { return d3_ease_quad; }, cubic: function() { return d3_ease_cubic; }, sin: function() { return d3_ease_sin; }, exp: function() { return d3_ease_exp; }, circle: function() { return d3_ease_circle; }, elastic: d3_ease_elastic, back: d3_ease_back, bounce: function() { return d3_ease_bounce; } }); var d3_ease_mode = d3.map({ “in”: d3_identity, out: d3_ease_reverse, “in-out”: d3_ease_reflect, “out-in”: function(f) { return d3_ease_reflect(d3_ease_reverse(f)); } }); d3.ease = function(name) { var i = name.indexOf(“-“), t = i &gt;= 0 ? name.slice(0, i) : name, m = i &gt;= 0 ? name.slice(i + 1) : “in”; t = d3_ease.get(t) || d3_ease_default; m = d3_ease_mode.get(m) || d3_identity; return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1)))); }; function d3_ease_clamp(f) { return function(t) { return t &lt;= 0 ? 0 : t &gt;= 1 ? 1 : f(t); }; } function d3_ease_reverse(f) { return function(t) { return 1 - f(1 - t); }; } function d3_ease_reflect(f) { return function(t) { return .5 (t &lt; .5 ? f(2 t) : 2 - f(2 - 2 t)); }; } function d3_ease_quad(t) { return t t; } function d3_ease_cubic(t) { return t t t; } function d3_ease_cubicInOut(t) { if (t &lt;= 0) return 0; if (t &gt;= 1) return 1; var t2 = t t, t3 = t2 t; return 4 (t &lt; .5 ? t3 : 3 (t - t2) + t3 - .75); } function d3_ease_poly(e) { return function(t) { return Math.pow(t, e); }; } function d3_ease_sin(t) { return 1 - Math.cos(t halfπ); } function d3_ease_exp(t) { return Math.pow(2, 10 (t - 1)); } function d3_ease_circle(t) { return 1 - Math.sqrt(1 - t t); } function d3_ease_elastic(a, p) { var s; if (arguments.length &lt; 2) p = .45; if (arguments.length) s = p / τ Math.asin(1 / a); else a = 1, s = p / 4; return function(t) { return 1 + a Math.pow(2, -10 t) Math.sin((t - s) τ / p); }; } function d3_ease_back(s) { if (!s) s = 1.70158; return function(t) { return t t ((s + 1) t - s); }; } function d3_ease_bounce(t) { return t &lt; 1 / 2.75 ? 7.5625 t t : t &lt; 2 / 2.75 ? 7.5625 (t -= 1.5 / 2.75) t + .75 : t &lt; 2.5 / 2.75 ? 7.5625 (t -= 2.25 / 2.75) t + .9375 : 7.5625 (t -= 2.625 / 2.75) t + .984375; } d3.interpolateHcl = d3_interpolateHcl; function d3_interpolateHcl(a, b) { a = d3.hcl(a); b = d3.hcl(b); var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al; if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac; if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &gt; 180) bh -= 360; else if (bh &lt; -180) bh += 360; return function(t) { return d3_hcl_lab(ah + bh t, ac + bc t, al + bl t) + “”; }; } d3.interpolateHsl = d3_interpolateHsl; function d3_interpolateHsl(a, b) { a = d3.hsl(a); b = d3.hsl(b); var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al; if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as; if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &gt; 180) bh -= 360; else if (bh &lt; -180) bh += 360; return function(t) { return d3_hsl_rgb(ah + bh t, as + bs t, al + bl t) + “”; }; } d3.interpolateLab = d3_interpolateLab; function d3_interpolateLab(a, b) { a = d3.lab(a); b = d3.lab(b); var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab; return function(t) { return d3_lab_rgb(al + bl t, aa + ba t, ab + bb t) + “”; }; } d3.interpolateRound = d3_interpolateRound; function d3_interpolateRound(a, b) { b -= a; return function(t) { return Math.round(a + b t); }; } d3.transform = function(string) { var g = d3_document.createElementNS(d3.ns.prefix.svg, “g”); return (d3.transform = function(string) { if (string != null) { g.setAttribute(“transform”, string); var t = g.transform.baseVal.consolidate(); } return new d3_transform(t ? t.matrix : d3_transformIdentity); })(string); }; function d3_transform(m) { var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0; if (r0[0] r1[1] &lt; r1[0] r0[1]) { r0[0] = -1; r0[1] = -1; kx = -1; kz = -1; } this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) d3_degrees; this.translate = [ m.e, m.f ]; this.scale = [ kx, ky ]; this.skew = ky ? Math.atan2(kz, ky) d3_degrees : 0; } d3_transform.prototype.toString = function() { return “translate(“ + this.translate + “)rotate(“ + this.rotate + “)skewX(“ + this.skew + “)scale(“ + this.scale + “)”; }; function d3_transformDot(a, b) { return a[0] b[0] + a[1] b[1]; } function d3_transformNormalize(a) { var k = Math.sqrt(d3_transformDot(a, a)); if (k) { a[0] /= k; a[1] /= k; } return k; } function d3_transformCombine(a, b, k) { a[0] += k b[0]; a[1] += k b[1]; return a; } var d3_transformIdentity = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }; d3.interpolateTransform = d3_interpolateTransform; function d3_interpolateTransformPop(s) { return s.length ? s.pop() + “,” : “”; } function d3_interpolateTranslate(ta, tb, s, q) { if (ta[0] !== tb[0] || ta[1] !== tb[1]) { var i = s.push(“translate(“, null, “,”, null, “)”); q.push({ i: i - 4, x: d3_interpolateNumber(ta[0], tb[0]) }, { i: i - 2, x: d3_interpolateNumber(ta[1], tb[1]) }); } else if (tb[0] || tb[1]) { s.push(“translate(“ + tb + “)”); } } function d3_interpolateRotate(ra, rb, s, q) { if (ra !== rb) { if (ra - rb &gt; 180) rb += 360; else if (rb - ra &gt; 180) ra += 360; q.push({ i: s.push(d3_interpolateTransformPop(s) + “rotate(“, null, “)”) - 2, x: d3_interpolateNumber(ra, rb) }); } else if (rb) { s.push(d3_interpolateTransformPop(s) + “rotate(“ + rb + “)”); } } function d3_interpolateSkew(wa, wb, s, q) { if (wa !== wb) { q.push({ i: s.push(d3_interpolateTransformPop(s) + “skewX(“, null, “)”) - 2, x: d3_interpolateNumber(wa, wb) }); } else if (wb) { s.push(d3_interpolateTransformPop(s) + “skewX(“ + wb + “)”); } } function d3_interpolateScale(ka, kb, s, q) { if (ka[0] !== kb[0] || ka[1] !== kb[1]) { var i = s.push(d3_interpolateTransformPop(s) + “scale(“, null, “,”, null, “)”); q.push({ i: i - 4, x: d3_interpolateNumber(ka[0], kb[0]) }, { i: i - 2, x: d3_interpolateNumber(ka[1], kb[1]) }); } else if (kb[0] !== 1 || kb[1] !== 1) { s.push(d3_interpolateTransformPop(s) + “scale(“ + kb + “)”); } } function d3_interpolateTransform(a, b) { var s = [], q = []; a = d3.transform(a), b = d3.transform(b); d3_interpolateTranslate(a.translate, b.translate, s, q); d3_interpolateRotate(a.rotate, b.rotate, s, q); d3_interpolateSkew(a.skew, b.skew, s, q); d3_interpolateScale(a.scale, b.scale, s, q); a = b = null; return function(t) { var i = -1, n = q.length, o; while (++i &lt; n) s[(o = q[i]).i] = o.x(t); return s.join(“”); }; } function d3_uninterpolateNumber(a, b) { b = (b -= a = +a) || 1 / b; return function(x) { return (x - a) / b; }; } function d3_uninterpolateClamp(a, b) { b = (b -= a = +a) || 1 / b; return function(x) { return Math.max(0, Math.min(1, (x - a) / b)); }; } d3.layout = {}; d3.layout.bundle = function() { return function(links) { var paths = [], i = -1, n = links.length; while (++i &lt; n) paths.push(d3_layout_bundlePath(links[i])); return paths; }; }; function d3_layout_bundlePath(link) { var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ]; while (start !== lca) { start = start.parent; points.push(start); } var k = points.length; while (end !== lca) { points.splice(k, 0, end); end = end.parent; } return points; } function d3_layout_bundleAncestors(node) { var ancestors = [], parent = node.parent; while (parent != null) { ancestors.push(node); node = parent; parent = parent.parent; } ancestors.push(node); return ancestors; } function d3_layout_bundleLeastCommonAncestor(a, b) { if (a === b) return a; var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null; while (aNode === bNode) { sharedNode = aNode; aNode = aNodes.pop(); bNode = bNodes.pop(); } return sharedNode; } d3.layout.chord = function() { var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords; function relayout() { var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j; chords = []; groups = []; k = 0, i = -1; while (++i &lt; n) { x = 0, j = -1; while (++j &lt; n) { x += matrix[i][j]; } groupSums.push(x); subgroupIndex.push(d3.range(n)); k += x; } if (sortGroups) { groupIndex.sort(function(a, b) { return sortGroups(groupSums[a], groupSums[b]); }); } if (sortSubgroups) { subgroupIndex.forEach(function(d, i) { d.sort(function(a, b) { return sortSubgroups(matrix[i][a], matrix[i][b]); }); }); } k = (τ - padding n) / k; x = 0, i = -1; while (++i &lt; n) { x0 = x, j = -1; while (++j &lt; n) { var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v k; subgroups[di + “-“ + dj] = { index: di, subindex: dj, startAngle: a0, endAngle: a1, value: v }; } groups[di] = { index: di, startAngle: x0, endAngle: x, value: groupSums[di] }; x += padding; } i = -1; while (++i &lt; n) { j = i - 1; while (++j &lt; n) { var source = subgroups[i + “-“ + j], target = subgroups[j + “-“ + i]; if (source.value || target.value) { chords.push(source.value &lt; target.value ? { source: target, target: source } : { source: source, target: target }); } } } if (sortChords) resort(); } function resort() { chords.sort(function(a, b) { return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2); }); } chord.matrix = function(x) { if (!arguments.length) return matrix; n = (matrix = x) &amp;&amp; matrix.length; chords = groups = null; return chord; }; chord.padding = function(x) { if (!arguments.length) return padding; padding = x; chords = groups = null; return chord; }; chord.sortGroups = function(x) { if (!arguments.length) return sortGroups; sortGroups = x; chords = groups = null; return chord; }; chord.sortSubgroups = function(x) { if (!arguments.length) return sortSubgroups; sortSubgroups = x; chords = null; return chord; }; chord.sortChords = function(x) { if (!arguments.length) return sortChords; sortChords = x; if (chords) resort(); return chord; }; chord.chords = function() { if (!chords) relayout(); return chords; }; chord.groups = function() { if (!groups) relayout(); return groups; }; return chord; }; d3.layout.force = function() { var force = {}, event = d3.dispatch(“start”, “tick”, “end”), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges; function repulse(node) { return function(quad, x1, _, x2) { if (quad.point !== node) { var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx dx + dy dy; if (dw dw / theta2 &lt; dn) { if (dn &lt; chargeDistance2) { var k = quad.charge / dn; node.px -= dx k; node.py -= dy k; } return true; } if (quad.point &amp;&amp; dn &amp;&amp; dn &lt; chargeDistance2) { var k = quad.pointCharge / dn; node.px -= dx k; node.py -= dy k; } } return !quad.charge; }; } force.tick = function() { if ((alpha = .99) &lt; .005) { timer = null; event.end({ type: “end”, alpha: alpha = 0 }); return true; } var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y; for (i = 0; i &lt; m; ++i) { o = links[i]; s = o.source; t = o.target; x = t.x - s.x; y = t.y - s.y; if (l = x x + y y) { l = alpha strengths[i] ((l = Math.sqrt(l)) - distances[i]) / l; x = l; y = l; t.x -= x (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5); t.y -= y k; s.x += x (k = 1 - k); s.y += y k; } } if (k = alpha gravity) { x = size[0] / 2; y = size[1] / 2; i = -1; if (k) while (++i &lt; n) { o = nodes[i]; o.x += (x - o.x) k; o.y += (y - o.y) k; } } if (charge) { d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges); i = -1; while (++i &lt; n) { if (!(o = nodes[i]).fixed) { q.visit(repulse(o)); } } } i = -1; while (++i &lt; n) { o = nodes[i]; if (o.fixed) { o.x = o.px; o.y = o.py; } else { o.x -= (o.px - (o.px = o.x)) friction; o.y -= (o.py - (o.py = o.y)) friction; } } event.tick({ type: “tick”, alpha: alpha }); }; force.nodes = function(x) { if (!arguments.length) return nodes; nodes = x; return force; }; force.links = function(x) { if (!arguments.length) return links; links = x; return force; }; force.size = function(x) { if (!arguments.length) return size; size = x; return force; }; force.linkDistance = function(x) { if (!arguments.length) return linkDistance; linkDistance = typeof x === “function” ? x : +x; return force; }; force.distance = force.linkDistance; force.linkStrength = function(x) { if (!arguments.length) return linkStrength; linkStrength = typeof x === “function” ? x : +x; return force; }; force.friction = function(x) { if (!arguments.length) return friction; friction = +x; return force; }; force.charge = function(x) { if (!arguments.length) return charge; charge = typeof x === “function” ? x : +x; return force; }; force.chargeDistance = function(x) { if (!arguments.length) return Math.sqrt(chargeDistance2); chargeDistance2 = x x; return force; }; force.gravity = function(x) { if (!arguments.length) return gravity; gravity = +x; return force; }; force.theta = function(x) { if (!arguments.length) return Math.sqrt(theta2); theta2 = x x; return force; }; force.alpha = function(x) { if (!arguments.length) return alpha; x = +x; if (alpha) { if (x &gt; 0) { alpha = x; } else { timer.c = null, timer.t = NaN, timer = null; event.end({ type: “end”, alpha: alpha = 0 }); } } else if (x &gt; 0) { event.start({ type: “start”, alpha: alpha = x }); timer = d3_timer(force.tick); } return force; }; force.start = function() { var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o; for (i = 0; i &lt; n; ++i) { (o = nodes[i]).index = i; o.weight = 0; } for (i = 0; i &lt; m; ++i) { o = links[i]; if (typeof o.source == “number”) o.source = nodes[o.source]; if (typeof o.target == “number”) o.target = nodes[o.target]; ++o.source.weight; ++o.target.weight; } for (i = 0; i &lt; n; ++i) { o = nodes[i]; if (isNaN(o.x)) o.x = position(“x”, w); if (isNaN(o.y)) o.y = position(“y”, h); if (isNaN(o.px)) o.px = o.x; if (isNaN(o.py)) o.py = o.y; } distances = []; if (typeof linkDistance === “function”) for (i = 0; i &lt; m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i &lt; m; ++i) distances[i] = linkDistance; strengths = []; if (typeof linkStrength === “function”) for (i = 0; i &lt; m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i &lt; m; ++i) strengths[i] = linkStrength; charges = []; if (typeof charge === “function”) for (i = 0; i &lt; n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i &lt; n; ++i) charges[i] = charge; function position(dimension, size) { if (!neighbors) { neighbors = new Array(n); for (j = 0; j &lt; n; ++j) { neighbors[j] = []; } for (j = 0; j &lt; m; ++j) { var o = links[j]; neighbors[o.source.index].push(o.target); neighbors[o.target.index].push(o.source); } } var candidates = neighbors[i], j = -1, l = candidates.length, x; while (++j &lt; l) if (!isNaN(x = candidates[j][dimension])) return x; return Math.random() size; } return force.resume(); }; force.resume = function() { return force.alpha(.1); }; force.stop = function() { return force.alpha(0); }; force.drag = function() { if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(“dragstart.force”, d3_layout_forceDragstart).on(“drag.force”, dragmove).on(“dragend.force”, d3_layout_forceDragend); if (!arguments.length) return drag; this.on(“mouseover.force”, d3_layout_forceMouseover).on(“mouseout.force”, d3_layout_forceMouseout).call(drag); }; function dragmove(d) { d.px = d3.event.x, d.py = d3.event.y; force.resume(); } return d3.rebind(force, event, “on”); }; function d3_layout_forceDragstart(d) { d.fixed |= 2; } function d3_layout_forceDragend(d) { d.fixed &amp;= ~6; } function d3_layout_forceMouseover(d) { d.fixed |= 4; d.px = d.x, d.py = d.y; } function d3_layout_forceMouseout(d) { d.fixed &amp;= ~4; } function d3_layout_forceAccumulate(quad, alpha, charges) { var cx = 0, cy = 0; quad.charge = 0; if (!quad.leaf) { var nodes = quad.nodes, n = nodes.length, i = -1, c; while (++i &lt; n) { c = nodes[i]; if (c == null) continue; d3_layout_forceAccumulate(c, alpha, charges); quad.charge += c.charge; cx += c.charge c.cx; cy += c.charge c.cy; } } if (quad.point) { if (!quad.leaf) { quad.point.x += Math.random() - .5; quad.point.y += Math.random() - .5; } var k = alpha charges[quad.point.index]; quad.charge += quad.pointCharge = k; cx += k quad.point.x; cy += k quad.point.y; } quad.cx = cx / quad.charge; quad.cy = cy / quad.charge; } var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity; d3.layout.hierarchy = function() { var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue; function hierarchy(root) { var stack = [ root ], nodes = [], node; root.depth = 0; while ((node = stack.pop()) != null) { nodes.push(node); if ((childs = children.call(hierarchy, node, node.depth)) &amp;&amp; (n = childs.length)) { var n, childs, child; while (–n &gt;= 0) { stack.push(child = childs[n]); child.parent = node; child.depth = node.depth + 1; } if (value) node.value = 0; node.children = childs; } else { if (value) node.value = +value.call(hierarchy, node, node.depth) || 0; delete node.children; } } d3_layout_hierarchyVisitAfter(root, function(node) { var childs, parent; if (sort &amp;&amp; (childs = node.children)) childs.sort(sort); if (value &amp;&amp; (parent = node.parent)) parent.value += node.value; }); return nodes; } hierarchy.sort = function(x) { if (!arguments.length) return sort; sort = x; return hierarchy; }; hierarchy.children = function(x) { if (!arguments.length) return children; children = x; return hierarchy; }; hierarchy.value = function(x) { if (!arguments.length) return value; value = x; return hierarchy; }; hierarchy.revalue = function(root) { if (value) { d3_layout_hierarchyVisitBefore(root, function(node) { if (node.children) node.value = 0; }); d3_layout_hierarchyVisitAfter(root, function(node) { var parent; if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0; if (parent = node.parent) parent.value += node.value; }); } return root; }; return hierarchy; }; function d3_layout_hierarchyRebind(object, hierarchy) { d3.rebind(object, hierarchy, “sort”, “children”, “value”); object.nodes = object; object.links = d3_layout_hierarchyLinks; return object; } function d3_layout_hierarchyVisitBefore(node, callback) { var nodes = [ node ]; while ((node = nodes.pop()) != null) { callback(node); if ((children = node.children) &amp;&amp; (n = children.length)) { var n, children; while (–n &gt;= 0) nodes.push(children[n]); } } } function d3_layout_hierarchyVisitAfter(node, callback) { var nodes = [ node ], nodes2 = []; while ((node = nodes.pop()) != null) { nodes2.push(node); if ((children = node.children) &amp;&amp; (n = children.length)) { var i = -1, n, children; while (++i &lt; n) nodes.push(children[i]); } } while ((node = nodes2.pop()) != null) { callback(node); } } function d3_layout_hierarchyChildren(d) { return d.children; } function d3_layout_hierarchyValue(d) { return d.value; } function d3_layout_hierarchySort(a, b) { return b.value - a.value; } function d3_layout_hierarchyLinks(nodes) { return d3.merge(nodes.map(function(parent) { return (parent.children || []).map(function(child) { return { source: parent, target: child }; }); })); } d3.layout.partition = function() { var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ]; function position(node, x, dx, dy) { var children = node.children; node.x = x; node.y = node.depth dy; node.dx = dx; node.dy = dy; if (children &amp;&amp; (n = children.length)) { var i = -1, n, c, d; dx = node.value ? dx / node.value : 0; while (++i &lt; n) { position(c = children[i], x, d = c.value dx, dy); x += d; } } } function depth(node) { var children = node.children, d = 0; if (children &amp;&amp; (n = children.length)) { var i = -1, n; while (++i &lt; n) d = Math.max(d, depth(children[i])); } return 1 + d; } function partition(d, i) { var nodes = hierarchy.call(this, d, i); position(nodes[0], 0, size[0], size[1] / depth(nodes[0])); return nodes; } partition.size = function(x) { if (!arguments.length) return size; size = x; return partition; }; return d3_layout_hierarchyRebind(partition, hierarchy); }; d3.layout.pie = function() { var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0; function pie(data) { var n = data.length, values = data.map(function(d, i) { return +value.call(pie, d, i); }), a = +(typeof startAngle === “function” ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === “function” ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === “function” ? padAngle.apply(this, arguments) : padAngle)), pa = p (da &lt; 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n pa) / sum : 0, index = d3.range(n), arcs = [], v; if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) { return values[j] - values[i]; } : function(i, j) { return sort(data[i], data[j]); }); index.forEach(function(i) { arcs[i] = { data: data[i], value: v = values[i], startAngle: a, endAngle: a += v k + pa, padAngle: p }; }); return arcs; } pie.value = function(_) { if (!arguments.length) return value; value = ; return pie; }; pie.sort = function() { if (!arguments.length) return sort; sort = ; return pie; }; pie.startAngle = function() { if (!arguments.length) return startAngle; startAngle = ; return pie; }; pie.endAngle = function() { if (!arguments.length) return endAngle; endAngle = ; return pie; }; pie.padAngle = function() { if (!arguments.length) return padAngle; padAngle = _; return pie; }; return pie; }; var d3_layout_pieSortByValue = {}; d3.layout.stack = function() { var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY; function stack(data, index) { if (!(n = data.length)) return data; var series = data.map(function(d, i) { return values.call(stack, d, i); }); var points = series.map(function(d) { return d.map(function(v, i) { return [ x.call(stack, v, i), y.call(stack, v, i) ]; }); }); var orders = order.call(stack, points, index); series = d3.permute(series, orders); points = d3.permute(points, orders); var offsets = offset.call(stack, points, index); var m = series[0].length, n, i, j, o; for (j = 0; j &lt; m; ++j) { out.call(stack, series[0][j], o = offsets[j], points[0][j][1]); for (i = 1; i &lt; n; ++i) { out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]); } } return data; } stack.values = function(x) { if (!arguments.length) return values; values = x; return stack; }; stack.order = function(x) { if (!arguments.length) return order; order = typeof x === “function” ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault; return stack; }; stack.offset = function(x) { if (!arguments.length) return offset; offset = typeof x === “function” ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero; return stack; }; stack.x = function(z) { if (!arguments.length) return x; x = z; return stack; }; stack.y = function(z) { if (!arguments.length) return y; y = z; return stack; }; stack.out = function(z) { if (!arguments.length) return out; out = z; return stack; }; return stack; }; function d3_layout_stackX(d) { return d.x; } function d3_layout_stackY(d) { return d.y; } function d3_layout_stackOut(d, y0, y) { d.y0 = y0; d.y = y; } var d3_layout_stackOrders = d3.map({ “inside-out”: function(data) { var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }), top = 0, bottom = 0, tops = [], bottoms = []; for (i = 0; i &lt; n; ++i) { j = index[i]; if (top &lt; bottom) { top += sums[j]; tops.push(j); } else { bottom += sums[j]; bottoms.push(j); } } return bottoms.reverse().concat(tops); }, reverse: function(data) { return d3.range(data.length).reverse(); }, “default”: d3_layout_stackOrderDefault }); var d3_layout_stackOffsets = d3.map({ silhouette: function(data) { var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = []; for (j = 0; j &lt; m; ++j) { for (i = 0, o = 0; i &lt; n; i++) o += data[i][j][1]; if (o &gt; max) max = o; sums.push(o); } for (j = 0; j &lt; m; ++j) { y0[j] = (max - sums[j]) / 2; } return y0; }, wiggle: function(data) { var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = []; y0[0] = o = o0 = 0; for (j = 1; j &lt; m; ++j) { for (i = 0, s1 = 0; i &lt; n; ++i) s1 += data[i][j][1]; for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i &lt; n; ++i) { for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 dx); k &lt; i; ++k) { s3 += (data[k][j][1] - data[k][j - 1][1]) / dx; } s2 += s3 data[i][j][1]; } y0[j] = o -= s1 ? s2 / s1 dx : 0; if (o &lt; o0) o0 = o; } for (j = 0; j &lt; m; ++j) y0[j] -= o0; return y0; }, expand: function(data) { var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = []; for (j = 0; j &lt; m; ++j) { for (i = 0, o = 0; i &lt; n; i++) o += data[i][j][1]; if (o) for (i = 0; i &lt; n; i++) data[i][j][1] /= o; else for (i = 0; i &lt; n; i++) data[i][j][1] = k; } for (j = 0; j &lt; m; ++j) y0[j] = 0; return y0; }, zero: d3_layout_stackOffsetZero }); function d3_layout_stackOrderDefault(data) { return d3.range(data.length); } function d3_layout_stackOffsetZero(data) { var j = -1, m = data[0].length, y0 = []; while (++j &lt; m) y0[j] = 0; return y0; } function d3_layout_stackMaxIndex(array) { var i = 1, j = 0, v = array[0][1], k, n = array.length; for (;i &lt; n; ++i) { if ((k = array[i][1]) &gt; v) { j = i; v = k; } } return j; } function d3_layout_stackReduceSum(d) { return d.reduce(d3_layout_stackSum, 0); } function d3_layout_stackSum(p, d) { return p + d[1]; } d3.layout.histogram = function() { var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges; function histogram(data, i) { var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x; while (++i &lt; m) { bin = bins[i] = []; bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]); bin.y = 0; } if (m &gt; 0) { i = -1; while (++i &lt; n) { x = values[i]; if (x &gt;= range[0] &amp;&amp; x &lt;= range[1]) { bin = bins[d3.bisect(thresholds, x, 1, m) - 1]; bin.y += k; bin.push(data[i]); } } } return bins; } histogram.value = function(x) { if (!arguments.length) return valuer; valuer = x; return histogram; }; histogram.range = function(x) { if (!arguments.length) return ranger; ranger = d3_functor(x); return histogram; }; histogram.bins = function(x) { if (!arguments.length) return binner; binner = typeof x === “number” ? function(range) { return d3_layout_histogramBinFixed(range, x); } : d3_functor(x); return histogram; }; histogram.frequency = function(x) { if (!arguments.length) return frequency; frequency = !!x; return histogram; }; return histogram; }; function d3_layout_histogramBinSturges(range, values) { return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1)); } function d3_layout_histogramBinFixed(range, n) { var x = -1, b = +range[0], m = (range[1] - b) / n, f = []; while (++x &lt;= n) f[x] = m x + b; return f; } function d3_layout_histogramRange(values) { return [ d3.min(values), d3.max(values) ]; } d3.layout.pack = function() { var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius; function pack(d, i) { var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === “function” ? radius : function() { return radius; }; root.x = root.y = 0; d3_layout_hierarchyVisitAfter(root, function(d) { d.r = +r(d.value); }); d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings); if (padding) { var dr = padding (radius ? 1 : Math.max(2 root.r / w, 2 root.r / h)) / 2; d3_layout_hierarchyVisitAfter(root, function(d) { d.r += dr; }); d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings); d3_layout_hierarchyVisitAfter(root, function(d) { d.r -= dr; }); } d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 root.r / w, 2 root.r / h)); return nodes; } pack.size = function(_) { if (!arguments.length) return size; size = ; return pack; }; pack.radius = function() { if (!arguments.length) return radius; radius = _ == null || typeof _ === “function” ? _ : +; return pack; }; pack.padding = function() { if (!arguments.length) return padding; padding = +_; return pack; }; return d3_layout_hierarchyRebind(pack, hierarchy); }; function d3_layout_packSort(a, b) { return a.value - b.value; } function d3_layout_packInsert(a, b) { var c = a._pack_next; a._pack_next = b; b._pack_prev = a; b._pack_next = c; c._pack_prev = b; } function d3_layout_packSplice(a, b) { a._pack_next = b; b._pack_prev = a; } function d3_layout_packIntersects(a, b) { var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r; return .999 dr dr &gt; dx dx + dy dy; } function d3_layout_packSiblings(node) { if (!(nodes = node.children) || !(n = nodes.length)) return; var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n; function bound(node) { xMin = Math.min(node.x - node.r, xMin); xMax = Math.max(node.x + node.r, xMax); yMin = Math.min(node.y - node.r, yMin); yMax = Math.max(node.y + node.r, yMax); } nodes.forEach(d3_layout_packLink); a = nodes[0]; a.x = -a.r; a.y = 0; bound(a); if (n &gt; 1) { b = nodes[1]; b.x = b.r; b.y = 0; bound(b); if (n &gt; 2) { c = nodes[2]; d3_layout_packPlace(a, b, c); bound(c); d3_layout_packInsert(a, c); a._pack_prev = c; d3_layout_packInsert(c, b); b = a._pack_next; for (i = 3; i &lt; n; i++) { d3_layout_packPlace(a, b, c = nodes[i]); var isect = 0, s1 = 1, s2 = 1; for (j = b._pack_next; j !== b; j = j._pack_next, s1++) { if (d3_layout_packIntersects(j, c)) { isect = 1; break; } } if (isect == 1) { for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) { if (d3_layout_packIntersects(k, c)) { break; } } } if (isect) { if (s1 &lt; s2 || s1 == s2 &amp;&amp; b.r &lt; a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b); i–; } else { d3_layout_packInsert(a, c); b = c; bound(c); } } } } var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0; for (i = 0; i &lt; n; i++) { c = nodes[i]; c.x -= cx; c.y -= cy; cr = Math.max(cr, c.r + Math.sqrt(c.x c.x + c.y c.y)); } node.r = cr; nodes.forEach(d3_layout_packUnlink); } function d3_layout_packLink(node) { node._pack_next = node._pack_prev = node; } function d3_layout_packUnlink(node) { delete node._pack_next; delete node._pack_prev; } function d3_layout_packTransform(node, x, y, k) { var children = node.children; node.x = x += k node.x; node.y = y += k node.y; node.r = k; if (children) { var i = -1, n = children.length; while (++i &lt; n) d3_layout_packTransform(children[i], x, y, k); } } function d3_layout_packPlace(a, b, c) { var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y; if (db &amp;&amp; (dx || dy)) { var da = b.r + c.r, dc = dx dx + dy dy; da = da; db = db; var x = .5 + (db - da) / (2 dc), y = Math.sqrt(Math.max(0, 2 da (db + dc) - (db -= dc) db - da da)) / (2 dc); c.x = a.x + x dx + y dy; c.y = a.y + x dy - y dx; } else { c.x = a.x + db; c.y = a.y; } } d3.layout.tree = function() { var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null; function tree(d, i) { var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0); d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z; d3_layout_hierarchyVisitBefore(root1, secondWalk); if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else { var left = root0, right = root0, bottom = root0; d3_layout_hierarchyVisitBefore(root0, function(node) { if (node.x &lt; left.x) left = node; if (node.x &gt; right.x) right = node; if (node.depth &gt; bottom.depth) bottom = node; }); var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1); d3_layout_hierarchyVisitBefore(root0, function(node) { node.x = (node.x + tx) kx; node.y = node.depth ky; }); } return nodes; } function wrapTree(root0) { var root1 = { A: null, children: [ root0 ] }, queue = [ root1 ], node1; while ((node1 = queue.pop()) != null) { for (var children = node1.children, child, i = 0, n = children.length; i &lt; n; ++i) { queue.push((children[i] = child = { _: children[i], parent: node1, children: (child = children[i].children) &amp;&amp; child.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: i }).a = child); } } return root1.children[0]; } function firstWalk(v) { var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null; if (children.length) { d3_layout_treeShift(v); var midpoint = (children[0].z + children[children.length - 1].z) / 2; if (w) { v.z = w.z + separation(v., w.); v.m = v.z - midpoint; } else { v.z = midpoint; } } else if (w) { v.z = w.z + separation(v., w.); } v.parent.A = apportion(v, w, v.parent.A || siblings[0]); } function secondWalk(v) { v._.x = v.z + v.parent.m; v.m += v.parent.m; } function apportion(v, w, ancestor) { if (w) { var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift; while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim &amp;&amp; vip) { vom = d3_layout_treeLeft(vom); vop = d3_layout_treeRight(vop); vop.a = v; shift = vim.z + sim - vip.z - sip + separation(vim., vip.); if (shift &gt; 0) { d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift); sip += shift; sop += shift; } sim += vim.m; sip += vip.m; som += vom.m; sop += vop.m; } if (vim &amp;&amp; !d3_layout_treeRight(vop)) { vop.t = vim; vop.m += sim - sop; } if (vip &amp;&amp; !d3_layout_treeLeft(vom)) { vom.t = vip; vom.m += sip - som; ancestor = v; } } return ancestor; } function sizeNode(node) { node.x = size[0]; node.y = node.depth size[1]; } tree.separation = function(x) { if (!arguments.length) return separation; separation = x; return tree; }; tree.size = function(x) { if (!arguments.length) return nodeSize ? null : size; nodeSize = (size = x) == null ? sizeNode : null; return tree; }; tree.nodeSize = function(x) { if (!arguments.length) return nodeSize ? size : null; nodeSize = (size = x) == null ? null : sizeNode; return tree; }; return d3_layout_hierarchyRebind(tree, hierarchy); }; function d3_layout_treeSeparation(a, b) { return a.parent == b.parent ? 1 : 2; } function d3_layout_treeLeft(v) { var children = v.children; return children.length ? children[0] : v.t; } function d3_layout_treeRight(v) { var children = v.children, n; return (n = children.length) ? children[n - 1] : v.t; } function d3_layout_treeMove(wm, wp, shift) { var change = shift / (wp.i - wm.i); wp.c -= change; wp.s += shift; wm.c += change; wp.z += shift; wp.m += shift; } function d3_layout_treeShift(v) { var shift = 0, change = 0, children = v.children, i = children.length, w; while (–i &gt;= 0) { w = children[i]; w.z += shift; w.m += shift; shift += w.s + (change += w.c); } } function d3_layout_treeAncestor(vim, v, ancestor) { return vim.a.parent === v.parent ? vim.a : ancestor; } d3.layout.cluster = function() { var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false; function cluster(d, i) { var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0; d3_layout_hierarchyVisitAfter(root, function(node) { var children = node.children; if (children &amp;&amp; children.length) { node.x = d3_layout_clusterX(children); node.y = d3_layout_clusterY(children); } else { node.x = previousNode ? x += separation(node, previousNode) : 0; node.y = 0; previousNode = node; } }); var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2; d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) { node.x = (node.x - root.x) size[0]; node.y = (root.y - node.y) size[1]; } : function(node) { node.x = (node.x - x0) / (x1 - x0) size[0]; node.y = (1 - (root.y ? node.y / root.y : 1)) size[1]; }); return nodes; } cluster.separation = function(x) { if (!arguments.length) return separation; separation = x; return cluster; }; cluster.size = function(x) { if (!arguments.length) return nodeSize ? null : size; nodeSize = (size = x) == null; return cluster; }; cluster.nodeSize = function(x) { if (!arguments.length) return nodeSize ? size : null; nodeSize = (size = x) != null; return cluster; }; return d3_layout_hierarchyRebind(cluster, hierarchy); }; function d3_layout_clusterY(children) { return 1 + d3.max(children, function(child) { return child.y; }); } function d3_layout_clusterX(children) { return children.reduce(function(x, child) { return x + child.x; }, 0) / children.length; } function d3_layout_clusterLeft(node) { var children = node.children; return children &amp;&amp; children.length ? d3_layout_clusterLeft(children[0]) : node; } function d3_layout_clusterRight(node) { var children = node.children, n; return children &amp;&amp; (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node; } d3.layout.treemap = function() { var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = “squarify”, ratio = .5 (1 + Math.sqrt(5)); function scale(children, k) { var i = -1, n = children.length, child, area; while (++i &lt; n) { area = (child = children[i]).value (k &lt; 0 ? 0 : k); child.area = isNaN(area) || area &lt;= 0 ? 0 : area; } } function squarify(node) { var children = node.children; if (children &amp;&amp; children.length) { var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === “slice” ? rect.dx : mode === “dice” ? rect.dy : mode === “slice-dice” ? node.depth &amp; 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n; scale(remaining, rect.dx rect.dy / node.value); row.area = 0; while ((n = remaining.length) &gt; 0) { row.push(child = remaining[n - 1]); row.area += child.area; if (mode !== “squarify” || (score = worst(row, u)) &lt;= best) { remaining.pop(); best = score; } else { row.area -= row.pop().area; position(row, u, rect, false); u = Math.min(rect.dx, rect.dy); row.length = row.area = 0; best = Infinity; } } if (row.length) { position(row, u, rect, true); row.length = row.area = 0; } children.forEach(squarify); } } function stickify(node) { var children = node.children; if (children &amp;&amp; children.length) { var rect = pad(node), remaining = children.slice(), child, row = []; scale(remaining, rect.dx rect.dy / node.value); row.area = 0; while (child = remaining.pop()) { row.push(child); row.area += child.area; if (child.z != null) { position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length); row.length = row.area = 0; } } children.forEach(stickify); } } function worst(row, u) { var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length; while (++i &lt; n) { if (!(r = row[i].area)) continue; if (r &lt; rmin) rmin = r; if (r &gt; rmax) rmax = r; } s = s; u = u; return s ? Math.max(u rmax ratio / s, s / (u rmin ratio)) : Infinity; } function position(row, u, rect, flush) { var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o; if (u == rect.dx) { if (flush || v &gt; rect.dy) v = rect.dy; while (++i &lt; n) { o = row[i]; o.x = x; o.y = y; o.dy = v; x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0); } o.z = true; o.dx += rect.x + rect.dx - x; rect.y += v; rect.dy -= v; } else { if (flush || v &gt; rect.dx) v = rect.dx; while (++i &lt; n) { o = row[i]; o.x = x; o.y = y; o.dx = v; y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0); } o.z = false; o.dy += rect.y + rect.dy - y; rect.x += v; rect.dx -= v; } } function treemap(d) { var nodes = stickies || hierarchy(d), root = nodes[0]; root.x = root.y = 0; if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0; if (stickies) hierarchy.revalue(root); scale([ root ], root.dx root.dy / root.value); (stickies ? stickify : squarify)(root); if (sticky) stickies = nodes; return nodes; } treemap.size = function(x) { if (!arguments.length) return size; size = x; return treemap; }; treemap.padding = function(x) { if (!arguments.length) return padding; function padFunction(node) { var p = x.call(treemap, node, node.depth); return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === “number” ? [ p, p, p, p ] : p); } function padConstant(node) { return d3_layout_treemapPad(node, x); } var type; pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === “function” ? padFunction : type === “number” ? (x = [ x, x, x, x ], padConstant) : padConstant; return treemap; }; treemap.round = function(x) { if (!arguments.length) return round != Number; round = x ? Math.round : Number; return treemap; }; treemap.sticky = function(x) { if (!arguments.length) return sticky; sticky = x; stickies = null; return treemap; }; treemap.ratio = function(x) { if (!arguments.length) return ratio; ratio = x; return treemap; }; treemap.mode = function(x) { if (!arguments.length) return mode; mode = x + “”; return treemap; }; return d3_layout_hierarchyRebind(treemap, hierarchy); }; function d3_layout_treemapPadNull(node) { return { x: node.x, y: node.y, dx: node.dx, dy: node.dy }; } function d3_layout_treemapPad(node, padding) { var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2]; if (dx &lt; 0) { x += dx / 2; dx = 0; } if (dy &lt; 0) { y += dy / 2; dy = 0; } return { x: x, y: y, dx: dx, dy: dy }; } d3.random = { normal: function(µ, σ) { var n = arguments.length; if (n &lt; 2) σ = 1; if (n &lt; 1) µ = 0; return function() { var x, y, r; do { x = Math.random() 2 - 1; y = Math.random() 2 - 1; r = x x + y y; } while (!r || r &gt; 1); return µ + σ x Math.sqrt(-2 Math.log(r) / r); }; }, logNormal: function() { var random = d3.random.normal.apply(d3, arguments); return function() { return Math.exp(random()); }; }, bates: function(m) { var random = d3.random.irwinHall(m); return function() { return random() / m; }; }, irwinHall: function(m) { return function() { for (var s = 0, j = 0; j &lt; m; j++) s += Math.random(); return s; }; } }; d3.scale = {}; function d3_scaleExtent(domain) { var start = domain[0], stop = domain[domain.length - 1]; return start &lt; stop ? [ start, stop ] : [ stop, start ]; } function d3_scaleRange(scale) { return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range()); } function d3_scale_bilinear(domain, range, uninterpolate, interpolate) { var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]); return function(x) { return i(u(x)); }; } function d3_scale_nice(domain, nice) { var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx; if (x1 &lt; x0) { dx = i0, i0 = i1, i1 = dx; dx = x0, x0 = x1, x1 = dx; } domain[i0] = nice.floor(x0); domain[i1] = nice.ceil(x1); return domain; } function d3_scale_niceStep(step) { return step ? { floor: function(x) { return Math.floor(x / step) step; }, ceil: function(x) { return Math.ceil(x / step) step; } } : d3_scale_niceIdentity; } var d3_scale_niceIdentity = { floor: d3_identity, ceil: d3_identity }; function d3_scale_polylinear(domain, range, uninterpolate, interpolate) { var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1; if (domain[k] &lt; domain[0]) { domain = domain.slice().reverse(); range = range.slice().reverse(); } while (++j &lt;= k) { u.push(uninterpolate(domain[j - 1], domain[j])); i.push(interpolate(range[j - 1], range[j])); } return function(x) { var j = d3.bisect(domain, x, 1, k) - 1; return ij); }; } d3.scale.linear = function() { return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false); }; function d3_scale_linear(domain, range, interpolate, clamp) { var output, input; function rescale() { var linear = Math.min(domain.length, range.length) &gt; 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber; output = linear(domain, range, uninterpolate, interpolate); input = linear(range, domain, uninterpolate, d3_interpolate); return scale; } function scale(x) { return output(x); } scale.invert = function(y) { return input(y); }; scale.domain = function(x) { if (!arguments.length) return domain; domain = x.map(Number); return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.rangeRound = function(x) { return scale.range(x).interpolate(d3_interpolateRound); }; scale.clamp = function(x) { if (!arguments.length) return clamp; clamp = x; return rescale(); }; scale.interpolate = function(x) { if (!arguments.length) return interpolate; interpolate = x; return rescale(); }; scale.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; scale.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; scale.nice = function(m) { d3_scale_linearNice(domain, m); return rescale(); }; scale.copy = function() { return d3_scale_linear(domain, range, interpolate, clamp); }; return rescale(); } function d3_scale_linearRebind(scale, linear) { return d3.rebind(scale, linear, “range”, “rangeRound”, “interpolate”, “clamp”); } function d3_scale_linearNice(domain, m) { d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2])); d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2])); return domain; } function d3_scale_linearTickRange(domain, m) { if (m == null) m = 10; var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span step; if (err &lt;= .15) step = 10; else if (err &lt;= .35) step = 5; else if (err &lt;= .75) step = 2; extent[0] = Math.ceil(extent[0] / step) step; extent[1] = Math.floor(extent[1] / step) step + step .5; extent[2] = step; return extent; } function d3_scale_linearTicks(domain, m) { return d3.range.apply(d3, d3_scale_linearTickRange(domain, m)); } function d3_scale_linearTickFormat(domain, m, format) { var range = d3_scale_linearTickRange(domain, m); if (format) { var match = d3_format_re.exec(format); match.shift(); if (match[8] === “s”) { var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1]))); if (!match[7]) match[7] = “.” + d3_scale_linearPrecision(prefix.scale(range[2])); match[8] = “f”; format = d3.format(match.join(“”)); return function(d) { return format(prefix.scale(d)) + prefix.symbol; }; } if (!match[7]) match[7] = “.” + d3_scale_linearFormatPrecision(match[8], range); format = match.join(“”); } else { format = “,.” + d3_scale_linearPrecision(range[2]) + “f”; } return d3.format(format); } var d3_scale_linearFormatSignificant = { s: 1, g: 1, p: 1, r: 1, e: 1 }; function d3_scale_linearPrecision(value) { return -Math.floor(Math.log(value) / Math.LN10 + .01); } function d3_scale_linearFormatPrecision(type, range) { var p = d3_scale_linearPrecision(range[2]); return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== “e”) : p - (type === “%”) 2; } d3.scale.log = function() { return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]); }; function d3_scale_log(linear, base, positive, domain) { function log(x) { return (positive ? Math.log(x &lt; 0 ? 0 : x) : -Math.log(x &gt; 0 ? 0 : -x)) / Math.log(base); } function pow(x) { return positive ? Math.pow(base, x) : -Math.pow(base, -x); } function scale(x) { return linear(log(x)); } scale.invert = function(x) { return pow(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return domain; positive = x[0] &gt;= 0; linear.domain((domain = x.map(Number)).map(log)); return scale; }; scale.base = function() { if (!arguments.length) return base; base = +; linear.domain(domain.map(log)); return scale; }; scale.nice = function() { var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative); linear.domain(niced); domain = niced.map(pow); return scale; }; scale.ticks = function() { var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base; if (isFinite(j - i)) { if (positive) { for (;i &lt; j; i++) for (var k = 1; k &lt; n; k++) ticks.push(pow(i) k); ticks.push(pow(i)); } else { ticks.push(pow(i)); for (;i++ &lt; j; ) for (var k = n - 1; k &gt; 0; k–) ticks.push(pow(i) k); } for (i = 0; ticks[i] &lt; u; i++) {} for (j = ticks.length; ticks[j - 1] &gt; v; j–) {} ticks = ticks.slice(i, j); } return ticks; }; scale.tickFormat = function(n, format) { if (!arguments.length) return d3_scale_logFormat; if (arguments.length &lt; 2) format = d3_scale_logFormat; else if (typeof format !== “function”) format = d3.format(format); var k = Math.max(1, base n / scale.ticks().length); return function(d) { var i = d / pow(Math.round(log(d))); if (i base &lt; base - .5) i = base; return i &lt;= k ? format(d) : “”; }; }; scale.copy = function() { return d3_scale_log(linear.copy(), base, positive, domain); }; return d3_scale_linearRebind(scale, linear); } var d3_scale_logFormat = d3.format(“.0e”), d3_scale_logNiceNegative = { floor: function(x) { return -Math.ceil(-x); }, ceil: function(x) { return -Math.floor(-x); } }; d3.scale.pow = function() { return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]); }; function d3_scale_pow(linear, exponent, domain) { var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent); function scale(x) { return linear(powp(x)); } scale.invert = function(x) { return powb(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return domain; linear.domain((domain = x.map(Number)).map(powp)); return scale; }; scale.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; scale.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; scale.nice = function(m) { return scale.domain(d3_scale_linearNice(domain, m)); }; scale.exponent = function(x) { if (!arguments.length) return exponent; powp = d3_scale_powPow(exponent = x); powb = d3_scale_powPow(1 / exponent); linear.domain(domain.map(powp)); return scale; }; scale.copy = function() { return d3_scale_pow(linear.copy(), exponent, domain); }; return d3_scale_linearRebind(scale, linear); } function d3_scale_powPow(e) { return function(x) { return x &lt; 0 ? -Math.pow(-x, e) : Math.pow(x, e); }; } d3.scale.sqrt = function() { return d3.scale.pow().exponent(.5); }; d3.scale.ordinal = function() { return d3_scale_ordinal([], { t: “range”, a: [ [] ] }); }; function d3_scale_ordinal(domain, ranger) { var index, range, rangeBand; function scale(x) { return range[((index.get(x) || (ranger.t === “range” ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length]; } function steps(start, step) { return d3.range(domain.length).map(function(i) { return start + step i; }); } scale.domain = function(x) { if (!arguments.length) return domain; domain = []; index = new d3_Map(); var i = -1, n = x.length, xi; while (++i &lt; n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi)); return scale[ranger.t].apply(scale, ranger.a); }; scale.range = function(x) { if (!arguments.length) return range; range = x; rangeBand = 0; ranger = { t: “range”, a: arguments }; return scale; }; scale.rangePoints = function(x, padding) { if (arguments.length &lt; 2) padding = 0; var start = x[0], stop = x[1], step = domain.length &lt; 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding); range = steps(start + step padding / 2, step); rangeBand = 0; ranger = { t: “rangePoints”, a: arguments }; return scale; }; scale.rangeRoundPoints = function(x, padding) { if (arguments.length &lt; 2) padding = 0; var start = x[0], stop = x[1], step = domain.length &lt; 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0; range = steps(start + Math.round(step padding / 2 + (stop - start - (domain.length - 1 + padding) step) / 2), step); rangeBand = 0; ranger = { t: “rangeRoundPoints”, a: arguments }; return scale; }; scale.rangeBands = function(x, padding, outerPadding) { if (arguments.length &lt; 2) padding = 0; if (arguments.length &lt; 3) outerPadding = padding; var reverse = x[1] &lt; x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 outerPadding); range = steps(start + step outerPadding, step); if (reverse) range.reverse(); rangeBand = step (1 - padding); ranger = { t: “rangeBands”, a: arguments }; return scale; }; scale.rangeRoundBands = function(x, padding, outerPadding) { if (arguments.length &lt; 2) padding = 0; if (arguments.length &lt; 3) outerPadding = padding; var reverse = x[1] &lt; x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 outerPadding)); range = steps(start + Math.round((stop - start - (domain.length - padding) step) / 2), step); if (reverse) range.reverse(); rangeBand = Math.round(step (1 - padding)); ranger = { t: “rangeRoundBands”, a: arguments }; return scale; }; scale.rangeBand = function() { return rangeBand; }; scale.rangeExtent = function() { return d3_scaleExtent(ranger.a[0]); }; scale.copy = function() { return d3_scale_ordinal(domain, ranger); }; return scale.domain(domain); } d3.scale.category10 = function() { return d3.scale.ordinal().range(d3_category10); }; d3.scale.category20 = function() { return d3.scale.ordinal().range(d3_category20); }; d3.scale.category20b = function() { return d3.scale.ordinal().range(d3_category20b); }; d3.scale.category20c = function() { return d3.scale.ordinal().range(d3_category20c); }; var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString); var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString); var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString); var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString); d3.scale.quantile = function() { return d3_scale_quantile([], []); }; function d3_scale_quantile(domain, range) { var thresholds; function rescale() { var k = 0, q = range.length; thresholds = []; while (++k &lt; q) thresholds[k - 1] = d3.quantile(domain, k / q); return scale; } function scale(x) { if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)]; } scale.domain = function(x) { if (!arguments.length) return domain; domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending); return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.quantiles = function() { return thresholds; }; scale.invertExtent = function(y) { y = range.indexOf(y); return y &lt; 0 ? [ NaN, NaN ] : [ y &gt; 0 ? thresholds[y - 1] : domain[0], y &lt; thresholds.length ? thresholds[y] : domain[domain.length - 1] ]; }; scale.copy = function() { return d3_scale_quantile(domain, range); }; return rescale(); } d3.scale.quantize = function() { return d3_scale_quantize(0, 1, [ 0, 1 ]); }; function d3_scale_quantize(x0, x1, range) { var kx, i; function scale(x) { return range[Math.max(0, Math.min(i, Math.floor(kx (x - x0))))]; } function rescale() { kx = range.length / (x1 - x0); i = range.length - 1; return scale; } scale.domain = function(x) { if (!arguments.length) return [ x0, x1 ]; x0 = +x[0]; x1 = +x[x.length - 1]; return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.invertExtent = function(y) { y = range.indexOf(y); y = y &lt; 0 ? NaN : y / kx + x0; return [ y, y + 1 / kx ]; }; scale.copy = function() { return d3_scale_quantize(x0, x1, range); }; return rescale(); } d3.scale.threshold = function() { return d3_scale_threshold([ .5 ], [ 0, 1 ]); }; function d3_scale_threshold(domain, range) { function scale(x) { if (x &lt;= x) return range[d3.bisect(domain, x)]; } scale.domain = function(_) { if (!arguments.length) return domain; domain = ; return scale; }; scale.range = function() { if (!arguments.length) return range; range = _; return scale; }; scale.invertExtent = function(y) { y = range.indexOf(y); return [ domain[y - 1], domain[y] ]; }; scale.copy = function() { return d3_scale_threshold(domain, range); }; return scale; } d3.scale.identity = function() { return d3_scale_identity([ 0, 1 ]); }; function d3_scale_identity(domain) { function identity(x) { return +x; } identity.invert = identity; identity.domain = identity.range = function(x) { if (!arguments.length) return domain; domain = x.map(identity); return identity; }; identity.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; identity.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; identity.copy = function() { return d3_scale_identity(domain); }; return identity; } d3.svg = {}; function d3_zero() { return 0; } d3.svg.arc = function() { var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle; function arc() { var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 &gt; a1 ? 0 : 1; if (r1 &lt; r0) rc = r1, r1 = r0, r0 = rc; if (da &gt;= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : “”) + “Z”; var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = []; if (ap = (+padAngle.apply(this, arguments) || 0) / 2) { rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 r0 + r1 r1) : +padRadius.apply(this, arguments); if (!cw) p1 = -1; if (r1) p1 = d3_asin(rp / r1 Math.sin(ap)); if (r0) p0 = d3_asin(rp / r0 Math.sin(ap)); } if (r1) { x0 = r1 Math.cos(a0 + p1); y0 = r1 Math.sin(a0 + p1); x1 = r1 Math.cos(a1 - p1); y1 = r1 Math.sin(a1 - p1); var l1 = Math.abs(a1 - a0 - 2 p1) &lt;= π ? 0 : 1; if (p1 &amp;&amp; d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) { var h1 = (a0 + a1) / 2; x0 = r1 Math.cos(h1); y0 = r1 Math.sin(h1); x1 = y1 = null; } } else { x0 = y0 = 0; } if (r0) { x2 = r0 Math.cos(a1 - p0); y2 = r0 Math.sin(a1 - p0); x3 = r0 Math.cos(a0 + p0); y3 = r0 Math.sin(a0 + p0); var l0 = Math.abs(a0 - a1 + 2 p0) &lt;= π ? 0 : 1; if (p0 &amp;&amp; d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) { var h0 = (a0 + a1) / 2; x2 = r0 Math.cos(h0); y2 = r0 Math.sin(h0); x3 = y3 = null; } } else { x2 = y2 = 0; } if (da &gt; ε &amp;&amp; (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) &gt; .001) { cr = r0 &lt; r1 ^ cw ? 0 : 1; var rc1 = rc, rc0 = rc; if (da &lt; π) { var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax bx + ay by) / (Math.sqrt(ax ax + ay ay) Math.sqrt(bx bx + by by))) / 2), lc = Math.sqrt(oc[0] oc[0] + oc[1] oc[1]); rc0 = Math.min(rc, (r0 - lc) / (kc - 1)); rc1 = Math.min(rc, (r1 - lc) / (kc + 1)); } if (x1 != null) { var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw); if (rc === rc1) { path.push(“M”, t30[0], “A”, rc1, “,”, rc1, “ 0 0,”, cr, “ “, t30[1], “A”, r1, “,”, r1, “ 0 “, 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), “,”, cw, “ “, t12[1], “A”, rc1, “,”, rc1, “ 0 0,”, cr, “ “, t12[0]); } else { path.push(“M”, t30[0], “A”, rc1, “,”, rc1, “ 0 1,”, cr, “ “, t12[0]); } } else { path.push(“M”, x0, “,”, y0); } if (x3 != null) { var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw); if (rc === rc0) { path.push(“L”, t21[0], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t21[1], “A”, r0, “,”, r0, “ 0 “, cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), “,”, 1 - cw, “ “, t03[1], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t03[0]); } else { path.push(“L”, t21[0], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t03[0]); } } else { path.push(“L”, x2, “,”, y2); } } else { path.push(“M”, x0, “,”, y0); if (x1 != null) path.push(“A”, r1, “,”, r1, “ 0 “, l1, “,”, cw, “ “, x1, “,”, y1); path.push(“L”, x2, “,”, y2); if (x3 != null) path.push(“A”, r0, “,”, r0, “ 0 “, l0, “,”, 1 - cw, “ “, x3, “,”, y3); } path.push(“Z”); return path.join(“”); } function circleSegment(r1, cw) { return “M0,” + r1 + “A” + r1 + “,” + r1 + “ 0 1,” + cw + “ 0,” + -r1 + “A” + r1 + “,” + r1 + “ 0 1,” + cw + “ 0,” + r1; } arc.innerRadius = function(v) { if (!arguments.length) return innerRadius; innerRadius = d3_functor(v); return arc; }; arc.outerRadius = function(v) { if (!arguments.length) return outerRadius; outerRadius = d3_functor(v); return arc; }; arc.cornerRadius = function(v) { if (!arguments.length) return cornerRadius; cornerRadius = d3_functor(v); return arc; }; arc.padRadius = function(v) { if (!arguments.length) return padRadius; padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v); return arc; }; arc.startAngle = function(v) { if (!arguments.length) return startAngle; startAngle = d3_functor(v); return arc; }; arc.endAngle = function(v) { if (!arguments.length) return endAngle; endAngle = d3_functor(v); return arc; }; arc.padAngle = function(v) { if (!arguments.length) return padAngle; padAngle = d3_functor(v); return arc; }; arc.centroid = function() { var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ; return [ Math.cos(a) r, Math.sin(a) r ]; }; return arc; }; var d3_svg_arcAuto = “auto”; function d3_svg_arcInnerRadius(d) { return d.innerRadius; } function d3_svg_arcOuterRadius(d) { return d.outerRadius; } function d3_svg_arcStartAngle(d) { return d.startAngle; } function d3_svg_arcEndAngle(d) { return d.endAngle; } function d3_svg_arcPadAngle(d) { return d &amp;&amp; d.padAngle; } function d3_svg_arcSweep(x0, y0, x1, y1) { return (x0 - x1) y0 - (y0 - y1) x0 &gt; 0 ? 0 : 1; } function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) { var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 x01 + y01 y01), ox = lo y01, oy = -lo x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx dx + dy dy, r = r1 - rc, D = x1 y2 - x2 y1, d = (dy &lt; 0 ? -1 : 1) Math.sqrt(Math.max(0, r r d2 - D D)), cx0 = (D dy - dx d) / d2, cy0 = (-D dx - dy d) / d2, cx1 = (D dy + dx d) / d2, cy1 = (-D dx + dy d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3; if (dx0 dx0 + dy0 dy0 &gt; dx1 dx1 + dy1 dy1) cx0 = cx1, cy0 = cy1; return [ [ cx0 - ox, cy0 - oy ], [ cx0 r1 / r, cy0 r1 / r ] ]; } function d3_svg_line(projection) { var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7; function line(data) { var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y); function segment() { segments.push(“M”, interpolate(projection(points), tension)); } while (++i &lt; n) { if (defined.call(this, d = data[i], i)) { points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]); } else if (points.length) { segment(); points = []; } } if (points.length) segment(); return segments.length ? segments.join(“”) : null; } line.x = function(_) { if (!arguments.length) return x; x = ; return line; }; line.y = function() { if (!arguments.length) return y; y = ; return line; }; line.defined = function() { if (!arguments.length) return defined; defined = ; return line; }; line.interpolate = function() { if (!arguments.length) return interpolateKey; if (typeof _ === “function”) interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key; return line; }; line.tension = function(_) { if (!arguments.length) return tension; tension = _; return line; }; return line; } d3.svg.line = function() { return d3_svg_line(d3_identity); }; var d3_svg_lineInterpolators = d3.map({ linear: d3_svg_lineLinear, “linear-closed”: d3_svg_lineLinearClosed, step: d3_svg_lineStep, “step-before”: d3_svg_lineStepBefore, “step-after”: d3_svg_lineStepAfter, basis: d3_svg_lineBasis, “basis-open”: d3_svg_lineBasisOpen, “basis-closed”: d3_svg_lineBasisClosed, bundle: d3_svg_lineBundle, cardinal: d3_svg_lineCardinal, “cardinal-open”: d3_svg_lineCardinalOpen, “cardinal-closed”: d3_svg_lineCardinalClosed, monotone: d3_svg_lineMonotone }); d3_svg_lineInterpolators.forEach(function(key, value) { value.key = key; value.closed = /-closed$/.test(key); }); function d3_svg_lineLinear(points) { return points.length &gt; 1 ? points.join(“L”) : points + “Z”; } function d3_svg_lineLinearClosed(points) { return points.join(“L”) + “Z”; } function d3_svg_lineStep(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“H”, (p[0] + (p = points[i])[0]) / 2, “V”, p[1]); if (n &gt; 1) path.push(“H”, p[0]); return path.join(“”); } function d3_svg_lineStepBefore(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“V”, (p = points[i])[1], “H”, p[0]); return path.join(“”); } function d3_svg_lineStepAfter(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“H”, (p = points[i])[0], “V”, p[1]); return path.join(“”); } function d3_svg_lineCardinalOpen(points, tension) { return points.length &lt; 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension)); } function d3_svg_lineCardinalClosed(points, tension) { return points.length &lt; 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension)); } function d3_svg_lineCardinal(points, tension) { return points.length &lt; 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension)); } function d3_svg_lineHermite(points, tangents) { if (tangents.length &lt; 1 || points.length != tangents.length &amp;&amp; points.length != tangents.length + 2) { return d3_svg_lineLinear(points); } var quad = points.length != tangents.length, path = “”, p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1; if (quad) { path += “Q” + (p[0] - t0[0] 2 / 3) + “,” + (p[1] - t0[1] 2 / 3) + “,” + p[0] + “,” + p[1]; p0 = points[1]; pi = 2; } if (tangents.length &gt; 1) { t = tangents[1]; p = points[pi]; pi++; path += “C” + (p0[0] + t0[0]) + “,” + (p0[1] + t0[1]) + “,” + (p[0] - t[0]) + “,” + (p[1] - t[1]) + “,” + p[0] + “,” + p[1]; for (var i = 2; i &lt; tangents.length; i++, pi++) { p = points[pi]; t = tangents[i]; path += “S” + (p[0] - t[0]) + “,” + (p[1] - t[1]) + “,” + p[0] + “,” + p[1]; } } if (quad) { var lp = points[pi]; path += “Q” + (p[0] + t[0] 2 / 3) + “,” + (p[1] + t[1] 2 / 3) + “,” + lp[0] + “,” + lp[1]; } return path; } function d3_svg_lineCardinalTangents(points, tension) { var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length; while (++i &lt; n) { p0 = p1; p1 = p2; p2 = points[i]; tangents.push([ a (p2[0] - p0[0]), a (p2[1] - p0[1]) ]); } return tangents; } function d3_svg_lineBasis(points) { if (points.length &lt; 3) return d3_svg_lineLinear(points); var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, “,”, y0, “L”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ]; points.push(points[n - 1]); while (++i &lt;= n) { pi = points[i]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } points.pop(); path.push(“L”, pi); return path.join(“”); } function d3_svg_lineBasisOpen(points) { if (points.length &lt; 4) return d3_svg_lineLinear(points); var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ]; while (++i &lt; 3) { pi = points[i]; px.push(pi[0]); py.push(pi[1]); } path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + “,” + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)); –i; while (++i &lt; n) { pi = points[i]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } return path.join(“”); } function d3_svg_lineBasisClosed(points) { var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = []; while (++i &lt; 4) { pi = points[i % n]; px.push(pi[0]); py.push(pi[1]); } path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ]; –i; while (++i &lt; m) { pi = points[i % n]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } return path.join(“”); } function d3_svg_lineBundle(points, tension) { var n = points.length - 1; if (n) { var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t; while (++i &lt;= n) { p = points[i]; t = i / n; p[0] = tension p[0] + (1 - tension) (x0 + t dx); p[1] = tension p[1] + (1 - tension) (y0 + t dy); } } return d3_svg_lineBasis(points); } function d3_svg_lineDot4(a, b) { return a[0] b[0] + a[1] b[1] + a[2] b[2] + a[3] b[3]; } var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ]; function d3_svg_lineBasisBezier(path, x, y) { path.push(“C”, d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, y)); } function d3_svg_lineSlope(p0, p1) { return (p1[1] - p0[1]) / (p1[0] - p0[0]); } function d3_svg_lineFiniteDifferences(points) { var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1); while (++i &lt; j) { m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2; } m[i] = d; return m; } function d3_svg_lineMonotoneTangents(points) { var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1; while (++i &lt; j) { d = d3_svg_lineSlope(points[i], points[i + 1]); if (abs(d) &lt; ε) { m[i] = m[i + 1] = 0; } else { a = m[i] / d; b = m[i + 1] / d; s = a a + b b; if (s &gt; 9) { s = d 3 / Math.sqrt(s); m[i] = s a; m[i + 1] = s b; } } } i = -1; while (++i &lt;= j) { s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 (1 + m[i] m[i])); tangents.push([ s || 0, m[i] s || 0 ]); } return tangents; } function d3_svg_lineMonotone(points) { return points.length &lt; 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points)); } d3.svg.line.radial = function() { var line = d3_svg_line(d3_svg_lineRadial); line.radius = line.x, delete line.x; line.angle = line.y, delete line.y; return line; }; function d3_svg_lineRadial(points) { var point, i = -1, n = points.length, r, a; while (++i &lt; n) { point = points[i]; r = point[0]; a = point[1] - halfπ; point[0] = r Math.cos(a); point[1] = r Math.sin(a); } return points; } function d3_svg_area(projection) { var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = “L”, tension = .7; function area(data) { var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() { return x; } : d3_functor(x1), fy1 = y0 === y1 ? function() { return y; } : d3_functor(y1), x, y; function segment() { segments.push(“M”, interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), “Z”); } while (++i &lt; n) { if (defined.call(this, d = data[i], i)) { points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]); points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]); } else if (points0.length) { segment(); points0 = []; points1 = []; } } if (points0.length) segment(); return segments.length ? segments.join(“”) : null; } area.x = function(_) { if (!arguments.length) return x1; x0 = x1 = ; return area; }; area.x0 = function() { if (!arguments.length) return x0; x0 = ; return area; }; area.x1 = function() { if (!arguments.length) return x1; x1 = ; return area; }; area.y = function() { if (!arguments.length) return y1; y0 = y1 = ; return area; }; area.y0 = function() { if (!arguments.length) return y0; y0 = ; return area; }; area.y1 = function() { if (!arguments.length) return y1; y1 = ; return area; }; area.defined = function() { if (!arguments.length) return defined; defined = ; return area; }; area.interpolate = function() { if (!arguments.length) return interpolateKey; if (typeof _ === “function”) interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key; interpolateReverse = interpolate.reverse || interpolate; L = interpolate.closed ? “M” : “L”; return area; }; area.tension = function(_) { if (!arguments.length) return tension; tension = _; return area; }; return area; } d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter; d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore; d3.svg.area = function() { return d3_svg_area(d3_identity); }; d3.svg.area.radial = function() { var area = d3_svg_area(d3_svg_lineRadial); area.radius = area.x, delete area.x; area.innerRadius = area.x0, delete area.x0; area.outerRadius = area.x1, delete area.x1; area.angle = area.y, delete area.y; area.startAngle = area.y0, delete area.y0; area.endAngle = area.y1, delete area.y1; return area; }; d3.svg.chord = function() { var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle; function chord(d, i) { var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i); return “M” + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + “Z”; } function subgroup(self, f, d, i) { var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ; return { r: r, a0: a0, a1: a1, p0: [ r Math.cos(a0), r Math.sin(a0) ], p1: [ r Math.cos(a1), r Math.sin(a1) ] }; } function equals(a, b) { return a.a0 == b.a0 &amp;&amp; a.a1 == b.a1; } function arc(r, p, a) { return “A” + r + “,” + r + “ 0 “ + +(a &gt; π) + “,1 “ + p; } function curve(r0, p0, r1, p1) { return “Q 0,0 “ + p1; } chord.radius = function(v) { if (!arguments.length) return radius; radius = d3_functor(v); return chord; }; chord.source = function(v) { if (!arguments.length) return source; source = d3_functor(v); return chord; }; chord.target = function(v) { if (!arguments.length) return target; target = d3_functor(v); return chord; }; chord.startAngle = function(v) { if (!arguments.length) return startAngle; startAngle = d3_functor(v); return chord; }; chord.endAngle = function(v) { if (!arguments.length) return endAngle; endAngle = d3_functor(v); return chord; }; return chord; }; function d3_svg_chordRadius(d) { return d.radius; } d3.svg.diagonal = function() { var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection; function diagonal(d, i) { var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, { x: p0.x, y: m }, { x: p3.x, y: m }, p3 ]; p = p.map(projection); return “M” + p[0] + “C” + p[1] + “ “ + p[2] + “ “ + p[3]; } diagonal.source = function(x) { if (!arguments.length) return source; source = d3_functor(x); return diagonal; }; diagonal.target = function(x) { if (!arguments.length) return target; target = d3_functor(x); return diagonal; }; diagonal.projection = function(x) { if (!arguments.length) return projection; projection = x; return diagonal; }; return diagonal; }; function d3_svg_diagonalProjection(d) { return [ d.x, d.y ]; } d3.svg.diagonal.radial = function() { var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection; diagonal.projection = function(x) { return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection; }; return diagonal; }; function d3_svg_diagonalRadialProjection(projection) { return function() { var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ; return [ r Math.cos(a), r Math.sin(a) ]; }; } d3.svg.symbol = function() { var type = d3_svg_symbolType, size = d3_svg_symbolSize; function symbol(d, i) { return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i)); } symbol.type = function(x) { if (!arguments.length) return type; type = d3_functor(x); return symbol; }; symbol.size = function(x) { if (!arguments.length) return size; size = d3_functor(x); return symbol; }; return symbol; }; function d3_svg_symbolSize() { return 64; } function d3_svg_symbolType() { return “circle”; } function d3_svg_symbolCircle(size) { var r = Math.sqrt(size / π); return “M0,” + r + “A” + r + “,” + r + “ 0 1,1 0,” + -r + “A” + r + “,” + r + “ 0 1,1 0,” + r + “Z”; } var d3_svg_symbols = d3.map({ circle: d3_svg_symbolCircle, cross: function(size) { var r = Math.sqrt(size / 5) / 2; return “M” + -3 r + “,” + -r + “H” + -r + “V” + -3 r + “H” + r + “V” + -r + “H” + 3 r + “V” + r + “H” + r + “V” + 3 r + “H” + -r + “V” + r + “H” + -3 r + “Z”; }, diamond: function(size) { var ry = Math.sqrt(size / (2 d3_svg_symbolTan30)), rx = ry d3_svg_symbolTan30; return “M0,” + -ry + “L” + rx + “,0” + “ 0,” + ry + “ “ + -rx + “,0” + “Z”; }, square: function(size) { var r = Math.sqrt(size) / 2; return “M” + -r + “,” + -r + “L” + r + “,” + -r + “ “ + r + “,” + r + “ “ + -r + “,” + r + “Z”; }, “triangle-down”: function(size) { var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx d3_svg_symbolSqrt3 / 2; return “M0,” + ry + “L” + rx + “,” + -ry + “ “ + -rx + “,” + -ry + “Z”; }, “triangle-up”: function(size) { var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx d3_svg_symbolSqrt3 / 2; return “M0,” + -ry + “L” + rx + “,” + ry + “ “ + -rx + “,” + ry + “Z”; } }); d3.svg.symbolTypes = d3_svg_symbols.keys(); var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 d3_radians); d3_selectionPrototype.transition = function(name) { var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || { time: Date.now(), ease: d3_ease_cubicInOut, delay: 0, duration: 250 }; for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) d3_transitionNode(node, i, ns, id, transition); subgroup.push(node); } } return d3_transition(subgroups, ns, id); }; d3_selectionPrototype.interrupt = function(name) { return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name))); }; var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace()); function d3_selection_interruptNS(ns) { return function() { var lock, activeId, active; if ((lock = this[ns]) &amp;&amp; (active = lock[activeId = lock.active])) { active.timer.c = null; active.timer.t = NaN; if (–lock.count) delete lock[activeId]; else delete this[ns]; lock.active += .5; active.event &amp;&amp; active.event.interrupt.call(this, this.data, active.index); } }; } function d3_transition(groups, ns, id) { d3_subclass(groups, d3_transitionPrototype); groups.namespace = ns; groups.id = id; return groups; } var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit; d3_transitionPrototype.call = d3_selectionPrototype.call; d3_transitionPrototype.empty = d3_selectionPrototype.empty; d3_transitionPrototype.node = d3_selectionPrototype.node; d3_transitionPrototype.size = d3_selectionPrototype.size; d3.transition = function(selection, name) { return selection &amp;&amp; selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection); }; d3.transition.prototype = d3_transitionPrototype; d3_transitionPrototype.select = function(selector) { var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if ((node = group[i]) &amp;&amp; (subnode = selector.call(node, node.data, i, j))) { if (“data“ in node) subnode.data = node.data; d3_transitionNode(subnode, i, ns, id, node[ns][id]); subgroup.push(subnode); } else { subgroup.push(null); } } } return d3_transition(subgroups, ns, id); }; d3_transitionPrototype.selectAll = function(selector) { var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { transition = node[ns][id]; subnodes = selector.call(node, node.data, i, j); subgroups.push(subgroup = []); for (var k = -1, o = subnodes.length; ++k &lt; o; ) { if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition); subgroup.push(subnode); } } } } return d3_transition(subgroups, ns, id); }; d3_transitionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== “function”) filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { if ((node = group[i]) &amp;&amp; filter.call(node, node.data, i, j)) { subgroup.push(node); } } } return d3_transition(subgroups, this.namespace, this.id); }; d3_transitionPrototype.tween = function(name, tween) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 2) return this.node()[ns][id].tween.get(name); return d3_selection_each(this, tween == null ? function(node) { node[ns][id].tween.remove(name); } : function(node) { node[ns][id].tween.set(name, tween); }); }; function d3_transition_tween(groups, name, value, tween) { var id = groups.id, ns = groups.namespace; return d3_selection_each(groups, typeof value === “function” ? function(node, i, j) { node[ns][id].tween.set(name, tween(value.call(node, node.data, i, j))); } : (value = tween(value), function(node) { node[ns][id].tween.set(name, value); })); } d3_transitionPrototype.attr = function(nameNS, value) { if (arguments.length &lt; 2) { for (value in nameNS) this.attr(value, nameNS[value]); return this; } var interpolate = nameNS == “transform” ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrTween(b) { return b == null ? attrNull : (b += “”, function() { var a = this.getAttribute(name), i; return a !== b &amp;&amp; (i = interpolate(a, b), function(t) { this.setAttribute(name, i(t)); }); }); } function attrTweenNS(b) { return b == null ? attrNullNS : (b += “”, function() { var a = this.getAttributeNS(name.space, name.local), i; return a !== b &amp;&amp; (i = interpolate(a, b), function(t) { this.setAttributeNS(name.space, name.local, i(t)); }); }); } return d3_transition_tween(this, “attr.” + nameNS, value, name.local ? attrTweenNS : attrTween); }; d3_transitionPrototype.attrTween = function(nameNS, tween) { var name = d3.ns.qualify(nameNS); function attrTween(d, i) { var f = tween.call(this, d, i, this.getAttribute(name)); return f &amp;&amp; function(t) { this.setAttribute(name, f(t)); }; } function attrTweenNS(d, i) { var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local)); return f &amp;&amp; function(t) { this.setAttributeNS(name.space, name.local, f(t)); }; } return this.tween(“attr.” + nameNS, name.local ? attrTweenNS : attrTween); }; d3_transitionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n &lt; 3) { if (typeof name !== “string”) { if (n &lt; 2) value = “”; for (priority in name) this.style(priority, name[priority], value); return this; } priority = “”; } function styleNull() { this.style.removeProperty(name); } function styleString(b) { return b == null ? styleNull : (b += “”, function() { var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i; return a !== b &amp;&amp; (i = d3_interpolate(a, b), function(t) { this.style.setProperty(name, i(t), priority); }); }); } return d3_transition_tween(this, “style.” + name, value, styleString); }; d3_transitionPrototype.styleTween = function(name, tween, priority) { if (arguments.length &lt; 3) priority = “”; function styleTween(d, i) { var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name)); return f &amp;&amp; function(t) { this.style.setProperty(name, f(t), priority); }; } return this.tween(“style.” + name, styleTween); }; d3_transitionPrototype.text = function(value) { return d3_transition_tween(this, “text”, value, d3_transition_text); }; function d3_transition_text(b) { if (b == null) b = “”; return function() { this.textContent = b; }; } d3_transitionPrototype.remove = function() { var ns = this.namespace; return this.each(“end.transition”, function() { var p; if (this[ns].count &lt; 2 &amp;&amp; (p = this.parentNode)) p.removeChild(this); }); }; d3_transitionPrototype.ease = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].ease; if (typeof value !== “function”) value = d3.ease.apply(d3, arguments); return d3_selection_each(this, function(node) { node[ns][id].ease = value; }); }; d3_transitionPrototype.delay = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].delay; return d3_selection_each(this, typeof value === “function” ? function(node, i, j) { node[ns][id].delay = +value.call(node, node.data, i, j); } : (value = +value, function(node) { node[ns][id].delay = value; })); }; d3_transitionPrototype.duration = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].duration; return d3_selection_each(this, typeof value === “function” ? function(node, i, j) { node[ns][id].duration = Math.max(1, value.call(node, node.data, i, j)); } : (value = Math.max(1, value), function(node) { node[ns][id].duration = value; })); }; d3_transitionPrototype.each = function(type, listener) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 2) { var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId; try { d3_transitionInheritId = id; d3_selection_each(this, function(node, i, j) { d3_transitionInherit = node[ns][id]; type.call(node, node.data, i, j); }); } finally { d3_transitionInherit = inherit; d3_transitionInheritId = inheritId; } } else { d3_selection_each(this, function(node) { var transition = node[ns][id]; (transition.event || (transition.event = d3.dispatch(“start”, “end”, “interrupt”))).on(type, listener); }); } return this; }; d3_transitionPrototype.transition = function() { var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition; for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { if (node = group[i]) { transition = node[ns][id0]; d3_transitionNode(node, i, ns, id1, { time: transition.time, ease: transition.ease, delay: transition.delay + transition.duration, duration: transition.duration }); } subgroup.push(node); } } return d3_transition(subgroups, ns, id1); }; function d3_transitionNamespace(name) { return name == null ? “transition“ : “transition_” + name + ““; } function d3_transitionNode(node, i, ns, id, inherit) { var lock = node[ns] || (node[ns] = { active: 0, count: 0 }), transition = lock[id], time, timer, duration, ease, tweens; function schedule(elapsed) { var delay = transition.delay; timer.t = delay + time; if (delay &lt;= elapsed) return start(elapsed - delay); timer.c = start; } function start(elapsed) { var activeId = lock.active, active = lock[activeId]; if (active) { active.timer.c = null; active.timer.t = NaN; –lock.count; delete lock[activeId]; active.event &amp;&amp; active.event.interrupt.call(node, node.data, active.index); } for (var cancelId in lock) { if (+cancelId &lt; id) { var cancel = lock[cancelId]; cancel.timer.c = null; cancel.timer.t = NaN; –lock.count; delete lock[cancelId]; } } timer.c = tick; d3_timer(function() { if (timer.c &amp;&amp; tick(elapsed || 1)) { timer.c = null; timer.t = NaN; } return 1; }, 0, time); lock.active = id; transition.event &amp;&amp; transition.event.start.call(node, node.data, i); tweens = []; transition.tween.forEach(function(key, value) { if (value = value.call(node, node.data, i)) { tweens.push(value); } }); ease = transition.ease; duration = transition.duration; } function tick(elapsed) { var t = elapsed / duration, e = ease(t), n = tweens.length; while (n &gt; 0) { tweens[–n].call(node, e); } if (t &gt;= 1) { transition.event &amp;&amp; transition.event.end.call(node, node.data, i); if (–lock.count) delete lock[id]; else delete node[ns]; return 1; } } if (!transition) { time = inherit.time; timer = d3_timer(schedule, 0, time); transition = lock[id] = { tween: new d3_Map(), time: time, timer: timer, delay: inherit.delay, duration: inherit.duration, ease: inherit.ease, index: i }; inherit = null; ++lock.count; } } d3.svg.axis = function() { var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_; function axis(g) { g.each(function() { var g = d3.select(this); var scale0 = this.chart || scale, scale1 = this.chart = scale.copy(); var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(“.tick”).data(ticks, scale1), tickEnter = tick.enter().insert(“g”, “.domain”).attr(“class”, “tick”).style(“opacity”, ε), tickExit = d3.transition(tick.exit()).style(“opacity”, ε).remove(), tickUpdate = d3.transition(tick.order()).style(“opacity”, 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform; var range = d3_scaleRange(scale1), path = g.selectAll(“.domain”).data([ 0 ]), pathUpdate = (path.enter().append(“path”).attr(“class”, “domain”), d3.transition(path)); tickEnter.append(“line”); tickEnter.append(“text”); var lineEnter = tickEnter.select(“line”), lineUpdate = tickUpdate.select(“line”), text = tick.select(“text”).text(tickFormat), textEnter = tickEnter.select(“text”), textUpdate = tickUpdate.select(“text”), sign = orient === “top” || orient === “left” ? -1 : 1, x1, x2, y1, y2; if (orient === “bottom” || orient === “top”) { tickTransform = d3_svg_axisX, x1 = “x”, y1 = “y”, x2 = “x2”, y2 = “y2”; text.attr(“dy”, sign &lt; 0 ? “0em” : “.71em”).style(“text-anchor”, “middle”); pathUpdate.attr(“d”, “M” + range[0] + “,” + sign outerTickSize + “V0H” + range[1] + “V” + sign outerTickSize); } else { tickTransform = d3_svg_axisY, x1 = “y”, y1 = “x”, x2 = “y2”, y2 = “x2”; text.attr(“dy”, “.32em”).style(“text-anchor”, sign &lt; 0 ? “end” : “start”); pathUpdate.attr(“d”, “M” + sign outerTickSize + “,” + range[0] + “H0V” + range[1] + “H” + sign outerTickSize); } lineEnter.attr(y2, sign innerTickSize); textEnter.attr(y1, sign tickSpacing); lineUpdate.attr(x2, 0).attr(y2, sign innerTickSize); textUpdate.attr(x1, 0).attr(y1, sign tickSpacing); if (scale1.rangeBand) { var x = scale1, dx = x.rangeBand() / 2; scale0 = scale1 = function(d) { return x(d) + dx; }; } else if (scale0.rangeBand) { scale0 = scale1; } else { tickExit.call(tickTransform, scale1, scale0); } tickEnter.call(tickTransform, scale0, scale1); tickUpdate.call(tickTransform, scale1, scale1); }); } axis.scale = function(x) { if (!arguments.length) return scale; scale = x; return axis; }; axis.orient = function(x) { if (!arguments.length) return orient; orient = x in d3_svg_axisOrients ? x + “” : d3_svg_axisDefaultOrient; return axis; }; axis.ticks = function() { if (!arguments.length) return tickArguments_; tickArguments_ = d3_array(arguments); return axis; }; axis.tickValues = function(x) { if (!arguments.length) return tickValues; tickValues = x; return axis; }; axis.tickFormat = function(x) { if (!arguments.length) return tickFormat_; tickFormat_ = x; return axis; }; axis.tickSize = function(x) { var n = arguments.length; if (!n) return innerTickSize; innerTickSize = +x; outerTickSize = +arguments[n - 1]; return axis; }; axis.innerTickSize = function(x) { if (!arguments.length) return innerTickSize; innerTickSize = +x; return axis; }; axis.outerTickSize = function(x) { if (!arguments.length) return outerTickSize; outerTickSize = +x; return axis; }; axis.tickPadding = function(x) { if (!arguments.length) return tickPadding; tickPadding = +x; return axis; }; axis.tickSubdivide = function() { return arguments.length &amp;&amp; axis; }; return axis; }; var d3_svg_axisDefaultOrient = “bottom”, d3_svg_axisOrients = { top: 1, right: 1, bottom: 1, left: 1 }; function d3_svg_axisX(selection, x0, x1) { selection.attr(“transform”, function(d) { var v0 = x0(d); return “translate(“ + (isFinite(v0) ? v0 : x1(d)) + “,0)”; }); } function d3_svg_axisY(selection, y0, y1) { selection.attr(“transform”, function(d) { var v0 = y0(d); return “translate(0,” + (isFinite(v0) ? v0 : y1(d)) + “)”; }); } d3.svg.brush = function() { var event = d3_eventDispatch(brush, “brushstart”, “brush”, “brushend”), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0]; function brush(g) { g.each(function() { var g = d3.select(this).style(“pointer-events”, “all”).style(“-webkit-tap-highlight-color”, “rgba(0,0,0,0)”).on(“mousedown.brush”, brushstart).on(“touchstart.brush”, brushstart); var background = g.selectAll(“.background”).data([ 0 ]); background.enter().append(“rect”).attr(“class”, “background”).style(“visibility”, “hidden”).style(“cursor”, “crosshair”); g.selectAll(“.extent”).data([ 0 ]).enter().append(“rect”).attr(“class”, “extent”).style(“cursor”, “move”); var resize = g.selectAll(“.resize”).data(resizes, d3_identity); resize.exit().remove(); resize.enter().append(“g”).attr(“class”, function(d) { return “resize “ + d; }).style(“cursor”, function(d) { return d3_svg_brushCursor[d]; }).append(“rect”).attr(“x”, function(d) { return /[ew]$/.test(d) ? -3 : null; }).attr(“y”, function(d) { return /^[ns]/.test(d) ? -3 : null; }).attr(“width”, 6).attr(“height”, 6).style(“visibility”, “hidden”); resize.style(“display”, brush.empty() ? “none” : null); var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range; if (x) { range = d3_scaleRange(x); backgroundUpdate.attr(“x”, range[0]).attr(“width”, range[1] - range[0]); redrawX(gUpdate); } if (y) { range = d3_scaleRange(y); backgroundUpdate.attr(“y”, range[0]).attr(“height”, range[1] - range[0]); redrawY(gUpdate); } redraw(gUpdate); }); } brush.event = function(g) { g.each(function() { var event_ = event.of(this, arguments), extent1 = { x: xExtent, y: yExtent, i: xExtentDomain, j: yExtentDomain }, extent0 = this.chart || extent1; this.chart = extent1; if (d3_transitionInheritId) { d3.select(this).transition().each(“start.brush”, function() { xExtentDomain = extent0.i; yExtentDomain = extent0.j; xExtent = extent0.x; yExtent = extent0.y; event_({ type: “brushstart” }); }).tween(“brush:brush”, function() { var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y); xExtentDomain = yExtentDomain = null; return function(t) { xExtent = extent1.x = xi(t); yExtent = extent1.y = yi(t); event_({ type: “brush”, mode: “resize” }); }; }).each(“end.brush”, function() { xExtentDomain = extent1.i; yExtentDomain = extent1.j; event_({ type: “brush”, mode: “resize” }); event_({ type: “brushend” }); }); } else { event_({ type: “brushstart” }); event_({ type: “brush”, mode: “resize” }); event_({ type: “brushend” }); } }); }; function redraw(g) { g.selectAll(“.resize”).attr(“transform”, function(d) { return “translate(“ + xExtent[+/e$/.test(d)] + “,” + yExtent[+/^s/.test(d)] + “)”; }); } function redrawX(g) { g.select(“.extent”).attr(“x”, xExtent[0]); g.selectAll(“.extent,.n&gt;rect,.s&gt;rect”).attr(“width”, xExtent[1] - xExtent[0]); } function redrawY(g) { g.select(“.extent”).attr(“y”, yExtent[0]); g.selectAll(“.extent,.e&gt;rect,.w&gt;rect”).attr(“height”, yExtent[1] - yExtent[0]); } function brushstart() { var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) &amp;&amp; x, resizingY = !/^(e|w)$/.test(resizing) &amp;&amp; y, dragging = eventTarget.classed(“extent”), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset; var w = d3.select(d3_window(target)).on(“keydown.brush”, keydown).on(“keyup.brush”, keyup); if (d3.event.changedTouches) { w.on(“touchmove.brush”, brushmove).on(“touchend.brush”, brushend); } else { w.on(“mousemove.brush”, brushmove).on(“mouseup.brush”, brushend); } g.interrupt().selectAll(““).interrupt(); if (dragging) { origin[0] = xExtent[0] - origin[0]; origin[1] = yExtent[0] - origin[1]; } else if (resizing) { var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing); offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ]; origin[0] = xExtent[ex]; origin[1] = yExtent[ey]; } else if (d3.event.altKey) center = origin.slice(); g.style(“pointer-events”, “none”).selectAll(“.resize”).style(“display”, null); d3.select(“body”).style(“cursor”, eventTarget.style(“cursor”)); event_({ type: “brushstart” }); brushmove(); function keydown() { if (d3.event.keyCode == 32) { if (!dragging) { center = null; origin[0] -= xExtent[1]; origin[1] -= yExtent[1]; dragging = 2; } d3_eventPreventDefault(); } } function keyup() { if (d3.event.keyCode == 32 &amp;&amp; dragging == 2) { origin[0] += xExtent[1]; origin[1] += yExtent[1]; dragging = 0; d3_eventPreventDefault(); } } function brushmove() { var point = d3.mouse(target), moved = false; if (offset) { point[0] += offset[0]; point[1] += offset[1]; } if (!dragging) { if (d3.event.altKey) { if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ]; origin[0] = xExtent[+(point[0] &lt; center[0])]; origin[1] = yExtent[+(point[1] &lt; center[1])]; } else center = null; } if (resizingX &amp;&amp; move1(point, x, 0)) { redrawX(g); moved = true; } if (resizingY &amp;&amp; move1(point, y, 1)) { redrawY(g); moved = true; } if (moved) { redraw(g); event_({ type: “brush”, mode: dragging ? “move” : “resize” }); } } function move1(point, scale, i) { var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max; if (dragging) { r0 -= position; r1 -= size + position; } min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i]; if (dragging) { max = (min += position) + size; } else { if (center) position = Math.max(r0, Math.min(r1, 2 center[i] - min)); if (position &lt; min) { max = min; min = position; } else { max = position; } } if (extent[0] != min || extent[1] != max) { if (i) yExtentDomain = null; else xExtentDomain = null; extent[0] = min; extent[1] = max; return true; } } function brushend() { brushmove(); g.style(“pointer-events”, “all”).selectAll(“.resize”).style(“display”, brush.empty() ? “none” : null); d3.select(“body”).style(“cursor”, null); w.on(“mousemove.brush”, null).on(“mouseup.brush”, null).on(“touchmove.brush”, null).on(“touchend.brush”, null).on(“keydown.brush”, null).on(“keyup.brush”, null); dragRestore(); event_({ type: “brushend” }); } } brush.x = function(z) { if (!arguments.length) return x; x = z; resizes = d3_svg_brushResizes[!x &lt;&lt; 1 | !y]; return brush; }; brush.y = function(z) { if (!arguments.length) return y; y = z; resizes = d3_svg_brushResizes[!x &lt;&lt; 1 | !y]; return brush; }; brush.clamp = function(z) { if (!arguments.length) return x &amp;&amp; y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null; if (x &amp;&amp; y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z; return brush; }; brush.extent = function(z) { var x0, x1, y0, y1, t; if (!arguments.length) { if (x) { if (xExtentDomain) { x0 = xExtentDomain[0], x1 = xExtentDomain[1]; } else { x0 = xExtent[0], x1 = xExtent[1]; if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1); if (x1 &lt; x0) t = x0, x0 = x1, x1 = t; } } if (y) { if (yExtentDomain) { y0 = yExtentDomain[0], y1 = yExtentDomain[1]; } else { y0 = yExtent[0], y1 = yExtent[1]; if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1); if (y1 &lt; y0) t = y0, y0 = y1, y1 = t; } } return x &amp;&amp; y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y &amp;&amp; [ y0, y1 ]; } if (x) { x0 = z[0], x1 = z[1]; if (y) x0 = x0[0], x1 = x1[0]; xExtentDomain = [ x0, x1 ]; if (x.invert) x0 = x(x0), x1 = x(x1); if (x1 &lt; x0) t = x0, x0 = x1, x1 = t; if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ]; } if (y) { y0 = z[0], y1 = z[1]; if (x) y0 = y0[1], y1 = y1[1]; yExtentDomain = [ y0, y1 ]; if (y.invert) y0 = y(y0), y1 = y(y1); if (y1 &lt; y0) t = y0, y0 = y1, y1 = t; if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ]; } return brush; }; brush.clear = function() { if (!brush.empty()) { xExtent = [ 0, 0 ], yExtent = [ 0, 0 ]; xExtentDomain = yExtentDomain = null; } return brush; }; brush.empty = function() { return !!x &amp;&amp; xExtent[0] == xExtent[1] || !!y &amp;&amp; yExtent[0] == yExtent[1]; }; return d3.rebind(brush, event, “on”); }; var d3_svg_brushCursor = { n: “ns-resize”, e: “ew-resize”, s: “ns-resize”, w: “ew-resize”, nw: “nwse-resize”, ne: “nesw-resize”, se: “nwse-resize”, sw: “nesw-resize” }; var d3_svg_brushResizes = [ [ “n”, “e”, “s”, “w”, “nw”, “ne”, “se”, “sw” ], [ “e”, “w” ], [ “n”, “s” ], [] ]; var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat; var d3_time_formatUtc = d3_time_format.utc; var d3_time_formatIso = d3_time_formatUtc(“%Y-%m-%dT%H:%M:%S.%LZ”); d3_time_format.iso = Date.prototype.toISOString &amp;&amp; +new Date(“2000-01-01T00:00:00.000Z”) ? d3_time_formatIsoNative : d3_time_formatIso; function d3_time_formatIsoNative(date) { return date.toISOString(); } d3_time_formatIsoNative.parse = function(string) { var date = new Date(string); return isNaN(date) ? null : date; }; d3_time_formatIsoNative.toString = d3_time_formatIso.toString; d3_time.second = d3_time_interval(function(date) { return new d3_date(Math.floor(date / 1e3) 1e3); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 1e3); }, function(date) { return date.getSeconds(); }); d3_time.seconds = d3_time.second.range; d3_time.seconds.utc = d3_time.second.utc.range; d3_time.minute = d3_time_interval(function(date) { return new d3_date(Math.floor(date / 6e4) 6e4); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 6e4); }, function(date) { return date.getMinutes(); }); d3_time.minutes = d3_time.minute.range; d3_time.minutes.utc = d3_time.minute.utc.range; d3_time.hour = d3_time_interval(function(date) { var timezone = date.getTimezoneOffset() / 60; return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) 36e5); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 36e5); }, function(date) { return date.getHours(); }); d3_time.hours = d3_time.hour.range; d3_time.hours.utc = d3_time.hour.utc.range; d3_time.month = d3_time_interval(function(date) { date = d3_time.day(date); date.setDate(1); return date; }, function(date, offset) { date.setMonth(date.getMonth() + offset); }, function(date) { return date.getMonth(); }); d3_time.months = d3_time.month.range; d3_time.months.utc = d3_time.month.utc.range; function d3_time_scale(linear, methods, format) { function scale(x) { return linear(x); } scale.invert = function(x) { return d3_time_scaleDate(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return linear.domain().map(d3_time_scaleDate); linear.domain(x); return scale; }; function tickMethod(extent, count) { var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target); return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) { return d / 31536e6; }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] &lt; d3_time_scaleSteps[i] / target ? i - 1 : i]; } scale.nice = function(interval, skip) { var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === “number” &amp;&amp; tickMethod(extent, interval); if (method) interval = method[0], skip = method[1]; function skipped(date) { return !isNaN(date) &amp;&amp; !interval.range(date, d3_time_scaleDate(+date + 1), skip).length; } return scale.domain(d3_scale_nice(domain, skip &gt; 1 ? { floor: function(date) { while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1); return date; }, ceil: function(date) { while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1); return date; } } : interval)); }; scale.ticks = function(interval, skip) { var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === “number” ? tickMethod(extent, interval) : !interval.range &amp;&amp; [ { range: interval }, skip ]; if (method) interval = method[0], skip = method[1]; return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip &lt; 1 ? 1 : skip); }; scale.tickFormat = function() { return format; }; scale.copy = function() { return d3_time_scale(linear.copy(), methods, format); }; return d3_scale_linearRebind(scale, linear); } function d3_time_scaleDate(t) { return new Date(t); } var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ]; var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ]; var d3_time_scaleLocalFormat = d3_time_format.multi([ [ “.%L”, function(d) { return d.getMilliseconds(); } ], [ “:%S”, function(d) { return d.getSeconds(); } ], [ “%I:%M”, function(d) { return d.getMinutes(); } ], [ “%I %p”, function(d) { return d.getHours(); } ], [ “%a %d”, function(d) { return d.getDay() &amp;&amp; d.getDate() != 1; } ], [ “%b %d”, function(d) { return d.getDate() != 1; } ], [ “%B”, function(d) { return d.getMonth(); } ], [ “%Y”, d3_true ] ]); var d3_time_scaleMilliseconds = { range: function(start, stop, step) { return d3.range(Math.ceil(start / step) step, +stop, step).map(d3_time_scaleDate); }, floor: d3_identity, ceil: d3_identity }; d3_time_scaleLocalMethods.year = d3_time.year; d3_time.scale = function() { return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat); }; var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) { return [ m[0].utc, m[1] ]; }); var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ “.%L”, function(d) { return d.getUTCMilliseconds(); } ], [ “:%S”, function(d) { return d.getUTCSeconds(); } ], [ “%I:%M”, function(d) { return d.getUTCMinutes(); } ], [ “%I %p”, function(d) { return d.getUTCHours(); } ], [ “%a %d”, function(d) { return d.getUTCDay() &amp;&amp; d.getUTCDate() != 1; } ], [ “%b %d”, function(d) { return d.getUTCDate() != 1; } ], [ “%B”, function(d) { return d.getUTCMonth(); } ], [ “%Y”, d3_true ] ]); d3_time_scaleUtcMethods.year = d3_time.year.utc; d3_time.scale.utc = function() { return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat); }; d3.text = d3_xhrType(function(request) { return request.responseText; }); d3.json = function(url, callback) { return d3_xhr(url, “application/json”, d3_json, callback); }; function d3_json(request) { return JSON.parse(request.responseText); } d3.html = function(url, callback) { return d3_xhr(url, “text/html”, d3_html, callback); }; function d3_html(request) { var range = d3_document.createRange(); range.selectNode(d3_document.body); return range.createContextualFragment(request.responseText); } d3.xml = d3_xhrType(function(request) { return request.responseXML; }); if (true) this.d3 = d3, !(WEBPACK_AMD_DEFINE_FACTORY = (d3), WEBPACK_AMD_DEFINE_RESULT = (typeof WEBPACK_AMD_DEFINE_FACTORY === ‘function’ ? (WEBPACK_AMD_DEFINE_FACTORY.call(exports, webpack_require, exports, module)) : WEBPACK_AMD_DEFINE_FACTORY), WEBPACK_AMD_DEFINE_RESULT !== undefined &amp;&amp; (module.exports = WEBPACK_AMD_DEFINE_RESULT)); else if (typeof module === “object” &amp;&amp; module.exports) module.exports = d3; else this.d3 = d3; }();/*/ }),/ 3 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _d = webpack_require__(2); var _d2 = _interopRequireDefault(_d); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var Barchart = // svg: d3 object with the svg in question // exp_array: list of (feature_name, weight) function Barchart(svg, exp_array) { var two_sided = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : true; var titles = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : undefined; var colors = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : [‘red’, ‘green’]; var show_numbers = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; var bar_height = arguments.length &gt; 6 &amp;&amp; arguments[6] !== undefined ? arguments[6] : 5; _classCallCheck(this, Barchart); var svg_width = Math.min(600, parseInt(svg.style(‘width’))); var bar_width = two_sided ? svg_width / 2 : svg_width; if (titles === undefined) { titles = two_sided ? [‘Cons’, ‘Pros’] : ‘Pros’; } if (show_numbers) { bar_width = bar_width - 30; } var x_offset = two_sided ? svg_width / 2 : 10; // 13.1 is +- the width of W, the widest letter. if (two_sided &amp;&amp; titles.length == 2) { svg.append(‘text’).attr(‘x’, svg_width / 4).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, ‘middle’).style(‘fill’, colors[0]).text(titles[0]); svg.append(‘text’).attr(‘x’, svg_width / 4 3).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, ‘middle’).style(‘fill’, colors[1]).text(titles[1]); } else { var pos = two_sided ? svg_width / 2 : x_offset; var anchor = two_sided ? ‘middle’ : ‘begin’; svg.append(‘text’).attr(‘x’, pos).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, anchor).text(titles); } var yshift = 20; var space_between_bars = 0; var text_height = 16; var space_between_bar_and_text = 3; var total_bar_height = text_height + space_between_bar_and_text + bar_height + space_between_bars; var total_height = total_bar_height exp_array.length; this.svg_height = total_height + yshift; var yscale = _d2.default.scale.linear().domain([0, exp_array.length]).range([yshift, yshift + total_height]); var names = exp_array.map(function (v) { return v[0]; }); var weights = exp_array.map(function (v) { return v[1]; }); var max_weight = Math.max.apply(Math, _toConsumableArray(weights.map(function (v) { return Math.abs(v); }))); var xscale = _d2.default.scale.linear().domain([0, Math.max(1, max_weight)]).range([0, bar_width]); for (var i = 0; i &lt; exp_array.length; ++i) { var name = names[i]; var weight = weights[i]; var size = xscale(Math.abs(weight)); var to_the_right = weight &gt; 0 || !two_sided; var text = svg.append(‘text’).attr(‘x’, to_the_right ? x_offset + 2 : x_offset - 2).attr(‘y’, yscale(i) + text_height).attr(‘text-anchor’, to_the_right ? ‘begin’ : ‘end’).attr(‘font-size’, ‘14’).text(name); while (text.node().getBBox()[‘width’] + 1 &gt; bar_width) { var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + ‘…’); if (text === ‘…’) { break; } } var bar = svg.append(‘rect’).attr(‘height’, bar_height).attr(‘x’, to_the_right ? x_offset : x_offset - size).attr(‘y’, text_height + yscale(i) + space_between_bar_and_text) // + bar_height) .attr(‘width’, size).style(‘fill’, weight &gt; 0 ? colors[1] : colors[0]); if (show_numbers) { var bartext = svg.append(‘text’).attr(‘x’, to_the_right ? x_offset + size + 1 : x_offset - size - 1).attr(‘text-anchor’, weight &gt; 0 || !two_sided ? ‘begin’ : ‘end’).attr(‘y’, bar_height + yscale(i) + text_height + space_between_bar_and_text).attr(‘font-size’, ‘10’).text(Math.abs(weight).toFixed(2)); } } var line = svg.append(“line”).attr(“x1”, x_offset).attr(“x2”, x_offset).attr(“y1”, bar_height + yshift).attr(“y2”, Math.max(bar_height, yscale(exp_array.length))).style(“stroke-width”, 2).style(“stroke”, “black”); }; exports.default = Barchart;// }),/ 4 /// (function(module, exports, webpack_require) { var WEBPACK_AMD_DEFINE_RESULT;/ WEBPACK VAR INJECTION */(function(global, module) {/ @license Lodash https://lodash.com/ Copyright JS Foundation and other contributors https://js.foundation/ Released under MIT license https://lodash.com/license Based on Underscore.js 1.8.3 http://underscorejs.org/LICENSE Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors / ;(function() { /** Used as a safe reference for undefined in pre-ES5 environments. / var undefined; / Used as the semantic version number. */ var VERSION = ‘4.17.11’; / Used as the size to enable large array optimizations. / var LARGE_ARRAY_SIZE = 200; /** Error message constants. / var CORE_ERROR_TEXT = ‘Unsupported core-js use. Try https://npms.io/search?q=ponyfill.&#39;, FUNC_ERROR_TEXT = ‘Expected a function’; / Used to stand-in for undefined hash values. */ var HASH_UNDEFINED = ‘lodash_hash_undefined‘; / Used as the maximum memoize cache size. / var MAX_MEMOIZE_SIZE = 500; /** Used as the internal argument placeholder. / var PLACEHOLDER = ‘lodash_placeholder‘; / Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4; / Used to compose bitmasks for value comparisons. / var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; /** Used to compose bitmasks for function metadata. / var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512; / Used as default options for _.truncate. */ var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = ‘…’; / Used to detect hot functions by number of calls within a span of milliseconds. / var HOT_COUNT = 800, HOT_SPAN = 16; /** Used to indicate the type of lazy iteratees. / var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3; / Used as references for various Number constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0; / Used as references for the maximum length and index of an array. / var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH &gt;&gt;&gt; 1; /** Used to associate wrap methods with their bit flags. / var wrapFlags = [ [‘ary’, WRAP_ARY_FLAG], [‘bind’, WRAP_BIND_FLAG], [‘bindKey’, WRAP_BIND_KEY_FLAG], [‘curry’, WRAP_CURRY_FLAG], [‘curryRight’, WRAP_CURRY_RIGHT_FLAG], [‘flip’, WRAP_FLIP_FLAG], [‘partial’, WRAP_PARTIAL_FLAG], [‘partialRight’, WRAP_PARTIAL_RIGHT_FLAG], [‘rearg’, WRAP_REARG_FLAG] ]; / Object#toString result references. */ var argsTag = ‘[object Arguments]’, arrayTag = ‘[object Array]’, asyncTag = ‘[object AsyncFunction]’, boolTag = ‘[object Boolean]’, dateTag = ‘[object Date]’, domExcTag = ‘[object DOMException]’, errorTag = ‘[object Error]’, funcTag = ‘[object Function]’, genTag = ‘[object GeneratorFunction]’, mapTag = ‘[object Map]’, numberTag = ‘[object Number]’, nullTag = ‘[object Null]’, objectTag = ‘[object Object]’, promiseTag = ‘[object Promise]’, proxyTag = ‘[object Proxy]’, regexpTag = ‘[object RegExp]’, setTag = ‘[object Set]’, stringTag = ‘[object String]’, symbolTag = ‘[object Symbol]’, undefinedTag = ‘[object Undefined]’, weakMapTag = ‘[object WeakMap]’, weakSetTag = ‘[object WeakSet]’; var arrayBufferTag = ‘[object ArrayBuffer]’, dataViewTag = ‘[object DataView]’, float32Tag = ‘[object Float32Array]’, float64Tag = ‘[object Float64Array]’, int8Tag = ‘[object Int8Array]’, int16Tag = ‘[object Int16Array]’, int32Tag = ‘[object Int32Array]’, uint8Tag = ‘[object Uint8Array]’, uint8ClampedTag = ‘[object Uint8ClampedArray]’, uint16Tag = ‘[object Uint16Array]’, uint32Tag = ‘[object Uint32Array]’; / Used to match empty string literals in compiled template source. / var reEmptyStringLeading = /\b__p += ‘’;/g, reEmptyStringMiddle = /\b(p +=) ‘’ +/g, reEmptyStringTrailing = /(e(.?)|\b__t)) +\n’’;/g; / Used to match HTML entities and HTML characters. */ var reEscapedHtml = /&amp;(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&amp;&lt;&gt;”‘]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source); / Used to match template delimiters. / var reEscape = /&lt;%-([\s\S]+?)%&gt;/g, reEvaluate = /&lt;%([\s\S]+?)%&gt;/g, reInterpolate = /&lt;%=([\s\S]+?)%&gt;/g; /** Used to match property names within property paths. / var reIsDeepProp = /.|[(?:[^[]]|([“‘])(?:(?!\1)[^\]|\.)?\1)]/, reIsPlainProp = /^\w$/, rePropName = /[^.[]]+|[(?:(-?\d+(?:.\d+)?)|([“‘])((?:(?!\2)[^\]|\.)?)\2)]|(?=(?:.|[])(?:.|[]|$))/g; / Used to match RegExp syntax characters. / var reRegExpChar = /[\^$.+?()[]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source); / Used to match leading and trailing whitespace. / var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/; /** Used to match wrap detail comments. / var reWrapComment = /{(?:\n\/* [wrapped with .+] *\/)?\n?/, reWrapDetails = /{\n\/* [wrapped with (.+)] */, reSplitDetails = /,? &amp; /; / Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g; / Used to match backslashes in property paths. / var reEscapeChar = /\(\)?/g; /** Used to match ES template delimiters. / var reEsTemplate = /\${([^\}](?:\.[^\}]))}/g; /** Used to match RegExp flags from their coerced string values. / var reFlags = /\w$/; /** Used to detect bad signed hexadecimal string values. / var reIsBadHex = /^[-+]0x[0-9a-f]+$/i; / Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i; / Used to detect host constructors (Safari). / var reIsHostCtor = /^[object .+?Constructor]$/; /** Used to detect octal string values. / var reIsOctal = /^0o[0-7]+$/i; / Used to detect unsigned integer values. / var reIsUint = /^(?:0|[1-9]\d)$/; / Used to match Latin Unicode letters (excluding mathematical operators). / var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g; /** Used to ensure capturing order of template delimiters. / var reNoMatch = /($^)/; / Used to match unescaped characters in compiled string literals. */ var reUnescapedString = /[‘\n\r\u2028\u2029\]/g; / Used to compose unicode character classes. / var rsAstralRange = ‘\ud800-\udfff’, rsComboMarksRange = ‘\u0300-\u036f’, reComboHalfMarksRange = ‘\ufe20-\ufe2f’, rsComboSymbolsRange = ‘\u20d0-\u20ff’, rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = ‘\u2700-\u27bf’, rsLowerRange = ‘a-z\xdf-\xf6\xf8-\xff’, rsMathOpRange = ‘\xac\xb1\xd7\xf7’, rsNonCharRange = ‘\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf’, rsPunctuationRange = ‘\u2000-\u206f’, rsSpaceRange = ‘ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000’, rsUpperRange = ‘A-Z\xc0-\xd6\xd8-\xde’, rsVarRange = ‘\ufe0e\ufe0f’, rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange; /** Used to compose unicode capture groups. / var rsApos = “[‘\u2019]”, rsAstral = ‘[‘ + rsAstralRange + ‘]’, rsBreak = ‘[‘ + rsBreakRange + ‘]’, rsCombo = ‘[‘ + rsComboRange + ‘]’, rsDigits = ‘\d+’, rsDingbat = ‘[‘ + rsDingbatRange + ‘]’, rsLower = ‘[‘ + rsLowerRange + ‘]’, rsMisc = ‘[^’ + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ‘]’, rsFitz = ‘\ud83c[\udffb-\udfff]’, rsModifier = ‘(?:’ + rsCombo + ‘|’ + rsFitz + ‘)’, rsNonAstral = ‘[^’ + rsAstralRange + ‘]’, rsRegional = ‘(?:\ud83c[\udde6-\uddff]){2}’, rsSurrPair = ‘[\ud800-\udbff][\udc00-\udfff]’, rsUpper = ‘[‘ + rsUpperRange + ‘]’, rsZWJ = ‘\u200d’; / Used to compose unicode regexes. / var rsMiscLower = ‘(?:’ + rsLower + ‘|’ + rsMisc + ‘)’, rsMiscUpper = ‘(?:’ + rsUpper + ‘|’ + rsMisc + ‘)’, rsOptContrLower = ‘(?:’ + rsApos + ‘(?:d|ll|m|re|s|t|ve))?’, rsOptContrUpper = ‘(?:’ + rsApos + ‘(?:D|LL|M|RE|S|T|VE))?’, reOptMod = rsModifier + ‘?’, rsOptVar = ‘[‘ + rsVarRange + ‘]?’, rsOptJoin = ‘(?:’ + rsZWJ + ‘(?:’ + [rsNonAstral, rsRegional, rsSurrPair].join(‘|’) + ‘)’ + rsOptVar + reOptMod + ‘)‘, rsOrdLower = ‘\d(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])’, rsOrdUpper = ‘\d(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])’, rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = ‘(?:’ + [rsDingbat, rsRegional, rsSurrPair].join(‘|’) + ‘)’ + rsSeq, rsSymbol = ‘(?:’ + [rsNonAstral + rsCombo + ‘?’, rsCombo, rsRegional, rsSurrPair, rsAstral].join(‘|’) + ‘)’; / Used to match apostrophes. / var reApos = RegExp(rsApos, ‘g’); /** Used to match combining diacritical marks and combining diacritical marks for symbols. / var reComboMark = RegExp(rsCombo, ‘g’); / Used to match string symbols. */ var reUnicode = RegExp(rsFitz + ‘(?=’ + rsFitz + ‘)|’ + rsSymbol + rsSeq, ‘g’); / Used to match complex or compound words. / var reUnicodeWord = RegExp([ rsUpper + ‘?’ + rsLower + ‘+’ + rsOptContrLower + ‘(?=’ + [rsBreak, rsUpper, ‘$’].join(‘|’) + ‘)’, rsMiscUpper + ‘+’ + rsOptContrUpper + ‘(?=’ + [rsBreak, rsUpper + rsMiscLower, ‘$’].join(‘|’) + ‘)’, rsUpper + ‘?’ + rsMiscLower + ‘+’ + rsOptContrLower, rsUpper + ‘+’ + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join(‘|’), ‘g’); /** Used to detect strings with zero-width joiners or code points from the astral planes. / var reHasUnicode = RegExp(‘[‘ + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ‘]’); / Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/; / Used to assign default context object properties. / var contextProps = [ ‘Array’, ‘Buffer’, ‘DataView’, ‘Date’, ‘Error’, ‘Float32Array’, ‘Float64Array’, ‘Function’, ‘Int8Array’, ‘Int16Array’, ‘Int32Array’, ‘Map’, ‘Math’, ‘Object’, ‘Promise’, ‘RegExp’, ‘Set’, ‘String’, ‘Symbol’, ‘TypeError’, ‘Uint8Array’, ‘Uint8ClampedArray’, ‘Uint16Array’, ‘Uint32Array’, ‘WeakMap’, ‘_’, ‘clearTimeout’, ‘isFinite’, ‘parseInt’, ‘setTimeout’ ]; /** Used to make template sourceURLs easier to identify. / var templateCounter = -1; / Used to identify toStringTag values of typed arrays. */ var typedArrayTags = {}; typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true; typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false; / Used to identify toStringTag values supported by _.clone. / var cloneableTags = {}; cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true; cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false; /** Used to map Latin Unicode letters to basic Latin letters. / var deburredLetters = { // Latin-1 Supplement block. ‘\xc0’: ‘A’, ‘\xc1’: ‘A’, ‘\xc2’: ‘A’, ‘\xc3’: ‘A’, ‘\xc4’: ‘A’, ‘\xc5’: ‘A’, ‘\xe0’: ‘a’, ‘\xe1’: ‘a’, ‘\xe2’: ‘a’, ‘\xe3’: ‘a’, ‘\xe4’: ‘a’, ‘\xe5’: ‘a’, ‘\xc7’: ‘C’, ‘\xe7’: ‘c’, ‘\xd0’: ‘D’, ‘\xf0’: ‘d’, ‘\xc8’: ‘E’, ‘\xc9’: ‘E’, ‘\xca’: ‘E’, ‘\xcb’: ‘E’, ‘\xe8’: ‘e’, ‘\xe9’: ‘e’, ‘\xea’: ‘e’, ‘\xeb’: ‘e’, ‘\xcc’: ‘I’, ‘\xcd’: ‘I’, ‘\xce’: ‘I’, ‘\xcf’: ‘I’, ‘\xec’: ‘i’, ‘\xed’: ‘i’, ‘\xee’: ‘i’, ‘\xef’: ‘i’, ‘\xd1’: ‘N’, ‘\xf1’: ‘n’, ‘\xd2’: ‘O’, ‘\xd3’: ‘O’, ‘\xd4’: ‘O’, ‘\xd5’: ‘O’, ‘\xd6’: ‘O’, ‘\xd8’: ‘O’, ‘\xf2’: ‘o’, ‘\xf3’: ‘o’, ‘\xf4’: ‘o’, ‘\xf5’: ‘o’, ‘\xf6’: ‘o’, ‘\xf8’: ‘o’, ‘\xd9’: ‘U’, ‘\xda’: ‘U’, ‘\xdb’: ‘U’, ‘\xdc’: ‘U’, ‘\xf9’: ‘u’, ‘\xfa’: ‘u’, ‘\xfb’: ‘u’, ‘\xfc’: ‘u’, ‘\xdd’: ‘Y’, ‘\xfd’: ‘y’, ‘\xff’: ‘y’, ‘\xc6’: ‘Ae’, ‘\xe6’: ‘ae’, ‘\xde’: ‘Th’, ‘\xfe’: ‘th’, ‘\xdf’: ‘ss’, // Latin Extended-A block. ‘\u0100’: ‘A’, ‘\u0102’: ‘A’, ‘\u0104’: ‘A’, ‘\u0101’: ‘a’, ‘\u0103’: ‘a’, ‘\u0105’: ‘a’, ‘\u0106’: ‘C’, ‘\u0108’: ‘C’, ‘\u010a’: ‘C’, ‘\u010c’: ‘C’, ‘\u0107’: ‘c’, ‘\u0109’: ‘c’, ‘\u010b’: ‘c’, ‘\u010d’: ‘c’, ‘\u010e’: ‘D’, ‘\u0110’: ‘D’, ‘\u010f’: ‘d’, ‘\u0111’: ‘d’, ‘\u0112’: ‘E’, ‘\u0114’: ‘E’, ‘\u0116’: ‘E’, ‘\u0118’: ‘E’, ‘\u011a’: ‘E’, ‘\u0113’: ‘e’, ‘\u0115’: ‘e’, ‘\u0117’: ‘e’, ‘\u0119’: ‘e’, ‘\u011b’: ‘e’, ‘\u011c’: ‘G’, ‘\u011e’: ‘G’, ‘\u0120’: ‘G’, ‘\u0122’: ‘G’, ‘\u011d’: ‘g’, ‘\u011f’: ‘g’, ‘\u0121’: ‘g’, ‘\u0123’: ‘g’, ‘\u0124’: ‘H’, ‘\u0126’: ‘H’, ‘\u0125’: ‘h’, ‘\u0127’: ‘h’, ‘\u0128’: ‘I’, ‘\u012a’: ‘I’, ‘\u012c’: ‘I’, ‘\u012e’: ‘I’, ‘\u0130’: ‘I’, ‘\u0129’: ‘i’, ‘\u012b’: ‘i’, ‘\u012d’: ‘i’, ‘\u012f’: ‘i’, ‘\u0131’: ‘i’, ‘\u0134’: ‘J’, ‘\u0135’: ‘j’, ‘\u0136’: ‘K’, ‘\u0137’: ‘k’, ‘\u0138’: ‘k’, ‘\u0139’: ‘L’, ‘\u013b’: ‘L’, ‘\u013d’: ‘L’, ‘\u013f’: ‘L’, ‘\u0141’: ‘L’, ‘\u013a’: ‘l’, ‘\u013c’: ‘l’, ‘\u013e’: ‘l’, ‘\u0140’: ‘l’, ‘\u0142’: ‘l’, ‘\u0143’: ‘N’, ‘\u0145’: ‘N’, ‘\u0147’: ‘N’, ‘\u014a’: ‘N’, ‘\u0144’: ‘n’, ‘\u0146’: ‘n’, ‘\u0148’: ‘n’, ‘\u014b’: ‘n’, ‘\u014c’: ‘O’, ‘\u014e’: ‘O’, ‘\u0150’: ‘O’, ‘\u014d’: ‘o’, ‘\u014f’: ‘o’, ‘\u0151’: ‘o’, ‘\u0154’: ‘R’, ‘\u0156’: ‘R’, ‘\u0158’: ‘R’, ‘\u0155’: ‘r’, ‘\u0157’: ‘r’, ‘\u0159’: ‘r’, ‘\u015a’: ‘S’, ‘\u015c’: ‘S’, ‘\u015e’: ‘S’, ‘\u0160’: ‘S’, ‘\u015b’: ‘s’, ‘\u015d’: ‘s’, ‘\u015f’: ‘s’, ‘\u0161’: ‘s’, ‘\u0162’: ‘T’, ‘\u0164’: ‘T’, ‘\u0166’: ‘T’, ‘\u0163’: ‘t’, ‘\u0165’: ‘t’, ‘\u0167’: ‘t’, ‘\u0168’: ‘U’, ‘\u016a’: ‘U’, ‘\u016c’: ‘U’, ‘\u016e’: ‘U’, ‘\u0170’: ‘U’, ‘\u0172’: ‘U’, ‘\u0169’: ‘u’, ‘\u016b’: ‘u’, ‘\u016d’: ‘u’, ‘\u016f’: ‘u’, ‘\u0171’: ‘u’, ‘\u0173’: ‘u’, ‘\u0174’: ‘W’, ‘\u0175’: ‘w’, ‘\u0176’: ‘Y’, ‘\u0177’: ‘y’, ‘\u0178’: ‘Y’, ‘\u0179’: ‘Z’, ‘\u017b’: ‘Z’, ‘\u017d’: ‘Z’, ‘\u017a’: ‘z’, ‘\u017c’: ‘z’, ‘\u017e’: ‘z’, ‘\u0132’: ‘IJ’, ‘\u0133’: ‘ij’, ‘\u0152’: ‘Oe’, ‘\u0153’: ‘oe’, ‘\u0149’: “‘n”, ‘\u017f’: ‘s’ }; / Used to map characters to HTML entities. */ var htmlEscapes = { ‘&amp;’: ‘&amp;’, ‘&lt;’: ‘&lt;’, ‘&gt;’: ‘&gt;’, ‘“‘: ‘&quot;’, “‘“: ‘&#39;’ }; / Used to map HTML entities to characters. / var htmlUnescapes = { ‘&amp;’: ‘&amp;’, ‘&lt;’: ‘&lt;’, ‘&gt;’: ‘&gt;’, ‘&quot;’: ‘“‘, ‘&#39;’: “‘“ }; /** Used to escape characters for inclusion in compiled string literals. / var stringEscapes = { ‘\‘: ‘\‘, “‘“: “‘“, ‘\n’: ‘n’, ‘\r’: ‘r’, ‘\u2028’: ‘u2028’, ‘\u2029’: ‘u2029’ }; / Built-in method references without a dependency on root. */ var freeParseFloat = parseFloat, freeParseInt = parseInt; / Detect free variable global from Node.js. / var freeGlobal = typeof global == ‘object’ &amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global; /** Detect free variable self. / var freeSelf = typeof self == ‘object’ &amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self; / Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function(‘return this’)(); / Detect free variable exports. / var freeExports = typeof exports == ‘object’ &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports; /** Detect free variable module. / var freeModule = freeExports &amp;&amp; typeof module == ‘object’ &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module; / Detect the popular CommonJS extension module.exports. */ var moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports; / Detect free variable process from Node.js. / var freeProcess = moduleExports &amp;&amp; freeGlobal.process; /** Used to access faster Node.js helpers. / var nodeUtil = (function() { try { // Use util.types for Node.js 10+. var types = freeModule &amp;&amp; freeModule.require &amp;&amp; freeModule.require(‘util’).types; if (types) { return types; } // Legacy process.binding(&#39;util&#39;) for Node.js &lt; 10. return freeProcess &amp;&amp; freeProcess.binding &amp;&amp; freeProcess.binding(‘util’); } catch (e) {} }()); / Node.js helper references. / var nodeIsArrayBuffer = nodeUtil &amp;&amp; nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil &amp;&amp; nodeUtil.isDate, nodeIsMap = nodeUtil &amp;&amp; nodeUtil.isMap, nodeIsRegExp = nodeUtil &amp;&amp; nodeUtil.isRegExp, nodeIsSet = nodeUtil &amp;&amp; nodeUtil.isSet, nodeIsTypedArray = nodeUtil &amp;&amp; nodeUtil.isTypedArray; /————————————————————————–/ / A faster alternative to Function#apply, this function invokes func with the this binding of thisArg and the arguments of args. @private @param {Function} func The function to invoke. @param {} thisArg The this binding of func. @param {Array} args The arguments to invoke func with. @returns {} Returns the result of func. */ function apply(func, thisArg, args) { switch (args.length) { case 0: return func.call(thisArg); case 1: return func.call(thisArg, args[0]); case 2: return func.call(thisArg, args[0], args[1]); case 3: return func.call(thisArg, args[0], args[1], args[2]); } return func.apply(thisArg, args); } / A specialized version of baseAggregator for arrays. @private @param {Array} [array] The array to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform keys. @param {Object} accumulator The initial aggregated object. @returns {Function} Returns accumulator. / function arrayAggregator(array, setter, iteratee, accumulator) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { var value = array[index]; setter(accumulator, value, iteratee(value), array); } return accumulator; } /** A specialized version of _.forEach for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns array. / function arrayEach(array, iteratee) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (iteratee(array[index], index, array) === false) { break; } } return array; } /** A specialized version of _.forEachRight for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns array. / function arrayEachRight(array, iteratee) { var length = array == null ? 0 : array.length; while (length–) { if (iteratee(array[length], length, array) === false) { break; } } return array; } /** A specialized version of _.every for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if all elements pass the predicate check, else false. / function arrayEvery(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (!predicate(array[index], index, array)) { return false; } } return true; } / A specialized version of _.filter for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {Array} Returns the new filtered array. / function arrayFilter(array, predicate) { var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (predicate(value, index, array)) { result[resIndex++] = value; } } return result; } / A specialized version of _.includes for arrays without support for specifying an index to search from. @private @param {Array} [array] The array to inspect. @param {} target The value to search for. @returns {boolean} Returns true if target is found, else false. / function arrayIncludes(array, value) { var length = array == null ? 0 : array.length; return !!length &amp;&amp; baseIndexOf(array, value, 0) &gt; -1; } /** This function is like arrayIncludes except that it accepts a comparator. @private @param {Array} [array] The array to inspect. @param {} target The value to search for. @param {Function} comparator The comparator invoked per element. @returns {boolean} Returns true if target is found, else false. / function arrayIncludesWith(array, value, comparator) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (comparator(value, array[index])) { return true; } } return false; } / A specialized version of _.map for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the new mapped array. / function arrayMap(array, iteratee) { var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index &lt; length) { result[index] = iteratee(array[index], index, array); } return result; } / Appends the elements of values to array. @private @param {Array} array The array to modify. @param {Array} values The values to append. @returns {Array} Returns array. / function arrayPush(array, values) { var index = -1, length = values.length, offset = array.length; while (++index &lt; length) { array[offset + index] = values[index]; } return array; } /** A specialized version of _.reduce for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} [accumulator] The initial value. @param {boolean} [initAccum] Specify using the first element of array as the initial value. @returns {} Returns the accumulated value. / function arrayReduce(array, iteratee, accumulator, initAccum) { var index = -1, length = array == null ? 0 : array.length; if (initAccum &amp;&amp; length) { accumulator = array[++index]; } while (++index &lt; length) { accumulator = iteratee(accumulator, array[index], index, array); } return accumulator; } / A specialized version of _.reduceRight for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} [accumulator] The initial value. @param {boolean} [initAccum] Specify using the last element of array as the initial value. @returns {} Returns the accumulated value. */ function arrayReduceRight(array, iteratee, accumulator, initAccum) { var length = array == null ? 0 : array.length; if (initAccum &amp;&amp; length) { accumulator = array[–length]; } while (length–) { accumulator = iteratee(accumulator, array[length], length, array); } return accumulator; } / A specialized version of _.some for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if any element passes the predicate check, else false. / function arraySome(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (predicate(array[index], index, array)) { return true; } } return false; } /** Gets the size of an ASCII string. @private @param {string} string The string inspect. @returns {number} Returns the string size. / var asciiSize = baseProperty(‘length’); /** Converts an ASCII string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function asciiToArray(string) { return string.split(‘’); } /** Splits an ASCII string into an array of its words. @private @param {string} The string to inspect. @returns {Array} Returns the words of string. / function asciiWords(string) { return string.match(reAsciiWord) || []; } /** The base implementation of methods like _.findKey and _.findLastKey, without support for iteratee shorthands, which iterates over collection using eachFunc. @private @param {Array|Object} collection The collection to inspect. @param {Function} predicate The function invoked per iteration. @param {Function} eachFunc The function to iterate over collection. @returns {} Returns the found element or its key, else undefined. / function baseFindKey(collection, predicate, eachFunc) { var result; eachFunc(collection, function(value, key, collection) { if (predicate(value, key, collection)) { result = key; return false; } }); return result; } / The base implementation of _.findIndex and _.findLastIndex without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} predicate The function invoked per iteration. @param {number} fromIndex The index to search from. @param {boolean} [fromRight] Specify iterating from right to left. @returns {number} Returns the index of the matched value, else -1. / function baseFindIndex(array, predicate, fromIndex, fromRight) { var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while ((fromRight ? index– : ++index &lt; length)) { if (predicate(array[index], index, array)) { return index; } } return -1; } / The base implementation of _.indexOf without fromIndex bounds checks. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function baseIndexOf(array, value, fromIndex) { return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex); } /** This function is like baseIndexOf except that it accepts a comparator. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @param {Function} comparator The comparator invoked per element. @returns {number} Returns the index of the matched value, else -1. / function baseIndexOfWith(array, value, fromIndex, comparator) { var index = fromIndex - 1, length = array.length; while (++index &lt; length) { if (comparator(array[index], value)) { return index; } } return -1; } /** The base implementation of _.isNaN without support for number objects. @private @param {} value The value to check. @returns {boolean} Returns true if value is NaN, else false. / function baseIsNaN(value) { return value !== value; } / The base implementation of _.mean and _.meanBy without support for iteratee shorthands. @private @param {Array} array The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {number} Returns the mean. / function baseMean(array, iteratee) { var length = array == null ? 0 : array.length; return length ? (baseSum(array, iteratee) / length) : NAN; } / The base implementation of _.property without support for deep paths. @private @param {string} key The key of the property to get. @returns {Function} Returns the new accessor function. / function baseProperty(key) { return function(object) { return object == null ? undefined : object[key]; }; } / The base implementation of _.propertyOf without support for deep paths. @private @param {Object} object The object to query. @returns {Function} Returns the new accessor function. / function basePropertyOf(object) { return function(key) { return object == null ? undefined : object[key]; }; } / The base implementation of _.reduce and _.reduceRight, without support for iteratee shorthands, which iterates over collection using eachFunc. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} accumulator The initial value. @param {boolean} initAccum Specify using the first or last element of collection as the initial value. @param {Function} eachFunc The function to iterate over collection. @returns {} Returns the accumulated value. / function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) { eachFunc(collection, function(value, index, collection) { accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection); }); return accumulator; } / The base implementation of _.sortBy which uses comparer to define the sort order of array and replaces criteria objects with their corresponding values. @private @param {Array} array The array to sort. @param {Function} comparer The function to define sort order. @returns {Array} Returns array. */ function baseSortBy(array, comparer) { var length = array.length; array.sort(comparer); while (length–) { array[length] = array[length].value; } return array; } / The base implementation of _.sum and _.sumBy without support for iteratee shorthands. @private @param {Array} array The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {number} Returns the sum. / function baseSum(array, iteratee) { var result, index = -1, length = array.length; while (++index &lt; length) { var current = iteratee(array[index]); if (current !== undefined) { result = result === undefined ? current : (result + current); } } return result; } / The base implementation of _.times without support for iteratee shorthands or max array length checks. @private @param {number} n The number of times to invoke iteratee. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the array of results. / function baseTimes(n, iteratee) { var index = -1, result = Array(n); while (++index &lt; n) { result[index] = iteratee(index); } return result; } / The base implementation of _.toPairs and _.toPairsIn which creates an array of key-value pairs for object corresponding to the property names of props. @private @param {Object} object The object to query. @param {Array} props The property names to get values for. @returns {Object} Returns the key-value pairs. / function baseToPairs(object, props) { return arrayMap(props, function(key) { return [key, object[key]]; }); } / The base implementation of _.unary without support for storing metadata. @private @param {Function} func The function to cap arguments for. @returns {Function} Returns the new capped function. / function baseUnary(func) { return function(value) { return func(value); }; } / The base implementation of _.values and _.valuesIn which creates an array of object property values corresponding to the property names of props. @private @param {Object} object The object to query. @param {Array} props The property names to get values for. @returns {Object} Returns the array of property values. / function baseValues(object, props) { return arrayMap(props, function(key) { return object[key]; }); } /** Checks if a cache value for key exists. @private @param {Object} cache The cache to query. @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function cacheHas(cache, key) { return cache.has(key); } / Used by _.trim and _.trimStart to get the index of the first string symbol that is not found in the character symbols. @private @param {Array} strSymbols The string symbols to inspect. @param {Array} chrSymbols The character symbols to find. @returns {number} Returns the index of the first unmatched string symbol. / function charsStartIndex(strSymbols, chrSymbols) { var index = -1, length = strSymbols.length; while (++index &lt; length &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], 0) &gt; -1) {} return index; } / Used by _.trim and _.trimEnd to get the index of the last string symbol that is not found in the character symbols. @private @param {Array} strSymbols The string symbols to inspect. @param {Array} chrSymbols The character symbols to find. @returns {number} Returns the index of the last unmatched string symbol. / function charsEndIndex(strSymbols, chrSymbols) { var index = strSymbols.length; while (index– &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], 0) &gt; -1) {} return index; } / Gets the number of placeholder occurrences in array. @private @param {Array} array The array to inspect. @param {} placeholder The placeholder to search for. @returns {number} Returns the placeholder count. / function countHolders(array, placeholder) { var length = array.length, result = 0; while (length–) { if (array[length] === placeholder) { ++result; } } return result; } / Used by _.deburr to convert Latin-1 Supplement and Latin Extended-A letters to basic Latin letters. @private @param {string} letter The matched letter to deburr. @returns {string} Returns the deburred letter. / var deburrLetter = basePropertyOf(deburredLetters); /** Used by _.escape to convert characters to HTML entities. @private @param {string} chr The matched character to escape. @returns {string} Returns the escaped character. / var escapeHtmlChar = basePropertyOf(htmlEscapes); /** Used by _.template to escape characters for inclusion in compiled string literals. @private @param {string} chr The matched character to escape. @returns {string} Returns the escaped character. / function escapeStringChar(chr) { return ‘\‘ + stringEscapes[chr]; } /** Gets the value at key of object. @private @param {Object} [object] The object to query. @param {string} key The key of the property to get. @returns {} Returns the property value. / function getValue(object, key) { return object == null ? undefined : object[key]; } /** Checks if string contains Unicode symbols. @private @param {string} string The string to inspect. @returns {boolean} Returns true if a symbol is found, else false. / function hasUnicode(string) { return reHasUnicode.test(string); } /** Checks if string contains a word composed of Unicode symbols. @private @param {string} string The string to inspect. @returns {boolean} Returns true if a word is found, else false. / function hasUnicodeWord(string) { return reHasUnicodeWord.test(string); } /** Converts iterator to an array. @private @param {Object} iterator The iterator to convert. @returns {Array} Returns the converted array. / function iteratorToArray(iterator) { var data, result = []; while (!(data = iterator.next()).done) { result.push(data.value); } return result; } /** Converts map to its key-value pairs. @private @param {Object} map The map to convert. @returns {Array} Returns the key-value pairs. / function mapToArray(map) { var index = -1, result = Array(map.size); map.forEach(function(value, key) { result[++index] = [key, value]; }); return result; } /** Creates a unary function that invokes func with its argument transformed. @private @param {Function} func The function to wrap. @param {Function} transform The argument transform. @returns {Function} Returns the new function. / function overArg(func, transform) { return function(arg) { return func(transform(arg)); }; } / Replaces all placeholder elements in array with an internal placeholder and returns an array of their indexes. @private @param {Array} array The array to modify. @param {} placeholder The placeholder to replace. @returns {Array} Returns the new array of placeholder indexes. */ function replaceHolders(array, placeholder) { var index = -1, length = array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (value === placeholder || value === PLACEHOLDER) { array[index] = PLACEHOLDER; result[resIndex++] = index; } } return result; } / Converts set to an array of its values. @private @param {Object} set The set to convert. @returns {Array} Returns the values. / function setToArray(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = value; }); return result; } / Converts set to its value-value pairs. @private @param {Object} set The set to convert. @returns {Array} Returns the value-value pairs. / function setToPairs(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = [value, value]; }); return result; } / A specialized version of _.indexOf which performs strict equality comparisons of values, i.e. ===. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function strictIndexOf(array, value, fromIndex) { var index = fromIndex - 1, length = array.length; while (++index &lt; length) { if (array[index] === value) { return index; } } return -1; } / A specialized version of _.lastIndexOf which performs strict equality comparisons of values, i.e. ===. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function strictLastIndexOf(array, value, fromIndex) { var index = fromIndex + 1; while (index–) { if (array[index] === value) { return index; } } return index; } / Gets the number of symbols in string. @private @param {string} string The string to inspect. @returns {number} Returns the string size. / function stringSize(string) { return hasUnicode(string) ? unicodeSize(string) : asciiSize(string); } / Converts string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function stringToArray(string) { return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string); } / Used by _.unescape to convert HTML entities to characters. @private @param {string} chr The matched character to unescape. @returns {string} Returns the unescaped character. / var unescapeHtmlChar = basePropertyOf(htmlUnescapes); / Gets the size of a Unicode string. @private @param {string} string The string inspect. @returns {number} Returns the string size. / function unicodeSize(string) { var result = reUnicode.lastIndex = 0; while (reUnicode.test(string)) { ++result; } return result; } / Converts a Unicode string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function unicodeToArray(string) { return string.match(reUnicode) || []; } / Splits a Unicode string into an array of its words. @private @param {string} The string to inspect. @returns {Array} Returns the words of string. / function unicodeWords(string) { return string.match(reUnicodeWord) || []; } /————————————————————————–/ / Create a new pristine lodash function using the context object. @static @memberOf _ @since 1.1.0 @category Util @param {Object} [context=root] The context object. @returns {Function} Returns a new lodash function. @example _.mixin({ ‘foo’: _.constant(‘foo’) }); var lodash = _.runInContext(); lodash.mixin({ ‘bar’: lodash.constant(‘bar’) }); .isFunction(.foo); // =&gt; true .isFunction(.bar); // =&gt; false lodash.isFunction(lodash.foo); // =&gt; false lodash.isFunction(lodash.bar); // =&gt; true // Create a suped-up defer in Node.js. var defer = _.runInContext({ ‘setTimeout’: setImmediate }).defer; / var runInContext = (function runInContext(context) { context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps)); / Built-in constructor references. */ var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError; / Used for built-in method references. / var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype; /** Used to detect overreaching core-js shims. / var coreJsData = context[‘core-js_shared‘]; / Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString; / Used to check objects for own properties. / var hasOwnProperty = objectProto.hasOwnProperty; /** Used to generate unique IDs. / var idCounter = 0; / Used to detect methods masquerading as native. */ var maskSrcKey = (function() { var uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || ‘’); return uid ? (‘Symbol(src)_1.’ + uid) : ‘’; }()); / Used to resolve the toStringTag of values. / var nativeObjectToString = objectProto.toString; / Used to infer the Object constructor. */ var objectCtorString = funcToString.call(Object); / Used to restore the original _ reference in _.noConflict. / var oldDash = root._; /** Used to detect if a method is native. / var reIsNative = RegExp(‘^’ + funcToString.call(hasOwnProperty).replace(reRegExpChar, ‘\$&amp;’) .replace(/hasOwnProperty|(function).?(?=\()| for .+?(?=\])/g, ‘$1.?’) + ‘$’ ); / Built-in value references. */ var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined; var defineProperty = (function() { try { var func = getNative(Object, ‘defineProperty’); func({}, ‘’, {}); return func; } catch (e) {} }()); / Mocked built-ins. / var ctxClearTimeout = context.clearTimeout !== root.clearTimeout &amp;&amp; context.clearTimeout, ctxNow = Date &amp;&amp; Date.now !== root.Date.now &amp;&amp; Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout &amp;&amp; context.setTimeout; / Built-in method references for those with the same name as other lodash methods. / var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse; / Built-in method references that are verified to be native. / var DataView = getNative(context, ‘DataView’), Map = getNative(context, ‘Map’), Promise = getNative(context, ‘Promise’), Set = getNative(context, ‘Set’), WeakMap = getNative(context, ‘WeakMap’), nativeCreate = getNative(Object, ‘create’); /** Used to store function metadata. / var metaMap = WeakMap &amp;&amp; new WeakMap; / Used to lookup unminified function names. */ var realNames = {}; / Used to detect maps, sets, and weakmaps. / var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap); /** Used to convert symbols to primitives and strings. / var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined; /————————————————————————/ / Creates a lodash object which wraps value to enable implicit method chain sequences. Methods that operate on and return arrays, collections, and functions can be chained together. Methods that retrieve a single value or may return a primitive value will automatically end the chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with _#value. Explicit chain sequences, which must be unwrapped with _#value, may be enabled using _.chain. The execution of chained methods is lazy, that is, it’s deferred until _#value is implicitly or explicitly called. Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion is an optimization to merge iteratee calls; this avoids the creation of intermediate arrays and can greatly reduce the number of iteratee executions. Sections of a chain sequence qualify for shortcut fusion if the section is applied to an array and iteratees accept only one argument. The heuristic for whether a section qualifies for shortcut fusion is subject to change. Chaining is supported in custom builds as long as the _#value method is directly or indirectly included in the build. In addition to lodash methods, wrappers have Array and String methods. The wrapper Array methods are: concat, join, pop, push, shift, sort, splice, and unshift The wrapper String methods are: replace and split The wrapper methods that support shortcut fusion are: at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last, map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray The chainable wrapper methods are: after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey, castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create, curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith, drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap, flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight, fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith, invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues, matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate, nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight, partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt, push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith, shuffle, slice, sort, sortBy, splice, spread, tail, take, takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn, toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith, unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap, xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith The wrapper methods that are not chainable by default are: add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith, conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp, every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach, forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head, identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith, isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN, isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join, kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy, min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop, random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size, snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase, startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy, template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger, toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase, upperFirst, value, and words @name _ @constructor @category Seq @param {} value The value to wrap in a lodash instance. @returns {Object} Returns the new lodash wrapper instance. @example function square(n) { return n n; } var wrapped = ([1, 2, 3]); // Returns an unwrapped value. * wrapped.reduce(.add); // =&gt; 6 // Returns a wrapped value. var squares = wrapped.map(square); _.isArray(squares); // =&gt; false _.isArray(squares.value()); // =&gt; true */ function lodash(value) { if (isObjectLike(value) &amp;&amp; !isArray(value) &amp;&amp; !(value instanceof LazyWrapper)) { if (value instanceof LodashWrapper) { return value; } if (hasOwnProperty.call(value, ‘wrapped‘)) { return wrapperClone(value); } } return new LodashWrapper(value); } / The base implementation of _.create without support for assigning properties to the created object. @private @param {Object} proto The object to inherit from. @returns {Object} Returns the new object. / var baseCreate = (function() { function object() {} return function(proto) { if (!isObject(proto)) { return {}; } if (objectCreate) { return objectCreate(proto); } object.prototype = proto; var result = new object; object.prototype = undefined; return result; }; }()); /** The function whose prototype chain sequence wrappers inherit from. @private / function baseLodash() { // No operation performed. } /** The base constructor for creating lodash wrapper objects. @private @param {} value The value to wrap. @param {boolean} [chainAll] Enable explicit method chain sequences. / function LodashWrapper(value, chainAll) { this.wrapped = value; this.actions = []; this.chain = !!chainAll; this.index = 0; this.values = undefined; } / By default, the template delimiters used by lodash are like those in embedded Ruby (ERB) as well as ES2015 template strings. Change the following template settings to use alternative delimiters. @static @memberOf _ @type {Object} / lodash.templateSettings = { / Used to detect data property values to be HTML-escaped. @memberOf _.templateSettings @type {RegExp} / ‘escape’: reEscape, /** Used to detect code to be evaluated. @memberOf _.templateSettings @type {RegExp} / ‘evaluate’: reEvaluate, / Used to detect data property values to inject. @memberOf _.templateSettings @type {RegExp} */ ‘interpolate’: reInterpolate, / Used to reference the data object in the template text. @memberOf _.templateSettings @type {string} / ‘variable’: ‘’, /** Used to import variables into the compiled template. @memberOf _.templateSettings @type {Object} / ‘imports’: { / A reference to the lodash function. @memberOf _.templateSettings.imports @type {Function} / ‘_’: lodash } }; // Ensure wrappers are instances of baseLodash. lodash.prototype = baseLodash.prototype; lodash.prototype.constructor = lodash; LodashWrapper.prototype = baseCreate(baseLodash.prototype); LodashWrapper.prototype.constructor = LodashWrapper; /————————————————————————*/ / Creates a lazy wrapper object which wraps value to enable lazy evaluation. @private @constructor @param {} value The value to wrap. / function LazyWrapper(value) { this.wrapped = value; this.actions = []; this.dir = 1; this.filtered = false; this.iteratees = []; this.takeCount = MAX_ARRAY_LENGTH; this.views = []; } /** Creates a clone of the lazy wrapper object. @private @name clone @memberOf LazyWrapper @returns {Object} Returns the cloned LazyWrapper object. / function lazyClone() { var result = new LazyWrapper(this.wrapped); result.actions = copyArray(this.actions); result.dir = this.dir; result.filtered = this.filtered; result.iteratees = copyArray(this.iteratees); result.takeCount = this.takeCount; result.views = copyArray(this.views); return result; } / Reverses the direction of lazy iteration. @private @name reverse @memberOf LazyWrapper @returns {Object} Returns the new reversed LazyWrapper object. / function lazyReverse() { if (this.filtered) { var result = new LazyWrapper(this); result.dir = -1; result.filtered = true; } else { result = this.clone(); result.dir = -1; } return result; } / Extracts the unwrapped value from its lazy wrapper. @private @name value @memberOf LazyWrapper @returns {} Returns the unwrapped value. / function lazyValue() { var array = this.wrapped.value(), dir = this.dir, isArr = isArray(array), isRight = dir &lt; 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.views), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.iteratees, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.takeCount); if (!isArr || (!isRight &amp;&amp; arrLength == length &amp;&amp; takeCount == length)) { return baseWrapperValue(array, this.actions); } var result = []; outer: while (length– &amp;&amp; resIndex &lt; takeCount) { index += dir; var iterIndex = -1, value = array[index]; while (++iterIndex &lt; iterLength) { var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value); if (type == LAZY_MAP_FLAG) { value = computed; } else if (!computed) { if (type == LAZY_FILTER_FLAG) { continue outer; } else { break outer; } } } result[resIndex++] = value; } return result; } // Ensure LazyWrapper is an instance of baseLodash. LazyWrapper.prototype = baseCreate(baseLodash.prototype); LazyWrapper.prototype.constructor = LazyWrapper; /————————————————————————/ / Creates a hash object. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function Hash(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } / Removes all key-value entries from the hash. @private @name clear @memberOf Hash / function hashClear() { this.data = nativeCreate ? nativeCreate(null) : {}; this.size = 0; } / Removes key and its value from the hash. @private @name delete @memberOf Hash @param {Object} hash The hash to modify. @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. */ function hashDelete(key) { var result = this.has(key) &amp;&amp; delete this.data[key]; this.size -= result ? 1 : 0; return result; } / Gets the hash value for key. @private @name get @memberOf Hash @param {string} key The key of the value to get. @returns {} Returns the entry value. / function hashGet(key) { var data = this.data; if (nativeCreate) { var result = data[key]; return result === HASH_UNDEFINED ? undefined : result; } return hasOwnProperty.call(data, key) ? data[key] : undefined; } /** Checks if a hash value for key exists. @private @name has @memberOf Hash @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function hashHas(key) { var data = this.data; return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key); } /** Sets the hash key to value. @private @name set @memberOf Hash @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the hash instance. / function hashSet(key, value) { var data = this.data; this.size += this.has(key) ? 0 : 1; data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value; return this; } // Add methods to Hash. Hash.prototype.clear = hashClear; Hash.prototype[‘delete’] = hashDelete; Hash.prototype.get = hashGet; Hash.prototype.has = hashHas; Hash.prototype.set = hashSet; /————————————————————————/ /** Creates an list cache object. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function ListCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } /** Removes all key-value entries from the list cache. @private @name clear @memberOf ListCache / function listCacheClear() { this.data = []; this.size = 0; } /** Removes key and its value from the list cache. @private @name delete @memberOf ListCache @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function listCacheDelete(key) { var data = this.data, index = assocIndexOf(data, key); if (index &lt; 0) { return false; } var lastIndex = data.length - 1; if (index == lastIndex) { data.pop(); } else { splice.call(data, index, 1); } –this.size; return true; } /** Gets the list cache value for key. @private @name get @memberOf ListCache @param {string} key The key of the value to get. @returns {} Returns the entry value. / function listCacheGet(key) { var data = this.data, index = assocIndexOf(data, key); return index &lt; 0 ? undefined : data[index][1]; } / Checks if a list cache value for key exists. @private @name has @memberOf ListCache @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function listCacheHas(key) { return assocIndexOf(this.data, key) &gt; -1; } / Sets the list cache key to value. @private @name set @memberOf ListCache @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the list cache instance. / function listCacheSet(key, value) { var data = this.data, index = assocIndexOf(data, key); if (index &lt; 0) { ++this.size; data.push([key, value]); } else { data[index][1] = value; } return this; } // Add methods to ListCache. ListCache.prototype.clear = listCacheClear; ListCache.prototype[‘delete’] = listCacheDelete; ListCache.prototype.get = listCacheGet; ListCache.prototype.has = listCacheHas; ListCache.prototype.set = listCacheSet; /————————————————————————/ / Creates a map cache object to store key-value pairs. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function MapCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } / Removes all key-value entries from the map. @private @name clear @memberOf MapCache / function mapCacheClear() { this.size = 0; this.data = { ‘hash’: new Hash, ‘map’: new (Map || ListCache), ‘string’: new Hash }; } / Removes key and its value from the map. @private @name delete @memberOf MapCache @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function mapCacheDelete(key) { var result = getMapData(this, key)‘delete’; this.size -= result ? 1 : 0; return result; } / Gets the map value for key. @private @name get @memberOf MapCache @param {string} key The key of the value to get. @returns {} Returns the entry value. / function mapCacheGet(key) { return getMapData(this, key).get(key); } /** Checks if a map value for key exists. @private @name has @memberOf MapCache @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function mapCacheHas(key) { return getMapData(this, key).has(key); } /** Sets the map key to value. @private @name set @memberOf MapCache @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the map cache instance. / function mapCacheSet(key, value) { var data = getMapData(this, key), size = data.size; data.set(key, value); this.size += data.size == size ? 0 : 1; return this; } // Add methods to MapCache. MapCache.prototype.clear = mapCacheClear; MapCache.prototype[‘delete’] = mapCacheDelete; MapCache.prototype.get = mapCacheGet; MapCache.prototype.has = mapCacheHas; MapCache.prototype.set = mapCacheSet; /————————————————————————/ /** Creates an array cache object to store unique values. @private @constructor @param {Array} [values] The values to cache. / function SetCache(values) { var index = -1, length = values == null ? 0 : values.length; this.data = new MapCache; while (++index &lt; length) { this.add(values[index]); } } / Adds value to the array cache. @private @name add @memberOf SetCache @alias push @param {} value The value to cache. @returns {Object} Returns the cache instance. / function setCacheAdd(value) { this.data.set(value, HASH_UNDEFINED); return this; } / Checks if value is in the array cache. @private @name has @memberOf SetCache @param {} value The value to search for. @returns {number} Returns true if value is found, else false. / function setCacheHas(value) { return this.data.has(value); } // Add methods to SetCache. SetCache.prototype.add = SetCache.prototype.push = setCacheAdd; SetCache.prototype.has = setCacheHas; /————————————————————————/ /** Creates a stack cache object to store key-value pairs. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function Stack(entries) { var data = this.data = new ListCache(entries); this.size = data.size; } /** Removes all key-value entries from the stack. @private @name clear @memberOf Stack / function stackClear() { this.data = new ListCache; this.size = 0; } /** Removes key and its value from the stack. @private @name delete @memberOf Stack @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function stackDelete(key) { var data = this.data, result = data‘delete’; this.size = data.size; return result; } /** Gets the stack value for key. @private @name get @memberOf Stack @param {string} key The key of the value to get. @returns {} Returns the entry value. / function stackGet(key) { return this.data.get(key); } / Checks if a stack value for key exists. @private @name has @memberOf Stack @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function stackHas(key) { return this.data.has(key); } / Sets the stack key to value. @private @name set @memberOf Stack @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the stack cache instance. / function stackSet(key, value) { var data = this.data; if (data instanceof ListCache) { var pairs = data.data; if (!Map || (pairs.length &lt; LARGE_ARRAY_SIZE - 1)) { pairs.push([key, value]); this.size = ++data.size; return this; } data = this.data = new MapCache(pairs); } data.set(key, value); this.size = data.size; return this; } // Add methods to Stack. Stack.prototype.clear = stackClear; Stack.prototype[‘delete’] = stackDelete; Stack.prototype.get = stackGet; Stack.prototype.has = stackHas; Stack.prototype.set = stackSet; /————————————————————————/ / Creates an array of the enumerable property names of the array-like value. @private @param {} value The value to query. @param {boolean} inherited Specify returning inherited property names. @returns {Array} Returns the array of property names. / function arrayLikeKeys(value, inherited) { var isArr = isArray(value), isArg = !isArr &amp;&amp; isArguments(value), isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value), isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) { if ((inherited || hasOwnProperty.call(value, key)) &amp;&amp; !(skipIndexes &amp;&amp; ( // Safari 9 has enumerable arguments.length in strict mode. key == ‘length’ || // Node.js 0.10 has enumerable non-index properties on buffers. (isBuff &amp;&amp; (key == ‘offset’ || key == ‘parent’)) || // PhantomJS 2 has enumerable non-index properties on typed arrays. (isType &amp;&amp; (key == ‘buffer’ || key == ‘byteLength’ || key == ‘byteOffset’)) || // Skip index properties. isIndex(key, length) ))) { result.push(key); } } return result; } / A specialized version of _.sample for arrays. @private @param {Array} array The array to sample. @returns {} Returns the random element. / function arraySample(array) { var length = array.length; return length ? array[baseRandom(0, length - 1)] : undefined; } /** A specialized version of _.sampleSize for arrays. @private @param {Array} array The array to sample. @param {number} n The number of elements to sample. @returns {Array} Returns the random elements. / function arraySampleSize(array, n) { return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length)); } / A specialized version of _.shuffle for arrays. @private @param {Array} array The array to shuffle. @returns {Array} Returns the new shuffled array. / function arrayShuffle(array) { return shuffleSelf(copyArray(array)); } / This function is like assignValue except that it doesn’t assign undefined values. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function assignMergeValue(object, key, value) { if ((value !== undefined &amp;&amp; !eq(object[key], value)) || (value === undefined &amp;&amp; !(key in object))) { baseAssignValue(object, key, value); } } /** Assigns value to key of object if the existing value is not equivalent using SameValueZero for equality comparisons. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function assignValue(object, key, value) { var objValue = object[key]; if (!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) || (value === undefined &amp;&amp; !(key in object))) { baseAssignValue(object, key, value); } } /** Gets the index at which the key is found in array of key-value pairs. @private @param {Array} array The array to inspect. @param {} key The key to search for. @returns {number} Returns the index of the matched value, else -1. / function assocIndexOf(array, key) { var length = array.length; while (length–) { if (eq(array[length][0], key)) { return length; } } return -1; } /** Aggregates elements of collection on accumulator with keys transformed by iteratee and values set by setter. @private @param {Array|Object} collection The collection to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform keys. @param {Object} accumulator The initial aggregated object. @returns {Function} Returns accumulator. / function baseAggregator(collection, setter, iteratee, accumulator) { baseEach(collection, function(value, key, collection) { setter(accumulator, value, iteratee(value), collection); }); return accumulator; } /** The base implementation of _.assign without support for multiple sources or customizer functions. @private @param {Object} object The destination object. @param {Object} source The source object. @returns {Object} Returns object. / function baseAssign(object, source) { return object &amp;&amp; copyObject(source, keys(source), object); } /** The base implementation of _.assignIn without support for multiple sources or customizer functions. @private @param {Object} object The destination object. @param {Object} source The source object. @returns {Object} Returns object. / function baseAssignIn(object, source) { return object &amp;&amp; copyObject(source, keysIn(source), object); } /** The base implementation of assignValue and assignMergeValue without value checks. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function baseAssignValue(object, key, value) { if (key == ‘proto‘ &amp;&amp; defineProperty) { defineProperty(object, key, { ‘configurable’: true, ‘enumerable’: true, ‘value’: value, ‘writable’: true }); } else { object[key] = value; } } / The base implementation of _.at without support for individual paths. @private @param {Object} object The object to iterate over. @param {string[]} paths The property paths to pick. @returns {Array} Returns the picked elements. */ function baseAt(object, paths) { var index = -1, length = paths.length, result = Array(length), skip = object == null; while (++index &lt; length) { result[index] = skip ? undefined : get(object, paths[index]); } return result; } / The base implementation of _.clamp which doesn’t coerce arguments. @private @param {number} number The number to clamp. @param {number} [lower] The lower bound. @param {number} upper The upper bound. @returns {number} Returns the clamped number. / function baseClamp(number, lower, upper) { if (number === number) { if (upper !== undefined) { number = number &lt;= upper ? number : upper; } if (lower !== undefined) { number = number &gt;= lower ? number : lower; } } return number; } / The base implementation of _.clone and _.cloneDeep which tracks traversed objects. @private @param {} value The value to clone. @param {boolean} bitmask The bitmask flags. 1 - Deep clone 2 - Flatten inherited properties 4 - Clone symbols @param {Function} [customizer] The function to customize cloning. @param {string} [key] The key of value. @param {Object} [object] The parent object of value. @param {Object} [stack] Tracks traversed objects and their clone counterparts. @returns {} Returns the cloned value. */ function baseClone(value, bitmask, customizer, key, object, stack) { var result, isDeep = bitmask &amp; CLONE_DEEP_FLAG, isFlat = bitmask &amp; CLONE_FLAT_FLAG, isFull = bitmask &amp; CLONE_SYMBOLS_FLAG; if (customizer) { result = object ? customizer(value, key, object, stack) : customizer(value); } if (result !== undefined) { return result; } if (!isObject(value)) { return value; } var isArr = isArray(value); if (isArr) { result = initCloneArray(value); if (!isDeep) { return copyArray(value, result); } } else { var tag = getTag(value), isFunc = tag == funcTag || tag == genTag; if (isBuffer(value)) { return cloneBuffer(value, isDeep); } if (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) { result = (isFlat || isFunc) ? {} : initCloneObject(value); if (!isDeep) { return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value)); } } else { if (!cloneableTags[tag]) { return object ? value : {}; } result = initCloneByTag(value, tag, isDeep); } } // Check for circular references and return its corresponding clone. stack || (stack = new Stack); var stacked = stack.get(value); if (stacked) { return stacked; } stack.set(value, result); if (isSet(value)) { value.forEach(function(subValue) { result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack)); }); return result; } if (isMap(value)) { value.forEach(function(subValue, key) { result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack)); }); return result; } var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys); var props = isArr ? undefined : keysFunc(value); arrayEach(props || value, function(subValue, key) { if (props) { key = subValue; subValue = value[key]; } // Recursively populate clone (susceptible to call stack limits). assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack)); }); return result; } / The base implementation of _.conforms which doesn’t clone source. @private @param {Object} source The object of property predicates to conform to. @returns {Function} Returns the new spec function. / function baseConforms(source) { var props = keys(source); return function(object) { return baseConformsTo(object, source, props); }; } / The base implementation of _.conformsTo which accepts props to check. @private @param {Object} object The object to inspect. @param {Object} source The object of property predicates to conform to. @returns {boolean} Returns true if object conforms, else false. */ function baseConformsTo(object, source, props) { var length = props.length; if (object == null) { return !length; } object = Object(object); while (length–) { var key = props[length], predicate = source[key], value = object[key]; if ((value === undefined &amp;&amp; !(key in object)) || !predicate(value)) { return false; } } return true; } / The base implementation of _.delay and _.defer which accepts args to provide to func. @private @param {Function} func The function to delay. @param {number} wait The number of milliseconds to delay invocation. @param {Array} args The arguments to provide to func. @returns {number|Object} Returns the timer id or timeout object. / function baseDelay(func, wait, args) { if (typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } return setTimeout(function() { func.apply(undefined, args); }, wait); } /** The base implementation of methods like _.difference without support for excluding multiple arrays or iteratee shorthands. @private @param {Array} array The array to inspect. @param {Array} values The values to exclude. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of filtered values. / function baseDifference(array, values, iteratee, comparator) { var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length; if (!length) { return result; } if (iteratee) { values = arrayMap(values, baseUnary(iteratee)); } if (comparator) { includes = arrayIncludesWith; isCommon = false; } else if (values.length &gt;= LARGE_ARRAY_SIZE) { includes = cacheHas; isCommon = false; values = new SetCache(values); } outer: while (++index &lt; length) { var value = array[index], computed = iteratee == null ? value : iteratee(value); value = (comparator || value !== 0) ? value : 0; if (isCommon &amp;&amp; computed === computed) { var valuesIndex = valuesLength; while (valuesIndex–) { if (values[valuesIndex] === computed) { continue outer; } } result.push(value); } else if (!includes(values, computed, comparator)) { result.push(value); } } return result; } /** The base implementation of _.forEach without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array|Object} Returns collection. / var baseEach = createBaseEach(baseForOwn); / The base implementation of _.forEachRight without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array|Object} Returns collection. */ var baseEachRight = createBaseEach(baseForOwnRight, true); / The base implementation of _.every without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if all elements pass the predicate check, else false / function baseEvery(collection, predicate) { var result = true; baseEach(collection, function(value, index, collection) { result = !!predicate(value, index, collection); return result; }); return result; } / The base implementation of methods like _.max and _.min which accepts a comparator to determine the extremum value. @private @param {Array} array The array to iterate over. @param {Function} iteratee The iteratee invoked per iteration. @param {Function} comparator The comparator used to compare values. @returns {} Returns the extremum value. / function baseExtremum(array, iteratee, comparator) { var index = -1, length = array.length; while (++index &lt; length) { var value = array[index], current = iteratee(value); if (current != null &amp;&amp; (computed === undefined ? (current === current &amp;&amp; !isSymbol(current)) : comparator(current, computed) )) { var computed = current, result = value; } } return result; } / The base implementation of _.fill without an iteratee call guard. @private @param {Array} array The array to fill. @param {} value The value to fill array with. @param {number} [start=0] The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns array. / function baseFill(array, value, start, end) { var length = array.length; start = toInteger(start); if (start &lt; 0) { start = -start &gt; length ? 0 : (length + start); } end = (end === undefined || end &gt; length) ? length : toInteger(end); if (end &lt; 0) { end += length; } end = start &gt; end ? 0 : toLength(end); while (start &lt; end) { array[start++] = value; } return array; } / The base implementation of _.filter without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {Array} Returns the new filtered array. */ function baseFilter(collection, predicate) { var result = []; baseEach(collection, function(value, index, collection) { if (predicate(value, index, collection)) { result.push(value); } }); return result; } / The base implementation of _.flatten with support for restricting flattening. @private @param {Array} array The array to flatten. @param {number} depth The maximum recursion depth. @param {boolean} [predicate=isFlattenable] The function invoked per iteration. @param {boolean} [isStrict] Restrict to values that pass predicate checks. @param {Array} [result=[]] The initial result value. @returns {Array} Returns the new flattened array. / function baseFlatten(array, depth, predicate, isStrict, result) { var index = -1, length = array.length; predicate || (predicate = isFlattenable); result || (result = []); while (++index &lt; length) { var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) { if (depth &gt; 1) { // Recursively flatten arrays (susceptible to call stack limits). baseFlatten(value, depth - 1, predicate, isStrict, result); } else { arrayPush(result, value); } } else if (!isStrict) { result[result.length] = value; } } return result; } / The base implementation of baseForOwn which iterates over object properties returned by keysFunc and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning false. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @param {Function} keysFunc The function to get the keys of object. @returns {Object} Returns object. / var baseFor = createBaseFor(); / This function is like baseFor except that it iterates over properties in the opposite order. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @param {Function} keysFunc The function to get the keys of object. @returns {Object} Returns object. / var baseForRight = createBaseFor(true); /** The base implementation of _.forOwn without support for iteratee shorthands. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Object} Returns object. / function baseForOwn(object, iteratee) { return object &amp;&amp; baseFor(object, iteratee, keys); } / The base implementation of _.forOwnRight without support for iteratee shorthands. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Object} Returns object. */ function baseForOwnRight(object, iteratee) { return object &amp;&amp; baseForRight(object, iteratee, keys); } / The base implementation of _.functions which creates an array of object function property names filtered from props. @private @param {Object} object The object to inspect. @param {Array} props The property names to filter. @returns {Array} Returns the function names. / function baseFunctions(object, props) { return arrayFilter(props, function(key) { return isFunction(object[key]); }); } / The base implementation of _.get without support for default values. @private @param {Object} object The object to query. @param {Array|string} path The path of the property to get. @returns {} Returns the resolved value. / function baseGet(object, path) { path = castPath(path, object); var index = 0, length = path.length; while (object != null &amp;&amp; index &lt; length) { object = object[toKey(path[index++])]; } return (index &amp;&amp; index == length) ? object : undefined; } / The base implementation of getAllKeys and getAllKeysIn which uses keysFunc and symbolsFunc to get the enumerable property names and symbols of object. @private @param {Object} object The object to query. @param {Function} keysFunc The function to get the keys of object. @param {Function} symbolsFunc The function to get the symbols of object. @returns {Array} Returns the array of property names and symbols. / function baseGetAllKeys(object, keysFunc, symbolsFunc) { var result = keysFunc(object); return isArray(object) ? result : arrayPush(result, symbolsFunc(object)); } / The base implementation of getTag without fallbacks for buggy environments. @private @param {} value The value to query. @returns {string} Returns the toStringTag. */ function baseGetTag(value) { if (value == null) { return value === undefined ? undefinedTag : nullTag; } return (symToStringTag &amp;&amp; symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value); } / The base implementation of _.gt which doesn’t coerce arguments. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {boolean} Returns true if value is greater than other, else false. / function baseGt(value, other) { return value &gt; other; } / The base implementation of _.has without support for deep paths. @private @param {Object} [object] The object to query. @param {Array|string} key The key to check. @returns {boolean} Returns true if key exists, else false. */ function baseHas(object, key) { return object != null &amp;&amp; hasOwnProperty.call(object, key); } / The base implementation of _.hasIn without support for deep paths. @private @param {Object} [object] The object to query. @param {Array|string} key The key to check. @returns {boolean} Returns true if key exists, else false. / function baseHasIn(object, key) { return object != null &amp;&amp; key in Object(object); } /** The base implementation of _.inRange which doesn’t coerce arguments. @private @param {number} number The number to check. @param {number} start The start of the range. @param {number} end The end of the range. @returns {boolean} Returns true if number is in the range, else false. / function baseInRange(number, start, end) { return number &gt;= nativeMin(start, end) &amp;&amp; number &lt; nativeMax(start, end); } /** The base implementation of methods like _.intersection, without support for iteratee shorthands, that accepts an array of arrays to inspect. @private @param {Array} arrays The arrays to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of shared values. / function baseIntersection(arrays, iteratee, comparator) { var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = []; while (othIndex–) { var array = arrays[othIndex]; if (othIndex &amp;&amp; iteratee) { array = arrayMap(array, baseUnary(iteratee)); } maxLength = nativeMin(array.length, maxLength); caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= 120 &amp;&amp; array.length &gt;= 120)) ? new SetCache(othIndex &amp;&amp; array) : undefined; } array = arrays[0]; var index = -1, seen = caches[0]; outer: while (++index &lt; length &amp;&amp; result.length &lt; maxLength) { var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator) )) { othIndex = othLength; while (–othIndex) { var cache = caches[othIndex]; if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)) ) { continue outer; } } if (seen) { seen.push(computed); } result.push(value); } } return result; } / The base implementation of _.invert and _.invertBy which inverts object with values transformed by iteratee and set by setter. @private @param {Object} object The object to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform values. @param {Object} accumulator The initial inverted object. @returns {Function} Returns accumulator. / function baseInverter(object, setter, iteratee, accumulator) { baseForOwn(object, function(value, key, object) { setter(accumulator, iteratee(value), key, object); }); return accumulator; } / The base implementation of _.invoke without support for individual method arguments. @private @param {Object} object The object to query. @param {Array|string} path The path of the method to invoke. @param {Array} args The arguments to invoke the method with. @returns {} Returns the result of the invoked method. / function baseInvoke(object, path, args) { path = castPath(path, object); object = parent(object, path); var func = object == null ? object : object[toKey(last(path))]; return func == null ? undefined : apply(func, object, args); } / The base implementation of _.isArguments. @private @param {} value The value to check. @returns {boolean} Returns true if value is an arguments object, */ function baseIsArguments(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == argsTag; } / The base implementation of _.isArrayBuffer without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is an array buffer, else false. / function baseIsArrayBuffer(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == arrayBufferTag; } /** The base implementation of _.isDate without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a date object, else false. / function baseIsDate(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == dateTag; } / The base implementation of _.isEqual which supports partial comparisons and tracks traversed objects. @private @param {} value The value to compare. @param {} other The other value to compare. @param {boolean} bitmask The bitmask flags. 1 - Unordered comparison 2 - Partial comparison @param {Function} [customizer] The function to customize comparisons. @param {Object} [stack] Tracks traversed value and other objects. @returns {boolean} Returns true if the values are equivalent, else false. */ function baseIsEqual(value, other, bitmask, customizer, stack) { if (value === other) { return true; } if (value == null || other == null || (!isObjectLike(value) &amp;&amp; !isObjectLike(other))) { return value !== value &amp;&amp; other !== other; } return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack); } / A specialized version of baseIsEqual for arrays and objects which performs deep comparisons and tracks traversed objects enabling objects with circular references to be compared. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} [stack] Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) { var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other); objTag = objTag == argsTag ? objectTag : objTag; othTag = othTag == argsTag ? objectTag : othTag; var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag; if (isSameTag &amp;&amp; isBuffer(object)) { if (!isBuffer(other)) { return false; } objIsArr = true; objIsObj = false; } if (isSameTag &amp;&amp; !objIsObj) { stack || (stack = new Stack); return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack); } if (!(bitmask &amp; COMPARE_PARTIAL_FLAG)) { var objIsWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, ‘wrapped‘), othIsWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, ‘wrapped‘); if (objIsWrapped || othIsWrapped) { var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other; stack || (stack = new Stack); return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack); } } if (!isSameTag) { return false; } stack || (stack = new Stack); return equalObjects(object, other, bitmask, customizer, equalFunc, stack); } /** The base implementation of _.isMap without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a map, else false. / function baseIsMap(value) { return isObjectLike(value) &amp;&amp; getTag(value) == mapTag; } / The base implementation of _.isMatch without support for iteratee shorthands. @private @param {Object} object The object to inspect. @param {Object} source The object of property values to match. @param {Array} matchData The property names, values, and compare flags to match. @param {Function} [customizer] The function to customize comparisons. @returns {boolean} Returns true if object is a match, else false. */ function baseIsMatch(object, source, matchData, customizer) { var index = matchData.length, length = index, noCustomizer = !customizer; if (object == null) { return !length; } object = Object(object); while (index–) { var data = matchData[index]; if ((noCustomizer &amp;&amp; data[2]) ? data[1] !== object[data[0]] : !(data[0] in object) ) { return false; } } while (++index &lt; length) { data = matchData[index]; var key = data[0], objValue = object[key], srcValue = data[1]; if (noCustomizer &amp;&amp; data[2]) { if (objValue === undefined &amp;&amp; !(key in object)) { return false; } } else { var stack = new Stack; if (customizer) { var result = customizer(objValue, srcValue, key, object, source, stack); } if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result )) { return false; } } } return true; } / The base implementation of _.isNative without bad shim checks. @private @param {} value The value to check. @returns {boolean} Returns true if value is a native function, else false. / function baseIsNative(value) { if (!isObject(value) || isMasked(value)) { return false; } var pattern = isFunction(value) ? reIsNative : reIsHostCtor; return pattern.test(toSource(value)); } / The base implementation of _.isRegExp without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a regexp, else false. */ function baseIsRegExp(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == regexpTag; } / The base implementation of _.isSet without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a set, else false. / function baseIsSet(value) { return isObjectLike(value) &amp;&amp; getTag(value) == setTag; } /** The base implementation of _.isTypedArray without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a typed array, else false. / function baseIsTypedArray(value) { return isObjectLike(value) &amp;&amp; isLength(value.length) &amp;&amp; !!typedArrayTags[baseGetTag(value)]; } / The base implementation of _.iteratee. @private @param {} [value=_.identity] The value to convert to an iteratee. @returns {Function} Returns the iteratee. */ function baseIteratee(value) { // Don’t store the typeof result in a variable to avoid a JIT bug in Safari 9. // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details. if (typeof value == ‘function’) { return value; } if (value == null) { return identity; } if (typeof value == ‘object’) { return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value); } return property(value); } / The base implementation of _.keys which doesn’t treat sparse arrays as dense. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function baseKeys(object) { if (!isPrototype(object)) { return nativeKeys(object); } var result = []; for (var key in Object(object)) { if (hasOwnProperty.call(object, key) &amp;&amp; key != ‘constructor’) { result.push(key); } } return result; } / The base implementation of _.keysIn which doesn’t treat sparse arrays as dense. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function baseKeysIn(object) { if (!isObject(object)) { return nativeKeysIn(object); } var isProto = isPrototype(object), result = []; for (var key in object) { if (!(key == ‘constructor’ &amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) { result.push(key); } } return result; } / The base implementation of _.lt which doesn’t coerce arguments. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {boolean} Returns true if value is less than other, else false. / function baseLt(value, other) { return value &lt; other; } / The base implementation of _.map without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the new mapped array. */ function baseMap(collection, iteratee) { var index = -1, result = isArrayLike(collection) ? Array(collection.length) : []; baseEach(collection, function(value, key, collection) { result[++index] = iteratee(value, key, collection); }); return result; } / The base implementation of _.matches which doesn’t clone source. @private @param {Object} source The object of property values to match. @returns {Function} Returns the new spec function. / function baseMatches(source) { var matchData = getMatchData(source); if (matchData.length == 1 &amp;&amp; matchData[0][2]) { return matchesStrictComparable(matchData[0][0], matchData[0][1]); } return function(object) { return object === source || baseIsMatch(object, source, matchData); }; } / The base implementation of _.matchesProperty which doesn’t clone srcValue. @private @param {string} path The path of the property to get. @param {} srcValue The value to match. @returns {Function} Returns the new spec function. / function baseMatchesProperty(path, srcValue) { if (isKey(path) &amp;&amp; isStrictComparable(srcValue)) { return matchesStrictComparable(toKey(path), srcValue); } return function(object) { var objValue = get(object, path); return (objValue === undefined &amp;&amp; objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG); }; } / The base implementation of _.merge without support for multiple sources. @private @param {Object} object The destination object. @param {Object} source The source object. @param {number} srcIndex The index of source. @param {Function} [customizer] The function to customize merged values. @param {Object} [stack] Tracks traversed source values and their merged counterparts. / function baseMerge(object, source, srcIndex, customizer, stack) { if (object === source) { return; } baseFor(source, function(srcValue, key) { if (isObject(srcValue)) { stack || (stack = new Stack); baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); } else { var newValue = customizer ? customizer(safeGet(object, key), srcValue, (key + ‘’), object, source, stack) : undefined; if (newValue === undefined) { newValue = srcValue; } assignMergeValue(object, key, newValue); } }, keysIn); } / A specialized version of baseMerge for arrays and objects which performs deep merges and tracks traversed objects enabling objects with circular references to be merged. @private @param {Object} object The destination object. @param {Object} source The source object. @param {string} key The key of the value to merge. @param {number} srcIndex The index of source. @param {Function} mergeFunc The function to merge values. @param {Function} [customizer] The function to customize assigned values. @param {Object} [stack] Tracks traversed source values and their merged counterparts. / function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) { var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue); if (stacked) { assignMergeValue(object, key, stacked); return; } var newValue = customizer ? customizer(objValue, srcValue, (key + ‘’), object, source, stack) : undefined; var isCommon = newValue === undefined; if (isCommon) { var isArr = isArray(srcValue), isBuff = !isArr &amp;&amp; isBuffer(srcValue), isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue); newValue = srcValue; if (isArr || isBuff || isTyped) { if (isArray(objValue)) { newValue = objValue; } else if (isArrayLikeObject(objValue)) { newValue = copyArray(objValue); } else if (isBuff) { isCommon = false; newValue = cloneBuffer(srcValue, true); } else if (isTyped) { isCommon = false; newValue = cloneTypedArray(srcValue, true); } else { newValue = []; } } else if (isPlainObject(srcValue) || isArguments(srcValue)) { newValue = objValue; if (isArguments(objValue)) { newValue = toPlainObject(objValue); } else if (!isObject(objValue) || isFunction(objValue)) { newValue = initCloneObject(srcValue); } } else { isCommon = false; } } if (isCommon) { // Recursively merge objects and arrays (susceptible to call stack limits). stack.set(srcValue, newValue); mergeFunc(newValue, srcValue, srcIndex, customizer, stack); stack‘delete’; } assignMergeValue(object, key, newValue); } / The base implementation of _.nth which doesn’t coerce arguments. @private @param {Array} array The array to query. @param {number} n The index of the element to return. @returns {} Returns the nth element of array. / function baseNth(array, n) { var length = array.length; if (!length) { return; } n += n &lt; 0 ? length : 0; return isIndex(n, length) ? array[n] : undefined; } / The base implementation of _.orderBy without param guards. @private @param {Array|Object} collection The collection to iterate over. @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by. @param {string[]} orders The sort orders of iteratees. @returns {Array} Returns the new sorted array. / function baseOrderBy(collection, iteratees, orders) { var index = -1; iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee())); var result = baseMap(collection, function(value, key, collection) { var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); }); return { ‘criteria’: criteria, ‘index’: ++index, ‘value’: value }; }); return baseSortBy(result, function(object, other) { return compareMultiple(object, other, orders); }); } / The base implementation of _.pick without support for individual property identifiers. @private @param {Object} object The source object. @param {string[]} paths The property paths to pick. @returns {Object} Returns the new object. / function basePick(object, paths) { return basePickBy(object, paths, function(value, path) { return hasIn(object, path); }); } / The base implementation of _.pickBy without support for iteratee shorthands. @private @param {Object} object The source object. @param {string[]} paths The property paths to pick. @param {Function} predicate The function invoked per property. @returns {Object} Returns the new object. / function basePickBy(object, paths, predicate) { var index = -1, length = paths.length, result = {}; while (++index &lt; length) { var path = paths[index], value = baseGet(object, path); if (predicate(value, path)) { baseSet(result, castPath(path, object), value); } } return result; } / A specialized version of baseProperty which supports deep paths. @private @param {Array|string} path The path of the property to get. @returns {Function} Returns the new accessor function. / function basePropertyDeep(path) { return function(object) { return baseGet(object, path); }; } / The base implementation of _.pullAllBy without support for iteratee shorthands. @private @param {Array} array The array to modify. @param {Array} values The values to remove. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns array. / function basePullAll(array, values, iteratee, comparator) { var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array; if (array === values) { values = copyArray(values); } if (iteratee) { seen = arrayMap(array, baseUnary(iteratee)); } while (++index &lt; length) { var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -1) { if (seen !== array) { splice.call(seen, fromIndex, 1); } splice.call(array, fromIndex, 1); } } return array; } / The base implementation of _.pullAt without support for individual indexes or capturing the removed elements. @private @param {Array} array The array to modify. @param {number[]} indexes The indexes of elements to remove. @returns {Array} Returns array. / function basePullAt(array, indexes) { var length = array ? indexes.length : 0, lastIndex = length - 1; while (length–) { var index = indexes[length]; if (length == lastIndex || index !== previous) { var previous = index; if (isIndex(index)) { splice.call(array, index, 1); } else { baseUnset(array, index); } } } return array; } / The base implementation of _.random without support for returning floating-point numbers. @private @param {number} lower The lower bound. @param {number} upper The upper bound. @returns {number} Returns the random number. / function baseRandom(lower, upper) { return lower + nativeFloor(nativeRandom() * (upper - lower + 1)); } / The base implementation of _.range and _.rangeRight which doesn’t coerce arguments. @private @param {number} start The start of the range. @param {number} end The end of the range. @param {number} step The value to increment or decrement by. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Array} Returns the range of numbers. / function baseRange(start, end, step, fromRight) { var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); while (length–) { result[fromRight ? length : ++index] = start; start += step; } return result; } / The base implementation of _.repeat which doesn’t coerce arguments. @private @param {string} string The string to repeat. @param {number} n The number of times to repeat the string. @returns {string} Returns the repeated string. */ function baseRepeat(string, n) { var result = ‘’; if (!string || n &lt; 1 || n &gt; MAX_SAFE_INTEGER) { return result; } // Leverage the exponentiation by squaring algorithm for a faster repeat. // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details. do { if (n % 2) { result += string; } n = nativeFloor(n / 2); if (n) { string += string; } } while (n); return result; } / The base implementation of _.rest which doesn’t validate or coerce arguments. @private @param {Function} func The function to apply a rest parameter to. @param {number} [start=func.length-1] The start position of the rest parameter. @returns {Function} Returns the new function. / function baseRest(func, start) { return setToString(overRest(func, start, identity), func + ‘’); } /** The base implementation of _.sample. @private @param {Array|Object} collection The collection to sample. @returns {} Returns the random element. / function baseSample(collection) { return arraySample(values(collection)); } / The base implementation of _.sampleSize without param guards. @private @param {Array|Object} collection The collection to sample. @param {number} n The number of elements to sample. @returns {Array} Returns the random elements. */ function baseSampleSize(collection, n) { var array = values(collection); return shuffleSelf(array, baseClamp(n, 0, array.length)); } / The base implementation of _.set. @private @param {Object} object The object to modify. @param {Array|string} path The path of the property to set. @param {} value The value to set. @param {Function} [customizer] The function to customize path creation. @returns {Object} Returns object. / function baseSet(object, path, value, customizer) { if (!isObject(object)) { return object; } path = castPath(path, object); var index = -1, length = path.length, lastIndex = length - 1, nested = object; while (nested != null &amp;&amp; ++index &lt; length) { var key = toKey(path[index]), newValue = value; if (index != lastIndex) { var objValue = nested[key]; newValue = customizer ? customizer(objValue, key, nested) : undefined; if (newValue === undefined) { newValue = isObject(objValue) ? objValue : (isIndex(path[index + 1]) ? [] : {}); } } assignValue(nested, key, newValue); nested = nested[key]; } return object; } / The base implementation of setData without support for hot loop shorting. @private @param {Function} func The function to associate metadata with. @param {} data The metadata. @returns {Function} Returns func. / var baseSetData = !metaMap ? identity : function(func, data) { metaMap.set(func, data); return func; }; / The base implementation of setToString without support for hot loop shorting. @private @param {Function} func The function to modify. @param {Function} string The toString result. @returns {Function} Returns func. / var baseSetToString = !defineProperty ? identity : function(func, string) { return defineProperty(func, ‘toString’, { ‘configurable’: true, ‘enumerable’: false, ‘value’: constant(string), ‘writable’: true }); }; /** The base implementation of _.shuffle. @private @param {Array|Object} collection The collection to shuffle. @returns {Array} Returns the new shuffled array. / function baseShuffle(collection) { return shuffleSelf(values(collection)); } /** The base implementation of _.slice without an iteratee call guard. @private @param {Array} array The array to slice. @param {number} [start=0] The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns the slice of array. / function baseSlice(array, start, end) { var index = -1, length = array.length; if (start &lt; 0) { start = -start &gt; length ? 0 : (length + start); } end = end &gt; length ? length : end; if (end &lt; 0) { end += length; } length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0); start &gt;&gt;&gt;= 0; var result = Array(length); while (++index &lt; length) { result[index] = array[index + start]; } return result; } /** The base implementation of _.some without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if any element passes the predicate check, else false. / function baseSome(collection, predicate) { var result; baseEach(collection, function(value, index, collection) { result = predicate(value, index, collection); return !result; }); return !!result; } /** The base implementation of _.sortedIndex and _.sortedLastIndex which performs a binary search of array to determine the index at which value should be inserted into array in order to maintain its sort order. @private @param {Array} array The sorted array to inspect. @param {} value The value to evaluate. @param {boolean} [retHighest] Specify returning the highest qualified index. @returns {number} Returns the index at which value should be inserted into array. / function baseSortedIndex(array, value, retHighest) { var low = 0, high = array == null ? low : array.length; if (typeof value == ‘number’ &amp;&amp; value === value &amp;&amp; high &lt;= HALF_MAX_ARRAY_LENGTH) { while (low &lt; high) { var mid = (low + high) &gt;&gt;&gt; 1, computed = array[mid]; if (computed !== null &amp;&amp; !isSymbol(computed) &amp;&amp; (retHighest ? (computed &lt;= value) : (computed &lt; value))) { low = mid + 1; } else { high = mid; } } return high; } return baseSortedIndexBy(array, value, identity, retHighest); } /** The base implementation of _.sortedIndexBy and _.sortedLastIndexBy which invokes iteratee for value and each element of array to compute their sort ranking. The iteratee is invoked with one argument; (value). @private @param {Array} array The sorted array to inspect. @param {} value The value to evaluate. @param {Function} iteratee The iteratee invoked per element. @param {boolean} [retHighest] Specify returning the highest qualified index. @returns {number} Returns the index at which value should be inserted into array. / function baseSortedIndexBy(array, value, iteratee, retHighest) { value = iteratee(value); var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; while (low &lt; high) { var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed); if (valIsNaN) { var setLow = retHighest || othIsReflexive; } else if (valIsUndefined) { setLow = othIsReflexive &amp;&amp; (retHighest || othIsDefined); } else if (valIsNull) { setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; (retHighest || !othIsNull); } else if (valIsSymbol) { setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; !othIsNull &amp;&amp; (retHighest || !othIsSymbol); } else if (othIsNull || othIsSymbol) { setLow = false; } else { setLow = retHighest ? (computed &lt;= value) : (computed &lt; value); } if (setLow) { low = mid + 1; } else { high = mid; } } return nativeMin(high, MAX_ARRAY_INDEX); } / The base implementation of _.sortedUniq and _.sortedUniqBy without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} [iteratee] The iteratee invoked per element. @returns {Array} Returns the new duplicate free array. / function baseSortedUniq(array, iteratee) { var index = -1, length = array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index], computed = iteratee ? iteratee(value) : value; if (!index || !eq(computed, seen)) { var seen = computed; result[resIndex++] = value === 0 ? 0 : value; } } return result; } / The base implementation of _.toNumber which doesn’t ensure correct conversions of binary, hexadecimal, or octal string values. @private @param {} value The value to process. @returns {number} Returns the number. / function baseToNumber(value) { if (typeof value == ‘number’) { return value; } if (isSymbol(value)) { return NAN; } return +value; } / The base implementation of _.toString which doesn’t convert nullish values to empty strings. @private @param {} value The value to process. @returns {string} Returns the string. / function baseToString(value) { // Exit early for strings to avoid a performance hit in some environments. if (typeof value == ‘string’) { return value; } if (isArray(value)) { // Recursively convert values (susceptible to call stack limits). return arrayMap(value, baseToString) + ‘’; } if (isSymbol(value)) { return symbolToString ? symbolToString.call(value) : ‘’; } var result = (value + ‘’); return (result == ‘0’ &amp;&amp; (1 / value) == -INFINITY) ? ‘-0’ : result; } / The base implementation of _.uniqBy without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new duplicate free array. / function baseUniq(array, iteratee, comparator) { var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result; if (comparator) { isCommon = false; includes = arrayIncludesWith; } else if (length &gt;= LARGE_ARRAY_SIZE) { var set = iteratee ? null : createSet(array); if (set) { return setToArray(set); } isCommon = false; includes = cacheHas; seen = new SetCache; } else { seen = iteratee ? [] : result; } outer: while (++index &lt; length) { var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (isCommon &amp;&amp; computed === computed) { var seenIndex = seen.length; while (seenIndex–) { if (seen[seenIndex] === computed) { continue outer; } } if (iteratee) { seen.push(computed); } result.push(value); } else if (!includes(seen, computed, comparator)) { if (seen !== result) { seen.push(computed); } result.push(value); } } return result; } / The base implementation of _.unset. @private @param {Object} object The object to modify. @param {Array|string} path The property path to unset. @returns {boolean} Returns true if the property is deleted, else false. */ function baseUnset(object, path) { path = castPath(path, object); object = parent(object, path); return object == null || delete object[toKey(last(path))]; } / The base implementation of _.update. @private @param {Object} object The object to modify. @param {Array|string} path The path of the property to update. @param {Function} updater The function to produce the updated value. @param {Function} [customizer] The function to customize path creation. @returns {Object} Returns object. / function baseUpdate(object, path, updater, customizer) { return baseSet(object, path, updater(baseGet(object, path)), customizer); } /** The base implementation of methods like _.dropWhile and _.takeWhile without support for iteratee shorthands. @private @param {Array} array The array to query. @param {Function} predicate The function invoked per iteration. @param {boolean} [isDrop] Specify dropping elements instead of taking them. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Array} Returns the slice of array. / function baseWhile(array, predicate, isDrop, fromRight) { var length = array.length, index = fromRight ? length : -1; while ((fromRight ? index– : ++index &lt; length) &amp;&amp; predicate(array[index], index, array)) {} return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index)); } /** The base implementation of wrapperValue which returns the result of performing a sequence of actions on the unwrapped value, where each successive action is supplied the return value of the previous. @private @param {} value The unwrapped value. @param {Array} actions Actions to perform to resolve the unwrapped value. @returns {} Returns the resolved value. / function baseWrapperValue(value, actions) { var result = value; if (result instanceof LazyWrapper) { result = result.value(); } return arrayReduce(actions, function(result, action) { return action.func.apply(action.thisArg, arrayPush([result], action.args)); }, result); } / The base implementation of methods like _.xor, without support for iteratee shorthands, that accepts an array of arrays to inspect. @private @param {Array} arrays The arrays to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of values. */ function baseXor(arrays, iteratee, comparator) { var length = arrays.length; if (length &lt; 2) { return length ? baseUniq(arrays[0]) : []; } var index = -1, result = Array(length); while (++index &lt; length) { var array = arrays[index], othIndex = -1; while (++othIndex &lt; length) { if (othIndex != index) { result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator); } } } return baseUniq(baseFlatten(result, 1), iteratee, comparator); } / This base implementation of _.zipObject which assigns values using assignFunc. @private @param {Array} props The property identifiers. @param {Array} values The property values. @param {Function} assignFunc The function to assign values. @returns {Object} Returns the new object. / function baseZipObject(props, values, assignFunc) { var index = -1, length = props.length, valsLength = values.length, result = {}; while (++index &lt; length) { var value = index &lt; valsLength ? values[index] : undefined; assignFunc(result, props[index], value); } return result; } / Casts value to an empty array if it’s not an array like object. @private @param {} value The value to inspect. @returns {Array|Object} Returns the cast array-like object. */ function castArrayLikeObject(value) { return isArrayLikeObject(value) ? value : []; } / Casts value to identity if it’s not a function. @private @param {} value The value to inspect. @returns {Function} Returns cast function. / function castFunction(value) { return typeof value == ‘function’ ? value : identity; } /** Casts value to a path array if it’s not one. @private @param {} value The value to inspect. @param {Object} [object] The object to query keys on. @returns {Array} Returns the cast property path array. / function castPath(value, object) { if (isArray(value)) { return value; } return isKey(value, object) ? [value] : stringToPath(toString(value)); } /** A baseRest alias which can be replaced with identity by module replacement plugins. @private @type {Function} @param {Function} func The function to apply a rest parameter to. @returns {Function} Returns the new function. / var castRest = baseRest; /** Casts array to a slice if it’s needed. @private @param {Array} array The array to inspect. @param {number} start The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns the cast slice. / function castSlice(array, start, end) { var length = array.length; end = end === undefined ? length : end; return (!start &amp;&amp; end &gt;= length) ? array : baseSlice(array, start, end); } /** A simple wrapper around the global clearTimeout. @private @param {number|Object} id The timer id or timeout object of the timer to clear. / var clearTimeout = ctxClearTimeout || function(id) { return root.clearTimeout(id); }; / Creates a clone of buffer. @private @param {Buffer} buffer The buffer to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Buffer} Returns the cloned buffer. */ function cloneBuffer(buffer, isDeep) { if (isDeep) { return buffer.slice(); } var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length); buffer.copy(result); return result; } / Creates a clone of arrayBuffer. @private @param {ArrayBuffer} arrayBuffer The array buffer to clone. @returns {ArrayBuffer} Returns the cloned array buffer. / function cloneArrayBuffer(arrayBuffer) { var result = new arrayBuffer.constructor(arrayBuffer.byteLength); new Uint8Array(result).set(new Uint8Array(arrayBuffer)); return result; } / Creates a clone of dataView. @private @param {Object} dataView The data view to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the cloned data view. */ function cloneDataView(dataView, isDeep) { var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer; return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength); } / Creates a clone of regexp. @private @param {Object} regexp The regexp to clone. @returns {Object} Returns the cloned regexp. / function cloneRegExp(regexp) { var result = new regexp.constructor(regexp.source, reFlags.exec(regexp)); result.lastIndex = regexp.lastIndex; return result; } / Creates a clone of the symbol object. @private @param {Object} symbol The symbol object to clone. @returns {Object} Returns the cloned symbol object. / function cloneSymbol(symbol) { return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}; } / Creates a clone of typedArray. @private @param {Object} typedArray The typed array to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the cloned typed array. / function cloneTypedArray(typedArray, isDeep) { var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer; return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length); } /** Compares values to sort them in ascending order. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {number} Returns the sort order indicator for value. / function compareAscending(value, other) { if (value !== other) { var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value); var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other); if ((!othIsNull &amp;&amp; !othIsSymbol &amp;&amp; !valIsSymbol &amp;&amp; value &gt; other) || (valIsSymbol &amp;&amp; othIsDefined &amp;&amp; othIsReflexive &amp;&amp; !othIsNull &amp;&amp; !othIsSymbol) || (valIsNull &amp;&amp; othIsDefined &amp;&amp; othIsReflexive) || (!valIsDefined &amp;&amp; othIsReflexive) || !valIsReflexive) { return 1; } if ((!valIsNull &amp;&amp; !valIsSymbol &amp;&amp; !othIsSymbol &amp;&amp; value &lt; other) || (othIsSymbol &amp;&amp; valIsDefined &amp;&amp; valIsReflexive &amp;&amp; !valIsNull &amp;&amp; !valIsSymbol) || (othIsNull &amp;&amp; valIsDefined &amp;&amp; valIsReflexive) || (!othIsDefined &amp;&amp; valIsReflexive) || !othIsReflexive) { return -1; } } return 0; } / Used by _.orderBy to compare multiple properties of a value to another and stable sort them. If orders is unspecified, all values are sorted in ascending order. Otherwise, specify an order of “desc” for descending or “asc” for ascending sort order of corresponding values. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {boolean[]|string[]} orders The order to sort by for each property. @returns {number} Returns the sort order indicator for object. / function compareMultiple(object, other, orders) { var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; while (++index &lt; length) { var result = compareAscending(objCriteria[index], othCriteria[index]); if (result) { if (index &gt;= ordersLength) { return result; } var order = orders[index]; return result (order == ‘desc’ ? -1 : 1); } } // Fixes an Array#sort bug in the JS engine embedded in Adobe applications // that causes it, under certain circumstances, to provide the same value for // object and other. See https://github.com/jashkenas/underscore/pull/1247 // for more details. // // This also ensures a stable sort in V8 and other engines. // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details. return object.index - other.index; } / Creates an array that is the composition of partially applied arguments, placeholders, and provided arguments into a single array of arguments. @private @param {Array} args The provided arguments. @param {Array} partials The arguments to prepend to those provided. @param {Array} holders The partials placeholder indexes. @params {boolean} [isCurried] Specify composing for a curried function. @returns {Array} Returns the new array of composed arguments. / function composeArgs(args, partials, holders, isCurried) { var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; while (++leftIndex &lt; leftLength) { result[leftIndex] = partials[leftIndex]; } while (++argsIndex &lt; holdersLength) { if (isUncurried || argsIndex &lt; argsLength) { result[holders[argsIndex]] = args[argsIndex]; } } while (rangeLength–) { result[leftIndex++] = args[argsIndex++]; } return result; } / This function is like composeArgs except that the arguments composition is tailored for _.partialRight. @private @param {Array} args The provided arguments. @param {Array} partials The arguments to append to those provided. @param {Array} holders The partials placeholder indexes. @params {boolean} [isCurried] Specify composing for a curried function. @returns {Array} Returns the new array of composed arguments. / function composeArgsRight(args, partials, holders, isCurried) { var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; while (++argsIndex &lt; rangeLength) { result[argsIndex] = args[argsIndex]; } var offset = argsIndex; while (++rightIndex &lt; rightLength) { result[offset + rightIndex] = partials[rightIndex]; } while (++holdersIndex &lt; holdersLength) { if (isUncurried || argsIndex &lt; argsLength) { result[offset + holders[holdersIndex]] = args[argsIndex++]; } } return result; } / Copies the values of source to array. @private @param {Array} source The array to copy values from. @param {Array} [array=[]] The array to copy values to. @returns {Array} Returns array. / function copyArray(source, array) { var index = -1, length = source.length; array || (array = Array(length)); while (++index &lt; length) { array[index] = source[index]; } return array; } /** Copies properties of source to object. @private @param {Object} source The object to copy properties from. @param {Array} props The property identifiers to copy. @param {Object} [object={}] The object to copy properties to. @param {Function} [customizer] The function to customize copied values. @returns {Object} Returns object. / function copyObject(source, props, object, customizer) { var isNew = !object; object || (object = {}); var index = -1, length = props.length; while (++index &lt; length) { var key = props[index]; var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined; if (newValue === undefined) { newValue = source[key]; } if (isNew) { baseAssignValue(object, key, newValue); } else { assignValue(object, key, newValue); } } return object; } / Copies own symbols of source to object. @private @param {Object} source The object to copy symbols from. @param {Object} [object={}] The object to copy symbols to. @returns {Object} Returns object. */ function copySymbols(source, object) { return copyObject(source, getSymbols(source), object); } / Copies own and inherited symbols of source to object. @private @param {Object} source The object to copy symbols from. @param {Object} [object={}] The object to copy symbols to. @returns {Object} Returns object. / function copySymbolsIn(source, object) { return copyObject(source, getSymbolsIn(source), object); } /** Creates a function like _.groupBy. @private @param {Function} setter The function to set accumulator values. @param {Function} [initializer] The accumulator object initializer. @returns {Function} Returns the new aggregator function. / function createAggregator(setter, initializer) { return function(collection, iteratee) { var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {}; return func(collection, setter, getIteratee(iteratee, 2), accumulator); }; } / Creates a function like _.assign. @private @param {Function} assigner The function to assign values. @returns {Function} Returns the new assigner function. / function createAssigner(assigner) { return baseRest(function(object, sources) { var index = -1, length = sources.length, customizer = length &gt; 1 ? sources[length - 1] : undefined, guard = length &gt; 2 ? sources[2] : undefined; customizer = (assigner.length &gt; 3 &amp;&amp; typeof customizer == ‘function’) ? (length–, customizer) : undefined; if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) { customizer = length &lt; 3 ? undefined : customizer; length = 1; } object = Object(object); while (++index &lt; length) { var source = sources[index]; if (source) { assigner(object, source, index, customizer); } } return object; }); } / Creates a baseEach or baseEachRight function. @private @param {Function} eachFunc The function to iterate over a collection. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new base function. / function createBaseEach(eachFunc, fromRight) { return function(collection, iteratee) { if (collection == null) { return collection; } if (!isArrayLike(collection)) { return eachFunc(collection, iteratee); } var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); while ((fromRight ? index– : ++index &lt; length)) { if (iteratee(iterable[index], index, iterable) === false) { break; } } return collection; }; } /** Creates a base function for methods like _.forIn and _.forOwn. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new base function. / function createBaseFor(fromRight) { return function(object, iteratee, keysFunc) { var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; while (length–) { var key = props[fromRight ? length : ++index]; if (iteratee(iterable[key], key, iterable) === false) { break; } } return object; }; } /** Creates a function that wraps func to invoke it with the optional this binding of thisArg. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} [thisArg] The this binding of func. @returns {Function} Returns the new wrapped function. / function createBind(func, bitmask, thisArg) { var isBind = bitmask &amp; WRAP_BIND_FLAG, Ctor = createCtor(func); function wrapper() { var fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; return fn.apply(isBind ? thisArg : this, arguments); } return wrapper; } /** Creates a function like _.lowerFirst. @private @param {string} methodName The name of the String case method to use. @returns {Function} Returns the new case function. / function createCaseFirst(methodName) { return function(string) { string = toString(string); var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined; var chr = strSymbols ? strSymbols[0] : string.charAt(0); var trailing = strSymbols ? castSlice(strSymbols, 1).join(‘’) : string.slice(1); return chrmethodName + trailing; }; } /** Creates a function like _.camelCase. @private @param {Function} callback The function to combine each word. @returns {Function} Returns the new compounder function. / function createCompounder(callback) { return function(string) { return arrayReduce(words(deburr(string).replace(reApos, ‘’)), callback, ‘’); }; } /** Creates a function that produces an instance of Ctor regardless of whether it was invoked as part of a new expression or by call or apply. @private @param {Function} Ctor The constructor to wrap. @returns {Function} Returns the new wrapped function. / function createCtor(Ctor) { return function() { // Use a switch statement to work with class constructors. See // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist // for more details. var args = arguments; switch (args.length) { case 0: return new Ctor; case 1: return new Ctor(args[0]); case 2: return new Ctor(args[0], args[1]); case 3: return new Ctor(args[0], args[1], args[2]); case 4: return new Ctor(args[0], args[1], args[2], args[3]); case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]); case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]); case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]); } var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args); // Mimic the constructor’s return behavior. // See https://es5.github.io/#x13.2.2 for more details. return isObject(result) ? result : thisBinding; }; } / Creates a function that wraps func to enable currying. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {number} arity The arity of func. @returns {Function} Returns the new wrapped function. / function createCurry(func, bitmask, arity) { var Ctor = createCtor(func); function wrapper() { var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); while (index–) { args[index] = arguments[index]; } var holders = (length &lt; 3 &amp;&amp; args[0] !== placeholder &amp;&amp; args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder); length -= holders.length; if (length &lt; arity) { return createRecurry( func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length); } var fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; return apply(fn, this, args); } return wrapper; } / Creates a _.find or _.findLast function. @private @param {Function} findIndexFunc The function to find the collection index. @returns {Function} Returns the new find function. / function createFind(findIndexFunc) { return function(collection, predicate, fromIndex) { var iterable = Object(collection); if (!isArrayLike(collection)) { var iteratee = getIteratee(predicate, 3); collection = keys(collection); predicate = function(key) { return iteratee(iterable[key], key, iterable); }; } var index = findIndexFunc(collection, predicate, fromIndex); return index &gt; -1 ? iterable[iteratee ? collection[index] : index] : undefined; }; } / Creates a _.flow or _.flowRight function. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new flow function. / function createFlow(fromRight) { return flatRest(function(funcs) { var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru; if (fromRight) { funcs.reverse(); } while (index–) { var func = funcs[index]; if (typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } if (prereq &amp;&amp; !wrapper &amp;&amp; getFuncName(func) == ‘wrapper’) { var wrapper = new LodashWrapper([], true); } } index = wrapper ? index : length; while (++index &lt; length) { func = funcs[index]; var funcName = getFuncName(func), data = funcName == ‘wrapper’ ? getData(func) : undefined; if (data &amp;&amp; isLaziable(data[0]) &amp;&amp; data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &amp;&amp; !data[4].length &amp;&amp; data[9] == 1 ) { wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]); } else { wrapper = (func.length == 1 &amp;&amp; isLaziable(func)) ? wrapperfuncName : wrapper.thru(func); } } return function() { var args = arguments, value = args[0]; if (wrapper &amp;&amp; args.length == 1 &amp;&amp; isArray(value)) { return wrapper.plant(value).value(); } var index = 0, result = length ? funcs[index].apply(this, args) : value; while (++index &lt; length) { result = funcs[index].call(this, result); } return result; }; }); } / Creates a function that wraps func to invoke it with optional this binding of thisArg, partial application, and currying. @private @param {Function|string} func The function or method name to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to prepend to those provided to the new function. @param {Array} [holders] The partials placeholder indexes. @param {Array} [partialsRight] The arguments to append to those provided to the new function. @param {Array} [holdersRight] The partialsRight placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. / function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) { var isAry = bitmask &amp; WRAP_ARY_FLAG, isBind = bitmask &amp; WRAP_BIND_FLAG, isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG, isCurried = bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask &amp; WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func); function wrapper() { var length = arguments.length, args = Array(length), index = length; while (index–) { args[index] = arguments[index]; } if (isCurried) { var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder); } if (partials) { args = composeArgs(args, partials, holders, isCurried); } if (partialsRight) { args = composeArgsRight(args, partialsRight, holdersRight, isCurried); } length -= holdersCount; if (isCurried &amp;&amp; length &lt; arity) { var newHolders = replaceHolders(args, placeholder); return createRecurry( func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length ); } var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func; length = args.length; if (argPos) { args = reorder(args, argPos); } else if (isFlip &amp;&amp; length &gt; 1) { args.reverse(); } if (isAry &amp;&amp; ary &lt; length) { args.length = ary; } if (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) { fn = Ctor || createCtor(fn); } return fn.apply(thisBinding, args); } return wrapper; } /** Creates a function like _.invertBy. @private @param {Function} setter The function to set accumulator values. @param {Function} toIteratee The function to resolve iteratees. @returns {Function} Returns the new inverter function. / function createInverter(setter, toIteratee) { return function(object, iteratee) { return baseInverter(object, setter, toIteratee(iteratee), {}); }; } / Creates a function that performs a mathematical operation on two values. @private @param {Function} operator The function to perform the operation. @param {number} [defaultValue] The value used for undefined arguments. @returns {Function} Returns the new mathematical operation function. */ function createMathOperation(operator, defaultValue) { return function(value, other) { var result; if (value === undefined &amp;&amp; other === undefined) { return defaultValue; } if (value !== undefined) { result = value; } if (other !== undefined) { if (result === undefined) { return other; } if (typeof value == ‘string’ || typeof other == ‘string’) { value = baseToString(value); other = baseToString(other); } else { value = baseToNumber(value); other = baseToNumber(other); } result = operator(value, other); } return result; }; } / Creates a function like _.over. @private @param {Function} arrayFunc The function to iterate over iteratees. @returns {Function} Returns the new over function. / function createOver(arrayFunc) { return flatRest(function(iteratees) { iteratees = arrayMap(iteratees, baseUnary(getIteratee())); return baseRest(function(args) { var thisArg = this; return arrayFunc(iteratees, function(iteratee) { return apply(iteratee, thisArg, args); }); }); }); } / Creates the padding for string based on length. The chars string is truncated if the number of characters exceeds length. @private @param {number} length The padding length. @param {string} [chars=’ ‘] The string used as padding. @returns {string} Returns the padding for string. / function createPadding(length, chars) { chars = chars === undefined ? ‘ ‘ : baseToString(chars); var charsLength = chars.length; if (charsLength &lt; 2) { return charsLength ? baseRepeat(chars, length) : chars; } var result = baseRepeat(chars, nativeCeil(length / stringSize(chars))); return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join(‘’) : result.slice(0, length); } / Creates a function that wraps func to invoke it with the this binding of thisArg and partials prepended to the arguments it receives. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} thisArg The this binding of func. @param {Array} partials The arguments to prepend to those provided to the new function. @returns {Function} Returns the new wrapped function. / function createPartial(func, bitmask, thisArg, partials) { var isBind = bitmask &amp; WRAP_BIND_FLAG, Ctor = createCtor(func); function wrapper() { var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; while (++leftIndex &lt; leftLength) { args[leftIndex] = partials[leftIndex]; } while (argsLength–) { args[leftIndex++] = arguments[++argsIndex]; } return apply(fn, isBind ? thisArg : this, args); } return wrapper; } / Creates a _.range or _.rangeRight function. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new range function. / function createRange(fromRight) { return function(start, end, step) { if (step &amp;&amp; typeof step != ‘number’ &amp;&amp; isIterateeCall(start, end, step)) { end = step = undefined; } // Ensure the sign of -0 is preserved. start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } step = step === undefined ? (start &lt; end ? 1 : -1) : toFinite(step); return baseRange(start, end, step, fromRight); }; } / Creates a function that performs a relational operation on two values. @private @param {Function} operator The function to perform the operation. @returns {Function} Returns the new relational operation function. / function createRelationalOperation(operator) { return function(value, other) { if (!(typeof value == ‘string’ &amp;&amp; typeof other == ‘string’)) { value = toNumber(value); other = toNumber(other); } return operator(value, other); }; } / Creates a function that wraps func to continue currying. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {Function} wrapFunc The function to create the func wrapper. @param {} placeholder The placeholder value. @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to prepend to those provided to the new function. @param {Array} [holders] The partials placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. / function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) { var isCurry = bitmask &amp; WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials; bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG); bitmask &amp;= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG); if (!(bitmask &amp; WRAP_CURRY_BOUND_FLAG)) { bitmask &amp;= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG); } var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ]; var result = wrapFunc.apply(undefined, newData); if (isLaziable(func)) { setData(result, newData); } result.placeholder = placeholder; return setWrapToString(result, func, bitmask); } / Creates a function like _.round. @private @param {string} methodName The name of the Math method to use when rounding. @returns {Function} Returns the new round function. / function createRound(methodName) { var func = Math[methodName]; return function(number, precision) { number = toNumber(number); precision = precision == null ? 0 : nativeMin(toInteger(precision), 292); if (precision) { // Shift with exponential notation to avoid floating-point issues. // See MDN for more details. var pair = (toString(number) + ‘e’).split(‘e’), value = func(pair[0] + ‘e’ + (+pair[1] + precision)); pair = (toString(value) + ‘e’).split(‘e’); return +(pair[0] + ‘e’ + (+pair[1] - precision)); } return func(number); }; } / Creates a set object of values. @private @param {Array} values The values to add to the set. @returns {Object} Returns the new set. / var createSet = !(Set &amp;&amp; (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) { return new Set(values); }; / Creates a _.toPairs or _.toPairsIn function. @private @param {Function} keysFunc The function to get the keys of a given object. @returns {Function} Returns the new pairs function. / function createToPairs(keysFunc) { return function(object) { var tag = getTag(object); if (tag == mapTag) { return mapToArray(object); } if (tag == setTag) { return setToPairs(object); } return baseToPairs(object, keysFunc(object)); }; } / Creates a function that either curries or invokes func with optional this binding and partially applied arguments. @private @param {Function|string} func The function or method name to wrap. @param {number} bitmask The bitmask flags. 1 - _.bind 2 - _.bindKey 4 - _.curry or _.curryRight of a bound function 8 - _.curry 16 - _.curryRight 32 - _.partial 64 - _.partialRight 128 - _.rearg 256 - _.ary 512 - _.flip @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to be partially applied. @param {Array} [holders] The partials placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. */ function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) { var isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG; if (!isBindKey &amp;&amp; typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } var length = partials ? partials.length : 0; if (!length) { bitmask &amp;= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG); partials = holders = undefined; } ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0); arity = arity === undefined ? arity : toInteger(arity); length -= holders ? holders.length : 0; if (bitmask &amp; WRAP_PARTIAL_RIGHT_FLAG) { var partialsRight = partials, holdersRight = holders; partials = holders = undefined; } var data = isBindKey ? undefined : getData(func); var newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ]; if (data) { mergeData(newData, data); } func = newData[0]; bitmask = newData[1]; thisArg = newData[2]; partials = newData[3]; holders = newData[4]; arity = newData[9] = newData[9] === undefined ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0); if (!arity &amp;&amp; bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) { bitmask &amp;= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG); } if (!bitmask || bitmask == WRAP_BIND_FLAG) { var result = createBind(func, bitmask, thisArg); } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) { result = createCurry(func, bitmask, arity); } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &amp;&amp; !holders.length) { result = createPartial(func, bitmask, thisArg, partials); } else { result = createHybrid.apply(undefined, newData); } var setter = data ? baseSetData : setData; return setWrapToString(setter(result, newData), func, bitmask); } / Used by _.defaults to customize its _.assignIn use to assign properties of source objects to the destination object for all destination properties that resolve to undefined. @private @param {} objValue The destination value. @param {} srcValue The source value. @param {string} key The key of the property to assign. @param {Object} object The parent object of objValue. @returns {} Returns the value to assign. / function customDefaultsAssignIn(objValue, srcValue, key, object) { if (objValue === undefined || (eq(objValue, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) { return srcValue; } return objValue; } / Used by _.defaultsDeep to customize its _.merge use to merge source objects into destination objects that are passed thru. @private @param {} objValue The destination value. @param {} srcValue The source value. @param {string} key The key of the property to merge. @param {Object} object The parent object of objValue. @param {Object} source The parent object of srcValue. @param {Object} [stack] Tracks traversed source values and their merged counterparts. @returns {} Returns the value to assign. / function customDefaultsMerge(objValue, srcValue, key, object, source, stack) { if (isObject(objValue) &amp;&amp; isObject(srcValue)) { // Recursively merge objects and arrays (susceptible to call stack limits). stack.set(srcValue, objValue); baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack); stack‘delete’; } return objValue; } / Used by _.omit to customize its _.cloneDeep use to only clone plain objects. @private @param {} value The value to inspect. @param {string} key The key of the property to inspect. @returns {} Returns the uncloned value or undefined to defer cloning to _.cloneDeep. / function customOmitClone(value) { return isPlainObject(value) ? undefined : value; } / A specialized version of baseIsEqualDeep for arrays with support for partial deep comparisons. @private @param {Array} array The array to compare. @param {Array} other The other array to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed array and other objects. @returns {boolean} Returns true if the arrays are equivalent, else false. / function equalArrays(array, other, bitmask, customizer, equalFunc, stack) { var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length; if (arrLength != othLength &amp;&amp; !(isPartial &amp;&amp; othLength &gt; arrLength)) { return false; } // Assume cyclic values are equal. var stacked = stack.get(array); if (stacked &amp;&amp; stack.get(other)) { return stacked == other; } var index = -1, result = true, seen = (bitmask &amp; COMPARE_UNORDERED_FLAG) ? new SetCache : undefined; stack.set(array, other); stack.set(other, array); // Ignore non-index properties. while (++index &lt; arrLength) { var arrValue = array[index], othValue = other[index]; if (customizer) { var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack); } if (compared !== undefined) { if (compared) { continue; } result = false; break; } // Recursively compare arrays (susceptible to call stack limits). if (seen) { if (!arraySome(other, function(othValue, othIndex) { if (!cacheHas(seen, othIndex) &amp;&amp; (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) { return seen.push(othIndex); } })) { result = false; break; } } else if (!( arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack) )) { result = false; break; } } stack‘delete’; stack‘delete’; return result; } / A specialized version of baseIsEqualDeep for comparing objects of the same toStringTag. Note: This function only supports comparing values with tags of Boolean, Date, Error, Number, RegExp, or String. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {string} tag The toStringTag of the objects to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) { switch (tag) { case dataViewTag: if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) { return false; } object = object.buffer; other = other.buffer; case arrayBufferTag: if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) { return false; } return true; case boolTag: case dateTag: case numberTag: // Coerce booleans to 1 or 0 and dates to milliseconds. // Invalid dates are coerced to NaN. return eq(+object, +other); case errorTag: return object.name == other.name &amp;&amp; object.message == other.message; case regexpTag: case stringTag: // Coerce regexes to strings and treat strings, primitives and objects, // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring // for more details. return object == (other + ‘’); case mapTag: var convert = mapToArray; case setTag: var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG; convert || (convert = setToArray); if (object.size != other.size &amp;&amp; !isPartial) { return false; } // Assume cyclic values are equal. var stacked = stack.get(object); if (stacked) { return stacked == other; } bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits). stack.set(object, other); var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack); stack‘delete’; return result; case symbolTag: if (symbolValueOf) { return symbolValueOf.call(object) == symbolValueOf.call(other); } } return false; } / A specialized version of baseIsEqualDeep for objects with support for partial deep comparisons. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function equalObjects(object, other, bitmask, customizer, equalFunc, stack) { var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length; if (objLength != othLength &amp;&amp; !isPartial) { return false; } var index = objLength; while (index–) { var key = objProps[index]; if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) { return false; } } // Assume cyclic values are equal. var stacked = stack.get(object); if (stacked &amp;&amp; stack.get(other)) { return stacked == other; } var result = true; stack.set(object, other); stack.set(other, object); var skipCtor = isPartial; while (++index &lt; objLength) { key = objProps[index]; var objValue = object[key], othValue = other[key]; if (customizer) { var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack); } // Recursively compare objects (susceptible to call stack limits). if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)) : compared )) { result = false; break; } skipCtor || (skipCtor = key == ‘constructor’); } if (result &amp;&amp; !skipCtor) { var objCtor = object.constructor, othCtor = other.constructor; // Non Object object instances with different constructors are not equal. if (objCtor != othCtor &amp;&amp; (‘constructor’ in object &amp;&amp; ‘constructor’ in other) &amp;&amp; !(typeof objCtor == ‘function’ &amp;&amp; objCtor instanceof objCtor &amp;&amp; typeof othCtor == ‘function’ &amp;&amp; othCtor instanceof othCtor)) { result = false; } } stack‘delete’; stack‘delete’; return result; } / A specialized version of baseRest which flattens the rest array. @private @param {Function} func The function to apply a rest parameter to. @returns {Function} Returns the new function. / function flatRest(func) { return setToString(overRest(func, undefined, flatten), func + ‘’); } / Creates an array of own enumerable property names and symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names and symbols. / function getAllKeys(object) { return baseGetAllKeys(object, keys, getSymbols); } / Creates an array of own and inherited enumerable property names and symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names and symbols. / function getAllKeysIn(object) { return baseGetAllKeys(object, keysIn, getSymbolsIn); } /** Gets metadata for func. @private @param {Function} func The function to query. @returns {} Returns the metadata for func. / var getData = !metaMap ? noop : function(func) { return metaMap.get(func); }; / Gets the name of func. @private @param {Function} func The function to query. @returns {string} Returns the function name. / function getFuncName(func) { var result = (func.name + ‘’), array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; while (length–) { var data = array[length], otherFunc = data.func; if (otherFunc == null || otherFunc == func) { return data.name; } } return result; } / Gets the argument placeholder value for func. @private @param {Function} func The function to inspect. @returns {} Returns the placeholder value. / function getHolder(func) { var object = hasOwnProperty.call(lodash, ‘placeholder’) ? lodash : func; return object.placeholder; } /** Gets the appropriate “iteratee” function. If _.iteratee is customized, this function returns the custom method, otherwise it returns baseIteratee. If arguments are provided, the chosen function is invoked with them and its result is returned. @private @param {} [value] The value to convert to an iteratee. @param {number} [arity] The arity of the created iteratee. @returns {Function} Returns the chosen function or its result. / function getIteratee() { var result = lodash.iteratee || iteratee; result = result === iteratee ? baseIteratee : result; return arguments.length ? result(arguments[0], arguments[1]) : result; } / Gets the data for map. @private @param {Object} map The map to query. @param {string} key The reference key. @returns {} Returns the map data. / function getMapData(map, key) { var data = map.data; return isKeyable(key) ? data[typeof key == ‘string’ ? ‘string’ : ‘hash’] : data.map; } / Gets the property names, values, and compare flags of object. @private @param {Object} object The object to query. @returns {Array} Returns the match data of object. / function getMatchData(object) { var result = keys(object), length = result.length; while (length–) { var key = result[length], value = object[key]; result[length] = [key, value, isStrictComparable(value)]; } return result; } / Gets the native function at key of object. @private @param {Object} object The object to query. @param {string} key The key of the method to get. @returns {} Returns the function if it’s native, else undefined. / function getNative(object, key) { var value = getValue(object, key); return baseIsNative(value) ? value : undefined; } / A specialized version of baseGetTag which ignores Symbol.toStringTag values. @private @param {} value The value to query. @returns {string} Returns the raw toStringTag. / function getRawTag(value) { var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag]; try { value[symToStringTag] = undefined; var unmasked = true; } catch (e) {} var result = nativeObjectToString.call(value); if (unmasked) { if (isOwn) { value[symToStringTag] = tag; } else { delete value[symToStringTag]; } } return result; } /** Creates an array of the own enumerable symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of symbols. / var getSymbols = !nativeGetSymbols ? stubArray : function(object) { if (object == null) { return []; } object = Object(object); return arrayFilter(nativeGetSymbols(object), function(symbol) { return propertyIsEnumerable.call(object, symbol); }); }; /** Creates an array of the own and inherited enumerable symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of symbols. / var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) { var result = []; while (object) { arrayPush(result, getSymbols(object)); object = getPrototype(object); } return result; }; /** Gets the toStringTag of value. @private @param {} value The value to query. @returns {string} Returns the toStringTag. / var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js &lt; 6. if ((DataView &amp;&amp; getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map &amp;&amp; getTag(new Map) != mapTag) || (Promise &amp;&amp; getTag(Promise.resolve()) != promiseTag) || (Set &amp;&amp; getTag(new Set) != setTag) || (WeakMap &amp;&amp; getTag(new WeakMap) != weakMapTag)) { getTag = function(value) { var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : ‘’; if (ctorString) { switch (ctorString) { case dataViewCtorString: return dataViewTag; case mapCtorString: return mapTag; case promiseCtorString: return promiseTag; case setCtorString: return setTag; case weakMapCtorString: return weakMapTag; } } return result; }; } / Gets the view, applying any transforms to the start and end positions. @private @param {number} start The start of the view. @param {number} end The end of the view. @param {Array} transforms The transformations to apply to the view. @returns {Object} Returns an object containing the start and end positions of the view. */ function getView(start, end, transforms) { var index = -1, length = transforms.length; while (++index &lt; length) { var data = transforms[index], size = data.size; switch (data.type) { case ‘drop’: start += size; break; case ‘dropRight’: end -= size; break; case ‘take’: end = nativeMin(end, start + size); break; case ‘takeRight’: start = nativeMax(start, end - size); break; } } return { ‘start’: start, ‘end’: end }; } / Extracts wrapper details from the source body comment. @private @param {string} source The source to inspect. @returns {Array} Returns the wrapper details. / function getWrapDetails(source) { var match = source.match(reWrapDetails); return match ? match[1].split(reSplitDetails) : []; } / Checks if path exists on object. @private @param {Object} object The object to query. @param {Array|string} path The path to check. @param {Function} hasFunc The function to check properties. @returns {boolean} Returns true if path exists, else false. / function hasPath(object, path, hasFunc) { path = castPath(path, object); var index = -1, length = path.length, result = false; while (++index &lt; length) { var key = toKey(path[index]); if (!(result = object != null &amp;&amp; hasFunc(object, key))) { break; } object = object[key]; } if (result || ++index != length) { return result; } length = object == null ? 0 : object.length; return !!length &amp;&amp; isLength(length) &amp;&amp; isIndex(key, length) &amp;&amp; (isArray(object) || isArguments(object)); } / Initializes an array clone. @private @param {Array} array The array to clone. @returns {Array} Returns the initialized clone. / function initCloneArray(array) { var length = array.length, result = new array.constructor(length); // Add properties assigned by RegExp#exec. if (length &amp;&amp; typeof array[0] == ‘string’ &amp;&amp; hasOwnProperty.call(array, ‘index’)) { result.index = array.index; result.input = array.input; } return result; } / Initializes an object clone. @private @param {Object} object The object to clone. @returns {Object} Returns the initialized clone. / function initCloneObject(object) { return (typeof object.constructor == ‘function’ &amp;&amp; !isPrototype(object)) ? baseCreate(getPrototype(object)) : {}; } / Initializes an object clone based on its toStringTag. Note: This function only supports cloning values with tags of Boolean, Date, Error, Map, Number, RegExp, Set, or String. @private @param {Object} object The object to clone. @param {string} tag The toStringTag of the object to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the initialized clone. / function initCloneByTag(object, tag, isDeep) { var Ctor = object.constructor; switch (tag) { case arrayBufferTag: return cloneArrayBuffer(object); case boolTag: case dateTag: return new Ctor(+object); case dataViewTag: return cloneDataView(object, isDeep); case float32Tag: case float64Tag: case int8Tag: case int16Tag: case int32Tag: case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag: return cloneTypedArray(object, isDeep); case mapTag: return new Ctor; case numberTag: case stringTag: return new Ctor(object); case regexpTag: return cloneRegExp(object); case setTag: return new Ctor; case symbolTag: return cloneSymbol(object); } } /** Inserts wrapper details in a comment at the top of the source body. @private @param {string} source The source to modify. @returns {Array} details The details to insert. @returns {string} Returns the modified source. / function insertWrapDetails(source, details) { var length = details.length; if (!length) { return source; } var lastIndex = length - 1; details[lastIndex] = (length &gt; 1 ? ‘&amp; ‘ : ‘’) + details[lastIndex]; details = details.join(length &gt; 2 ? ‘, ‘ : ‘ ‘); return source.replace(reWrapComment, ‘{\n/ [wrapped with ‘ + details + ‘] /\n’); } / Checks if value is a flattenable arguments object or array. @private @param {} value The value to check. @returns {boolean} Returns true if value is flattenable, else false. */ function isFlattenable(value) { return isArray(value) || isArguments(value) || !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]); } / Checks if value is a valid array-like index. @private @param {} value The value to check. @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index. @returns {boolean} Returns true if value is a valid index, else false. / function isIndex(value, length) { var type = typeof value; length = length == null ? MAX_SAFE_INTEGER : length; return !!length &amp;&amp; (type == ‘number’ || (type != ‘symbol’ &amp;&amp; reIsUint.test(value))) &amp;&amp; (value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length); } / Checks if the given arguments are from an iteratee call. @private @param {} value The potential iteratee value argument. @param {} index The potential iteratee index or key argument. @param {} object The potential iteratee object argument. @returns {boolean} Returns true if the arguments are from an iteratee call, else false. / function isIterateeCall(value, index, object) { if (!isObject(object)) { return false; } var type = typeof index; if (type == ‘number’ ? (isArrayLike(object) &amp;&amp; isIndex(index, object.length)) : (type == ‘string’ &amp;&amp; index in object) ) { return eq(object[index], value); } return false; } / Checks if value is a property name and not a property path. @private @param {} value The value to check. @param {Object} [object] The object to query keys on. @returns {boolean} Returns true if value is a property name, else false. / function isKey(value, object) { if (isArray(value)) { return false; } var type = typeof value; if (type == ‘number’ || type == ‘symbol’ || type == ‘boolean’ || value == null || isSymbol(value)) { return true; } return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null &amp;&amp; value in Object(object)); } / Checks if value is suitable for use as unique object key. @private @param {} value The value to check. @returns {boolean} Returns true if value is suitable, else false. */ function isKeyable(value) { var type = typeof value; return (type == ‘string’ || type == ‘number’ || type == ‘symbol’ || type == ‘boolean’) ? (value !== ‘proto‘) : (value === null); } / Checks if func has a lazy counterpart. @private @param {Function} func The function to check. @returns {boolean} Returns true if func has a lazy counterpart, else false. / function isLaziable(func) { var funcName = getFuncName(func), other = lodash[funcName]; if (typeof other != ‘function’ || !(funcName in LazyWrapper.prototype)) { return false; } if (func === other) { return true; } var data = getData(other); return !!data &amp;&amp; func === data[0]; } /** Checks if func has its source masked. @private @param {Function} func The function to check. @returns {boolean} Returns true if func is masked, else false. / function isMasked(func) { return !!maskSrcKey &amp;&amp; (maskSrcKey in func); } /** Checks if func is capable of being masked. @private @param {} value The value to check. @returns {boolean} Returns true if func is maskable, else false. / var isMaskable = coreJsData ? isFunction : stubFalse; / Checks if value is likely a prototype object. @private @param {} value The value to check. @returns {boolean} Returns true if value is a prototype, else false. */ function isPrototype(value) { var Ctor = value &amp;&amp; value.constructor, proto = (typeof Ctor == ‘function’ &amp;&amp; Ctor.prototype) || objectProto; return value === proto; } / Checks if value is suitable for strict equality comparisons, i.e. ===. @private @param {} value The value to check. @returns {boolean} Returns true if value if suitable for strict equality comparisons, else false. / function isStrictComparable(value) { return value === value &amp;&amp; !isObject(value); } / A specialized version of matchesProperty for source values suitable for strict equality comparisons, i.e. ===. @private @param {string} key The key of the property to get. @param {} srcValue The value to match. @returns {Function} Returns the new spec function. */ function matchesStrictComparable(key, srcValue) { return function(object) { if (object == null) { return false; } return object[key] === srcValue &amp;&amp; (srcValue !== undefined || (key in Object(object))); }; } / A specialized version of _.memoize which clears the memoized function’s cache when it exceeds MAX_MEMOIZE_SIZE. @private @param {Function} func The function to have its output memoized. @returns {Function} Returns the new memoized function. / function memoizeCapped(func) { var result = memoize(func, function(key) { if (cache.size === MAX_MEMOIZE_SIZE) { cache.clear(); } return key; }); var cache = result.cache; return result; } /** Merges the function metadata of source into data. Merging metadata reduces the number of wrappers used to invoke a function. This is possible because methods like _.bind, _.curry, and _.partial may be applied regardless of execution order. Methods like _.ary and _.rearg modify function arguments, making the order in which they are executed important, preventing the merging of metadata. However, we make an exception for a safe combined case where curried functions have _.ary and or _.rearg applied. @private @param {Array} data The destination metadata. @param {Array} source The source metadata. @returns {Array} Returns data. / function mergeData(data, source) { var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask &lt; (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG); var isCombo = ((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_CURRY_FLAG)) || ((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_REARG_FLAG) &amp;&amp; (data[7].length &lt;= source[8])) || ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) &amp;&amp; (source[7].length &lt;= source[8]) &amp;&amp; (bitmask == WRAP_CURRY_FLAG)); // Exit early if metadata can’t be merged. if (!(isCommon || isCombo)) { return data; } // Use source thisArg if available. if (srcBitmask &amp; WRAP_BIND_FLAG) { data[2] = source[2]; // Set when currying a bound function. newBitmask |= bitmask &amp; WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG; } // Compose partial arguments. var value = source[3]; if (value) { var partials = data[3]; data[3] = partials ? composeArgs(partials, value, source[4]) : value; data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]; } // Compose partial right arguments. value = source[5]; if (value) { partials = data[5]; data[5] = partials ? composeArgsRight(partials, value, source[6]) : value; data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]; } // Use source argPos if available. value = source[7]; if (value) { data[7] = value; } // Use source ary if it’s smaller. if (srcBitmask &amp; WRAP_ARY_FLAG) { data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]); } // Use source arity if one is not provided. if (data[9] == null) { data[9] = source[9]; } // Use source func and merge bitmasks. data[0] = source[0]; data[1] = newBitmask; return data; } / This function is like Object.keys except that it includes inherited enumerable properties. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function nativeKeysIn(object) { var result = []; if (object != null) { for (var key in Object(object)) { result.push(key); } } return result; } / Converts value to a string using Object.prototype.toString. @private @param {} value The value to convert. @returns {string} Returns the converted string. / function objectToString(value) { return nativeObjectToString.call(value); } /** A specialized version of baseRest which transforms the rest array. @private @param {Function} func The function to apply a rest parameter to. @param {number} [start=func.length-1] The start position of the rest parameter. @param {Function} transform The rest array transform. @returns {Function} Returns the new function. / function overRest(func, start, transform) { start = nativeMax(start === undefined ? (func.length - 1) : start, 0); return function() { var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); while (++index &lt; length) { array[index] = args[start + index]; } index = -1; var otherArgs = Array(start + 1); while (++index &lt; start) { otherArgs[index] = args[index]; } otherArgs[start] = transform(array); return apply(func, this, otherArgs); }; } /** Gets the parent value at path of object. @private @param {Object} object The object to query. @param {Array} path The path to get the parent value of. @returns {} Returns the parent value. / function parent(object, path) { return path.length &lt; 2 ? object : baseGet(object, baseSlice(path, 0, -1)); } /** Reorder array according to the specified indexes where the element at the first index is assigned as the first element, the element at the second index is assigned as the second element, and so on. @private @param {Array} array The array to reorder. @param {Array} indexes The arranged array indexes. @returns {Array} Returns array. / function reorder(array, indexes) { var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); while (length–) { var index = indexes[length]; array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined; } return array; } / Gets the value at key, unless key is “proto“. @private @param {Object} object The object to query. @param {string} key The key of the property to get. @returns {} Returns the property value. / function safeGet(object, key) { if (key == ‘proto‘) { return; } return object[key]; } / Sets metadata for func. Note: If this function becomes hot, i.e. is invoked a lot in a short period of time, it will trip its breaker and transition to an identity function to avoid garbage collection pauses in V8. See V8 issue 2070 for more details. @private @param {Function} func The function to associate metadata with. @param {} data The metadata. @returns {Function} Returns func. / var setData = shortOut(baseSetData); / A simple wrapper around the global setTimeout. @private @param {Function} func The function to delay. @param {number} wait The number of milliseconds to delay invocation. @returns {number|Object} Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) { return root.setTimeout(func, wait); }; / Sets the toString method of func to return string. @private @param {Function} func The function to modify. @param {Function} string The toString result. @returns {Function} Returns func. / var setToString = shortOut(baseSetToString); /** Sets the toString method of wrapper to mimic the source of reference with wrapper details in a comment at the top of the source body. @private @param {Function} wrapper The function to modify. @param {Function} reference The reference function. @param {number} bitmask The bitmask flags. See createWrap for more details. @returns {Function} Returns wrapper. / function setWrapToString(wrapper, reference, bitmask) { var source = (reference + ‘’); return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask))); } / Creates a function that’ll short out and invoke identity instead of func when it’s called HOT_COUNT or more times in HOT_SPAN milliseconds. @private @param {Function} func The function to restrict. @returns {Function} Returns the new shortable function. / function shortOut(func) { var count = 0, lastCalled = 0; return function() { var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled); lastCalled = stamp; if (remaining &gt; 0) { if (++count &gt;= HOT_COUNT) { return arguments[0]; } } else { count = 0; } return func.apply(undefined, arguments); }; } / A specialized version of _.shuffle which mutates and sets the size of array. @private @param {Array} array The array to shuffle. @param {number} [size=array.length] The size of array. @returns {Array} Returns array. / function shuffleSelf(array, size) { var index = -1, length = array.length, lastIndex = length - 1; size = size === undefined ? length : size; while (++index &lt; size) { var rand = baseRandom(index, lastIndex), value = array[rand]; array[rand] = array[index]; array[index] = value; } array.length = size; return array; } /** Converts string to a property path array. @private @param {string} string The string to convert. @returns {Array} Returns the property path array. / var stringToPath = memoizeCapped(function(string) { var result = []; if (string.charCodeAt(0) === 46 / . /) { result.push(‘’); } string.replace(rePropName, function(match, number, quote, subString) { result.push(quote ? subString.replace(reEscapeChar, ‘$1’) : (number || match)); }); return result; }); /** Converts value to a string key if it’s not a string or symbol. @private @param {} value The value to inspect. @returns {string|symbol} Returns the key. / function toKey(value) { if (typeof value == ‘string’ || isSymbol(value)) { return value; } var result = (value + ‘’); return (result == ‘0’ &amp;&amp; (1 / value) == -INFINITY) ? ‘-0’ : result; } / Converts func to its source code. @private @param {Function} func The function to convert. @returns {string} Returns the source code. / function toSource(func) { if (func != null) { try { return funcToString.call(func); } catch (e) {} try { return (func + ‘’); } catch (e) {} } return ‘’; } / Updates wrapper details based on bitmask flags. @private @returns {Array} details The details to modify. @param {number} bitmask The bitmask flags. See createWrap for more details. @returns {Array} Returns details. / function updateWrapDetails(details, bitmask) { arrayEach(wrapFlags, function(pair) { var value = ‘_.’ + pair[0]; if ((bitmask &amp; pair[1]) &amp;&amp; !arrayIncludes(details, value)) { details.push(value); } }); return details.sort(); } /** Creates a clone of wrapper. @private @param {Object} wrapper The wrapper to clone. @returns {Object} Returns the cloned wrapper. / function wrapperClone(wrapper) { if (wrapper instanceof LazyWrapper) { return wrapper.clone(); } var result = new LodashWrapper(wrapper.wrapped, wrapper.chain); result.actions = copyArray(wrapper.actions); result.index = wrapper.index; result.values = wrapper.values; return result; } /————————————————————————/ /** Creates an array of elements split into groups the length of size. If array can’t be split evenly, the final chunk will be the remaining elements. @static @memberOf _ @since 3.0.0 @category Array @param {Array} array The array to process. @param {number} [size=1] The length of each chunk @param- {Object} [guard] Enables use as an iteratee for methods like _.map. @returns {Array} Returns the new array of chunks. @example _.chunk([‘a’, ‘b’, ‘c’, ‘d’], 2); // =&gt; [[‘a’, ‘b’], [‘c’, ‘d’]] _.chunk([‘a’, ‘b’, ‘c’, ‘d’], 3); // =&gt; [[‘a’, ‘b’, ‘c’], [‘d’]] / function chunk(array, size, guard) { if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) { size = 1; } else { size = nativeMax(toInteger(size), 0); } var length = array == null ? 0 : array.length; if (!length || size &lt; 1) { return []; } var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); while (index &lt; length) { result[resIndex++] = baseSlice(array, index, (index += size)); } return result; } /** Creates an array with all falsey values removed. The values false, null, 0, &quot;&quot;, undefined, and NaN are falsey. @static @memberOf _ @since 0.1.0 @category Array @param {Array} array The array to compact. @returns {Array} Returns the new array of filtered values. @example _.compact([0, 1, false, 2, ‘’, 3]); // =&gt; [1, 2, 3] / function compact(array) { var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (value) { result[resIndex++] = value; } } return result; } /** Creates a new array concatenating array with any additional arrays and/or values. @static @memberOf _ @since 4.0.0 @category Array @param {Array} array The array to concatenate. @param {…} [values] The values to concatenate. @returns {Array} Returns the new concatenated array. @example var array = [1]; var other = .concat(array, 2, [3], [[4]]); console.log(other); // =&gt; [1, 2, 3, [4]] console.log(array); // =&gt; [1] / function concat() { var length = arguments.length; if (!length) { return []; } var args = Array(length - 1), array = arguments[0], index = length; while (index–) { args[index - 1] = arguments[index]; } return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)); } /** Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array. * Note: Unlike `.pullAll, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @returns {Array} Returns the new array of filtered values. * @see _.without, _.xor * @example * * _.difference([2, 1], [2, 3]); * // =&gt; [1] */ var difference = baseRest(function(array, values) { return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []; }); /** * This method is like.differenceexcept that it acceptsiterateewhich * is invoked for each element ofarrayandvaluesto generate the criterion * by which they&#39;re compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * * **Note:** Unlike.pullAllBy, this method returns a new array. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [1.2] * * // The_.propertyiteratee shorthand. * _.differenceBy([{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], [{ &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 2 }] */ var differenceBy = baseRest(function(array, values) { var iteratee = last(values); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : []; }); /** * This method is like.differenceexcept that it acceptscomparator* which is invoked to compare elements ofarraytovalues. The order and * references of result values are determined by the first array. The comparator * is invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike.pullAllWith, this method returns a new array. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * * _.differenceWith(objects, [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }], _.isEqual); * // =&gt; [{ &#39;x&#39;: 2, &#39;y&#39;: 1 }] */ var differenceWith = baseRest(function(array, values) { var comparator = last(values); if (isArrayLikeObject(comparator)) { comparator = undefined; } return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : []; }); /** * Creates a slice ofarraywithnelements dropped from the beginning. * * @static * @memberOf _ * @since 0.5.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to drop. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.drop([1, 2, 3]); * // =&gt; [2, 3] * * _.drop([1, 2, 3], 2); * // =&gt; [3] * * _.drop([1, 2, 3], 5); * // =&gt; [] * * _.drop([1, 2, 3], 0); * // =&gt; [1, 2, 3] */ function drop(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, n &lt; 0 ? 0 : n, length); } /** * Creates a slice ofarraywithnelements dropped from the end. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to drop. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.dropRight([1, 2, 3]); * // =&gt; [1, 2] * * _.dropRight([1, 2, 3], 2); * // =&gt; [1] * * _.dropRight([1, 2, 3], 5); * // =&gt; [] * * _.dropRight([1, 2, 3], 0); * // =&gt; [1, 2, 3] */ function dropRight(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); n = length - n; return baseSlice(array, 0, n &lt; 0 ? 0 : n); } /** * Creates a slice ofarrayexcluding elements dropped from the end. * Elements are dropped untilpredicatereturns falsey. The predicate is * invoked with three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.dropRightWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesiteratee shorthand. * _.dropRightWhile(users, { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.dropRightWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;barney&#39;] * * // The_.propertyiteratee shorthand. * _.dropRightWhile(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;, &#39;pebbles&#39;] */ function dropRightWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : []; } /** * Creates a slice ofarrayexcluding elements dropped from the beginning. * Elements are dropped untilpredicatereturns falsey. The predicate is * invoked with three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.dropWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.matchesiteratee shorthand. * _.dropWhile(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.dropWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.propertyiteratee shorthand. * _.dropWhile(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;, &#39;pebbles&#39;] */ function dropWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : []; } /** * Fills elements ofarraywithvaluefromstartup to, but not * including,end. * * **Note:** This method mutatesarray. * * @static * @memberOf _ * @since 3.2.0 * @category Array * @param {Array} array The array to fill. * @param {*} value The value to fillarraywith. * @param {number} [start=0] The start position. * @param {number} [end=array.length] The end position. * @returns {Array} Returnsarray. * @example * * var array = [1, 2, 3]; * * _.fill(array, &#39;a&#39;); * console.log(array); * // =&gt; [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;] * * _.fill(Array(3), 2); * // =&gt; [2, 2, 2] * * _.fill([4, 6, 8, 10], &#39;*&#39;, 1, 3); * // =&gt; [4, &#39;*&#39;, &#39;*&#39;, 10] */ function fill(array, value, start, end) { var length = array == null ? 0 : array.length; if (!length) { return []; } if (start &amp;&amp; typeof start != &#39;number&#39; &amp;&amp; isIterateeCall(array, value, start)) { start = 0; end = length; } return baseFill(array, value, start, end); } /** * This method is like_.findexcept that it returns the index of the first * elementpredicatereturns truthy for instead of the element itself. * * @static * @memberOf _ * @since 1.1.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=0] The index to search from. * @returns {number} Returns the index of the found element, else-1. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.findIndex(users, function(o) { return o.user == &#39;barney&#39;; }); * // =&gt; 0 * * // The_.matchesiteratee shorthand. * _.findIndex(users, { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }); * // =&gt; 1 * * // The_.matchesPropertyiteratee shorthand. * _.findIndex(users, [&#39;active&#39;, false]); * // =&gt; 0 * * // The_.propertyiteratee shorthand. * _.findIndex(users, &#39;active&#39;); * // =&gt; 2 */ function findIndex(array, predicate, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) { index = nativeMax(length + index, 0); } return baseFindIndex(array, getIteratee(predicate, 3), index); } /** * This method is like_.findIndexexcept that it iterates over elements * ofcollectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=array.length-1] The index to search from. * @returns {number} Returns the index of the found element, else-1. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.findLastIndex(users, function(o) { return o.user == &#39;pebbles&#39;; }); * // =&gt; 2 * * // The_.matchesiteratee shorthand. * _.findLastIndex(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }); * // =&gt; 0 * * // The_.matchesPropertyiteratee shorthand. * _.findLastIndex(users, [&#39;active&#39;, false]); * // =&gt; 2 * * // The_.propertyiteratee shorthand. * _.findLastIndex(users, &#39;active&#39;); * // =&gt; 0 */ function findLastIndex(array, predicate, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = length - 1; if (fromIndex !== undefined) { index = toInteger(fromIndex); index = fromIndex &lt; 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1); } return baseFindIndex(array, getIteratee(predicate, 3), index, true); } /** * Flattensarraya single level deep. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to flatten. * @returns {Array} Returns the new flattened array. * @example * * _.flatten([1, [2, [3, [4]], 5]]); * // =&gt; [1, 2, [3, [4]], 5] */ function flatten(array) { var length = array == null ? 0 : array.length; return length ? baseFlatten(array, 1) : []; } /** * Recursively flattensarray. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to flatten. * @returns {Array} Returns the new flattened array. * @example * * _.flattenDeep([1, [2, [3, [4]], 5]]); * // =&gt; [1, 2, 3, 4, 5] */ function flattenDeep(array) { var length = array == null ? 0 : array.length; return length ? baseFlatten(array, INFINITY) : []; } /** * Recursively flattenarrayup todepthtimes. * * @static * @memberOf _ * @since 4.4.0 * @category Array * @param {Array} array The array to flatten. * @param {number} [depth=1] The maximum recursion depth. * @returns {Array} Returns the new flattened array. * @example * * var array = [1, [2, [3, [4]], 5]]; * * _.flattenDepth(array, 1); * // =&gt; [1, 2, [3, [4]], 5] * * _.flattenDepth(array, 2); * // =&gt; [1, 2, 3, [4], 5] */ function flattenDepth(array, depth) { var length = array == null ? 0 : array.length; if (!length) { return []; } depth = depth === undefined ? 1 : toInteger(depth); return baseFlatten(array, depth); } /** * The inverse of_.toPairs; this method returns an object composed * from key-valuepairs. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} pairs The key-value pairs. * @returns {Object} Returns the new object. * @example * * _.fromPairs([[&#39;a&#39;, 1], [&#39;b&#39;, 2]]); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ function fromPairs(pairs) { var index = -1, length = pairs == null ? 0 : pairs.length, result = {}; while (++index &lt; length) { var pair = pairs[index]; result[pair[0]] = pair[1]; } return result; } /** * Gets the first element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @alias first * @category Array * @param {Array} array The array to query. * @returns {*} Returns the first element ofarray. * @example * * _.head([1, 2, 3]); * // =&gt; 1 * * _.head([]); * // =&gt; undefined */ function head(array) { return (array &amp;&amp; array.length) ? array[0] : undefined; } /** * Gets the index at which the first occurrence ofvalueis found inarray* using [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. IffromIndexis negative, it&#39;s used as the * offset from the end ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=0] The index to search from. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.indexOf([1, 2, 1, 2], 2); * // =&gt; 1 * * // Search from thefromIndex. * _.indexOf([1, 2, 1, 2], 2, 2); * // =&gt; 3 */ function indexOf(array, value, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) { index = nativeMax(length + index, 0); } return baseIndexOf(array, value, index); } /** * Gets all but the last element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @returns {Array} Returns the slice ofarray. * @example * * _.initial([1, 2, 3]); * // =&gt; [1, 2] */ function initial(array) { var length = array == null ? 0 : array.length; return length ? baseSlice(array, 0, -1) : []; } /** * Creates an array of unique values that are included in all given arrays * using [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. The order and references of result values are * determined by the first array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of intersecting values. * @example * * _.intersection([2, 1], [2, 3]); * // =&gt; [2] */ var intersection = baseRest(function(arrays) { var mapped = arrayMap(arrays, castArrayLikeObject); return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped) : []; }); /** * This method is like_.intersectionexcept that it acceptsiteratee* which is invoked for each element of eacharraysto generate the criterion * by which they&#39;re compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of intersecting values. * @example * * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [2.1] * * // The_.propertyiteratee shorthand. * _.intersectionBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }] */ var intersectionBy = baseRest(function(arrays) { var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject); if (iteratee === last(mapped)) { iteratee = undefined; } else { mapped.pop(); } return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []; }); /** * This method is like_.intersectionexcept that it acceptscomparator* which is invoked to compare elements ofarrays. The order and references * of result values are determined by the first array. The comparator is * invoked with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of intersecting values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.intersectionWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }] */ var intersectionWith = baseRest(function(arrays) { var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; if (comparator) { mapped.pop(); } return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined, comparator) : []; }); /** * Converts all elements inarrayinto a string separated byseparator. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to convert. * @param {string} [separator=&#39;,&#39;] The element separator. * @returns {string} Returns the joined string. * @example * * _.join([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;~&#39;); * // =&gt; &#39;a~b~c&#39; */ function join(array, separator) { return array == null ? &#39;&#39; : nativeJoin.call(array, separator); } /** * Gets the last element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @returns {*} Returns the last element ofarray. * @example * * _.last([1, 2, 3]); * // =&gt; 3 */ function last(array) { var length = array == null ? 0 : array.length; return length ? array[length - 1] : undefined; } /** * This method is like_.indexOfexcept that it iterates over elements of *arrayfrom right to left. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=array.length-1] The index to search from. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.lastIndexOf([1, 2, 1, 2], 2); * // =&gt; 3 * * // Search from thefromIndex. * _.lastIndexOf([1, 2, 1, 2], 2, 2); * // =&gt; 1 */ function lastIndexOf(array, value, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = length; if (fromIndex !== undefined) { index = toInteger(fromIndex); index = index &lt; 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1); } return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true); } /** * Gets the element at indexnofarray. Ifnis negative, the nth * element from the end is returned. * * @static * @memberOf _ * @since 4.11.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=0] The index of the element to return. * @returns {*} Returns the nth element ofarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; * * _.nth(array, 1); * // =&gt; &#39;b&#39; * * _.nth(array, -2); * // =&gt; &#39;c&#39;; */ function nth(array, n) { return (array &amp;&amp; array.length) ? baseNth(array, toInteger(n)) : undefined; } /** * Removes all given values fromarrayusing * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike.without, this method mutatesarray. Use.remove* to remove elements from an array by predicate. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to modify. * @param {...*} [values] The values to remove. * @returns {Array} Returnsarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; * * _.pull(array, &#39;a&#39;, &#39;c&#39;); * console.log(array); * // =&gt; [&#39;b&#39;, &#39;b&#39;] */ var pull = baseRest(pullAll); /** * This method is like.pullexcept that it accepts an array of values to remove. * * **Note:** Unlike.difference, this method mutatesarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @returns {Array} Returnsarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; * * _.pullAll(array, [&#39;a&#39;, &#39;c&#39;]); * console.log(array); * // =&gt; [&#39;b&#39;, &#39;b&#39;] */ function pullAll(array, values) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values) : array; } /** * This method is like.pullAllexcept that it acceptsiterateewhich is * invoked for each element ofarrayandvaluesto generate the criterion * by which they&#39;re compared. The iteratee is invoked with one argument: (value). * * **Note:** Unlike.differenceBy, this method mutatesarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returnsarray. * @example * * var array = [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }, { &#39;x&#39;: 3 }, { &#39;x&#39;: 1 }]; * * _.pullAllBy(array, [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 3 }], &#39;x&#39;); * console.log(array); * // =&gt; [{ &#39;x&#39;: 2 }] */ function pullAllBy(array, values, iteratee) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values, getIteratee(iteratee, 2)) : array; } /** * This method is like.pullAllexcept that it acceptscomparatorwhich * is invoked to compare elements ofarraytovalues. The comparator is * invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike.differenceWith, this method mutatesarray. * * @static * @memberOf _ * @since 4.6.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returnsarray. * @example * * var array = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 3, &#39;y&#39;: 4 }, { &#39;x&#39;: 5, &#39;y&#39;: 6 }]; * * _.pullAllWith(array, [{ &#39;x&#39;: 3, &#39;y&#39;: 4 }], _.isEqual); * console.log(array); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 5, &#39;y&#39;: 6 }] */ function pullAllWith(array, values, comparator) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values, undefined, comparator) : array; } /** * Removes elements fromarraycorresponding toindexesand returns an * array of removed elements. * * **Note:** Unlike_.at, this method mutatesarray. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to modify. * @param {...(number|number[])} [indexes] The indexes of elements to remove. * @returns {Array} Returns the new array of removed elements. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; * var pulled = _.pullAt(array, [1, 3]); * * console.log(array); * // =&gt; [&#39;a&#39;, &#39;c&#39;] * * console.log(pulled); * // =&gt; [&#39;b&#39;, &#39;d&#39;] */ var pullAt = flatRest(function(array, indexes) { var length = array == null ? 0 : array.length, result = baseAt(array, indexes); basePullAt(array, arrayMap(indexes, function(index) { return isIndex(index, length) ? +index : index; }).sort(compareAscending)); return result; }); /** * Removes all elements fromarraythatpredicatereturns truthy for * and returns an array of the removed elements. The predicate is invoked * with three arguments: (value, index, array). * * **Note:** Unlike.filter, this method mutatesarray. Use.pull* to pull elements from an array by value. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to modify. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new array of removed elements. * @example * * var array = [1, 2, 3, 4]; * var evens = _.remove(array, function(n) { * return n % 2 == 0; * }); * * console.log(array); * // =&gt; [1, 3] * * console.log(evens); * // =&gt; [2, 4] */ function remove(array, predicate) { var result = []; if (!(array &amp;&amp; array.length)) { return result; } var index = -1, indexes = [], length = array.length; predicate = getIteratee(predicate, 3); while (++index &lt; length) { var value = array[index]; if (predicate(value, index, array)) { result.push(value); indexes.push(index); } } basePullAt(array, indexes); return result; } /** * Reversesarrayso that the first element becomes the last, the second * element becomes the second to last, and so on. * * **Note:** This method mutatesarrayand is based on * [Array#reverse](https://mdn.io/Array/reverse). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @returns {Array} Returnsarray. * @example * * var array = [1, 2, 3]; * * _.reverse(array); * // =&gt; [3, 2, 1] * * console.log(array); * // =&gt; [3, 2, 1] */ function reverse(array) { return array == null ? array : nativeReverse.call(array); } /** * Creates a slice ofarrayfromstartup to, but not including,end. * * **Note:** This method is used instead of * [Array#slice](https://mdn.io/Array/slice) to ensure dense arrays are * returned. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to slice. * @param {number} [start=0] The start position. * @param {number} [end=array.length] The end position. * @returns {Array} Returns the slice ofarray. */ function slice(array, start, end) { var length = array == null ? 0 : array.length; if (!length) { return []; } if (end &amp;&amp; typeof end != &#39;number&#39; &amp;&amp; isIterateeCall(array, start, end)) { start = 0; end = length; } else { start = start == null ? 0 : toInteger(start); end = end === undefined ? length : toInteger(end); } return baseSlice(array, start, end); } /** * Uses a binary search to determine the lowest index at whichvalue* should be inserted intoarrayin order to maintain its sort order. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * _.sortedIndex([30, 50], 40); * // =&gt; 1 */ function sortedIndex(array, value) { return baseSortedIndex(array, value); } /** * This method is like_.sortedIndexexcept that it acceptsiteratee* which is invoked forvalueand each element ofarrayto compute their * sort ranking. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * var objects = [{ &#39;x&#39;: 4 }, { &#39;x&#39;: 5 }]; * * _.sortedIndexBy(objects, { &#39;x&#39;: 4 }, function(o) { return o.x; }); * // =&gt; 0 * * // The_.propertyiteratee shorthand. * _.sortedIndexBy(objects, { &#39;x&#39;: 4 }, &#39;x&#39;); * // =&gt; 0 */ function sortedIndexBy(array, value, iteratee) { return baseSortedIndexBy(array, value, getIteratee(iteratee, 2)); } /** * This method is like_.indexOfexcept that it performs a binary * search on a sortedarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.sortedIndexOf([4, 5, 5, 5, 6], 5); * // =&gt; 1 */ function sortedIndexOf(array, value) { var length = array == null ? 0 : array.length; if (length) { var index = baseSortedIndex(array, value); if (index &lt; length &amp;&amp; eq(array[index], value)) { return index; } } return -1; } /** * This method is like_.sortedIndexexcept that it returns the highest * index at whichvalueshould be inserted intoarrayin order to * maintain its sort order. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * _.sortedLastIndex([4, 5, 5, 5, 6], 5); * // =&gt; 4 */ function sortedLastIndex(array, value) { return baseSortedIndex(array, value, true); } /** * This method is like_.sortedLastIndexexcept that it acceptsiteratee* which is invoked forvalueand each element ofarrayto compute their * sort ranking. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * var objects = [{ &#39;x&#39;: 4 }, { &#39;x&#39;: 5 }]; * * _.sortedLastIndexBy(objects, { &#39;x&#39;: 4 }, function(o) { return o.x; }); * // =&gt; 1 * * // The_.propertyiteratee shorthand. * _.sortedLastIndexBy(objects, { &#39;x&#39;: 4 }, &#39;x&#39;); * // =&gt; 1 */ function sortedLastIndexBy(array, value, iteratee) { return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true); } /** * This method is like_.lastIndexOfexcept that it performs a binary * search on a sortedarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5); * // =&gt; 3 */ function sortedLastIndexOf(array, value) { var length = array == null ? 0 : array.length; if (length) { var index = baseSortedIndex(array, value, true) - 1; if (eq(array[index], value)) { return index; } } return -1; } /** * This method is like_.uniqexcept that it&#39;s designed and optimized * for sorted arrays. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @returns {Array} Returns the new duplicate free array. * @example * * _.sortedUniq([1, 1, 2]); * // =&gt; [1, 2] */ function sortedUniq(array) { return (array &amp;&amp; array.length) ? baseSortedUniq(array) : []; } /** * This method is like_.uniqByexcept that it&#39;s designed and optimized * for sorted arrays. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [iteratee] The iteratee invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor); * // =&gt; [1.1, 2.3] */ function sortedUniqBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []; } /** * Gets all but the first element ofarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to query. * @returns {Array} Returns the slice ofarray. * @example * * _.tail([1, 2, 3]); * // =&gt; [2, 3] */ function tail(array) { var length = array == null ? 0 : array.length; return length ? baseSlice(array, 1, length) : []; } /** * Creates a slice ofarraywithnelements taken from the beginning. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to take. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.take([1, 2, 3]); * // =&gt; [1] * * _.take([1, 2, 3], 2); * // =&gt; [1, 2] * * _.take([1, 2, 3], 5); * // =&gt; [1, 2, 3] * * _.take([1, 2, 3], 0); * // =&gt; [] */ function take(array, n, guard) { if (!(array &amp;&amp; array.length)) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, 0, n &lt; 0 ? 0 : n); } /** * Creates a slice ofarraywithnelements taken from the end. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to take. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.takeRight([1, 2, 3]); * // =&gt; [3] * * _.takeRight([1, 2, 3], 2); * // =&gt; [2, 3] * * _.takeRight([1, 2, 3], 5); * // =&gt; [1, 2, 3] * * _.takeRight([1, 2, 3], 0); * // =&gt; [] */ function takeRight(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); n = length - n; return baseSlice(array, n &lt; 0 ? 0 : n, length); } /** * Creates a slice ofarraywith elements taken from the end. Elements are * taken untilpredicatereturns falsey. The predicate is invoked with * three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.takeRightWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.matchesiteratee shorthand. * _.takeRightWhile(users, { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.takeRightWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.propertyiteratee shorthand. * _.takeRightWhile(users, &#39;active&#39;); * // =&gt; [] */ function takeRightWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : []; } /** * Creates a slice ofarraywith elements taken from the beginning. Elements * are taken untilpredicatereturns falsey. The predicate is invoked with * three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.takeWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.takeWhile(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.takeWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.takeWhile(users, &#39;active&#39;); * // =&gt; [] */ function takeWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3)) : []; } /** * Creates an array of unique values, in order, from all given arrays using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of combined values. * @example * * _.union([2], [1, 2]); * // =&gt; [2, 1] */ var union = baseRest(function(arrays) { return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true)); }); /** * This method is like_.unionexcept that it acceptsiterateewhich is * invoked for each element of eacharraysto generate the criterion by * which uniqueness is computed. Result values are chosen from the first * array in which the value occurs. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of combined values. * @example * * _.unionBy([2.1], [1.2, 2.3], Math.floor); * // =&gt; [2.1, 1.2] * * // The_.propertyiteratee shorthand. * _.unionBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }] */ var unionBy = baseRest(function(arrays) { var iteratee = last(arrays); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)); }); /** * This method is like_.unionexcept that it acceptscomparatorwhich * is invoked to compare elements ofarrays. Result values are chosen from * the first array in which the value occurs. The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of combined values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.unionWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 1 }] */ var unionWith = baseRest(function(arrays) { var comparator = last(arrays); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator); }); /** * Creates a duplicate-free version of an array, using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons, in which only the first occurrence of each element * is kept. The order of result values is determined by the order they occur * in the array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @returns {Array} Returns the new duplicate free array. * @example * * _.uniq([2, 1, 2]); * // =&gt; [2, 1] */ function uniq(array) { return (array &amp;&amp; array.length) ? baseUniq(array) : []; } /** * This method is like_.uniqexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * uniqueness is computed. The order of result values is determined by the * order they occur in the array. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * _.uniqBy([2.1, 1.2, 2.3], Math.floor); * // =&gt; [2.1, 1.2] * * // The_.propertyiteratee shorthand. * _.uniqBy([{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }] */ function uniqBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : []; } /** * This method is like_.uniqexcept that it acceptscomparatorwhich * is invoked to compare elements ofarray. The order of result values is * determined by the order they occur in the array.The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.uniqWith(objects, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }] */ function uniqWith(array, comparator) { comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return (array &amp;&amp; array.length) ? baseUniq(array, undefined, comparator) : []; } /** * This method is like_.zipexcept that it accepts an array of grouped * elements and creates an array regrouping the elements to their pre-zip * configuration. * * @static * @memberOf _ * @since 1.2.0 * @category Array * @param {Array} array The array of grouped elements to process. * @returns {Array} Returns the new array of regrouped elements. * @example * * var zipped = _.zip([&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]); * // =&gt; [[&#39;a&#39;, 1, true], [&#39;b&#39;, 2, false]] * * _.unzip(zipped); * // =&gt; [[&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]] */ function unzip(array) { if (!(array &amp;&amp; array.length)) { return []; } var length = 0; array = arrayFilter(array, function(group) { if (isArrayLikeObject(group)) { length = nativeMax(group.length, length); return true; } }); return baseTimes(length, function(index) { return arrayMap(array, baseProperty(index)); }); } /** * This method is like_.unzipexcept that it acceptsiterateeto specify * how regrouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * * @static * @memberOf _ * @since 3.8.0 * @category Array * @param {Array} array The array of grouped elements to process. * @param {Function} [iteratee=_.identity] The function to combine * regrouped values. * @returns {Array} Returns the new array of regrouped elements. * @example * * var zipped = _.zip([1, 2], [10, 20], [100, 200]); * // =&gt; [[1, 10, 100], [2, 20, 200]] * * _.unzipWith(zipped, _.add); * // =&gt; [3, 30, 300] */ function unzipWith(array, iteratee) { if (!(array &amp;&amp; array.length)) { return []; } var result = unzip(array); if (iteratee == null) { return result; } return arrayMap(result, function(group) { return apply(iteratee, undefined, group); }); } /** * Creates an array excluding all given values using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike_.pull, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {...*} [values] The values to exclude. * @returns {Array} Returns the new array of filtered values. * @see _.difference, _.xor * @example * * _.without([2, 1, 2, 3], 1, 2); * // =&gt; [3] */ var without = baseRest(function(array, values) { return isArrayLikeObject(array) ? baseDifference(array, values) : []; }); /** * Creates an array of unique values that is the * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) * of the given arrays. The order of result values is determined by the order * they occur in the arrays. * * @static * @memberOf _ * @since 2.4.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of filtered values. * @see _.difference, _.without * @example * * _.xor([2, 1], [2, 3]); * // =&gt; [1, 3] */ var xor = baseRest(function(arrays) { return baseXor(arrayFilter(arrays, isArrayLikeObject)); }); /** * This method is like_.xorexcept that it acceptsiterateewhich is * invoked for each element of eacharraysto generate the criterion by * which by which they&#39;re compared. The order of result values is determined * by the order they occur in the arrays. The iteratee is invoked with one * argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [1.2, 3.4] * * // The_.propertyiteratee shorthand. * _.xorBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 2 }] */ var xorBy = baseRest(function(arrays) { var iteratee = last(arrays); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2)); }); /** * This method is like_.xorexcept that it acceptscomparatorwhich is * invoked to compare elements ofarrays. The order of result values is * determined by the order they occur in the arrays. The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.xorWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 1 }] */ var xorWith = baseRest(function(arrays) { var comparator = last(arrays); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator); }); /** * Creates an array of grouped elements, the first of which contains the * first elements of the given arrays, the second of which contains the * second elements of the given arrays, and so on. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to process. * @returns {Array} Returns the new array of grouped elements. * @example * * _.zip([&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]); * // =&gt; [[&#39;a&#39;, 1, true], [&#39;b&#39;, 2, false]] */ var zip = baseRest(unzip); /** * This method is like_.fromPairsexcept that it accepts two arrays, * one of property identifiers and one of corresponding values. * * @static * @memberOf _ * @since 0.4.0 * @category Array * @param {Array} [props=[]] The property identifiers. * @param {Array} [values=[]] The property values. * @returns {Object} Returns the new object. * @example * * _.zipObject([&#39;a&#39;, &#39;b&#39;], [1, 2]); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ function zipObject(props, values) { return baseZipObject(props || [], values || [], assignValue); } /** * This method is like_.zipObjectexcept that it supports property paths. * * @static * @memberOf _ * @since 4.1.0 * @category Array * @param {Array} [props=[]] The property identifiers. * @param {Array} [values=[]] The property values. * @returns {Object} Returns the new object. * @example * * _.zipObjectDeep([&#39;a.b[0].c&#39;, &#39;a.b[1].d&#39;], [1, 2]); * // =&gt; { &#39;a&#39;: { &#39;b&#39;: [{ &#39;c&#39;: 1 }, { &#39;d&#39;: 2 }] } } */ function zipObjectDeep(props, values) { return baseZipObject(props || [], values || [], baseSet); } /** * This method is like_.zipexcept that it acceptsiterateeto specify * how grouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * * @static * @memberOf _ * @since 3.8.0 * @category Array * @param {...Array} [arrays] The arrays to process. * @param {Function} [iteratee=_.identity] The function to combine * grouped values. * @returns {Array} Returns the new array of grouped elements. * @example * * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) { * return a + b + c; * }); * // =&gt; [111, 222] */ var zipWith = baseRest(function(arrays) { var length = arrays.length, iteratee = length &gt; 1 ? arrays[length - 1] : undefined; iteratee = typeof iteratee == &#39;function&#39; ? (arrays.pop(), iteratee) : undefined; return unzipWith(arrays, iteratee); }); /*------------------------------------------------------------------------*/ /** * Creates alodashwrapper instance that wrapsvaluewith explicit method * chain sequences enabled. The result of such sequences must be unwrapped * with_#value. * * @static * @memberOf _ * @since 1.3.0 * @category Seq * @param {*} value The value to wrap. * @returns {Object} Returns the newlodashwrapper instance. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1 } * ]; * * var youngest = _ * .chain(users) * .sortBy(&#39;age&#39;) * .map(function(o) { * return o.user + &#39; is &#39; + o.age; * }) * .head() * .value(); * // =&gt; &#39;pebbles is 1&#39; */ function chain(value) { var result = lodash(value); result.__chain__ = true; return result; } /** * This method invokesinterceptorand returnsvalue. The interceptor * is invoked with one argument; (value). The purpose of this method is to * &quot;tap into&quot; a method chain sequence in order to modify intermediate results. * * @static * @memberOf _ * @since 0.1.0 * @category Seq * @param {*} value The value to provide tointerceptor. * @param {Function} interceptor The function to invoke. * @returns {*} Returnsvalue. * @example * * _([1, 2, 3]) * .tap(function(array) { * // Mutate input array. * array.pop(); * }) * .reverse() * .value(); * // =&gt; [2, 1] */ function tap(value, interceptor) { interceptor(value); return value; } /** * This method is like_.tapexcept that it returns the result ofinterceptor. * The purpose of this method is to &quot;pass thru&quot; values replacing intermediate * results in a method chain sequence. * * @static * @memberOf _ * @since 3.0.0 * @category Seq * @param {*} value The value to provide tointerceptor. * @param {Function} interceptor The function to invoke. * @returns {*} Returns the result ofinterceptor. * @example * * _(&#39; abc &#39;) * .chain() * .trim() * .thru(function(value) { * return [value]; * }) * .value(); * // =&gt; [&#39;abc&#39;] */ function thru(value, interceptor) { return interceptor(value); } /** * This method is the wrapper version of_.at. * * @name at * @memberOf _ * @since 1.0.0 * @category Seq * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Object} Returns the newlodashwrapper instance. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }, 4] }; * * _(object).at([&#39;a[0].b.c&#39;, &#39;a[1]&#39;]).value(); * // =&gt; [3, 4] */ var wrapperAt = flatRest(function(paths) { var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) { return baseAt(object, paths); }; if (length &gt; 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) { return this.thru(interceptor); } value = value.slice(start, +start + (length ? 1 : 0)); value.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [interceptor], &#39;thisArg&#39;: undefined }); return new LodashWrapper(value, this.__chain__).thru(function(array) { if (length &amp;&amp; !array.length) { array.push(undefined); } return array; }); }); /** * Creates alodashwrapper instance with explicit method chain sequences enabled. * * @name chain * @memberOf _ * @since 0.1.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 } * ]; * * // A sequence without explicit chaining. * _(users).head(); * // =&gt; { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } * * // A sequence with explicit chaining. * _(users) * .chain() * .head() * .pick(&#39;user&#39;) * .value(); * // =&gt; { &#39;user&#39;: &#39;barney&#39; } */ function wrapperChain() { return chain(this); } /** * Executes the chain sequence and returns the wrapped result. * * @name commit * @memberOf _ * @since 3.2.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var array = [1, 2]; * var wrapped = _(array).push(3); * * console.log(array); * // =&gt; [1, 2] * * wrapped = wrapped.commit(); * console.log(array); * // =&gt; [1, 2, 3] * * wrapped.last(); * // =&gt; 3 * * console.log(array); * // =&gt; [1, 2, 3] */ function wrapperCommit() { return new LodashWrapper(this.value(), this.__chain__); } /** * Gets the next value on a wrapped object following the * [iterator protocol](https://mdn.io/iteration_protocols#iterator). * * @name next * @memberOf _ * @since 4.0.0 * @category Seq * @returns {Object} Returns the next iterator value. * @example * * var wrapped = _([1, 2]); * * wrapped.next(); * // =&gt; { &#39;done&#39;: false, &#39;value&#39;: 1 } * * wrapped.next(); * // =&gt; { &#39;done&#39;: false, &#39;value&#39;: 2 } * * wrapped.next(); * // =&gt; { &#39;done&#39;: true, &#39;value&#39;: undefined } */ function wrapperNext() { if (this.__values__ === undefined) { this.__values__ = toArray(this.value()); } var done = this.__index__ &gt;= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++]; return { &#39;done&#39;: done, &#39;value&#39;: value }; } /** * Enables the wrapper to be iterable. * * @name Symbol.iterator * @memberOf _ * @since 4.0.0 * @category Seq * @returns {Object} Returns the wrapper object. * @example * * var wrapped = _([1, 2]); * * wrapped[Symbol.iterator]() === wrapped; * // =&gt; true * * Array.from(wrapped); * // =&gt; [1, 2] */ function wrapperToIterator() { return this; } /** * Creates a clone of the chain sequence plantingvalueas the wrapped value. * * @name plant * @memberOf _ * @since 3.2.0 * @category Seq * @param {*} value The value to plant. * @returns {Object} Returns the newlodashwrapper instance. * @example * * function square(n) { * return n * n; * } * * var wrapped = _([1, 2]).map(square); * var other = wrapped.plant([3, 4]); * * other.value(); * // =&gt; [9, 16] * * wrapped.value(); * // =&gt; [1, 4] */ function wrapperPlant(value) { var result, parent = this; while (parent instanceof baseLodash) { var clone = wrapperClone(parent); clone.__index__ = 0; clone.__values__ = undefined; if (result) { previous.__wrapped__ = clone; } else { result = clone; } var previous = clone; parent = parent.__wrapped__; } previous.__wrapped__ = value; return result; } /** * This method is the wrapper version of_.reverse. * * **Note:** This method mutates the wrapped array. * * @name reverse * @memberOf _ * @since 0.1.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var array = [1, 2, 3]; * * _(array).reverse().value() * // =&gt; [3, 2, 1] * * console.log(array); * // =&gt; [3, 2, 1] */ function wrapperReverse() { var value = this.__wrapped__; if (value instanceof LazyWrapper) { var wrapped = value; if (this.__actions__.length) { wrapped = new LazyWrapper(this); } wrapped = wrapped.reverse(); wrapped.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [reverse], &#39;thisArg&#39;: undefined }); return new LodashWrapper(wrapped, this.__chain__); } return this.thru(reverse); } /** * Executes the chain sequence to resolve the unwrapped value. * * @name value * @memberOf _ * @since 0.1.0 * @alias toJSON, valueOf * @category Seq * @returns {*} Returns the resolved unwrapped value. * @example * * _([1, 2, 3]).value(); * // =&gt; [1, 2, 3] */ function wrapperValue() { return baseWrapperValue(this.__wrapped__, this.__actions__); } /*------------------------------------------------------------------------*/ /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The corresponding value of * each key is the number of times the key was returned byiteratee. The * iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 0.5.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * _.countBy([6.1, 4.2, 6.3], Math.floor); * // =&gt; { &#39;4&#39;: 1, &#39;6&#39;: 2 } * * // The_.propertyiteratee shorthand. * _.countBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); * // =&gt; { &#39;3&#39;: 2, &#39;5&#39;: 1 } */ var countBy = createAggregator(function(result, value, key) { if (hasOwnProperty.call(result, key)) { ++result[key]; } else { baseAssignValue(result, key, 1); } }); /** * Checks ifpredicatereturns truthy for **all** elements ofcollection. * Iteration is stopped oncepredicatereturns falsey. The predicate is * invoked with three arguments: (value, index|key, collection). * * **Note:** This method returnstruefor * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of * elements of empty collections. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {boolean} Returnstrueif all elements pass the predicate check, * elsefalse. * @example * * _.every([true, 1, null, &#39;yes&#39;], Boolean); * // =&gt; false * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.every(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; false * * // The_.matchesPropertyiteratee shorthand. * _.every(users, [&#39;active&#39;, false]); * // =&gt; true * * // The_.propertyiteratee shorthand. * _.every(users, &#39;active&#39;); * // =&gt; false */ function every(collection, predicate, guard) { var func = isArray(collection) ? arrayEvery : baseEvery; if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) { predicate = undefined; } return func(collection, getIteratee(predicate, 3)); } /** * Iterates over elements ofcollection, returning an array of all elements *predicatereturns truthy for. The predicate is invoked with three * arguments: (value, index|key, collection). * * **Note:** Unlike_.remove, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new filtered array. * @see _.reject * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * _.filter(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.filter(users, { &#39;age&#39;: 36, &#39;active&#39;: true }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.filter(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.filter(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;] */ function filter(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, getIteratee(predicate, 3)); } /** * Iterates over elements ofcollection, returning the first element *predicatereturns truthy for. The predicate is invoked with three * arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=0] The index to search from. * @returns {*} Returns the matched element, elseundefined. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1, &#39;active&#39;: true } * ]; * * _.find(users, function(o) { return o.age &lt; 40; }); * // =&gt; object for &#39;barney&#39; * * // The_.matchesiteratee shorthand. * _.find(users, { &#39;age&#39;: 1, &#39;active&#39;: true }); * // =&gt; object for &#39;pebbles&#39; * * // The_.matchesPropertyiteratee shorthand. * _.find(users, [&#39;active&#39;, false]); * // =&gt; object for &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.find(users, &#39;active&#39;); * // =&gt; object for &#39;barney&#39; */ var find = createFind(findIndex); /** * This method is like_.findexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @category Collection * @param {Array|Object} collection The collection to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=collection.length-1] The index to search from. * @returns {*} Returns the matched element, elseundefined. * @example * * _.findLast([1, 2, 3, 4], function(n) { * return n % 2 == 1; * }); * // =&gt; 3 */ var findLast = createFind(findLastIndex); /** * Creates a flattened array of values by running each element incollection* thruiterateeand flattening the mapped results. The iteratee is invoked * with three arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [n, n]; * } * * _.flatMap([1, 2], duplicate); * // =&gt; [1, 1, 2, 2] */ function flatMap(collection, iteratee) { return baseFlatten(map(collection, iteratee), 1); } /** * This method is like_.flatMapexcept that it recursively flattens the * mapped results. * * @static * @memberOf _ * @since 4.7.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [[[n, n]]]; * } * * _.flatMapDeep([1, 2], duplicate); * // =&gt; [1, 1, 2, 2] */ function flatMapDeep(collection, iteratee) { return baseFlatten(map(collection, iteratee), INFINITY); } /** * This method is like_.flatMapexcept that it recursively flattens the * mapped results up todepthtimes. * * @static * @memberOf _ * @since 4.7.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {number} [depth=1] The maximum recursion depth. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [[[n, n]]]; * } * * _.flatMapDepth([1, 2], duplicate, 2); * // =&gt; [[1, 1], [2, 2]] */ function flatMapDepth(collection, iteratee, depth) { depth = depth === undefined ? 1 : toInteger(depth); return baseFlatten(map(collection, iteratee), depth); } /** * Iterates over elements ofcollectionand invokesiterateefor each element. * The iteratee is invoked with three arguments: (value, index|key, collection). * Iteratee functions may exit iteration early by explicitly returningfalse. * * **Note:** As with other &quot;Collections&quot; methods, objects with a &quot;length&quot; * property are iterated like arrays. To avoid this behavior use.forIn* or.forOwnfor object iteration. * * @static * @memberOf _ * @since 0.1.0 * @alias each * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array|Object} Returnscollection. * @see _.forEachRight * @example * * _.forEach([1, 2], function(value) { * console.log(value); * }); * // =&gt; Logs1then2. * * _.forEach({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39; then &#39;b&#39; (iteration order is not guaranteed). */ function forEach(collection, iteratee) { var func = isArray(collection) ? arrayEach : baseEach; return func(collection, getIteratee(iteratee, 3)); } /** * This method is like_.forEachexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @alias eachRight * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array|Object} Returnscollection. * @see _.forEach * @example * * _.forEachRight([1, 2], function(value) { * console.log(value); * }); * // =&gt; Logs2then1. */ function forEachRight(collection, iteratee) { var func = isArray(collection) ? arrayEachRight : baseEachRight; return func(collection, getIteratee(iteratee, 3)); } /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The order of grouped values * is determined by the order they occur incollection. The corresponding * value of each key is an array of elements responsible for generating the * key. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * _.groupBy([6.1, 4.2, 6.3], Math.floor); * // =&gt; { &#39;4&#39;: [4.2], &#39;6&#39;: [6.1, 6.3] } * * // The_.propertyiteratee shorthand. * _.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); * // =&gt; { &#39;3&#39;: [&#39;one&#39;, &#39;two&#39;], &#39;5&#39;: [&#39;three&#39;] } */ var groupBy = createAggregator(function(result, value, key) { if (hasOwnProperty.call(result, key)) { result[key].push(value); } else { baseAssignValue(result, key, [value]); } }); /** * Checks ifvalueis incollection. Ifcollectionis a string, it&#39;s * checked for a substring ofvalue, otherwise * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * is used for equality comparisons. IffromIndexis negative, it&#39;s used as * the offset from the end ofcollection. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object|string} collection The collection to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=0] The index to search from. * @param- {Object} [guard] Enables use as an iteratee for methods like_.reduce. * @returns {boolean} Returnstrueifvalueis found, elsefalse. * @example * * _.includes([1, 2, 3], 1); * // =&gt; true * * _.includes([1, 2, 3], 1, 2); * // =&gt; false * * _.includes({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, 1); * // =&gt; true * * _.includes(&#39;abcd&#39;, &#39;bc&#39;); * // =&gt; true */ function includes(collection, value, fromIndex, guard) { collection = isArrayLike(collection) ? collection : values(collection); fromIndex = (fromIndex &amp;&amp; !guard) ? toInteger(fromIndex) : 0; var length = collection.length; if (fromIndex &lt; 0) { fromIndex = nativeMax(length + fromIndex, 0); } return isString(collection) ? (fromIndex &lt;= length &amp;&amp; collection.indexOf(value, fromIndex) &gt; -1) : (!!length &amp;&amp; baseIndexOf(collection, value, fromIndex) &gt; -1); } /** * Invokes the method atpathof each element incollection, returning * an array of the results of each invoked method. Any additional arguments * are provided to each invoked method. Ifpathis a function, it&#39;s invoked * for, andthisbound to, each element incollection. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Array|Function|string} path The path of the method to invoke or * the function invoked per iteration. * @param {...*} [args] The arguments to invoke each method with. * @returns {Array} Returns the array of results. * @example * * _.invokeMap([[5, 1, 7], [3, 2, 1]], &#39;sort&#39;); * // =&gt; [[1, 5, 7], [1, 2, 3]] * * _.invokeMap([123, 456], String.prototype.split, &#39;&#39;); * // =&gt; [[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;5&#39;, &#39;6&#39;]] */ var invokeMap = baseRest(function(collection, path, args) { var index = -1, isFunc = typeof path == &#39;function&#39;, result = isArrayLike(collection) ? Array(collection.length) : []; baseEach(collection, function(value) { result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args); }); return result; }); /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The corresponding value of * each key is the last element responsible for generating the key. The * iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * var array = [ * { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, * { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } * ]; * * _.keyBy(array, function(o) { * return String.fromCharCode(o.code); * }); * // =&gt; { &#39;a&#39;: { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, &#39;d&#39;: { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } } * * _.keyBy(array, &#39;dir&#39;); * // =&gt; { &#39;left&#39;: { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, &#39;right&#39;: { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } } */ var keyBy = createAggregator(function(result, value, key) { baseAssignValue(result, key, value); }); /** * Creates an array of values by running each element incollectionthru *iteratee. The iteratee is invoked with three arguments: * (value, index|key, collection). * * Many lodash methods are guarded to work as iteratees for methods like *.every,.filter,.map,.mapValues,.reject, and.some. * * The guarded methods are: *ary,chunk,curry,curryRight,drop,dropRight,every, *fill,invert,parseInt,random,range,rangeRight,repeat, *sampleSize,slice,some,sortBy,split,take,takeRight, *template,trim,trimEnd,trimStart, andwords* * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new mapped array. * @example * * function square(n) { * return n * n; * } * * _.map([4, 8], square); * // =&gt; [16, 64] * * _.map({ &#39;a&#39;: 4, &#39;b&#39;: 8 }, square); * // =&gt; [16, 64] (iteration order is not guaranteed) * * var users = [ * { &#39;user&#39;: &#39;barney&#39; }, * { &#39;user&#39;: &#39;fred&#39; } * ]; * * // The_.propertyiteratee shorthand. * _.map(users, &#39;user&#39;); * // =&gt; [&#39;barney&#39;, &#39;fred&#39;] */ function map(collection, iteratee) { var func = isArray(collection) ? arrayMap : baseMap; return func(collection, getIteratee(iteratee, 3)); } /** * This method is like_.sortByexcept that it allows specifying the sort * orders of the iteratees to sort by. Ifordersis unspecified, all values * are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for * descending or &quot;asc&quot; for ascending sort order of corresponding values. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]] * The iteratees to sort by. * @param {string[]} [orders] The sort orders ofiteratees. * @param- {Object} [guard] Enables use as an iteratee for methods like_.reduce. * @returns {Array} Returns the new sorted array. * @example * * var users = [ * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 48 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 34 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } * ]; * * // Sort byuserin ascending order and byagein descending order. * _.orderBy(users, [&#39;user&#39;, &#39;age&#39;], [&#39;asc&#39;, &#39;desc&#39;]); * // =&gt; objects for [[&#39;barney&#39;, 36], [&#39;barney&#39;, 34], [&#39;fred&#39;, 48], [&#39;fred&#39;, 40]] */ function orderBy(collection, iteratees, orders, guard) { if (collection == null) { return []; } if (!isArray(iteratees)) { iteratees = iteratees == null ? [] : [iteratees]; } orders = guard ? undefined : orders; if (!isArray(orders)) { orders = orders == null ? [] : [orders]; } return baseOrderBy(collection, iteratees, orders); } /** * Creates an array of elements split into two groups, the first of which * contains elementspredicatereturns truthy for, the second of which * contains elementspredicatereturns falsey for. The predicate is * invoked with one argument: (value). * * @static * @memberOf _ * @since 3.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of grouped elements. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1, &#39;active&#39;: false } * ]; * * _.partition(users, function(o) { return o.active; }); * // =&gt; objects for [[&#39;fred&#39;], [&#39;barney&#39;, &#39;pebbles&#39;]] * * // The_.matchesiteratee shorthand. * _.partition(users, { &#39;age&#39;: 1, &#39;active&#39;: false }); * // =&gt; objects for [[&#39;pebbles&#39;], [&#39;barney&#39;, &#39;fred&#39;]] * * // The_.matchesPropertyiteratee shorthand. * _.partition(users, [&#39;active&#39;, false]); * // =&gt; objects for [[&#39;barney&#39;, &#39;pebbles&#39;], [&#39;fred&#39;]] * * // The_.propertyiteratee shorthand. * _.partition(users, &#39;active&#39;); * // =&gt; objects for [[&#39;fred&#39;], [&#39;barney&#39;, &#39;pebbles&#39;]] */ var partition = createAggregator(function(result, value, key) { result[key ? 0 : 1].push(value); }, function() { return [[], []]; }); /** * Reducescollectionto a value which is the accumulated result of running * each element incollectionthruiteratee, where each successive * invocation is supplied the return value of the previous. Ifaccumulator* is not given, the first element ofcollectionis used as the initial * value. The iteratee is invoked with four arguments: * (accumulator, value, index|key, collection). * * Many lodash methods are guarded to work as iteratees for methods like *.reduce,.reduceRight, and_.transform. * * The guarded methods are: *assign,defaults,defaultsDeep,includes,merge,orderBy, * andsortBy* * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The initial value. * @returns {*} Returns the accumulated value. * @see _.reduceRight * @example * * _.reduce([1, 2], function(sum, n) { * return sum + n; * }, 0); * // =&gt; 3 * * _.reduce({ &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }, function(result, value, key) { * (result[value] || (result[value] = [])).push(key); * return result; * }, {}); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } (iteration order is not guaranteed) */ function reduce(collection, iteratee, accumulator) { var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length &lt; 3; return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach); } /** * This method is like_.reduceexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The initial value. * @returns {*} Returns the accumulated value. * @see _.reduce * @example * * var array = [[0, 1], [2, 3], [4, 5]]; * * _.reduceRight(array, function(flattened, other) { * return flattened.concat(other); * }, []); * // =&gt; [4, 5, 2, 3, 0, 1] */ function reduceRight(collection, iteratee, accumulator) { var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length &lt; 3; return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight); } /** * The opposite of_.filter; this method returns the elements ofcollection* thatpredicatedoes **not** return truthy for. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new filtered array. * @see _.filter * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: true } * ]; * * _.reject(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.reject(users, { &#39;age&#39;: 40, &#39;active&#39;: true }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.reject(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.reject(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;] */ function reject(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, negate(getIteratee(predicate, 3))); } /** * Gets a random element fromcollection. * * @static * @memberOf _ * @since 2.0.0 * @category Collection * @param {Array|Object} collection The collection to sample. * @returns {*} Returns the random element. * @example * * _.sample([1, 2, 3, 4]); * // =&gt; 2 */ function sample(collection) { var func = isArray(collection) ? arraySample : baseSample; return func(collection); } /** * Getsnrandom elements at unique keys fromcollectionup to the * size ofcollection. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to sample. * @param {number} [n=1] The number of elements to sample. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the random elements. * @example * * _.sampleSize([1, 2, 3], 2); * // =&gt; [3, 1] * * _.sampleSize([1, 2, 3], 4); * // =&gt; [2, 3, 1] */ function sampleSize(collection, n, guard) { if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } var func = isArray(collection) ? arraySampleSize : baseSampleSize; return func(collection, n); } /** * Creates an array of shuffled values, using a version of the * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to shuffle. * @returns {Array} Returns the new shuffled array. * @example * * _.shuffle([1, 2, 3, 4]); * // =&gt; [4, 1, 3, 2] */ function shuffle(collection) { var func = isArray(collection) ? arrayShuffle : baseShuffle; return func(collection); } /** * Gets the size ofcollectionby returning its length for array-like * values or the number of own enumerable string keyed properties for objects. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object|string} collection The collection to inspect. * @returns {number} Returns the collection size. * @example * * _.size([1, 2, 3]); * // =&gt; 3 * * _.size({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; 2 * * _.size(&#39;pebbles&#39;); * // =&gt; 7 */ function size(collection) { if (collection == null) { return 0; } if (isArrayLike(collection)) { return isString(collection) ? stringSize(collection) : collection.length; } var tag = getTag(collection); if (tag == mapTag || tag == setTag) { return collection.size; } return baseKeys(collection).length; } /** * Checks ifpredicatereturns truthy for **any** element ofcollection. * Iteration is stopped oncepredicatereturns truthy. The predicate is * invoked with three arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {boolean} Returnstrueif any element passes the predicate check, * elsefalse. * @example * * _.some([null, 0, &#39;yes&#39;, false], Boolean); * // =&gt; true * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.some(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; false * * // The_.matchesPropertyiteratee shorthand. * _.some(users, [&#39;active&#39;, false]); * // =&gt; true * * // The_.propertyiteratee shorthand. * _.some(users, &#39;active&#39;); * // =&gt; true */ function some(collection, predicate, guard) { var func = isArray(collection) ? arraySome : baseSome; if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) { predicate = undefined; } return func(collection, getIteratee(predicate, 3)); } /** * Creates an array of elements, sorted in ascending order by the results of * running each element in a collection thru each iteratee. This method * performs a stable sort, that is, it preserves the original sort order of * equal elements. The iteratees are invoked with one argument: (value). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to sort by. * @returns {Array} Returns the new sorted array. * @example * * var users = [ * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 48 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 34 } * ]; * * _.sortBy(users, [function(o) { return o.user; }]); * // =&gt; objects for [[&#39;barney&#39;, 36], [&#39;barney&#39;, 34], [&#39;fred&#39;, 48], [&#39;fred&#39;, 40]] * * _.sortBy(users, [&#39;user&#39;, &#39;age&#39;]); * // =&gt; objects for [[&#39;barney&#39;, 34], [&#39;barney&#39;, 36], [&#39;fred&#39;, 40], [&#39;fred&#39;, 48]] */ var sortBy = baseRest(function(collection, iteratees) { if (collection == null) { return []; } var length = iteratees.length; if (length &gt; 1 &amp;&amp; isIterateeCall(collection, iteratees[0], iteratees[1])) { iteratees = []; } else if (length &gt; 2 &amp;&amp; isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) { iteratees = [iteratees[0]]; } return baseOrderBy(collection, baseFlatten(iteratees, 1), []); }); /*------------------------------------------------------------------------*/ /** * Gets the timestamp of the number of milliseconds that have elapsed since * the Unix epoch (1 January 1970 00:00:00 UTC). * * @static * @memberOf _ * @since 2.4.0 * @category Date * @returns {number} Returns the timestamp. * @example * * _.defer(function(stamp) { * console.log(_.now() - stamp); * }, _.now()); * // =&gt; Logs the number of milliseconds it took for the deferred invocation. */ var now = ctxNow || function() { return root.Date.now(); }; /*------------------------------------------------------------------------*/ /** * The opposite of_.before; this method creates a function that invokes *funconce it&#39;s callednor more times. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {number} n The number of calls beforefuncis invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * var saves = [&#39;profile&#39;, &#39;settings&#39;]; * * var done = _.after(saves.length, function() { * console.log(&#39;done saving!&#39;); * }); * * _.forEach(saves, function(type) { * asyncSave({ &#39;type&#39;: type, &#39;complete&#39;: done }); * }); * // =&gt; Logs &#39;done saving!&#39; after the two async saves have completed. */ function after(n, func) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } n = toInteger(n); return function() { if (--n &lt; 1) { return func.apply(this, arguments); } }; } /** * Creates a function that invokesfunc, with up tonarguments, * ignoring any additional arguments. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to cap arguments for. * @param {number} [n=func.length] The arity cap. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new capped function. * @example * * _.map([&#39;6&#39;, &#39;8&#39;, &#39;10&#39;], _.ary(parseInt, 1)); * // =&gt; [6, 8, 10] */ function ary(func, n, guard) { n = guard ? undefined : n; n = (func &amp;&amp; n == null) ? func.length : n; return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n); } /** * Creates a function that invokesfunc, with thethisbinding and arguments * of the created function, while it&#39;s called less thanntimes. Subsequent * calls to the created function return the result of the lastfuncinvocation. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {number} n The number of calls at whichfuncis no longer invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * jQuery(element).on(&#39;click&#39;, _.before(5, addContactToList)); * // =&gt; Allows adding up to 4 contacts to the list. */ function before(n, func) { var result; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } n = toInteger(n); return function() { if (--n &gt; 0) { result = func.apply(this, arguments); } if (n &lt;= 1) { func = undefined; } return result; }; } /** * Creates a function that invokesfuncwith thethisbinding ofthisArg* andpartialsprepended to the arguments it receives. * * The.bind.placeholdervalue, which defaults toin monolithic builds, * may be used as a placeholder for partially applied arguments. * * **Note:** Unlike nativeFunction#bind, this method doesn&#39;t set the &quot;length&quot; * property of bound functions. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to bind. * @param {*} thisArg Thethisbinding offunc. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new bound function. * @example * * function greet(greeting, punctuation) { * return greeting + &#39; &#39; + this.user + punctuation; * } * * var object = { &#39;user&#39;: &#39;fred&#39; }; * * var bound = _.bind(greet, object, &#39;hi&#39;); * bound(&#39;!&#39;); * // =&gt; &#39;hi fred!&#39; * * // Bound with placeholders. * var bound = _.bind(greet, object, _, &#39;!&#39;); * bound(&#39;hi&#39;); * // =&gt; &#39;hi fred!&#39; */ var bind = baseRest(function(func, thisArg, partials) { var bitmask = WRAP_BIND_FLAG; if (partials.length) { var holders = replaceHolders(partials, getHolder(bind)); bitmask |= WRAP_PARTIAL_FLAG; } return createWrap(func, bitmask, thisArg, partials, holders); }); /** * Creates a function that invokes the method atobject[key]withpartials* prepended to the arguments it receives. * * This method differs from.bindby allowing bound functions to reference * methods that may be redefined or don&#39;t yet exist. See * [Peter Michaux&#39;s article](http://peter.michaux.ca/articles/lazy-function-definition-pattern) * for more details. * * The.bindKey.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * @static * @memberOf _ * @since 0.10.0 * @category Function * @param {Object} object The object to invoke the method on. * @param {string} key The key of the method. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new bound function. * @example * * var object = { * &#39;user&#39;: &#39;fred&#39;, * &#39;greet&#39;: function(greeting, punctuation) { * return greeting + &#39; &#39; + this.user + punctuation; * } * }; * * var bound = _.bindKey(object, &#39;greet&#39;, &#39;hi&#39;); * bound(&#39;!&#39;); * // =&gt; &#39;hi fred!&#39; * * object.greet = function(greeting, punctuation) { * return greeting + &#39;ya &#39; + this.user + punctuation; * }; * * bound(&#39;!&#39;); * // =&gt; &#39;hiya fred!&#39; * * // Bound with placeholders. * var bound = _.bindKey(object, &#39;greet&#39;, _, &#39;!&#39;); * bound(&#39;hi&#39;); * // =&gt; &#39;hiya fred!&#39; */ var bindKey = baseRest(function(object, key, partials) { var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG; if (partials.length) { var holders = replaceHolders(partials, getHolder(bindKey)); bitmask |= WRAP_PARTIAL_FLAG; } return createWrap(key, bitmask, object, partials, holders); }); /** * Creates a function that accepts arguments offuncand either invokes *funcreturning its result, if at leastaritynumber of arguments have * been provided, or returns a function that accepts the remainingfunc* arguments, and so on. The arity offuncmay be specified iffunc.length* is not sufficient. * * The.curry.placeholdervalue, which defaults toin monolithic builds, * may be used as a placeholder for provided arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of curried functions. * * @static * @memberOf _ * @since 2.0.0 * @category Function * @param {Function} func The function to curry. * @param {number} [arity=func.length] The arity offunc. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new curried function. * @example * * var abc = function(a, b, c) { * return [a, b, c]; * }; * * var curried = _.curry(abc); * * curried(1)(2)(3); * // =&gt; [1, 2, 3] * * curried(1, 2)(3); * // =&gt; [1, 2, 3] * * curried(1, 2, 3); * // =&gt; [1, 2, 3] * * // Curried with placeholders. * curried(1)(_, 3)(2); * // =&gt; [1, 2, 3] */ function curry(func, arity, guard) { arity = guard ? undefined : arity; var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity); result.placeholder = curry.placeholder; return result; } /** * This method is like.curryexcept that arguments are applied tofunc* in the manner of.partialRightinstead of.partial. * * The.curryRight.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for provided arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of curried functions. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to curry. * @param {number} [arity=func.length] The arity offunc. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new curried function. * @example * * var abc = function(a, b, c) { * return [a, b, c]; * }; * * var curried = _.curryRight(abc); * * curried(3)(2)(1); * // =&gt; [1, 2, 3] * * curried(2, 3)(1); * // =&gt; [1, 2, 3] * * curried(1, 2, 3); * // =&gt; [1, 2, 3] * * // Curried with placeholders. * curried(3)(1, _)(2); * // =&gt; [1, 2, 3] */ function curryRight(func, arity, guard) { arity = guard ? undefined : arity; var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity); result.placeholder = curryRight.placeholder; return result; } /** * Creates a debounced function that delays invokingfuncuntil afterwait* milliseconds have elapsed since the last time the debounced function was * invoked. The debounced function comes with acancelmethod to cancel * delayedfuncinvocations and aflushmethod to immediately invoke them. * Provideoptionsto indicate whetherfuncshould be invoked on the * leading and/or trailing edge of thewaittimeout. Thefuncis invoked * with the last arguments provided to the debounced function. Subsequent * calls to the debounced function return the result of the lastfunc* invocation. * * **Note:** Ifleadingandtrailingoptions aretrue,funcis * invoked on the trailing edge of the timeout only if the debounced function * is invoked more than once during thewaittimeout. * * Ifwaitis0andleadingisfalse,funcinvocation is deferred * until to the next tick, similar tosetTimeoutwith a timeout of0. * * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between.debounceand.throttle. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to debounce. * @param {number} [wait=0] The number of milliseconds to delay. * @param {Object} [options={}] The options object. * @param {boolean} [options.leading=false] * Specify invoking on the leading edge of the timeout. * @param {number} [options.maxWait] * The maximum timefuncis allowed to be delayed before it&#39;s invoked. * @param {boolean} [options.trailing=true] * Specify invoking on the trailing edge of the timeout. * @returns {Function} Returns the new debounced function. * @example * * // Avoid costly calculations while the window size is in flux. * jQuery(window).on(&#39;resize&#39;, _.debounce(calculateLayout, 150)); * * // InvokesendMailwhen clicked, debouncing subsequent calls. * jQuery(element).on(&#39;click&#39;, _.debounce(sendMail, 300, { * &#39;leading&#39;: true, * &#39;trailing&#39;: false * })); * * // EnsurebatchLogis invoked once after 1 second of debounced calls. * var debounced = _.debounce(batchLog, 250, { &#39;maxWait&#39;: 1000 }); * var source = new EventSource(&#39;/stream&#39;); * jQuery(source).on(&#39;message&#39;, debounced); * * // Cancel the trailing debounced invocation. * jQuery(window).on(&#39;popstate&#39;, debounced.cancel); */ function debounce(func, wait, options) { var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } wait = toNumber(wait) || 0; if (isObject(options)) { leading = !!options.leading; maxing = &#39;maxWait&#39; in options; maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait; trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing; } function invokeFunc(time) { var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; } function leadingEdge(time) { // Reset anymaxWaittimer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; } function remainingWait(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall; return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting; } function shouldInvoke(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&#39;re at the // trailing edge, the system time has gone backwards and we&#39;re treating // it as the trailing edge, or we&#39;ve hit themaxWaitlimit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)); } function timerExpired() { var time = now(); if (shouldInvoke(time)) { return trailingEdge(time); } // Restart the timer. timerId = setTimeout(timerExpired, remainingWait(time)); } function trailingEdge(time) { timerId = undefined; // Only invoke if we havelastArgswhich meansfunchas been // debounced at least once. if (trailing &amp;&amp; lastArgs) { return invokeFunc(time); } lastArgs = lastThis = undefined; return result; } function cancel() { if (timerId !== undefined) { clearTimeout(timerId); } lastInvokeTime = 0; lastArgs = lastCallTime = lastThis = timerId = undefined; } function flush() { return timerId === undefined ? result : trailingEdge(now()); } function debounced() { var time = now(), isInvoking = shouldInvoke(time); lastArgs = arguments; lastThis = this; lastCallTime = time; if (isInvoking) { if (timerId === undefined) { return leadingEdge(lastCallTime); } if (maxing) { // Handle invocations in a tight loop. timerId = setTimeout(timerExpired, wait); return invokeFunc(lastCallTime); } } if (timerId === undefined) { timerId = setTimeout(timerExpired, wait); } return result; } debounced.cancel = cancel; debounced.flush = flush; return debounced; } /** * Defers invoking thefuncuntil the current call stack has cleared. Any * additional arguments are provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to defer. * @param {...*} [args] The arguments to invokefuncwith. * @returns {number} Returns the timer id. * @example * * _.defer(function(text) { * console.log(text); * }, &#39;deferred&#39;); * // =&gt; Logs &#39;deferred&#39; after one millisecond. */ var defer = baseRest(function(func, args) { return baseDelay(func, 1, args); }); /** * Invokesfuncafterwaitmilliseconds. Any additional arguments are * provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to delay. * @param {number} wait The number of milliseconds to delay invocation. * @param {...*} [args] The arguments to invokefuncwith. * @returns {number} Returns the timer id. * @example * * _.delay(function(text) { * console.log(text); * }, 1000, &#39;later&#39;); * // =&gt; Logs &#39;later&#39; after one second. */ var delay = baseRest(function(func, wait, args) { return baseDelay(func, toNumber(wait) || 0, args); }); /** * Creates a function that invokesfuncwith arguments reversed. * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to flip arguments for. * @returns {Function} Returns the new flipped function. * @example * * var flipped = _.flip(function() { * return _.toArray(arguments); * }); * * flipped(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; [&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] */ function flip(func) { return createWrap(func, WRAP_FLIP_FLAG); } /** * Creates a function that memoizes the result offunc. Ifresolveris * provided, it determines the cache key for storing the result based on the * arguments provided to the memoized function. By default, the first argument * provided to the memoized function is used as the map cache key. Thefunc* is invoked with thethisbinding of the memoized function. * * **Note:** The cache is exposed as thecacheproperty on the memoized * function. Its creation may be customized by replacing the_.memoize.Cache* constructor with one whose instances implement the * [Map](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object) * method interface ofclear,delete,get,has, andset. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to have its output memoized. * @param {Function} [resolver] The function to resolve the cache key. * @returns {Function} Returns the new memoized function. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * var other = { &#39;c&#39;: 3, &#39;d&#39;: 4 }; * * var values = _.memoize(_.values); * values(object); * // =&gt; [1, 2] * * values(other); * // =&gt; [3, 4] * * object.a = 2; * values(object); * // =&gt; [1, 2] * * // Modify the result cache. * values.cache.set(object, [&#39;a&#39;, &#39;b&#39;]); * values(object); * // =&gt; [&#39;a&#39;, &#39;b&#39;] * * // Replace_.memoize.Cache. * _.memoize.Cache = WeakMap; */ function memoize(func, resolver) { if (typeof func != &#39;function&#39; || (resolver != null &amp;&amp; typeof resolver != &#39;function&#39;)) { throw new TypeError(FUNC_ERROR_TEXT); } var memoized = function() { var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache; if (cache.has(key)) { return cache.get(key); } var result = func.apply(this, args); memoized.cache = cache.set(key, result) || cache; return result; }; memoized.cache = new (memoize.Cache || MapCache); return memoized; } // ExposeMapCache. memoize.Cache = MapCache; /** * Creates a function that negates the result of the predicatefunc. The *funcpredicate is invoked with thethisbinding and arguments of the * created function. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} predicate The predicate to negate. * @returns {Function} Returns the new negated function. * @example * * function isEven(n) { * return n % 2 == 0; * } * * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven)); * // =&gt; [1, 3, 5] */ function negate(predicate) { if (typeof predicate != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } return function() { var args = arguments; switch (args.length) { case 0: return !predicate.call(this); case 1: return !predicate.call(this, args[0]); case 2: return !predicate.call(this, args[0], args[1]); case 3: return !predicate.call(this, args[0], args[1], args[2]); } return !predicate.apply(this, args); }; } /** * Creates a function that is restricted to invokingfunconce. Repeat calls * to the function return the value of the first invocation. Thefuncis * invoked with thethisbinding and arguments of the created function. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * var initialize = _.once(createApplication); * initialize(); * initialize(); * // =&gt;createApplicationis invoked once */ function once(func) { return before(2, func); } /** * Creates a function that invokesfuncwith its arguments transformed. * * @static * @since 4.0.0 * @memberOf _ * @category Function * @param {Function} func The function to wrap. * @param {...(Function|Function[])} [transforms=[_.identity]] * The argument transforms. * @returns {Function} Returns the new function. * @example * * function doubled(n) { * return n * 2; * } * * function square(n) { * return n * n; * } * * var func = _.overArgs(function(x, y) { * return [x, y]; * }, [square, doubled]); * * func(9, 3); * // =&gt; [81, 6] * * func(10, 5); * // =&gt; [100, 10] */ var overArgs = castRest(function(func, transforms) { transforms = (transforms.length == 1 &amp;&amp; isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee())); var funcsLength = transforms.length; return baseRest(function(args) { var index = -1, length = nativeMin(args.length, funcsLength); while (++index &lt; length) { args[index] = transforms[index].call(this, args[index]); } return apply(func, this, args); }); }); /** * Creates a function that invokesfuncwithpartialsprepended to the * arguments it receives. This method is like.bindexcept it does **not** * alter thethisbinding. * * The.partial.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of partially * applied functions. * * @static * @memberOf _ * @since 0.2.0 * @category Function * @param {Function} func The function to partially apply arguments to. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new partially applied function. * @example * * function greet(greeting, name) { * return greeting + &#39; &#39; + name; * } * * var sayHelloTo = _.partial(greet, &#39;hello&#39;); * sayHelloTo(&#39;fred&#39;); * // =&gt; &#39;hello fred&#39; * * // Partially applied with placeholders. * var greetFred = _.partial(greet, _, &#39;fred&#39;); * greetFred(&#39;hi&#39;); * // =&gt; &#39;hi fred&#39; */ var partial = baseRest(function(func, partials) { var holders = replaceHolders(partials, getHolder(partial)); return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders); }); /** * This method is like.partialexcept that partially applied arguments * are appended to the arguments it receives. * * The.partialRight.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of partially * applied functions. * * @static * @memberOf _ * @since 1.0.0 * @category Function * @param {Function} func The function to partially apply arguments to. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new partially applied function. * @example * * function greet(greeting, name) { * return greeting + &#39; &#39; + name; * } * * var greetFred = _.partialRight(greet, &#39;fred&#39;); * greetFred(&#39;hi&#39;); * // =&gt; &#39;hi fred&#39; * * // Partially applied with placeholders. * var sayHelloTo = _.partialRight(greet, &#39;hello&#39;, _); * sayHelloTo(&#39;fred&#39;); * // =&gt; &#39;hello fred&#39; */ var partialRight = baseRest(function(func, partials) { var holders = replaceHolders(partials, getHolder(partialRight)); return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders); }); /** * Creates a function that invokesfuncwith arguments arranged according * to the specifiedindexeswhere the argument value at the first index is * provided as the first argument, the argument value at the second index is * provided as the second argument, and so on. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to rearrange arguments for. * @param {...(number|number[])} indexes The arranged argument indexes. * @returns {Function} Returns the new function. * @example * * var rearged = _.rearg(function(a, b, c) { * return [a, b, c]; * }, [2, 0, 1]); * * rearged(&#39;b&#39;, &#39;c&#39;, &#39;a&#39;) * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] */ var rearg = flatRest(function(func, indexes) { return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes); }); /** * Creates a function that invokesfuncwith thethisbinding of the * created function and arguments fromstartand beyond provided as * an array. * * **Note:** This method is based on the * [rest parameter](https://mdn.io/rest_parameters). * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to apply a rest parameter to. * @param {number} [start=func.length-1] The start position of the rest parameter. * @returns {Function} Returns the new function. * @example * * var say = _.rest(function(what, names) { * return what + &#39; &#39; + _.initial(names).join(&#39;, &#39;) + * (_.size(names) &gt; 1 ? &#39;, &amp; &#39; : &#39;&#39;) + _.last(names); * }); * * say(&#39;hello&#39;, &#39;fred&#39;, &#39;barney&#39;, &#39;pebbles&#39;); * // =&gt; &#39;hello fred, barney, &amp; pebbles&#39; */ function rest(func, start) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } start = start === undefined ? start : toInteger(start); return baseRest(func, start); } /** * Creates a function that invokesfuncwith thethisbinding of the * create function and an array of arguments much like * [Function#apply](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply). * * **Note:** This method is based on the * [spread operator](https://mdn.io/spread_operator). * * @static * @memberOf _ * @since 3.2.0 * @category Function * @param {Function} func The function to spread arguments over. * @param {number} [start=0] The start position of the spread. * @returns {Function} Returns the new function. * @example * * var say = _.spread(function(who, what) { * return who + &#39; says &#39; + what; * }); * * say([&#39;fred&#39;, &#39;hello&#39;]); * // =&gt; &#39;fred says hello&#39; * * var numbers = Promise.all([ * Promise.resolve(40), * Promise.resolve(36) * ]); * * numbers.then(_.spread(function(x, y) { * return x + y; * })); * // =&gt; a Promise of 76 */ function spread(func, start) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } start = start == null ? 0 : nativeMax(toInteger(start), 0); return baseRest(function(args) { var array = args[start], otherArgs = castSlice(args, 0, start); if (array) { arrayPush(otherArgs, array); } return apply(func, this, otherArgs); }); } /** * Creates a throttled function that only invokesfuncat most once per * everywaitmilliseconds. The throttled function comes with acancel* method to cancel delayedfuncinvocations and aflushmethod to * immediately invoke them. Provideoptionsto indicate whetherfunc* should be invoked on the leading and/or trailing edge of thewait* timeout. Thefuncis invoked with the last arguments provided to the * throttled function. Subsequent calls to the throttled function return the * result of the lastfuncinvocation. * * **Note:** Ifleadingandtrailingoptions aretrue,funcis * invoked on the trailing edge of the timeout only if the throttled function * is invoked more than once during thewaittimeout. * * Ifwaitis0andleadingisfalse,funcinvocation is deferred * until to the next tick, similar tosetTimeoutwith a timeout of0. * * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between.throttleand.debounce. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to throttle. * @param {number} [wait=0] The number of milliseconds to throttle invocations to. * @param {Object} [options={}] The options object. * @param {boolean} [options.leading=true] * Specify invoking on the leading edge of the timeout. * @param {boolean} [options.trailing=true] * Specify invoking on the trailing edge of the timeout. * @returns {Function} Returns the new throttled function. * @example * * // Avoid excessively updating the position while scrolling. * jQuery(window).on(&#39;scroll&#39;, _.throttle(updatePosition, 100)); * * // InvokerenewTokenwhen the click event is fired, but not more than once every 5 minutes. * var throttled = _.throttle(renewToken, 300000, { &#39;trailing&#39;: false }); * jQuery(element).on(&#39;click&#39;, throttled); * * // Cancel the trailing throttled invocation. * jQuery(window).on(&#39;popstate&#39;, throttled.cancel); */ function throttle(func, wait, options) { var leading = true, trailing = true; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } if (isObject(options)) { leading = &#39;leading&#39; in options ? !!options.leading : leading; trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing; } return debounce(func, wait, { &#39;leading&#39;: leading, &#39;maxWait&#39;: wait, &#39;trailing&#39;: trailing }); } /** * Creates a function that accepts up to one argument, ignoring any * additional arguments. * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to cap arguments for. * @returns {Function} Returns the new capped function. * @example * * _.map([&#39;6&#39;, &#39;8&#39;, &#39;10&#39;], _.unary(parseInt)); * // =&gt; [6, 8, 10] */ function unary(func) { return ary(func, 1); } /** * Creates a function that providesvaluetowrapperas its first * argument. Any additional arguments provided to the function are appended * to those provided to thewrapper. The wrapper is invoked with thethis* binding of the created function. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {*} value The value to wrap. * @param {Function} [wrapper=identity] The wrapper function. * @returns {Function} Returns the new function. * @example * * var p = _.wrap(_.escape, function(func, text) { * return &#39;&lt;p&gt;&#39; + func(text) + &#39;&lt;/p&gt;&#39;; * }); * * p(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; &#39;&lt;p&gt;fred, barney, &amp;amp; pebbles&lt;/p&gt;&#39; */ function wrap(value, wrapper) { return partial(castFunction(wrapper), value); } /*------------------------------------------------------------------------*/ /** * Castsvalueas an array if it&#39;s not one. * * @static * @memberOf _ * @since 4.4.0 * @category Lang * @param {*} value The value to inspect. * @returns {Array} Returns the cast array. * @example * * _.castArray(1); * // =&gt; [1] * * _.castArray({ &#39;a&#39;: 1 }); * // =&gt; [{ &#39;a&#39;: 1 }] * * _.castArray(&#39;abc&#39;); * // =&gt; [&#39;abc&#39;] * * _.castArray(null); * // =&gt; [null] * * _.castArray(undefined); * // =&gt; [undefined] * * _.castArray(); * // =&gt; [] * * var array = [1, 2, 3]; * console.log(_.castArray(array) === array); * // =&gt; true */ function castArray() { if (!arguments.length) { return []; } var value = arguments[0]; return isArray(value) ? value : [value]; } /** * Creates a shallow clone ofvalue. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers,Objectobjects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties ofargumentsobjects are cloned * as plain objects. An empty object is returned for uncloneable values such * as error objects, functions, DOM nodes, and WeakMaps. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to clone. * @returns {*} Returns the cloned value. * @see _.cloneDeep * @example * * var objects = [{ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }]; * * var shallow = _.clone(objects); * console.log(shallow[0] === objects[0]); * // =&gt; true */ function clone(value) { return baseClone(value, CLONE_SYMBOLS_FLAG); } /** * This method is like_.cloneexcept that it acceptscustomizerwhich * is invoked to produce the cloned value. Ifcustomizerreturnsundefined, * cloning is handled by the method instead. Thecustomizeris invoked with * up to four arguments; (value [, index|key, object, stack]). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the cloned value. * @see _.cloneDeepWith * @example * * function customizer(value) { * if (_.isElement(value)) { * return value.cloneNode(false); * } * } * * var el = _.cloneWith(document.body, customizer); * * console.log(el === document.body); * // =&gt; false * console.log(el.nodeName); * // =&gt; &#39;BODY&#39; * console.log(el.childNodes.length); * // =&gt; 0 */ function cloneWith(value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseClone(value, CLONE_SYMBOLS_FLAG, customizer); } /** * This method is like_.cloneexcept that it recursively clonesvalue. * * @static * @memberOf _ * @since 1.0.0 * @category Lang * @param {*} value The value to recursively clone. * @returns {*} Returns the deep cloned value. * @see _.clone * @example * * var objects = [{ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }]; * * var deep = _.cloneDeep(objects); * console.log(deep[0] === objects[0]); * // =&gt; false */ function cloneDeep(value) { return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG); } /** * This method is like_.cloneWithexcept that it recursively clonesvalue. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to recursively clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the deep cloned value. * @see _.cloneWith * @example * * function customizer(value) { * if (_.isElement(value)) { * return value.cloneNode(true); * } * } * * var el = _.cloneDeepWith(document.body, customizer); * * console.log(el === document.body); * // =&gt; false * console.log(el.nodeName); * // =&gt; &#39;BODY&#39; * console.log(el.childNodes.length); * // =&gt; 20 */ function cloneDeepWith(value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer); } /** * Checks ifobjectconforms tosourceby invoking the predicate * properties ofsourcewith the corresponding property values ofobject. * * **Note:** This method is equivalent to_.conformswhensourceis * partially applied. * * @static * @memberOf _ * @since 4.14.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property predicates to conform to. * @returns {boolean} Returnstrueifobjectconforms, elsefalse. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * * _.conformsTo(object, { &#39;b&#39;: function(n) { return n &gt; 1; } }); * // =&gt; true * * _.conformsTo(object, { &#39;b&#39;: function(n) { return n &gt; 2; } }); * // =&gt; false */ function conformsTo(object, source) { return source == null || baseConformsTo(object, source, keys(source)); } /** * Performs a * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * comparison between two values to determine if they are equivalent. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * var object = { &#39;a&#39;: 1 }; * var other = { &#39;a&#39;: 1 }; * * _.eq(object, object); * // =&gt; true * * _.eq(object, other); * // =&gt; false * * _.eq(&#39;a&#39;, &#39;a&#39;); * // =&gt; true * * _.eq(&#39;a&#39;, Object(&#39;a&#39;)); * // =&gt; false * * _.eq(NaN, NaN); * // =&gt; true */ function eq(value, other) { return value === other || (value !== value &amp;&amp; other !== other); } /** * Checks ifvalueis greater thanother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis greater thanother, * elsefalse. * @see _.lt * @example * * _.gt(3, 1); * // =&gt; true * * _.gt(3, 3); * // =&gt; false * * _.gt(1, 3); * // =&gt; false */ var gt = createRelationalOperation(baseGt); /** * Checks ifvalueis greater than or equal toother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis greater than or equal to *other, elsefalse. * @see _.lte * @example * * _.gte(3, 1); * // =&gt; true * * _.gte(3, 3); * // =&gt; true * * _.gte(1, 3); * // =&gt; false */ var gte = createRelationalOperation(function(value, other) { return value &gt;= other; }); /** * Checks ifvalueis likely anargumentsobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis anargumentsobject, * elsefalse. * @example * * _.isArguments(function() { return arguments; }()); * // =&gt; true * * _.isArguments([1, 2, 3]); * // =&gt; false */ var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) { return isObjectLike(value) &amp;&amp; hasOwnProperty.call(value, &#39;callee&#39;) &amp;&amp; !propertyIsEnumerable.call(value, &#39;callee&#39;); }; /** * Checks ifvalueis classified as anArrayobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array, elsefalse. * @example * * _.isArray([1, 2, 3]); * // =&gt; true * * _.isArray(document.body.children); * // =&gt; false * * _.isArray(&#39;abc&#39;); * // =&gt; false * * _.isArray(_.noop); * // =&gt; false */ var isArray = Array.isArray; /** * Checks ifvalueis classified as anArrayBufferobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array buffer, elsefalse. * @example * * _.isArrayBuffer(new ArrayBuffer(2)); * // =&gt; true * * _.isArrayBuffer(new Array(2)); * // =&gt; false */ var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer; /** * Checks ifvalueis array-like. A value is considered array-like if it&#39;s * not a function and has avalue.lengththat&#39;s an integer greater than or * equal to0and less than or equal toNumber.MAX_SAFE_INTEGER. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis array-like, elsefalse. * @example * * _.isArrayLike([1, 2, 3]); * // =&gt; true * * _.isArrayLike(document.body.children); * // =&gt; true * * _.isArrayLike(&#39;abc&#39;); * // =&gt; true * * _.isArrayLike(_.noop); * // =&gt; false */ function isArrayLike(value) { return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value); } /** * This method is like_.isArrayLikeexcept that it also checks ifvalue* is an object. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array-like object, * elsefalse. * @example * * _.isArrayLikeObject([1, 2, 3]); * // =&gt; true * * _.isArrayLikeObject(document.body.children); * // =&gt; true * * _.isArrayLikeObject(&#39;abc&#39;); * // =&gt; false * * _.isArrayLikeObject(_.noop); * // =&gt; false */ function isArrayLikeObject(value) { return isObjectLike(value) &amp;&amp; isArrayLike(value); } /** * Checks ifvalueis classified as a boolean primitive or object. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a boolean, elsefalse. * @example * * _.isBoolean(false); * // =&gt; true * * _.isBoolean(null); * // =&gt; false */ function isBoolean(value) { return value === true || value === false || (isObjectLike(value) &amp;&amp; baseGetTag(value) == boolTag); } /** * Checks ifvalueis a buffer. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a buffer, elsefalse. * @example * * _.isBuffer(new Buffer(2)); * // =&gt; true * * _.isBuffer(new Uint8Array(2)); * // =&gt; false */ var isBuffer = nativeIsBuffer || stubFalse; /** * Checks ifvalueis classified as aDateobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a date object, elsefalse. * @example * * _.isDate(new Date); * // =&gt; true * * _.isDate(&#39;Mon April 23 2012&#39;); * // =&gt; false */ var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate; /** * Checks ifvalueis likely a DOM element. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a DOM element, elsefalse. * @example * * _.isElement(document.body); * // =&gt; true * * _.isElement(&#39;&lt;body&gt;&#39;); * // =&gt; false */ function isElement(value) { return isObjectLike(value) &amp;&amp; value.nodeType === 1 &amp;&amp; !isPlainObject(value); } /** * Checks ifvalueis an empty object, collection, map, or set. * * Objects are considered empty if they have no own enumerable string keyed * properties. * * Array-like values such asargumentsobjects, arrays, buffers, strings, or * jQuery-like collections are considered empty if they have alengthof0. * Similarly, maps and sets are considered empty if they have asizeof0. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis empty, elsefalse. * @example * * _.isEmpty(null); * // =&gt; true * * _.isEmpty(true); * // =&gt; true * * _.isEmpty(1); * // =&gt; true * * _.isEmpty([1, 2, 3]); * // =&gt; false * * _.isEmpty({ &#39;a&#39;: 1 }); * // =&gt; false */ function isEmpty(value) { if (value == null) { return true; } if (isArrayLike(value) &amp;&amp; (isArray(value) || typeof value == &#39;string&#39; || typeof value.splice == &#39;function&#39; || isBuffer(value) || isTypedArray(value) || isArguments(value))) { return !value.length; } var tag = getTag(value); if (tag == mapTag || tag == setTag) { return !value.size; } if (isPrototype(value)) { return !baseKeys(value).length; } for (var key in value) { if (hasOwnProperty.call(value, key)) { return false; } } return true; } /** * Performs a deep comparison between two values to determine if they are * equivalent. * * **Note:** This method supports comparing arrays, array buffers, booleans, * date objects, error objects, maps, numbers,Objectobjects, regexes, * sets, strings, symbols, and typed arrays.Objectobjects are compared * by their own, not inherited, enumerable properties. Functions and DOM * nodes are compared by strict equality, i.e.===. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * var object = { &#39;a&#39;: 1 }; * var other = { &#39;a&#39;: 1 }; * * _.isEqual(object, other); * // =&gt; true * * object === other; * // =&gt; false */ function isEqual(value, other) { return baseIsEqual(value, other); } /** * This method is like_.isEqualexcept that it acceptscustomizerwhich * is invoked to compare values. Ifcustomizerreturnsundefined, comparisons * are handled by the method instead. Thecustomizeris invoked with up to * six arguments: (objValue, othValue [, index|key, object, other, stack]). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @param {Function} [customizer] The function to customize comparisons. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * function isGreeting(value) { * return /^h(?:i|ello)$/.test(value); * } * * function customizer(objValue, othValue) { * if (isGreeting(objValue) &amp;&amp; isGreeting(othValue)) { * return true; * } * } * * var array = [&#39;hello&#39;, &#39;goodbye&#39;]; * var other = [&#39;hi&#39;, &#39;goodbye&#39;]; * * _.isEqualWith(array, other, customizer); * // =&gt; true */ function isEqualWith(value, other, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; var result = customizer ? customizer(value, other) : undefined; return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result; } /** * Checks ifvalueis anError,EvalError,RangeError,ReferenceError, *SyntaxError,TypeError, orURIErrorobject. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an error object, elsefalse. * @example * * _.isError(new Error); * // =&gt; true * * _.isError(Error); * // =&gt; false */ function isError(value) { if (!isObjectLike(value)) { return false; } var tag = baseGetTag(value); return tag == errorTag || tag == domExcTag || (typeof value.message == &#39;string&#39; &amp;&amp; typeof value.name == &#39;string&#39; &amp;&amp; !isPlainObject(value)); } /** * Checks ifvalueis a finite primitive number. * * **Note:** This method is based on * [Number.isFinite](https://mdn.io/Number/isFinite). * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a finite number, elsefalse. * @example * * _.isFinite(3); * // =&gt; true * * _.isFinite(Number.MIN_VALUE); * // =&gt; true * * _.isFinite(Infinity); * // =&gt; false * * _.isFinite(&#39;3&#39;); * // =&gt; false */ function isFinite(value) { return typeof value == &#39;number&#39; &amp;&amp; nativeIsFinite(value); } /** * Checks ifvalueis classified as aFunctionobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a function, elsefalse. * @example * * _.isFunction(_); * // =&gt; true * * _.isFunction(/abc/); * // =&gt; false */ function isFunction(value) { if (!isObject(value)) { return false; } // The use ofObject#toStringavoids issues with thetypeofoperator // in Safari 9 which returns &#39;object&#39; for typed arrays and other constructors. var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag; } /** * Checks ifvalueis an integer. * * **Note:** This method is based on * [Number.isInteger](https://mdn.io/Number/isInteger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an integer, elsefalse. * @example * * _.isInteger(3); * // =&gt; true * * _.isInteger(Number.MIN_VALUE); * // =&gt; false * * _.isInteger(Infinity); * // =&gt; false * * _.isInteger(&#39;3&#39;); * // =&gt; false */ function isInteger(value) { return typeof value == &#39;number&#39; &amp;&amp; value == toInteger(value); } /** * Checks ifvalueis a valid array-like length. * * **Note:** This method is loosely based on * [ToLength](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a valid length, elsefalse. * @example * * _.isLength(3); * // =&gt; true * * _.isLength(Number.MIN_VALUE); * // =&gt; false * * _.isLength(Infinity); * // =&gt; false * * _.isLength(&#39;3&#39;); * // =&gt; false */ function isLength(value) { return typeof value == &#39;number&#39; &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER; } /** * Checks ifvalueis the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * ofObject. (e.g. arrays, functions, objects, regexes,new Number(0), andnew String(‘’)) * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an object, elsefalse. * @example * * _.isObject({}); * // =&gt; true * * _.isObject([1, 2, 3]); * // =&gt; true * * _.isObject(_.noop); * // =&gt; true * * _.isObject(null); * // =&gt; false */ function isObject(value) { var type = typeof value; return value != null &amp;&amp; (type == &#39;object&#39; || type == &#39;function&#39;); } /** * Checks ifvalueis object-like. A value is object-like if it&#39;s notnull* and has atypeofresult of &quot;object&quot;. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis object-like, elsefalse. * @example * * _.isObjectLike({}); * // =&gt; true * * _.isObjectLike([1, 2, 3]); * // =&gt; true * * _.isObjectLike(_.noop); * // =&gt; false * * _.isObjectLike(null); * // =&gt; false */ function isObjectLike(value) { return value != null &amp;&amp; typeof value == &#39;object&#39;; } /** * Checks ifvalueis classified as aMapobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a map, elsefalse. * @example * * _.isMap(new Map); * // =&gt; true * * _.isMap(new WeakMap); * // =&gt; false */ var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap; /** * Performs a partial deep comparison betweenobjectandsourceto * determine ifobjectcontains equivalent property values. * * **Note:** This method is equivalent to.matcheswhensourceis * partially applied. * * Partial comparisons will match empty array and empty objectsource* values against any array or object value, respectively. See.isEqual* for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property values to match. * @returns {boolean} Returnstrueifobjectis a match, elsefalse. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * * _.isMatch(object, { &#39;b&#39;: 2 }); * // =&gt; true * * _.isMatch(object, { &#39;b&#39;: 1 }); * // =&gt; false */ function isMatch(object, source) { return object === source || baseIsMatch(object, source, getMatchData(source)); } /** * This method is like_.isMatchexcept that it acceptscustomizerwhich * is invoked to compare values. Ifcustomizerreturnsundefined, comparisons * are handled by the method instead. Thecustomizeris invoked with five * arguments: (objValue, srcValue, index|key, object, source). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property values to match. * @param {Function} [customizer] The function to customize comparisons. * @returns {boolean} Returnstrueifobjectis a match, elsefalse. * @example * * function isGreeting(value) { * return /^h(?:i|ello)$/.test(value); * } * * function customizer(objValue, srcValue) { * if (isGreeting(objValue) &amp;&amp; isGreeting(srcValue)) { * return true; * } * } * * var object = { &#39;greeting&#39;: &#39;hello&#39; }; * var source = { &#39;greeting&#39;: &#39;hi&#39; }; * * _.isMatchWith(object, source, customizer); * // =&gt; true */ function isMatchWith(object, source, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseIsMatch(object, source, getMatchData(source), customizer); } /** * Checks ifvalueisNaN. * * **Note:** This method is based on * [Number.isNaN](https://mdn.io/Number/isNaN) and is not the same as * global [isNaN](https://mdn.io/isNaN) which returnstruefor *undefinedand other non-number values. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} ReturnstrueifvalueisNaN, elsefalse. * @example * * _.isNaN(NaN); * // =&gt; true * * _.isNaN(new Number(NaN)); * // =&gt; true * * isNaN(undefined); * // =&gt; true * * _.isNaN(undefined); * // =&gt; false */ function isNaN(value) { // AnNaNprimitive is the only value that is not equal to itself. // Perform thetoStringTagcheck first to avoid errors with some // ActiveX objects in IE. return isNumber(value) &amp;&amp; value != +value; } /** * Checks ifvalueis a pristine native function. * * **Note:** This method can&#39;t reliably detect native functions in the presence * of the core-js package because core-js circumvents this kind of detection. * Despite multiple requests, the core-js maintainer has made it clear: any * attempt to fix the detection will be obstructed. As a result, we&#39;re left * with little choice but to throw an error. Unfortunately, this also affects * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill), * which rely on core-js. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a native function, * elsefalse. * @example * * _.isNative(Array.prototype.push); * // =&gt; true * * _.isNative(_); * // =&gt; false */ function isNative(value) { if (isMaskable(value)) { throw new Error(CORE_ERROR_TEXT); } return baseIsNative(value); } /** * Checks ifvalueisnull. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueisnull, elsefalse. * @example * * _.isNull(null); * // =&gt; true * * _.isNull(void 0); * // =&gt; false */ function isNull(value) { return value === null; } /** * Checks ifvalueisnullorundefined. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis nullish, elsefalse. * @example * * _.isNil(null); * // =&gt; true * * _.isNil(void 0); * // =&gt; true * * _.isNil(NaN); * // =&gt; false */ function isNil(value) { return value == null; } /** * Checks ifvalueis classified as aNumberprimitive or object. * * **Note:** To excludeInfinity,-Infinity, andNaN, which are * classified as numbers, use the_.isFinitemethod. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a number, elsefalse. * @example * * _.isNumber(3); * // =&gt; true * * _.isNumber(Number.MIN_VALUE); * // =&gt; true * * _.isNumber(Infinity); * // =&gt; true * * _.isNumber(&#39;3&#39;); * // =&gt; false */ function isNumber(value) { return typeof value == &#39;number&#39; || (isObjectLike(value) &amp;&amp; baseGetTag(value) == numberTag); } /** * Checks ifvalueis a plain object, that is, an object created by the *Objectconstructor or one with a[[Prototype]]ofnull. * * @static * @memberOf _ * @since 0.8.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a plain object, elsefalse. * @example * * function Foo() { * this.a = 1; * } * * _.isPlainObject(new Foo); * // =&gt; false * * _.isPlainObject([1, 2, 3]); * // =&gt; false * * _.isPlainObject({ &#39;x&#39;: 0, &#39;y&#39;: 0 }); * // =&gt; true * * _.isPlainObject(Object.create(null)); * // =&gt; true */ function isPlainObject(value) { if (!isObjectLike(value) || baseGetTag(value) != objectTag) { return false; } var proto = getPrototype(value); if (proto === null) { return true; } var Ctor = hasOwnProperty.call(proto, &#39;constructor&#39;) &amp;&amp; proto.constructor; return typeof Ctor == &#39;function&#39; &amp;&amp; Ctor instanceof Ctor &amp;&amp; funcToString.call(Ctor) == objectCtorString; } /** * Checks ifvalueis classified as aRegExpobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a regexp, elsefalse. * @example * * _.isRegExp(/abc/); * // =&gt; true * * _.isRegExp(&#39;/abc/&#39;); * // =&gt; false */ var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp; /** * Checks ifvalueis a safe integer. An integer is safe if it&#39;s an IEEE-754 * double precision number which isn&#39;t the result of a rounded unsafe integer. * * **Note:** This method is based on * [Number.isSafeInteger](https://mdn.io/Number/isSafeInteger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a safe integer, elsefalse. * @example * * _.isSafeInteger(3); * // =&gt; true * * _.isSafeInteger(Number.MIN_VALUE); * // =&gt; false * * _.isSafeInteger(Infinity); * // =&gt; false * * _.isSafeInteger(&#39;3&#39;); * // =&gt; false */ function isSafeInteger(value) { return isInteger(value) &amp;&amp; value &gt;= -MAX_SAFE_INTEGER &amp;&amp; value &lt;= MAX_SAFE_INTEGER; } /** * Checks ifvalueis classified as aSetobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a set, elsefalse. * @example * * _.isSet(new Set); * // =&gt; true * * _.isSet(new WeakSet); * // =&gt; false */ var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet; /** * Checks ifvalueis classified as aStringprimitive or object. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a string, elsefalse. * @example * * _.isString(&#39;abc&#39;); * // =&gt; true * * _.isString(1); * // =&gt; false */ function isString(value) { return typeof value == &#39;string&#39; || (!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag); } /** * Checks ifvalueis classified as aSymbolprimitive or object. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a symbol, elsefalse. * @example * * _.isSymbol(Symbol.iterator); * // =&gt; true * * _.isSymbol(&#39;abc&#39;); * // =&gt; false */ function isSymbol(value) { return typeof value == &#39;symbol&#39; || (isObjectLike(value) &amp;&amp; baseGetTag(value) == symbolTag); } /** * Checks ifvalueis classified as a typed array. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a typed array, elsefalse. * @example * * _.isTypedArray(new Uint8Array); * // =&gt; true * * _.isTypedArray([]); * // =&gt; false */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray; /** * Checks ifvalueisundefined. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueisundefined, elsefalse. * @example * * _.isUndefined(void 0); * // =&gt; true * * _.isUndefined(null); * // =&gt; false */ function isUndefined(value) { return value === undefined; } /** * Checks ifvalueis classified as aWeakMapobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a weak map, elsefalse. * @example * * _.isWeakMap(new WeakMap); * // =&gt; true * * _.isWeakMap(new Map); * // =&gt; false */ function isWeakMap(value) { return isObjectLike(value) &amp;&amp; getTag(value) == weakMapTag; } /** * Checks ifvalueis classified as aWeakSetobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a weak set, elsefalse. * @example * * _.isWeakSet(new WeakSet); * // =&gt; true * * _.isWeakSet(new Set); * // =&gt; false */ function isWeakSet(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == weakSetTag; } /** * Checks ifvalueis less thanother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis less thanother, * elsefalse. * @see _.gt * @example * * _.lt(1, 3); * // =&gt; true * * _.lt(3, 3); * // =&gt; false * * _.lt(3, 1); * // =&gt; false */ var lt = createRelationalOperation(baseLt); /** * Checks ifvalueis less than or equal toother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis less than or equal to *other, elsefalse. * @see _.gte * @example * * _.lte(1, 3); * // =&gt; true * * _.lte(3, 3); * // =&gt; true * * _.lte(3, 1); * // =&gt; false */ var lte = createRelationalOperation(function(value, other) { return value &lt;= other; }); /** * Convertsvalueto an array. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to convert. * @returns {Array} Returns the converted array. * @example * * _.toArray({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; [1, 2] * * _.toArray(&#39;abc&#39;); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] * * _.toArray(1); * // =&gt; [] * * _.toArray(null); * // =&gt; [] */ function toArray(value) { if (!value) { return []; } if (isArrayLike(value)) { return isString(value) ? stringToArray(value) : copyArray(value); } if (symIterator &amp;&amp; value[symIterator]) { return iteratorToArray(value[symIterator]()); } var tag = getTag(value), func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values); return func(value); } /** * Convertsvalueto a finite number. * * @static * @memberOf _ * @since 4.12.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted number. * @example * * _.toFinite(3.2); * // =&gt; 3.2 * * _.toFinite(Number.MIN_VALUE); * // =&gt; 5e-324 * * _.toFinite(Infinity); * // =&gt; 1.7976931348623157e+308 * * _.toFinite(&#39;3.2&#39;); * // =&gt; 3.2 */ function toFinite(value) { if (!value) { return value === 0 ? value : 0; } value = toNumber(value); if (value === INFINITY || value === -INFINITY) { var sign = (value &lt; 0 ? -1 : 1); return sign * MAX_INTEGER; } return value === value ? value : 0; } /** * Convertsvalueto an integer. * * **Note:** This method is loosely based on * [ToInteger](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toInteger(3.2); * // =&gt; 3 * * _.toInteger(Number.MIN_VALUE); * // =&gt; 0 * * _.toInteger(Infinity); * // =&gt; 1.7976931348623157e+308 * * _.toInteger(&#39;3.2&#39;); * // =&gt; 3 */ function toInteger(value) { var result = toFinite(value), remainder = result % 1; return result === result ? (remainder ? result - remainder : result) : 0; } /** * Convertsvalueto an integer suitable for use as the length of an * array-like object. * * **Note:** This method is based on * [ToLength](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toLength(3.2); * // =&gt; 3 * * _.toLength(Number.MIN_VALUE); * // =&gt; 0 * * _.toLength(Infinity); * // =&gt; 4294967295 * * _.toLength(&#39;3.2&#39;); * // =&gt; 3 */ function toLength(value) { return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0; } /** * Convertsvalueto a number. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to process. * @returns {number} Returns the number. * @example * * _.toNumber(3.2); * // =&gt; 3.2 * * _.toNumber(Number.MIN_VALUE); * // =&gt; 5e-324 * * _.toNumber(Infinity); * // =&gt; Infinity * * _.toNumber(&#39;3.2&#39;); * // =&gt; 3.2 */ function toNumber(value) { if (typeof value == &#39;number&#39;) { return value; } if (isSymbol(value)) { return NAN; } if (isObject(value)) { var other = typeof value.valueOf == &#39;function&#39; ? value.valueOf() : value; value = isObject(other) ? (other + &#39;&#39;) : other; } if (typeof value != &#39;string&#39;) { return value === 0 ? value : +value; } value = value.replace(reTrim, &#39;&#39;); var isBinary = reIsBinary.test(value); return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value); } /** * Convertsvalueto a plain object flattening inherited enumerable string * keyed properties ofvalueto own properties of the plain object. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to convert. * @returns {Object} Returns the converted plain object. * @example * * function Foo() { * this.b = 2; * } * * Foo.prototype.c = 3; * * _.assign({ &#39;a&#39;: 1 }, new Foo); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } * * _.assign({ &#39;a&#39;: 1 }, _.toPlainObject(new Foo)); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 } */ function toPlainObject(value) { return copyObject(value, keysIn(value)); } /** * Convertsvalueto a safe integer. A safe integer can be compared and * represented correctly. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toSafeInteger(3.2); * // =&gt; 3 * * _.toSafeInteger(Number.MIN_VALUE); * // =&gt; 0 * * _.toSafeInteger(Infinity); * // =&gt; 9007199254740991 * * _.toSafeInteger(&#39;3.2&#39;); * // =&gt; 3 */ function toSafeInteger(value) { return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : (value === 0 ? value : 0); } /** * Convertsvalueto a string. An empty string is returned fornull* andundefinedvalues. The sign of-0is preserved. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {string} Returns the converted string. * @example * * _.toString(null); * // =&gt; &#39;&#39; * * _.toString(-0); * // =&gt; &#39;-0&#39; * * _.toString([1, 2, 3]); * // =&gt; &#39;1,2,3&#39; */ function toString(value) { return value == null ? &#39;&#39; : baseToString(value); } /*------------------------------------------------------------------------*/ /** * Assigns own enumerable string keyed properties of source objects to the * destination object. Source objects are applied from left to right. * Subsequent sources overwrite property assignments of previous sources. * * **Note:** This method mutatesobjectand is loosely based on * [Object.assign](https://mdn.io/Object/assign). * * @static * @memberOf _ * @since 0.10.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.assignIn * @example * * function Foo() { * this.a = 1; * } * * function Bar() { * this.c = 3; * } * * Foo.prototype.b = 2; * Bar.prototype.d = 4; * * _.assign({ &#39;a&#39;: 0 }, new Foo, new Bar); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ var assign = createAssigner(function(object, source) { if (isPrototype(source) || isArrayLike(source)) { copyObject(source, keys(source), object); return; } for (var key in source) { if (hasOwnProperty.call(source, key)) { assignValue(object, key, source[key]); } } }); /** * This method is like_.assignexcept that it iterates over own and * inherited source properties. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @alias extend * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.assign * @example * * function Foo() { * this.a = 1; * } * * function Bar() { * this.c = 3; * } * * Foo.prototype.b = 2; * Bar.prototype.d = 4; * * _.assignIn({ &#39;a&#39;: 0 }, new Foo, new Bar); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4 } */ var assignIn = createAssigner(function(object, source) { copyObject(source, keysIn(source), object); }); /** * This method is like_.assignInexcept that it acceptscustomizer* which is invoked to produce the assigned values. Ifcustomizerreturns *undefined, assignment is handled by the method instead. Thecustomizer* is invoked with five arguments: (objValue, srcValue, key, object, source). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @alias extendWith * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @see _.assignWith * @example * * function customizer(objValue, srcValue) { * return _.isUndefined(objValue) ? srcValue : objValue; * } * * var defaults = _.partialRight(_.assignInWith, customizer); * * defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var assignInWith = createAssigner(function(object, source, srcIndex, customizer) { copyObject(source, keysIn(source), object, customizer); }); /** * This method is like_.assignexcept that it acceptscustomizer* which is invoked to produce the assigned values. Ifcustomizerreturns *undefined, assignment is handled by the method instead. Thecustomizer* is invoked with five arguments: (objValue, srcValue, key, object, source). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @see _.assignInWith * @example * * function customizer(objValue, srcValue) { * return _.isUndefined(objValue) ? srcValue : objValue; * } * * var defaults = _.partialRight(_.assignWith, customizer); * * defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var assignWith = createAssigner(function(object, source, srcIndex, customizer) { copyObject(source, keys(source), object, customizer); }); /** * Creates an array of values corresponding topathsofobject. * * @static * @memberOf _ * @since 1.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Array} Returns the picked values. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }, 4] }; * * _.at(object, [&#39;a[0].b.c&#39;, &#39;a[1]&#39;]); * // =&gt; [3, 4] */ var at = flatRest(baseAt); /** * Creates an object that inherits from theprototypeobject. If a *propertiesobject is given, its own enumerable string keyed properties * are assigned to the created object. * * @static * @memberOf _ * @since 2.3.0 * @category Object * @param {Object} prototype The object to inherit from. * @param {Object} [properties] The properties to assign to the object. * @returns {Object} Returns the new object. * @example * * function Shape() { * this.x = 0; * this.y = 0; * } * * function Circle() { * Shape.call(this); * } * * Circle.prototype = _.create(Shape.prototype, { * &#39;constructor&#39;: Circle * }); * * var circle = new Circle; * circle instanceof Circle; * // =&gt; true * * circle instanceof Shape; * // =&gt; true */ function create(prototype, properties) { var result = baseCreate(prototype); return properties == null ? result : baseAssign(result, properties); } /** * Assigns own and inherited enumerable string keyed properties of source * objects to the destination object for all destination properties that * resolve toundefined. Source objects are applied from left to right. * Once a property is set, additional values of the same property are ignored. * * **Note:** This method mutatesobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.defaultsDeep * @example * * _.defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var defaults = baseRest(function(object, sources) { object = Object(object); var index = -1; var length = sources.length; var guard = length &gt; 2 ? sources[2] : undefined; if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) { length = 1; } while (++index &lt; length) { var source = sources[index]; var props = keysIn(source); var propsIndex = -1; var propsLength = props.length; while (++propsIndex &lt; propsLength) { var key = props[propsIndex]; var value = object[key]; if (value === undefined || (eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) { object[key] = source[key]; } } } return object; }); /** * This method is like_.defaultsexcept that it recursively assigns * default properties. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 3.10.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.defaults * @example * * _.defaultsDeep({ &#39;a&#39;: { &#39;b&#39;: 2 } }, { &#39;a&#39;: { &#39;b&#39;: 1, &#39;c&#39;: 3 } }); * // =&gt; { &#39;a&#39;: { &#39;b&#39;: 2, &#39;c&#39;: 3 } } */ var defaultsDeep = baseRest(function(args) { args.push(undefined, customDefaultsMerge); return apply(mergeWith, undefined, args); }); /** * This method is like_.findexcept that it returns the key of the first * elementpredicatereturns truthy for instead of the element itself. * * @static * @memberOf _ * @since 1.1.0 * @category Object * @param {Object} object The object to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {string|undefined} Returns the key of the matched element, * elseundefined. * @example * * var users = { * &#39;barney&#39;: { &#39;age&#39;: 36, &#39;active&#39;: true }, * &#39;fred&#39;: { &#39;age&#39;: 40, &#39;active&#39;: false }, * &#39;pebbles&#39;: { &#39;age&#39;: 1, &#39;active&#39;: true } * }; * * _.findKey(users, function(o) { return o.age &lt; 40; }); * // =&gt; &#39;barney&#39; (iteration order is not guaranteed) * * // The_.matchesiteratee shorthand. * _.findKey(users, { &#39;age&#39;: 1, &#39;active&#39;: true }); * // =&gt; &#39;pebbles&#39; * * // The_.matchesPropertyiteratee shorthand. * _.findKey(users, [&#39;active&#39;, false]); * // =&gt; &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.findKey(users, &#39;active&#39;); * // =&gt; &#39;barney&#39; */ function findKey(object, predicate) { return baseFindKey(object, getIteratee(predicate, 3), baseForOwn); } /** * This method is like_.findKeyexcept that it iterates over elements of * a collection in the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {string|undefined} Returns the key of the matched element, * elseundefined. * @example * * var users = { * &#39;barney&#39;: { &#39;age&#39;: 36, &#39;active&#39;: true }, * &#39;fred&#39;: { &#39;age&#39;: 40, &#39;active&#39;: false }, * &#39;pebbles&#39;: { &#39;age&#39;: 1, &#39;active&#39;: true } * }; * * _.findLastKey(users, function(o) { return o.age &lt; 40; }); * // =&gt; returns &#39;pebbles&#39; assuming.findKeyreturns &#39;barney&#39; * * // The.matchesiteratee shorthand. * _.findLastKey(users, { &#39;age&#39;: 36, &#39;active&#39;: true }); * // =&gt; &#39;barney&#39; * * // The_.matchesPropertyiteratee shorthand. * _.findLastKey(users, [&#39;active&#39;, false]); * // =&gt; &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.findLastKey(users, &#39;active&#39;); * // =&gt; &#39;pebbles&#39; */ function findLastKey(object, predicate) { return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight); } /** * Iterates over own and inherited enumerable string keyed properties of an * object and invokesiterateefor each property. The iteratee is invoked * with three arguments: (value, key, object). Iteratee functions may exit * iteration early by explicitly returningfalse. * * @static * @memberOf _ * @since 0.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forInRight * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forIn(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39;, &#39;b&#39;, then &#39;c&#39; (iteration order is not guaranteed). */ function forIn(object, iteratee) { return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn); } /** * This method is like_.forInexcept that it iterates over properties of *objectin the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forIn * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forInRight(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;c&#39;, &#39;b&#39;, then &#39;a&#39; assuming_.forInlogs &#39;a&#39;, &#39;b&#39;, then &#39;c&#39;. */ function forInRight(object, iteratee) { return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn); } /** * Iterates over own enumerable string keyed properties of an object and * invokesiterateefor each property. The iteratee is invoked with three * arguments: (value, key, object). Iteratee functions may exit iteration * early by explicitly returningfalse. * * @static * @memberOf _ * @since 0.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forOwnRight * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forOwn(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39; then &#39;b&#39; (iteration order is not guaranteed). */ function forOwn(object, iteratee) { return object &amp;&amp; baseForOwn(object, getIteratee(iteratee, 3)); } /** * This method is like_.forOwnexcept that it iterates over properties of *objectin the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forOwn * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forOwnRight(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;b&#39; then &#39;a&#39; assuming_.forOwnlogs &#39;a&#39; then &#39;b&#39;. */ function forOwnRight(object, iteratee) { return object &amp;&amp; baseForOwnRight(object, getIteratee(iteratee, 3)); } /** * Creates an array of function property names from own enumerable properties * ofobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to inspect. * @returns {Array} Returns the function names. * @see _.functionsIn * @example * * function Foo() { * this.a = _.constant(&#39;a&#39;); * this.b = _.constant(&#39;b&#39;); * } * * Foo.prototype.c = _.constant(&#39;c&#39;); * * _.functions(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;] */ function functions(object) { return object == null ? [] : baseFunctions(object, keys(object)); } /** * Creates an array of function property names from own and inherited * enumerable properties ofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to inspect. * @returns {Array} Returns the function names. * @see _.functions * @example * * function Foo() { * this.a = _.constant(&#39;a&#39;); * this.b = _.constant(&#39;b&#39;); * } * * Foo.prototype.c = _.constant(&#39;c&#39;); * * _.functionsIn(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] */ function functionsIn(object) { return object == null ? [] : baseFunctions(object, keysIn(object)); } /** * Gets the value atpathofobject. If the resolved value is *undefined, thedefaultValueis returned in its place. * * @static * @memberOf _ * @since 3.7.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the property to get. * @param {*} [defaultValue] The value returned forundefinedresolved values. * @returns {*} Returns the resolved value. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.get(object, &#39;a[0].b.c&#39;); * // =&gt; 3 * * _.get(object, [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;]); * // =&gt; 3 * * _.get(object, &#39;a.b.c&#39;, &#39;default&#39;); * // =&gt; &#39;default&#39; */ function get(object, path, defaultValue) { var result = object == null ? undefined : baseGet(object, path); return result === undefined ? defaultValue : result; } /** * Checks ifpathis a direct property ofobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path to check. * @returns {boolean} Returnstrueifpathexists, elsefalse. * @example * * var object = { &#39;a&#39;: { &#39;b&#39;: 2 } }; * var other = _.create({ &#39;a&#39;: _.create({ &#39;b&#39;: 2 }) }); * * _.has(object, &#39;a&#39;); * // =&gt; true * * _.has(object, &#39;a.b&#39;); * // =&gt; true * * _.has(object, [&#39;a&#39;, &#39;b&#39;]); * // =&gt; true * * _.has(other, &#39;a&#39;); * // =&gt; false */ function has(object, path) { return object != null &amp;&amp; hasPath(object, path, baseHas); } /** * Checks ifpathis a direct or inherited property ofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path to check. * @returns {boolean} Returnstrueifpathexists, elsefalse. * @example * * var object = _.create({ &#39;a&#39;: _.create({ &#39;b&#39;: 2 }) }); * * _.hasIn(object, &#39;a&#39;); * // =&gt; true * * _.hasIn(object, &#39;a.b&#39;); * // =&gt; true * * _.hasIn(object, [&#39;a&#39;, &#39;b&#39;]); * // =&gt; true * * _.hasIn(object, &#39;b&#39;); * // =&gt; false */ function hasIn(object, path) { return object != null &amp;&amp; hasPath(object, path, baseHasIn); } /** * Creates an object composed of the inverted keys and values ofobject. * Ifobjectcontains duplicate values, subsequent values overwrite * property assignments of previous values. * * @static * @memberOf _ * @since 0.7.0 * @category Object * @param {Object} object The object to invert. * @returns {Object} Returns the new inverted object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }; * * _.invert(object); * // =&gt; { &#39;1&#39;: &#39;c&#39;, &#39;2&#39;: &#39;b&#39; } */ var invert = createInverter(function(result, value, key) { if (value != null &amp;&amp; typeof value.toString != &#39;function&#39;) { value = nativeObjectToString.call(value); } result[value] = key; }, constant(identity)); /** * This method is like_.invertexcept that the inverted object is generated * from the results of running each element ofobjectthruiteratee. The * corresponding inverted value of each inverted key is an array of keys * responsible for generating the inverted value. The iteratee is invoked * with one argument: (value). * * @static * @memberOf _ * @since 4.1.0 * @category Object * @param {Object} object The object to invert. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Object} Returns the new inverted object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }; * * _.invertBy(object); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } * * _.invertBy(object, function(value) { * return &#39;group&#39; + value; * }); * // =&gt; { &#39;group1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;group2&#39;: [&#39;b&#39;] } */ var invertBy = createInverter(function(result, value, key) { if (value != null &amp;&amp; typeof value.toString != &#39;function&#39;) { value = nativeObjectToString.call(value); } if (hasOwnProperty.call(result, value)) { result[value].push(key); } else { result[value] = [key]; } }, getIteratee); /** * Invokes the method atpathofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {*} Returns the result of the invoked method. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: [1, 2, 3, 4] } }] }; * * _.invoke(object, &#39;a[0].b.c.slice&#39;, 1, 3); * // =&gt; [2, 3] */ var invoke = baseRest(baseInvoke); /** * Creates an array of the own enumerable property names ofobject. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) * for more details. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keys(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;] (iteration order is not guaranteed) * * _.keys(&#39;hi&#39;); * // =&gt; [&#39;0&#39;, &#39;1&#39;] */ function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object); } /** * Creates an array of the own and inherited enumerable property names ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @memberOf _ * @since 3.0.0 * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keysIn(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] (iteration order is not guaranteed) */ function keysIn(object) { return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object); } /** * The opposite of_.mapValues; this method creates an object with the * same values asobjectand keys generated by running each own enumerable * string keyed property ofobjectthruiteratee. The iteratee is invoked * with three arguments: (value, key, object). * * @static * @memberOf _ * @since 3.8.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returns the new mapped object. * @see _.mapValues * @example * * _.mapKeys({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, function(value, key) { * return key + value; * }); * // =&gt; { &#39;a1&#39;: 1, &#39;b2&#39;: 2 } */ function mapKeys(object, iteratee) { var result = {}; iteratee = getIteratee(iteratee, 3); baseForOwn(object, function(value, key, object) { baseAssignValue(result, iteratee(value, key, object), value); }); return result; } /** * Creates an object with the same keys asobjectand values generated * by running each own enumerable string keyed property ofobjectthru *iteratee. The iteratee is invoked with three arguments: * (value, key, object). * * @static * @memberOf _ * @since 2.4.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returns the new mapped object. * @see _.mapKeys * @example * * var users = { * &#39;fred&#39;: { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * &#39;pebbles&#39;: { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1 } * }; * * _.mapValues(users, function(o) { return o.age; }); * // =&gt; { &#39;fred&#39;: 40, &#39;pebbles&#39;: 1 } (iteration order is not guaranteed) * * // The_.propertyiteratee shorthand. * _.mapValues(users, &#39;age&#39;); * // =&gt; { &#39;fred&#39;: 40, &#39;pebbles&#39;: 1 } (iteration order is not guaranteed) */ function mapValues(object, iteratee) { var result = {}; iteratee = getIteratee(iteratee, 3); baseForOwn(object, function(value, key, object) { baseAssignValue(result, key, iteratee(value, key, object)); }); return result; } /** * This method is like_.assignexcept that it recursively merges own and * inherited enumerable string keyed properties of source objects into the * destination object. Source properties that resolve toundefinedare * skipped if a destination value exists. Array and plain object properties * are merged recursively. Other objects and value types are overridden by * assignment. Source objects are applied from left to right. Subsequent * sources overwrite property assignments of previous sources. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 0.5.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @example * * var object = { * &#39;a&#39;: [{ &#39;b&#39;: 2 }, { &#39;d&#39;: 4 }] * }; * * var other = { * &#39;a&#39;: [{ &#39;c&#39;: 3 }, { &#39;e&#39;: 5 }] * }; * * _.merge(object, other); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: 2, &#39;c&#39;: 3 }, { &#39;d&#39;: 4, &#39;e&#39;: 5 }] } */ var merge = createAssigner(function(object, source, srcIndex) { baseMerge(object, source, srcIndex); }); /** * This method is like_.mergeexcept that it acceptscustomizerwhich * is invoked to produce the merged values of the destination and source * properties. Ifcustomizerreturnsundefined, merging is handled by the * method instead. Thecustomizeris invoked with six arguments: * (objValue, srcValue, key, object, source, stack). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} customizer The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * function customizer(objValue, srcValue) { * if (_.isArray(objValue)) { * return objValue.concat(srcValue); * } * } * * var object = { &#39;a&#39;: [1], &#39;b&#39;: [2] }; * var other = { &#39;a&#39;: [3], &#39;b&#39;: [4] }; * * _.mergeWith(object, other, customizer); * // =&gt; { &#39;a&#39;: [1, 3], &#39;b&#39;: [2, 4] } */ var mergeWith = createAssigner(function(object, source, srcIndex, customizer) { baseMerge(object, source, srcIndex, customizer); }); /** * The opposite of.pick; this method creates an object composed of the * own and inherited enumerable property paths ofobjectthat are not omitted. * * **Note:** This method is considerably slower than.pick. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The source object. * @param {...(string|string[])} [paths] The property paths to omit. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.omit(object, [&#39;a&#39;, &#39;c&#39;]); * // =&gt; { &#39;b&#39;: &#39;2&#39; } */ var omit = flatRest(function(object, paths) { var result = {}; if (object == null) { return result; } var isDeep = false; paths = arrayMap(paths, function(path) { path = castPath(path, object); isDeep || (isDeep = path.length &gt; 1); return path; }); copyObject(object, getAllKeysIn(object), result); if (isDeep) { result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone); } var length = paths.length; while (length--) { baseUnset(result, paths[length]); } return result; }); /** * The opposite of_.pickBy; this method creates an object composed of * the own and inherited enumerable string keyed properties ofobjectthat *predicatedoesn&#39;t return truthy for. The predicate is invoked with two * arguments: (value, key). * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The source object. * @param {Function} [predicate=_.identity] The function invoked per property. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.omitBy(object, _.isNumber); * // =&gt; { &#39;b&#39;: &#39;2&#39; } */ function omitBy(object, predicate) { return pickBy(object, negate(getIteratee(predicate))); } /** * Creates an object composed of the pickedobjectproperties. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The source object. * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.pick(object, [&#39;a&#39;, &#39;c&#39;]); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ var pick = flatRest(function(object, paths) { return object == null ? {} : basePick(object, paths); }); /** * Creates an object composed of theobjectpropertiespredicatereturns * truthy for. The predicate is invoked with two arguments: (value, key). * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The source object. * @param {Function} [predicate=_.identity] The function invoked per property. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.pickBy(object, _.isNumber); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ function pickBy(object, predicate) { if (object == null) { return {}; } var props = arrayMap(getAllKeysIn(object), function(prop) { return [prop]; }); predicate = getIteratee(predicate); return basePickBy(object, props, function(value, path) { return predicate(value, path[0]); }); } /** * This method is like_.getexcept that if the resolved value is a * function it&#39;s invoked with thethisbinding of its parent object and * its result is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the property to resolve. * @param {*} [defaultValue] The value returned forundefinedresolved values. * @returns {*} Returns the resolved value. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c1&#39;: 3, &#39;c2&#39;: _.constant(4) } }] }; * * _.result(object, &#39;a[0].b.c1&#39;); * // =&gt; 3 * * _.result(object, &#39;a[0].b.c2&#39;); * // =&gt; 4 * * _.result(object, &#39;a[0].b.c3&#39;, &#39;default&#39;); * // =&gt; &#39;default&#39; * * _.result(object, &#39;a[0].b.c3&#39;, _.constant(&#39;default&#39;)); * // =&gt; &#39;default&#39; */ function result(object, path, defaultValue) { path = castPath(path, object); var index = -1, length = path.length; // Ensure the loop is entered when path is empty. if (!length) { length = 1; object = undefined; } while (++index &lt; length) { var value = object == null ? undefined : object[toKey(path[index])]; if (value === undefined) { index = length; value = defaultValue; } object = isFunction(value) ? value.call(object) : value; } return object; } /** * Sets the value atpathofobject. If a portion ofpathdoesn&#39;t exist, * it&#39;s created. Arrays are created for missing index properties while objects * are created for all other missing properties. Use_.setWithto customize *pathcreation. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 3.7.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {*} value The value to set. * @returns {Object} Returnsobject. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.set(object, &#39;a[0].b.c&#39;, 4); * console.log(object.a[0].b.c); * // =&gt; 4 * * _.set(object, [&#39;x&#39;, &#39;0&#39;, &#39;y&#39;, &#39;z&#39;], 5); * console.log(object.x[0].y.z); * // =&gt; 5 */ function set(object, path, value) { return object == null ? object : baseSet(object, path, value); } /** * This method is like_.setexcept that it acceptscustomizerwhich is * invoked to produce the objects ofpath. Ifcustomizerreturnsundefined* path creation is handled by the method instead. Thecustomizeris invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {*} value The value to set. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * var object = {}; * * _.setWith(object, &#39;[0][1]&#39;, &#39;a&#39;, Object); * // =&gt; { &#39;0&#39;: { &#39;1&#39;: &#39;a&#39; } } */ function setWith(object, path, value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return object == null ? object : baseSet(object, path, value, customizer); } /** * Creates an array of own enumerable string keyed-value pairs forobject* which can be consumed by_.fromPairs. Ifobjectis a map or set, its * entries are returned. * * @static * @memberOf _ * @since 4.0.0 * @alias entries * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the key-value pairs. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.toPairs(new Foo); * // =&gt; [[&#39;a&#39;, 1], [&#39;b&#39;, 2]] (iteration order is not guaranteed) */ var toPairs = createToPairs(keys); /** * Creates an array of own and inherited enumerable string keyed-value pairs * forobjectwhich can be consumed by_.fromPairs. Ifobjectis a map * or set, its entries are returned. * * @static * @memberOf _ * @since 4.0.0 * @alias entriesIn * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the key-value pairs. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.toPairsIn(new Foo); * // =&gt; [[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]] (iteration order is not guaranteed) */ var toPairsIn = createToPairs(keysIn); /** * An alternative to_.reduce; this method transformsobjectto a new *accumulatorobject which is the result of running each of its own * enumerable string keyed properties thruiteratee, with each invocation * potentially mutating theaccumulatorobject. Ifaccumulatoris not * provided, a new object with the same[[Prototype]]will be used. The * iteratee is invoked with four arguments: (accumulator, value, key, object). * Iteratee functions may exit iteration early by explicitly returningfalse. * * @static * @memberOf _ * @since 1.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The custom accumulator value. * @returns {*} Returns the accumulated value. * @example * * _.transform([2, 3, 4], function(result, n) { * result.push(n *= n); * return n % 2 == 0; * }, []); * // =&gt; [4, 9] * * _.transform({ &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }, function(result, value, key) { * (result[value] || (result[value] = [])).push(key); * }, {}); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } */ function transform(object, iteratee, accumulator) { var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object); iteratee = getIteratee(iteratee, 4); if (accumulator == null) { var Ctor = object &amp;&amp; object.constructor; if (isArrLike) { accumulator = isArr ? new Ctor : []; } else if (isObject(object)) { accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}; } else { accumulator = {}; } } (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) { return iteratee(accumulator, value, index, object); }); return accumulator; } /** * Removes the property atpathofobject. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to unset. * @returns {boolean} Returnstrueif the property is deleted, elsefalse. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 7 } }] }; * _.unset(object, &#39;a[0].b.c&#39;); * // =&gt; true * * console.log(object); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: {} }] }; * * _.unset(object, [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;]); * // =&gt; true * * console.log(object); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: {} }] }; */ function unset(object, path) { return object == null ? true : baseUnset(object, path); } /** * This method is like.setexcept that acceptsupdaterto produce the * value to set. Use.updateWithto customizepathcreation. Theupdater* is invoked with one argument: (value). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.6.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {Function} updater The function to produce the updated value. * @returns {Object} Returnsobject. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.update(object, &#39;a[0].b.c&#39;, function(n) { return n * n; }); * console.log(object.a[0].b.c); * // =&gt; 9 * * _.update(object, &#39;x[0].y.z&#39;, function(n) { return n ? n + 1 : 0; }); * console.log(object.x[0].y.z); * // =&gt; 0 */ function update(object, path, updater) { return object == null ? object : baseUpdate(object, path, castFunction(updater)); } /** * This method is like_.updateexcept that it acceptscustomizerwhich is * invoked to produce the objects ofpath. Ifcustomizerreturnsundefined* path creation is handled by the method instead. Thecustomizeris invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.6.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {Function} updater The function to produce the updated value. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * var object = {}; * * _.updateWith(object, &#39;[0][1]&#39;, _.constant(&#39;a&#39;), Object); * // =&gt; { &#39;0&#39;: { &#39;1&#39;: &#39;a&#39; } } */ function updateWith(object, path, updater, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer); } /** * Creates an array of the own enumerable string keyed property values ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property values. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.values(new Foo); * // =&gt; [1, 2] (iteration order is not guaranteed) * * _.values(&#39;hi&#39;); * // =&gt; [&#39;h&#39;, &#39;i&#39;] */ function values(object) { return object == null ? [] : baseValues(object, keys(object)); } /** * Creates an array of the own and inherited enumerable string keyed property * values ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @memberOf _ * @since 3.0.0 * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property values. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.valuesIn(new Foo); * // =&gt; [1, 2, 3] (iteration order is not guaranteed) */ function valuesIn(object) { return object == null ? [] : baseValues(object, keysIn(object)); } /*------------------------------------------------------------------------*/ /** * Clampsnumberwithin the inclusivelowerandupperbounds. * * @static * @memberOf _ * @since 4.0.0 * @category Number * @param {number} number The number to clamp. * @param {number} [lower] The lower bound. * @param {number} upper The upper bound. * @returns {number} Returns the clamped number. * @example * * _.clamp(-10, -5, 5); * // =&gt; -5 * * _.clamp(10, -5, 5); * // =&gt; 5 */ function clamp(number, lower, upper) { if (upper === undefined) { upper = lower; lower = undefined; } if (upper !== undefined) { upper = toNumber(upper); upper = upper === upper ? upper : 0; } if (lower !== undefined) { lower = toNumber(lower); lower = lower === lower ? lower : 0; } return baseClamp(toNumber(number), lower, upper); } /** * Checks ifnis betweenstartand up to, but not including,end. If *endis not specified, it&#39;s set tostartwithstartthen set to0. * Ifstartis greater thanendthe params are swapped to support * negative ranges. * * @static * @memberOf _ * @since 3.3.0 * @category Number * @param {number} number The number to check. * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @returns {boolean} Returnstrueifnumberis in the range, elsefalse. * @see _.range, _.rangeRight * @example * * _.inRange(3, 2, 4); * // =&gt; true * * _.inRange(4, 8); * // =&gt; true * * _.inRange(4, 2); * // =&gt; false * * _.inRange(2, 2); * // =&gt; false * * _.inRange(1.2, 2); * // =&gt; true * * _.inRange(5.2, 4); * // =&gt; false * * _.inRange(-3, -2, -6); * // =&gt; true */ function inRange(number, start, end) { start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } number = toNumber(number); return baseInRange(number, start, end); } /** * Produces a random number between the inclusivelowerandupperbounds. * If only one argument is provided a number between0and the given number * is returned. Iffloatingistrue, or eitherlowerorupperare * floats, a floating-point number is returned instead of an integer. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @memberOf _ * @since 0.7.0 * @category Number * @param {number} [lower=0] The lower bound. * @param {number} [upper=1] The upper bound. * @param {boolean} [floating] Specify returning a floating-point number. * @returns {number} Returns the random number. * @example * * _.random(0, 5); * // =&gt; an integer between 0 and 5 * * _.random(5); * // =&gt; also an integer between 0 and 5 * * _.random(5, true); * // =&gt; a floating-point number between 0 and 5 * * _.random(1.2, 5.2); * // =&gt; a floating-point number between 1.2 and 5.2 */ function random(lower, upper, floating) { if (floating &amp;&amp; typeof floating != &#39;boolean&#39; &amp;&amp; isIterateeCall(lower, upper, floating)) { upper = floating = undefined; } if (floating === undefined) { if (typeof upper == &#39;boolean&#39;) { floating = upper; upper = undefined; } else if (typeof lower == &#39;boolean&#39;) { floating = lower; lower = undefined; } } if (lower === undefined &amp;&amp; upper === undefined) { lower = 0; upper = 1; } else { lower = toFinite(lower); if (upper === undefined) { upper = lower; lower = 0; } else { upper = toFinite(upper); } } if (lower &gt; upper) { var temp = lower; lower = upper; upper = temp; } if (floating || lower % 1 || upper % 1) { var rand = nativeRandom(); return nativeMin(lower + (rand * (upper - lower + freeParseFloat(&#39;1e-&#39; + ((rand + &#39;&#39;).length - 1)))), upper); } return baseRandom(lower, upper); } /*------------------------------------------------------------------------*/ /** * Convertsstringto [camel case](https://en.wikipedia.org/wiki/CamelCase). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the camel cased string. * @example * * _.camelCase(&#39;Foo Bar&#39;); * // =&gt; &#39;fooBar&#39; * * _.camelCase(&#39;--foo-bar--&#39;); * // =&gt; &#39;fooBar&#39; * * _.camelCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;fooBar&#39; */ var camelCase = createCompounder(function(result, word, index) { word = word.toLowerCase(); return result + (index ? capitalize(word) : word); }); /** * Converts the first character ofstringto upper case and the remaining * to lower case. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to capitalize. * @returns {string} Returns the capitalized string. * @example * * _.capitalize(&#39;FRED&#39;); * // =&gt; &#39;Fred&#39; */ function capitalize(string) { return upperFirst(toString(string).toLowerCase()); } /** * Deburrsstringby converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to deburr. * @returns {string} Returns the deburred string. * @example * * _.deburr(&#39;déjà vu&#39;); * // =&gt; &#39;deja vu&#39; */ function deburr(string) { string = toString(string); return string &amp;&amp; string.replace(reLatin, deburrLetter).replace(reComboMark, &#39;&#39;); } /** * Checks ifstringends with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=string.length] The position to search up to. * @returns {boolean} Returnstrueifstringends withtarget, * elsefalse. * @example * * _.endsWith(&#39;abc&#39;, &#39;c&#39;); * // =&gt; true * * _.endsWith(&#39;abc&#39;, &#39;b&#39;); * // =&gt; false * * _.endsWith(&#39;abc&#39;, &#39;b&#39;, 2); * // =&gt; true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position &gt;= 0 &amp;&amp; string.slice(position, end) == target; } /** * Converts the characters &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &#39;&quot;&#39;, and &quot;&#39;&quot; instringto their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the &quot;&gt;&quot; character is escaped for symmetry, characters like * &quot;&gt;&quot; and &quot;/&quot; don&#39;t need escaping in HTML and have no special meaning * unless they&#39;re part of a tag or unquoted attribute value. See * [Mathias Bynens&#39;s article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under &quot;semi-related fun fact&quot;) for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=&#39;&#39;] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; &#39;fred, barney, &amp;amp; pebbles&#39; */ function escape(string) { string = toString(string); return (string &amp;&amp; reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes theRegExpspecial characters &quot;^&quot;, &quot;$&quot;, &quot;\&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, * &quot;?&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, and &quot;|&quot; instring. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp(&#39;[lodash](https://lodash.com/)&#39;); * // =&gt; &#39;\[lodash\]\(https://lodash\.com/\)&#39; */ function escapeRegExp(string) { string = toString(string); return (string &amp;&amp; reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, &#39;\\$&amp;&#39;) : string; } /** * Convertsstringto * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase(&#39;Foo Bar&#39;); * // =&gt; &#39;foo-bar&#39; * * _.kebabCase(&#39;fooBar&#39;); * // =&gt; &#39;foo-bar&#39; * * _.kebabCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;foo-bar&#39; */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? &#39;-&#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Convertsstring, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase(&#39;--Foo-Bar--&#39;); * // =&gt; &#39;foo bar&#39; * * _.lowerCase(&#39;fooBar&#39;); * // =&gt; &#39;foo bar&#39; * * _.lowerCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;foo bar&#39; */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Converts the first character ofstringto lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst(&#39;Fred&#39;); * // =&gt; &#39;fred&#39; * * _.lowerFirst(&#39;FRED&#39;); * // =&gt; &#39;fRED&#39; */ var lowerFirst = createCaseFirst(&#39;toLowerCase&#39;); /** * Padsstringon the left and right sides if it&#39;s shorter thanlength. * Padding characters are truncated if they can&#39;t be evenly divided bylength. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad(&#39;abc&#39;, 8); * // =&gt; &#39; abc &#39; * * _.pad(&#39;abc&#39;, 8, &#39;_-&#39;); * // =&gt; &#39;_-abc_-_&#39; * * _.pad(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength &gt;= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Padsstringon the right side if it&#39;s shorter thanlength. Padding * characters are truncated if they exceedlength. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd(&#39;abc&#39;, 6); * // =&gt; &#39;abc &#39; * * _.padEnd(&#39;abc&#39;, 6, &#39;_-&#39;); * // =&gt; &#39;abc_-_&#39; * * _.padEnd(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length &amp;&amp; strLength &lt; length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Padsstringon the left side if it&#39;s shorter thanlength. Padding * characters are truncated if they exceedlength. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart(&#39;abc&#39;, 6); * // =&gt; &#39; abc&#39; * * _.padStart(&#39;abc&#39;, 6, &#39;_-&#39;); * // =&gt; &#39;_-_abc&#39; * * _.padStart(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length &amp;&amp; strLength &lt; length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Convertsstringto an integer of the specified radix. Ifradixis *undefinedor0, aradixof10is used unlessvalueis a * hexadecimal, in which case aradixof16is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) ofparseInt. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpretvalueby. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {number} Returns the converted integer. * @example * * _.parseInt(&#39;08&#39;); * // =&gt; 8 * * _.map([&#39;6&#39;, &#39;08&#39;, &#39;10&#39;], _.parseInt); * // =&gt; [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, &#39;&#39;), radix || 0); } /** * Repeats the given stringntimes. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the repeated string. * @example * * _.repeat(&#39;*&#39;, 3); * // =&gt; &#39;***&#39; * * _.repeat(&#39;abc&#39;, 2); * // =&gt; &#39;abcabc&#39; * * _.repeat(&#39;abc&#39;, 0); * // =&gt; &#39;&#39; */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches forpatterninstringwithreplacement. * * **Note:** This method is based on * [String#replace](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace(&#39;Hi Fred&#39;, &#39;Fred&#39;, &#39;Barney&#39;); * // =&gt; &#39;Hi Barney&#39; */ function replace() { var args = arguments, string = toString(args[0]); return args.length &lt; 3 ? string : string.replace(args[1], args[2]); } /** * Convertsstringto * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase(&#39;Foo Bar&#39;); * // =&gt; &#39;foo_bar&#39; * * _.snakeCase(&#39;fooBar&#39;); * // =&gt; &#39;foo_bar&#39; * * _.snakeCase(&#39;--FOO-BAR--&#39;); * // =&gt; &#39;foo_bar&#39; */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? &#39;_&#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Splitsstringbyseparator. * * **Note:** This method is based on * [String#split](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split(&#39;a-b-c&#39;, &#39;-&#39;, 2); * // =&gt; [&#39;a&#39;, &#39;b&#39;] */ function split(string, separator, limit) { if (limit &amp;&amp; typeof limit != &#39;number&#39; &amp;&amp; isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit &gt;&gt;&gt; 0; if (!limit) { return []; } string = toString(string); if (string &amp;&amp; ( typeof separator == &#39;string&#39; || (separator != null &amp;&amp; !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator &amp;&amp; hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Convertsstringto * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase(&#39;--foo-bar--&#39;); * // =&gt; &#39;Foo Bar&#39; * * _.startCase(&#39;fooBar&#39;); * // =&gt; &#39;Foo Bar&#39; * * _.startCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;FOO BAR&#39; */ var startCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + upperFirst(word); }); /** * Checks ifstringstarts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returnstrueifstringstarts withtarget, * elsefalse. * @example * * _.startsWith(&#39;abc&#39;, &#39;a&#39;); * // =&gt; true * * _.startsWith(&#39;abc&#39;, &#39;b&#39;); * // =&gt; false * * _.startsWith(&#39;abc&#39;, &#39;b&#39;, 1); * // =&gt; true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in &quot;interpolate&quot; delimiters, HTML-escape interpolated data properties in * &quot;escape&quot; delimiters, and execute JavaScript in &quot;evaluate&quot; delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over.templateSettingsvalues. * * **Note:** In the development build.templateutilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash&#39;s custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome&#39;s extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=&#39;&#39;] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML &quot;escape&quot; delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The &quot;evaluate&quot; delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The &quot;interpolate&quot; delimiter. * @param {string} [options.sourceURL=&#39;lodash.templateSources[n]&#39;] * The sourceURL of the compiled template. * @param {string} [options.variable=&#39;obj&#39;] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the compiled template function. * @example * * // Use the &quot;interpolate&quot; delimiter to create a compiled template. * var compiled = _.template(&#39;hello &lt;%= user %&gt;!&#39;); * compiled({ &#39;user&#39;: &#39;fred&#39; }); * // =&gt; &#39;hello fred!&#39; * * // Use the HTML &quot;escape&quot; delimiter to escape data property values. * var compiled = _.template(&#39;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&#39;); * compiled({ &#39;value&#39;: &#39;&lt;script&gt;&#39; }); * // =&gt; &#39;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&#39; * * // Use the &quot;evaluate&quot; delimiter to execute JavaScript and generate HTML. * var compiled = _.template(&#39;&lt;% _.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;&#39;); * compiled({ &#39;users&#39;: [&#39;fred&#39;, &#39;barney&#39;] }); * // =&gt; &#39;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#39; * * // Use the internalprintfunction in &quot;evaluate&quot; delimiters. * var compiled = _.template(&#39;&lt;% print(&quot;hello &quot; + user); %&gt;!&#39;); * compiled({ &#39;user&#39;: &#39;barney&#39; }); * // =&gt; &#39;hello barney!&#39; * * // Use the ES template literal delimiter as an &quot;interpolate&quot; delimiter. * // Disable support by replacing the &quot;interpolate&quot; delimiter. * var compiled = _.template(&#39;hello ${ user }!&#39;); * compiled({ &#39;user&#39;: &#39;pebbles&#39; }); * // =&gt; &#39;hello pebbles!&#39; * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(&#39;&lt;%= &quot;\\&lt;%- value %\\&gt;&quot; %&gt;&#39;); * compiled({ &#39;value&#39;: &#39;ignored&#39; }); * // =&gt; &#39;&lt;%- value %&gt;&#39; * * // Use theimportsoption to importjQueryasjq. * var text = &#39;&lt;% jq.each(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;&#39;; * var compiled = _.template(text, { &#39;imports&#39;: { &#39;jq&#39;: jQuery } }); * compiled({ &#39;users&#39;: [&#39;fred&#39;, &#39;barney&#39;] }); * // =&gt; &#39;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#39; * * // Use thesourceURLoption to specify a custom sourceURL for the template. * var compiled = _.template(&#39;hello &lt;%= user %&gt;!&#39;, { &#39;sourceURL&#39;: &#39;/basic/greeting.jst&#39; }); * compiled(data); * // =&gt; Find the source of &quot;greeting.jst&quot; under the Sources tab or Resources panel of the web inspector. * * // Use thevariableoption to ensure a with-statement isn&#39;t used in the compiled template. * var compiled = _.template(&#39;hi &lt;%= data.user %&gt;!&#39;, { &#39;variable&#39;: &#39;data&#39; }); * compiled.source; * // =&gt; function(data) { * // var __t, __p = &#39;&#39;; * // __p += &#39;hi &#39; + ((__t = ( data.user )) == null ? &#39;&#39; : __t) + &#39;!&#39;; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template(&#39;hello !&#39;); * compiled({ &#39;user&#39;: &#39;mustache&#39; }); * // =&gt; &#39;hello mustache!&#39; * * // Use thesourceproperty to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), &#39;jst.js&#39;), &#39;\ * var JST = {\ * &quot;main&quot;: &#39; + _.template(mainText).source + &#39;\ * };\ * &#39;); */ function template(string, options, guard) { // Based on John Resig&#39;stmplimplementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova&#39;s doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard &amp;&amp; isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = &quot;__p += &#39;&quot;; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + &#39;|&#39; + interpolate.source + &#39;|&#39; + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + &#39;|&#39; + (options.evaluate || reNoMatch).source + &#39;|$&#39; , &#39;g&#39;); // Use a sourceURL for easier debugging. var sourceURL = &#39;//# sourceURL=&#39; + (&#39;sourceURL&#39; in options ? options.sourceURL : (&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;) ) + &#39;\n&#39;; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can&#39;t be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += &quot;&#39; +\n__e(&quot; + escapeValue + &quot;) +\n&#39;&quot;; } if (evaluateValue) { isEvaluating = true; source += &quot;&#39;;\n&quot; + evaluateValue + &quot;;\n__p += &#39;&quot;; } if (interpolateValue) { source += &quot;&#39; +\n((__t = (&quot; + interpolateValue + &quot;)) == null ? &#39;&#39; : __t) +\n&#39;&quot;; } index = offset + match.length; // The JS engine embedded in Adobe products needsmatchreturned in // order to produce the correctoffsetvalue. return match; }); source += &quot;&#39;;\n&quot;; // Ifvariableis not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = &#39;with (obj) {\n&#39; + source + &#39;\n}\n&#39;; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, &#39;&#39;) : source) .replace(reEmptyStringMiddle, &#39;$1&#39;) .replace(reEmptyStringTrailing, &#39;$1;&#39;); // Frame code as the function body. source = &#39;function(&#39; + (variable || &#39;obj&#39;) + &#39;) {\n&#39; + (variable ? &#39;&#39; : &#39;obj || (obj = {});\n&#39; ) + &quot;var __t, __p = &#39;&#39;&quot; + (isEscaping ? &#39;, __e = _.escape&#39; : &#39;&#39; ) + (isEvaluating ? &#39;, __j = Array.prototype.join;\n&#39; + &quot;function print() { __p += __j.call(arguments, &#39;&#39;) }\n&quot; : &#39;;\n&#39; ) + source + &#39;return __p\n}&#39;; var result = attempt(function() { return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues); }); // Provide the compiled function&#39;s source by itstoStringmethod or // thesourceproperty as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Convertsstring, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower(&#39;--Foo-Bar--&#39;); * // =&gt; &#39;--foo-bar--&#39; * * _.toLower(&#39;fooBar&#39;); * // =&gt; &#39;foobar&#39; * * _.toLower(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;__foo_bar__&#39; */ function toLower(value) { return toString(value).toLowerCase(); } /** * Convertsstring, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper(&#39;--foo-bar--&#39;); * // =&gt; &#39;--FOO-BAR--&#39; * * _.toUpper(&#39;fooBar&#39;); * // =&gt; &#39;FOOBAR&#39; * * _.toUpper(&#39;__foo_bar__&#39;); * // =&gt; &#39;__FOO_BAR__&#39; */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trim(&#39; abc &#39;); * // =&gt; &#39;abc&#39; * * _.trim(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;abc&#39; * * _.map([&#39; foo &#39;, &#39; bar &#39;], _.trim); * // =&gt; [&#39;foo&#39;, &#39;bar&#39;] */ function trim(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrim, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(&#39;&#39;); } /** * Removes trailing whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(&#39; abc &#39;); * // =&gt; &#39; abc&#39; * * _.trimEnd(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;-_-abc&#39; */ function trimEnd(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrimEnd, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(&#39;&#39;); } /** * Removes leading whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(&#39; abc &#39;); * // =&gt; &#39;abc &#39; * * _.trimStart(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;abc-_-&#39; */ function trimStart(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrimStart, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(&#39;&#39;); } /** * Truncatesstringif it&#39;s longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to &quot;...&quot;. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission=&#39;...&#39;] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;); * // =&gt; &#39;hi-diddly-ho there, neighbo...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;length&#39;: 24, * &#39;separator&#39;: &#39; &#39; * }); * // =&gt; &#39;hi-diddly-ho there,...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;length&#39;: 24, * &#39;separator&#39;: /,? +/ * }); * // =&gt; &#39;hi-diddly-ho there...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;omission&#39;: &#39; [...]&#39; * }); * // =&gt; &#39;hi-diddly-ho there, neig [...]&#39; */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = &#39;separator&#39; in options ? options.separator : separator; length = &#39;length&#39; in options ? toInteger(options.length) : length; omission = &#39;omission&#39; in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length &gt;= strLength) { return string; } var end = length - stringSize(omission); if (end &lt; 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join(&#39;&#39;) : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + &#39;g&#39;); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index &gt; -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of_.escape; this method converts the HTML entities *&amp;,&lt;,&gt;,&quot;, and&#39;instringto * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=&#39;&#39;] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape(&#39;fred, barney, &amp;amp; pebbles&#39;); * // =&gt; &#39;fred, barney, &amp; pebbles&#39; */ function unescape(string) { string = toString(string); return (string &amp;&amp; reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Convertsstring, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase(&#39;--foo-bar&#39;); * // =&gt; &#39;FOO BAR&#39; * * _.upperCase(&#39;fooBar&#39;); * // =&gt; &#39;FOO BAR&#39; * * _.upperCase(&#39;__foo_bar__&#39;); * // =&gt; &#39;FOO BAR&#39; */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + word.toUpperCase(); }); /** * Converts the first character ofstringto upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst(&#39;fred&#39;); * // =&gt; &#39;Fred&#39; * * _.upperFirst(&#39;FRED&#39;); * // =&gt; &#39;FRED&#39; */ var upperFirst = createCaseFirst(&#39;toUpperCase&#39;); /** * Splitsstringinto an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the words ofstring. * @example * * _.words(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; [&#39;fred&#39;, &#39;barney&#39;, &#39;pebbles&#39;] * * _.words(&#39;fred, barney, &amp; pebbles&#39;, /[^, ]+/g); * // =&gt; [&#39;fred&#39;, &#39;barney&#39;, &#39;&amp;&#39;, &#39;pebbles&#39;] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invokefunc, returning either the result or the caught error * object. Any additional arguments are provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invokefuncwith. * @returns {*} Returns thefuncresult or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, &#39;&gt;_&gt;&#39;); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returnsobject. * @example * * var view = { * &#39;label&#39;: &#39;docs&#39;, * &#39;click&#39;: function() { * console.log(&#39;clicked &#39; + this.label); * } * }; * * _.bindAll(view, [&#39;click&#39;]); * jQuery(element).on(&#39;click&#39;, view.click); * // =&gt; Logs &#39;clicked docs&#39; when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates overpairsand invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with thethisbinding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ &#39;a&#39;: 1 }), _.constant(&#39;matches A&#39;)], * [_.conforms({ &#39;b&#39;: _.isNumber }), _.constant(&#39;matches B&#39;)], * [_.stubTrue, _.constant(&#39;no match&#39;)] * ]); * * func({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; &#39;matches A&#39; * * func({ &#39;a&#39;: 0, &#39;b&#39;: 1 }); * // =&gt; &#39;matches B&#39; * * func({ &#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;2&#39; }); * // =&gt; &#39;no match&#39; */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index &lt; length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties ofsourcewith * the corresponding property values of a given object, returningtrueif * all predicates return truthy, elsefalse. * * **Note:** The created function is equivalent to_.conformsTowith *sourcepartially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 2, &#39;b&#39;: 1 }, * { &#39;a&#39;: 1, &#39;b&#39;: 2 } * ]; * * _.filter(objects, _.conforms({ &#39;b&#39;: function(n) { return n &gt; 1; } })); * // =&gt; [{ &#39;a&#39;: 1, &#39;b&#39;: 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returnsvalue. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ &#39;a&#39;: 1 })); * * console.log(objects); * // =&gt; [{ &#39;a&#39;: 1 }, { &#39;a&#39;: 1 }] * * console.log(objects[0] === objects[1]); * // =&gt; true */ function constant(value) { return function() { return value; }; } /** * Checksvalueto determine whether a default value should be returned in * its place. ThedefaultValueis returned ifvalueisNaN,null, * orundefined. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // =&gt; 1 * * _.defaultTo(undefined, 10); * // =&gt; 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with thethisbinding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // =&gt; 9 */ var flow = createFlow(); /** * This method is like_.flowexcept that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // =&gt; 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returnsvalue. * @example * * var object = { &#39;a&#39;: 1 }; * * console.log(_.identity(object) === object); * // =&gt; true */ function identity(value) { return value; } /** * Creates a function that invokesfuncwith the arguments of the created * function. Iffuncis a property name, the created function returns the * property value for a given element. Iffuncis an array or object, the * created function returnstruefor elements that contain the equivalent * source properties, otherwise it returnsfalse. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.filter(users, _.iteratee({ &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true })); * // =&gt; [{ &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }] * * // The_.matchesPropertyiteratee shorthand. * _.filter(users, _.iteratee([&#39;user&#39;, &#39;fred&#39;])); * // =&gt; [{ &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }] * * // The_.propertyiteratee shorthand. * _.map(users, _.iteratee(&#39;user&#39;)); * // =&gt; [&#39;barney&#39;, &#39;fred&#39;] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter([&#39;abc&#39;, &#39;def&#39;], /ef/); * // =&gt; [&#39;def&#39;] */ function iteratee(func) { return baseIteratee(typeof func == &#39;function&#39; ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object andsource, returningtrueif the given object has equivalent * property values, elsefalse. * * **Note:** The created function is equivalent to.isMatchwithsource* partially applied. * * Partial comparisons will match empty array and empty objectsource* values against any array or object value, respectively. See.isEqual* for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 }, * { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } * ]; * * _.filter(objects, _.matches({ &#39;a&#39;: 4, &#39;c&#39;: 6 })); * // =&gt; [{ &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value atpathof a given object tosrcValue, returningtrueif the * object value is equivalent, elsefalse. * * **Note:** Partial comparisons will match empty array and empty object *srcValuevalues against any array or object value, respectively. See *_.isEqualfor a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 }, * { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } * ]; * * _.find(objects, _.matchesProperty(&#39;a&#39;, 4)); * // =&gt; { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method atpathof a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { &#39;a&#39;: { &#39;b&#39;: _.constant(2) } }, * { &#39;a&#39;: { &#39;b&#39;: _.constant(1) } } * ]; * * _.map(objects, _.method(&#39;a.b&#39;)); * // =&gt; [2, 1] * * _.map(objects, _.method([&#39;a&#39;, &#39;b&#39;])); * // =&gt; [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of_.method; this method creates a function that invokes * the method at a given path ofobject. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { &#39;a&#39;: array, &#39;b&#39;: array, &#39;c&#39;: array }; * * _.map([&#39;a[2]&#39;, &#39;c[0]&#39;], _.methodOf(object)); * // =&gt; [2, 0] * * _.map([[&#39;a&#39;, &#39;2&#39;], [&#39;c&#39;, &#39;0&#39;]], _.methodOf(object)); * // =&gt; [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. Ifobjectis a function, then methods * are added to its prototype as well. * * **Note:** Use_.runInContextto create a pristinelodashfunction to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returnsobject. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ &#39;vowels&#39;: vowels }); * _.vowels(&#39;fred&#39;); * // =&gt; [&#39;e&#39;] * * _(&#39;fred&#39;).vowels().value(); * // =&gt; [&#39;e&#39;] * * _.mixin({ &#39;vowels&#39;: vowels }, { &#39;chain&#39;: false }); * _(&#39;fred&#39;).vowels(); * // =&gt; [&#39;e&#39;] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null &amp;&amp; !(isObject(source) &amp;&amp; (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) &amp;&amp; &#39;chain&#39; in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ &#39;func&#39;: func, &#39;args&#39;: arguments, &#39;thisArg&#39;: object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the_variable to its previous value and returns a reference to * thelodashfunction. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns thelodashfunction. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returnsundefined. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // =&gt; [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at indexn. Ifnis negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; &#39;b&#39; * * var func = _.nthArg(-2); * func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; &#39;c&#39; */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokesiterateeswith the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // =&gt; [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of thepredicatesreturn * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func(&#39;1&#39;); * // =&gt; true * * func(null); * // =&gt; false * * func(NaN); * // =&gt; false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of thepredicatesreturn * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func(&#39;1&#39;); * // =&gt; true * * func(null); * // =&gt; true * * func(NaN); * // =&gt; false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value atpathof a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { &#39;a&#39;: { &#39;b&#39;: 2 } }, * { &#39;a&#39;: { &#39;b&#39;: 1 } } * ]; * * _.map(objects, _.property(&#39;a.b&#39;)); * // =&gt; [2, 1] * * _.map(_.sortBy(objects, _.property([&#39;a&#39;, &#39;b&#39;])), &#39;a.b&#39;); * // =&gt; [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of_.property; this method creates a function that returns * the value at a given path ofobject. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { &#39;a&#39;: array, &#39;b&#39;: array, &#39;c&#39;: array }; * * _.map([&#39;a[2]&#39;, &#39;c[0]&#39;], _.propertyOf(object)); * // =&gt; [2, 0] * * _.map([[&#39;a&#39;, &#39;2&#39;], [&#39;c&#39;, &#39;0&#39;]], _.propertyOf(object)); * // =&gt; [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from *startup to, but not including,end. A step of-1is used if a negative *startis specified without anendorstep. Ifendis not specified, * it&#39;s set tostartwithstartthen set to0. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // =&gt; [0, 1, 2, 3] * * _.range(-4); * // =&gt; [0, -1, -2, -3] * * _.range(1, 5); * // =&gt; [1, 2, 3, 4] * * _.range(0, 20, 5); * // =&gt; [0, 5, 10, 15] * * _.range(0, -4, -1); * // =&gt; [0, -1, -2, -3] * * _.range(1, 4, 0); * // =&gt; [1, 1, 1] * * _.range(0); * // =&gt; [] */ var range = createRange(); /** * This method is like_.rangeexcept that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // =&gt; [3, 2, 1, 0] * * _.rangeRight(-4); * // =&gt; [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // =&gt; [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // =&gt; [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // =&gt; [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // =&gt; [1, 1, 1] * * _.rangeRight(0); * // =&gt; [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // =&gt; [[], []] * * console.log(arrays[0] === arrays[1]); * // =&gt; false */ function stubArray() { return []; } /** * This method returnsfalse. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returnsfalse. * @example * * _.times(2, _.stubFalse); * // =&gt; [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // =&gt; [{}, {}] * * console.log(objects[0] === objects[1]); * // =&gt; false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // =&gt; [&#39;&#39;, &#39;&#39;] */ function stubString() { return &#39;&#39;; } /** * This method returnstrue. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returnstrue. * @example * * _.times(2, _.stubTrue); * // =&gt; [true, true] */ function stubTrue() { return true; } /** * Invokes the iterateentimes, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invokeiteratee. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // =&gt; [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;] * * _.times(4, _.constant(0)); * // =&gt; [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n &lt; 1 || n &gt; MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index &lt; n) { iteratee(index); } return result; } /** * Convertsvalueto a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath(&#39;a.b.c&#39;); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] * * _.toPath(&#39;a[0].b.c&#39;); * // =&gt; [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. Ifprefixis given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=&#39;&#39;] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId(&#39;contact_&#39;); * // =&gt; &#39;contact_104&#39; * * _.uniqueId(); * // =&gt; &#39;105&#39; */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // =&gt; 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computesnumberrounded up toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // =&gt; 5 * * _.ceil(6.004, 2); * // =&gt; 6.01 * * _.ceil(6040, -2); * // =&gt; 6100 */ var ceil = createRound(&#39;ceil&#39;); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // =&gt; 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computesnumberrounded down toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // =&gt; 4 * * _.floor(0.046, 2); * // =&gt; 0.04 * * _.floor(4060, -2); * // =&gt; 4000 */ var floor = createRound(&#39;floor&#39;); /** * Computes the maximum value ofarray. Ifarrayis empty or falsey, *undefinedis returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // =&gt; 8 * * _.max([]); * // =&gt; undefined */ function max(array) { return (array &amp;&amp; array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like_.maxexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ &#39;n&#39;: 1 }, { &#39;n&#39;: 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // =&gt; { &#39;n&#39;: 2 } * * // The_.propertyiteratee shorthand. * _.maxBy(objects, &#39;n&#39;); * // =&gt; { &#39;n&#39;: 2 } */ function maxBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values inarray. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // =&gt; 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like_.meanexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ &#39;n&#39;: 4 }, { &#39;n&#39;: 2 }, { &#39;n&#39;: 8 }, { &#39;n&#39;: 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // =&gt; 5 * * // The_.propertyiteratee shorthand. * _.meanBy(objects, &#39;n&#39;); * // =&gt; 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value ofarray. Ifarrayis empty or falsey, *undefinedis returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // =&gt; 2 * * _.min([]); * // =&gt; undefined */ function min(array) { return (array &amp;&amp; array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like_.minexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ &#39;n&#39;: 1 }, { &#39;n&#39;: 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // =&gt; { &#39;n&#39;: 1 } * * // The_.propertyiteratee shorthand. * _.minBy(objects, &#39;n&#39;); * // =&gt; { &#39;n&#39;: 1 } */ function minBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // =&gt; 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computesnumberrounded toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // =&gt; 4 * * _.round(4.006, 2); * // =&gt; 4.01 * * _.round(4060, -2); * // =&gt; 4100 */ var round = createRound(&#39;round&#39;); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // =&gt; 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values inarray. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // =&gt; 20 */ function sum(array) { return (array &amp;&amp; array.length) ? baseSum(array, identity) : 0; } /** * This method is like_.sumexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ &#39;n&#39;: 4 }, { &#39;n&#39;: 2 }, { &#39;n&#39;: 8 }, { &#39;n&#39;: 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // =&gt; 20 * * // The_.propertyiteratee shorthand. * _.sumBy(objects, &#39;n&#39;); * // =&gt; 20 */ function sumBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods tolodash.prototype. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { &#39;chain&#39;: false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach([&#39;bind&#39;, &#39;bindKey&#39;, &#39;curry&#39;, &#39;curryRight&#39;, &#39;partial&#39;, &#39;partialRight&#39;], function(methodName) { lodash[methodName].placeholder = lodash; }); // AddLazyWrappermethods for.dropand.takevariants. arrayEach([&#39;drop&#39;, &#39;take&#39;], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ &amp;&amp; !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ &#39;size&#39;: nativeMin(n, MAX_ARRAY_LENGTH), &#39;type&#39;: methodName + (result.__dir__ &lt; 0 ? &#39;Right&#39; : &#39;&#39;) }); } return result; }; LazyWrapper.prototype[methodName + &#39;Right&#39;] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // AddLazyWrappermethods that accept aniterateevalue. arrayEach([&#39;filter&#39;, &#39;map&#39;, &#39;takeWhile&#39;], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ &#39;iteratee&#39;: getIteratee(iteratee, 3), &#39;type&#39;: type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // AddLazyWrappermethods for.headand.last. arrayEach([&#39;head&#39;, &#39;last&#39;], function(methodName, index) { var takeName = &#39;take&#39; + (index ? &#39;Right&#39; : &#39;&#39;); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // AddLazyWrappermethods for.initialand.tail. arrayEach([&#39;initial&#39;, &#39;tail&#39;], function(methodName, index) { var dropName = &#39;drop&#39; + (index ? &#39;&#39; : &#39;Right&#39;); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == &#39;function&#39;) { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ &amp;&amp; (start &gt; 0 || end &lt; 0)) { return new LazyWrapper(result); } if (start &lt; 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end &lt; 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // AddLazyWrappermethods tolodash.prototype. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? (&#39;take&#39; + (methodName == &#39;last&#39; ? &#39;Right&#39; : &#39;&#39;)) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker &amp;&amp; chainAll) ? result[0] : result; }; if (useLazy &amp;&amp; checkIteratee &amp;&amp; typeof iteratee == &#39;function&#39; &amp;&amp; iteratee.length != 1) { // Avoid lazy use if the iteratee has a &quot;length&quot; value other than1. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped &amp;&amp; !chainAll, onlyLazy = isLazy &amp;&amp; !isHybrid; if (!retUnwrapped &amp;&amp; useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [interceptor], &#39;thisArg&#39;: undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped &amp;&amp; onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // AddArraymethods tolodash.prototype. arrayEach([&#39;pop&#39;, &#39;push&#39;, &#39;shift&#39;, &#39;sort&#39;, &#39;splice&#39;, &#39;unshift&#39;], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? &#39;tap&#39; : &#39;thru&#39;, retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped &amp;&amp; !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + &#39;&#39;), names = realNames[key] || (realNames[key] = []); names.push({ &#39;name&#39;: methodName, &#39;func&#39;: lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ &#39;name&#39;: &#39;wrapper&#39;, &#39;func&#39;: undefined }]; // Add methods toLazyWrapper. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to thelodashwrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use.noConflict` to remove Lodash from the global object. root. = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the “underscore” module. !(WEBPACK_AMD_DEFINE_RESULT = function() { return _; }.call(exports, webpack_require, exports, module), WEBPACK_AMD_DEFINE_RESULT !== undefined &amp;&amp; (module.exports = WEBPACK_AMD_DEFINE_RESULT)); } // Check for exports after define in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = ; // Export for CommonJS support. freeExports. = ; } else { // Export to the global object. root. = _; } }.call(this)); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }()), webpack_require(5)(module)))// }),/ 5 /// (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; }// }),/ 6 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arrSymbol.iterator, _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[“return”]) _i“return”; } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(“Invalid attempt to destructure non-iterable instance”); } }; }(); var _d2 = webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : ‘Prediction probabilities’; _classCallCheck(this, PredictProba); var width = parseInt(svg.style(‘width’)); this.names = class_names; this.names.push(‘Other’); if (class_names.length &lt; 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === ‘’ ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars (bar_height + space_between_bars) + bar_yshift; svg.style(‘height’, this.svg_height + ‘px’); var this_object = this; if (title !== ‘’) { svg.append(‘text’).text(title).attr(‘x’, 20).attr(‘y’, 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) i + bar_yshift; }; var bar = svg.append(“g”); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)Symbol.iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == ‘Other’ &amp;&amp; this.names.length &gt; 20) { color = ‘#5F9EA0’; } var rect = bar.append(“rect”); rect.attr(“x”, bar_x).attr(“y”, bar_y(i)).attr(“height”, bar_height).attr(“width”, x_scale(data[i])).style(“fill”, color); bar.append(“rect”).attr(“x”, bar_x).attr(“y”, bar_y(i)).attr(“height”, bar_height).attr(“width”, bar_width - 1).attr(“fill-opacity”, 0).attr(“stroke”, “black”); var text = bar.append(“text”); text.classed(“prob_text”, true); text.attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”); text = bar.append(“text”); text.attr(“x”, bar_x + x_scale(data[i]) + 5).attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”).text(data[i].toFixed(2)); text = bar.append(“text”); text.attr(“x”, bar_x - 10).attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(names[i]); while (text.node().getBBox()[‘width’] + 1 &gt; class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + ‘…’); if (cur_text === ‘’) { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length &lt;= 6) { return [class_names, predict_proba]; } var class_dict = (0, _lodash.range)(predict_proba.length).map(function (i) { return { ‘name’: class_names[i], ‘prob’: predict_proba[i], ‘i’: i }; }); var sorted = (0, _lodash.sortBy)(class_dict, function (d) { return -d.prob; }); var other = new Set(); (0, _lodash.range)(4, sorted.length).map(function (d) { return other.add(sorted[d].name); }); var other_prob = 0; var ret_probs = []; var ret_names = []; var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = (0, _lodash.range)(sorted.length)Symbol.iterator, _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var d = _step2.value; if (other.has(sorted[d].name)) { other_prob += sorted[d].prob; } else { ret_probs.push(sorted[d].prob); ret_names.push(sorted[d].name); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } ; ret_names.push(“Other”); ret_probs.push(other_prob); return [ret_names, ret_probs]; }; return PredictProba; }(); exports.default = PredictProba;// }),/ 7 /// (function(module, exports, webpack_require__) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _d = webpack_require__(2); var _d2 = _interopRequireDefault(_d); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var PredictedValue = // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictedValue(svg, predicted_value, min_value, max_value) { var title = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : ‘Predicted value’; var log_coords = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style(‘width’)); this.color = _d2.default.scale.category10(); this.color(‘predicted_value’); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 num_digits; var corner_padding = 5.5 num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width 2 - corner_padding 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === ‘’ ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== ‘’) { svg.append(‘text’).text(title).attr(‘x’, 20).attr(‘y’, 20); } var bar_y = bar_yshift; var bar = svg.append(“g”); //filled in bar representing predicted value in range var rect = bar.append(“rect”); rect.attr(“x”, bar_x).attr(“y”, bar_y).attr(“height”, bar_height).attr(“width”, x_scale(width_proportion)).style(“fill”, this.color); //empty box representing range bar.append(“rect”).attr(“x”, bar_x).attr(“y”, bar_y).attr(“height”, bar_height).attr(“width”, x_scale(1)).attr(“fill-opacity”, 0).attr(“stroke”, “black”); var text = bar.append(“text”); text.classed(“prob_text”, true); text.attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”); //text for min value text = bar.append(“text”); text.attr(“x”, bar_x - corner_padding).attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append(“text”); text.attr(“x”, bar_x - corner_padding).attr(“y”, bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(“(min)”); //text for predicted value // console.log(‘bar height: ‘ + bar_height) text = bar.append(“text”); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr(“x”, bar_x + x_scale(width_proportion)).attr(“y”, bar_y + bar_height + v_adjust_predicted_value_text).attr(“fill”, “black”).attr(“text-anchor”, “middle”).style(“font”, “14px tahoma, sans-serif”); //text for max value text = bar.append(“text”); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr(“x”, bar_x + bar_width + corner_padding).attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “begin”).style(“font”, “14px tahoma, sans-serif”); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append(“text”); text.attr(“x”, bar_x + bar_width + corner_padding).attr(“y”, bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr(“fill”, “black”).attr(“text-anchor”, “begin”).style(“font”, “14px tahoma, sans-serif”).text(“(max)”); //readjust svg size // let svg_width = width + 1 h_adjust; // svg.style(‘width’, svg_width + ‘px’); this.svg_height = n_bars bar_height + bar_yshift + 2 text.node().getBBox().height + 10; svg.style(‘height’, this.svg_height + ‘px’); if (log_coords) { console.log(“svg width: “ + svg_width); console.log(“svg height: “ + this.svg_height); console.log(“bar_y: “ + bar_y); console.log(“bar_x: “ + bar_x); console.log(“Min value: “ + min_value); console.log(“Max value: “ + max_value); console.log(“Pred value: “ + predicted_value); } }; exports.default = PredictedValue;/**/ }),/ 8 //***/ (function(module, exports, webpack_require__) { / WEBPACK VAR INJECTION /(function(global) {“use strict”; webpack_require(9); webpack_require(335); webpack_require(336); if (global._babelPolyfill) { throw new Error(“only one instance of babel-polyfill is allowed”); } global._babelPolyfill = true; var DEFINE_PROPERTY = “defineProperty”; function define(O, key, value) { O[key] || ObjectDEFINE_PROPERTY; } define(String.prototype, “padLeft”, “”.padStart); define(String.prototype, “padRight”, “”.padEnd); “pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill”.split(“,”).forEach(function (key) { [][key] &amp;&amp; define(Array, key, Function.call.bind([][key])); }); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))// }),/ 9 /// (function(module, exports, webpack_require) { webpack_require(10); webpack_require(59); webpack_require(60); webpack_require(61); webpack_require(62); webpack_require(64); webpack_require(67); webpack_require(68); webpack_require(69); webpack_require(70); webpack_require(71); webpack_require(72); webpack_require(73); webpack_require(74); webpack_require(75); webpack_require(77); webpack_require(79); webpack_require(81); webpack_require(83); webpack_require(86); webpack_require(87); webpack_require(88); webpack_require(92); webpack_require(94); webpack_require(96); webpack_require(99); webpack_require(100); webpack_require(101); webpack_require(102); webpack_require(104); webpack_require(105); webpack_require(106); webpack_require(107); webpack_require(108); webpack_require(109); webpack_require(110); webpack_require(112); webpack_require(113); webpack_require(114); webpack_require(116); webpack_require(117); webpack_require(118); webpack_require(120); webpack_require(122); webpack_require(123); webpack_require(124); webpack_require(125); webpack_require(126); webpack_require(127); webpack_require(128); webpack_require(129); webpack_require(130); webpack_require(131); webpack_require(132); webpack_require(133); webpack_require(134); webpack_require(139); webpack_require(140); webpack_require(144); webpack_require(145); webpack_require(146); webpack_require(147); webpack_require(149); webpack_require(150); webpack_require(151); webpack_require(152); webpack_require(153); webpack_require(154); webpack_require(155); webpack_require(156); webpack_require(157); webpack_require(158); webpack_require(159); webpack_require(160); webpack_require(161); webpack_require(162); webpack_require(163); webpack_require(165); webpack_require(166); webpack_require(168); webpack_require(169); webpack_require(175); webpack_require(176); webpack_require(178); webpack_require(179); webpack_require(180); webpack_require(184); webpack_require(185); webpack_require(186); webpack_require(187); webpack_require(188); webpack_require(190); webpack_require(191); webpack_require(192); webpack_require(193); webpack_require(196); webpack_require(198); webpack_require(199); webpack_require(200); webpack_require(202); webpack_require(204); webpack_require(206); webpack_require(208); webpack_require(209); webpack_require(210); webpack_require(214); webpack_require(215); webpack_require(216); webpack_require(218); webpack_require(228); webpack_require(232); webpack_require(233); webpack_require(235); webpack_require(236); webpack_require(240); webpack_require(241); webpack_require(243); webpack_require(244); webpack_require(245); webpack_require(246); webpack_require(247); webpack_require(248); webpack_require(249); webpack_require(250); webpack_require(251); webpack_require(252); webpack_require(253); webpack_require(254); webpack_require(255); webpack_require(256); webpack_require(257); webpack_require(258); webpack_require(259); webpack_require(260); webpack_require(261); webpack_require(263); webpack_require(264); webpack_require(265); webpack_require(266); webpack_require(267); webpack_require(269); webpack_require(270); webpack_require(271); webpack_require(273); webpack_require(274); webpack_require(275); webpack_require(276); webpack_require(277); webpack_require(278); webpack_require(279); webpack_require(280); webpack_require(282); webpack_require(283); webpack_require(285); webpack_require(286); webpack_require(287); webpack_require(288); webpack_require(291); webpack_require(292); webpack_require(294); webpack_require(295); webpack_require(296); webpack_require(297); webpack_require(299); webpack_require(300); webpack_require(301); webpack_require(302); webpack_require(303); webpack_require(304); webpack_require(305); webpack_require(306); webpack_require(307); webpack_require(308); webpack_require(310); webpack_require(311); webpack_require(312); webpack_require(313); webpack_require(314); webpack_require(315); webpack_require(316); webpack_require(317); webpack_require(318); webpack_require(319); webpack_require(320); webpack_require(322); webpack_require(323); webpack_require(324); webpack_require(325); webpack_require(326); webpack_require(327); webpack_require(328); webpack_require(329); webpack_require(330); webpack_require(331); webpack_require(332); webpack_require(333); webpack_require(334); module.exports = webpack_require(16);// }),/ 10 /// (function(module, exports, webpack_require) { ‘use strict’; // ECMAScript 6 symbols shim var global = webpack_require(11); var has = webpack_require(12); var DESCRIPTORS = webpack_require(13); var $export = webpack_require(15); var redefine = webpack_require(25); var META = webpack_require(32).KEY; var $fails = webpack_require(14); var shared = webpack_require(28); var setToStringTag = webpack_require(33); var uid = webpack_require(26); var wks = webpack_require(34); var wksExt = webpack_require(35); var wksDefine = webpack_require(36); var enumKeys = webpack_require(37); var isArray = webpack_require(52); var anObject = webpack_require(19); var isObject = webpack_require(20); var toIObject = webpack_require(40); var toPrimitive = webpack_require(23); var createDesc = webpack_require(24); var _create = webpack_require(53); var gOPNExt = webpack_require(56); var $GOPD = webpack_require(58); var $DP = webpack_require(18); var $keys = webpack_require(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON &amp;&amp; $JSON.stringify; var PROTOTYPE = ‘prototype’; var HIDDEN = wks(‘_hidden’); var TO_PRIMITIVE = wks(‘toPrimitive’); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared(‘symbol-registry’); var AllSymbols = shared(‘symbols’); var OPSymbols = shared(‘op-symbols’); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == ‘function’; var QObject = global.QObject; // Don’t use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS &amp;&amp; $fails(function () { return _create(dP({}, ‘a’, { get: function () { return dP(this, ‘a’, { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc &amp;&amp; it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE &amp;&amp; typeof $Symbol.iterator == ‘symbol’ ? function (it) { return typeof it == ‘symbol’; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) &amp;&amp; it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l &gt; i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto &amp;&amp; has(AllSymbols, key) &amp;&amp; !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) &amp;&amp; this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto &amp;&amp; has(AllSymbols, key) &amp;&amp; !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D &amp;&amp; has(AllSymbols, key) &amp;&amp; !(has(it, HIDDEN) &amp;&amp; it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length &gt; i) { if (!has(AllSymbols, key = names[i++]) &amp;&amp; key != HIDDEN &amp;&amp; key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length &gt; i) { if (has(AllSymbols, key = names[i++]) &amp;&amp; (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError(‘Symbol is not a constructor!’); var tag = uid(arguments.length &gt; 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) &amp;&amp; has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS &amp;&amp; setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], ‘toString’, function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; webpack_require(57).f = gOPNExt.f = $getOwnPropertyNames; webpack_require(51).f = $propertyIsEnumerable; webpack_require(50).f = $getOwnPropertySymbols; if (DESCRIPTORS &amp;&amp; !webpack_require(29)) { redefine(ObjectProto, ‘propertyIsEnumerable’, $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 ‘hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables’ ).split(‘,’), j = 0; es6Symbols.length &gt; j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length &gt; k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F !USE_NATIVE, ‘Symbol’, { // 19.4.2.1 Symbol.for(key) ‘for’: function (key) { return has(SymbolRegistry, key += ‘’) ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ‘ is not a symbol!’); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F !USE_NATIVE, ‘Object’, { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON &amp;&amp; $export($export.S + $export.F (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != ‘[null]’ || _stringify({ a: S }) != ‘{}’ || _stringify(Object(S)) != ‘{}’; })), ‘JSON’, { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length &gt; i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) &amp;&amp; it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == ‘function’) value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype@@toPrimitive $Symbol[PROTOTYPE][TO_PRIMITIVE] || webpack_require(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, ‘Symbol’); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, ‘Math’, true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, ‘JSON’, true);// }),/ 11 /// (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != ‘undefined’ &amp;&amp; window.Math == Math ? window : typeof self != ‘undefined’ &amp;&amp; self.Math == Math ? self // eslint-disable-next-line no-new-func : Function(‘return this’)(); if (typeof g == ‘number’) g = global; // eslint-disable-line no-undef// }),/ 12 /// (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); };// }),/ 13 /// (function(module, exports, webpack_require) { // Thank’s IE8 for his funny defineProperty module.exports = !webpack_require(14)(function () { return Object.defineProperty({}, ‘a’, { get: function () { return 7; } }).a != 7; });// }),/ 14 /// (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } };// }),/ 15 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var core = webpack_require(16); var hide = webpack_require(17); var redefine = webpack_require(25); var ctx = webpack_require(30); var PROTOTYPE = ‘prototype’; var $export = function (type, name, source) { var IS_FORCED = type &amp; $export.F; var IS_GLOBAL = type &amp; $export.G; var IS_STATIC = type &amp; $export.S; var IS_PROTO = type &amp; $export.P; var IS_BIND = type &amp; $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED &amp;&amp; target &amp;&amp; target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND &amp;&amp; own ? ctx(out, global) : IS_PROTO &amp;&amp; typeof out == ‘function’ ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type &amp; $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO &amp;&amp; expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for library module.exports = $export;// }),/ 16 /// (function(module, exports) { var core = module.exports = { version: ‘2.6.5’ }; if (typeof e == ‘number’) e = core; // eslint-disable-line no-undef// }),/ 17 /// (function(module, exports, webpack_require) { var dP = webpack_require(18); var createDesc = webpack_require(24); module.exports = webpack_require(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; };// }),/ 18 /// (function(module, exports, webpack_require) { var anObject = webpack_require(19); var IE8_DOM_DEFINE = webpack_require(21); var toPrimitive = webpack_require(23); var dP = Object.defineProperty; exports.f = webpack_require(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { / empty / } if (‘get’ in Attributes || ‘set’ in Attributes) throw TypeError(‘Accessors not supported!’); if (‘value’ in Attributes) O[P] = Attributes.value; return O; };// }),/ 19 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ‘ is not an object!’); return it; };// }),/ 20 /// (function(module, exports) { module.exports = function (it) { return typeof it === ‘object’ ? it !== null : typeof it === ‘function’; };// }),/ 21 /// (function(module, exports, webpack_require) { module.exports = !webpack_require(13) &amp;&amp; !webpack_require(14)(function () { return Object.defineProperty(webpack_require(22)(‘div’), ‘a’, { get: function () { return 7; } }).a != 7; });// }),/ 22 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var document = webpack_require(11).document; // typeof document.createElement is ‘object’ in old IE var is = isObject(document) &amp;&amp; isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; };// }),/ 23 /// (function(module, exports, webpack_require) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = webpack_require(20); // instead of the ES6 spec version, we didn’t implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S &amp;&amp; typeof (fn = it.toString) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; if (!S &amp;&amp; typeof (fn = it.toString) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; throw TypeError(“Can’t convert object to primitive value”); };// }),/ 24 /// (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap &amp; 1), configurable: !(bitmap &amp; 2), writable: !(bitmap &amp; 4), value: value }; };// }),/ 25 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var hide = webpack_require(17); var has = webpack_require(12); var SRC = webpack_require(26)(‘src’); var $toString = webpack_require(27); var TO_STRING = ‘toString’; var TPL = (‘’ + $toString).split(TO_STRING); webpack_require(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == ‘function’; if (isFunction) has(val, ‘name’) || hide(val, ‘name’, key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? ‘’ + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == ‘function’ &amp;&amp; this[SRC] || $toString.call(this); });// }),/ 26 /// (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return ‘Symbol(‘.concat(key === undefined ? ‘’ : key, ‘)_’, (++id + px).toString(36)); };// }),/ 27 /// (function(module, exports, webpack_require) { module.exports = webpack_require(28)(‘native-function-to-string’, Function.toString);// }),/ 28 /// (function(module, exports, webpack_require) { var core = webpack_require(16); var global = webpack_require(11); var SHARED = ‘core-js_shared‘; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })(‘versions’, []).push({ version: core.version, mode: webpack_require(29) ? ‘pure’ : ‘global’, copyright: ‘© 2019 Denis Pushkarev (zloirock.ru)’ });// }),/ 29 /// (function(module, exports) { module.exports = false;// }),/ 30 /// (function(module, exports, webpack_require) { // optional / simple context binding var aFunction = webpack_require(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/ …args /) { return fn.apply(that, arguments); }; };// }),/ 31 /// (function(module, exports) { module.exports = function (it) { if (typeof it != ‘function’) throw TypeError(it + ‘ is not a function!’); return it; };// }),/ 32 /// (function(module, exports, webpack_require) { var META = webpack_require(26)(‘meta’); var isObject = webpack_require(20); var has = webpack_require(12); var setDesc = webpack_require(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !webpack_require(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: ‘O’ + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == ‘symbol’ ? it : (typeof it == ‘string’ ? ‘S’ : ‘P’) + it; if (!has(it, META)) { // can’t set metadata to uncaught frozen object if (!isExtensible(it)) return ‘F’; // not necessary to add metadata if (!create) return ‘E’; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can’t set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE &amp;&amp; meta.NEED &amp;&amp; isExtensible(it) &amp;&amp; !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze };// }),/ 33 /// (function(module, exports, webpack_require) { var def = webpack_require(18).f; var has = webpack_require(12); var TAG = webpack_require(34)(‘toStringTag’); module.exports = function (it, tag, stat) { if (it &amp;&amp; !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); };// }),/ 34 /// (function(module, exports, webpack_require) { var store = webpack_require(28)(‘wks’); var uid = webpack_require(26); var Symbol = webpack_require(11).Symbol; var USE_SYMBOL = typeof Symbol == ‘function’; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL &amp;&amp; Symbol[name] || (USE_SYMBOL ? Symbol : uid)(‘Symbol.’ + name)); }; $exports.store = store;// }),/ 35 /// (function(module, exports, webpack_require) { exports.f = webpack_require(34);// }),/ 36 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var core = webpack_require(16); var LIBRARY = webpack_require(29); var wksExt = webpack_require(35); var defineProperty = webpack_require(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != ‘_’ &amp;&amp; !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); };// }),/ 37 /// (function(module, exports, webpack_require) { // all enumerable object keys, includes symbols var getKeys = webpack_require(38); var gOPS = webpack_require(50); var pIE = webpack_require(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length &gt; i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; };// }),/ 38 /// (function(module, exports, webpack_require) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = webpack_require(39); var enumBugKeys = webpack_require(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); };// }),/ 39 /// (function(module, exports, webpack_require) { var has = webpack_require(12); var toIObject = webpack_require(40); var arrayIndexOf = webpack_require(44)(false); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) &amp;&amp; result.push(key); // Don’t enum bug &amp; hidden keys while (names.length &gt; i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; };// }),/ 40 /// (function(module, exports, webpack_require) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = webpack_require(41); var defined = webpack_require(43); module.exports = function (it) { return IObject(defined(it)); };// }),/ 41 /// (function(module, exports, webpack_require) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = webpack_require(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object(‘z’).propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == ‘String’ ? it.split(‘’) : Object(it); };// }),/ 42 /// (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); };// }),/ 43 /// (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError(“Can’t call method on “ + it); return it; };// }),/ 44 /// (function(module, exports, webpack_require) { // false -&gt; Array#indexOf // true -&gt; Array#includes var toIObject = webpack_require(40); var toLength = webpack_require(45); var toAbsoluteIndex = webpack_require(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES &amp;&amp; el != el) while (length &gt; index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length &gt; index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES &amp;&amp; -1; }; };// }),/ 45 /// (function(module, exports, webpack_require) { // 7.1.15 ToLength var toInteger = webpack_require(46); var min = Math.min; module.exports = function (it) { return it &gt; 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 };// }),/ 46 /// (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it &gt; 0 ? floor : ceil)(it); };// }),/ 47 /// (function(module, exports, webpack_require) { var toInteger = webpack_require(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index &lt; 0 ? max(index + length, 0) : min(index, length); };// }),/ 48 /// (function(module, exports, webpack_require) { var shared = webpack_require(28)(‘keys’); var uid = webpack_require(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); };// }),/ 49 /// (function(module, exports) { // IE 8- don’t enum bug keys module.exports = ( ‘constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf’ ).split(‘,’);// }),/ 50 /// (function(module, exports) { exports.f = Object.getOwnPropertySymbols;// }),/ 51 /// (function(module, exports) { exports.f = {}.propertyIsEnumerable;// }),/ 52 /// (function(module, exports, webpack_require) { // 7.2.2 IsArray(argument) var cof = webpack_require(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == ‘Array’; };// }),/ 53 /// (function(module, exports, webpack_require) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = webpack_require(19); var dPs = webpack_require(54); var enumBugKeys = webpack_require(49); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); var Empty = function () { / empty / }; var PROTOTYPE = ‘prototype’; // Create object with fake null prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = webpack_require(22)(‘iframe’); var i = enumBugKeys.length; var lt = ‘&lt;’; var gt = ‘&gt;’; var iframeDocument; iframe.style.display = ‘none’; webpack_require(55).appendChild(iframe); iframe.src = ‘javascript:’; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + ‘script’ + gt + ‘document.F=Object’ + lt + ‘/script’ + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i–) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add “proto“ for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); };// }),/ 54 /// (function(module, exports, webpack_require) { var dP = webpack_require(18); var anObject = webpack_require(19); var getKeys = webpack_require(38); module.exports = webpack_require(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length &gt; i) dP.f(O, P = keys[i++], Properties[P]); return O; };// }),/ 55 /// (function(module, exports, webpack_require) { var document = webpack_require(11).document; module.exports = document &amp;&amp; document.documentElement;// }),/ 56 /// (function(module, exports, webpack_require) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = webpack_require(40); var gOPN = webpack_require(57).f; var toString = {}.toString; var windowNames = typeof window == ‘object’ &amp;&amp; window &amp;&amp; Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames &amp;&amp; toString.call(it) == ‘[object Window]’ ? getWindowNames(it) : gOPN(toIObject(it)); };// }),/ 57 /// (function(module, exports, webpack_require) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = webpack_require(39); var hiddenKeys = webpack_require(49).concat(‘length’, ‘prototype’); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); };// }),/ 58 /// (function(module, exports, webpack_require) { var pIE = webpack_require(51); var createDesc = webpack_require(24); var toIObject = webpack_require(40); var toPrimitive = webpack_require(23); var has = webpack_require(12); var IE8_DOM_DEFINE = webpack_require(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = webpack_require(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { / empty / } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); };// }),/ 59 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, ‘Object’, { create: webpack_require(53) });// }),/ 60 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F !webpack_require(13), ‘Object’, { defineProperty: webpack_require(18).f });/**/ }),/ 61 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F !webpack_require(13), ‘Object’, { defineProperties: webpack_require(54) });/*/ }),/ 62 /// (function(module, exports, webpack_require) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = webpack_require(40); var $getOwnPropertyDescriptor = webpack_require(58).f; webpack_require(63)(‘getOwnPropertyDescriptor’, function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; });// }),/ 63 /// (function(module, exports, webpack_require) { // most Object methods by ES6 should accept primitives var $export = webpack_require(15); var core = webpack_require(16); var fails = webpack_require(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F fails(function () { fn(1); }), ‘Object’, exp); };/*/ }),/ 64 /// (function(module, exports, webpack_require) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = webpack_require(65); var $getPrototypeOf = webpack_require(66); webpack_require(63)(‘getPrototypeOf’, function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; });// }),/ 65 /// (function(module, exports, webpack_require) { // 7.1.13 ToObject(argument) var defined = webpack_require(43); module.exports = function (it) { return Object(defined(it)); };// }),/ 66 /// (function(module, exports, webpack_require) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = webpack_require(12); var toObject = webpack_require(65); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == ‘function’ &amp;&amp; O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; };// }),/ 67 /// (function(module, exports, webpack_require) { // 19.1.2.14 Object.keys(O) var toObject = webpack_require(65); var $keys = webpack_require(38); webpack_require(63)(‘keys’, function () { return function keys(it) { return $keys(toObject(it)); }; });// }),/ 68 /// (function(module, exports, webpack_require) { // 19.1.2.7 Object.getOwnPropertyNames(O) webpack_require(63)(‘getOwnPropertyNames’, function () { return webpack_require(56).f; });// }),/ 69 /// (function(module, exports, webpack_require) { // 19.1.2.5 Object.freeze(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘freeze’, function ($freeze) { return function freeze(it) { return $freeze &amp;&amp; isObject(it) ? $freeze(meta(it)) : it; }; });// }),/ 70 /// (function(module, exports, webpack_require) { // 19.1.2.17 Object.seal(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘seal’, function ($seal) { return function seal(it) { return $seal &amp;&amp; isObject(it) ? $seal(meta(it)) : it; }; });// }),/ 71 /// (function(module, exports, webpack_require) { // 19.1.2.15 Object.preventExtensions(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘preventExtensions’, function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions &amp;&amp; isObject(it) ? $preventExtensions(meta(it)) : it; }; });// }),/ 72 /// (function(module, exports, webpack_require) { // 19.1.2.12 Object.isFrozen(O) var isObject = webpack_require(20); webpack_require(63)(‘isFrozen’, function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; });// }),/ 73 /// (function(module, exports, webpack_require) { // 19.1.2.13 Object.isSealed(O) var isObject = webpack_require(20); webpack_require(63)(‘isSealed’, function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; });// }),/ 74 /// (function(module, exports, webpack_require) { // 19.1.2.11 Object.isExtensible(O) var isObject = webpack_require(20); webpack_require(63)(‘isExtensible’, function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; });// }),/ 75 /// (function(module, exports, webpack_require) { // 19.1.3.1 Object.assign(target, source) var $export = webpack_require(15); $export($export.S + $export.F, ‘Object’, { assign: webpack_require(76) });// }),/ 76 /// (function(module, exports, webpack_require) { ‘use strict’; // 19.1.2.1 Object.assign(target, source, …) var getKeys = webpack_require(38); var gOPS = webpack_require(50); var pIE = webpack_require(51); var toObject = webpack_require(65); var IObject = webpack_require(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || webpack_require(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = ‘abcdefghijklmnopqrst’; A[S] = 7; K.split(‘’).forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join(‘’) != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen &gt; index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length &gt; j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign;// }),/ 77 /// (function(module, exports, webpack_require) { // 19.1.3.10 Object.is(value1, value2) var $export = webpack_require(15); $export($export.S, ‘Object’, { is: webpack_require(78) });// }),/ 78 /// (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x &amp;&amp; y != y; };// }),/ 79 /// (function(module, exports, webpack_require) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = webpack_require(15); $export($export.S, ‘Object’, { setPrototypeOf: webpack_require(80).set });// }),/ 80 /// (function(module, exports, webpack_require) { // Works with proto only. Old v8 can’t work with null proto objects. / eslint-disable no-proto / var isObject = webpack_require(20); var anObject = webpack_require(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) &amp;&amp; proto !== null) throw TypeError(proto + “: can’t set as prototype!”); }; module.exports = { set: Object.setPrototypeOf || (‘proto‘ in {} ? // eslint-disable-line function (test, buggy, set) { try { set = webpack_require(30)(Function.call, webpack_require(58).f(Object.prototype, ‘proto‘).set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.proto = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check };// }),/ 81 /// (function(module, exports, webpack_require) { ‘use strict’; // 19.1.3.6 Object.prototype.toString() var classof = webpack_require(82); var test = {}; test[webpack_require(34)(‘toStringTag’)] = ‘z’; if (test + ‘’ != ‘[object z]’) { webpack_require(25)(Object.prototype, ‘toString’, function toString() { return ‘[object ‘ + classof(this) + ‘]’; }, true); }// }),/ 82 /// (function(module, exports, webpack_require) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = webpack_require(42); var TAG = webpack_require(34)(‘toStringTag’); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == ‘Arguments’; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { / empty / } }; module.exports = function (it) { var O, T, B; return it === undefined ? ‘Undefined’ : it === null ? ‘Null’ // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == ‘string’ ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == ‘Object’ &amp;&amp; typeof O.callee == ‘function’ ? ‘Arguments’ : B; };// }),/ 83 /// (function(module, exports, webpack_require) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args…) var $export = webpack_require(15); $export($export.P, ‘Function’, { bind: webpack_require(84) });// }),/ 84 /// (function(module, exports, webpack_require) { ‘use strict’; var aFunction = webpack_require(31); var isObject = webpack_require(20); var invoke = webpack_require(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i &lt; len; i++) n[i] = ‘a[‘ + i + ‘]’; // eslint-disable-next-line no-new-func factories[len] = Function(‘F,a’, ‘return new F(‘ + n.join(‘,’) + ‘)’); } return factorieslen; }; module.exports = Function.bind || function bind(that / , …args /) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/ args… /) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; };// }),/ 85 /// (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); };// }),/ 86 /// (function(module, exports, webpack_require) { var dP = webpack_require(18).f; var FProto = Function.prototype; var nameRE = /^\sfunction ([^ (])/; var NAME = ‘name’; // 19.2.4.2 name NAME in FProto || webpack_require(13) &amp;&amp; dP(FProto, NAME, { configurable: true, get: function () { try { return (‘’ + this).match(nameRE)[1]; } catch (e) { return ‘’; } } });// }),/ 87 /// (function(module, exports, webpack_require) { ‘use strict’; var isObject = webpack_require(20); var getPrototypeOf = webpack_require(66); var HAS_INSTANCE = webpack_require(34)(‘hasInstance’); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype@@hasInstance if (!(HAS_INSTANCE in FunctionProto)) webpack_require(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != ‘function’ || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native @@hasInstance logic enough instanceof, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } });// }),/ 88 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseInt = webpack_require(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F (parseInt != $parseInt), { parseInt: $parseInt });/*/ }),/ 89 /// (function(module, exports, webpack_require) { var $parseInt = webpack_require(11).parseInt; var $trim = webpack_require(90).trim; var ws = webpack_require(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + ‘08’) !== 8 || $parseInt(ws + ‘0x16’) !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix &gt;&gt;&gt; 0) || (hex.test(string) ? 16 : 10)); } : $parseInt;// }),/ 90 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var defined = webpack_require(43); var fails = webpack_require(14); var spaces = webpack_require(91); var space = ‘[‘ + spaces + ‘]’; var non = ‘\u200b\u0085’; var ltrim = RegExp(‘^’ + space + space + ‘‘); var rtrim = RegExp(space + space + ‘$’); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spacesKEY || nonKEY != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F FORCE, ‘String’, exp); }; // 1 -&gt; String#trimLeft // 2 -&gt; String#trimRight // 3 -&gt; String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE &amp; 1) string = string.replace(ltrim, ‘’); if (TYPE &amp; 2) string = string.replace(rtrim, ‘’); return string; }; module.exports = exporter;/*/ }),/ 91 /// (function(module, exports) { module.exports = ‘\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003’ + ‘\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF’;// }),/ 92 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseFloat = webpack_require(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F (parseFloat != $parseFloat), { parseFloat: $parseFloat });/*/ }),/ 93 /// (function(module, exports, webpack_require) { var $parseFloat = webpack_require(11).parseFloat; var $trim = webpack_require(90).trim; module.exports = 1 / $parseFloat(webpack_require(91) + ‘-0’) !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 &amp;&amp; string.charAt(0) == ‘-‘ ? -0 : result; } : $parseFloat;// }),/ 94 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var has = webpack_require(12); var cof = webpack_require(42); var inheritIfRequired = webpack_require(95); var toPrimitive = webpack_require(23); var fails = webpack_require(14); var gOPN = webpack_require(57).f; var gOPD = webpack_require(58).f; var dP = webpack_require(18).f; var $trim = webpack_require(90).trim; var NUMBER = ‘Number’; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(webpack_require(53)(proto)) == NUMBER; var TRIM = ‘trim’ in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == ‘string’ &amp;&amp; it.length &gt; 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number(‘+0x1’) should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i &lt; l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code &lt; 48 || code &gt; maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(‘ 0o1’) || !$Number(‘0b1’) || $Number(‘+0x1’)) { $Number = function Number(value) { var it = arguments.length &lt; 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case &amp;&amp; (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = webpack_require(13) ? gOPN(Base) : ( // ES3: ‘MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,’ + // ES6 (in case, if modules with ES6 Number statics required before): ‘EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,’ + ‘MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger’ ).split(‘,’), j = 0, key; keys.length &gt; j; j++) { if (has(Base, key = keys[j]) &amp;&amp; !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; webpack_require(25)(global, NUMBER, $Number); }// }),/ 95 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var setPrototypeOf = webpack_require(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C &amp;&amp; typeof S == ‘function’ &amp;&amp; (P = S.prototype) !== C.prototype &amp;&amp; isObject(P) &amp;&amp; setPrototypeOf) { setPrototypeOf(that, P); } return that; };// }),/ 96 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toInteger = webpack_require(46); var aNumberValue = webpack_require(97); var repeat = webpack_require(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = ‘Number.toFixed: incorrect invocation!’; var ZERO = ‘0’; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i &lt; 6) { c2 += n data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (–i &gt;= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) 1e7; } }; var numToString = function () { var i = 6; var s = ‘’; while (–i &gt;= 0) { if (s !== ‘’ || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === ‘’ ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc x) : pow(x x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 &gt;= 4096) { n += 12; x2 /= 4096; } while (x2 &gt;= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F (!!$toFixed &amp;&amp; ( 0.00008.toFixed(3) !== ‘0.000’ || 0.9.toFixed(0) !== ‘1’ || 1.255.toFixed(2) !== ‘1.25’ || 1000000000000000128.0.toFixed(0) !== ‘1000000000000000128’ ) || !webpack_require(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), ‘Number’, { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ‘’; var m = ZERO; var e, z, j, k; if (f &lt; 0 || f &gt; 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return ‘NaN’; if (x &lt;= -1e21 || x &gt;= 1e21) return String(x); if (x &lt; 0) { s = ‘-‘; x = -x; } if (x &gt; 1e-21) { e = log(x pow(2, 69, 1)) - 69; z = e &lt; 0 ? x pow(2, -e, 1) : x / pow(2, e, 1); z = 0x10000000000000; e = 52 - e; if (e &gt; 0) { multiply(0, z); j = f; while (j &gt;= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j &gt;= 23) { divide(1 &lt;&lt; 23); j -= 23; } divide(1 &lt;&lt; j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 &lt;&lt; -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f &gt; 0) { k = m.length; m = s + (k &lt;= f ? ‘0.’ + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + ‘.’ + m.slice(k - f)); } else { m = s + m; } return m; } });// }),/ 97 /// (function(module, exports, webpack_require) { var cof = webpack_require(42); module.exports = function (it, msg) { if (typeof it != ‘number’ &amp;&amp; cof(it) != ‘Number’) throw TypeError(msg); return +it; };// }),/ 98 /// (function(module, exports, webpack_require) { ‘use strict’; var toInteger = webpack_require(46); var defined = webpack_require(43); module.exports = function repeat(count) { var str = String(defined(this)); var res = ‘’; var n = toInteger(count); if (n &lt; 0 || n == Infinity) throw RangeError(“Count can’t be negative”); for (;n &gt; 0; (n &gt;&gt;&gt;= 1) &amp;&amp; (str += str)) if (n &amp; 1) res += str; return res; };// }),/ 99 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $fails = webpack_require(14); var aNumberValue = webpack_require(97); var $toPrecision = 1.0.toPrecision; $export($export.P + $export.F ($fails(function () { // IE7- return $toPrecision.call(1, undefined) !== ‘1’; }) || !$fails(function () { // V8 ~ Android 4.3- $toPrecision.call({}); })), ‘Number’, { toPrecision: function toPrecision(precision) { var that = aNumberValue(this, ‘Number#toPrecision: incorrect invocation!’); return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); } });/*/ }),/ 100 /// (function(module, exports, webpack_require) { // 20.1.2.1 Number.EPSILON var $export = webpack_require(15); $export($export.S, ‘Number’, { EPSILON: Math.pow(2, -52) });// }),/ 101 /// (function(module, exports, webpack_require) { // 20.1.2.2 Number.isFinite(number) var $export = webpack_require(15); var _isFinite = webpack_require(11).isFinite; $export($export.S, ‘Number’, { isFinite: function isFinite(it) { return typeof it == ‘number’ &amp;&amp; _isFinite(it); } });// }),/ 102 /// (function(module, exports, webpack_require) { // 20.1.2.3 Number.isInteger(number) var $export = webpack_require(15); $export($export.S, ‘Number’, { isInteger: webpack_require(103) });// }),/ 103 /// (function(module, exports, webpack_require) { // 20.1.2.3 Number.isInteger(number) var isObject = webpack_require(20); var floor = Math.floor; module.exports = function isInteger(it) { return !isObject(it) &amp;&amp; isFinite(it) &amp;&amp; floor(it) === it; };// }),/ 104 /// (function(module, exports, webpack_require) { // 20.1.2.4 Number.isNaN(number) var $export = webpack_require(15); $export($export.S, ‘Number’, { isNaN: function isNaN(number) { // eslint-disable-next-line no-self-compare return number != number; } });// }),/ 105 /// (function(module, exports, webpack_require) { // 20.1.2.5 Number.isSafeInteger(number) var $export = webpack_require(15); var isInteger = webpack_require(103); var abs = Math.abs; $export($export.S, ‘Number’, { isSafeInteger: function isSafeInteger(number) { return isInteger(number) &amp;&amp; abs(number) &lt;= 0x1fffffffffffff; } });// }),/ 106 /// (function(module, exports, webpack_require) { // 20.1.2.6 Number.MAX_SAFE_INTEGER var $export = webpack_require(15); $export($export.S, ‘Number’, { MAX_SAFE_INTEGER: 0x1fffffffffffff });// }),/ 107 /// (function(module, exports, webpack_require) { // 20.1.2.10 Number.MIN_SAFE_INTEGER var $export = webpack_require(15); $export($export.S, ‘Number’, { MIN_SAFE_INTEGER: -0x1fffffffffffff });// }),/ 108 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseFloat = webpack_require(93); // 20.1.2.12 Number.parseFloat(string) $export($export.S + $export.F (Number.parseFloat != $parseFloat), ‘Number’, { parseFloat: $parseFloat });/*/ }),/ 109 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseInt = webpack_require(89); // 20.1.2.13 Number.parseInt(string, radix) $export($export.S + $export.F (Number.parseInt != $parseInt), ‘Number’, { parseInt: $parseInt });/*/ }),/ 110 /// (function(module, exports, webpack_require) { // 20.2.2.3 Math.acosh(x) var $export = webpack_require(15); var log1p = webpack_require(111); var sqrt = Math.sqrt; var $acosh = Math.acosh; $export($export.S + $export.F !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509 &amp;&amp; Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -&gt; NaN &amp;&amp; $acosh(Infinity) == Infinity ), ‘Math’, { acosh: function acosh(x) { return (x = +x) &lt; 1 ? NaN : x &gt; 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) sqrt(x + 1)); } });// }),/ 111 /// (function(module, exports) { // 20.2.2.20 Math.log1p(x) module.exports = Math.log1p || function log1p(x) { return (x = +x) &gt; -1e-8 &amp;&amp; x &lt; 1e-8 ? x - x x / 2 : Math.log(1 + x); };/*/ }),/ 112 /// (function(module, exports, webpack_require) { // 20.2.2.5 Math.asinh(x) var $export = webpack_require(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x &lt; 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x x + 1)); } // Tor Browser bug: Math.asinh(0) -&gt; -0 $export($export.S + $export.F !($asinh &amp;&amp; 1 / $asinh(0) &gt; 0), ‘Math’, { asinh: asinh });// }),/ 113 /// (function(module, exports, webpack_require) { // 20.2.2.7 Math.atanh(x) var $export = webpack_require(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -&gt; 0 $export($export.S + $export.F !($atanh &amp;&amp; 1 / $atanh(-0) &lt; 0), ‘Math’, { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } });/*/ }),/ 114 /// (function(module, exports, webpack_require) { // 20.2.2.9 Math.cbrt(x) var $export = webpack_require(15); var sign = webpack_require(115); $export($export.S, ‘Math’, { cbrt: function cbrt(x) { return sign(x = +x) Math.pow(Math.abs(x), 1 / 3); } });/*/ }),/ 115 /// (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x &lt; 0 ? -1 : 1; };// }),/ 116 /// (function(module, exports, webpack_require) { // 20.2.2.11 Math.clz32(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { clz32: function clz32(x) { return (x &gt;&gt;&gt;= 0) ? 31 - Math.floor(Math.log(x + 0.5) Math.LOG2E) : 32; } });/*/ }),/ 117 /// (function(module, exports, webpack_require) { // 20.2.2.12 Math.cosh(x) var $export = webpack_require(15); var exp = Math.exp; $export($export.S, ‘Math’, { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } });// }),/ 118 /// (function(module, exports, webpack_require) { // 20.2.2.14 Math.expm1(x) var $export = webpack_require(15); var $expm1 = webpack_require(119); $export($export.S + $export.F ($expm1 != Math.expm1), ‘Math’, { expm1: $expm1 });/*/ }),/ 119 /// (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) &gt; 22025.465794806719 || $expm1(10) &lt; 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x &gt; -1e-6 &amp;&amp; x &lt; 1e-6 ? x + x x / 2 : Math.exp(x) - 1; } : $expm1;/*/ }),/ 120 /// (function(module, exports, webpack_require) { // 20.2.2.16 Math.fround(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { fround: webpack_require(121) });// }),/ 121 /// (function(module, exports, webpack_require) { // 20.2.2.16 Math.fround(x) var sign = webpack_require(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs &lt; MIN32) return $sign roundTiesToEven($abs / MIN32 / EPSILON32) MIN32 EPSILON32; a = (1 + EPSILON32 / EPSILON) $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result &gt; MAX32 || result != result) return $sign Infinity; return $sign result; };/*/ }),/ 122 /// (function(module, exports, webpack_require) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = webpack_require(15); var abs = Math.abs; $export($export.S, ‘Math’, { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i &lt; aLen) { arg = abs(arguments[i++]); if (larg &lt; arg) { div = larg / arg; sum = sum div div + 1; larg = arg; } else if (arg &gt; 0) { div = arg / larg; sum += div div; } else sum += arg; } return larg === Infinity ? Infinity : larg Math.sqrt(sum); } });// }),/ 123 /// (function(module, exports, webpack_require) { // 20.2.2.18 Math.imul(x, y) var $export = webpack_require(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F webpack_require(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), ‘Math’, { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 &amp; xn; var yl = UINT16 &amp; yn; return 0 | xl yl + ((UINT16 &amp; xn &gt;&gt;&gt; 16) yl + xl (UINT16 &amp; yn &gt;&gt;&gt; 16) &lt;&lt; 16 &gt;&gt;&gt; 0); } });// }),/ 124 /// (function(module, exports, webpack_require) { // 20.2.2.21 Math.log10(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log10: function log10(x) { return Math.log(x) Math.LOG10E; } });/*/ }),/ 125 /// (function(module, exports, webpack_require) { // 20.2.2.20 Math.log1p(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log1p: webpack_require(111) });// }),/ 126 /// (function(module, exports, webpack_require) { // 20.2.2.22 Math.log2(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log2: function log2(x) { return Math.log(x) / Math.LN2; } });// }),/ 127 /// (function(module, exports, webpack_require) { // 20.2.2.28 Math.sign(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { sign: webpack_require(115) });// }),/ 128 /// (function(module, exports, webpack_require) { // 20.2.2.30 Math.sinh(x) var $export = webpack_require(15); var expm1 = webpack_require(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F webpack_require(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), ‘Math’, { sinh: function sinh(x) { return Math.abs(x = +x) &lt; 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) (Math.E / 2); } });// }),/ 129 /// (function(module, exports, webpack_require) { // 20.2.2.33 Math.tanh(x) var $export = webpack_require(15); var expm1 = webpack_require(119); var exp = Math.exp; $export($export.S, ‘Math’, { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } });// }),/ 130 /// (function(module, exports, webpack_require) { // 20.2.2.34 Math.trunc(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { trunc: function trunc(it) { return (it &gt; 0 ? Math.floor : Math.ceil)(it); } });// }),/ 131 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var toAbsoluteIndex = webpack_require(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F (!!$fromCodePoint &amp;&amp; $fromCodePoint.length != 1), ‘String’, { // 21.1.2.2 String.fromCodePoint(…codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen &gt; i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ‘ is not a valid code point’); res.push(code &lt; 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) &gt;&gt; 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(‘’); } });/*/ }),/ 132 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var toIObject = webpack_require(40); var toLength = webpack_require(45); $export($export.S, ‘String’, { // 21.1.2.4 String.raw(callSite, …substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len &gt; i) { res.push(String(tpl[i++])); if (i &lt; aLen) res.push(String(arguments[i])); } return res.join(‘’); } });// }),/ 133 /// (function(module, exports, webpack_require) { ‘use strict’; // 21.1.3.25 String.prototype.trim() webpack_require(90)(‘trim’, function ($trim) { return function trim() { return $trim(this, 3); }; });// }),/ 134 /// (function(module, exports, webpack_require) { ‘use strict’; var $at = webpack_require(135)(true); // 21.1.3.27 String.prototype@@iterator webpack_require(136)(String, ‘String’, function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index &gt;= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; });// }),/ 135 /// (function(module, exports, webpack_require) { var toInteger = webpack_require(46); var defined = webpack_require(43); // true -&gt; String#at // false -&gt; String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i &lt; 0 || i &gt;= l) return TO_STRING ? ‘’ : undefined; a = s.charCodeAt(i); return a &lt; 0xd800 || a &gt; 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) &lt; 0xdc00 || b &gt; 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 &lt;&lt; 10) + (b - 0xdc00) + 0x10000; }; };// }),/ 136 /// (function(module, exports, webpack_require) { ‘use strict’; var LIBRARY = webpack_require(29); var $export = webpack_require(15); var redefine = webpack_require(25); var hide = webpack_require(17); var Iterators = webpack_require(137); var $iterCreate = webpack_require(138); var setToStringTag = webpack_require(33); var getPrototypeOf = webpack_require(66); var ITERATOR = webpack_require(34)(‘iterator’); var BUGGY = !([].keys &amp;&amp; ‘next’ in [].keys()); // Safari has buggy iterators w/o next var FF_ITERATOR = ‘@@iterator’; var KEYS = ‘keys’; var VALUES = ‘values’; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY &amp;&amp; kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ‘ Iterator’; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT &amp;&amp; proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(‘entries’) : undefined; var $anyNative = NAME == ‘Array’ ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype &amp;&amp; IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY &amp;&amp; typeof IteratorPrototype[ITERATOR] != ‘function’) hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES &amp;&amp; $native &amp;&amp; $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) &amp;&amp; (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F (BUGGY || VALUES_BUG), NAME, methods); } return methods; };/*/ }),/ 137 /// (function(module, exports) { module.exports = {};// }),/ 138 /// (function(module, exports, webpack_require) { ‘use strict’; var create = webpack_require(53); var descriptor = webpack_require(24); var setToStringTag = webpack_require(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%@@iterator webpack_require(17)(IteratorPrototype, webpack_require(34)(‘iterator’), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ‘ Iterator’); };// }),/ 139 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $at = webpack_require(135)(false); $export($export.P, ‘String’, { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } });// }),/ 140 /// (function(module, exports, webpack_require) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) ‘use strict’; var $export = webpack_require(15); var toLength = webpack_require(45); var context = webpack_require(141); var ENDS_WITH = ‘endsWith’; var $endsWith = ‘’[ENDS_WITH]; $export($export.P + $export.F webpack_require(143)(ENDS_WITH), ‘String’, { endsWith: function endsWith(searchString / , endPosition = @length /) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length &gt; 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } });/*/ }),/ 141 /// (function(module, exports, webpack_require) { // helper for String#{startsWith, endsWith, includes} var isRegExp = webpack_require(142); var defined = webpack_require(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError(‘String#’ + NAME + “ doesn’t accept regex!”); return String(defined(that)); };// }),/ 142 /// (function(module, exports, webpack_require) { // 7.2.8 IsRegExp(argument) var isObject = webpack_require(20); var cof = webpack_require(42); var MATCH = webpack_require(34)(‘match’); module.exports = function (it) { var isRegExp; return isObject(it) &amp;&amp; ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == ‘RegExp’); };// }),/ 143 /// (function(module, exports, webpack_require) { var MATCH = webpack_require(34)(‘match’); module.exports = function (KEY) { var re = /./; try { ‘/./‘KEY; } catch (e) { try { re[MATCH] = false; return !’/./‘KEY; } catch (f) { / empty / } } return true; };// }),/ 144 /// (function(module, exports, webpack_require) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) ‘use strict’; var $export = webpack_require(15); var context = webpack_require(141); var INCLUDES = ‘includes’; $export($export.P + $export.F webpack_require(143)(INCLUDES), ‘String’, { includes: function includes(searchString / , position = 0 /) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length &gt; 1 ? arguments[1] : undefined); } });/*/ }),/ 145 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); $export($export.P, ‘String’, { // 21.1.3.13 String.prototype.repeat(count) repeat: webpack_require(98) });// }),/ 146 /// (function(module, exports, webpack_require) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) ‘use strict’; var $export = webpack_require(15); var toLength = webpack_require(45); var context = webpack_require(141); var STARTS_WITH = ‘startsWith’; var $startsWith = ‘’[STARTS_WITH]; $export($export.P + $export.F webpack_require(143)(STARTS_WITH), ‘String’, { startsWith: function startsWith(searchString / , position = 0 /) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length &gt; 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } });/*/ }),/ 147 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.2 String.prototype.anchor(name) webpack_require(148)(‘anchor’, function (createHTML) { return function anchor(name) { return createHTML(this, ‘a’, ‘name’, name); }; });// }),/ 148 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var fails = webpack_require(14); var defined = webpack_require(43); var quot = /“/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ‘&lt;’ + tag; if (attribute !== ‘’) p1 += ‘ ‘ + attribute + ‘=”‘ + String(value).replace(quot, ‘&quot;’) + ‘“‘; return p1 + ‘&gt;’ + S + ‘&lt;/‘ + tag + ‘&gt;’; }; module.exports = function (NAME, exec) { var O = {}; O[NAME] = exec(createHTML); $export($export.P + $export.F fails(function () { var test = ‘’NAME; return test !== test.toLowerCase() || test.split(‘“‘).length &gt; 3; }), ‘String’, O); };/*/ }),/ 149 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.3 String.prototype.big() webpack_require(148)(‘big’, function (createHTML) { return function big() { return createHTML(this, ‘big’, ‘’, ‘’); }; });// }),/ 150 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.4 String.prototype.blink() webpack_require(148)(‘blink’, function (createHTML) { return function blink() { return createHTML(this, ‘blink’, ‘’, ‘’); }; });// }),/ 151 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.5 String.prototype.bold() webpack_require(148)(‘bold’, function (createHTML) { return function bold() { return createHTML(this, ‘b’, ‘’, ‘’); }; });// }),/ 152 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.6 String.prototype.fixed() webpack_require(148)(‘fixed’, function (createHTML) { return function fixed() { return createHTML(this, ‘tt’, ‘’, ‘’); }; });// }),/ 153 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.7 String.prototype.fontcolor(color) webpack_require(148)(‘fontcolor’, function (createHTML) { return function fontcolor(color) { return createHTML(this, ‘font’, ‘color’, color); }; });// }),/ 154 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.8 String.prototype.fontsize(size) webpack_require(148)(‘fontsize’, function (createHTML) { return function fontsize(size) { return createHTML(this, ‘font’, ‘size’, size); }; });// }),/ 155 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.9 String.prototype.italics() webpack_require(148)(‘italics’, function (createHTML) { return function italics() { return createHTML(this, ‘i’, ‘’, ‘’); }; });// }),/ 156 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.10 String.prototype.link(url) webpack_require(148)(‘link’, function (createHTML) { return function link(url) { return createHTML(this, ‘a’, ‘href’, url); }; });// }),/ 157 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.11 String.prototype.small() webpack_require(148)(‘small’, function (createHTML) { return function small() { return createHTML(this, ‘small’, ‘’, ‘’); }; });// }),/ 158 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.12 String.prototype.strike() webpack_require(148)(‘strike’, function (createHTML) { return function strike() { return createHTML(this, ‘strike’, ‘’, ‘’); }; });// }),/ 159 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.13 String.prototype.sub() webpack_require(148)(‘sub’, function (createHTML) { return function sub() { return createHTML(this, ‘sub’, ‘’, ‘’); }; });// }),/ 160 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.14 String.prototype.sup() webpack_require(148)(‘sup’, function (createHTML) { return function sup() { return createHTML(this, ‘sup’, ‘’, ‘’); }; });// }),/ 161 /// (function(module, exports, webpack_require) { // 20.3.3.1 / 15.9.4.4 Date.now() var $export = webpack_require(15); $export($export.S, ‘Date’, { now: function () { return new Date().getTime(); } });// }),/ 162 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); $export($export.P + $export.F webpack_require(14)(function () { return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1; }), ‘Date’, { // eslint-disable-next-line no-unused-vars toJSON: function toJSON(key) { var O = toObject(this); var pv = toPrimitive(O); return typeof pv == ‘number’ &amp;&amp; !isFinite(pv) ? null : O.toISOString(); } });/*/ }),/ 163 /// (function(module, exports, webpack_require) { // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString() var $export = webpack_require(15); var toISOString = webpack_require(164); // PhantomJS / old WebKit has a broken implementations $export($export.P + $export.F (Date.prototype.toISOString !== toISOString), ‘Date’, { toISOString: toISOString });/*/ }),/ 164 /// (function(module, exports, webpack_require) { ‘use strict’; // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString() var fails = webpack_require(14); var getTime = Date.prototype.getTime; var $toISOString = Date.prototype.toISOString; var lz = function (num) { return num &gt; 9 ? num : ‘0’ + num; }; // PhantomJS / old WebKit has a broken implementations module.exports = (fails(function () { return $toISOString.call(new Date(-5e13 - 1)) != ‘0385-07-25T07:06:39.999Z’; }) || !fails(function () { $toISOString.call(new Date(NaN)); })) ? function toISOString() { if (!isFinite(getTime.call(this))) throw RangeError(‘Invalid time value’); var d = this; var y = d.getUTCFullYear(); var m = d.getUTCMilliseconds(); var s = y &lt; 0 ? ‘-‘ : y &gt; 9999 ? ‘+’ : ‘’; return s + (‘00000’ + Math.abs(y)).slice(s ? -6 : -4) + ‘-‘ + lz(d.getUTCMonth() + 1) + ‘-‘ + lz(d.getUTCDate()) + ‘T’ + lz(d.getUTCHours()) + ‘:’ + lz(d.getUTCMinutes()) + ‘:’ + lz(d.getUTCSeconds()) + ‘.’ + (m &gt; 99 ? m : ‘0’ + lz(m)) + ‘Z’; } : $toISOString;// }),/ 165 /// (function(module, exports, webpack_require) { var DateProto = Date.prototype; var INVALID_DATE = ‘Invalid Date’; var TO_STRING = ‘toString’; var $toString = DateProto[TO_STRING]; var getTime = DateProto.getTime; if (new Date(NaN) + ‘’ != INVALID_DATE) { webpack_require(25)(DateProto, TO_STRING, function toString() { var value = getTime.call(this); // eslint-disable-next-line no-self-compare return value === value ? $toString.call(this) : INVALID_DATE; }); }// }),/ 166 /// (function(module, exports, webpack_require) { var TO_PRIMITIVE = webpack_require(34)(‘toPrimitive’); var proto = Date.prototype; if (!(TO_PRIMITIVE in proto)) webpack_require(17)(proto, TO_PRIMITIVE, webpack_require(167));// }),/ 167 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toPrimitive = webpack_require(23); var NUMBER = ‘number’; module.exports = function (hint) { if (hint !== ‘string’ &amp;&amp; hint !== NUMBER &amp;&amp; hint !== ‘default’) throw TypeError(‘Incorrect hint’); return toPrimitive(anObject(this), hint != NUMBER); };// }),/ 168 /// (function(module, exports, webpack_require) { // 22.1.2.2 / 15.4.3.2 Array.isArray(arg) var $export = webpack_require(15); $export($export.S, ‘Array’, { isArray: webpack_require(52) });// }),/ 169 /// (function(module, exports, webpack_require) { ‘use strict’; var ctx = webpack_require(30); var $export = webpack_require(15); var toObject = webpack_require(65); var call = webpack_require(170); var isArrayIter = webpack_require(171); var toLength = webpack_require(45); var createProperty = webpack_require(172); var getIterFn = webpack_require(173); $export($export.S + $export.F !webpack_require(174)(function (iter) { Array.from(iter); }), ‘Array’, { // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined) from: function from(arrayLike / , mapfn = undefined, thisArg = undefined /) { var O = toObject(arrayLike); var C = typeof this == ‘function’ ? this : Array; var aLen = arguments.length; var mapfn = aLen &gt; 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var index = 0; var iterFn = getIterFn(O); var length, result, step, iterator; if (mapping) mapfn = ctx(mapfn, aLen &gt; 2 ? arguments[2] : undefined, 2); // if object isn’t iterable or it’s array with default iterator - use simple case if (iterFn != undefined &amp;&amp; !(C == Array &amp;&amp; isArrayIter(iterFn))) { for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) { createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value); } } else { length = toLength(O.length); for (result = new C(length); length &gt; index; index++) { createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]); } } result.length = index; return result; } });/*/ }),/ 170 /// (function(module, exports, webpack_require) { // call something on iterator step with safe closing on error var anObject = webpack_require(19); module.exports = function (iterator, fn, value, entries) { try { return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion) } catch (e) { var ret = iterator[‘return’]; if (ret !== undefined) anObject(ret.call(iterator)); throw e; } };// }),/ 171 /// (function(module, exports, webpack_require) { // check on default Array iterator var Iterators = webpack_require(137); var ITERATOR = webpack_require(34)(‘iterator’); var ArrayProto = Array.prototype; module.exports = function (it) { return it !== undefined &amp;&amp; (Iterators.Array === it || ArrayProto[ITERATOR] === it); };// }),/ 172 /// (function(module, exports, webpack_require) { ‘use strict’; var $defineProperty = webpack_require(18); var createDesc = webpack_require(24); module.exports = function (object, index, value) { if (index in object) $defineProperty.f(object, index, createDesc(0, value)); else object[index] = value; };// }),/ 173 /// (function(module, exports, webpack_require) { var classof = webpack_require(82); var ITERATOR = webpack_require(34)(‘iterator’); var Iterators = webpack_require(137); module.exports = webpack_require(16).getIteratorMethod = function (it) { if (it != undefined) return it[ITERATOR] || it[‘@@iterator’] || Iterators[classof(it)]; };// }),/ 174 /// (function(module, exports, webpack_require) { var ITERATOR = webpack_require(34)(‘iterator’); var SAFE_CLOSING = false; try { var riter = [7]ITERATOR; riter[‘return’] = function () { SAFE_CLOSING = true; }; // eslint-disable-next-line no-throw-literal Array.from(riter, function () { throw 2; }); } catch (e) { / empty / } module.exports = function (exec, skipClosing) { if (!skipClosing &amp;&amp; !SAFE_CLOSING) return false; var safe = false; try { var arr = [7]; var iter = arrITERATOR; iter.next = function () { return { done: safe = true }; }; arr[ITERATOR] = function () { return iter; }; exec(arr); } catch (e) { / empty / } return safe; };// }),/ 175 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var createProperty = webpack_require(172); // WebKit Array.of isn’t generic $export($export.S + $export.F webpack_require(14)(function () { function F() { / empty / } return !(Array.of.call(F) instanceof F); }), ‘Array’, { // 22.1.2.3 Array.of( …items) of: function of(/ …args /) { var index = 0; var aLen = arguments.length; var result = new (typeof this == ‘function’ ? this : Array)(aLen); while (aLen &gt; index) createProperty(result, index, arguments[index++]); result.length = aLen; return result; } });/*/ }),/ 176 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.13 Array.prototype.join(separator) var $export = webpack_require(15); var toIObject = webpack_require(40); var arrayJoin = [].join; // fallback for not array-like strings $export($export.P + $export.F (webpack_require(41) != Object || !webpack_require(177)(arrayJoin)), ‘Array’, { join: function join(separator) { return arrayJoin.call(toIObject(this), separator === undefined ? ‘,’ : separator); } });/*/ }),/ 177 /// (function(module, exports, webpack_require) { ‘use strict’; var fails = webpack_require(14); module.exports = function (method, arg) { return !!method &amp;&amp; fails(function () { // eslint-disable-next-line no-useless-call arg ? method.call(null, function () { / empty / }, 1) : method.call(null); }); };// }),/ 178 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var html = webpack_require(55); var cof = webpack_require(42); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects $export($export.P + $export.F webpack_require(14)(function () { if (html) arraySlice.call(html); }), ‘Array’, { slice: function slice(begin, end) { var len = toLength(this.length); var klass = cof(this); end = end === undefined ? len : end; if (klass == ‘Array’) return arraySlice.call(this, begin, end); var start = toAbsoluteIndex(begin, len); var upTo = toAbsoluteIndex(end, len); var size = toLength(upTo - start); var cloned = new Array(size); var i = 0; for (; i &lt; size; i++) cloned[i] = klass == ‘String’ ? this.charAt(start + i) : this[start + i]; return cloned; } });/*/ }),/ 179 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var aFunction = webpack_require(31); var toObject = webpack_require(65); var fails = webpack_require(14); var $sort = [].sort; var test = [1, 2, 3]; $export($export.P + $export.F (fails(function () { // IE8- test.sort(undefined); }) || !fails(function () { // V8 bug test.sort(null); // Old WebKit }) || !webpack_require(177)($sort)), ‘Array’, { // 22.1.3.25 Array.prototype.sort(comparefn) sort: function sort(comparefn) { return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn)); } });/*/ }),/ 180 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $forEach = webpack_require(181)(0); var STRICT = webpack_require(177)([].forEach, true); $export($export.P + $export.F !STRICT, ‘Array’, { // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg]) forEach: function forEach(callbackfn / , thisArg /) { return $forEach(this, callbackfn, arguments[1]); } });/*/ }),/ 181 /// (function(module, exports, webpack_require) { // 0 -&gt; Array#forEach // 1 -&gt; Array#map // 2 -&gt; Array#filter // 3 -&gt; Array#some // 4 -&gt; Array#every // 5 -&gt; Array#find // 6 -&gt; Array#findIndex var ctx = webpack_require(30); var IObject = webpack_require(41); var toObject = webpack_require(65); var toLength = webpack_require(45); var asc = webpack_require(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length &gt; index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; };// }),/ 182 /// (function(module, exports, webpack_require) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = webpack_require(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); };// }),/ 183 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var isArray = webpack_require(52); var SPECIES = webpack_require(34)(‘species’); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == ‘function’ &amp;&amp; (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; };// }),/ 184 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $map = webpack_require(181)(1); $export($export.P + $export.F !webpack_require(177)([].map, true), ‘Array’, { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn / , thisArg /) { return $map(this, callbackfn, arguments[1]); } });/*/ }),/ 185 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $filter = webpack_require(181)(2); $export($export.P + $export.F !webpack_require(177)([].filter, true), ‘Array’, { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn / , thisArg /) { return $filter(this, callbackfn, arguments[1]); } });/*/ }),/ 186 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $some = webpack_require(181)(3); $export($export.P + $export.F !webpack_require(177)([].some, true), ‘Array’, { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn / , thisArg /) { return $some(this, callbackfn, arguments[1]); } });/*/ }),/ 187 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $every = webpack_require(181)(4); $export($export.P + $export.F !webpack_require(177)([].every, true), ‘Array’, { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn / , thisArg /) { return $every(this, callbackfn, arguments[1]); } });/*/ }),/ 188 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $reduce = webpack_require(189); $export($export.P + $export.F !webpack_require(177)([].reduce, true), ‘Array’, { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn / , initialValue /) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } });/*/ }),/ 189 /// (function(module, exports, webpack_require) { var aFunction = webpack_require(31); var toObject = webpack_require(65); var IObject = webpack_require(41); var toLength = webpack_require(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen &lt; 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index &lt; 0 : length &lt;= index) { throw TypeError(‘Reduce of empty array with no initial value’); } } for (;isRight ? index &gt;= 0 : length &gt; index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; };// }),/ 190 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $reduce = webpack_require(189); $export($export.P + $export.F !webpack_require(177)([].reduceRight, true), ‘Array’, { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn / , initialValue /) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } });/*/ }),/ 191 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $indexOf = webpack_require(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native &amp;&amp; 1 / [1].indexOf(1, -0) &lt; 0; $export($export.P + $export.F (NEGATIVE_ZERO || !webpack_require(177)($native)), ‘Array’, { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement / , fromIndex = 0 /) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } });/*/ }),/ 192 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toIObject = webpack_require(40); var toInteger = webpack_require(46); var toLength = webpack_require(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native &amp;&amp; 1 / [1].lastIndexOf(1, -0) &lt; 0; $export($export.P + $export.F (NEGATIVE_ZERO || !webpack_require(177)($native)), ‘Array’, { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement / , fromIndex = @[-1] /) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length &gt; 1) index = Math.min(index, toInteger(arguments[1])); if (index &lt; 0) index = length + index; for (;index &gt;= 0; index–) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } });// }),/ 193 /// (function(module, exports, webpack_require) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = webpack_require(15); $export($export.P, ‘Array’, { copyWithin: webpack_require(194) }); webpack_require(195)(‘copyWithin’);// }),/ 194 /// (function(module, exports, webpack_require) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) ‘use strict’; var toObject = webpack_require(65); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); module.exports = [].copyWithin || function copyWithin(target / = 0 /, start / = 0, end = @length /) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length &gt; 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from &lt; to &amp;&amp; to &lt; from + count) { inc = -1; from += count - 1; to += count - 1; } while (count– &gt; 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; };// }),/ 195 /// (function(module, exports, webpack_require) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = webpack_require(34)(‘unscopables’); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) webpack_require(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; };// }),/ 196 /// (function(module, exports, webpack_require) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = webpack_require(15); $export($export.P, ‘Array’, { fill: webpack_require(197) }); webpack_require(195)(‘fill’);// }),/ 197 /// (function(module, exports, webpack_require) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) ‘use strict’; var toObject = webpack_require(65); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); module.exports = function fill(value / , start = 0, end = @length /) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen &gt; 1 ? arguments[1] : undefined, length); var end = aLen &gt; 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos &gt; index) O[index++] = value; return O; };// }),/ 198 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = webpack_require(15); var $find = webpack_require(181)(5); var KEY = ‘find’; var forced = true; // Shouldn’t skip holes if (KEY in []) Array(1)KEY { forced = false; }); $export($export.P + $export.F forced, ‘Array’, { find: function find(callbackfn / , that = undefined /) { return $find(this, callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(KEY);/*/ }),/ 199 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = webpack_require(15); var $find = webpack_require(181)(6); var KEY = ‘findIndex’; var forced = true; // Shouldn’t skip holes if (KEY in []) Array(1)KEY { forced = false; }); $export($export.P + $export.F forced, ‘Array’, { findIndex: function findIndex(callbackfn / , that = undefined /) { return $find(this, callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(KEY);/*/ }),/ 200 /// (function(module, exports, webpack_require) { webpack_require(201)(‘Array’);// }),/ 201 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var dP = webpack_require(18); var DESCRIPTORS = webpack_require(13); var SPECIES = webpack_require(34)(‘species’); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS &amp;&amp; C &amp;&amp; !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); };// }),/ 202 /// (function(module, exports, webpack_require) { ‘use strict’; var addToUnscopables = webpack_require(195); var step = webpack_require(203); var Iterators = webpack_require(137); var toIObject = webpack_require(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype@@iterator module.exports = webpack_require(136)(Array, ‘Array’, function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index &gt;= O.length) { this._t = undefined; return step(1); } if (kind == ‘keys’) return step(0, index); if (kind == ‘values’) return step(0, O[index]); return step(0, [index, O[index]]); }, ‘values’); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables(‘keys’); addToUnscopables(‘values’); addToUnscopables(‘entries’);// }),/ 203 /// (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; };// }),/ 204 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var inheritIfRequired = webpack_require(95); var dP = webpack_require(18).f; var gOPN = webpack_require(57).f; var isRegExp = webpack_require(142); var $flags = webpack_require(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // “new” creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (webpack_require(13) &amp;&amp; (!CORRECT_NEW || webpack_require(14)(function () { re2[webpack_require(34)(‘match’)] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, ‘i’) != ‘/a/i’; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE &amp;&amp; piRE &amp;&amp; p.constructor === $RegExp &amp;&amp; fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE &amp;&amp; !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE &amp;&amp; fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length &gt; i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; webpack_require(25)(global, ‘RegExp’, $RegExp); } webpack_require(201)(‘RegExp’);// }),/ 205 /// (function(module, exports, webpack_require) { ‘use strict’; // 21.2.5.3 get RegExp.prototype.flags var anObject = webpack_require(19); module.exports = function () { var that = anObject(this); var result = ‘’; if (that.global) result += ‘g’; if (that.ignoreCase) result += ‘i’; if (that.multiline) result += ‘m’; if (that.unicode) result += ‘u’; if (that.sticky) result += ‘y’; return result; };// }),/ 206 /// (function(module, exports, webpack_require) { ‘use strict’; var regexpExec = webpack_require(207); webpack_require(15)({ target: ‘RegExp’, proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec });// }),/ 207 /// (function(module, exports, webpack_require) { ‘use strict’; var regexpFlags = webpack_require(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = ‘lastIndex’; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b/g; nativeExec.call(re1, ‘a’); nativeExec.call(re2, ‘a’); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim’s String#split patch. var NPCG_INCLUDED = /()??/.exec(‘’)[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp(‘^’ + re.source + ‘$(?!\s)’, regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG &amp;&amp; match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED &amp;&amp; match &amp;&amp; match.length &gt; 1) { // Fix browsers whose exec methods don’t consistently return undefined // for NPCG, like IE8. NOTE: This doesn’ work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i &lt; arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec;/*/ }),/ 208 /// (function(module, exports, webpack_require) { ‘use strict’; webpack_require(209); var anObject = webpack_require(19); var $flags = webpack_require(205); var DESCRIPTORS = webpack_require(13); var TO_STRING = ‘toString’; var $toString = /./[TO_STRING]; var define = function (fn) { webpack_require(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (webpack_require(14)(function () { return $toString.call({ source: ‘a’, flags: ‘b’ }) != ‘/a/b’; })) { define(function toString() { var R = anObject(this); return ‘/‘.concat(R.source, ‘/‘, ‘flags’ in R ? R.flags : !DESCRIPTORS &amp;&amp; R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); }// }),/ 209 /// (function(module, exports, webpack_require) { // 21.2.5.3 get RegExp.prototype.flags() if (webpack_require(13) &amp;&amp; /./g.flags != ‘g’) webpack_require(18).f(RegExp.prototype, ‘flags’, { configurable: true, get: webpack_require(205) });// }),/ 210 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toLength = webpack_require(45); var advanceStringIndex = webpack_require(211); var regExpExec = webpack_require(212); // @@match logic webpack_require(213)(‘match’, 1, function (defined, MATCH, $match, maybeCallNative) { return [ // String.prototype.match method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)MATCH); }, // RegExp.prototype[@@match] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === ‘’) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; });// }),/ 211 /// (function(module, exports, webpack_require) { ‘use strict’; var at = webpack_require(135)(true); // AdvanceStringIndex abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); };// }),/ 212 /// (function(module, exports, webpack_require) { ‘use strict’; var classof = webpack_require(82); var builtinExec = RegExp.prototype.exec; // RegExpExec abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === ‘function’) { var result = exec.call(R, S); if (typeof result !== ‘object’) { throw new TypeError(‘RegExp exec method returned something other than an Object or null’); } return result; } if (classof(R) !== ‘RegExp’) { throw new TypeError(‘RegExp#exec called on incompatible receiver’); } return builtinExec.call(R, S); };// }),/ 213 /// (function(module, exports, webpack_require) { ‘use strict’; webpack_require(206); var redefine = webpack_require(25); var hide = webpack_require(17); var fails = webpack_require(14); var defined = webpack_require(43); var wks = webpack_require(34); var regexpExec = webpack_require(207); var SPECIES = wks(‘species’); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a “grops” property. var re = /./; re.exec = function () { var result = []; result.groups = { a: ‘7’ }; return result; }; return ‘’.replace(re, ‘$‘) !== ‘7’; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy “split” implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = ‘ab’.split(re); return result.length === 2 &amp;&amp; result[0] === ‘a’ &amp;&amp; result[1] === ‘b’; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ‘’KEY != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === ‘split’) { // RegExp[@@split] doesn’t call the regex’s exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } reSYMBOL; return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === ‘replace’ &amp;&amp; !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === ‘split’ &amp;&amp; !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ‘’[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL &amp;&amp; !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype@@replace // 21.2.5.11 RegExp.prototype@@split ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype@@match // 21.2.5.9 RegExp.prototype@@search : function (string) { return rxfn.call(string, this); } ); } };// }),/ 214 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toObject = webpack_require(65); var toLength = webpack_require(45); var toInteger = webpack_require(46); var advanceStringIndex = webpack_require(211); var regExpExec = webpack_require(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&amp;`’]|\d\d?|&lt;[^&gt;]&gt;)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&amp;&#39;]|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)(&#39;replace&#39;, 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ //String.prototype.replacemethod // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, //RegExp.prototype[@@replace]method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === &#39;function&#39;; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === &#39;&#39;) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = &#39;&#39;; var nextSourcePosition = 0; for (var i = 0; i &lt; results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reasonnativeSlice.call(result, 1, result.length)(called in // the slice polyfill when slicing native arrays) &quot;doesn&#39;t work&quot; in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j &lt; result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position &gt;= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case &#39;$&#39;: return &#39;$&#39;; case &#39;&amp;&#39;: return matched; case &#39;‘: return str.slice(0, position); case “‘“: return str.slice(tailPos); case ‘&lt;’: capture = namedCaptures[ch.slice(1, -1)]; break; default: // \d\d? var n = +ch; if (n === 0) return match; if (n &gt; m) { var f = floor(n / 10); if (f === 0) return match; if (f &lt;= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1); return match; } capture = captures[n - 1]; } return capture === undefined ? ‘’ : capture; }); } });/*/ }),/ 215 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var sameValue = webpack_require(78); var regExpExec = webpack_require(212); // @@search logic webpack_require(213)(‘search’, 1, function (defined, SEARCH, $search, maybeCallNative) { return [ // String.prototype.search method // https://tc39.github.io/ecma262/#sec-string.prototype.search function search(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[SEARCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)SEARCH); }, // RegExp.prototype[@@search] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search function (regexp) { var res = maybeCallNative($search, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var previousLastIndex = rx.lastIndex; if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0; var result = regExpExec(rx, S); if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex; return result === null ? -1 : result.index; } ]; });// }),/ 216 /// (function(module, exports, webpack_require) { ‘use strict’; var isRegExp = webpack_require(142); var anObject = webpack_require(19); var speciesConstructor = webpack_require(217); var advanceStringIndex = webpack_require(211); var toLength = webpack_require(45); var callRegExpExec = webpack_require(212); var regexpExec = webpack_require(207); var fails = webpack_require(14); var $min = Math.min; var $push = [].push; var $SPLIT = ‘split’; var LENGTH = ‘length’; var LAST_INDEX = ‘lastIndex’; var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp(‘x’, ‘y’) -&gt; /x/y and it causes SyntaxError var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, ‘y’); }); // @@split logic webpack_require(213)(‘split’, 2, function (defined, SPLIT, $split, maybeCallNative) { var internalSplit; if ( ‘abbc’$SPLIT/)[1] == ‘c’ || ‘test’$SPLIT/, -1)[LENGTH] != 4 || ‘ab’$SPLIT/)[LENGTH] != 2 || ‘.’$SPLIT(.?)/)[LENGTH] != 4 || ‘.’$SPLIT()/)[LENGTH] &gt; 1 || ‘’$SPLIT[LENGTH] ) { // based on es5-shim implementation, need to rework it internalSplit = function (separator, limit) { var string = String(this); if (separator === undefined &amp;&amp; limit === 0) return []; // If separator is not a regex, use native split if (!isRegExp(separator)) return $split.call(string, separator, limit); var output = []; var flags = (separator.ignoreCase ? ‘i’ : ‘’) + (separator.multiline ? ‘m’ : ‘’) + (separator.unicode ? ‘u’ : ‘’) + (separator.sticky ? ‘y’ : ‘’); var lastLastIndex = 0; var splitLimit = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0; // Make global and avoid lastIndex issues by working with a copy var separatorCopy = new RegExp(separator.source, flags + ‘g’); var match, lastIndex, lastLength; while (match = regexpExec.call(separatorCopy, string)) { lastIndex = separatorCopy[LAST_INDEX]; if (lastIndex &gt; lastLastIndex) { output.push(string.slice(lastLastIndex, match.index)); if (match[LENGTH] &gt; 1 &amp;&amp; match.index &lt; string[LENGTH]) $push.apply(output, match.slice(1)); lastLength = match[0][LENGTH]; lastLastIndex = lastIndex; if (output[LENGTH] &gt;= splitLimit) break; } if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop } if (lastLastIndex === string[LENGTH]) { if (lastLength || !separatorCopy.test(‘’)) output.push(‘’); } else output.push(string.slice(lastLastIndex)); return output[LENGTH] &gt; splitLimit ? output.slice(0, splitLimit) : output; }; // Chakra, V8 } else if (‘0’$SPLIT[LENGTH]) { internalSplit = function (separator, limit) { return separator === undefined &amp;&amp; limit === 0 ? [] : $split.call(this, separator, limit); }; } else { internalSplit = $split; } return [ // String.prototype.split method // https://tc39.github.io/ecma262/#sec-string.prototype.split function split(separator, limit) { var O = defined(this); var splitter = separator == undefined ? undefined : separator[SPLIT]; return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit); }, // RegExp.prototype[@@split] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split // // NOTE: This cannot be properly polyfilled in engines that don’t support // the ‘y’ flag. function (regexp, limit) { var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var C = speciesConstructor(rx, RegExp); var unicodeMatching = rx.unicode; var flags = (rx.ignoreCase ? ‘i’ : ‘’) + (rx.multiline ? ‘m’ : ‘’) + (rx.unicode ? ‘u’ : ‘’) + (SUPPORTS_Y ? ‘y’ : ‘g’); // ^(? + rx + ) is needed, in combination with some S slicing, to // simulate the ‘y’ flag. var splitter = new C(SUPPORTS_Y ? rx : ‘^(?:’ + rx.source + ‘)’, flags); var lim = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q &lt; S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i &lt;= z.length - 1; i++) { A.push(z[i]); if (A.length === lim) return A; } q = p = e; } } A.push(S.slice(p)); return A; } ]; });// }),/ 217 /// (function(module, exports, webpack_require) { // 7.3.20 SpeciesConstructor(O, defaultConstructor) var anObject = webpack_require(19); var aFunction = webpack_require(31); var SPECIES = webpack_require(34)(‘species’); module.exports = function (O, D) { var C = anObject(O).constructor; var S; return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S); };// }),/ 218 /// (function(module, exports, webpack_require) { ‘use strict’; var LIBRARY = webpack_require(29); var global = webpack_require(11); var ctx = webpack_require(30); var classof = webpack_require(82); var $export = webpack_require(15); var isObject = webpack_require(20); var aFunction = webpack_require(31); var anInstance = webpack_require(219); var forOf = webpack_require(220); var speciesConstructor = webpack_require(217); var task = webpack_require(221).set; var microtask = webpack_require(222)(); var newPromiseCapabilityModule = webpack_require(223); var perform = webpack_require(224); var userAgent = webpack_require(225); var promiseResolve = webpack_require(226); var PROMISE = ‘Promise’; var TypeError = global.TypeError; var process = global.process; var versions = process &amp;&amp; process.versions; var v8 = versions &amp;&amp; versions.v8 || ‘’; var $Promise = global[PROMISE]; var isNode = classof(process) == ‘process’; var empty = function () { / empty / }; var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper; var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f; var USE_NATIVE = !!function () { try { // correct subclassing with @@species support var promise = $Promise.resolve(1); var FakePromise = (promise.constructor = {})[webpack_require(34)(‘species’)] = function (exec) { exec(empty, empty); }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test return (isNode || typeof PromiseRejectionEvent == ‘function’) &amp;&amp; promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables // https://bugs.chromium.org/p/chromium/issues/detail?id=830565 // we can’t detect it synchronously, so just check versions &amp;&amp; v8.indexOf(‘6.6’) !== 0 &amp;&amp; userAgent.indexOf(‘Chrome/66’) === -1; } catch (e) { / empty / } }(); // helpers var isThenable = function (it) { var then; return isObject(it) &amp;&amp; typeof (then = it.then) == ‘function’ ? then : false; }; var notify = function (promise, isReject) { if (promise._n) return; promise._n = true; var chain = promise._c; microtask(function () { var value = promise._v; var ok = promise._s == 1; var i = 0; var run = function (reaction) { var handler = ok ? reaction.ok : reaction.fail; var resolve = reaction.resolve; var reject = reaction.reject; var domain = reaction.domain; var result, then, exited; try { if (handler) { if (!ok) { if (promise._h == 2) onHandleUnhandled(promise); promise._h = 1; } if (handler === true) result = value; else { if (domain) domain.enter(); result = handler(value); // may throw if (domain) { domain.exit(); exited = true; } } if (result === reaction.promise) { reject(TypeError(‘Promise-chain cycle’)); } else if (then = isThenable(result)) { then.call(result, resolve, reject); } else resolve(result); } else reject(value); } catch (e) { if (domain &amp;&amp; !exited) domain.exit(); reject(e); } }; while (chain.length &gt; i) run(chain[i++]); // variable length - can’t use forEach promise._c = []; promise._n = false; if (isReject &amp;&amp; !promise._h) onUnhandled(promise); }); }; var onUnhandled = function (promise) { task.call(global, function () { var value = promise._v; var unhandled = isUnhandled(promise); var result, handler, console; if (unhandled) { result = perform(function () { if (isNode) { process.emit(‘unhandledRejection’, value, promise); } else if (handler = global.onunhandledrejection) { handler({ promise: promise, reason: value }); } else if ((console = global.console) &amp;&amp; console.error) { console.error(‘Unhandled promise rejection’, value); } }); // Browsers should not trigger rejectionHandled event if it was handled here, NodeJS - should promise._h = isNode || isUnhandled(promise) ? 2 : 1; } promise._a = undefined; if (unhandled &amp;&amp; result.e) throw result.v; }); }; var isUnhandled = function (promise) { return promise._h !== 1 &amp;&amp; (promise._a || promise._c).length === 0; }; var onHandleUnhandled = function (promise) { task.call(global, function () { var handler; if (isNode) { process.emit(‘rejectionHandled’, promise); } else if (handler = global.onrejectionhandled) { handler({ promise: promise, reason: promise._v }); } }); }; var $reject = function (value) { var promise = this; if (promise._d) return; promise._d = true; promise = promise._w || promise; // unwrap promise._v = value; promise._s = 2; if (!promise._a) promise._a = promise._c.slice(); notify(promise, true); }; var $resolve = function (value) { var promise = this; var then; if (promise._d) return; promise._d = true; promise = promise._w || promise; // unwrap try { if (promise === value) throw TypeError(“Promise can’t be resolved itself”); if (then = isThenable(value)) { microtask(function () { var wrapper = { _w: promise, _d: false }; // wrap try { then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1)); } catch (e) { $reject.call(wrapper, e); } }); } else { promise._v = value; promise._s = 1; notify(promise, false); } } catch (e) { $reject.call({ _w: promise, _d: false }, e); // wrap } }; // constructor polyfill if (!USE_NATIVE) { // 25.4.3.1 Promise(executor) $Promise = function Promise(executor) { anInstance(this, $Promise, PROMISE, ‘_h’); aFunction(executor); Internal.call(this); try { executor(ctx($resolve, this, 1), ctx($reject, this, 1)); } catch (err) { $reject.call(this, err); } }; // eslint-disable-next-line no-unused-vars Internal = function Promise(executor) { this._c = []; // &lt;- awaiting reactions this._a = undefined; // &lt;- checked in isUnhandled reactions this._s = 0; // &lt;- state this._d = false; // &lt;- done this._v = undefined; // &lt;- value this._h = 0; // &lt;- rejection state, 0 - default, 1 - handled, 2 - unhandled this._n = false; // &lt;- notify }; Internal.prototype = webpack_require(227)($Promise.prototype, { // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected) then: function then(onFulfilled, onRejected) { var reaction = newPromiseCapability(speciesConstructor(this, $Promise)); reaction.ok = typeof onFulfilled == ‘function’ ? onFulfilled : true; reaction.fail = typeof onRejected == ‘function’ &amp;&amp; onRejected; reaction.domain = isNode ? process.domain : undefined; this._c.push(reaction); if (this._a) this._a.push(reaction); if (this._s) notify(this, false); return reaction.promise; }, // 25.4.5.1 Promise.prototype.catch(onRejected) ‘catch’: function (onRejected) { return this.then(undefined, onRejected); } }); OwnPromiseCapability = function () { var promise = new Internal(); this.promise = promise; this.resolve = ctx($resolve, promise, 1); this.reject = ctx($reject, promise, 1); }; newPromiseCapabilityModule.f = newPromiseCapability = function (C) { return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C); }; } $export($export.G + $export.W + $export.F !USE_NATIVE, { Promise: $Promise }); webpack_require(33)($Promise, PROMISE); webpack_require(201)(PROMISE); Wrapper = webpack_require(16)[PROMISE]; // statics $export($export.S + $export.F !USE_NATIVE, PROMISE, { // 25.4.4.5 Promise.reject(r) reject: function reject(r) { var capability = newPromiseCapability(this); var $$reject = capability.reject; $$reject(r); return capability.promise; } }); $export($export.S + $export.F (LIBRARY || !USE_NATIVE), PROMISE, { // 25.4.4.6 Promise.resolve(x) resolve: function resolve(x) { return promiseResolve(LIBRARY &amp;&amp; this === Wrapper ? $Promise : this, x); } }); $export($export.S + $export.F !(USE_NATIVE &amp;&amp; webpack_require(174)(function (iter) { $Promise.all(iter)‘catch’; })), PROMISE, { // 25.4.4.1 Promise.all(iterable) all: function all(iterable) { var C = this; var capability = newPromiseCapability(C); var resolve = capability.resolve; var reject = capability.reject; var result = perform(function () { var values = []; var index = 0; var remaining = 1; forOf(iterable, false, function (promise) { var $index = index++; var alreadyCalled = false; values.push(undefined); remaining++; C.resolve(promise).then(function (value) { if (alreadyCalled) return; alreadyCalled = true; values[$index] = value; –remaining || resolve(values); }, reject); }); –remaining || resolve(values); }); if (result.e) reject(result.v); return capability.promise; }, // 25.4.4.4 Promise.race(iterable) race: function race(iterable) { var C = this; var capability = newPromiseCapability(C); var reject = capability.reject; var result = perform(function () { forOf(iterable, false, function (promise) { C.resolve(promise).then(capability.resolve, reject); }); }); if (result.e) reject(result.v); return capability.promise; } });// }),/ 219 /// (function(module, exports) { module.exports = function (it, Constructor, name, forbiddenField) { if (!(it instanceof Constructor) || (forbiddenField !== undefined &amp;&amp; forbiddenField in it)) { throw TypeError(name + ‘: incorrect invocation!’); } return it; };// }),/ 220 /// (function(module, exports, webpack_require) { var ctx = webpack_require(30); var call = webpack_require(170); var isArrayIter = webpack_require(171); var anObject = webpack_require(19); var toLength = webpack_require(45); var getIterFn = webpack_require(173); var BREAK = {}; var RETURN = {}; var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) { var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable); var f = ctx(fn, that, entries ? 2 : 1); var index = 0; var length, step, iterator, result; if (typeof iterFn != ‘function’) throw TypeError(iterable + ‘ is not iterable!’); // fast case for arrays with default iterator if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length &gt; index; index++) { result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]); if (result === BREAK || result === RETURN) return result; } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) { result = call(iterator, f, step.value, entries); if (result === BREAK || result === RETURN) return result; } }; exports.BREAK = BREAK; exports.RETURN = RETURN;// }),/ 221 /// (function(module, exports, webpack_require) { var ctx = webpack_require(30); var invoke = webpack_require(85); var html = webpack_require(55); var cel = webpack_require(22); var global = webpack_require(11); var process = global.process; var setTask = global.setImmediate; var clearTask = global.clearImmediate; var MessageChannel = global.MessageChannel; var Dispatch = global.Dispatch; var counter = 0; var queue = {}; var ONREADYSTATECHANGE = ‘onreadystatechange’; var defer, channel, port; var run = function () { var id = +this; // eslint-disable-next-line no-prototype-builtins if (queue.hasOwnProperty(id)) { var fn = queue[id]; delete queue[id]; fn(); } }; var listener = function (event) { run.call(event.data); }; // Node.js 0.9+ &amp; IE10+ has setImmediate, otherwise: if (!setTask || !clearTask) { setTask = function setImmediate(fn) { var args = []; var i = 1; while (arguments.length &gt; i) args.push(arguments[i++]); queue[++counter] = function () { // eslint-disable-next-line no-new-func invoke(typeof fn == ‘function’ ? fn : Function(fn), args); }; defer(counter); return counter; }; clearTask = function clearImmediate(id) { delete queue[id]; }; // Node.js 0.8- if (webpack_require(42)(process) == ‘process’) { defer = function (id) { process.nextTick(ctx(run, id, 1)); }; // Sphere (JS game engine) Dispatch API } else if (Dispatch &amp;&amp; Dispatch.now) { defer = function (id) { Dispatch.now(ctx(run, id, 1)); }; // Browsers with MessageChannel, includes WebWorkers } else if (MessageChannel) { channel = new MessageChannel(); port = channel.port2; channel.port1.onmessage = listener; defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers // IE8 has postMessage, but it’s sync &amp; typeof its postMessage is ‘object’ } else if (global.addEventListener &amp;&amp; typeof postMessage == ‘function’ &amp;&amp; !global.importScripts) { defer = function (id) { global.postMessage(id + ‘’, ‘‘); }; global.addEventListener(‘message’, listener, false); // IE8- } else if (ONREADYSTATECHANGE in cel(‘script’)) { defer = function (id) { html.appendChild(cel(‘script’))[ONREADYSTATECHANGE] = function () { html.removeChild(this); run.call(id); }; }; // Rest old browsers } else { defer = function (id) { setTimeout(ctx(run, id, 1), 0); }; } } module.exports = { set: setTask, clear: clearTask };/*/ }),/ 222 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var macrotask = webpack_require(221).set; var Observer = global.MutationObserver || global.WebKitMutationObserver; var process = global.process; var Promise = global.Promise; var isNode = webpack_require(42)(process) == ‘process’; module.exports = function () { var head, last, notify; var flush = function () { var parent, fn; if (isNode &amp;&amp; (parent = process.domain)) parent.exit(); while (head) { fn = head.fn; head = head.next; try { fn(); } catch (e) { if (head) notify(); else last = undefined; throw e; } } last = undefined; if (parent) parent.enter(); }; // Node.js if (isNode) { notify = function () { process.nextTick(flush); }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339 } else if (Observer &amp;&amp; !(global.navigator &amp;&amp; global.navigator.standalone)) { var toggle = true; var node = document.createTextNode(‘’); new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new notify = function () { node.data = toggle = !toggle; }; // environments with maybe non-completely correct, but existent Promise } else if (Promise &amp;&amp; Promise.resolve) { // Promise.resolve without an argument throws an error in LG WebOS 2 var promise = Promise.resolve(undefined); notify = function () { promise.then(flush); }; // for other environments - macrotask based on: // - setImmediate // - MessageChannel // - window.postMessag // - onreadystatechange // - setTimeout } else { notify = function () { // strange IE + webpack dev server bug - use .call(global) macrotask.call(global, flush); }; } return function (fn) { var task = { fn: fn, next: undefined }; if (last) last.next = task; if (!head) { head = task; notify(); } last = task; }; };// }),/ 223 /// (function(module, exports, webpack_require) { ‘use strict’; // 25.4.1.5 NewPromiseCapability(C) var aFunction = webpack_require(31); function PromiseCapability(C) { var resolve, reject; this.promise = new C(function ($$resolve, $$reject) { if (resolve !== undefined || reject !== undefined) throw TypeError(‘Bad Promise constructor’); resolve = $$resolve; reject = $$reject; }); this.resolve = aFunction(resolve); this.reject = aFunction(reject); } module.exports.f = function (C) { return new PromiseCapability(C); };// }),/ 224 /// (function(module, exports) { module.exports = function (exec) { try { return { e: false, v: exec() }; } catch (e) { return { e: true, v: e }; } };// }),/ 225 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var navigator = global.navigator; module.exports = navigator &amp;&amp; navigator.userAgent || ‘’;// }),/ 226 /// (function(module, exports, webpack_require) { var anObject = webpack_require(19); var isObject = webpack_require(20); var newPromiseCapability = webpack_require(223); module.exports = function (C, x) { anObject(C); if (isObject(x) &amp;&amp; x.constructor === C) return x; var promiseCapability = newPromiseCapability.f(C); var resolve = promiseCapability.resolve; resolve(x); return promiseCapability.promise; };// }),/ 227 /// (function(module, exports, webpack_require) { var redefine = webpack_require(25); module.exports = function (target, src, safe) { for (var key in src) redefine(target, key, src[key], safe); return target; };// }),/ 228 /// (function(module, exports, webpack_require) { ‘use strict’; var strong = webpack_require(229); var validate = webpack_require(230); var MAP = ‘Map’; // 23.1 Map Objects module.exports = webpack_require(231)(MAP, function (get) { return function Map() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.1.3.6 Map.prototype.get(key) get: function get(key) { var entry = strong.getEntry(validate(this, MAP), key); return entry &amp;&amp; entry.v; }, // 23.1.3.9 Map.prototype.set(key, value) set: function set(key, value) { return strong.def(validate(this, MAP), key === 0 ? 0 : key, value); } }, strong, true);// }),/ 229 /// (function(module, exports, webpack_require) { ‘use strict’; var dP = webpack_require(18).f; var create = webpack_require(53); var redefineAll = webpack_require(227); var ctx = webpack_require(30); var anInstance = webpack_require(219); var forOf = webpack_require(220); var $iterDefine = webpack_require(136); var step = webpack_require(203); var setSpecies = webpack_require(201); var DESCRIPTORS = webpack_require(13); var fastKey = webpack_require(32).fastKey; var validate = webpack_require(230); var SIZE = DESCRIPTORS ? ‘_s’ : ‘size’; var getEntry = function (that, key) { // fast case var index = fastKey(key); var entry; if (index !== ‘F’) return that._i[index]; // frozen object case for (entry = that._f; entry; entry = entry.n) { if (entry.k == key) return entry; } }; module.exports = { getConstructor: function (wrapper, NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, NAME, ‘_i’); that._t = NAME; // collection type that._i = create(null); // index that._f = undefined; // first entry that._l = undefined; // last entry that[SIZE] = 0; // size if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); }); redefineAll(C.prototype, { // 23.1.3.1 Map.prototype.clear() // 23.2.3.2 Set.prototype.clear() clear: function clear() { for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) { entry.r = true; if (entry.p) entry.p = entry.p.n = undefined; delete data[entry.i]; } that._f = that._l = undefined; that[SIZE] = 0; }, // 23.1.3.3 Map.prototype.delete(key) // 23.2.3.4 Set.prototype.delete(value) ‘delete’: function (key) { var that = validate(this, NAME); var entry = getEntry(that, key); if (entry) { var next = entry.n; var prev = entry.p; delete that._i[entry.i]; entry.r = true; if (prev) prev.n = next; if (next) next.p = prev; if (that._f == entry) that._f = next; if (that._l == entry) that._l = prev; that[SIZE]–; } return !!entry; }, // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined) // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined) forEach: function forEach(callbackfn / , that = undefined /) { validate(this, NAME); var f = ctx(callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined, 3); var entry; while (entry = entry ? entry.n : this._f) { f(entry.v, entry.k, this); // revert to the last existing entry while (entry &amp;&amp; entry.r) entry = entry.p; } }, // 23.1.3.7 Map.prototype.has(key) // 23.2.3.7 Set.prototype.has(value) has: function has(key) { return !!getEntry(validate(this, NAME), key); } }); if (DESCRIPTORS) dP(C.prototype, ‘size’, { get: function () { return validate(this, NAME)[SIZE]; } }); return C; }, def: function (that, key, value) { var entry = getEntry(that, key); var prev, index; // change existing entry if (entry) { entry.v = value; // create new entry } else { that._l = entry = { i: index = fastKey(key, true), // &lt;- index k: key, // &lt;- key v: value, // &lt;- value p: prev = that._l, // &lt;- previous entry n: undefined, // &lt;- next entry r: false // &lt;- removed }; if (!that._f) that._f = entry; if (prev) prev.n = entry; that[SIZE]++; // add to index if (index !== ‘F’) that._i[index] = entry; } return that; }, getEntry: getEntry, setStrong: function (C, NAME, IS_MAP) { // add .keys, .values, .entries, [@@iterator] // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11 $iterDefine(C, NAME, function (iterated, kind) { this._t = validate(iterated, NAME); // target this._k = kind; // kind this._l = undefined; // previous }, function () { var that = this; var kind = that._k; var entry = that._l; // revert to the last existing entry while (entry &amp;&amp; entry.r) entry = entry.p; // get next entry if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) { // or finish the iteration that._t = undefined; return step(1); } // return step by kind if (kind == ‘keys’) return step(0, entry.k); if (kind == ‘values’) return step(0, entry.v); return step(0, [entry.k, entry.v]); }, IS_MAP ? ‘entries’ : ‘values’, !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2 setSpecies(NAME); } };// }),/ 230 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); module.exports = function (it, TYPE) { if (!isObject(it) || it._t !== TYPE) throw TypeError(‘Incompatible receiver, ‘ + TYPE + ‘ required!’); return it; };// }),/ 231 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var $export = webpack_require(15); var redefine = webpack_require(25); var redefineAll = webpack_require(227); var meta = webpack_require(32); var forOf = webpack_require(220); var anInstance = webpack_require(219); var isObject = webpack_require(20); var fails = webpack_require(14); var $iterDetect = webpack_require(174); var setToStringTag = webpack_require(33); var inheritIfRequired = webpack_require(95); module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) { var Base = global[NAME]; var C = Base; var ADDER = IS_MAP ? ‘set’ : ‘add’; var proto = C &amp;&amp; C.prototype; var O = {}; var fixMethod = function (KEY) { var fn = proto[KEY]; redefine(proto, KEY, KEY == ‘delete’ ? function (a) { return IS_WEAK &amp;&amp; !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘has’ ? function has(a) { return IS_WEAK &amp;&amp; !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘get’ ? function get(a) { return IS_WEAK &amp;&amp; !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘add’ ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; } : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; } ); }; if (typeof C != ‘function’ || !(IS_WEAK || proto.forEach &amp;&amp; !fails(function () { new C().entries().next(); }))) { // create collection constructor C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER); redefineAll(C.prototype, methods); meta.NEED = true; } else { var instance = new C(); // early implementations not supports chaining var HASNT_CHAINING = instanceADDER != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); }); // most early implementations doesn’t supports iterables, most modern - not close it correctly var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new // for early implementations -0 and +0 not the same var BUGGY_ZERO = !IS_WEAK &amp;&amp; fails(function () { // V8 ~ Chromium 42- fails only with 5+ elements var $instance = new C(); var index = 5; while (index–) $instanceADDER; return !$instance.has(-0); }); if (!ACCEPT_ITERABLES) { C = wrapper(function (target, iterable) { anInstance(target, C, NAME); var that = inheritIfRequired(new Base(), target, C); if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); return that; }); C.prototype = proto; proto.constructor = C; } if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) { fixMethod(‘delete’); fixMethod(‘has’); IS_MAP &amp;&amp; fixMethod(‘get’); } if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method if (IS_WEAK &amp;&amp; proto.clear) delete proto.clear; } setToStringTag(C, NAME); O[NAME] = C; $export($export.G + $export.W + $export.F (C != Base), O); if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP); return C; };/*/ }),/ 232 /// (function(module, exports, webpack_require) { ‘use strict’; var strong = webpack_require(229); var validate = webpack_require(230); var SET = ‘Set’; // 23.2 Set Objects module.exports = webpack_require(231)(SET, function (get) { return function Set() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.2.3.1 Set.prototype.add(value) add: function add(value) { return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value); } }, strong);// }),/ 233 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var each = webpack_require(181)(0); var redefine = webpack_require(25); var meta = webpack_require(32); var assign = webpack_require(76); var weak = webpack_require(234); var isObject = webpack_require(20); var validate = webpack_require(230); var NATIVE_WEAK_MAP = webpack_require(230); var IS_IE11 = !global.ActiveXObject &amp;&amp; ‘ActiveXObject’ in global; var WEAK_MAP = ‘WeakMap’; var getWeak = meta.getWeak; var isExtensible = Object.isExtensible; var uncaughtFrozenStore = weak.ufstore; var InternalMap; var wrapper = function (get) { return function WeakMap() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }; var methods = { // 23.3.3.3 WeakMap.prototype.get(key) get: function get(key) { if (isObject(key)) { var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key); return data ? data[this._i] : undefined; } }, // 23.3.3.5 WeakMap.prototype.set(key, value) set: function set(key, value) { return weak.def(validate(this, WEAK_MAP), key, value); } }; // 23.3 WeakMap Objects var $WeakMap = module.exports = webpack_require(231)(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix if (NATIVE_WEAK_MAP &amp;&amp; IS_IE11) { InternalMap = weak.getConstructor(wrapper, WEAK_MAP); assign(InternalMap.prototype, methods); meta.NEED = true; each([‘delete’, ‘has’, ‘get’, ‘set’], function (key) { var proto = $WeakMap.prototype; var method = proto[key]; redefine(proto, key, function (a, b) { // store frozen objects on internal weakmap shim if (isObject(a) &amp;&amp; !isExtensible(a)) { if (!this._f) this._f = new InternalMap(); var result = this._fkey; return key == ‘set’ ? this : result; // store all the rest on native weakmap } return method.call(this, a, b); }); }); }// }),/ 234 /// (function(module, exports, webpack_require) { ‘use strict’; var redefineAll = webpack_require(227); var getWeak = webpack_require(32).getWeak; var anObject = webpack_require(19); var isObject = webpack_require(20); var anInstance = webpack_require(219); var forOf = webpack_require(220); var createArrayMethod = webpack_require(181); var $has = webpack_require(12); var validate = webpack_require(230); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var id = 0; // fallback for uncaught frozen keys var uncaughtFrozenStore = function (that) { return that._l || (that._l = new UncaughtFrozenStore()); }; var UncaughtFrozenStore = function () { this.a = []; }; var findUncaughtFrozen = function (store, key) { return arrayFind(store.a, function (it) { return it[0] === key; }); }; UncaughtFrozenStore.prototype = { get: function (key) { var entry = findUncaughtFrozen(this, key); if (entry) return entry[1]; }, has: function (key) { return !!findUncaughtFrozen(this, key); }, set: function (key, value) { var entry = findUncaughtFrozen(this, key); if (entry) entry[1] = value; else this.a.push([key, value]); }, ‘delete’: function (key) { var index = arrayFindIndex(this.a, function (it) { return it[0] === key; }); if (~index) this.a.splice(index, 1); return !!~index; } }; module.exports = { getConstructor: function (wrapper, NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, NAME, ‘_i’); that._t = NAME; // collection type that._i = id++; // collection id that._l = undefined; // leak store for uncaught frozen objects if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); }); redefineAll(C.prototype, { // 23.3.3.2 WeakMap.prototype.delete(key) // 23.4.3.3 WeakSet.prototype.delete(value) ‘delete’: function (key) { if (!isObject(key)) return false; var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, NAME))‘delete’; return data &amp;&amp; $has(data, this._i) &amp;&amp; delete data[this._i]; }, // 23.3.3.4 WeakMap.prototype.has(key) // 23.4.3.4 WeakSet.prototype.has(value) has: function has(key) { if (!isObject(key)) return false; var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key); return data &amp;&amp; $has(data, this._i); } }); return C; }, def: function (that, key, value) { var data = getWeak(anObject(key), true); if (data === true) uncaughtFrozenStore(that).set(key, value); else data[that._i] = value; return that; }, ufstore: uncaughtFrozenStore };// }),/ 235 /// (function(module, exports, webpack_require) { ‘use strict’; var weak = webpack_require(234); var validate = webpack_require(230); var WEAK_SET = ‘WeakSet’; // 23.4 WeakSet Objects webpack_require(231)(WEAK_SET, function (get) { return function WeakSet() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.4.3.1 WeakSet.prototype.add(value) add: function add(value) { return weak.def(validate(this, WEAK_SET), value, true); } }, weak, false, true);// }),/ 236 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $typed = webpack_require(237); var buffer = webpack_require(238); var anObject = webpack_require(19); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); var isObject = webpack_require(20); var ArrayBuffer = webpack_require(11).ArrayBuffer; var speciesConstructor = webpack_require(217); var $ArrayBuffer = buffer.ArrayBuffer; var $DataView = buffer.DataView; var $isView = $typed.ABV &amp;&amp; ArrayBuffer.isView; var $slice = $ArrayBuffer.prototype.slice; var VIEW = $typed.VIEW; var ARRAY_BUFFER = ‘ArrayBuffer’; $export($export.G + $export.W + $export.F (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer }); $export($export.S + $export.F !$typed.CONSTR, ARRAY_BUFFER, { // 24.1.3.1 ArrayBuffer.isView(arg) isView: function isView(it) { return $isView &amp;&amp; $isView(it) || isObject(it) &amp;&amp; VIEW in it; } }); $export($export.P + $export.U + $export.F webpack_require(14)(function () { return !new $ArrayBuffer(2).slice(1, undefined).byteLength; }), ARRAY_BUFFER, { // 24.1.4.3 ArrayBuffer.prototype.slice(start, end) slice: function slice(start, end) { if ($slice !== undefined &amp;&amp; end === undefined) return $slice.call(anObject(this), start); // FF fix var len = anObject(this).byteLength; var first = toAbsoluteIndex(start, len); var fin = toAbsoluteIndex(end === undefined ? len : end, len); var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first)); var viewS = new $DataView(this); var viewT = new $DataView(result); var index = 0; while (first &lt; fin) { viewT.setUint8(index++, viewS.getUint8(first++)); } return result; } }); webpack_require(201)(ARRAY_BUFFER);/*/ }),/ 237 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var hide = webpack_require(17); var uid = webpack_require(26); var TYPED = uid(‘typed_array’); var VIEW = uid(‘view’); var ABV = !!(global.ArrayBuffer &amp;&amp; global.DataView); var CONSTR = ABV; var i = 0; var l = 9; var Typed; var TypedArrayConstructors = ( ‘Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array’ ).split(‘,’); while (i &lt; l) { if (Typed = global[TypedArrayConstructors[i++]]) { hide(Typed.prototype, TYPED, true); hide(Typed.prototype, VIEW, true); } else CONSTR = false; } module.exports = { ABV: ABV, CONSTR: CONSTR, TYPED: TYPED, VIEW: VIEW };// }),/ 238 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var DESCRIPTORS = webpack_require(13); var LIBRARY = webpack_require(29); var $typed = webpack_require(237); var hide = webpack_require(17); var redefineAll = webpack_require(227); var fails = webpack_require(14); var anInstance = webpack_require(219); var toInteger = webpack_require(46); var toLength = webpack_require(45); var toIndex = webpack_require(239); var gOPN = webpack_require(57).f; var dP = webpack_require(18).f; var arrayFill = webpack_require(197); var setToStringTag = webpack_require(33); var ARRAY_BUFFER = ‘ArrayBuffer’; var DATA_VIEW = ‘DataView’; var PROTOTYPE = ‘prototype’; var WRONG_LENGTH = ‘Wrong length!’; var WRONG_INDEX = ‘Wrong index!’; var $ArrayBuffer = global[ARRAY_BUFFER]; var $DataView = global[DATA_VIEW]; var Math = global.Math; var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names var Infinity = global.Infinity; var BaseBuffer = $ArrayBuffer; var abs = Math.abs; var pow = Math.pow; var floor = Math.floor; var log = Math.log; var LN2 = Math.LN2; var BUFFER = ‘buffer’; var BYTE_LENGTH = ‘byteLength’; var BYTE_OFFSET = ‘byteOffset’; var $BUFFER = DESCRIPTORS ? ‘_b’ : BUFFER; var $LENGTH = DESCRIPTORS ? ‘_l’ : BYTE_LENGTH; var $OFFSET = DESCRIPTORS ? ‘_o’ : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754 function packIEEE754(value, mLen, nBytes) { var buffer = new Array(nBytes); var eLen = nBytes 8 - mLen - 1; var eMax = (1 &lt;&lt; eLen) - 1; var eBias = eMax &gt;&gt; 1; var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0; var i = 0; var s = value &lt; 0 || value === 0 &amp;&amp; 1 / value &lt; 0 ? 1 : 0; var e, m, c; value = abs(value); // eslint-disable-next-line no-self-compare if (value != value || value === Infinity) { // eslint-disable-next-line no-self-compare m = value != value ? 1 : 0; e = eMax; } else { e = floor(log(value) / LN2); if (value (c = pow(2, -e)) &lt; 1) { e–; c = 2; } if (e + eBias &gt;= 1) { value += rt / c; } else { value += rt pow(2, 1 - eBias); } if (value c &gt;= 2) { e++; c /= 2; } if (e + eBias &gt;= eMax) { m = 0; e = eMax; } else if (e + eBias &gt;= 1) { m = (value c - 1) pow(2, mLen); e = e + eBias; } else { m = value pow(2, eBias - 1) pow(2, mLen); e = 0; } } for (; mLen &gt;= 8; buffer[i++] = m &amp; 255, m /= 256, mLen -= 8); e = e &lt;&lt; mLen | m; eLen += mLen; for (; eLen &gt; 0; buffer[i++] = e &amp; 255, e /= 256, eLen -= 8); buffer[–i] |= s 128; return buffer; } function unpackIEEE754(buffer, mLen, nBytes) { var eLen = nBytes 8 - mLen - 1; var eMax = (1 &lt;&lt; eLen) - 1; var eBias = eMax &gt;&gt; 1; var nBits = eLen - 7; var i = nBytes - 1; var s = buffer[i–]; var e = s &amp; 127; var m; s &gt;&gt;= 7; for (; nBits &gt; 0; e = e 256 + buffer[i], i–, nBits -= 8); m = e &amp; (1 &lt;&lt; -nBits) - 1; e &gt;&gt;= -nBits; nBits += mLen; for (; nBits &gt; 0; m = m 256 + buffer[i], i–, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) m pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] &lt;&lt; 24 | bytes[2] &lt;&lt; 16 | bytes[1] &lt;&lt; 8 | bytes[0]; } function packI8(it) { return [it &amp; 0xff]; } function packI16(it) { return [it &amp; 0xff, it &gt;&gt; 8 &amp; 0xff]; } function packI32(it) { return [it &amp; 0xff, it &gt;&gt; 8 &amp; 0xff, it &gt;&gt; 16 &amp; 0xff, it &gt;&gt; 24 &amp; 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes &gt; view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes &gt; view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i &lt; bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset &lt; 0 || offset &gt; bufferLength) throw RangeError(‘Wrong offset!’); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength &gt; bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, ‘_l’); addGetter($DataView, BUFFER, ‘_b’); addGetter($DataView, BYTE_LENGTH, ‘_l’); addGetter($DataView, BYTE_OFFSET, ‘_o’); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] &lt;&lt; 24 &gt;&gt; 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset / , littleEndian /) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] &lt;&lt; 8 | bytes[0]) &lt;&lt; 16 &gt;&gt; 16; }, getUint16: function getUint16(byteOffset / , littleEndian /) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] &lt;&lt; 8 | bytes[0]; }, getInt32: function getInt32(byteOffset / , littleEndian /) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset / , littleEndian /) { return unpackI32(get(this, 4, byteOffset, arguments[1])) &gt;&gt;&gt; 0; }, getFloat32: function getFloat32(byteOffset / , littleEndian /) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset / , littleEndian /) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value / , littleEndian /) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value / , littleEndian /) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value / , littleEndian /) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length &gt; j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value &lt;&lt; 24 &gt;&gt; 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value &lt;&lt; 24 &gt;&gt; 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView;/*/ }),/ 239 /// (function(module, exports, webpack_require) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = webpack_require(46); var toLength = webpack_require(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError(‘Wrong length!’); return length; };// }),/ 240 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); $export($export.G + $export.W + $export.F !webpack_require(237).ABV, { DataView: webpack_require(238).DataView });/*/ }),/ 241 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int8’, 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 242 /// (function(module, exports, webpack_require) { ‘use strict’; if (webpack_require(13)) { var LIBRARY = webpack_require(29); var global = webpack_require(11); var fails = webpack_require(14); var $export = webpack_require(15); var $typed = webpack_require(237); var $buffer = webpack_require(238); var ctx = webpack_require(30); var anInstance = webpack_require(219); var propertyDesc = webpack_require(24); var hide = webpack_require(17); var redefineAll = webpack_require(227); var toInteger = webpack_require(46); var toLength = webpack_require(45); var toIndex = webpack_require(239); var toAbsoluteIndex = webpack_require(47); var toPrimitive = webpack_require(23); var has = webpack_require(12); var classof = webpack_require(82); var isObject = webpack_require(20); var toObject = webpack_require(65); var isArrayIter = webpack_require(171); var create = webpack_require(53); var getPrototypeOf = webpack_require(66); var gOPN = webpack_require(57).f; var getIterFn = webpack_require(173); var uid = webpack_require(26); var wks = webpack_require(34); var createArrayMethod = webpack_require(181); var createArrayIncludes = webpack_require(44); var speciesConstructor = webpack_require(217); var ArrayIterators = webpack_require(202); var Iterators = webpack_require(137); var $iterDetect = webpack_require(174); var setSpecies = webpack_require(201); var arrayFill = webpack_require(197); var arrayCopyWithin = webpack_require(194); var $DP = webpack_require(18); var $GOPD = webpack_require(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = ‘ArrayBuffer’; var SHARED_BUFFER = ‘Shared’ + ARRAY_BUFFER; var BYTES_PER_ELEMENT = ‘BYTES_PER_ELEMENT’; var PROTOTYPE = ‘prototype’; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks(‘iterator’); var TAG = wks(‘toStringTag’); var TYPED_CONSTRUCTOR = uid(‘typed_constructor’); var DEF_CONSTRUCTOR = uid(‘def_constructor’); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = ‘Wrong length!’; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array &amp;&amp; !!Uint8Array[PROTOTYPE].set &amp;&amp; fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset &lt; 0 || offset % BYTES) throw RangeError(‘Wrong offset!’); return offset; }; var validate = function (it) { if (isObject(it) &amp;&amp; TYPED_ARRAY in it) return it; throw TypeError(it + ‘ is not a typed array!’); }; var allocate = function (C, length) { if (!(isObject(C) &amp;&amp; TYPED_CONSTRUCTOR in C)) { throw TypeError(‘It is not a typed array constructor!’); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length &gt; index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source / , mapfn, thisArg /) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen &gt; 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined &amp;&amp; !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping &amp;&amp; aLen &gt; 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length &gt; i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/ …items /) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length &gt; index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array &amp;&amp; fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start / , end /) { return arrayCopyWithin.call(validate(this), target, start, arguments.length &gt; 2 ? arguments[2] : undefined); }, every: function every(callbackfn / , thisArg /) { return arrayEvery(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, fill: function fill(value / , start, end /) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn / , thisArg /) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined)); }, find: function find(predicate / , thisArg /) { return arrayFind(validate(this), predicate, arguments.length &gt; 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate / , thisArg /) { return arrayFindIndex(validate(this), predicate, arguments.length &gt; 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn / , thisArg /) { arrayForEach(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement / , fromIndex /) { return arrayIndexOf(validate(this), searchElement, arguments.length &gt; 1 ? arguments[1] : undefined); }, includes: function includes(searchElement / , fromIndex /) { return arrayIncludes(validate(this), searchElement, arguments.length &gt; 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement / , fromIndex /) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn / , thisArg /) { return $map(validate(this), mapfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn / , initialValue /) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn / , initialValue /) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index &lt; middle) { value = that[index]; that[index++] = that[–length]; that[length] = value; } return that; }, some: function some(callbackfn / , thisArg /) { return arraySome(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike / , offset /) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset &gt; length) throw RangeError(WRONG_LENGTH); while (index &lt; len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) &amp;&amp; target[TYPED_ARRAY] &amp;&amp; typeof key != ‘symbol’ &amp;&amp; key in target &amp;&amp; String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) &amp;&amp; isObject(desc) &amp;&amp; has(desc, ‘value’) &amp;&amp; !has(desc, ‘get’) &amp;&amp; !has(desc, ‘set’) // TODO: add validation descriptor w/o calling accessors &amp;&amp; !desc.configurable &amp;&amp; (!has(desc, ‘writable’) || desc.writable) &amp;&amp; (!has(desc, ‘enumerable’) || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F !ALL_CONSTRUCTORS, ‘Object’, { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { / noop / }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, ‘buffer’, ‘b’); addGetter($TypedArrayPrototype$, ‘byteOffset’, ‘o’); addGetter($TypedArrayPrototype$, ‘byteLength’, ‘l’); addGetter($TypedArrayPrototype$, ‘length’, ‘e’); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? ‘Clamped’ : ‘’) + ‘Array’; var GETTER = ‘get’ + KEY; var SETTER = ‘set’ + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray &amp;&amp; getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray &amp;&amp; TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) &lt; 0 ? 0 : value &gt; 0xff ? 0xff : value &amp; 0xff; data.vSETTER; }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, ‘_d’); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength &lt; 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) BYTES; if (byteLength + offset &gt; $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, ‘_d’, { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index &lt; length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, ‘constructor’, TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // ws module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator &amp;&amp; ($nativeIterator.name == ‘values’ || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY &amp;&amp; TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY &amp;&amp; !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { / empty / };/*/ }),/ 243 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint8’, 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 244 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint8’, 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true);// }),/ 245 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int16’, 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 246 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint16’, 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 247 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int32’, 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 248 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint32’, 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 249 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Float32’, 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 250 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Float64’, 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 251 /// (function(module, exports, webpack_require) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = webpack_require(15); var aFunction = webpack_require(31); var anObject = webpack_require(19); var rApply = (webpack_require(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F !webpack_require(14)(function () { rApply(function () { / empty / }); }), ‘Reflect’, { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } });/*/ }),/ 252 /// (function(module, exports, webpack_require) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = webpack_require(15); var create = webpack_require(53); var aFunction = webpack_require(31); var anObject = webpack_require(19); var isObject = webpack_require(20); var fails = webpack_require(14); var bind = webpack_require(84); var rConstruct = (webpack_require(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as new.target, but does not create this from it var NEW_TARGET_BUG = fails(function () { function F() { / empty / } return !(rConstruct(function () { / empty / }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { / empty / }); }); $export($export.S + $export.F (NEW_TARGET_BUG || ARGS_BUG), ‘Reflect’, { construct: function construct(Target, args / , newTarget /) { aFunction(Target); anObject(args); var newTarget = arguments.length &lt; 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG &amp;&amp; !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } });/*/ }),/ 253 /// (function(module, exports, webpack_require) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = webpack_require(18); var $export = webpack_require(15); var anObject = webpack_require(19); var toPrimitive = webpack_require(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F webpack_require(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), ‘Reflect’, { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } });/*/ }),/ 254 /// (function(module, exports, webpack_require) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = webpack_require(15); var gOPD = webpack_require(58).f; var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc &amp;&amp; !desc.configurable ? false : delete target[propertyKey]; } });// }),/ 255 /// (function(module, exports, webpack_require) { ‘use strict’; // 26.1.5 Reflect.enumerate(target) var $export = webpack_require(15); var anObject = webpack_require(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; webpack_require(138)(Enumerate, ‘Object’, function () { var that = this; var keys = that._k; var key; do { if (that._i &gt;= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, ‘Reflect’, { enumerate: function enumerate(target) { return new Enumerate(target); } });// }),/ 256 /// (function(module, exports, webpack_require) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = webpack_require(58); var getPrototypeOf = webpack_require(66); var has = webpack_require(12); var $export = webpack_require(15); var isObject = webpack_require(20); var anObject = webpack_require(19); function get(target, propertyKey / , receiver /) { var receiver = arguments.length &lt; 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, ‘value’) ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, ‘Reflect’, { get: get });// }),/ 257 /// (function(module, exports, webpack_require) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = webpack_require(58); var $export = webpack_require(15); var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } });// }),/ 258 /// (function(module, exports, webpack_require) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = webpack_require(15); var getProto = webpack_require(66); var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } });// }),/ 259 /// (function(module, exports, webpack_require) { // 26.1.9 Reflect.has(target, propertyKey) var $export = webpack_require(15); $export($export.S, ‘Reflect’, { has: function has(target, propertyKey) { return propertyKey in target; } });// }),/ 260 /// (function(module, exports, webpack_require) { // 26.1.10 Reflect.isExtensible(target) var $export = webpack_require(15); var anObject = webpack_require(19); var $isExtensible = Object.isExtensible; $export($export.S, ‘Reflect’, { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } });// }),/ 261 /// (function(module, exports, webpack_require) { // 26.1.11 Reflect.ownKeys(target) var $export = webpack_require(15); $export($export.S, ‘Reflect’, { ownKeys: webpack_require(262) });// }),/ 262 /// (function(module, exports, webpack_require) { // all object keys, includes non-enumerable and symbols var gOPN = webpack_require(57); var gOPS = webpack_require(50); var anObject = webpack_require(19); var Reflect = webpack_require(11).Reflect; module.exports = Reflect &amp;&amp; Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; };// }),/ 263 /// (function(module, exports, webpack_require) { // 26.1.12 Reflect.preventExtensions(target) var $export = webpack_require(15); var anObject = webpack_require(19); var $preventExtensions = Object.preventExtensions; $export($export.S, ‘Reflect’, { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } });// }),/ 264 /// (function(module, exports, webpack_require) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = webpack_require(18); var gOPD = webpack_require(58); var getPrototypeOf = webpack_require(66); var has = webpack_require(12); var $export = webpack_require(15); var createDesc = webpack_require(24); var anObject = webpack_require(19); var isObject = webpack_require(20); function set(target, propertyKey, V / , receiver /) { var receiver = arguments.length &lt; 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, ‘value’)) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, ‘Reflect’, { set: set });// }),/ 265 /// (function(module, exports, webpack_require) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = webpack_require(15); var setProto = webpack_require(80); if (setProto) $export($export.S, ‘Reflect’, { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } });// }),/ 266 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/Array.prototype.includes var $export = webpack_require(15); var $includes = webpack_require(44)(true); $export($export.P, ‘Array’, { includes: function includes(el / , fromIndex = 0 /) { return $includes(this, el, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(‘includes’);// }),/ 267 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = webpack_require(15); var flattenIntoArray = webpack_require(268); var toObject = webpack_require(65); var toLength = webpack_require(45); var aFunction = webpack_require(31); var arraySpeciesCreate = webpack_require(182); $export($export.P, ‘Array’, { flatMap: function flatMap(callbackfn / , thisArg /) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); webpack_require(195)(‘flatMap’);// }),/ 268 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = webpack_require(52); var isObject = webpack_require(20); var toLength = webpack_require(45); var ctx = webpack_require(30); var IS_CONCAT_SPREADABLE = webpack_require(34)(‘isConcatSpreadable’); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex &lt; sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable &amp;&amp; depth &gt; 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex &gt;= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray;// }),/ 269 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = webpack_require(15); var flattenIntoArray = webpack_require(268); var toObject = webpack_require(65); var toLength = webpack_require(45); var toInteger = webpack_require(46); var arraySpeciesCreate = webpack_require(182); $export($export.P, ‘Array’, { flatten: function flatten(/ depthArg = 1 /) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); webpack_require(195)(‘flatten’);// }),/ 270 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/mathiasbynens/String.prototype.at var $export = webpack_require(15); var $at = webpack_require(135)(true); $export($export.P, ‘String’, { at: function at(pos) { return $at(this, pos); } });// }),/ 271 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-string-pad-start-end var $export = webpack_require(15); var $pad = webpack_require(272); var userAgent = webpack_require(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10.\d+(.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F WEBKIT_BUG, ‘String’, { padStart: function padStart(maxLength / , fillString = ‘ ‘ /) { return $pad(this, maxLength, arguments.length &gt; 1 ? arguments[1] : undefined, true); } });/*/ }),/ 272 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = webpack_require(45); var repeat = webpack_require(98); var defined = webpack_require(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ‘ ‘ : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength &lt;= stringLength || fillStr == ‘’) return S; var fillLen = intMaxLength - stringLength; var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length)); if (stringFiller.length &gt; fillLen) stringFiller = stringFiller.slice(0, fillLen); return left ? stringFiller + S : S + stringFiller; };// }),/ 273 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-string-pad-start-end var $export = webpack_require(15); var $pad = webpack_require(272); var userAgent = webpack_require(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10.\d+(.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F WEBKIT_BUG, ‘String’, { padEnd: function padEnd(maxLength / , fillString = ‘ ‘ /) { return $pad(this, maxLength, arguments.length &gt; 1 ? arguments[1] : undefined, false); } });/*/ }),/ 274 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/sebmarkbage/ecmascript-string-left-right-trim webpack_require(90)(‘trimLeft’, function ($trim) { return function trimLeft() { return $trim(this, 1); }; }, ‘trimStart’);// }),/ 275 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/sebmarkbage/ecmascript-string-left-right-trim webpack_require(90)(‘trimRight’, function ($trim) { return function trimRight() { return $trim(this, 2); }; }, ‘trimEnd’);// }),/ 276 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/String.prototype.matchAll/ var $export = webpack_require(15); var defined = webpack_require(43); var toLength = webpack_require(45); var isRegExp = webpack_require(142); var getFlags = webpack_require(205); var RegExpProto = RegExp.prototype; var $RegExpStringIterator = function (regexp, string) { this._r = regexp; this._s = string; }; webpack_require(138)($RegExpStringIterator, ‘RegExp String’, function next() { var match = this._r.exec(this._s); return { value: match, done: match === null }; }); $export($export.P, ‘String’, { matchAll: function matchAll(regexp) { defined(this); if (!isRegExp(regexp)) throw TypeError(regexp + ‘ is not a regexp!’); var S = String(this); var flags = ‘flags’ in RegExpProto ? String(regexp.flags) : getFlags.call(regexp); var rx = new RegExp(regexp.source, ~flags.indexOf(‘g’) ? flags : ‘g’ + flags); rx.lastIndex = toLength(regexp.lastIndex); return new $RegExpStringIterator(rx, S); } });// }),/ 277 /// (function(module, exports, webpack_require) { webpack_require(36)(‘asyncIterator’);// }),/ 278 /// (function(module, exports, webpack_require) { webpack_require(36)(‘observable’);// }),/ 279 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-getownpropertydescriptors var $export = webpack_require(15); var ownKeys = webpack_require(262); var toIObject = webpack_require(40); var gOPD = webpack_require(58); var createProperty = webpack_require(172); $export($export.S, ‘Object’, { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) { var O = toIObject(object); var getDesc = gOPD.f; var keys = ownKeys(O); var result = {}; var i = 0; var key, desc; while (keys.length &gt; i) { desc = getDesc(O, key = keys[i++]); if (desc !== undefined) createProperty(result, key, desc); } return result; } });// }),/ 280 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-values-entries var $export = webpack_require(15); var $values = webpack_require(281)(false); $export($export.S, ‘Object’, { values: function values(it) { return $values(it); } });// }),/ 281 /// (function(module, exports, webpack_require) { var getKeys = webpack_require(38); var toIObject = webpack_require(40); var isEnum = webpack_require(51).f; module.exports = function (isEntries) { return function (it) { var O = toIObject(it); var keys = getKeys(O); var length = keys.length; var i = 0; var result = []; var key; while (length &gt; i) if (isEnum.call(O, key = keys[i++])) { result.push(isEntries ? [key, O[key]] : O[key]); } return result; }; };// }),/ 282 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-values-entries var $export = webpack_require(15); var $entries = webpack_require(281)(true); $export($export.S, ‘Object’, { entries: function entries(it) { return $entries(it); } });// }),/ 283 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var aFunction = webpack_require(31); var $defineProperty = webpack_require(18); // B.2.2.2 Object.prototype.defineGetter(P, getter) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { defineGetter: function defineGetter(P, getter) { $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true }); } });// }),/ 284 /// (function(module, exports, webpack_require) { ‘use strict’; // Forced replacement prototype accessors methods module.exports = webpack_require(29) || !webpack_require(14)(function () { var K = Math.random(); // In FF throws only define methods // eslint-disable-next-line no-undef, no-useless-call defineSetter.call(null, K, function () { / empty / }); delete webpack_require(11)[K]; });// }),/ 285 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var aFunction = webpack_require(31); var $defineProperty = webpack_require(18); // B.2.2.3 Object.prototype.defineSetter(P, setter) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { defineSetter: function defineSetter(P, setter) { $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true }); } });// }),/ 286 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); var getPrototypeOf = webpack_require(66); var getOwnPropertyDescriptor = webpack_require(58).f; // B.2.2.4 Object.prototype.lookupGetter(P) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { lookupGetter: function lookupGetter(P) { var O = toObject(this); var K = toPrimitive(P, true); var D; do { if (D = getOwnPropertyDescriptor(O, K)) return D.get; } while (O = getPrototypeOf(O)); } });// }),/ 287 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); var getPrototypeOf = webpack_require(66); var getOwnPropertyDescriptor = webpack_require(58).f; // B.2.2.5 Object.prototype.lookupSetter(P) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { lookupSetter: function lookupSetter(P) { var O = toObject(this); var K = toPrimitive(P, true); var D; do { if (D = getOwnPropertyDescriptor(O, K)) return D.set; } while (O = getPrototypeOf(O)); } });// }),/ 288 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var $export = webpack_require(15); $export($export.P + $export.R, ‘Map’, { toJSON: webpack_require(289)(‘Map’) });// }),/ 289 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var classof = webpack_require(82); var from = webpack_require(290); module.exports = function (NAME) { return function toJSON() { if (classof(this) != NAME) throw TypeError(NAME + “#toJSON isn’t generic”); return from(this); }; };// }),/ 290 /// (function(module, exports, webpack_require) { var forOf = webpack_require(220); module.exports = function (iter, ITERATOR) { var result = []; forOf(iter, false, result.push, result, ITERATOR); return result; };// }),/ 291 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var $export = webpack_require(15); $export($export.P + $export.R, ‘Set’, { toJSON: webpack_require(289)(‘Set’) });// }),/ 292 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of webpack_require(293)(‘Map’);// }),/ 293 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-setmap-offrom/ var $export = webpack_require(15); module.exports = function (COLLECTION) { $export($export.S, COLLECTION, { of: function of() { var length = arguments.length; var A = new Array(length); while (length–) A[length] = arguments[length]; return new this(A); } }); };// }),/ 294 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of webpack_require(293)(‘Set’);// }),/ 295 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of webpack_require(293)(‘WeakMap’);// }),/ 296 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of webpack_require(293)(‘WeakSet’);// }),/ 297 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from webpack_require(298)(‘Map’);// }),/ 298 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-setmap-offrom/ var $export = webpack_require(15); var aFunction = webpack_require(31); var ctx = webpack_require(30); var forOf = webpack_require(220); module.exports = function (COLLECTION) { $export($export.S, COLLECTION, { from: function from(source / , mapFn, thisArg /) { var mapFn = arguments[1]; var mapping, A, n, cb; aFunction(this); mapping = mapFn !== undefined; if (mapping) aFunction(mapFn); if (source == undefined) return new this(); A = []; if (mapping) { n = 0; cb = ctx(mapFn, arguments[2], 2); forOf(source, false, function (nextItem) { A.push(cb(nextItem, n++)); }); } else { forOf(source, false, A.push, A); } return new this(A); } }); };// }),/ 299 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from webpack_require(298)(‘Set’);// }),/ 300 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from webpack_require(298)(‘WeakMap’);// }),/ 301 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from webpack_require(298)(‘WeakSet’);// }),/ 302 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-global var $export = webpack_require(15); $export($export.G, { global: webpack_require(11) });// }),/ 303 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-global var $export = webpack_require(15); $export($export.S, ‘System’, { global: webpack_require(11) });// }),/ 304 /// (function(module, exports, webpack_require) { // https://github.com/ljharb/proposal-is-error var $export = webpack_require(15); var cof = webpack_require(42); $export($export.S, ‘Error’, { isError: function isError(it) { return cof(it) === ‘Error’; } });// }),/ 305 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { clamp: function clamp(x, lower, upper) { return Math.min(upper, Math.max(lower, x)); } });// }),/ 306 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { DEG_PER_RAD: Math.PI / 180 });// }),/ 307 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var RAD_PER_DEG = 180 / Math.PI; $export($export.S, ‘Math’, { degrees: function degrees(radians) { return radians RAD_PER_DEG; } });/*/ }),/ 308 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var scale = webpack_require(309); var fround = webpack_require(121); $export($export.S, ‘Math’, { fscale: function fscale(x, inLow, inHigh, outLow, outHigh) { return fround(scale(x, inLow, inHigh, outLow, outHigh)); } });// }),/ 309 /// (function(module, exports) { // https://rwaldron.github.io/proposal-math-extensions/ module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) { if ( arguments.length === 0 // eslint-disable-next-line no-self-compare || x != x // eslint-disable-next-line no-self-compare || inLow != inLow // eslint-disable-next-line no-self-compare || inHigh != inHigh // eslint-disable-next-line no-self-compare || outLow != outLow // eslint-disable-next-line no-self-compare || outHigh != outHigh ) return NaN; if (x === Infinity || x === -Infinity) return x; return (x - inLow) (outHigh - outLow) / (inHigh - inLow) + outLow; };/*/ }),/ 310 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { iaddh: function iaddh(x0, x1, y0, y1) { var $x0 = x0 &gt;&gt;&gt; 0; var $x1 = x1 &gt;&gt;&gt; 0; var $y0 = y0 &gt;&gt;&gt; 0; return $x1 + (y1 &gt;&gt;&gt; 0) + (($x0 &amp; $y0 | ($x0 | $y0) &amp; ~($x0 + $y0 &gt;&gt;&gt; 0)) &gt;&gt;&gt; 31) | 0; } });// }),/ 311 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 &gt;&gt;&gt; 0; var $x1 = x1 &gt;&gt;&gt; 0; var $y0 = y0 &gt;&gt;&gt; 0; return $x1 - (y1 &gt;&gt;&gt; 0) - ((~$x0 &amp; $y0 | ~($x0 ^ $y0) &amp; $x0 - $y0 &gt;&gt;&gt; 0) &gt;&gt;&gt; 31) | 0; } });// }),/ 312 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u &amp; UINT16; var v0 = $v &amp; UINT16; var u1 = $u &gt;&gt; 16; var v1 = $v &gt;&gt; 16; var t = (u1 v0 &gt;&gt;&gt; 0) + (u0 v0 &gt;&gt;&gt; 16); return u1 v1 + (t &gt;&gt; 16) + ((u0 v1 &gt;&gt;&gt; 0) + (t &amp; UINT16) &gt;&gt; 16); } });// }),/ 313 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { RAD_PER_DEG: 180 / Math.PI });// }),/ 314 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, ‘Math’, { radians: function radians(degrees) { return degrees DEG_PER_RAD; } });/*/ }),/ 315 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { scale: webpack_require(309) });// }),/ 316 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u &amp; UINT16; var v0 = $v &amp; UINT16; var u1 = $u &gt;&gt;&gt; 16; var v1 = $v &gt;&gt;&gt; 16; var t = (u1 v0 &gt;&gt;&gt; 0) + (u0 v0 &gt;&gt;&gt; 16); return u1 v1 + (t &gt;&gt;&gt; 16) + ((u0 v1 &gt;&gt;&gt; 0) + (t &amp; UINT16) &gt;&gt;&gt; 16); } });// }),/ 317 /// (function(module, exports, webpack_require) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = webpack_require(15); $export($export.S, ‘Math’, { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x &gt; 0; } });// }),/ 318 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-promise-finally ‘use strict’; var $export = webpack_require(15); var core = webpack_require(16); var global = webpack_require(11); var speciesConstructor = webpack_require(217); var promiseResolve = webpack_require(226); $export($export.P + $export.R, ‘Promise’, { ‘finally’: function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == ‘function’; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } });// }),/ 319 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-promise-try var $export = webpack_require(15); var newPromiseCapability = webpack_require(223); var perform = webpack_require(224); $export($export.S, ‘Promise’, { ‘try’: function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } });// }),/ 320 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } });// }),/ 321 /// (function(module, exports, webpack_require) { var Map = webpack_require(228); var $export = webpack_require(15); var shared = webpack_require(28)(‘metadata’); var store = shared.store || (shared.store = new (webpack_require(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == ‘symbol’ ? it : String(it); }; var exp = function (O) { $export($export.S, ‘Reflect’, O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp };// }),/ 322 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target / , targetKey /) { var targetKey = arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap‘delete’) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata‘delete’; return !!targetMetadata.size || store‘delete’; } });// }),/ 323 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target / , targetKey /) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 324 /// (function(module, exports, webpack_require) { var Set = webpack_require(232); var from = webpack_require(290); var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target / , targetKey /) { return ordinaryMetadataKeys(anObject(target), arguments.length &lt; 2 ? undefined : toMetaKey(arguments[1])); } });// }),/ 325 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target / , targetKey /) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 326 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target / , targetKey /) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length &lt; 2 ? undefined : toMetaKey(arguments[1])); } });// }),/ 327 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target / , targetKey /) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 328 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target / , targetKey /) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 329 /// (function(module, exports, webpack_require) { var $metadata = webpack_require(321); var anObject = webpack_require(19); var aFunction = webpack_require(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } });// }),/ 330 /// (function(module, exports, webpack_require) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = webpack_require(15); var microtask = webpack_require(222)(); var process = webpack_require(11).process; var isNode = webpack_require(42)(process) == ‘process’; $export($export.G, { asap: function asap(fn) { var domain = isNode &amp;&amp; process.domain; microtask(domain ? domain.bind(fn) : fn); } });// }),/ 331 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/zenparsing/es-observable var $export = webpack_require(15); var global = webpack_require(11); var core = webpack_require(16); var microtask = webpack_require(222)(); var OBSERVABLE = webpack_require(34)(‘observable’); var aFunction = webpack_require(31); var anObject = webpack_require(19); var anInstance = webpack_require(219); var redefineAll = webpack_require(227); var hide = webpack_require(17); var forOf = webpack_require(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === ‘function’) cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, ‘Observable’, ‘_f’)._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === ‘function’ ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i &lt; l;) items[i] = arguments[i++]; return new (typeof this === ‘function’ ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j &lt; items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); webpack_require(201)(‘Observable’);// }),/ 332 /// (function(module, exports, webpack_require) { // ie9- setTimeout &amp; setInterval additional parameters fix var global = webpack_require(11); var $export = webpack_require(15); var userAgent = webpack_require(225); var slice = [].slice; var MSIE = /MSIE ../.test(userAgent); // &lt;- dirty ie9- check var wrap = function (set) { return function (fn, time / , …args /) { var boundArgs = arguments.length &gt; 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == ‘function’ ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) });/*/ }),/ 333 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $task = webpack_require(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear });// }),/ 334 /// (function(module, exports, webpack_require) { var $iterators = webpack_require(202); var getKeys = webpack_require(38); var redefine = webpack_require(25); var global = webpack_require(11); var hide = webpack_require(17); var Iterators = webpack_require(137); var wks = webpack_require(34); var ITERATOR = wks(‘iterator’); var TO_STRING_TAG = wks(‘toStringTag’); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i &lt; collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection &amp;&amp; Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } }// }),/ 335 /// (function(module, exports) { / WEBPACK VAR INJECTION */(function(global) {/ Copyright (c) 2014, Facebook, Inc. All rights reserved. This source code is licensed under the BSD-style license found in the https://raw.github.com/facebook/regenerator/master/LICENSE file. An additional grant of patent rights can be found in the PATENTS file in the same directory. / !(function(global) { “use strict”; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === “function” ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || “@@iterator”; var asyncIteratorSymbol = $Symbol.asyncIterator || “@@asyncIterator”; var toStringTagSymbol = $Symbol.toStringTag || “@@toStringTag”; var inModule = typeof module === “object”; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we’re in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don’t bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we’re in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there’s no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don’t have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: “normal”, arg: fn.call(obj, arg) }; } catch (err) { return { type: “throw”, arg: err }; } } var GenStateSuspendedStart = “suspendedStart”; var GenStateSuspendedYield = “suspendedYield”; var GenStateExecuting = “executing”; var GenStateCompleted = “completed”; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don’t natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([]))); if (NativeIteratorPrototype &amp;&amp; NativeIteratorPrototype !== Op &amp;&amp; hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = “GeneratorFunction”; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { [“next”, “throw”, “return”].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === “function” &amp;&amp; genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === “GeneratorFunction” : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.proto = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = “GeneratorFunction”; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, await x is transformed to // yield regeneratorRuntime.awrap(x), so that the runtime can test // hasOwn.call(value, &quot;__await&quot;) to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === “throw”) { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === “object” &amp;&amp; hasOwn.call(value, “await”)) { return Promise.resolve(value.await).then(function(value) { invoke(“next”, value, resolve, reject); }, function(err) { invoke(“throw”, err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise&lt;{value,done}&gt; result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === “object” &amp;&amp; global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error(“Generator is already running”); } if (state === GenStateCompleted) { if (method === “throw”) { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === “next”) { // Setting context._sent for legacy support of Babel’s // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === “throw”) { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === “return”) { context.abrupt(“return”, context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === “normal”) { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === “throw”) { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = “throw”; context.arg = record.arg; } } }; } // Call delegate.iteratorcontext.method and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield loop. context.delegate = null; if (context.method === “throw”) { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = “return”; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === “throw”) { // If maybeInvokeDelegate(context) changed context.method from // “return” to “throw”, let that override the TypeError below. return ContinueSentinel; } } context.method = “throw”; context.arg = new TypeError( “The iterator does not provide a ‘throw’ method”); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === “throw”) { context.method = “throw”; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = “throw”; context.arg = new TypeError(“iterator result is not an object”); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was “throw” but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was “next”, forget context.arg since it has been // “consumed” by the delegate iterator. If context.method was // “return”, allow the original .return call to continue in the // outer generator. if (context.method !== “return”) { context.method = “next”; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = “Generator”; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers’ implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn’t happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return “[object Generator]”; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = “normal”; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: “root” }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === “function”) { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i &lt; iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel’s // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = “next”; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === “t” &amp;&amp; hasOwn.call(this, name) &amp;&amp; !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === “throw”) { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = “throw”; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = “next”; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === “root”) { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle(“end”); } if (entry.tryLoc &lt;= this.prev) { var hasCatch = hasOwn.call(entry, “catchLoc”); var hasFinally = hasOwn.call(entry, “finallyLoc”); if (hasCatch &amp;&amp; hasFinally) { if (this.prev &lt; entry.catchLoc) { return handle(entry.catchLoc, true); } else if (this.prev &lt; entry.finallyLoc) { return handle(entry.finallyLoc); } } else if (hasCatch) { if (this.prev &lt; entry.catchLoc) { return handle(entry.catchLoc, true); } } else if (hasFinally) { if (this.prev &lt; entry.finallyLoc) { return handle(entry.finallyLoc); } } else { throw new Error(“try statement without catch or finally”); } } } }, abrupt: function(type, arg) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.tryLoc &lt;= this.prev &amp;&amp; hasOwn.call(entry, “finallyLoc”) &amp;&amp; this.prev &lt; entry.finallyLoc) { var finallyEntry = entry; break; } } if (finallyEntry &amp;&amp; (type === “break” || type === “continue”) &amp;&amp; finallyEntry.tryLoc &lt;= arg &amp;&amp; arg &lt;= finallyEntry.finallyLoc) { // Ignore the finally entry if control is not jumping to a // location outside the try/catch block. finallyEntry = null; } var record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = “next”; this.next = finallyEntry.finallyLoc; return ContinueSentinel; } return this.complete(record); }, complete: function(record, afterLoc) { if (record.type === “throw”) { throw record.arg; } if (record.type === “break” || record.type === “continue”) { this.next = record.arg; } else if (record.type === “return”) { this.rval = this.arg = record.arg; this.method = “return”; this.next = “end”; } else if (record.type === “normal” &amp;&amp; afterLoc) { this.next = afterLoc; } return ContinueSentinel; }, finish: function(finallyLoc) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; } } }, “catch”: function(tryLoc) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (record.type === “throw”) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } // The context.catch method must only be called with a location // argument that corresponds to a known catch block. throw new Error(“illegal catch attempt”); }, delegateYield: function(iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === “next”) { // Deliberately forget the last sent value so that we don’t // accidentally pass it on to the delegate. this.arg = undefined; } return ContinueSentinel; } }; })( // Among the various tricks for obtaining a reference to the global // object, this seems to be the most reliable technique that does not // use indirect eval (which violates Content Security Policy). typeof global === “object” ? global : typeof window === “object” ? window : typeof self === “object” ? self : this ); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))/**/ }),/ 336 //***/ (function(module, exports, webpack_require__) { webpack_require(337); module.exports = webpack_require(16).RegExp.escape;// }),/ 337 /// (function(module, exports, webpack_require) { // https://github.com/benjamingr/RexExp.escape var $export = webpack_require(15); var $re = webpack_require(338)(/[\^$+?.()|[]{}]/g, ‘\$&amp;’); $export($export.S, ‘RegExp’, { escape: function escape(it) { return $re(it); } });/**/ }),/ 338 /// (function(module, exports) { module.exports = function (regExp, replace) { var replacer = replace === Object(replace) ? function (part) { return replace[part]; } : replace; return function (it) { return String(it).replace(regExp, replacer); }; };// }),/ 339 /// (function(module, exports, webpack_require) { // style-loader: Adds some css to the DOM by adding a tag // load the styles var content = webpack_require(340); if(typeof content === ‘string’) content = [[module.id, content, ‘’]]; // add the styles to the DOM var update = webpack_require(342)(content, {}); if(content.locals) module.exports = content.locals; // Hot Module Replacement if(false) { // When the styles change, update the tags if(!content.locals) { module.hot.accept(“!!./node_modules/css-loader/index.js!./style.css”, function() { var newContent = require(“!!./node_modules/css-loader/index.js!./style.css”); if(typeof newContent === ‘string’) newContent = [[module.id, newContent, ‘’]]; update(newContent); }); } // When the module is disposed, remove the tags module.hot.dispose(function() { update(); }); }// }),/ 340 /// (function(module, exports, webpack_require) { exports = module.exports = webpack_require(341)(); // imports // module exports.push([module.id, “.lime {\n all: initial;\n}\n.lime.top_div {\n display: flex;\n flex-wrap: wrap;\n}\n.lime.predict_proba {\n width: 245px;\n}\n.lime.predicted_value {\n width: 245px;\n}\n.lime.explanation {\n width: 350px;\n}\n\n.lime.text_div {\n max-height:300px;\n flex: 1 0 300px;\n overflow:scroll;\n}\n.lime.table_div {\n max-height:300px;\n flex: 1 0 300px;\n overflow:scroll;\n}\n.lime.table_div table {\n border-collapse: collapse;\n color: white;\n border-style: hidden;\n margin: 0 auto;\n}\n”, “”]); // exports// }),/ 341 /// (function(module, exports) { / MIT License http://www.opensource.org/licenses/mit-license.php Author Tobias Koppers @sokra / // css base code, injected by the css-loader module.exports = function() { var list = []; // return the list of modules as css string list.toString = function toString() { var result = []; for(var i = 0; i &lt; this.length; i++) { var item = this[i]; if(item[2]) { result.push(“@media “ + item[2] + “{“ + item[1] + “}”); } else { result.push(item[1]); } } return result.join(“”); }; // import a list of modules into the list list.i = function(modules, mediaQuery) { if(typeof modules === “string”) modules = [[null, modules, “”]]; var alreadyImportedModules = {}; for(var i = 0; i &lt; this.length; i++) { var id = this[i][0]; if(typeof id === “number”) alreadyImportedModules[id] = true; } for(i = 0; i &lt; modules.length; i++) { var item = modules[i]; // skip already imported module // this implementation is not 100% perfect for weird media query combinations // when a module is imported multiple times with different media queries. // I hope this will never occur (Hey this way we have smaller bundles) if(typeof item[0] !== “number” || !alreadyImportedModules[item[0]]) { if(mediaQuery &amp;&amp; !item[2]) { item[2] = mediaQuery; } else if(mediaQuery) { item[2] = “(“ + item[2] + “) and (“ + mediaQuery + “)”; } list.push(item); } } }; return list; };// }),/ 342 /// (function(module, exports, webpack_require) { / MIT License http://www.opensource.org/licenses/mit-license.php Author Tobias Koppers @sokra / var stylesInDom = {}, memoize = function(fn) { var memo; return function () { if (typeof memo === “undefined”) memo = fn.apply(this, arguments); return memo; }; }, isOldIE = memoize(function() { return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase()); }), getHeadElement = memoize(function () { return document.head || document.getElementsByTagName(“head”)[0]; }), singletonElement = null, singletonCounter = 0, styleElementsInsertedAtTop = []; module.exports = function(list, options) { if(false) { if(typeof document !== “object”) throw new Error(“The style-loader cannot be used in a non-browser environment”); } options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of // tags it will allow on a page if (typeof options.singleton === “undefined”) options.singleton = isOldIE(); // By default, add tags to the bottom of . if (typeof options.insertAt === “undefined”) options.insertAt = “bottom”; var styles = listToStyles(list); addStylesToDom(styles, options); return function update(newList) { var mayRemove = []; for(var i = 0; i &lt; styles.length; i++) { var item = styles[i]; var domStyle = stylesInDom[item.id]; domStyle.refs–; mayRemove.push(domStyle); } if(newList) { var newStyles = listToStyles(newList); addStylesToDom(newStyles, options); } for(var i = 0; i &lt; mayRemove.length; i++) { var domStyle = mayRemove[i]; if(domStyle.refs === 0) { for(var j = 0; j &lt; domStyle.parts.length; j++) domStyle.partsj; delete stylesInDom[domStyle.id]; } } }; } function addStylesToDom(styles, options) { for(var i = 0; i &lt; styles.length; i++) { var item = styles[i]; var domStyle = stylesInDom[item.id]; if(domStyle) { domStyle.refs++; for(var j = 0; j &lt; domStyle.parts.length; j++) { domStyle.partsj; } for(; j &lt; item.parts.length; j++) { domStyle.parts.push(addStyle(item.parts[j], options)); } } else { var parts = []; for(var j = 0; j &lt; item.parts.length; j++) { parts.push(addStyle(item.parts[j], options)); } stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts}; } } } function listToStyles(list) { var styles = []; var newStyles = {}; for(var i = 0; i &lt; list.length; i++) { var item = list[i]; var id = item[0]; var css = item[1]; var media = item[2]; var sourceMap = item[3]; var part = {css: css, media: media, sourceMap: sourceMap}; if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]}); else newStyles[id].parts.push(part); } return styles; } function insertStyleElement(options, styleElement) { var head = getHeadElement(); var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1]; if (options.insertAt === “top”) { if(!lastStyleElementInsertedAtTop) { head.insertBefore(styleElement, head.firstChild); } else if(lastStyleElementInsertedAtTop.nextSibling) { head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling); } else { head.appendChild(styleElement); } styleElementsInsertedAtTop.push(styleElement); } else if (options.insertAt === “bottom”) { head.appendChild(styleElement); } else { throw new Error(“Invalid value for parameter ‘insertAt’. Must be ‘top’ or ‘bottom’.”); } } function removeStyleElement(styleElement) { styleElement.parentNode.removeChild(styleElement); var idx = styleElementsInsertedAtTop.indexOf(styleElement); if(idx &gt;= 0) { styleElementsInsertedAtTop.splice(idx, 1); } } function createStyleElement(options) { var styleElement = document.createElement(“style”); styleElement.type = “text/css”; insertStyleElement(options, styleElement); return styleElement; } function createLinkElement(options) { var linkElement = document.createElement(“link”); linkElement.rel = “stylesheet”; insertStyleElement(options, linkElement); return linkElement; } function addStyle(obj, options) { var styleElement, update, remove; if (options.singleton) { var styleIndex = singletonCounter++; styleElement = singletonElement || (singletonElement = createStyleElement(options)); update = applyToSingletonTag.bind(null, styleElement, styleIndex, false); remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true); } else if(obj.sourceMap &amp;&amp; typeof URL === “function” &amp;&amp; typeof URL.createObjectURL === “function” &amp;&amp; typeof URL.revokeObjectURL === “function” &amp;&amp; typeof Blob === “function” &amp;&amp; typeof btoa === “function”) { styleElement = createLinkElement(options); update = updateLink.bind(null, styleElement); remove = function() { removeStyleElement(styleElement); if(styleElement.href) URL.revokeObjectURL(styleElement.href); }; } else { styleElement = createStyleElement(options); update = applyToTag.bind(null, styleElement); remove = function() { removeStyleElement(styleElement); }; } update(obj); return function updateStyle(newObj) { if(newObj) { if(newObj.css === obj.css &amp;&amp; newObj.media === obj.media &amp;&amp; newObj.sourceMap === obj.sourceMap) return; update(obj = newObj); } else { remove(); } }; } var replaceText = (function () { var textStore = []; return function (index, replacement) { textStore[index] = replacement; return textStore.filter(Boolean).join(‘\n’); }; })(); function applyToSingletonTag(styleElement, index, remove, obj) { var css = remove ? “” : obj.css; if (styleElement.styleSheet) { styleElement.styleSheet.cssText = replaceText(index, css); } else { var cssNode = document.createTextNode(css); var childNodes = styleElement.childNodes; if (childNodes[index]) styleElement.removeChild(childNodes[index]); if (childNodes.length) { styleElement.insertBefore(cssNode, childNodes[index]); } else { styleElement.appendChild(cssNode); } } } function applyToTag(styleElement, obj) { var css = obj.css; var media = obj.media; if(media) { styleElement.setAttribute(“media”, media) } if(styleElement.styleSheet) { styleElement.styleSheet.cssText = css; } else { while(styleElement.firstChild) { styleElement.removeChild(styleElement.firstChild); } styleElement.appendChild(document.createTextNode(css)); } } function updateLink(linkElement, obj) { var css = obj.css; var sourceMap = obj.sourceMap; if(sourceMap) { // http://stackoverflow.com/a/26603875 css += “\n/# sourceMappingURL=data:application/json;base64,” + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + “ /“; } var blob = new Blob([css], { type: “text/css” }); var oldSrc = linkElement.href; linkElement.href = URL.createObjectURL(blob); if(oldSrc) URL.revokeObjectURL(oldSrc); }// })/**/ ]);//# sourceMappingURL=bundle.js.map var top_div = d3.select(‘#top_div63V3VN8QZ0QBP9R’).classed(‘lime top_div’, true); var exp_div; var exp = new lime.Explanation([“negative”, “positive”]); exp_div = top_div.append(‘div’).classed(‘lime explanation’, true); exp.show([[“Site EUI (kBtu/ft²) &gt; 0.47”, -40.61827109438541], [“Weather Normalized Site Electricity Intensity (kWh/ft²) &gt; 0.16”, -26.92659296059405], [“Largest Property Use Type_Non-Refrigerated Warehouse &lt;= 0.00”, 18.196650593417797], [“log_Direct GHG Emissions (Metric Tons CO2e) &gt; 0.63”, 1.8437848762279982], [“Property Id &gt; 0.74”, -1.569526870778118], [“0.53 &lt; log_Water Intensity (All Water Sources) (gal/ft²) &lt;= 0.55”, 1.1353272363449252], [“0.75 &lt; Year Built &lt;= 0.79”, 0.49562383349780276], [“0.00 &lt; Water Intensity (All Water Sources) (gal/ft²) &lt;= 0.00”, 0.326751543611257], [“0.00 &lt; DOF Gross Floor Area &lt;= 0.01”, -0.0473509973779096], [“Largest Property Use Type_Multifamily Housing &lt;= 1.00”, 0.0]], 1, exp_div); var raw_div = top_div.append(‘div’); exp.show_raw_tabular([[“Site EUI (kBtu/ft²)”, “0.82”, -40.61827109438541], [“Weather Normalized Site Electricity Intensity (kWh/ft²)”, “0.42”, -26.92659296059405], [“Largest Property Use Type_Non-Refrigerated Warehouse”, “0.00”, 18.196650593417797], [“log_Direct GHG Emissions (Metric Tons CO2e)”, “0.68”, 1.8437848762279982], [“Property Id”, “0.75”, -1.569526870778118], [“log_Water Intensity (All Water Sources) (gal/ft²)”, “0.55”, 1.1353272363449252], [“Year Built”, “0.76”, 0.49562383349780276], [“Water Intensity (All Water Sources) (gal/ft²)”, “0.00”, 0.326751543611257], [“DOF Gross Floor Area”, “0.01”, -0.0473509973779096], [“Largest Property Use Type_Multifamily Housing”, “0.00”, 0.0]], 1, raw_div); 在这个例子中，我们的梯度提升模型预测得分为14.1601，实际值为96.0。 LIME的图表向我们展示了该示例的每个特征对最终预测的贡献。我们可以看到，Site EUI 显着降低了预测，因为它高于0.47。另一方面，Largest Property Use Type_Non-Refrigerated Warehouse 增加了预测，因为它低于0。 我们可以将此解释为我们的模型认为能源之星得分会比实际低得多，因为网站EUI很高。然而，在这种情况下，尽管Site EUI很大，但得分仍为96。虽然这个重大错误（偏离了82分！）可能最初令人困惑，但现在我们可以看到，实际上，该模型正在推理问题并且刚刚达到了错误值！一个人在同一个过程中可能会得出同样的结论（如果他们有耐心去查看所有数据）。 现在我们可以通过模型得到最好预测的解释。 12345678910# 为正确示例显示预测值和真实值print('Prediction: %0.4f' % model_reduced.predict(right.reshape(1, -1)))print('Actual Value: %0.4f' % y_test[np.argmin(residuals)])# 解释正确预测right_exp = explainer.explain_instance(data_row = right, predict_fn = model_reduced.predict)# 绘制预测解释right_exp.as_pyplot_figure()plt.title('Explanation of Prediction', size = 28);plt.xlabel('Effect on Prediction', size = 22); Prediction: 100.0000 Actual Value: 100.0000 C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\linear_model\ridge.py:125: LinAlgWarning: scipy.linalg.solve Ill-conditioned matrix detected. Result is not guaranteed to be accurate. Reciprocal condition number4.087887e-27 overwrite_a=True).T 1right_exp.show_in_notebook(show_predicted_value=False) var lime =/**/ (function(modules) { // webpackBootstrap/**/ // The module cache/**/ var installedModules = {};/**//**/ // The require function/**/ function webpack_require(moduleId) {/**//**/ // Check if module is in cache/**/ if(installedModules[moduleId])/**/ return installedModules[moduleId].exports;/**//**/ // Create a new module (and put it into the cache)/**/ var module = installedModules[moduleId] = {/**/ exports: {},/**/ id: moduleId,/**/ loaded: false/**/ };/**//**/ // Execute the module function/**/ modules[moduleId].call(module.exports, module, module.exports, webpack_require);/**//**/ // Flag the module as loaded/**/ module.loaded = true;/**//**/ // Return the exports of the module/**/ return module.exports;/**/ }/**//**//**/ // expose the modules object (webpack_modules)/**/ webpack_require.m = modules;/**//**/ // expose the module cache/**/ webpack_require.c = installedModules;/**//**/ // webpack_public_path/**/ webpack_require.p = “”;/**//**/ // Load entry module and return exports/**/ return webpack_require(0);/**/ })/**//**/ ([/ 0 /// (function(module, exports, webpack_require) { / WEBPACK VAR INJECTION /(function(global) {‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); exports.PredictedValue = exports.PredictProba = exports.Barchart = exports.Explanation = undefined; var _explanation = webpack_require__(1); var _explanation2 = _interopRequireDefault(_explanation); var _bar_chart = webpack_require(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _predict_proba = webpack_require(6); var _predict_proba2 = _interopRequireDefault(_predict_proba); var _predicted_value = webpack_require(7); var _predicted_value2 = _interopRequireDefault(_predicted_value); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } if (!global._babelPolyfill) { webpack_require__(8); } webpack_require(339); exports.Explanation = _explanation2.default; exports.Barchart = _bar_chart2.default; exports.PredictProba = _predict_proba2.default; exports.PredictedValue = _predicted_value2.default; //require(‘style-loader’); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))// }),/ 1 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arrSymbol.iterator, _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[“return”]) _i“return”; } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(“Invalid attempt to destructure non-iterable instance”); } }; }(); var _d2 = webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _bar_chart = webpack_require(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var Explanation = function () { function Explanation(class_names) { _classCallCheck(this, Explanation); this.names = class_names; if (class_names.length &lt; 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } } // exp: [(feature-name, weight), …] // label: int // div: d3 selection Explanation.prototype.show = function show(exp, label, div) { var svg = div.append(‘svg’).style(‘width’, ‘100%’); var colors = [‘#5F9EA0’, this.colors_i(label)]; var names = [‘NOT ‘ + this.names[label], this.names[label]]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; names = this.names; } var plot = new _bar_chart2.default(svg, exp, true, names, colors, true, 10); svg.style(‘height’, plot.svg_height + ‘px’); }; // exp has all ocurrences of words, with start index and weight: // exp = [(‘word’, 132, -0.13), (‘word3’, 111, 1.3) Explanation.prototype.show_raw_text = function show_raw_text(exp, label, raw, div) { var opacity = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : true; //let colors=[‘#5F9EA0’, this.colors(this.exp[‘class’])]; var colors = [‘#5F9EA0’, this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var word_lists = [[], []]; var max_weight = -1; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = expSymbol.iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var _step$value = _slicedToArray(_step.value, 3), word = _step$value[0], start = _step$value[1], weight = _step$value[2]; if (weight &gt; 0) { word_lists[1].push([start, start + word.length, weight]); } else { word_lists[0].push([start, start + word.length, -weight]); } max_weight = Math.max(max_weight, Math.abs(weight)); } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } if (!opacity) { max_weight = 0; } this.display_raw_text(div, raw, word_lists, colors, max_weight, true); }; // exp is list of (feature_name, value, weight) Explanation.prototype.show_raw_tabular = function show_raw_tabular(exp, label, div) { div.classed(‘lime’, true).classed(‘table_div’, true); var colors = [‘#5F9EA0’, this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var table = div.append(‘table’); var thead = table.append(‘tr’); thead.append(‘td’).text(‘Feature’); thead.append(‘td’).text(‘Value’); thead.style(‘color’, ‘black’).style(‘font-size’, ‘20px’); var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = expSymbol.iterator, _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var _step2$value = _slicedToArray(_step2.value, 3), fname = _step2$value[0], value = _step2$value[1], weight = _step2$value[2]; var tr = table.append(‘tr’); tr.style(‘border-style’, ‘hidden’); tr.append(‘td’).text(fname); tr.append(‘td’).text(value); if (weight &gt; 0) { tr.style(‘background-color’, colors[1]); } else if (weight &lt; 0) { tr.style(‘background-color’, colors[0]); } else { tr.style(‘color’, ‘black’); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } }; Explanation.prototype.hexToRgb = function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }; Explanation.prototype.applyAlpha = function applyAlpha(hex, alpha) { var components = this.hexToRgb(hex); return ‘rgba(‘ + components.r + “,” + components.g + “,” + components.b + “,” + alpha.toFixed(3) + “)”; }; // sord_lists is an array of arrays, of length (colors). if with_positions is true, // word_lists is an array of [start,end] positions instead Explanation.prototype.display_raw_text = function display_raw_text(div, raw_text) { var word_lists = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : []; var colors = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : []; var max_weight = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : 1; var positions = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; div.classed(‘lime’, true).classed(‘text_div’, true); div.append(‘h3’).text(‘Text with highlighted words’); var highlight_tag = ‘span’; var text_span = div.append(‘span’).style(‘white-space’, ‘pre-wrap’).text(raw_text); var position_lists = word_lists; if (!positions) { position_lists = this.wordlists_to_positions(word_lists, raw_text); } var objects = []; var _iteratorNormalCompletion3 = true; var _didIteratorError3 = false; var _iteratorError3 = undefined; try { var _loop = function _loop() { var i = _step3.value; position_lists[i].map(function (x) { return objects.push({ ‘label’: i, ‘start’: x[0], ‘end’: x[1], ‘alpha’: max_weight === 0 ? 1 : x[2] / max_weight }); }); }; for (var _iterator3 = (0, _lodash.range)(position_lists.length)Symbol.iterator, _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) { _loop(); } } catch (err) { _didIteratorError3 = true; _iteratorError3 = err; } finally { try { if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) { _iterator3.return(); } } finally { if (_didIteratorError3) { throw _iteratorError3; } } } objects = (0, _lodash.sortBy)(objects, function (x) { return x[‘start’]; }); var node = text_span.node().childNodes[0]; var subtract = 0; var _iteratorNormalCompletion4 = true; var _didIteratorError4 = false; var _iteratorError4 = undefined; try { for (var _iterator4 = objectsSymbol.iterator, _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) { var obj = _step4.value; var word = raw_text.slice(obj.start, obj.end); var start = obj.start - subtract; var end = obj.end - subtract; var match = document.createElement(highlight_tag); match.appendChild(document.createTextNode(word)); match.style.backgroundColor = this.applyAlpha(colors[obj.label], obj.alpha); var after = node.splitText(start); after.nodeValue = after.nodeValue.substring(word.length); node.parentNode.insertBefore(match, after); subtract += end; node = after; } } catch (err) { _didIteratorError4 = true; _iteratorError4 = err; } finally { try { if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) { _iterator4.return(); } } finally { if (_didIteratorError4) { throw _iteratorError4; } } } }; Explanation.prototype.wordlists_to_positions = function wordlists_to_positions(word_lists, raw_text) { var ret = []; var _iteratorNormalCompletion5 = true; var _didIteratorError5 = false; var _iteratorError5 = undefined; try { for (var _iterator5 = word_listsSymbol.iterator, _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) { var words = _step5.value; if (words.length === 0) { ret.push([]); continue; } var re = new RegExp(“\b(“ + words.join(‘|’) + “)\b”, ‘gm’); var temp = void 0; var list = []; while ((temp = re.exec(raw_text)) !== null) { list.push([temp.index, temp.index + temp[0].length]); } ret.push(list); } } catch (err) { _didIteratorError5 = true; _iteratorError5 = err; } finally { try { if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) { _iterator5.return(); } } finally { if (_didIteratorError5) { throw _iteratorError5; } } } return ret; }; return Explanation; }(); exports.default = Explanation;// }),/ 2 /// (function(module, exports, webpack_require) { var WEBPACK_AMD_DEFINE_FACTORY, WEBPACK_AMD_DEFINE_RESULT;!function() { var d3 = { version: “3.5.17” }; var d3_arraySlice = [].slice, d3_array = function(list) { return d3_arraySlice.call(list); }; var d3_document = this.document; function d3_documentElement(node) { return node &amp;&amp; (node.ownerDocument || node.document || node).documentElement; } function d3_window(node) { return node &amp;&amp; (node.ownerDocument &amp;&amp; node.ownerDocument.defaultView || node.document &amp;&amp; node || node.defaultView); } if (d3_document) { try { d3_array(d3_document.documentElement.childNodes)[0].nodeType; } catch (e) { d3_array = function(list) { var i = list.length, array = new Array(i); while (i–) array[i] = list[i]; return array; }; } } if (!Date.now) Date.now = function() { return +new Date(); }; if (d3_document) { try { d3_document.createElement(“DIV”).style.setProperty(“opacity”, 0, “”); } catch (error) { var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty; d3_element_prototype.setAttribute = function(name, value) { d3_element_setAttribute.call(this, name, value + “”); }; d3_element_prototype.setAttributeNS = function(space, local, value) { d3_element_setAttributeNS.call(this, space, local, value + “”); }; d3_style_prototype.setProperty = function(name, value, priority) { d3_style_setProperty.call(this, name, value + “”, priority); }; } } d3.ascending = d3_ascending; function d3_ascending(a, b) { return a &lt; b ? -1 : a &gt; b ? 1 : a &gt;= b ? 0 : NaN; } d3.descending = function(a, b) { return b &lt; a ? -1 : b &gt; a ? 1 : b &gt;= a ? 0 : NaN; }; d3.min = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; a &gt; b) a = b; } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; a &gt; b) a = b; } return a; }; d3.max = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt; a) a = b; } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt; a) a = b; } return a; }; d3.extent = function(array, f) { var i = -1, n = array.length, a, b, c; if (arguments.length === 1) { while (++i &lt; n) if ((b = array[i]) != null &amp;&amp; b &gt;= b) { a = c = b; break; } while (++i &lt; n) if ((b = array[i]) != null) { if (a &gt; b) a = b; if (c &lt; b) c = b; } } else { while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null &amp;&amp; b &gt;= b) { a = c = b; break; } while (++i &lt; n) if ((b = f.call(array, array[i], i)) != null) { if (a &gt; b) a = b; if (c &lt; b) c = b; } } return [ a, c ]; }; function d3_number(x) { return x === null ? NaN : +x; } function d3_numeric(x) { return !isNaN(x); } d3.sum = function(array, f) { var s = 0, n = array.length, a, i = -1; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = +array[i])) s += a; } else { while (++i &lt; n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a; } return s; }; d3.mean = function(array, f) { var s = 0, n = array.length, a, i = -1, j = n; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = d3_number(array[i]))) s += a; else –j; } else { while (++i &lt; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else –j; } if (j) return s / j; }; d3.quantile = function(values, p) { var H = (values.length - 1) p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h; return e ? v + e (values[h] - v) : v; }; d3.median = function(array, f) { var numbers = [], n = array.length, a, i = -1; if (arguments.length === 1) { while (++i &lt; n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a); } else { while (++i &lt; n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a); } if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5); }; d3.variance = function(array, f) { var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0; if (arguments.length === 1) { while (++i &lt; n) { if (d3_numeric(a = d3_number(array[i]))) { d = a - m; m += d / ++j; s += d (a - m); } } } else { while (++i &lt; n) { if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) { d = a - m; m += d / ++j; s += d (a - m); } } } if (j &gt; 1) return s / (j - 1); }; d3.deviation = function() { var v = d3.variance.apply(this, arguments); return v ? Math.sqrt(v) : v; }; function d3_bisector(compare) { return { left: function(a, x, lo, hi) { if (arguments.length &lt; 3) lo = 0; if (arguments.length &lt; 4) hi = a.length; while (lo &lt; hi) { var mid = lo + hi &gt;&gt;&gt; 1; if (compare(a[mid], x) &lt; 0) lo = mid + 1; else hi = mid; } return lo; }, right: function(a, x, lo, hi) { if (arguments.length &lt; 3) lo = 0; if (arguments.length &lt; 4) hi = a.length; while (lo &lt; hi) { var mid = lo + hi &gt;&gt;&gt; 1; if (compare(a[mid], x) &gt; 0) hi = mid; else lo = mid + 1; } return lo; } }; } var d3_bisect = d3_bisector(d3_ascending); d3.bisectLeft = d3_bisect.left; d3.bisect = d3.bisectRight = d3_bisect.right; d3.bisector = function(f) { return d3_bisector(f.length === 1 ? function(d, x) { return d3_ascending(f(d), x); } : f); }; d3.shuffle = function(array, i0, i1) { if ((m = arguments.length) &lt; 3) { i1 = array.length; if (m &lt; 2) i0 = 0; } var m = i1 - i0, t, i; while (m) { i = Math.random() m– | 0; t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t; } return array; }; d3.permute = function(array, indexes) { var i = indexes.length, permutes = new Array(i); while (i–) permutes[i] = array[indexes[i]]; return permutes; }; d3.pairs = function(array) { var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n &lt; 0 ? 0 : n); while (i &lt; n) pairs[i] = [ p0 = p1, p1 = array[++i] ]; return pairs; }; d3.transpose = function(matrix) { if (!(n = matrix.length)) return []; for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i &lt; m; ) { for (var j = -1, n, row = transpose[i] = new Array(n); ++j &lt; n; ) { row[j] = matrix[j][i]; } } return transpose; }; function d3_transposeLength(d) { return d.length; } d3.zip = function() { return d3.transpose(arguments); }; d3.keys = function(map) { var keys = []; for (var key in map) keys.push(key); return keys; }; d3.values = function(map) { var values = []; for (var key in map) values.push(map[key]); return values; }; d3.entries = function(map) { var entries = []; for (var key in map) entries.push({ key: key, value: map[key] }); return entries; }; d3.merge = function(arrays) { var n = arrays.length, m, i = -1, j = 0, merged, array; while (++i &lt; n) j += arrays[i].length; merged = new Array(j); while (–n &gt;= 0) { array = arrays[n]; m = array.length; while (–m &gt;= 0) { merged[–j] = array[m]; } } return merged; }; var abs = Math.abs; d3.range = function(start, stop, step) { if (arguments.length &lt; 3) { step = 1; if (arguments.length &lt; 2) { stop = start; start = 0; } } if ((stop - start) / step === Infinity) throw new Error(“infinite range”); var range = [], k = d3_range_integerScale(abs(step)), i = -1, j; start = k, stop = k, step = k; if (step &lt; 0) while ((j = start + step ++i) &gt; stop) range.push(j / k); else while ((j = start + step ++i) &lt; stop) range.push(j / k); return range; }; function d3_range_integerScale(x) { var k = 1; while (x k % 1) k = 10; return k; } function d3_class(ctor, properties) { for (var key in properties) { Object.defineProperty(ctor.prototype, key, { value: properties[key], enumerable: false }); } } d3.map = function(object, f) { var map = new d3_Map(); if (object instanceof d3_Map) { object.forEach(function(key, value) { map.set(key, value); }); } else if (Array.isArray(object)) { var i = -1, n = object.length, o; if (arguments.length === 1) while (++i &lt; n) map.set(i, object[i]); else while (++i &lt; n) map.set(f.call(object, o = object[i], i), o); } else { for (var key in object) map.set(key, object[key]); } return map; }; function d3_Map() { this._ = Object.create(null); } var d3_map_proto = “proto“, d3_map_zero = “\x00”; d3_class(d3_Map, { has: d3_map_has, get: function(key) { return this._[d3_map_escape(key)]; }, set: function(key, value) { return this._[d3_map_escape(key)] = value; }, remove: d3_map_remove, keys: d3_map_keys, values: function() { var values = []; for (var key in this.) values.push(this.[key]); return values; }, entries: function() { var entries = []; for (var key in this._) entries.push({ key: d3_map_unescape(key), value: this._[key] }); return entries; }, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]); } }); function d3_map_escape(key) { return (key += “”) === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key; } function d3_map_unescape(key) { return (key += “”)[0] === d3_map_zero ? key.slice(1) : key; } function d3_map_has(key) { return d3_map_escape(key) in this._; } function d3_map_remove(key) { return (key = d3_map_escape(key)) in this._ &amp;&amp; delete this._[key]; } function d3_map_keys() { var keys = []; for (var key in this._) keys.push(d3_map_unescape(key)); return keys; } function d3_map_size() { var size = 0; for (var key in this._) ++size; return size; } function d3_map_empty() { for (var key in this._) return false; return true; } d3.nest = function() { var nest = {}, keys = [], sortKeys = [], sortValues, rollup; function map(mapType, array, depth) { if (depth &gt;= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array; var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values; while (++i &lt; n) { if (values = valuesByKey.get(keyValue = key(object = array[i]))) { values.push(object); } else { valuesByKey.set(keyValue, [ object ]); } } if (mapType) { object = mapType(); setter = function(keyValue, values) { object.set(keyValue, map(mapType, values, depth)); }; } else { object = {}; setter = function(keyValue, values) { object[keyValue] = map(mapType, values, depth); }; } valuesByKey.forEach(setter); return object; } function entries(map, depth) { if (depth &gt;= keys.length) return map; var array = [], sortKey = sortKeys[depth++]; map.forEach(function(key, keyMap) { array.push({ key: key, values: entries(keyMap, depth) }); }); return sortKey ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array; } nest.map = function(array, mapType) { return map(mapType, array, 0); }; nest.entries = function(array) { return entries(map(d3.map, array, 0), 0); }; nest.key = function(d) { keys.push(d); return nest; }; nest.sortKeys = function(order) { sortKeys[keys.length - 1] = order; return nest; }; nest.sortValues = function(order) { sortValues = order; return nest; }; nest.rollup = function(f) { rollup = f; return nest; }; return nest; }; d3.set = function(array) { var set = new d3_Set(); if (array) for (var i = 0, n = array.length; i &lt; n; ++i) set.add(array[i]); return set; }; function d3_Set() { this._ = Object.create(null); } d3_class(d3_Set, { has: d3_map_has, add: function(key) { this._[d3_map_escape(key += “”)] = true; return key; }, remove: d3_map_remove, values: d3_map_keys, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key)); } }); d3.behavior = {}; function d3_identity(d) { return d; } d3.rebind = function(target, source) { var i = 1, n = arguments.length, method; while (++i &lt; n) target[method = arguments[i]] = d3_rebind(target, source, source[method]); return target; }; function d3_rebind(target, source, method) { return function() { var value = method.apply(source, arguments); return value === source ? target : value; }; } function d3_vendorSymbol(object, name) { if (name in object) return name; name = name.charAt(0).toUpperCase() + name.slice(1); for (var i = 0, n = d3_vendorPrefixes.length; i &lt; n; ++i) { var prefixName = d3_vendorPrefixes[i] + name; if (prefixName in object) return prefixName; } } var d3_vendorPrefixes = [ “webkit”, “ms”, “moz”, “Moz”, “o”, “O” ]; function d3_noop() {} d3.dispatch = function() { var dispatch = new d3_dispatch(), i = -1, n = arguments.length; while (++i &lt; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); return dispatch; }; function d3_dispatch() {} d3_dispatch.prototype.on = function(type, listener) { var i = type.indexOf(“.”), name = “”; if (i &gt;= 0) { name = type.slice(i + 1); type = type.slice(0, i); } if (type) return arguments.length &lt; 2 ? this[type].on(name) : this[type].on(name, listener); if (arguments.length === 2) { if (listener == null) for (type in this) { if (this.hasOwnProperty(type)) this[type].on(name, null); } return this; } }; function d3_dispatch_event(dispatch) { var listeners = [], listenerByName = new d3_Map(); function event() { var z = listeners, i = -1, n = z.length, l; while (++i &lt; n) if (l = z[i].on) l.apply(this, arguments); return dispatch; } event.on = function(name, listener) { var l = listenerByName.get(name), i; if (arguments.length &lt; 2) return l &amp;&amp; l.on; if (l) { l.on = null; listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)); listenerByName.remove(name); } if (listener) listeners.push(listenerByName.set(name, { on: listener })); return dispatch; }; return event; } d3.event = null; function d3_eventPreventDefault() { d3.event.preventDefault(); } function d3_eventSource() { var e = d3.event, s; while (s = e.sourceEvent) e = s; return e; } function d3_eventDispatch(target) { var dispatch = new d3_dispatch(), i = 0, n = arguments.length; while (++i &lt; n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); dispatch.of = function(thiz, argumentz) { return function(e1) { try { var e0 = e1.sourceEvent = d3.event; e1.target = target; d3.event = e1; dispatch[e1.type].apply(thiz, argumentz); } finally { d3.event = e0; } }; }; return dispatch; } d3.requote = function(s) { return s.replace(d3_requote_re, “\$&amp;”); }; var d3_requote_re = /[\\^\$\+\?|[]().{}]/g; var d3_subclass = {}.proto ? function(object, prototype) { object.proto = prototype; } : function(object, prototype) { for (var property in prototype) object[property] = prototype[property]; }; function d3_selection(groups) { d3_subclass(groups, d3_selectionPrototype); return groups; } var d3_select = function(s, n) { return n.querySelector(s); }, d3_selectAll = function(s, n) { return n.querySelectorAll(s); }, d3_selectMatches = function(n, s) { var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, “matchesSelector”)]; d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); }; return d3_selectMatches(n, s); }; if (typeof Sizzle === “function”) { d3_select = function(s, n) { return Sizzle(s, n)[0] || null; }; d3_selectAll = Sizzle; d3_selectMatches = Sizzle.matchesSelector; } d3.selection = function() { return d3.select(d3_document.documentElement); }; var d3_selectionPrototype = d3.selection.prototype = []; d3_selectionPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, group, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroup.push(subnode = selector.call(node, node.data, i, j)); if (subnode &amp;&amp; “data“ in node) subnode.data = node.data; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; function d3_selection_selector(selector) { return typeof selector === “function” ? selector : function() { return d3_select(selector, this); }; } d3_selectionPrototype.selectAll = function(selector) { var subgroups = [], subgroup, node; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroups.push(subgroup = d3_array(selector.call(node, node.data, i, j))); subgroup.parentNode = node; } } } return d3_selection(subgroups); }; function d3_selection_selectorAll(selector) { return typeof selector === “function” ? selector : function() { return d3_selectAll(selector, this); }; } var d3_nsXhtml = “http://www.w3.org/1999/xhtml&quot;; var d3_nsPrefix = { svg: “http://www.w3.org/2000/svg&quot;, xhtml: d3_nsXhtml, xlink: “http://www.w3.org/1999/xlink&quot;, xml: “http://www.w3.org/XML/1998/namespace&quot;, xmlns: “http://www.w3.org/2000/xmlns/&quot; }; d3.ns = { prefix: d3_nsPrefix, qualify: function(name) { var i = name.indexOf(“:”), prefix = name; if (i &gt;= 0 &amp;&amp; (prefix = name.slice(0, i)) !== “xmlns”) name = name.slice(i + 1); return d3_nsPrefix.hasOwnProperty(prefix) ? { space: d3_nsPrefix[prefix], local: name } : name; } }; d3_selectionPrototype.attr = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) { var node = this.node(); name = d3.ns.qualify(name); return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name); } for (value in name) this.each(d3_selection_attr(value, name[value])); return this; } return this.each(d3_selection_attr(name, value)); }; function d3_selection_attr(name, value) { name = d3.ns.qualify(name); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrConstant() { this.setAttribute(name, value); } function attrConstantNS() { this.setAttributeNS(name.space, name.local, value); } function attrFunction() { var x = value.apply(this, arguments); if (x == null) this.removeAttribute(name); else this.setAttribute(name, x); } function attrFunctionNS() { var x = value.apply(this, arguments); if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x); } return value == null ? name.local ? attrNullNS : attrNull : typeof value === “function” ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant; } function d3_collapse(s) { return s.trim().replace(/\s+/g, “ “); } d3_selectionPrototype.classed = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) { var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1; if (value = node.classList) { while (++i &lt; n) if (!value.contains(name[i])) return false; } else { value = node.getAttribute(“class”); while (++i &lt; n) if (!d3_selection_classedRe(name[i]).test(value)) return false; } return true; } for (value in name) this.each(d3_selection_classed(value, name[value])); return this; } return this.each(d3_selection_classed(name, value)); }; function d3_selection_classedRe(name) { return new RegExp(“(?:^|\s+)” + d3.requote(name) + “(?:\s+|$)”, “g”); } function d3_selection_classes(name) { return (name + “”).trim().split(/^|\s+/); } function d3_selection_classed(name, value) { name = d3_selection_classes(name).map(d3_selection_classedName); var n = name.length; function classedConstant() { var i = -1; while (++i &lt; n) namei; } function classedFunction() { var i = -1, x = value.apply(this, arguments); while (++i &lt; n) namei; } return typeof value === “function” ? classedFunction : classedConstant; } function d3_selection_classedName(name) { var re = d3_selection_classedRe(name); return function(node, value) { if (c = node.classList) return value ? c.add(name) : c.remove(name); var c = node.getAttribute(“class”) || “”; if (value) { re.lastIndex = 0; if (!re.test(c)) node.setAttribute(“class”, d3_collapse(c + “ “ + name)); } else { node.setAttribute(“class”, d3_collapse(c.replace(re, “ “))); } }; } d3_selectionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n &lt; 3) { if (typeof name !== “string”) { if (n &lt; 2) value = “”; for (priority in name) this.each(d3_selection_style(priority, name[priority], value)); return this; } if (n &lt; 2) { var node = this.node(); return d3_window(node).getComputedStyle(node, null).getPropertyValue(name); } priority = “”; } return this.each(d3_selection_style(name, value, priority)); }; function d3_selection_style(name, value, priority) { function styleNull() { this.style.removeProperty(name); } function styleConstant() { this.style.setProperty(name, value, priority); } function styleFunction() { var x = value.apply(this, arguments); if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority); } return value == null ? styleNull : typeof value === “function” ? styleFunction : styleConstant; } d3_selectionPrototype.property = function(name, value) { if (arguments.length &lt; 2) { if (typeof name === “string”) return this.node()[name]; for (value in name) this.each(d3_selection_property(value, name[value])); return this; } return this.each(d3_selection_property(name, value)); }; function d3_selection_property(name, value) { function propertyNull() { delete this[name]; } function propertyConstant() { this[name] = value; } function propertyFunction() { var x = value.apply(this, arguments); if (x == null) delete this[name]; else this[name] = x; } return value == null ? propertyNull : typeof value === “function” ? propertyFunction : propertyConstant; } d3_selectionPrototype.text = function(value) { return arguments.length ? this.each(typeof value === “function” ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? “” : v; } : value == null ? function() { this.textContent = “”; } : function() { this.textContent = value; }) : this.node().textContent; }; d3_selectionPrototype.html = function(value) { return arguments.length ? this.each(typeof value === “function” ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? “” : v; } : value == null ? function() { this.innerHTML = “”; } : function() { this.innerHTML = value; }) : this.node().innerHTML; }; d3_selectionPrototype.append = function(name) { name = d3_selection_creator(name); return this.select(function() { return this.appendChild(name.apply(this, arguments)); }); }; function d3_selection_creator(name) { function create() { var document = this.ownerDocument, namespace = this.namespaceURI; return namespace === d3_nsXhtml &amp;&amp; document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name); } function createNS() { return this.ownerDocument.createElementNS(name.space, name.local); } return typeof name === “function” ? name : (name = d3.ns.qualify(name)).local ? createNS : create; } d3_selectionPrototype.insert = function(name, before) { name = d3_selection_creator(name); before = d3_selection_selector(before); return this.select(function() { return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null); }); }; d3_selectionPrototype.remove = function() { return this.each(d3_selectionRemove); }; function d3_selectionRemove() { var parent = this.parentNode; if (parent) parent.removeChild(this); } d3_selectionPrototype.data = function(value, key) { var i = -1, n = this.length, group, node; if (!arguments.length) { value = new Array(n = (group = this[0]).length); while (++i &lt; n) { if (node = group[i]) { value[i] = node.data; } } return value; } function bind(group, groupData) { var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData; if (key) { var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue; for (i = -1; ++i &lt; n; ) { if (node = group[i]) { if (nodeByKeyValue.has(keyValue = key.call(node, node.data, i))) { exitNodes[i] = node; } else { nodeByKeyValue.set(keyValue, node); } keyValues[i] = keyValue; } } for (i = -1; ++i &lt; m; ) { if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) { enterNodes[i] = d3_selection_dataNode(nodeData); } else if (node !== true) { updateNodes[i] = node; node.data = nodeData; } nodeByKeyValue.set(keyValue, true); } for (i = -1; ++i &lt; n; ) { if (i in keyValues &amp;&amp; nodeByKeyValue.get(keyValues[i]) !== true) { exitNodes[i] = group[i]; } } } else { for (i = -1; ++i &lt; n0; ) { node = group[i]; nodeData = groupData[i]; if (node) { node.data = nodeData; updateNodes[i] = node; } else { enterNodes[i] = d3_selection_dataNode(nodeData); } } for (;i &lt; m; ++i) { enterNodes[i] = d3_selection_dataNode(groupData[i]); } for (;i &lt; n; ++i) { exitNodes[i] = group[i]; } } enterNodes.update = updateNodes; enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode; enter.push(enterNodes); update.push(updateNodes); exit.push(exitNodes); } var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]); if (typeof value === “function”) { while (++i &lt; n) { bind(group = this[i], value.call(group, group.parentNode.data, i)); } } else { while (++i &lt; n) { bind(group = this[i], value); } } update.enter = function() { return enter; }; update.exit = function() { return exit; }; return update; }; function d3_selection_dataNode(data) { return { data: data }; } d3_selectionPrototype.datum = function(value) { return arguments.length ? this.property(“data“, value) : this.property(“data“); }; d3_selectionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== “function”) filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = 0, n = group.length; i &lt; n; i++) { if ((node = group[i]) &amp;&amp; filter.call(node, node.data, i, j)) { subgroup.push(node); } } } return d3_selection(subgroups); }; function d3_selection_filter(selector) { return function() { return d3_selectMatches(this, selector); }; } d3_selectionPrototype.order = function() { for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = group.length - 1, next = group[i], node; –i &gt;= 0; ) { if (node = group[i]) { if (next &amp;&amp; next !== node.nextSibling) next.parentNode.insertBefore(node, next); next = node; } } } return this; }; d3_selectionPrototype.sort = function(comparator) { comparator = d3_selection_sortComparator.apply(this, arguments); for (var j = -1, m = this.length; ++j &lt; m; ) this[j].sort(comparator); return this.order(); }; function d3_selection_sortComparator(comparator) { if (!arguments.length) comparator = d3_ascending; return function(a, b) { return a &amp;&amp; b ? comparator(a.data, b.data) : !a - !b; }; } d3_selectionPrototype.each = function(callback) { return d3_selection_each(this, function(node, i, j) { callback.call(node, node.data, i, j); }); }; function d3_selection_each(groups, callback) { for (var j = 0, m = groups.length; j &lt; m; j++) { for (var group = groups[j], i = 0, n = group.length, node; i &lt; n; i++) { if (node = group[i]) callback(node, i, j); } } return groups; } d3_selectionPrototype.call = function(callback) { var args = d3_array(arguments); callback.apply(args[0] = this, args); return this; }; d3_selectionPrototype.empty = function() { return !this.node(); }; d3_selectionPrototype.node = function() { for (var j = 0, m = this.length; j &lt; m; j++) { for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { var node = group[i]; if (node) return node; } } return null; }; d3_selectionPrototype.size = function() { var n = 0; d3_selection_each(this, function() { ++n; }); return n; }; function d3_selection_enter(selection) { d3_subclass(selection, d3_selection_enterPrototype); return selection; } var d3_selection_enterPrototype = []; d3.selection.enter = d3_selection_enter; d3.selection.enter.prototype = d3_selection_enterPrototype; d3_selection_enterPrototype.append = d3_selectionPrototype.append; d3_selection_enterPrototype.empty = d3_selectionPrototype.empty; d3_selection_enterPrototype.node = d3_selectionPrototype.node; d3_selection_enterPrototype.call = d3_selectionPrototype.call; d3_selection_enterPrototype.size = d3_selectionPrototype.size; d3_selection_enterPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, upgroup, group, node; for (var j = -1, m = this.length; ++j &lt; m; ) { upgroup = (group = this[j]).update; subgroups.push(subgroup = []); subgroup.parentNode = group.parentNode; for (var i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.data, i, j)); subnode.data = node.data; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; d3_selection_enterPrototype.insert = function(name, before) { if (arguments.length &lt; 2) before = d3_selection_enterInsertBefore(this); return d3_selectionPrototype.insert.call(this, name, before); }; function d3_selection_enterInsertBefore(enter) { var i0, j0; return function(d, i, j) { var group = enter[j].update, n = group.length, node; if (j != j0) j0 = j, i0 = 0; if (i &gt;= i0) i0 = i + 1; while (!(node = group[i0]) &amp;&amp; ++i0 &lt; n) ; return node; }; } d3.select = function(node) { var group; if (typeof node === “string”) { group = [ d3_select(node, d3_document) ]; group.parentNode = d3_document.documentElement; } else { group = [ node ]; group.parentNode = d3_documentElement(node); } return d3_selection([ group ]); }; d3.selectAll = function(nodes) { var group; if (typeof nodes === “string”) { group = d3_array(d3_selectAll(nodes, d3_document)); group.parentNode = d3_document.documentElement; } else { group = d3_array(nodes); group.parentNode = null; } return d3_selection([ group ]); }; d3_selectionPrototype.on = function(type, listener, capture) { var n = arguments.length; if (n &lt; 3) { if (typeof type !== “string”) { if (n &lt; 2) listener = false; for (capture in type) this.each(d3_selection_on(capture, type[capture], listener)); return this; } if (n &lt; 2) return (n = this.node()[“on” + type]) &amp;&amp; n._; capture = false; } return this.each(d3_selection_on(type, listener, capture)); }; function d3_selection_on(type, listener, capture) { var name = “on” + type, i = type.indexOf(“.”), wrap = d3_selection_onListener; if (i &gt; 0) type = type.slice(0, i); var filter = d3_selection_onFilters.get(type); if (filter) type = filter, wrap = d3_selection_onFilter; function onRemove() { var l = this[name]; if (l) { this.removeEventListener(type, l, l.$); delete this[name]; } } function onAdd() { var l = wrap(listener, d3_array(arguments)); onRemove.call(this); this.addEventListener(type, this[name] = l, l.$ = capture); l._ = listener; } function removeAll() { var re = new RegExp(“^on([^.]+)” + d3.requote(type) + “$”), match; for (var name in this) { if (match = name.match(re)) { var l = this[name]; this.removeEventListener(match[1], l, l.$); delete this[name]; } } } return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll; } var d3_selection_onFilters = d3.map({ mouseenter: “mouseover”, mouseleave: “mouseout” }); if (d3_document) { d3_selection_onFilters.forEach(function(k) { if (“on” + k in d3_document) d3_selection_onFilters.remove(k); }); } function d3_selection_onListener(listener, argumentz) { return function(e) { var o = d3.event; d3.event = e; argumentz[0] = this.data__; try { listener.apply(this, argumentz); } finally { d3.event = o; } }; } function d3_selection_onFilter(listener, argumentz) { var l = d3_selection_onListener(listener, argumentz); return function(e) { var target = this, related = e.relatedTarget; if (!related || related !== target &amp;&amp; !(related.compareDocumentPosition(target) &amp; 8)) { l.call(target, e); } }; } var d3_event_dragSelect, d3_event_dragId = 0; function d3_event_dragSuppress(node) { var name = “.dragsuppress-“ + ++d3_event_dragId, click = “click” + name, w = d3.select(d3_window(node)).on(“touchmove” + name, d3_eventPreventDefault).on(“dragstart” + name, d3_eventPreventDefault).on(“selectstart” + name, d3_eventPreventDefault); if (d3_event_dragSelect == null) { d3_event_dragSelect = “onselectstart” in node ? false : d3_vendorSymbol(node.style, “userSelect”); } if (d3_event_dragSelect) { var style = d3_documentElement(node).style, select = style[d3_event_dragSelect]; style[d3_event_dragSelect] = “none”; } return function(suppressClick) { w.on(name, null); if (d3_event_dragSelect) style[d3_event_dragSelect] = select; if (suppressClick) { var off = function() { w.on(click, null); }; w.on(click, function() { d3_eventPreventDefault(); off(); }, true); setTimeout(off, 0); } }; } d3.mouse = function(container) { return d3_mousePoint(container, d3_eventSource()); }; var d3_mouse_bug44083 = this.navigator &amp;&amp; /WebKit/.test(this.navigator.userAgent) ? -1 : 0; function d3_mousePoint(container, e) { if (e.changedTouches) e = e.changedTouches[0]; var svg = container.ownerSVGElement || container; if (svg.createSVGPoint) { var point = svg.createSVGPoint(); if (d3_mouse_bug44083 &lt; 0) { var window = d3_window(container); if (window.scrollX || window.scrollY) { svg = d3.select(“body”).append(“svg”).style({ position: “absolute”, top: 0, left: 0, margin: 0, padding: 0, border: “none” }, “important”); var ctm = svg[0][0].getScreenCTM(); d3_mouse_bug44083 = !(ctm.f || ctm.e); svg.remove(); } } if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, point.y = e.clientY; point = point.matrixTransform(container.getScreenCTM().inverse()); return [ point.x, point.y ]; } var rect = container.getBoundingClientRect(); return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ]; } d3.touch = function(container, touches, identifier) { if (arguments.length &lt; 3) identifier = touches, touches = d3_eventSource().changedTouches; if (touches) for (var i = 0, n = touches.length, touch; i &lt; n; ++i) { if ((touch = touches[i]).identifier === identifier) { return d3_mousePoint(container, touch); } } }; d3.behavior.drag = function() { var event = d3_eventDispatch(drag, “drag”, “dragstart”, “dragend”), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, “mousemove”, “mouseup”), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, “touchmove”, “touchend”); function drag() { this.on(“mousedown.drag”, mousedown).on(“touchstart.drag”, touchstart); } function dragstart(id, position, subject, move, end) { return function() { var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = “.drag” + (dragId == null ? “” : “-“ + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId); if (origin) { dragOffset = origin.apply(that, arguments); dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ]; } else { dragOffset = [ 0, 0 ]; } dispatch({ type: “dragstart” }); function moved() { var position1 = position(parent, dragId), dx, dy; if (!position1) return; dx = position1[0] - position0[0]; dy = position1[1] - position0[1]; dragged |= dx | dy; position0 = position1; dispatch({ type: “drag”, x: position1[0] + dragOffset[0], y: position1[1] + dragOffset[1], dx: dx, dy: dy }); } function ended() { if (!position(parent, dragId)) return; dragSubject.on(move + dragName, null).on(end + dragName, null); dragRestore(dragged); dispatch({ type: “dragend” }); } }; } drag.origin = function(x) { if (!arguments.length) return origin; origin = x; return drag; }; return d3.rebind(drag, event, “on”); }; function d3_behavior_dragTouchId() { return d3.event.changedTouches[0].identifier; } d3.touches = function(container, touches) { if (arguments.length &lt; 2) touches = d3_eventSource().touches; return touches ? d3_array(touches).map(function(touch) { var point = d3_mousePoint(container, touch); point.identifier = touch.identifier; return point; }) : []; }; var ε = 1e-6, ε2 = ε ε, π = Math.PI, τ = 2 π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π; function d3_sgn(x) { return x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0; } function d3_cross2d(a, b, c) { return (b[0] - a[0]) (c[1] - a[1]) - (b[1] - a[1]) (c[0] - a[0]); } function d3_acos(x) { return x &gt; 1 ? 0 : x &lt; -1 ? π : Math.acos(x); } function d3_asin(x) { return x &gt; 1 ? halfπ : x &lt; -1 ? -halfπ : Math.asin(x); } function d3_sinh(x) { return ((x = Math.exp(x)) - 1 / x) / 2; } function d3_cosh(x) { return ((x = Math.exp(x)) + 1 / x) / 2; } function d3_tanh(x) { return ((x = Math.exp(2 x)) - 1) / (x + 1); } function d3_haversin(x) { return (x = Math.sin(x / 2)) x; } var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4; d3.interpolateZoom = function(p0, p1) { var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx dx + dy dy, i, S; if (d2 &lt; ε2) { S = Math.log(w1 / w0) / ρ; i = function(t) { return [ ux0 + t dx, uy0 + t dy, w0 Math.exp(ρ t S) ]; }; } else { var d1 = Math.sqrt(d2), b0 = (w1 w1 - w0 w0 + ρ4 d2) / (2 w0 ρ2 d1), b1 = (w1 w1 - w0 w0 - ρ4 d2) / (2 w1 ρ2 d1), r0 = Math.log(Math.sqrt(b0 b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 b1 + 1) - b1); S = (r1 - r0) / ρ; i = function(t) { var s = t S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 d1) (coshr0 d3_tanh(ρ s + r0) - d3_sinh(r0)); return [ ux0 + u dx, uy0 + u dy, w0 coshr0 / d3_cosh(ρ s + r0) ]; }; } i.duration = S 1e3; return i; }; d3.behavior.zoom = function() { var view = { x: 0, y: 0, k: 1 }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = “mousedown.zoom”, mousemove = “mousemove.zoom”, mouseup = “mouseup.zoom”, mousewheelTimer, touchstart = “touchstart.zoom”, touchtime, event = d3_eventDispatch(zoom, “zoomstart”, “zoom”, “zoomend”), x0, x1, y0, y1; if (!d3_behavior_zoomWheel) { d3_behavior_zoomWheel = “onwheel” in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY (d3.event.deltaMode ? 120 : 1); }, “wheel”) : “onmousewheel” in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, “mousewheel”) : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, “MozMousePixelScroll”); } function zoom(g) { g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + “.zoom”, mousewheeled).on(“dblclick.zoom”, dblclicked).on(touchstart, touchstarted); } zoom.event = function(g) { g.each(function() { var dispatch = event.of(this, arguments), view1 = view; if (d3_transitionInheritId) { d3.select(this).transition().each(“start.zoom”, function() { view = this.chart || { x: 0, y: 0, k: 1 }; zoomstarted(dispatch); }).tween(“zoom:zoom”, function() { var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]); return function(t) { var l = i(t), k = dx / l[2]; this.chart = view = { x: cx - l[0] k, y: cy - l[1] k, k: k }; zoomed(dispatch); }; }).each(“interrupt.zoom”, function() { zoomended(dispatch); }).each(“end.zoom”, function() { zoomended(dispatch); }); } else { this.chart = view; zoomstarted(dispatch); zoomed(dispatch); zoomended(dispatch); } }); }; zoom.translate = function() { if (!arguments.length) return [ view.x, view.y ]; view = { x: +[0], y: +[1], k: view.k }; rescale(); return zoom; }; zoom.scale = function() { if (!arguments.length) return view.k; view = { x: view.x, y: view.y, k: null }; scaleTo(+); rescale(); return zoom; }; zoom.scaleExtent = function() { if (!arguments.length) return scaleExtent; scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +[0], +[1] ]; return zoom; }; zoom.center = function(_) { if (!arguments.length) return center; center = _ &amp;&amp; [ +[0], +[1] ]; return zoom; }; zoom.size = function(_) { if (!arguments.length) return size; size = _ &amp;&amp; [ +[0], +[1] ]; return zoom; }; zoom.duration = function() { if (!arguments.length) return duration; duration = +; return zoom; }; zoom.x = function(z) { if (!arguments.length) return x1; x1 = z; x0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; zoom.y = function(z) { if (!arguments.length) return y1; y1 = z; y0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; function location(p) { return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ]; } function point(l) { return [ l[0] view.k + view.x, l[1] view.k + view.y ]; } function scaleTo(s) { view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s)); } function translateTo(p, l) { l = point(l); view.x += p[0] - l[0]; view.y += p[1] - l[1]; } function zoomTo(that, p, l, k) { that.chart = { x: view.x, y: view.y, k: view.k }; scaleTo(Math.pow(2, k)); translateTo(center0 = p, l); that = d3.select(that); if (duration &gt; 0) that = that.transition().duration(duration); that.call(zoom.event); } function rescale() { if (x1) x1.domain(x0.range().map(function(x) { return (x - view.x) / view.k; }).map(x0.invert)); if (y1) y1.domain(y0.range().map(function(y) { return (y - view.y) / view.k; }).map(y0.invert)); } function zoomstarted(dispatch) { if (!zooming++) dispatch({ type: “zoomstart” }); } function zoomed(dispatch) { rescale(); dispatch({ type: “zoom”, scale: view.k, translate: [ view.x, view.y ] }); } function zoomended(dispatch) { if (!–zooming) dispatch({ type: “zoomend” }), center0 = null; } function mousedowned() { var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that); d3_selection_interrupt.call(that); zoomstarted(dispatch); function moved() { dragged = 1; translateTo(d3.mouse(that), location0); zoomed(dispatch); } function ended() { subject.on(mousemove, null).on(mouseup, null); dragRestore(dragged); zoomended(dispatch); } } function touchstarted() { var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = “.zoom-“ + d3.event.changedTouches[0].identifier, touchmove = “touchmove” + zoomName, touchend = “touchend” + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that); started(); zoomstarted(dispatch); subject.on(mousedown, null).on(touchstart, started); function relocate() { var touches = d3.touches(that); scale0 = view.k; touches.forEach(function(t) { if (t.identifier in locations0) locations0[t.identifier] = location(t); }); return touches; } function started() { var target = d3.event.target; d3.select(target).on(touchmove, moved).on(touchend, ended); targets.push(target); var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i &lt; n; ++i) { locations0[changed[i].identifier] = null; } var touches = relocate(), now = Date.now(); if (touches.length === 1) { if (now - touchtime &lt; 500) { var p = touches[0]; zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1); d3_eventPreventDefault(); } touchtime = now; } else if (touches.length &gt; 1) { var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1]; distance0 = dx dx + dy dy; } } function moved() { var touches = d3.touches(that), p0, l0, p1, l1; d3_selection_interrupt.call(that); for (var i = 0, n = touches.length; i &lt; n; ++i, l1 = null) { p1 = touches[i]; if (l1 = locations0[p1.identifier]) { if (l0) break; p0 = p1, l0 = l1; } } if (l1) { var distance1 = (distance1 = p1[0] - p0[0]) distance1 + (distance1 = p1[1] - p0[1]) distance1, scale1 = distance0 &amp;&amp; Math.sqrt(distance1 / distance0); p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ]; l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ]; scaleTo(scale1 scale0); } touchtime = null; translateTo(p0, l0); zoomed(dispatch); } function ended() { if (d3.event.touches.length) { var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i &lt; n; ++i) { delete locations0[changed[i].identifier]; } for (var identifier in locations0) { return void relocate(); } } d3.selectAll(targets).on(zoomName, null); subject.on(mousedown, mousedowned).on(touchstart, touchstarted); dragRestore(); zoomended(dispatch); } } function mousewheeled() { var dispatch = event.of(this, arguments); if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch); mousewheelTimer = setTimeout(function() { mousewheelTimer = null; zoomended(dispatch); }, 50); d3_eventPreventDefault(); scaleTo(Math.pow(2, d3_behavior_zoomDelta() .002) view.k); translateTo(center0, translate0); zoomed(dispatch); } function dblclicked() { var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2; zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1); } return d3.rebind(zoom, event, “on”); }; var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel; d3.color = d3_color; function d3_color() {} d3_color.prototype.toString = function() { return this.rgb() + “”; }; d3.hsl = d3_hsl; function d3_hsl(h, s, l) { return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length &lt; 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(“” + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l); } var d3_hslPrototype = d3_hsl.prototype = new d3_color(); d3_hslPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, this.l / k); }; d3_hslPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, k this.l); }; d3_hslPrototype.rgb = function() { return d3_hsl_rgb(this.h, this.s, this.l); }; function d3_hsl_rgb(h, s, l) { var m1, m2; h = isNaN(h) ? 0 : (h %= 360) &lt; 0 ? h + 360 : h; s = isNaN(s) ? 0 : s &lt; 0 ? 0 : s &gt; 1 ? 1 : s; l = l &lt; 0 ? 0 : l &gt; 1 ? 1 : l; m2 = l &lt;= .5 ? l (1 + s) : l + s - l s; m1 = 2 l - m2; function v(h) { if (h &gt; 360) h -= 360; else if (h &lt; 0) h += 360; if (h &lt; 60) return m1 + (m2 - m1) h / 60; if (h &lt; 180) return m2; if (h &lt; 240) return m1 + (m2 - m1) (240 - h) / 60; return m1; } function vv(h) { return Math.round(v(h) 255); } return new d3_rgb(vv(h + 120), vv(h), vv(h - 120)); } d3.hcl = d3_hcl; function d3_hcl(h, c, l) { return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length &lt; 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l); } var d3_hclPrototype = d3_hcl.prototype = new d3_color(); d3_hclPrototype.brighter = function(k) { return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K (arguments.length ? k : 1))); }; d3_hclPrototype.darker = function(k) { return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K (arguments.length ? k : 1))); }; d3_hclPrototype.rgb = function() { return d3_hcl_lab(this.h, this.c, this.l).rgb(); }; function d3_hcl_lab(h, c, l) { if (isNaN(h)) h = 0; if (isNaN(c)) c = 0; return new d3_lab(l, Math.cos(h = d3_radians) c, Math.sin(h) c); } d3.lab = d3_lab; function d3_lab(l, a, b) { return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length &lt; 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b); } var d3_lab_K = 18; var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883; var d3_labPrototype = d3_lab.prototype = new d3_color(); d3_labPrototype.brighter = function(k) { return new d3_lab(Math.min(100, this.l + d3_lab_K (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.darker = function(k) { return new d3_lab(Math.max(0, this.l - d3_lab_K (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.rgb = function() { return d3_lab_rgb(this.l, this.a, this.b); }; function d3_lab_rgb(l, a, b) { var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200; x = d3_lab_xyz(x) d3_lab_X; y = d3_lab_xyz(y) d3_lab_Y; z = d3_lab_xyz(z) d3_lab_Z; return new d3_rgb(d3_xyz_rgb(3.2404542 x - 1.5371385 y - .4985314 z), d3_xyz_rgb(-.969266 x + 1.8760108 y + .041556 z), d3_xyz_rgb(.0556434 x - .2040259 y + 1.0572252 z)); } function d3_lab_hcl(l, a, b) { return l &gt; 0 ? new d3_hcl(Math.atan2(b, a) d3_degrees, Math.sqrt(a a + b b), l) : new d3_hcl(NaN, NaN, l); } function d3_lab_xyz(x) { return x &gt; .206893034 ? x x x : (x - 4 / 29) / 7.787037; } function d3_xyz_lab(x) { return x &gt; .008856 ? Math.pow(x, 1 / 3) : 7.787037 x + 4 / 29; } function d3_xyz_rgb(r) { return Math.round(255 (r &lt;= .00304 ? 12.92 r : 1.055 Math.pow(r, 1 / 2.4) - .055)); } d3.rgb = d3_rgb; function d3_rgb(r, g, b) { return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length &lt; 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(“” + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b); } function d3_rgbNumber(value) { return new d3_rgb(value &gt;&gt; 16, value &gt;&gt; 8 &amp; 255, value &amp; 255); } function d3_rgbString(value) { return d3_rgbNumber(value) + “”; } var d3_rgbPrototype = d3_rgb.prototype = new d3_color(); d3_rgbPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); var r = this.r, g = this.g, b = this.b, i = 30; if (!r &amp;&amp; !g &amp;&amp; !b) return new d3_rgb(i, i, i); if (r &amp;&amp; r &lt; i) r = i; if (g &amp;&amp; g &lt; i) g = i; if (b &amp;&amp; b &lt; i) b = i; return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k)); }; d3_rgbPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_rgb(k this.r, k this.g, k this.b); }; d3_rgbPrototype.hsl = function() { return d3_rgb_hsl(this.r, this.g, this.b); }; d3_rgbPrototype.toString = function() { return “#” + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b); }; function d3_rgb_hex(v) { return v &lt; 16 ? “0” + Math.max(0, v).toString(16) : Math.min(255, v).toString(16); } function d3_rgb_parse(format, rgb, hsl) { var r = 0, g = 0, b = 0, m1, m2, color; m1 = /([a-z]+)((.))/.exec(format = format.toLowerCase()); if (m1) { m2 = m1[2].split(“,”); switch (m1[1]) { case “hsl”: { return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100); } case “rgb”: { return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2])); } } } if (color = d3_rgb_names.get(format)) { return rgb(color.r, color.g, color.b); } if (format != null &amp;&amp; format.charAt(0) === “#” &amp;&amp; !isNaN(color = parseInt(format.slice(1), 16))) { if (format.length === 4) { r = (color &amp; 3840) &gt;&gt; 4; r = r &gt;&gt; 4 | r; g = color &amp; 240; g = g &gt;&gt; 4 | g; b = color &amp; 15; b = b &lt;&lt; 4 | b; } else if (format.length === 7) { r = (color &amp; 16711680) &gt;&gt; 16; g = (color &amp; 65280) &gt;&gt; 8; b = color &amp; 255; } } return rgb(r, g, b); } function d3_rgb_hsl(r, g, b) { var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2; if (d) { s = l &lt; .5 ? d / (max + min) : d / (2 - max - min); if (r == max) h = (g - b) / d + (g &lt; b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4; h = 60; } else { h = NaN; s = l &gt; 0 &amp;&amp; l &lt; 1 ? 0 : h; } return new d3_hsl(h, s, l); } function d3_rgb_lab(r, g, b) { r = d3_rgb_xyz(r); g = d3_rgb_xyz(g); b = d3_rgb_xyz(b); var x = d3_xyz_lab((.4124564 r + .3575761 g + .1804375 b) / d3_lab_X), y = d3_xyz_lab((.2126729 r + .7151522 g + .072175 b) / d3_lab_Y), z = d3_xyz_lab((.0193339 r + .119192 g + .9503041 b) / d3_lab_Z); return d3_lab(116 y - 16, 500 (x - y), 200 (y - z)); } function d3_rgb_xyz(r) { return (r /= 255) &lt;= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4); } function d3_rgb_parseNumber(c) { var f = parseFloat(c); return c.charAt(c.length - 1) === “%” ? Math.round(f 2.55) : f; } var d3_rgb_names = d3.map({ aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }); d3_rgb_names.forEach(function(key, value) { d3_rgb_names.set(key, d3_rgbNumber(value)); }); function d3_functor(v) { return typeof v === “function” ? v : function() { return v; }; } d3.functor = d3_functor; d3.xhr = d3_xhrType(d3_identity); function d3_xhrType(response) { return function(url, mimeType, callback) { if (arguments.length === 2 &amp;&amp; typeof mimeType === “function”) callback = mimeType, mimeType = null; return d3_xhr(url, mimeType, response, callback); }; } function d3_xhr(url, mimeType, response, callback) { var xhr = {}, dispatch = d3.dispatch(“beforesend”, “progress”, “load”, “error”), headers = {}, request = new XMLHttpRequest(), responseType = null; if (this.XDomainRequest &amp;&amp; !(“withCredentials” in request) &amp;&amp; /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest(); “onload” in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() { request.readyState &gt; 3 &amp;&amp; respond(); }; function respond() { var status = request.status, result; if (!status &amp;&amp; d3_xhrHasResponse(request) || status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304) { try { result = response.call(xhr, request); } catch (e) { dispatch.error.call(xhr, e); return; } dispatch.load.call(xhr, result); } else { dispatch.error.call(xhr, request); } } request.onprogress = function(event) { var o = d3.event; d3.event = event; try { dispatch.progress.call(xhr, request); } finally { d3.event = o; } }; xhr.header = function(name, value) { name = (name + “”).toLowerCase(); if (arguments.length &lt; 2) return headers[name]; if (value == null) delete headers[name]; else headers[name] = value + “”; return xhr; }; xhr.mimeType = function(value) { if (!arguments.length) return mimeType; mimeType = value == null ? null : value + “”; return xhr; }; xhr.responseType = function(value) { if (!arguments.length) return responseType; responseType = value; return xhr; }; xhr.response = function(value) { response = value; return xhr; }; [ “get”, “post” ].forEach(function(method) { xhr[method] = function() { return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments))); }; }); xhr.send = function(method, data, callback) { if (arguments.length === 2 &amp;&amp; typeof data === “function”) callback = data, data = null; request.open(method, url, true); if (mimeType != null &amp;&amp; !(“accept” in headers)) headers[“accept”] = mimeType + “,/“; if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]); if (mimeType != null &amp;&amp; request.overrideMimeType) request.overrideMimeType(mimeType); if (responseType != null) request.responseType = responseType; if (callback != null) xhr.on(“error”, callback).on(“load”, function(request) { callback(null, request); }); dispatch.beforesend.call(xhr, request); request.send(data == null ? null : data); return xhr; }; xhr.abort = function() { request.abort(); return xhr; }; d3.rebind(xhr, dispatch, “on”); return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback)); } function d3_xhr_fixCallback(callback) { return callback.length === 1 ? function(error, request) { callback(error == null ? request : null); } : callback; } function d3_xhrHasResponse(request) { var type = request.responseType; return type &amp;&amp; type !== “text” ? request.response : request.responseText; } d3.dsv = function(delimiter, mimeType) { var reFormat = new RegExp(‘[“‘ + delimiter + “\n]”), delimiterCode = delimiter.charCodeAt(0); function dsv(url, row, callback) { if (arguments.length &lt; 3) callback = row, row = null; var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback); xhr.row = function(_) { return arguments.length ? xhr.response((row = ) == null ? response : typedResponse()) : row; }; return xhr; } function response(request) { return dsv.parse(request.responseText); } function typedResponse(f) { return function(request) { return dsv.parse(request.responseText, f); }; } dsv.parse = function(text, f) { var o; return dsv.parseRows(text, function(row, i) { if (o) return o(row, i - 1); var a = new Function(“d”, “return {“ + row.map(function(name, i) { return JSON.stringify(name) + “: d[“ + i + “]”; }).join(“,”) + “}”); o = f ? function(row, i) { return f(a(row), i); } : a; }); }; dsv.parseRows = function(text, f) { var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol; function token() { if (I &gt;= N) return EOF; if (eol) return eol = false, EOL; var j = I; if (text.charCodeAt(j) === 34) { var i = j; while (i++ &lt; N) { if (text.charCodeAt(i) === 34) { if (text.charCodeAt(i + 1) !== 34) break; ++i; } } I = i + 2; var c = text.charCodeAt(i + 1); if (c === 13) { eol = true; if (text.charCodeAt(i + 2) === 10) ++I; } else if (c === 10) { eol = true; } return text.slice(j + 1, i).replace(/“”/g, ‘“‘); } while (I &lt; N) { var c = text.charCodeAt(I++), k = 1; if (c === 10) eol = true; else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } else if (c !== delimiterCode) continue; return text.slice(j, I - k); } return text.slice(j); } while ((t = token()) !== EOF) { var a = []; while (t !== EOL &amp;&amp; t !== EOF) { a.push(t); t = token(); } if (f &amp;&amp; (a = f(a, n++)) == null) continue; rows.push(a); } return rows; }; dsv.format = function(rows) { if (Array.isArray(rows[0])) return dsv.formatRows(rows); var fieldSet = new d3_Set(), fields = []; rows.forEach(function(row) { for (var field in row) { if (!fieldSet.has(field)) { fields.push(fieldSet.add(field)); } } }); return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) { return fields.map(function(field) { return formatValue(row[field]); }).join(delimiter); })).join(“\n”); }; dsv.formatRows = function(rows) { return rows.map(formatRow).join(“\n”); }; function formatRow(row) { return row.map(formatValue).join(delimiter); } function formatValue(text) { return reFormat.test(text) ? ‘“‘ + text.replace(/\”/g, ‘“”‘) + ‘“‘ : text; } return dsv; }; d3.csv = d3.dsv(“,”, “text/csv”); d3.tsv = d3.dsv(“ “, “text/tab-separated-values”); var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, “requestAnimationFrame”)] || function(callback) { setTimeout(callback, 17); }; d3.timer = function() { d3_timer.apply(this, arguments); }; function d3_timer(callback, delay, then) { var n = arguments.length; if (n &lt; 2) delay = 0; if (n &lt; 3) then = Date.now(); var time = then + delay, timer = { c: callback, t: time, n: null }; if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer; d3_timer_queueTail = timer; if (!d3_timer_interval) { d3_timer_timeout = clearTimeout(d3_timer_timeout); d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } return timer; } function d3_timer_step() { var now = d3_timer_mark(), delay = d3_timer_sweep() - now; if (delay &gt; 24) { if (isFinite(delay)) { clearTimeout(d3_timer_timeout); d3_timer_timeout = setTimeout(d3_timer_step, delay); } d3_timer_interval = 0; } else { d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } } d3.timer.flush = function() { d3_timer_mark(); d3_timer_sweep(); }; function d3_timer_mark() { var now = Date.now(), timer = d3_timer_queueHead; while (timer) { if (now &gt;= timer.t &amp;&amp; timer.c(now - timer.t)) timer.c = null; timer = timer.n; } return now; } function d3_timer_sweep() { var t0, t1 = d3_timer_queueHead, time = Infinity; while (t1) { if (t1.c) { if (t1.t &lt; time) time = t1.t; t1 = (t0 = t1).n; } else { t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n; } } d3_timer_queueTail = t0; return time; } function d3_format_precision(x, p) { return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1); } d3.round = function(x, n) { return n ? Math.round(x (n = Math.pow(10, n))) / n : Math.round(x); }; var d3_formatPrefixes = [ “y”, “z”, “a”, “f”, “p”, “n”, “µ”, “m”, “”, “k”, “M”, “G”, “T”, “P”, “E”, “Z”, “Y” ].map(d3_formatPrefix); d3.formatPrefix = function(value, precision) { var i = 0; if (value = +value) { if (value &lt; 0) value = -1; if (precision) value = d3.round(value, d3_format_precision(value, precision)); i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10); i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) 3)); } return d3_formatPrefixes[8 + i / 3]; }; function d3_formatPrefix(d, i) { var k = Math.pow(10, abs(8 - i) 3); return { scale: i &gt; 8 ? function(d) { return d / k; } : function(d) { return d k; }, symbol: d }; } function d3_locale_numberFormat(locale) { var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping &amp;&amp; locale_thousands ? function(value, width) { var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0; while (i &gt; 0 &amp;&amp; g &gt; 0) { if (length + g + 1 &gt; width) g = Math.max(1, width - length); t.push(value.substring(i -= g, i + g)); if ((length += g + 1) &gt; width) break; g = locale_grouping[j = (j + 1) % locale_grouping.length]; } return t.reverse().join(locale_thousands); } : d3_identity; return function(specifier) { var match = d3_format_re.exec(specifier), fill = match[1] || “ “, align = match[2] || “&gt;”, sign = match[3] || “-“, symbol = match[4] || “”, zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = “”, suffix = “”, integer = false, exponent = true; if (precision) precision = +precision.substring(1); if (zfill || fill === “0” &amp;&amp; align === “=”) { zfill = fill = “0”; align = “=”; } switch (type) { case “n”: comma = true; type = “g”; break; case “%”: scale = 100; suffix = “%”; type = “f”; break; case “p”: scale = 100; suffix = “%”; type = “r”; break; case “b”: case “o”: case “x”: case “X”: if (symbol === “#”) prefix = “0” + type.toLowerCase(); case “c”: exponent = false; case “d”: integer = true; precision = 0; break; case “s”: scale = -1; type = “r”; break; } if (symbol === “$”) prefix = locale_currency[0], suffix = locale_currency[1]; if (type == “r” &amp;&amp; !precision) type = “g”; if (precision != null) { if (type == “g”) precision = Math.max(1, Math.min(21, precision)); else if (type == “e” || type == “f”) precision = Math.max(0, Math.min(20, precision)); } type = d3_format_types.get(type) || d3_format_typeDefault; var zcomma = zfill &amp;&amp; comma; return function(value) { var fullSuffix = suffix; if (integer &amp;&amp; value % 1) return “”; var negative = value &lt; 0 || value === 0 &amp;&amp; 1 / value &lt; 0 ? (value = -value, “-“) : sign === “-“ ? “” : sign; if (scale &lt; 0) { var unit = d3.formatPrefix(value, precision); value = unit.scale(value); fullSuffix = unit.symbol + suffix; } else { value = scale; } value = type(value, precision); var i = value.lastIndexOf(“.”), before, after; if (i &lt; 0) { var j = exponent ? value.lastIndexOf(“e”) : -1; if (j &lt; 0) before = value, after = “”; else before = value.substring(0, j), after = value.substring(j); } else { before = value.substring(0, i); after = locale_decimal + value.substring(i + 1); } if (!zfill &amp;&amp; comma) before = formatGroup(before, Infinity); var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length &lt; width ? new Array(length = width - length + 1).join(fill) : “”; if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity); negative += prefix; value = before + after; return (align === “&lt;” ? negative + value + padding : align === “&gt;” ? padding + negative + value : align === “^” ? padding.substring(0, length &gt;&gt;= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix; }; }; } var d3_format_re = /(?:([^{])?([&lt;&gt;=^]))?([+- ])?([$#])?(0)?(\d+)?(,)?(.-?\d+)?([a-z%])?/i; var d3_format_types = d3.map({ b: function(x) { return x.toString(2); }, c: function(x) { return String.fromCharCode(x); }, o: function(x) { return x.toString(8); }, x: function(x) { return x.toString(16); }, X: function(x) { return x.toString(16).toUpperCase(); }, g: function(x, p) { return x.toPrecision(p); }, e: function(x, p) { return x.toExponential(p); }, f: function(x, p) { return x.toFixed(p); }, r: function(x, p) { return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x (1 + 1e-15), p)))); } }); function d3_format_typeDefault(x) { return x + “”; } var d3_time = d3.time = {}, d3_date = Date; function d3_date_utc() { this._ = new Date(arguments.length &gt; 1 ? Date.UTC.apply(this, arguments) : arguments[0]); } d3_date_utc.prototype = { getDate: function() { return this..getUTCDate(); }, getDay: function() { return this..getUTCDay(); }, getFullYear: function() { return this..getUTCFullYear(); }, getHours: function() { return this..getUTCHours(); }, getMilliseconds: function() { return this..getUTCMilliseconds(); }, getMinutes: function() { return this..getUTCMinutes(); }, getMonth: function() { return this..getUTCMonth(); }, getSeconds: function() { return this..getUTCSeconds(); }, getTime: function() { return this..getTime(); }, getTimezoneOffset: function() { return 0; }, valueOf: function() { return this..valueOf(); }, setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); }, setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); }, setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); }, setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); }, setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); }, setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); }, setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); }, setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); }, setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); } }; var d3_time_prototype = Date.prototype; function d3_time_interval(local, step, number) { function round(date) { var d0 = local(date), d1 = offset(d0, 1); return date - d0 &lt; d1 - date ? d0 : d1; } function ceil(date) { step(date = local(new d3_date(date - 1)), 1); return date; } function offset(date, k) { step(date = new d3_date(+date), k); return date; } function range(t0, t1, dt) { var time = ceil(t0), times = []; if (dt &gt; 1) { while (time &lt; t1) { if (!(number(time) % dt)) times.push(new Date(+time)); step(time, 1); } } else { while (time &lt; t1) times.push(new Date(+time)), step(time, 1); } return times; } function range_utc(t0, t1, dt) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = t0; return range(utc, t1, dt); } finally { d3_date = Date; } } local.floor = local; local.round = round; local.ceil = ceil; local.offset = offset; local.range = range; var utc = local.utc = d3_time_interval_utc(local); utc.floor = utc; utc.round = d3_time_interval_utc(round); utc.ceil = d3_time_interval_utc(ceil); utc.offset = d3_time_interval_utc(offset); utc.range = range_utc; return local; } function d3_time_interval_utc(method) { return function(date, k) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = date; return method(utc, k)._; } finally { d3_date = Date; } }; } d3_time.year = d3_time_interval(function(date) { date = d3_time.day(date); date.setMonth(0, 1); return date; }, function(date, offset) { date.setFullYear(date.getFullYear() + offset); }, function(date) { return date.getFullYear(); }); d3_time.years = d3_time.year.range; d3_time.years.utc = d3_time.year.utc.range; d3_time.day = d3_time_interval(function(date) { var day = new d3_date(2e3, 0); day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()); return day; }, function(date, offset) { date.setDate(date.getDate() + offset); }, function(date) { return date.getDate() - 1; }); d3_time.days = d3_time.day.range; d3_time.days.utc = d3_time.day.utc.range; d3_time.dayOfYear = function(date) { var year = d3_time.year(date); return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) 6e4) / 864e5); }; [ “sunday”, “monday”, “tuesday”, “wednesday”, “thursday”, “friday”, “saturday” ].forEach(function(day, i) { i = 7 - i; var interval = d3_time[day] = d3_time_interval(function(date) { (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7); return date; }, function(date, offset) { date.setDate(date.getDate() + Math.floor(offset) 7); }, function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i); }); d3_time[day + “s”] = interval.range; d3_time[day + “s”].utc = interval.utc.range; d3_time[day + “OfYear”] = function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7); }; }); d3_time.week = d3_time.sunday; d3_time.weeks = d3_time.sunday.range; d3_time.weeks.utc = d3_time.sunday.utc.range; d3_time.weekOfYear = d3_time.sundayOfYear; function d3_locale_timeFormat(locale) { var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths; function d3_time_format(template) { var n = template.length; function format(date) { var string = [], i = -1, j = 0, c, p, f; while (++i &lt; n) { if (template.charCodeAt(i) === 37) { string.push(template.slice(j, i)); if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i); if (f = d3_time_formats[c]) c = f(date, p == null ? c === “e” ? “ “ : “0” : p); string.push(c); j = i + 1; } } string.push(template.slice(j, i)); return string.join(“”); } format.parse = function(string) { var d = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, i = d3_time_parse(d, template, string, 0); if (i != string.length) return null; if (“p” in d) d.H = d.H % 12 + d.p 12; var localZ = d.Z != null &amp;&amp; d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)(); if (“j” in d) date.setFullYear(d.y, 0, d.j); else if (“W” in d || “U” in d) { if (!(“w” in d)) d.w = “W” in d ? 1 : 0; date.setFullYear(d.y, 0, 1); date.setFullYear(d.y, 0, “W” in d ? (d.w + 6) % 7 + d.W 7 - (date.getDay() + 5) % 7 : d.w + d.U 7 - (date.getDay() + 6) % 7); } else date.setFullYear(d.y, d.m, d.d); date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L); return localZ ? date._ : date; }; format.toString = function() { return template; }; return format; } function d3_time_parse(date, template, string, j) { var c, p, t, i = 0, n = template.length, m = string.length; while (i &lt; n) { if (j &gt;= m) return -1; c = template.charCodeAt(i++); if (c === 37) { t = template.charAt(i++); p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t]; if (!p || (j = p(date, string, j)) &lt; 0) return -1; } else if (c != string.charCodeAt(j++)) { return -1; } } return j; } d3_time_format.utc = function(template) { var local = d3_time_format(template); function format(date) { try { d3_date = d3_date_utc; var utc = new d3_date(); utc._ = date; return local(utc); } finally { d3_date = Date; } } format.parse = function(string) { try { d3_date = d3_date_utc; var date = local.parse(string); return date &amp;&amp; date._; } finally { d3_date = Date; } }; format.toString = local.toString; return format; }; d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti; var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths); locale_periods.forEach(function(p, i) { d3_time_periodLookup.set(p.toLowerCase(), i); }); var d3_time_formats = { a: function(d) { return locale_shortDays[d.getDay()]; }, A: function(d) { return locale_days[d.getDay()]; }, b: function(d) { return locale_shortMonths[d.getMonth()]; }, B: function(d) { return locale_months[d.getMonth()]; }, c: d3_time_format(locale_dateTime), d: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, e: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, H: function(d, p) { return d3_time_formatPad(d.getHours(), p, 2); }, I: function(d, p) { return d3_time_formatPad(d.getHours() % 12 || 12, p, 2); }, j: function(d, p) { return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3); }, L: function(d, p) { return d3_time_formatPad(d.getMilliseconds(), p, 3); }, m: function(d, p) { return d3_time_formatPad(d.getMonth() + 1, p, 2); }, M: function(d, p) { return d3_time_formatPad(d.getMinutes(), p, 2); }, p: function(d) { return locale_periods[+(d.getHours() &gt;= 12)]; }, S: function(d, p) { return d3_time_formatPad(d.getSeconds(), p, 2); }, U: function(d, p) { return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2); }, w: function(d) { return d.getDay(); }, W: function(d, p) { return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2); }, x: d3_time_format(locale_date), X: d3_time_format(locale_time), y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 100, p, 2); }, Y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 1e4, p, 4); }, Z: d3_time_zone, “%”: function() { return “%”; } }; var d3_time_parsers = { a: d3_time_parseWeekdayAbbrev, A: d3_time_parseWeekday, b: d3_time_parseMonthAbbrev, B: d3_time_parseMonth, c: d3_time_parseLocaleFull, d: d3_time_parseDay, e: d3_time_parseDay, H: d3_time_parseHour24, I: d3_time_parseHour24, j: d3_time_parseDayOfYear, L: d3_time_parseMilliseconds, m: d3_time_parseMonthNumber, M: d3_time_parseMinutes, p: d3_time_parseAmPm, S: d3_time_parseSeconds, U: d3_time_parseWeekNumberSunday, w: d3_time_parseWeekdayNumber, W: d3_time_parseWeekNumberMonday, x: d3_time_parseLocaleDate, X: d3_time_parseLocaleTime, y: d3_time_parseYear, Y: d3_time_parseFullYear, Z: d3_time_parseZone, “%”: d3_time_parseLiteralPercent }; function d3_time_parseWeekdayAbbrev(date, string, i) { d3_time_dayAbbrevRe.lastIndex = 0; var n = d3_time_dayAbbrevRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseWeekday(date, string, i) { d3_time_dayRe.lastIndex = 0; var n = d3_time_dayRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonthAbbrev(date, string, i) { d3_time_monthAbbrevRe.lastIndex = 0; var n = d3_time_monthAbbrevRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonth(date, string, i) { d3_time_monthRe.lastIndex = 0; var n = d3_time_monthRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseLocaleFull(date, string, i) { return d3_time_parse(date, d3_time_formats.c.toString(), string, i); } function d3_time_parseLocaleDate(date, string, i) { return d3_time_parse(date, d3_time_formats.x.toString(), string, i); } function d3_time_parseLocaleTime(date, string, i) { return d3_time_parse(date, d3_time_formats.X.toString(), string, i); } function d3_time_parseAmPm(date, string, i) { var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase()); return n == null ? -1 : (date.p = n, i); } return d3_time_format; } var d3_time_formatPads = { “-“: “”, _: “ “, “0”: “0” }, d3_time_numberRe = /^\s\d+/, d3_time_percentRe = /^%/; function d3_time_formatPad(value, fill, width) { var sign = value &lt; 0 ? “-“ : “”, string = (sign ? -value : value) + “”, length = string.length; return sign + (length &lt; width ? new Array(width - length + 1).join(fill) + string : string); } function d3_time_formatRe(names) { return new RegExp(“^(?:” + names.map(d3.requote).join(“|”) + “)”, “i”); } function d3_time_formatLookup(names) { var map = new d3_Map(), i = -1, n = names.length; while (++i &lt; n) map.set(names[i].toLowerCase(), i); return map; } function d3_time_parseWeekdayNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 1)); return n ? (date.w = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberSunday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.U = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberMonday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.W = +n[0], i + n[0].length) : -1; } function d3_time_parseFullYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 4)); return n ? (date.y = +n[0], i + n[0].length) : -1; } function d3_time_parseYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1; } function d3_time_parseZone(date, string, i) { return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1; } function d3_time_expandYear(d) { return d + (d &gt; 68 ? 1900 : 2e3); } function d3_time_parseMonthNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.m = n[0] - 1, i + n[0].length) : -1; } function d3_time_parseDay(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.d = +n[0], i + n[0].length) : -1; } function d3_time_parseDayOfYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.j = +n[0], i + n[0].length) : -1; } function d3_time_parseHour24(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.H = +n[0], i + n[0].length) : -1; } function d3_time_parseMinutes(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.M = +n[0], i + n[0].length) : -1; } function d3_time_parseSeconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.S = +n[0], i + n[0].length) : -1; } function d3_time_parseMilliseconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.L = +n[0], i + n[0].length) : -1; } function d3_time_zone(d) { var z = d.getTimezoneOffset(), zs = z &gt; 0 ? “-“ : “+”, zh = abs(z) / 60 | 0, zm = abs(z) % 60; return zs + d3_time_formatPad(zh, “0”, 2) + d3_time_formatPad(zm, “0”, 2); } function d3_time_parseLiteralPercent(date, string, i) { d3_time_percentRe.lastIndex = 0; var n = d3_time_percentRe.exec(string.slice(i, i + 1)); return n ? i + n[0].length : -1; } function d3_time_formatMulti(formats) { var n = formats.length, i = -1; while (++i &lt; n) formats[i][0] = this(formats[i][0]); return function(date) { var i = 0, f = formats[i]; while (!f1) f = formats[++i]; return f0; }; } d3.locale = function(locale) { return { numberFormat: d3_locale_numberFormat(locale), timeFormat: d3_locale_timeFormat(locale) }; }; var d3_locale_enUS = d3.locale({ decimal: “.”, thousands: “,”, grouping: [ 3 ], currency: [ “$”, “” ], dateTime: “%a %b %e %X %Y”, date: “%m/%d/%Y”, time: “%H:%M:%S”, periods: [ “AM”, “PM” ], days: [ “Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday” ], shortDays: [ “Sun”, “Mon”, “Tue”, “Wed”, “Thu”, “Fri”, “Sat” ], months: [ “January”, “February”, “March”, “April”, “May”, “June”, “July”, “August”, “September”, “October”, “November”, “December” ], shortMonths: [ “Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec” ] }); d3.format = d3_locale_enUS.numberFormat; d3.geo = {}; function d3_adder() {} d3_adder.prototype = { s: 0, t: 0, add: function(y) { d3_adderSum(y, this.t, d3_adderTemp); d3_adderSum(d3_adderTemp.s, this.s, this); if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t; }, reset: function() { this.s = this.t = 0; }, valueOf: function() { return this.s; } }; var d3_adderTemp = new d3_adder(); function d3_adderSum(a, b, o) { var x = o.s = a + b, bv = x - a, av = x - bv; o.t = a - av + (b - bv); } d3.geo.stream = function(object, listener) { if (object &amp;&amp; d3_geo_streamObjectType.hasOwnProperty(object.type)) { d3_geo_streamObjectTypeobject.type; } else { d3_geo_streamGeometry(object, listener); } }; function d3_geo_streamGeometry(geometry, listener) { if (geometry &amp;&amp; d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) { d3_geo_streamGeometryTypegeometry.type; } } var d3_geo_streamObjectType = { Feature: function(feature, listener) { d3_geo_streamGeometry(feature.geometry, listener); }, FeatureCollection: function(object, listener) { var features = object.features, i = -1, n = features.length; while (++i &lt; n) d3_geo_streamGeometry(features[i].geometry, listener); } }; var d3_geo_streamGeometryType = { Sphere: function(object, listener) { listener.sphere(); }, Point: function(object, listener) { object = object.coordinates; listener.point(object[0], object[1], object[2]); }, MultiPoint: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) object = coordinates[i], listener.point(object[0], object[1], object[2]); }, LineString: function(object, listener) { d3_geo_streamLine(object.coordinates, listener, 0); }, MultiLineString: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) d3_geo_streamLine(coordinates[i], listener, 0); }, Polygon: function(object, listener) { d3_geo_streamPolygon(object.coordinates, listener); }, MultiPolygon: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i &lt; n) d3_geo_streamPolygon(coordinates[i], listener); }, GeometryCollection: function(object, listener) { var geometries = object.geometries, i = -1, n = geometries.length; while (++i &lt; n) d3_geo_streamGeometry(geometries[i], listener); } }; function d3_geo_streamLine(coordinates, listener, closed) { var i = -1, n = coordinates.length - closed, coordinate; listener.lineStart(); while (++i &lt; n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]); listener.lineEnd(); } function d3_geo_streamPolygon(coordinates, listener) { var i = -1, n = coordinates.length; listener.polygonStart(); while (++i &lt; n) d3_geo_streamLine(coordinates[i], listener, 1); listener.polygonEnd(); } d3.geo.area = function(object) { d3_geo_areaSum = 0; d3.geo.stream(object, d3_geo_area); return d3_geo_areaSum; }; var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder(); var d3_geo_area = { sphere: function() { d3_geo_areaSum += 4 π; }, point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_areaRingSum.reset(); d3_geo_area.lineStart = d3_geo_areaRingStart; }, polygonEnd: function() { var area = 2 d3_geo_areaRingSum; d3_geo_areaSum += area &lt; 0 ? 4 π + area : area; d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop; } }; function d3_geo_areaRingStart() { var λ00, φ00, λ0, cosφ0, sinφ0; d3_geo_area.point = function(λ, φ) { d3_geo_area.point = nextPoint; λ0 = (λ00 = λ) d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ); }; function nextPoint(λ, φ) { λ = d3_radians; φ = φ d3_radians / 2 + π / 4; var dλ = λ - λ0, sdλ = dλ &gt;= 0 ? 1 : -1, adλ = sdλ dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 sinφ, u = cosφ0 cosφ + k Math.cos(adλ), v = k sdλ Math.sin(adλ); d3_geo_areaRingSum.add(Math.atan2(v, u)); λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ; } d3_geo_area.lineEnd = function() { nextPoint(λ00, φ00); }; } function d3_geo_cartesian(spherical) { var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ); return [ cosφ Math.cos(λ), cosφ Math.sin(λ), Math.sin(φ) ]; } function d3_geo_cartesianDot(a, b) { return a[0] b[0] + a[1] b[1] + a[2] b[2]; } function d3_geo_cartesianCross(a, b) { return [ a[1] b[2] - a[2] b[1], a[2] b[0] - a[0] b[2], a[0] b[1] - a[1] b[0] ]; } function d3_geo_cartesianAdd(a, b) { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; } function d3_geo_cartesianScale(vector, k) { return [ vector[0] k, vector[1] k, vector[2] k ]; } function d3_geo_cartesianNormalize(d) { var l = Math.sqrt(d[0] d[0] + d[1] d[1] + d[2] d[2]); d[0] /= l; d[1] /= l; d[2] /= l; } function d3_geo_spherical(cartesian) { return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ]; } function d3_geo_sphericalEqual(a, b) { return abs(a[0] - b[0]) &lt; ε &amp;&amp; abs(a[1] - b[1]) &lt; ε; } d3.geo.bounds = function() { var λ0, φ0, λ1, φ1, λ_, λ, φ, p0, dλSum, ranges, range; var bound = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { bound.point = ringPoint; bound.lineStart = ringStart; bound.lineEnd = ringEnd; dλSum = 0; d3_geo_area.polygonStart(); }, polygonEnd: function() { d3_geo_area.polygonEnd(); bound.point = point; bound.lineStart = lineStart; bound.lineEnd = lineEnd; if (d3_geo_areaRingSum &lt; 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum &gt; ε) φ1 = 90; else if (dλSum &lt; -ε) φ0 = -90; range[0] = λ0, range[1] = λ1; } }; function point(λ, φ) { ranges.push(range = [ λ0 = λ, λ1 = λ ]); if (φ &lt; φ0) φ0 = φ; if (φ &gt; φ1) φ1 = φ; } function linePoint(λ, φ) { var p = d3_geo_cartesian([ λ d3_radians, φ d3_radians ]); if (p0) { var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal); d3_geo_cartesianNormalize(inflection); inflection = d3_geo_spherical(inflection); var dλ = λ - λ_, s = dλ &gt; 0 ? 1 : -1, λi = inflection[0] d3_degrees s, antimeridian = abs(dλ) &gt; 180; if (antimeridian ^ (s λ_ &lt; λi &amp;&amp; λi &lt; s λ)) { var φi = inflection[1] d3_degrees; if (φi &gt; φ1) φ1 = φi; } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s λ_ &lt; λi &amp;&amp; λi &lt; s λ)) { var φi = -inflection[1] d3_degrees; if (φi &lt; φ0) φ0 = φi; } else { if (φ &lt; φ0) φ0 = φ; if (φ &gt; φ1) φ1 = φ; } if (antimeridian) { if (λ &lt; λ) { if (angle(λ0, λ) &gt; angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) &gt; angle(λ0, λ1)) λ0 = λ; } } else { if (λ1 &gt;= λ0) { if (λ &lt; λ0) λ0 = λ; if (λ &gt; λ1) λ1 = λ; } else { if (λ &gt; λ) { if (angle(λ0, λ) &gt; angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) &gt; angle(λ0, λ1)) λ0 = λ; } } } } else { point(λ, φ); } p0 = p, λ_ = λ; } function lineStart() { bound.point = linePoint; } function lineEnd() { range[0] = λ0, range[1] = λ1; bound.point = point; p0 = null; } function ringPoint(λ, φ) { if (p0) { var dλ = λ - λ_; dλSum += abs(dλ) &gt; 180 ? dλ + (dλ &gt; 0 ? 360 : -360) : dλ; } else λ = λ, φ = φ; d3_geo_area.point(λ, φ); linePoint(λ, φ); } function ringStart() { d3_geo_area.lineStart(); } function ringEnd() { ringPoint(λ, φ); d3_geo_area.lineEnd(); if (abs(dλSum) &gt; ε) λ0 = -(λ1 = 180); range[0] = λ0, range[1] = λ1; p0 = null; } function angle(λ0, λ1) { return (λ1 -= λ0) &lt; 0 ? λ1 + 360 : λ1; } function compareRanges(a, b) { return a[0] - b[0]; } function withinRange(x, range) { return range[0] &lt;= range[1] ? range[0] &lt;= x &amp;&amp; x &lt;= range[1] : x &lt; range[0] || range[1] &lt; x; } return function(feature) { φ1 = λ1 = -(λ0 = φ0 = Infinity); ranges = []; d3.geo.stream(feature, bound); var n = ranges.length; if (n) { ranges.sort(compareRanges); for (var i = 1, a = ranges[0], b, merged = [ a ]; i &lt; n; ++i) { b = ranges[i]; if (withinRange(b[0], a) || withinRange(b[1], a)) { if (angle(a[0], b[1]) &gt; angle(a[0], a[1])) a[1] = b[1]; if (angle(b[0], a[1]) &gt; angle(a[0], a[1])) a[0] = b[0]; } else { merged.push(a = b); } } var best = -Infinity, dλ; for (var n = merged.length - 1, i = 0, a = merged[n], b; i &lt;= n; a = b, ++i) { b = merged[i]; if ((dλ = angle(a[1], b[0])) &gt; best) best = dλ, λ0 = b[0], λ1 = a[1]; } } ranges = range = null; return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ]; }; }(); d3.geo.centroid = function(object) { d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0; d3.geo.stream(object, d3_geo_centroid); var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x x + y y + z z; if (m &lt; ε2) { x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1; if (d3_geo_centroidW1 &lt; ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0; m = x x + y y + z z; if (m &lt; ε2) return [ NaN, NaN ]; } return [ Math.atan2(y, x) d3_degrees, d3_asin(z / Math.sqrt(m)) d3_degrees ]; }; var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2; var d3_geo_centroid = { sphere: d3_noop, point: d3_geo_centroidPoint, lineStart: d3_geo_centroidLineStart, lineEnd: d3_geo_centroidLineEnd, polygonStart: function() { d3_geo_centroid.lineStart = d3_geo_centroidRingStart; }, polygonEnd: function() { d3_geo_centroid.lineStart = d3_geo_centroidLineStart; } }; function d3_geo_centroidPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); d3_geo_centroidPointXYZ(cosφ Math.cos(λ), cosφ Math.sin(λ), Math.sin(φ)); } function d3_geo_centroidPointXYZ(x, y, z) { ++d3_geo_centroidW0; d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0; d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0; d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0; } function d3_geo_centroidLineStart() { var x0, y0, z0; d3_geo_centroid.point = function(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); x0 = cosφ Math.cos(λ); y0 = cosφ Math.sin(λ); z0 = Math.sin(φ); d3_geo_centroid.point = nextPoint; d3_geo_centroidPointXYZ(x0, y0, z0); }; function nextPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians), x = cosφ Math.cos(λ), y = cosφ Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 z - z0 y) w + (w = z0 x - x0 z) w + (w = x0 y - y0 x) w), x0 x + y0 y + z0 z); d3_geo_centroidW1 += w; d3_geo_centroidX1 += w (x0 + (x0 = x)); d3_geo_centroidY1 += w (y0 + (y0 = y)); d3_geo_centroidZ1 += w (z0 + (z0 = z)); d3_geo_centroidPointXYZ(x0, y0, z0); } } function d3_geo_centroidLineEnd() { d3_geo_centroid.point = d3_geo_centroidPoint; } function d3_geo_centroidRingStart() { var λ00, φ00, x0, y0, z0; d3_geo_centroid.point = function(λ, φ) { λ00 = λ, φ00 = φ; d3_geo_centroid.point = nextPoint; λ = d3_radians; var cosφ = Math.cos(φ = d3_radians); x0 = cosφ Math.cos(λ); y0 = cosφ Math.sin(λ); z0 = Math.sin(φ); d3_geo_centroidPointXYZ(x0, y0, z0); }; d3_geo_centroid.lineEnd = function() { nextPoint(λ00, φ00); d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd; d3_geo_centroid.point = d3_geo_centroidPoint; }; function nextPoint(λ, φ) { λ = d3_radians; var cosφ = Math.cos(φ = d3_radians), x = cosφ Math.cos(λ), y = cosφ Math.sin(λ), z = Math.sin(φ), cx = y0 z - z0 y, cy = z0 x - x0 z, cz = x0 y - y0 x, m = Math.sqrt(cx cx + cy cy + cz cz), u = x0 x + y0 y + z0 z, v = m &amp;&amp; -d3_acos(u) / m, w = Math.atan2(m, u); d3_geo_centroidX2 += v cx; d3_geo_centroidY2 += v cy; d3_geo_centroidZ2 += v cz; d3_geo_centroidW1 += w; d3_geo_centroidX1 += w (x0 + (x0 = x)); d3_geo_centroidY1 += w (y0 + (y0 = y)); d3_geo_centroidZ1 += w (z0 + (z0 = z)); d3_geo_centroidPointXYZ(x0, y0, z0); } } function d3_geo_compose(a, b) { function compose(x, y) { return x = a(x, y), b(x[0], x[1]); } if (a.invert &amp;&amp; b.invert) compose.invert = function(x, y) { return x = b.invert(x, y), x &amp;&amp; a.invert(x[0], x[1]); }; return compose; } function d3_true() { return true; } function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) { var subject = [], clip = []; segments.forEach(function(segment) { if ((n = segment.length - 1) &lt;= 0) return; var n, p0 = segment[0], p1 = segment[n]; if (d3_geo_sphericalEqual(p0, p1)) { listener.lineStart(); for (var i = 0; i &lt; n; ++i) listener.point((p0 = segment[i])[0], p0[1]); listener.lineEnd(); return; } var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false); a.o = b; subject.push(a); clip.push(b); a = new d3_geo_clipPolygonIntersection(p1, segment, null, false); b = new d3_geo_clipPolygonIntersection(p1, null, a, true); a.o = b; subject.push(a); clip.push(b); }); clip.sort(compare); d3_geo_clipPolygonLinkCircular(subject); d3_geo_clipPolygonLinkCircular(clip); if (!subject.length) return; for (var i = 0, entry = clipStartInside, n = clip.length; i &lt; n; ++i) { clip[i].e = entry = !entry; } var start = subject[0], points, point; while (1) { var current = start, isSubject = true; while (current.v) if ((current = current.n) === start) return; points = current.z; listener.lineStart(); do { current.v = current.o.v = true; if (current.e) { if (isSubject) { for (var i = 0, n = points.length; i &lt; n; ++i) listener.point((point = points[i])[0], point[1]); } else { interpolate(current.x, current.n.x, 1, listener); } current = current.n; } else { if (isSubject) { points = current.p.z; for (var i = points.length - 1; i &gt;= 0; –i) listener.point((point = points[i])[0], point[1]); } else { interpolate(current.x, current.p.x, -1, listener); } current = current.p; } current = current.o; points = current.z; isSubject = !isSubject; } while (!current.v); listener.lineEnd(); } } function d3_geo_clipPolygonLinkCircular(array) { if (!(n = array.length)) return; var n, i = 0, a = array[0], b; while (++i &lt; n) { a.n = b = array[i]; b.p = a; a = b; } a.n = b = array[0]; b.p = a; } function d3_geo_clipPolygonIntersection(point, points, other, entry) { this.x = point; this.z = points; this.o = other; this.e = entry; this.v = false; this.n = this.p = null; } function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) { return function(rotate, listener) { var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]); var clip = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { clip.point = pointRing; clip.lineStart = ringStart; clip.lineEnd = ringEnd; segments = []; polygon = []; }, polygonEnd: function() { clip.point = point; clip.lineStart = lineStart; clip.lineEnd = lineEnd; segments = d3.merge(segments); var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon); if (segments.length) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener); } else if (clipStartInside) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); } if (polygonStarted) listener.polygonEnd(), polygonStarted = false; segments = polygon = null; }, sphere: function() { listener.polygonStart(); listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); listener.polygonEnd(); } }; function point(λ, φ) { var point = rotate(λ, φ); if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ); } function pointLine(λ, φ) { var point = rotate(λ, φ); line.point(point[0], point[1]); } function lineStart() { clip.point = pointLine; line.lineStart(); } function lineEnd() { clip.point = point; line.lineEnd(); } var segments; var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring; function pointRing(λ, φ) { ring.push([ λ, φ ]); var point = rotate(λ, φ); ringListener.point(point[0], point[1]); } function ringStart() { ringListener.lineStart(); ring = []; } function ringEnd() { pointRing(ring[0][0], ring[0][1]); ringListener.lineEnd(); var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length; ring.pop(); polygon.push(ring); ring = null; if (!n) return; if (clean &amp; 1) { segment = ringSegments[0]; var n = segment.length - 1, i = -1, point; if (n &gt; 0) { if (!polygonStarted) listener.polygonStart(), polygonStarted = true; listener.lineStart(); while (++i &lt; n) listener.point((point = segment[i])[0], point[1]); listener.lineEnd(); } return; } if (n &gt; 1 &amp;&amp; clean &amp; 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift())); segments.push(ringSegments.filter(d3_geo_clipSegmentLength1)); } return clip; }; } function d3_geo_clipSegmentLength1(segment) { return segment.length &gt; 1; } function d3_geo_clipBufferListener() { var lines = [], line; return { lineStart: function() { lines.push(line = []); }, point: function(λ, φ) { line.push([ λ, φ ]); }, lineEnd: d3_noop, buffer: function() { var buffer = lines; lines = []; line = null; return buffer; }, rejoin: function() { if (lines.length &gt; 1) lines.push(lines.pop().concat(lines.shift())); } }; } function d3_geo_clipSort(a, b) { return ((a = a.x)[0] &lt; 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] &lt; 0 ? b[1] - halfπ - ε : halfπ - b[1]); } var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]); function d3_geo_clipAntimeridianLine(listener) { var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean; return { lineStart: function() { listener.lineStart(); clean = 1; }, point: function(λ1, φ1) { var sλ1 = λ1 &gt; 0 ? π : -π, dλ = abs(λ1 - λ0); if (abs(dλ - π) &lt; ε) { listener.point(λ0, φ0 = (φ0 + φ1) / 2 &gt; 0 ? halfπ : -halfπ); listener.point(sλ0, φ0); listener.lineEnd(); listener.lineStart(); listener.point(sλ1, φ0); listener.point(λ1, φ0); clean = 0; } else if (sλ0 !== sλ1 &amp;&amp; dλ &gt;= π) { if (abs(λ0 - sλ0) &lt; ε) λ0 -= sλ0 ε; if (abs(λ1 - sλ1) &lt; ε) λ1 -= sλ1 ε; φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1); listener.point(sλ0, φ0); listener.lineEnd(); listener.lineStart(); listener.point(sλ1, φ0); clean = 0; } listener.point(λ0 = λ1, φ0 = φ1); sλ0 = sλ1; }, lineEnd: function() { listener.lineEnd(); λ0 = φ0 = NaN; }, clean: function() { return 2 - clean; } }; } function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) { var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1); return abs(sinλ0_λ1) &gt; ε ? Math.atan((Math.sin(φ0) (cosφ1 = Math.cos(φ1)) Math.sin(λ1) - Math.sin(φ1) (cosφ0 = Math.cos(φ0)) Math.sin(λ0)) / (cosφ0 cosφ1 sinλ0_λ1)) : (φ0 + φ1) / 2; } function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) { var φ; if (from == null) { φ = direction halfπ; listener.point(-π, φ); listener.point(0, φ); listener.point(π, φ); listener.point(π, 0); listener.point(π, -φ); listener.point(0, -φ); listener.point(-π, -φ); listener.point(-π, 0); listener.point(-π, φ); } else if (abs(from[0] - to[0]) &gt; ε) { var s = from[0] &lt; to[0] ? π : -π; φ = direction s / 2; listener.point(-s, φ); listener.point(0, φ); listener.point(s, φ); } else { listener.point(to[0], to[1]); } } function d3_geo_pointInPolygon(point, polygon) { var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0; d3_geo_areaRingSum.reset(); for (var i = 0, n = polygon.length; i &lt; n; ++i) { var ring = polygon[i], m = ring.length; if (!m) continue; var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1; while (true) { if (j === m) j = 0; point = ring[j]; var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ &gt;= 0 ? 1 : -1, adλ = sdλ dλ, antimeridian = adλ &gt; π, k = sinφ0 sinφ; d3_geo_areaRingSum.add(Math.atan2(k sdλ Math.sin(adλ), cosφ0 cosφ + k Math.cos(adλ))); polarAngle += antimeridian ? dλ + sdλ τ : dλ; if (antimeridian ^ λ0 &gt;= meridian ^ λ &gt;= meridian) { var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point)); d3_geo_cartesianNormalize(arc); var intersection = d3_geo_cartesianCross(meridianNormal, arc); d3_geo_cartesianNormalize(intersection); var φarc = (antimeridian ^ dλ &gt;= 0 ? -1 : 1) d3_asin(intersection[2]); if (parallel &gt; φarc || parallel === φarc &amp;&amp; (arc[0] || arc[1])) { winding += antimeridian ^ dλ &gt;= 0 ? 1 : -1; } } if (!j++) break; λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point; } } return (polarAngle &lt; -ε || polarAngle &lt; ε &amp;&amp; d3_geo_areaRingSum &lt; -ε) ^ winding &amp; 1; } function d3_geo_clipCircle(radius) { var cr = Math.cos(radius), smallRadius = cr &gt; 0, notHemisphere = abs(cr) &gt; ε, interpolate = d3_geo_circleInterpolate(radius, 6 d3_radians); return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]); function visible(λ, φ) { return Math.cos(λ) Math.cos(φ) &gt; cr; } function clipLine(listener) { var point0, c0, v0, v00, clean; return { lineStart: function() { v00 = v0 = false; clean = 1; }, point: function(λ, φ) { var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ &lt; 0 ? π : -π), φ) : 0; if (!point0 &amp;&amp; (v00 = v0 = v)) listener.lineStart(); if (v !== v0) { point2 = intersect(point0, point1); if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) { point1[0] += ε; point1[1] += ε; v = visible(point1[0], point1[1]); } } if (v !== v0) { clean = 0; if (v) { listener.lineStart(); point2 = intersect(point1, point0); listener.point(point2[0], point2[1]); } else { point2 = intersect(point0, point1); listener.point(point2[0], point2[1]); listener.lineEnd(); } point0 = point2; } else if (notHemisphere &amp;&amp; point0 &amp;&amp; smallRadius ^ v) { var t; if (!(c &amp; c0) &amp;&amp; (t = intersect(point1, point0, true))) { clean = 0; if (smallRadius) { listener.lineStart(); listener.point(t[0][0], t[0][1]); listener.point(t[1][0], t[1][1]); listener.lineEnd(); } else { listener.point(t[1][0], t[1][1]); listener.lineEnd(); listener.lineStart(); listener.point(t[0][0], t[0][1]); } } } if (v &amp;&amp; (!point0 || !d3_geo_sphericalEqual(point0, point1))) { listener.point(point1[0], point1[1]); } point0 = point1, v0 = v, c0 = c; }, lineEnd: function() { if (v0) listener.lineEnd(); point0 = null; }, clean: function() { return clean | (v00 &amp;&amp; v0) &lt;&lt; 1; } }; } function intersect(a, b, two) { var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b); var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 n1n2; if (!determinant) return !two &amp;&amp; a; var c1 = cr n2n2 / determinant, c2 = -cr n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2); d3_geo_cartesianAdd(A, B); var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w w - uu (d3_geo_cartesianDot(A, A) - 1); if (t2 &lt; 0) return; var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu); d3_geo_cartesianAdd(q, A); q = d3_geo_spherical(q); if (!two) return q; var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z; if (λ1 &lt; λ0) z = λ0, λ0 = λ1, λ1 = z; var δλ = λ1 - λ0, polar = abs(δλ - π) &lt; ε, meridian = polar || δλ &lt; ε; if (!polar &amp;&amp; φ1 &lt; φ0) z = φ0, φ0 = φ1, φ1 = z; if (meridian ? polar ? φ0 + φ1 &gt; 0 ^ q[1] &lt; (abs(q[0] - λ0) &lt; ε ? φ0 : φ1) : φ0 &lt;= q[1] &amp;&amp; q[1] &lt;= φ1 : δλ &gt; π ^ (λ0 &lt;= q[0] &amp;&amp; q[0] &lt;= λ1)) { var q1 = d3_geo_cartesianScale(u, (-w + t) / uu); d3_geo_cartesianAdd(q1, A); return [ q, d3_geo_spherical(q1) ]; } } function code(λ, φ) { var r = smallRadius ? radius : π - radius, code = 0; if (λ &lt; -r) code |= 1; else if (λ &gt; r) code |= 2; if (φ &lt; -r) code |= 4; else if (φ &gt; r) code |= 8; return code; } } function d3_geom_clipLine(x0, y0, x1, y1) { return function(line) { var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r; r = x0 - ax; if (!dx &amp;&amp; r &gt; 0) return; r /= dx; if (dx &lt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } else if (dx &gt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } r = x1 - ax; if (!dx &amp;&amp; r &lt; 0) return; r /= dx; if (dx &lt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } else if (dx &gt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } r = y0 - ay; if (!dy &amp;&amp; r &gt; 0) return; r /= dy; if (dy &lt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } else if (dy &gt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } r = y1 - ay; if (!dy &amp;&amp; r &lt; 0) return; r /= dy; if (dy &lt; 0) { if (r &gt; t1) return; if (r &gt; t0) t0 = r; } else if (dy &gt; 0) { if (r &lt; t0) return; if (r &lt; t1) t1 = r; } if (t0 &gt; 0) line.a = { x: ax + t0 dx, y: ay + t0 dy }; if (t1 &lt; 1) line.b = { x: ax + t1 dx, y: ay + t1 dy }; return line; }; } var d3_geo_clipExtentMAX = 1e9; d3.geo.clipExtent = function() { var x0, y0, x1, y1, stream, clip, clipExtent = { stream: function(output) { if (stream) stream.valid = false; stream = clip(output); stream.valid = true; return stream; }, extent: function(_) { if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ]; clip = d3_geo_clipExtent(x0 = +[0][0], y0 = +[0][1], x1 = +[1][0], y1 = +[1][1]); if (stream) stream.valid = false, stream = null; return clipExtent; } }; return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]); }; function d3_geo_clipExtent(x0, y0, x1, y1) { return function(listener) { var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring; var clip = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { listener = bufferListener; segments = []; polygon = []; clean = true; }, polygonEnd: function() { listener = listener_; segments = d3.merge(segments); var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean &amp;&amp; clipStartInside, visible = segments.length; if (inside || visible) { listener.polygonStart(); if (inside) { listener.lineStart(); interpolate(null, null, 1, listener); listener.lineEnd(); } if (visible) { d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener); } listener.polygonEnd(); } segments = polygon = ring = null; } }; function insidePolygon(p) { var wn = 0, n = polygon.length, y = p[1]; for (var i = 0; i &lt; n; ++i) { for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j &lt; m; ++j) { b = v[j]; if (a[1] &lt;= y) { if (b[1] &gt; y &amp;&amp; d3_cross2d(a, b, p) &gt; 0) ++wn; } else { if (b[1] &lt;= y &amp;&amp; d3_cross2d(a, b, p) &lt; 0) –wn; } a = b; } } return wn !== 0; } function interpolate(from, to, direction, listener) { var a = 0, a1 = 0; if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) &lt; 0 ^ direction &gt; 0) { do { listener.point(a === 0 || a === 3 ? x0 : x1, a &gt; 1 ? y1 : y0); } while ((a = (a + direction + 4) % 4) !== a1); } else { listener.point(to[0], to[1]); } } function pointVisible(x, y) { return x0 &lt;= x &amp;&amp; x &lt;= x1 &amp;&amp; y0 &lt;= y &amp;&amp; y &lt;= y1; } function point(x, y) { if (pointVisible(x, y)) listener.point(x, y); } var x__, y__, v__, x_, y_, v_, first, clean; function lineStart() { clip.point = linePoint; if (polygon) polygon.push(ring = []); first = true; v_ = false; x_ = y_ = NaN; } function lineEnd() { if (segments) { linePoint(x__, y__); if (v__ &amp;&amp; v_) bufferListener.rejoin(); segments.push(bufferListener.buffer()); } clip.point = point; if (v_) listener.lineEnd(); } function linePoint(x, y) { x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x)); y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y)); var v = pointVisible(x, y); if (polygon) ring.push([ x, y ]); if (first) { x__ = x, y__ = y, v__ = v; first = false; if (v) { listener.lineStart(); listener.point(x, y); } } else { if (v &amp;&amp; v_) listener.point(x, y); else { var l = { a: { x: x_, y: y_ }, b: { x: x, y: y } }; if (clipLine(l)) { if (!v_) { listener.lineStart(); listener.point(l.a.x, l.a.y); } listener.point(l.b.x, l.b.y); if (!v) listener.lineEnd(); clean = false; } else if (v) { listener.lineStart(); listener.point(x, y); clean = false; } } } x_ = x, y_ = y, v_ = v; } return clip; }; function corner(p, direction) { return abs(p[0] - x0) &lt; ε ? direction &gt; 0 ? 0 : 3 : abs(p[0] - x1) &lt; ε ? direction &gt; 0 ? 2 : 1 : abs(p[1] - y0) &lt; ε ? direction &gt; 0 ? 1 : 0 : direction &gt; 0 ? 3 : 2; } function compare(a, b) { return comparePoints(a.x, b.x); } function comparePoints(a, b) { var ca = corner(a, 1), cb = corner(b, 1); return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0]; } } function d3_geo_conic(projectAt) { var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1); p.parallels = function(_) { if (!arguments.length) return [ φ0 / π 180, φ1 / π 180 ]; return m(φ0 = _[0] π / 180, φ1 = _[1] π / 180); }; return p; } function d3_geo_conicEqualArea(φ0, φ1) { var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 (2 n - sinφ0), ρ0 = Math.sqrt(C) / n; function forward(λ, φ) { var ρ = Math.sqrt(C - 2 n Math.sin(φ)) / n; return [ ρ Math.sin(λ = n), ρ0 - ρ Math.cos(λ) ]; } forward.invert = function(x, y) { var ρ0_y = ρ0 - y; return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x x + ρ0_y ρ0_y) n n) / (2 n)) ]; }; return forward; } (d3.geo.conicEqualArea = function() { return d3_geo_conic(d3_geo_conicEqualArea); }).raw = d3_geo_conicEqualArea; d3.geo.albers = function() { return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070); }; d3.geo.albersUsa = function() { var lower48 = d3.geo.albers(); var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]); var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]); var point, pointStream = { point: function(x, y) { point = [ x, y ]; } }, lower48Point, alaskaPoint, hawaiiPoint; function albersUsa(coordinates) { var x = coordinates[0], y = coordinates[1]; point = null; (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y); return point; } albersUsa.invert = function(coordinates) { var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k; return (y &gt;= .12 &amp;&amp; y &lt; .234 &amp;&amp; x &gt;= -.425 &amp;&amp; x &lt; -.214 ? alaska : y &gt;= .166 &amp;&amp; y &lt; .234 &amp;&amp; x &gt;= -.214 &amp;&amp; x &lt; -.115 ? hawaii : lower48).invert(coordinates); }; albersUsa.stream = function(stream) { var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream); return { point: function(x, y) { lower48Stream.point(x, y); alaskaStream.point(x, y); hawaiiStream.point(x, y); }, sphere: function() { lower48Stream.sphere(); alaskaStream.sphere(); hawaiiStream.sphere(); }, lineStart: function() { lower48Stream.lineStart(); alaskaStream.lineStart(); hawaiiStream.lineStart(); }, lineEnd: function() { lower48Stream.lineEnd(); alaskaStream.lineEnd(); hawaiiStream.lineEnd(); }, polygonStart: function() { lower48Stream.polygonStart(); alaskaStream.polygonStart(); hawaiiStream.polygonStart(); }, polygonEnd: function() { lower48Stream.polygonEnd(); alaskaStream.polygonEnd(); hawaiiStream.polygonEnd(); } }; }; albersUsa.precision = function() { if (!arguments.length) return lower48.precision(); lower48.precision(); alaska.precision(); hawaii.precision(); return albersUsa; }; albersUsa.scale = function() { if (!arguments.length) return lower48.scale(); lower48.scale(); alaska.scale(_ .35); hawaii.scale(); return albersUsa.translate(lower48.translate()); }; albersUsa.translate = function() { if (!arguments.length) return lower48.translate(); var k = lower48.scale(), x = +[0], y = +[1]; lower48Point = lower48.translate(_).clipExtent([ [ x - .455 k, y - .238 k ], [ x + .455 k, y + .238 k ] ]).stream(pointStream).point; alaskaPoint = alaska.translate([ x - .307 k, y + .201 k ]).clipExtent([ [ x - .425 k + ε, y + .12 k + ε ], [ x - .214 k - ε, y + .234 k - ε ] ]).stream(pointStream).point; hawaiiPoint = hawaii.translate([ x - .205 k, y + .212 k ]).clipExtent([ [ x - .214 k + ε, y + .166 k + ε ], [ x - .115 k - ε, y + .234 k - ε ] ]).stream(pointStream).point; return albersUsa; }; return albersUsa.scale(1070); }; var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = { point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_pathAreaPolygon = 0; d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart; }, polygonEnd: function() { d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop; d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2); } }; function d3_geo_pathAreaRingStart() { var x00, y00, x0, y0; d3_geo_pathArea.point = function(x, y) { d3_geo_pathArea.point = nextPoint; x00 = x0 = x, y00 = y0 = y; }; function nextPoint(x, y) { d3_geo_pathAreaPolygon += y0 x - x0 y; x0 = x, y0 = y; } d3_geo_pathArea.lineEnd = function() { nextPoint(x00, y00); }; } var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1; var d3_geo_pathBounds = { point: d3_geo_pathBoundsPoint, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop }; function d3_geo_pathBoundsPoint(x, y) { if (x &lt; d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x; if (x &gt; d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x; if (y &lt; d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y; if (y &gt; d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y; } function d3_geo_pathBuffer() { var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = []; var stream = { point: point, lineStart: function() { stream.point = pointLineStart; }, lineEnd: lineEnd, polygonStart: function() { stream.lineEnd = lineEndPolygon; }, polygonEnd: function() { stream.lineEnd = lineEnd; stream.point = point; }, pointRadius: function(_) { pointCircle = d3_geo_pathBufferCircle(_); return stream; }, result: function() { if (buffer.length) { var result = buffer.join(“”); buffer = []; return result; } } }; function point(x, y) { buffer.push(“M”, x, “,”, y, pointCircle); } function pointLineStart(x, y) { buffer.push(“M”, x, “,”, y); stream.point = pointLine; } function pointLine(x, y) { buffer.push(“L”, x, “,”, y); } function lineEnd() { stream.point = point; } function lineEndPolygon() { buffer.push(“Z”); } return stream; } function d3_geo_pathBufferCircle(radius) { return “m0,” + radius + “a” + radius + “,” + radius + “ 0 1,1 0,” + -2 radius + “a” + radius + “,” + radius + “ 0 1,1 0,” + 2 radius + “z”; } var d3_geo_pathCentroid = { point: d3_geo_pathCentroidPoint, lineStart: d3_geo_pathCentroidLineStart, lineEnd: d3_geo_pathCentroidLineEnd, polygonStart: function() { d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart; }, polygonEnd: function() { d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint; d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart; d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd; } }; function d3_geo_pathCentroidPoint(x, y) { d3_geo_centroidX0 += x; d3_geo_centroidY0 += y; ++d3_geo_centroidZ0; } function d3_geo_pathCentroidLineStart() { var x0, y0; d3_geo_pathCentroid.point = function(x, y) { d3_geo_pathCentroid.point = nextPoint; d3_geo_pathCentroidPoint(x0 = x, y0 = y); }; function nextPoint(x, y) { var dx = x - x0, dy = y - y0, z = Math.sqrt(dx dx + dy dy); d3_geo_centroidX1 += z (x0 + x) / 2; d3_geo_centroidY1 += z (y0 + y) / 2; d3_geo_centroidZ1 += z; d3_geo_pathCentroidPoint(x0 = x, y0 = y); } } function d3_geo_pathCentroidLineEnd() { d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint; } function d3_geo_pathCentroidRingStart() { var x00, y00, x0, y0; d3_geo_pathCentroid.point = function(x, y) { d3_geo_pathCentroid.point = nextPoint; d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y); }; function nextPoint(x, y) { var dx = x - x0, dy = y - y0, z = Math.sqrt(dx dx + dy dy); d3_geo_centroidX1 += z (x0 + x) / 2; d3_geo_centroidY1 += z (y0 + y) / 2; d3_geo_centroidZ1 += z; z = y0 x - x0 y; d3_geo_centroidX2 += z (x0 + x); d3_geo_centroidY2 += z (y0 + y); d3_geo_centroidZ2 += z 3; d3_geo_pathCentroidPoint(x0 = x, y0 = y); } d3_geo_pathCentroid.lineEnd = function() { nextPoint(x00, y00); }; } function d3_geo_pathContext(context) { var pointRadius = 4.5; var stream = { point: point, lineStart: function() { stream.point = pointLineStart; }, lineEnd: lineEnd, polygonStart: function() { stream.lineEnd = lineEndPolygon; }, polygonEnd: function() { stream.lineEnd = lineEnd; stream.point = point; }, pointRadius: function(_) { pointRadius = _; return stream; }, result: d3_noop }; function point(x, y) { context.moveTo(x + pointRadius, y); context.arc(x, y, pointRadius, 0, τ); } function pointLineStart(x, y) { context.moveTo(x, y); stream.point = pointLine; } function pointLine(x, y) { context.lineTo(x, y); } function lineEnd() { stream.point = point; } function lineEndPolygon() { context.closePath(); } return stream; } function d3_geo_resample(project) { var δ2 = .5, cosMinDistance = Math.cos(30 d3_radians), maxDepth = 16; function resample(stream) { return (maxDepth ? resampleRecursive : resampleNone)(stream); } function resampleNone(stream) { return d3_geo_transformPoint(stream, function(x, y) { x = project(x, y); stream.point(x[0], x[1]); }); } function resampleRecursive(stream) { var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0; var resample = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { stream.polygonStart(); resample.lineStart = ringStart; }, polygonEnd: function() { stream.polygonEnd(); resample.lineStart = lineStart; } }; function point(x, y) { x = project(x, y); stream.point(x[0], x[1]); } function lineStart() { x0 = NaN; resample.point = linePoint; stream.lineStart(); } function linePoint(λ, φ) { var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ); resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream); stream.point(x0, y0); } function lineEnd() { resample.point = point; stream.lineEnd(); } function ringStart() { lineStart(); resample.point = ringPoint; resample.lineEnd = ringEnd; } function ringPoint(λ, φ) { linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0; resample.point = linePoint; } function ringEnd() { resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream); resample.lineEnd = lineEnd; lineEnd(); } return resample; } function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) { var dx = x1 - x0, dy = y1 - y0, d2 = dx dx + dy dy; if (d2 &gt; 4 δ2 &amp;&amp; depth–) { var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a a + b b + c c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) &lt; ε || abs(λ0 - λ1) &lt; ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy dx2 - dx dy2; if (dz dz / d2 &gt; δ2 || abs((dx dx2 + dy dy2) / d2 - .5) &gt; .3 || a0 a1 + b0 b1 + c0 c1 &lt; cosMinDistance) { resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream); stream.point(x2, y2); resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream); } } } resample.precision = function(_) { if (!arguments.length) return Math.sqrt(δ2); maxDepth = (δ2 = _ _) &gt; 0 &amp;&amp; 16; return resample; }; return resample; } d3.geo.path = function() { var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream; function path(object) { if (object) { if (typeof pointRadius === “function”) contextStream.pointRadius(+pointRadius.apply(this, arguments)); if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream); d3.geo.stream(object, cacheStream); } return contextStream.result(); } path.area = function(object) { d3_geo_pathAreaSum = 0; d3.geo.stream(object, projectStream(d3_geo_pathArea)); return d3_geo_pathAreaSum; }; path.centroid = function(object) { d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0; d3.geo.stream(object, projectStream(d3_geo_pathCentroid)); return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ]; }; path.bounds = function(object) { d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity); d3.geo.stream(object, projectStream(d3_geo_pathBounds)); return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ]; }; path.projection = function(_) { if (!arguments.length) return projection; projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity; return reset(); }; path.context = function(_) { if (!arguments.length) return context; contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(); if (typeof pointRadius !== “function”) contextStream.pointRadius(pointRadius); return reset(); }; path.pointRadius = function() { if (!arguments.length) return pointRadius; pointRadius = typeof _ === “function” ? _ : (contextStream.pointRadius(+), +); return path; }; function reset() { cacheStream = null; return path; } return path.projection(d3.geo.albersUsa()).context(null); }; function d3_geo_pathProjectStream(project) { var resample = d3_geo_resample(function(x, y) { return project([ x d3_degrees, y d3_degrees ]); }); return function(stream) { return d3_geo_projectionRadians(resample(stream)); }; } d3.geo.transform = function(methods) { return { stream: function(stream) { var transform = new d3_geo_transform(stream); for (var k in methods) transform[k] = methods[k]; return transform; } }; }; function d3_geo_transform(stream) { this.stream = stream; } d3_geo_transform.prototype = { point: function(x, y) { this.stream.point(x, y); }, sphere: function() { this.stream.sphere(); }, lineStart: function() { this.stream.lineStart(); }, lineEnd: function() { this.stream.lineEnd(); }, polygonStart: function() { this.stream.polygonStart(); }, polygonEnd: function() { this.stream.polygonEnd(); } }; function d3_geo_transformPoint(stream, point) { return { point: point, sphere: function() { stream.sphere(); }, lineStart: function() { stream.lineStart(); }, lineEnd: function() { stream.lineEnd(); }, polygonStart: function() { stream.polygonStart(); }, polygonEnd: function() { stream.polygonEnd(); } }; } d3.geo.projection = d3_geo_projection; d3.geo.projectionMutator = d3_geo_projectionMutator; function d3_geo_projection(project) { return d3_geo_projectionMutator(function() { return project; })(); } function d3_geo_projectionMutator(projectAt) { var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) { x = project(x, y); return [ x[0] k + δx, δy - x[1] k ]; }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream; function projection(point) { point = projectRotate(point[0] d3_radians, point[1] d3_radians); return [ point[0] k + δx, δy - point[1] k ]; } function invert(point) { point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k); return point &amp;&amp; [ point[0] d3_degrees, point[1] d3_degrees ]; } projection.stream = function(output) { if (stream) stream.valid = false; stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output)))); stream.valid = true; return stream; }; projection.clipAngle = function(_) { if (!arguments.length) return clipAngle; preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) d3_radians); return invalidate(); }; projection.clipExtent = function(_) { if (!arguments.length) return clipExtent; clipExtent = _; postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity; return invalidate(); }; projection.scale = function() { if (!arguments.length) return k; k = +; return reset(); }; projection.translate = function() { if (!arguments.length) return [ x, y ]; x = +[0]; y = +[1]; return reset(); }; projection.center = function() { if (!arguments.length) return [ λ d3_degrees, φ d3_degrees ]; λ = _[0] % 360 d3_radians; φ = _[1] % 360 d3_radians; return reset(); }; projection.rotate = function(_) { if (!arguments.length) return [ δλ d3_degrees, δφ d3_degrees, δγ d3_degrees ]; δλ = _[0] % 360 d3_radians; δφ = _[1] % 360 d3_radians; δγ = _.length &gt; 2 ? _[2] % 360 d3_radians : 0; return reset(); }; d3.rebind(projection, projectResample, “precision”); function reset() { projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project); var center = project(λ, φ); δx = x - center[0] k; δy = y + center[1] k; return invalidate(); } function invalidate() { if (stream) stream.valid = false, stream = null; return projection; } return function() { project = projectAt.apply(this, arguments); projection.invert = project.invert &amp;&amp; invert; return reset(); }; } function d3_geo_projectionRadians(stream) { return d3_geo_transformPoint(stream, function(x, y) { stream.point(x d3_radians, y d3_radians); }); } function d3_geo_equirectangular(λ, φ) { return [ λ, φ ]; } (d3.geo.equirectangular = function() { return d3_geo_projection(d3_geo_equirectangular); }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular; d3.geo.rotation = function(rotate) { rotate = d3_geo_rotation(rotate[0] % 360 d3_radians, rotate[1] d3_radians, rotate.length &gt; 2 ? rotate[2] d3_radians : 0); function forward(coordinates) { coordinates = rotate(coordinates[0] d3_radians, coordinates[1] d3_radians); return coordinates[0] = d3_degrees, coordinates[1] = d3_degrees, coordinates; } forward.invert = function(coordinates) { coordinates = rotate.invert(coordinates[0] d3_radians, coordinates[1] d3_radians); return coordinates[0] = d3_degrees, coordinates[1] = d3_degrees, coordinates; }; return forward; }; function d3_geo_identityRotation(λ, φ) { return [ λ &gt; π ? λ - τ : λ &lt; -π ? λ + τ : λ, φ ]; } d3_geo_identityRotation.invert = d3_geo_equirectangular; function d3_geo_rotation(δλ, δφ, δγ) { return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation; } function d3_geo_forwardRotationλ(δλ) { return function(λ, φ) { return λ += δλ, [ λ &gt; π ? λ - τ : λ &lt; -π ? λ + τ : λ, φ ]; }; } function d3_geo_rotationλ(δλ) { var rotation = d3_geo_forwardRotationλ(δλ); rotation.invert = d3_geo_forwardRotationλ(-δλ); return rotation; } function d3_geo_rotationφγ(δφ, δγ) { var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ); function rotation(λ, φ) { var cosφ = Math.cos(φ), x = Math.cos(λ) cosφ, y = Math.sin(λ) cosφ, z = Math.sin(φ), k = z cosδφ + x sinδφ; return [ Math.atan2(y cosδγ - k sinδγ, x cosδφ - z sinδφ), d3_asin(k cosδγ + y sinδγ) ]; } rotation.invert = function(λ, φ) { var cosφ = Math.cos(φ), x = Math.cos(λ) cosφ, y = Math.sin(λ) cosφ, z = Math.sin(φ), k = z cosδγ - y sinδγ; return [ Math.atan2(y cosδγ + z sinδγ, x cosδφ + k sinδφ), d3_asin(k cosδφ - x sinδφ) ]; }; return rotation; } d3.geo.circle = function() { var origin = [ 0, 0 ], angle, precision = 6, interpolate; function circle() { var center = typeof origin === “function” ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] d3_radians, -center[1] d3_radians, 0).invert, ring = []; interpolate(null, null, 1, { point: function(x, y) { ring.push(x = rotate(x, y)); x[0] = d3_degrees, x[1] = d3_degrees; } }); return { type: “Polygon”, coordinates: [ ring ] }; } circle.origin = function(x) { if (!arguments.length) return origin; origin = x; return circle; }; circle.angle = function(x) { if (!arguments.length) return angle; interpolate = d3_geo_circleInterpolate((angle = +x) d3_radians, precision d3_radians); return circle; }; circle.precision = function(_) { if (!arguments.length) return precision; interpolate = d3_geo_circleInterpolate(angle d3_radians, (precision = +_) d3_radians); return circle; }; return circle.angle(90); }; function d3_geo_circleInterpolate(radius, precision) { var cr = Math.cos(radius), sr = Math.sin(radius); return function(from, to, direction, listener) { var step = direction precision; if (from != null) { from = d3_geo_circleAngle(cr, from); to = d3_geo_circleAngle(cr, to); if (direction &gt; 0 ? from &lt; to : from &gt; to) from += direction τ; } else { from = radius + direction τ; to = radius - .5 step; } for (var point, t = from; direction &gt; 0 ? t &gt; to : t &lt; to; t -= step) { listener.point((point = d3_geo_spherical([ cr, -sr Math.cos(t), -sr Math.sin(t) ]))[0], point[1]); } }; } function d3_geo_circleAngle(cr, point) { var a = d3_geo_cartesian(point); a[0] -= cr; d3_geo_cartesianNormalize(a); var angle = d3_acos(-a[1]); return ((-a[2] &lt; 0 ? -angle : angle) + 2 Math.PI - ε) % (2 Math.PI); } d3.geo.distance = function(a, b) { var Δλ = (b[0] - a[0]) d3_radians, φ0 = a[1] d3_radians, φ1 = b[1] d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t; return Math.atan2(Math.sqrt((t = cosφ1 sinΔλ) t + (t = cosφ0 sinφ1 - sinφ0 cosφ1 cosΔλ) t), sinφ0 sinφ1 + cosφ0 cosφ1 cosΔλ); }; d3.geo.graticule = function() { var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5; function graticule() { return { type: “MultiLineString”, coordinates: lines() }; } function lines() { return d3.range(Math.ceil(X0 / DX) DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) dx, x1, dx).filter(function(x) { return abs(x % DX) &gt; ε; }).map(x)).concat(d3.range(Math.ceil(y0 / dy) dy, y1, dy).filter(function(y) { return abs(y % DY) &gt; ε; }).map(y)); } graticule.lines = function() { return lines().map(function(coordinates) { return { type: “LineString”, coordinates: coordinates }; }); }; graticule.outline = function() { return { type: “Polygon”, coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ] }; }; graticule.extent = function() { if (!arguments.length) return graticule.minorExtent(); return graticule.majorExtent().minorExtent(); }; graticule.majorExtent = function() { if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ]; X0 = +[0][0], X1 = +[1][0]; Y0 = +[0][1], Y1 = +[1][1]; if (X0 &gt; X1) _ = X0, X0 = X1, X1 = _; if (Y0 &gt; Y1) _ = Y0, Y0 = Y1, Y1 = ; return graticule.precision(precision); }; graticule.minorExtent = function() { if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ]; x0 = +[0][0], x1 = +[1][0]; y0 = +[0][1], y1 = +[1][1]; if (x0 &gt; x1) _ = x0, x0 = x1, x1 = _; if (y0 &gt; y1) _ = y0, y0 = y1, y1 = ; return graticule.precision(precision); }; graticule.step = function() { if (!arguments.length) return graticule.minorStep(); return graticule.majorStep().minorStep(); }; graticule.majorStep = function() { if (!arguments.length) return [ DX, DY ]; DX = +[0], DY = +[1]; return graticule; }; graticule.minorStep = function() { if (!arguments.length) return [ dx, dy ]; dx = +[0], dy = +[1]; return graticule; }; graticule.precision = function() { if (!arguments.length) return precision; precision = +; x = d3_geo_graticuleX(y0, y1, 90); y = d3_geo_graticuleY(x0, x1, precision); X = d3_geo_graticuleX(Y0, Y1, 90); Y = d3_geo_graticuleY(X0, X1, precision); return graticule; }; return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]); }; function d3_geo_graticuleX(y0, y1, dy) { var y = d3.range(y0, y1 - ε, dy).concat(y1); return function(x) { return y.map(function(y) { return [ x, y ]; }); }; } function d3_geo_graticuleY(x0, x1, dx) { var x = d3.range(x0, x1 - ε, dx).concat(x1); return function(y) { return x.map(function(x) { return [ x, y ]; }); }; } function d3_source(d) { return d.source; } function d3_target(d) { return d.target; } d3.geo.greatArc = function() { var source = d3_source, source_, target = d3_target, target_; function greatArc() { return { type: “LineString”, coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ] }; } greatArc.distance = function() { return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)); }; greatArc.source = function(_) { if (!arguments.length) return source; source = , source = typeof _ === “function” ? null : ; return greatArc; }; greatArc.target = function() { if (!arguments.length) return target; target = , target = typeof _ === “function” ? null : _; return greatArc; }; greatArc.precision = function() { return arguments.length ? greatArc : 0; }; return greatArc; }; d3.geo.interpolate = function(source, target) { return d3_geo_interpolate(source[0] d3_radians, source[1] d3_radians, target[0] d3_radians, target[1] d3_radians); }; function d3_geo_interpolate(x0, y0, x1, y1) { var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 Math.cos(x0), ky0 = cy0 Math.sin(x0), kx1 = cy1 Math.cos(x1), ky1 = cy1 Math.sin(x1), d = 2 Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 cy1 d3_haversin(x1 - x0))), k = 1 / Math.sin(d); var interpolate = d ? function(t) { var B = Math.sin(t = d) k, A = Math.sin(d - t) k, x = A kx0 + B kx1, y = A ky0 + B ky1, z = A sy0 + B sy1; return [ Math.atan2(y, x) d3_degrees, Math.atan2(z, Math.sqrt(x x + y y)) d3_degrees ]; } : function() { return [ x0 d3_degrees, y0 d3_degrees ]; }; interpolate.distance = d; return interpolate; } d3.geo.length = function(object) { d3_geo_lengthSum = 0; d3.geo.stream(object, d3_geo_length); return d3_geo_lengthSum; }; var d3_geo_lengthSum; var d3_geo_length = { sphere: d3_noop, point: d3_noop, lineStart: d3_geo_lengthLineStart, lineEnd: d3_noop, polygonStart: d3_noop, polygonEnd: d3_noop }; function d3_geo_lengthLineStart() { var λ0, sinφ0, cosφ0; d3_geo_length.point = function(λ, φ) { λ0 = λ d3_radians, sinφ0 = Math.sin(φ = d3_radians), cosφ0 = Math.cos(φ); d3_geo_length.point = nextPoint; }; d3_geo_length.lineEnd = function() { d3_geo_length.point = d3_geo_length.lineEnd = d3_noop; }; function nextPoint(λ, φ) { var sinφ = Math.sin(φ = d3_radians), cosφ = Math.cos(φ), t = abs((λ = d3_radians) - λ0), cosΔλ = Math.cos(t); d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ Math.sin(t)) t + (t = cosφ0 sinφ - sinφ0 cosφ cosΔλ) t), sinφ0 sinφ + cosφ0 cosφ cosΔλ); λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ; } } function d3_geo_azimuthal(scale, angle) { function azimuthal(λ, φ) { var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ cosφ); return [ k cosφ Math.sin(λ), k Math.sin(φ) ]; } azimuthal.invert = function(x, y) { var ρ = Math.sqrt(x x + y y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c); return [ Math.atan2(x sinc, ρ cosc), Math.asin(ρ &amp;&amp; y sinc / ρ) ]; }; return azimuthal; } var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) { return Math.sqrt(2 / (1 + cosλcosφ)); }, function(ρ) { return 2 Math.asin(ρ / 2); }); (d3.geo.azimuthalEqualArea = function() { return d3_geo_projection(d3_geo_azimuthalEqualArea); }).raw = d3_geo_azimuthalEqualArea; var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) { var c = Math.acos(cosλcosφ); return c &amp;&amp; c / Math.sin(c); }, d3_identity); (d3.geo.azimuthalEquidistant = function() { return d3_geo_projection(d3_geo_azimuthalEquidistant); }).raw = d3_geo_azimuthalEquidistant; function d3_geo_conicConformal(φ0, φ1) { var cosφ0 = Math.cos(φ0), t = function(φ) { return Math.tan(π / 4 + φ / 2); }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 Math.pow(t(φ0), n) / n; if (!n) return d3_geo_mercator; function forward(λ, φ) { if (F &gt; 0) { if (φ &lt; -halfπ + ε) φ = -halfπ + ε; } else { if (φ &gt; halfπ - ε) φ = halfπ - ε; } var ρ = F / Math.pow(t(φ), n); return [ ρ Math.sin(n λ), F - ρ Math.cos(n λ) ]; } forward.invert = function(x, y) { var ρ0_y = F - y, ρ = d3_sgn(n) Math.sqrt(x x + ρ0_y ρ0_y); return [ Math.atan2(x, ρ0_y) / n, 2 Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ]; }; return forward; } (d3.geo.conicConformal = function() { return d3_geo_conic(d3_geo_conicConformal); }).raw = d3_geo_conicConformal; function d3_geo_conicEquidistant(φ0, φ1) { var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0; if (abs(n) &lt; ε) return d3_geo_equirectangular; function forward(λ, φ) { var ρ = G - φ; return [ ρ Math.sin(n λ), G - ρ Math.cos(n λ) ]; } forward.invert = function(x, y) { var ρ0_y = G - y; return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) Math.sqrt(x x + ρ0_y ρ0_y) ]; }; return forward; } (d3.geo.conicEquidistant = function() { return d3_geo_conic(d3_geo_conicEquidistant); }).raw = d3_geo_conicEquidistant; var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) { return 1 / cosλcosφ; }, Math.atan); (d3.geo.gnomonic = function() { return d3_geo_projection(d3_geo_gnomonic); }).raw = d3_geo_gnomonic; function d3_geo_mercator(λ, φ) { return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ]; } d3_geo_mercator.invert = function(x, y) { return [ x, 2 Math.atan(Math.exp(y)) - halfπ ]; }; function d3_geo_mercatorProjection(project) { var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto; m.scale = function() { var v = scale.apply(m, arguments); return v === m ? clipAuto ? m.clipExtent(null) : m : v; }; m.translate = function() { var v = translate.apply(m, arguments); return v === m ? clipAuto ? m.clipExtent(null) : m : v; }; m.clipExtent = function(_) { var v = clipExtent.apply(m, arguments); if (v === m) { if (clipAuto = _ == null) { var k = π scale(), t = translate(); clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]); } } else if (clipAuto) { v = null; } return v; }; return m.clipExtent(null); } (d3.geo.mercator = function() { return d3_geo_mercatorProjection(d3_geo_mercator); }).raw = d3_geo_mercator; var d3_geo_orthographic = d3_geo_azimuthal(function() { return 1; }, Math.asin); (d3.geo.orthographic = function() { return d3_geo_projection(d3_geo_orthographic); }).raw = d3_geo_orthographic; var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) { return 1 / (1 + cosλcosφ); }, function(ρ) { return 2 Math.atan(ρ); }); (d3.geo.stereographic = function() { return d3_geo_projection(d3_geo_stereographic); }).raw = d3_geo_stereographic; function d3_geo_transverseMercator(λ, φ) { return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ]; } d3_geo_transverseMercator.invert = function(x, y) { return [ -y, 2 Math.atan(Math.exp(x)) - halfπ ]; }; (d3.geo.transverseMercator = function() { var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate; projection.center = function(_) { return _ ? center([ -_[1], [0] ]) : ( = center(), [ [1], -[0] ]); }; projection.rotate = function(_) { return _ ? rotate([ _[0], _[1], _.length &gt; 2 ? [2] + 90 : 90 ]) : ( = rotate(), [ _[0], _[1], _[2] - 90 ]); }; return rotate([ 0, 0, 90 ]); }).raw = d3_geo_transverseMercator; d3.geom = {}; function d3_geom_pointX(d) { return d[0]; } function d3_geom_pointY(d) { return d[1]; } d3.geom.hull = function(vertices) { var x = d3_geom_pointX, y = d3_geom_pointY; if (arguments.length) return hull(vertices); function hull(data) { if (data.length &lt; 3) return []; var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = []; for (i = 0; i &lt; n; i++) { points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]); } points.sort(d3_geom_hullOrder); for (i = 0; i &lt; n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]); var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints); var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = []; for (i = upper.length - 1; i &gt;= 0; –i) polygon.push(data[points[upper[i]][2]]); for (i = +skipLeft; i &lt; lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]); return polygon; } hull.x = function(_) { return arguments.length ? (x = , hull) : x; }; hull.y = function() { return arguments.length ? (y = _, hull) : y; }; return hull; }; function d3_geom_hullUpper(points) { var n = points.length, hull = [ 0, 1 ], hs = 2; for (var i = 2; i &lt; n; i++) { while (hs &gt; 1 &amp;&amp; d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) &lt;= 0) –hs; hull[hs++] = i; } return hull.slice(0, hs); } function d3_geom_hullOrder(a, b) { return a[0] - b[0] || a[1] - b[1]; } d3.geom.polygon = function(coordinates) { d3_subclass(coordinates, d3_geom_polygonPrototype); return coordinates; }; var d3_geom_polygonPrototype = d3.geom.polygon.prototype = []; d3_geom_polygonPrototype.area = function() { var i = -1, n = this.length, a, b = this[n - 1], area = 0; while (++i &lt; n) { a = b; b = this[i]; area += a[1] b[0] - a[0] b[1]; } return area .5; }; d3_geom_polygonPrototype.centroid = function(k) { var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c; if (!arguments.length) k = -1 / (6 this.area()); while (++i &lt; n) { a = b; b = this[i]; c = a[0] b[1] - b[0] a[1]; x += (a[0] + b[0]) c; y += (a[1] + b[1]) c; } return [ x k, y k ]; }; d3_geom_polygonPrototype.clip = function(subject) { var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d; while (++i &lt; n) { input = subject.slice(); subject.length = 0; b = this[i]; c = input[(m = input.length - closed) - 1]; j = -1; while (++j &lt; m) { d = input[j]; if (d3_geom_polygonInside(d, a, b)) { if (!d3_geom_polygonInside(c, a, b)) { subject.push(d3_geom_polygonIntersect(c, d, a, b)); } subject.push(d); } else if (d3_geom_polygonInside(c, a, b)) { subject.push(d3_geom_polygonIntersect(c, d, a, b)); } c = d; } if (closed) subject.push(subject[0]); a = b; } return subject; }; function d3_geom_polygonInside(p, a, b) { return (b[0] - a[0]) (p[1] - a[1]) &lt; (b[1] - a[1]) (p[0] - a[0]); } function d3_geom_polygonIntersect(c, d, a, b) { var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 (y1 - y3) - y43 (x1 - x3)) / (y43 x21 - x43 y21); return [ x1 + ua x21, y1 + ua y21 ]; } function d3_geom_polygonClosed(coordinates) { var a = coordinates[0], b = coordinates[coordinates.length - 1]; return !(a[0] - b[0] || a[1] - b[1]); } var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = []; function d3_geom_voronoiBeach() { d3_geom_voronoiRedBlackNode(this); this.edge = this.site = this.circle = null; } function d3_geom_voronoiCreateBeach(site) { var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach(); beach.site = site; return beach; } function d3_geom_voronoiDetachBeach(beach) { d3_geom_voronoiDetachCircle(beach); d3_geom_voronoiBeaches.remove(beach); d3_geom_voronoiBeachPool.push(beach); d3_geom_voronoiRedBlackNode(beach); } function d3_geom_voronoiRemoveBeach(beach) { var circle = beach.circle, x = circle.x, y = circle.cy, vertex = { x: x, y: y }, previous = beach.P, next = beach.N, disappearing = [ beach ]; d3_geom_voronoiDetachBeach(beach); var lArc = previous; while (lArc.circle &amp;&amp; abs(x - lArc.circle.x) &lt; ε &amp;&amp; abs(y - lArc.circle.cy) &lt; ε) { previous = lArc.P; disappearing.unshift(lArc); d3_geom_voronoiDetachBeach(lArc); lArc = previous; } disappearing.unshift(lArc); d3_geom_voronoiDetachCircle(lArc); var rArc = next; while (rArc.circle &amp;&amp; abs(x - rArc.circle.x) &lt; ε &amp;&amp; abs(y - rArc.circle.cy) &lt; ε) { next = rArc.N; disappearing.push(rArc); d3_geom_voronoiDetachBeach(rArc); rArc = next; } disappearing.push(rArc); d3_geom_voronoiDetachCircle(rArc); var nArcs = disappearing.length, iArc; for (iArc = 1; iArc &lt; nArcs; ++iArc) { rArc = disappearing[iArc]; lArc = disappearing[iArc - 1]; d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex); } lArc = disappearing[0]; rArc = disappearing[nArcs - 1]; rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); } function d3_geom_voronoiAddBeach(site) { var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._; while (node) { dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x; if (dxl &gt; ε) node = node.L; else { dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix); if (dxr &gt; ε) { if (!node.R) { lArc = node; break; } node = node.R; } else { if (dxl &gt; -ε) { lArc = node.P; rArc = node; } else if (dxr &gt; -ε) { lArc = node; rArc = node.N; } else { lArc = rArc = node; } break; } } } var newArc = d3_geom_voronoiCreateBeach(site); d3_geom_voronoiBeaches.insert(lArc, newArc); if (!lArc &amp;&amp; !rArc) return; if (lArc === rArc) { d3_geom_voronoiDetachCircle(lArc); rArc = d3_geom_voronoiCreateBeach(lArc.site); d3_geom_voronoiBeaches.insert(newArc, rArc); newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); return; } if (!rArc) { newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site); return; } d3_geom_voronoiDetachCircle(lArc); d3_geom_voronoiDetachCircle(rArc); var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 (bx cy - by cx), hb = bx bx + by by, hc = cx cx + cy cy, vertex = { x: (cy hb - by hc) / d + ax, y: (bx hc - cx hb) / d + ay }; d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex); newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex); rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex); d3_geom_voronoiAttachCircle(lArc); d3_geom_voronoiAttachCircle(rArc); } function d3_geom_voronoiLeftBreakPoint(arc, directrix) { var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix; if (!pby2) return rfocx; var lArc = arc.P; if (!lArc) return -Infinity; site = lArc.site; var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix; if (!plby2) return lfocx; var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2; if (aby2) return (-b + Math.sqrt(b b - 2 aby2 (hl hl / (-2 plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx; return (rfocx + lfocx) / 2; } function d3_geom_voronoiRightBreakPoint(arc, directrix) { var rArc = arc.N; if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix); var site = arc.site; return site.y === directrix ? site.x : Infinity; } function d3_geom_voronoiCell(site) { this.site = site; this.edges = []; } d3_geom_voronoiCell.prototype.prepare = function() { var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge; while (iHalfEdge–) { edge = halfEdges[iHalfEdge].edge; if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1); } halfEdges.sort(d3_geom_voronoiHalfEdgeOrder); return halfEdges.length; }; function d3_geom_voronoiCloseCells(extent) { var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end; while (iCell–) { cell = cells[iCell]; if (!cell || !cell.prepare()) continue; halfEdges = cell.edges; nHalfEdges = halfEdges.length; iHalfEdge = 0; while (iHalfEdge &lt; nHalfEdges) { end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y; start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y; if (abs(x3 - x2) &gt; ε || abs(y3 - y2) &gt; ε) { halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) &lt; ε &amp;&amp; y1 - y3 &gt; ε ? { x: x0, y: abs(x2 - x0) &lt; ε ? y2 : y1 } : abs(y3 - y1) &lt; ε &amp;&amp; x1 - x3 &gt; ε ? { x: abs(y2 - y1) &lt; ε ? x2 : x1, y: y1 } : abs(x3 - x1) &lt; ε &amp;&amp; y3 - y0 &gt; ε ? { x: x1, y: abs(x2 - x1) &lt; ε ? y2 : y0 } : abs(y3 - y0) &lt; ε &amp;&amp; x3 - x0 &gt; ε ? { x: abs(y2 - y0) &lt; ε ? x2 : x0, y: y0 } : null), cell.site, null)); ++nHalfEdges; } } } } function d3_geom_voronoiHalfEdgeOrder(a, b) { return b.angle - a.angle; } function d3_geom_voronoiCircle() { d3_geom_voronoiRedBlackNode(this); this.x = this.y = this.arc = this.site = this.cy = null; } function d3_geom_voronoiAttachCircle(arc) { var lArc = arc.P, rArc = arc.N; if (!lArc || !rArc) return; var lSite = lArc.site, cSite = arc.site, rSite = rArc.site; if (lSite === rSite) return; var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by; var d = 2 (ax cy - ay cx); if (d &gt;= -ε2) return; var ha = ax ax + ay ay, hc = cx cx + cy cy, x = (cy ha - ay hc) / d, y = (ax hc - cx ha) / d, cy = y + by; var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle(); circle.arc = arc; circle.site = cSite; circle.x = x + bx; circle.y = cy + Math.sqrt(x x + y y); circle.cy = cy; arc.circle = circle; var before = null, node = d3_geom_voronoiCircles._; while (node) { if (circle.y &lt; node.y || circle.y === node.y &amp;&amp; circle.x &lt;= node.x) { if (node.L) node = node.L; else { before = node.P; break; } } else { if (node.R) node = node.R; else { before = node; break; } } } d3_geom_voronoiCircles.insert(before, circle); if (!before) d3_geom_voronoiFirstCircle = circle; } function d3_geom_voronoiDetachCircle(arc) { var circle = arc.circle; if (circle) { if (!circle.P) d3_geom_voronoiFirstCircle = circle.N; d3_geom_voronoiCircles.remove(circle); d3_geom_voronoiCirclePool.push(circle); d3_geom_voronoiRedBlackNode(circle); arc.circle = null; } } function d3_geom_voronoiClipEdges(extent) { var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e; while (i–) { e = edges[i]; if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) &lt; ε &amp;&amp; abs(e.a.y - e.b.y) &lt; ε) { e.a = e.b = null; edges.splice(i, 1); } } } function d3_geom_voronoiConnectEdge(edge, extent) { var vb = edge.b; if (vb) return true; var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb; if (ry === ly) { if (fx &lt; x0 || fx &gt;= x1) return; if (lx &gt; rx) { if (!va) va = { x: fx, y: y0 }; else if (va.y &gt;= y1) return; vb = { x: fx, y: y1 }; } else { if (!va) va = { x: fx, y: y1 }; else if (va.y &lt; y0) return; vb = { x: fx, y: y0 }; } } else { fm = (lx - rx) / (ry - ly); fb = fy - fm fx; if (fm &lt; -1 || fm &gt; 1) { if (lx &gt; rx) { if (!va) va = { x: (y0 - fb) / fm, y: y0 }; else if (va.y &gt;= y1) return; vb = { x: (y1 - fb) / fm, y: y1 }; } else { if (!va) va = { x: (y1 - fb) / fm, y: y1 }; else if (va.y &lt; y0) return; vb = { x: (y0 - fb) / fm, y: y0 }; } } else { if (ly &lt; ry) { if (!va) va = { x: x0, y: fm x0 + fb }; else if (va.x &gt;= x1) return; vb = { x: x1, y: fm x1 + fb }; } else { if (!va) va = { x: x1, y: fm x1 + fb }; else if (va.x &lt; x0) return; vb = { x: x0, y: fm x0 + fb }; } } } edge.a = va; edge.b = vb; return true; } function d3_geom_voronoiEdge(lSite, rSite) { this.l = lSite; this.r = rSite; this.a = this.b = null; } function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) { var edge = new d3_geom_voronoiEdge(lSite, rSite); d3_geom_voronoiEdges.push(edge); if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va); if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb); d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite)); d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite)); return edge; } function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) { var edge = new d3_geom_voronoiEdge(lSite, null); edge.a = va; edge.b = vb; d3_geom_voronoiEdges.push(edge); return edge; } function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) { if (!edge.a &amp;&amp; !edge.b) { edge.a = vertex; edge.l = lSite; edge.r = rSite; } else if (edge.l === rSite) { edge.b = vertex; } else { edge.a = vertex; } } function d3_geom_voronoiHalfEdge(edge, lSite, rSite) { var va = edge.a, vb = edge.b; this.edge = edge; this.site = lSite; this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y); } d3_geom_voronoiHalfEdge.prototype = { start: function() { return this.edge.l === this.site ? this.edge.a : this.edge.b; }, end: function() { return this.edge.l === this.site ? this.edge.b : this.edge.a; } }; function d3_geom_voronoiRedBlackTree() { this._ = null; } function d3_geom_voronoiRedBlackNode(node) { node.U = node.C = node.L = node.R = node.P = node.N = null; } d3_geom_voronoiRedBlackTree.prototype = { insert: function(after, node) { var parent, grandpa, uncle; if (after) { node.P = after; node.N = after.N; if (after.N) after.N.P = node; after.N = node; if (after.R) { after = after.R; while (after.L) after = after.L; after.L = node; } else { after.R = node; } parent = after; } else if (this._) { after = d3_geom_voronoiRedBlackFirst(this.); node.P = null; node.N = after; after.P = after.L = node; parent = after; } else { node.P = node.N = null; this. = node; parent = null; } node.L = node.R = null; node.U = parent; node.C = true; after = node; while (parent &amp;&amp; parent.C) { grandpa = parent.U; if (parent === grandpa.L) { uncle = grandpa.R; if (uncle &amp;&amp; uncle.C) { parent.C = uncle.C = false; grandpa.C = true; after = grandpa; } else { if (after === parent.R) { d3_geom_voronoiRedBlackRotateLeft(this, parent); after = parent; parent = after.U; } parent.C = false; grandpa.C = true; d3_geom_voronoiRedBlackRotateRight(this, grandpa); } } else { uncle = grandpa.L; if (uncle &amp;&amp; uncle.C) { parent.C = uncle.C = false; grandpa.C = true; after = grandpa; } else { if (after === parent.L) { d3_geom_voronoiRedBlackRotateRight(this, parent); after = parent; parent = after.U; } parent.C = false; grandpa.C = true; d3_geom_voronoiRedBlackRotateLeft(this, grandpa); } } parent = after.U; } this._.C = false; }, remove: function(node) { if (node.N) node.N.P = node.P; if (node.P) node.P.N = node.N; node.N = node.P = null; var parent = node.U, sibling, left = node.L, right = node.R, next, red; if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right); if (parent) { if (parent.L === node) parent.L = next; else parent.R = next; } else { this._ = next; } if (left &amp;&amp; right) { red = next.C; next.C = node.C; next.L = left; left.U = next; if (next !== right) { parent = next.U; next.U = node.U; node = next.R; parent.L = node; next.R = right; right.U = next; } else { next.U = parent; parent = next; node = next.R; } } else { red = node.C; node = next; } if (node) node.U = parent; if (red) return; if (node &amp;&amp; node.C) { node.C = false; return; } do { if (node === this._) break; if (node === parent.L) { sibling = parent.R; if (sibling.C) { sibling.C = false; parent.C = true; d3_geom_voronoiRedBlackRotateLeft(this, parent); sibling = parent.R; } if (sibling.L &amp;&amp; sibling.L.C || sibling.R &amp;&amp; sibling.R.C) { if (!sibling.R || !sibling.R.C) { sibling.L.C = false; sibling.C = true; d3_geom_voronoiRedBlackRotateRight(this, sibling); sibling = parent.R; } sibling.C = parent.C; parent.C = sibling.R.C = false; d3_geom_voronoiRedBlackRotateLeft(this, parent); node = this._; break; } } else { sibling = parent.L; if (sibling.C) { sibling.C = false; parent.C = true; d3_geom_voronoiRedBlackRotateRight(this, parent); sibling = parent.L; } if (sibling.L &amp;&amp; sibling.L.C || sibling.R &amp;&amp; sibling.R.C) { if (!sibling.L || !sibling.L.C) { sibling.R.C = false; sibling.C = true; d3_geom_voronoiRedBlackRotateLeft(this, sibling); sibling = parent.L; } sibling.C = parent.C; parent.C = sibling.L.C = false; d3_geom_voronoiRedBlackRotateRight(this, parent); node = this._; break; } } sibling.C = true; node = parent; parent = parent.U; } while (!node.C); if (node) node.C = false; } }; function d3_geom_voronoiRedBlackRotateLeft(tree, node) { var p = node, q = node.R, parent = p.U; if (parent) { if (parent.L === p) parent.L = q; else parent.R = q; } else { tree._ = q; } q.U = parent; p.U = q; p.R = q.L; if (p.R) p.R.U = p; q.L = p; } function d3_geom_voronoiRedBlackRotateRight(tree, node) { var p = node, q = node.L, parent = p.U; if (parent) { if (parent.L === p) parent.L = q; else parent.R = q; } else { tree._ = q; } q.U = parent; p.U = q; p.L = q.R; if (p.L) p.L.U = p; q.R = p; } function d3_geom_voronoiRedBlackFirst(node) { while (node.L) node = node.L; return node; } function d3_geom_voronoi(sites, bbox) { var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle; d3_geom_voronoiEdges = []; d3_geom_voronoiCells = new Array(sites.length); d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree(); d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree(); while (true) { circle = d3_geom_voronoiFirstCircle; if (site &amp;&amp; (!circle || site.y &lt; circle.y || site.y === circle.y &amp;&amp; site.x &lt; circle.x)) { if (site.x !== x0 || site.y !== y0) { d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site); d3_geom_voronoiAddBeach(site); x0 = site.x, y0 = site.y; } site = sites.pop(); } else if (circle) { d3_geom_voronoiRemoveBeach(circle.arc); } else { break; } } if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox); var diagram = { cells: d3_geom_voronoiCells, edges: d3_geom_voronoiEdges }; d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null; return diagram; } function d3_geom_voronoiVertexOrder(a, b) { return b.y - a.y || b.x - a.x; } d3.geom.voronoi = function(points) { var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent; if (points) return voronoi(points); function voronoi(data) { var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1]; d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) { var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) { var s = e.start(); return [ s.x, s.y ]; }) : site.x &gt;= x0 &amp;&amp; site.x &lt;= x1 &amp;&amp; site.y &gt;= y0 &amp;&amp; site.y &lt;= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : []; polygon.point = data[i]; }); return polygons; } function sites(data) { return data.map(function(d, i) { return { x: Math.round(fx(d, i) / ε) ε, y: Math.round(fy(d, i) / ε) ε, i: i }; }); } voronoi.links = function(data) { return d3_geom_voronoi(sites(data)).edges.filter(function(edge) { return edge.l &amp;&amp; edge.r; }).map(function(edge) { return { source: data[edge.l.i], target: data[edge.r.i] }; }); }; voronoi.triangles = function(data) { var triangles = []; d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) { var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l; while (++j &lt; m) { e0 = e1; s0 = s1; e1 = edges[j].edge; s1 = e1.l === site ? e1.r : e1.l; if (i &lt; s0.i &amp;&amp; i &lt; s1.i &amp;&amp; d3_geom_voronoiTriangleArea(site, s0, s1) &lt; 0) { triangles.push([ data[i], data[s0.i], data[s1.i] ]); } } }); return triangles; }; voronoi.x = function(_) { return arguments.length ? (fx = d3_functor(x = ), voronoi) : x; }; voronoi.y = function() { return arguments.length ? (fy = d3_functor(y = ), voronoi) : y; }; voronoi.clipExtent = function() { if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent; clipExtent = _ == null ? d3_geom_voronoiClipExtent : ; return voronoi; }; voronoi.size = function() { if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent &amp;&amp; clipExtent[1]; return voronoi.clipExtent(_ &amp;&amp; [ [ 0, 0 ], _ ]); }; return voronoi; }; var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ]; function d3_geom_voronoiTriangleArea(a, b, c) { return (a.x - c.x) (b.y - a.y) - (a.x - b.x) (c.y - a.y); } d3.geom.delaunay = function(vertices) { return d3.geom.voronoi().triangles(vertices); }; d3.geom.quadtree = function(points, x1, y1, x2, y2) { var x = d3_geom_pointX, y = d3_geom_pointY, compat; if (compat = arguments.length) { x = d3_geom_quadtreeCompatX; y = d3_geom_quadtreeCompatY; if (compat === 3) { y2 = y1; x2 = x1; y1 = x1 = 0; } return quadtree(points); } function quadtree(data) { var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_; if (x1 != null) { x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2; } else { x2_ = y2_ = -(x1_ = y1_ = Infinity); xs = [], ys = []; n = data.length; if (compat) for (i = 0; i &lt; n; ++i) { d = data[i]; if (d.x &lt; x1_) x1_ = d.x; if (d.y &lt; y1_) y1_ = d.y; if (d.x &gt; x2_) x2_ = d.x; if (d.y &gt; y2_) y2_ = d.y; xs.push(d.x); ys.push(d.y); } else for (i = 0; i &lt; n; ++i) { var x_ = +fx(d = data[i], i), y_ = +fy(d, i); if (x_ &lt; x1_) x1_ = x_; if (y_ &lt; y1_) y1_ = y_; if (x_ &gt; x2_) x2_ = x_; if (y_ &gt; y2_) y2_ = y_; xs.push(x_); ys.push(y_); } } var dx = x2_ - x1_, dy = y2_ - y1_; if (dx &gt; dy) y2_ = y1_ + dx; else x2_ = x1_ + dy; function insert(n, d, x, y, x1, y1, x2, y2) { if (isNaN(x) || isNaN(y)) return; if (n.leaf) { var nx = n.x, ny = n.y; if (nx != null) { if (abs(nx - x) + abs(ny - y) &lt; .01) { insertChild(n, d, x, y, x1, y1, x2, y2); } else { var nPoint = n.point; n.x = n.y = n.point = null; insertChild(n, nPoint, nx, ny, x1, y1, x2, y2); insertChild(n, d, x, y, x1, y1, x2, y2); } } else { n.x = x, n.y = y, n.point = d; } } else { insertChild(n, d, x, y, x1, y1, x2, y2); } } function insertChild(n, d, x, y, x1, y1, x2, y2) { var xm = (x1 + x2) .5, ym = (y1 + y2) .5, right = x &gt;= xm, below = y &gt;= ym, i = below &lt;&lt; 1 | right; n.leaf = false; n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode()); if (right) x1 = xm; else x2 = xm; if (below) y1 = ym; else y2 = ym; insert(n, d, x, y, x1, y1, x2, y2); } var root = d3_geom_quadtreeNode(); root.add = function(d) { insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_); }; root.visit = function(f) { d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_); }; root.find = function(point) { return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_); }; i = -1; if (x1 == null) { while (++i &lt; n) { insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_); } –i; } else data.forEach(root.add); xs = ys = data = d = null; return root; } quadtree.x = function(_) { return arguments.length ? (x = , quadtree) : x; }; quadtree.y = function() { return arguments.length ? (y = , quadtree) : y; }; quadtree.extent = function() { if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ]; if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +[0][0], y1 = +[0][1], x2 = +[1][0], y2 = +[1][1]; return quadtree; }; quadtree.size = function() { if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ]; if ( == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +[0], y2 = +[1]; return quadtree; }; return quadtree; }; function d3_geom_quadtreeCompatX(d) { return d.x; } function d3_geom_quadtreeCompatY(d) { return d.y; } function d3_geom_quadtreeNode() { return { leaf: true, nodes: [], point: null, x: null, y: null }; } function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) { if (!f(node, x1, y1, x2, y2)) { var sx = (x1 + x2) .5, sy = (y1 + y2) .5, children = node.nodes; if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy); if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy); if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2); if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2); } } function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) { var minDistance2 = Infinity, closestPoint; (function find(node, x1, y1, x2, y2) { if (x1 &gt; x3 || y1 &gt; y3 || x2 &lt; x0 || y2 &lt; y0) return; if (point = node.point) { var point, dx = x - node.x, dy = y - node.y, distance2 = dx dx + dy dy; if (distance2 &lt; minDistance2) { var distance = Math.sqrt(minDistance2 = distance2); x0 = x - distance, y0 = y - distance; x3 = x + distance, y3 = y + distance; closestPoint = point; } } var children = node.nodes, xm = (x1 + x2) .5, ym = (y1 + y2) .5, right = x &gt;= xm, below = y &gt;= ym; for (var i = below &lt;&lt; 1 | right, j = i + 4; i &lt; j; ++i) { if (node = children[i &amp; 3]) switch (i &amp; 3) { case 0: find(node, x1, y1, xm, ym); break; case 1: find(node, xm, y1, x2, ym); break; case 2: find(node, x1, ym, xm, y2); break; case 3: find(node, xm, ym, x2, y2); break; } } })(root, x0, y0, x3, y3); return closestPoint; } d3.interpolateRgb = d3_interpolateRgb; function d3_interpolateRgb(a, b) { a = d3.rgb(a); b = d3.rgb(b); var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab; return function(t) { return “#” + d3_rgb_hex(Math.round(ar + br t)) + d3_rgb_hex(Math.round(ag + bg t)) + d3_rgb_hex(Math.round(ab + bb t)); }; } d3.interpolateObject = d3_interpolateObject; function d3_interpolateObject(a, b) { var i = {}, c = {}, k; for (k in a) { if (k in b) { i[k] = d3_interpolate(a[k], b[k]); } else { c[k] = a[k]; } } for (k in b) { if (!(k in a)) { c[k] = b[k]; } } return function(t) { for (k in i) c[k] = ik; return c; }; } d3.interpolateNumber = d3_interpolateNumber; function d3_interpolateNumber(a, b) { a = +a, b = +b; return function(t) { return a (1 - t) + b t; }; } d3.interpolateString = d3_interpolateString; function d3_interpolateString(a, b) { var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = []; a = a + “”, b = b + “”; while ((am = d3_interpolate_numberA.exec(a)) &amp;&amp; (bm = d3_interpolate_numberB.exec(b))) { if ((bs = bm.index) &gt; bi) { bs = b.slice(bi, bs); if (s[i]) s[i] += bs; else s[++i] = bs; } if ((am = am[0]) === (bm = bm[0])) { if (s[i]) s[i] += bm; else s[++i] = bm; } else { s[++i] = null; q.push({ i: i, x: d3_interpolateNumber(am, bm) }); } bi = d3_interpolate_numberB.lastIndex; } if (bi &lt; b.length) { bs = b.slice(bi); if (s[i]) s[i] += bs; else s[++i] = bs; } return s.length &lt; 2 ? q[0] ? (b = q[0].x, function(t) { return b(t) + “”; }) : function() { return b; } : (b = q.length, function(t) { for (var i = 0, o; i &lt; b; ++i) s[(o = q[i]).i] = o.x(t); return s.join(“”); }); } var d3_interpolate_numberA = /[-+]?(?:\d+.?\d|.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, “g”); d3.interpolate = d3_interpolate; function d3_interpolate(a, b) { var i = d3.interpolators.length, f; while (–i &gt;= 0 &amp;&amp; !(f = d3.interpolatorsi)) ; return f; } d3.interpolators = [ function(a, b) { var t = typeof b; return (t === “string” ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb(|hsl()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === “object” &amp;&amp; isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b); } ]; d3.interpolateArray = d3_interpolateArray; function d3_interpolateArray(a, b) { var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i; for (i = 0; i &lt; n0; ++i) x.push(d3_interpolate(a[i], b[i])); for (;i &lt; na; ++i) c[i] = a[i]; for (;i &lt; nb; ++i) c[i] = b[i]; return function(t) { for (i = 0; i &lt; n0; ++i) c[i] = xi; return c; }; } var d3_ease_default = function() { return d3_identity; }; var d3_ease = d3.map({ linear: d3_ease_default, poly: d3_ease_poly, quad: function() { return d3_ease_quad; }, cubic: function() { return d3_ease_cubic; }, sin: function() { return d3_ease_sin; }, exp: function() { return d3_ease_exp; }, circle: function() { return d3_ease_circle; }, elastic: d3_ease_elastic, back: d3_ease_back, bounce: function() { return d3_ease_bounce; } }); var d3_ease_mode = d3.map({ “in”: d3_identity, out: d3_ease_reverse, “in-out”: d3_ease_reflect, “out-in”: function(f) { return d3_ease_reflect(d3_ease_reverse(f)); } }); d3.ease = function(name) { var i = name.indexOf(“-“), t = i &gt;= 0 ? name.slice(0, i) : name, m = i &gt;= 0 ? name.slice(i + 1) : “in”; t = d3_ease.get(t) || d3_ease_default; m = d3_ease_mode.get(m) || d3_identity; return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1)))); }; function d3_ease_clamp(f) { return function(t) { return t &lt;= 0 ? 0 : t &gt;= 1 ? 1 : f(t); }; } function d3_ease_reverse(f) { return function(t) { return 1 - f(1 - t); }; } function d3_ease_reflect(f) { return function(t) { return .5 (t &lt; .5 ? f(2 t) : 2 - f(2 - 2 t)); }; } function d3_ease_quad(t) { return t t; } function d3_ease_cubic(t) { return t t t; } function d3_ease_cubicInOut(t) { if (t &lt;= 0) return 0; if (t &gt;= 1) return 1; var t2 = t t, t3 = t2 t; return 4 (t &lt; .5 ? t3 : 3 (t - t2) + t3 - .75); } function d3_ease_poly(e) { return function(t) { return Math.pow(t, e); }; } function d3_ease_sin(t) { return 1 - Math.cos(t halfπ); } function d3_ease_exp(t) { return Math.pow(2, 10 (t - 1)); } function d3_ease_circle(t) { return 1 - Math.sqrt(1 - t t); } function d3_ease_elastic(a, p) { var s; if (arguments.length &lt; 2) p = .45; if (arguments.length) s = p / τ Math.asin(1 / a); else a = 1, s = p / 4; return function(t) { return 1 + a Math.pow(2, -10 t) Math.sin((t - s) τ / p); }; } function d3_ease_back(s) { if (!s) s = 1.70158; return function(t) { return t t ((s + 1) t - s); }; } function d3_ease_bounce(t) { return t &lt; 1 / 2.75 ? 7.5625 t t : t &lt; 2 / 2.75 ? 7.5625 (t -= 1.5 / 2.75) t + .75 : t &lt; 2.5 / 2.75 ? 7.5625 (t -= 2.25 / 2.75) t + .9375 : 7.5625 (t -= 2.625 / 2.75) t + .984375; } d3.interpolateHcl = d3_interpolateHcl; function d3_interpolateHcl(a, b) { a = d3.hcl(a); b = d3.hcl(b); var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al; if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac; if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &gt; 180) bh -= 360; else if (bh &lt; -180) bh += 360; return function(t) { return d3_hcl_lab(ah + bh t, ac + bc t, al + bl t) + “”; }; } d3.interpolateHsl = d3_interpolateHsl; function d3_interpolateHsl(a, b) { a = d3.hsl(a); b = d3.hsl(b); var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al; if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as; if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh &gt; 180) bh -= 360; else if (bh &lt; -180) bh += 360; return function(t) { return d3_hsl_rgb(ah + bh t, as + bs t, al + bl t) + “”; }; } d3.interpolateLab = d3_interpolateLab; function d3_interpolateLab(a, b) { a = d3.lab(a); b = d3.lab(b); var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab; return function(t) { return d3_lab_rgb(al + bl t, aa + ba t, ab + bb t) + “”; }; } d3.interpolateRound = d3_interpolateRound; function d3_interpolateRound(a, b) { b -= a; return function(t) { return Math.round(a + b t); }; } d3.transform = function(string) { var g = d3_document.createElementNS(d3.ns.prefix.svg, “g”); return (d3.transform = function(string) { if (string != null) { g.setAttribute(“transform”, string); var t = g.transform.baseVal.consolidate(); } return new d3_transform(t ? t.matrix : d3_transformIdentity); })(string); }; function d3_transform(m) { var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0; if (r0[0] r1[1] &lt; r1[0] r0[1]) { r0[0] = -1; r0[1] = -1; kx = -1; kz = -1; } this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) d3_degrees; this.translate = [ m.e, m.f ]; this.scale = [ kx, ky ]; this.skew = ky ? Math.atan2(kz, ky) d3_degrees : 0; } d3_transform.prototype.toString = function() { return “translate(“ + this.translate + “)rotate(“ + this.rotate + “)skewX(“ + this.skew + “)scale(“ + this.scale + “)”; }; function d3_transformDot(a, b) { return a[0] b[0] + a[1] b[1]; } function d3_transformNormalize(a) { var k = Math.sqrt(d3_transformDot(a, a)); if (k) { a[0] /= k; a[1] /= k; } return k; } function d3_transformCombine(a, b, k) { a[0] += k b[0]; a[1] += k b[1]; return a; } var d3_transformIdentity = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 }; d3.interpolateTransform = d3_interpolateTransform; function d3_interpolateTransformPop(s) { return s.length ? s.pop() + “,” : “”; } function d3_interpolateTranslate(ta, tb, s, q) { if (ta[0] !== tb[0] || ta[1] !== tb[1]) { var i = s.push(“translate(“, null, “,”, null, “)”); q.push({ i: i - 4, x: d3_interpolateNumber(ta[0], tb[0]) }, { i: i - 2, x: d3_interpolateNumber(ta[1], tb[1]) }); } else if (tb[0] || tb[1]) { s.push(“translate(“ + tb + “)”); } } function d3_interpolateRotate(ra, rb, s, q) { if (ra !== rb) { if (ra - rb &gt; 180) rb += 360; else if (rb - ra &gt; 180) ra += 360; q.push({ i: s.push(d3_interpolateTransformPop(s) + “rotate(“, null, “)”) - 2, x: d3_interpolateNumber(ra, rb) }); } else if (rb) { s.push(d3_interpolateTransformPop(s) + “rotate(“ + rb + “)”); } } function d3_interpolateSkew(wa, wb, s, q) { if (wa !== wb) { q.push({ i: s.push(d3_interpolateTransformPop(s) + “skewX(“, null, “)”) - 2, x: d3_interpolateNumber(wa, wb) }); } else if (wb) { s.push(d3_interpolateTransformPop(s) + “skewX(“ + wb + “)”); } } function d3_interpolateScale(ka, kb, s, q) { if (ka[0] !== kb[0] || ka[1] !== kb[1]) { var i = s.push(d3_interpolateTransformPop(s) + “scale(“, null, “,”, null, “)”); q.push({ i: i - 4, x: d3_interpolateNumber(ka[0], kb[0]) }, { i: i - 2, x: d3_interpolateNumber(ka[1], kb[1]) }); } else if (kb[0] !== 1 || kb[1] !== 1) { s.push(d3_interpolateTransformPop(s) + “scale(“ + kb + “)”); } } function d3_interpolateTransform(a, b) { var s = [], q = []; a = d3.transform(a), b = d3.transform(b); d3_interpolateTranslate(a.translate, b.translate, s, q); d3_interpolateRotate(a.rotate, b.rotate, s, q); d3_interpolateSkew(a.skew, b.skew, s, q); d3_interpolateScale(a.scale, b.scale, s, q); a = b = null; return function(t) { var i = -1, n = q.length, o; while (++i &lt; n) s[(o = q[i]).i] = o.x(t); return s.join(“”); }; } function d3_uninterpolateNumber(a, b) { b = (b -= a = +a) || 1 / b; return function(x) { return (x - a) / b; }; } function d3_uninterpolateClamp(a, b) { b = (b -= a = +a) || 1 / b; return function(x) { return Math.max(0, Math.min(1, (x - a) / b)); }; } d3.layout = {}; d3.layout.bundle = function() { return function(links) { var paths = [], i = -1, n = links.length; while (++i &lt; n) paths.push(d3_layout_bundlePath(links[i])); return paths; }; }; function d3_layout_bundlePath(link) { var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ]; while (start !== lca) { start = start.parent; points.push(start); } var k = points.length; while (end !== lca) { points.splice(k, 0, end); end = end.parent; } return points; } function d3_layout_bundleAncestors(node) { var ancestors = [], parent = node.parent; while (parent != null) { ancestors.push(node); node = parent; parent = parent.parent; } ancestors.push(node); return ancestors; } function d3_layout_bundleLeastCommonAncestor(a, b) { if (a === b) return a; var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null; while (aNode === bNode) { sharedNode = aNode; aNode = aNodes.pop(); bNode = bNodes.pop(); } return sharedNode; } d3.layout.chord = function() { var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords; function relayout() { var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j; chords = []; groups = []; k = 0, i = -1; while (++i &lt; n) { x = 0, j = -1; while (++j &lt; n) { x += matrix[i][j]; } groupSums.push(x); subgroupIndex.push(d3.range(n)); k += x; } if (sortGroups) { groupIndex.sort(function(a, b) { return sortGroups(groupSums[a], groupSums[b]); }); } if (sortSubgroups) { subgroupIndex.forEach(function(d, i) { d.sort(function(a, b) { return sortSubgroups(matrix[i][a], matrix[i][b]); }); }); } k = (τ - padding n) / k; x = 0, i = -1; while (++i &lt; n) { x0 = x, j = -1; while (++j &lt; n) { var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v k; subgroups[di + “-“ + dj] = { index: di, subindex: dj, startAngle: a0, endAngle: a1, value: v }; } groups[di] = { index: di, startAngle: x0, endAngle: x, value: groupSums[di] }; x += padding; } i = -1; while (++i &lt; n) { j = i - 1; while (++j &lt; n) { var source = subgroups[i + “-“ + j], target = subgroups[j + “-“ + i]; if (source.value || target.value) { chords.push(source.value &lt; target.value ? { source: target, target: source } : { source: source, target: target }); } } } if (sortChords) resort(); } function resort() { chords.sort(function(a, b) { return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2); }); } chord.matrix = function(x) { if (!arguments.length) return matrix; n = (matrix = x) &amp;&amp; matrix.length; chords = groups = null; return chord; }; chord.padding = function(x) { if (!arguments.length) return padding; padding = x; chords = groups = null; return chord; }; chord.sortGroups = function(x) { if (!arguments.length) return sortGroups; sortGroups = x; chords = groups = null; return chord; }; chord.sortSubgroups = function(x) { if (!arguments.length) return sortSubgroups; sortSubgroups = x; chords = null; return chord; }; chord.sortChords = function(x) { if (!arguments.length) return sortChords; sortChords = x; if (chords) resort(); return chord; }; chord.chords = function() { if (!chords) relayout(); return chords; }; chord.groups = function() { if (!groups) relayout(); return groups; }; return chord; }; d3.layout.force = function() { var force = {}, event = d3.dispatch(“start”, “tick”, “end”), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges; function repulse(node) { return function(quad, x1, _, x2) { if (quad.point !== node) { var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx dx + dy dy; if (dw dw / theta2 &lt; dn) { if (dn &lt; chargeDistance2) { var k = quad.charge / dn; node.px -= dx k; node.py -= dy k; } return true; } if (quad.point &amp;&amp; dn &amp;&amp; dn &lt; chargeDistance2) { var k = quad.pointCharge / dn; node.px -= dx k; node.py -= dy k; } } return !quad.charge; }; } force.tick = function() { if ((alpha = .99) &lt; .005) { timer = null; event.end({ type: “end”, alpha: alpha = 0 }); return true; } var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y; for (i = 0; i &lt; m; ++i) { o = links[i]; s = o.source; t = o.target; x = t.x - s.x; y = t.y - s.y; if (l = x x + y y) { l = alpha strengths[i] ((l = Math.sqrt(l)) - distances[i]) / l; x = l; y = l; t.x -= x (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5); t.y -= y k; s.x += x (k = 1 - k); s.y += y k; } } if (k = alpha gravity) { x = size[0] / 2; y = size[1] / 2; i = -1; if (k) while (++i &lt; n) { o = nodes[i]; o.x += (x - o.x) k; o.y += (y - o.y) k; } } if (charge) { d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges); i = -1; while (++i &lt; n) { if (!(o = nodes[i]).fixed) { q.visit(repulse(o)); } } } i = -1; while (++i &lt; n) { o = nodes[i]; if (o.fixed) { o.x = o.px; o.y = o.py; } else { o.x -= (o.px - (o.px = o.x)) friction; o.y -= (o.py - (o.py = o.y)) friction; } } event.tick({ type: “tick”, alpha: alpha }); }; force.nodes = function(x) { if (!arguments.length) return nodes; nodes = x; return force; }; force.links = function(x) { if (!arguments.length) return links; links = x; return force; }; force.size = function(x) { if (!arguments.length) return size; size = x; return force; }; force.linkDistance = function(x) { if (!arguments.length) return linkDistance; linkDistance = typeof x === “function” ? x : +x; return force; }; force.distance = force.linkDistance; force.linkStrength = function(x) { if (!arguments.length) return linkStrength; linkStrength = typeof x === “function” ? x : +x; return force; }; force.friction = function(x) { if (!arguments.length) return friction; friction = +x; return force; }; force.charge = function(x) { if (!arguments.length) return charge; charge = typeof x === “function” ? x : +x; return force; }; force.chargeDistance = function(x) { if (!arguments.length) return Math.sqrt(chargeDistance2); chargeDistance2 = x x; return force; }; force.gravity = function(x) { if (!arguments.length) return gravity; gravity = +x; return force; }; force.theta = function(x) { if (!arguments.length) return Math.sqrt(theta2); theta2 = x x; return force; }; force.alpha = function(x) { if (!arguments.length) return alpha; x = +x; if (alpha) { if (x &gt; 0) { alpha = x; } else { timer.c = null, timer.t = NaN, timer = null; event.end({ type: “end”, alpha: alpha = 0 }); } } else if (x &gt; 0) { event.start({ type: “start”, alpha: alpha = x }); timer = d3_timer(force.tick); } return force; }; force.start = function() { var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o; for (i = 0; i &lt; n; ++i) { (o = nodes[i]).index = i; o.weight = 0; } for (i = 0; i &lt; m; ++i) { o = links[i]; if (typeof o.source == “number”) o.source = nodes[o.source]; if (typeof o.target == “number”) o.target = nodes[o.target]; ++o.source.weight; ++o.target.weight; } for (i = 0; i &lt; n; ++i) { o = nodes[i]; if (isNaN(o.x)) o.x = position(“x”, w); if (isNaN(o.y)) o.y = position(“y”, h); if (isNaN(o.px)) o.px = o.x; if (isNaN(o.py)) o.py = o.y; } distances = []; if (typeof linkDistance === “function”) for (i = 0; i &lt; m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i &lt; m; ++i) distances[i] = linkDistance; strengths = []; if (typeof linkStrength === “function”) for (i = 0; i &lt; m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i &lt; m; ++i) strengths[i] = linkStrength; charges = []; if (typeof charge === “function”) for (i = 0; i &lt; n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i &lt; n; ++i) charges[i] = charge; function position(dimension, size) { if (!neighbors) { neighbors = new Array(n); for (j = 0; j &lt; n; ++j) { neighbors[j] = []; } for (j = 0; j &lt; m; ++j) { var o = links[j]; neighbors[o.source.index].push(o.target); neighbors[o.target.index].push(o.source); } } var candidates = neighbors[i], j = -1, l = candidates.length, x; while (++j &lt; l) if (!isNaN(x = candidates[j][dimension])) return x; return Math.random() size; } return force.resume(); }; force.resume = function() { return force.alpha(.1); }; force.stop = function() { return force.alpha(0); }; force.drag = function() { if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(“dragstart.force”, d3_layout_forceDragstart).on(“drag.force”, dragmove).on(“dragend.force”, d3_layout_forceDragend); if (!arguments.length) return drag; this.on(“mouseover.force”, d3_layout_forceMouseover).on(“mouseout.force”, d3_layout_forceMouseout).call(drag); }; function dragmove(d) { d.px = d3.event.x, d.py = d3.event.y; force.resume(); } return d3.rebind(force, event, “on”); }; function d3_layout_forceDragstart(d) { d.fixed |= 2; } function d3_layout_forceDragend(d) { d.fixed &amp;= ~6; } function d3_layout_forceMouseover(d) { d.fixed |= 4; d.px = d.x, d.py = d.y; } function d3_layout_forceMouseout(d) { d.fixed &amp;= ~4; } function d3_layout_forceAccumulate(quad, alpha, charges) { var cx = 0, cy = 0; quad.charge = 0; if (!quad.leaf) { var nodes = quad.nodes, n = nodes.length, i = -1, c; while (++i &lt; n) { c = nodes[i]; if (c == null) continue; d3_layout_forceAccumulate(c, alpha, charges); quad.charge += c.charge; cx += c.charge c.cx; cy += c.charge c.cy; } } if (quad.point) { if (!quad.leaf) { quad.point.x += Math.random() - .5; quad.point.y += Math.random() - .5; } var k = alpha charges[quad.point.index]; quad.charge += quad.pointCharge = k; cx += k quad.point.x; cy += k quad.point.y; } quad.cx = cx / quad.charge; quad.cy = cy / quad.charge; } var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity; d3.layout.hierarchy = function() { var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue; function hierarchy(root) { var stack = [ root ], nodes = [], node; root.depth = 0; while ((node = stack.pop()) != null) { nodes.push(node); if ((childs = children.call(hierarchy, node, node.depth)) &amp;&amp; (n = childs.length)) { var n, childs, child; while (–n &gt;= 0) { stack.push(child = childs[n]); child.parent = node; child.depth = node.depth + 1; } if (value) node.value = 0; node.children = childs; } else { if (value) node.value = +value.call(hierarchy, node, node.depth) || 0; delete node.children; } } d3_layout_hierarchyVisitAfter(root, function(node) { var childs, parent; if (sort &amp;&amp; (childs = node.children)) childs.sort(sort); if (value &amp;&amp; (parent = node.parent)) parent.value += node.value; }); return nodes; } hierarchy.sort = function(x) { if (!arguments.length) return sort; sort = x; return hierarchy; }; hierarchy.children = function(x) { if (!arguments.length) return children; children = x; return hierarchy; }; hierarchy.value = function(x) { if (!arguments.length) return value; value = x; return hierarchy; }; hierarchy.revalue = function(root) { if (value) { d3_layout_hierarchyVisitBefore(root, function(node) { if (node.children) node.value = 0; }); d3_layout_hierarchyVisitAfter(root, function(node) { var parent; if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0; if (parent = node.parent) parent.value += node.value; }); } return root; }; return hierarchy; }; function d3_layout_hierarchyRebind(object, hierarchy) { d3.rebind(object, hierarchy, “sort”, “children”, “value”); object.nodes = object; object.links = d3_layout_hierarchyLinks; return object; } function d3_layout_hierarchyVisitBefore(node, callback) { var nodes = [ node ]; while ((node = nodes.pop()) != null) { callback(node); if ((children = node.children) &amp;&amp; (n = children.length)) { var n, children; while (–n &gt;= 0) nodes.push(children[n]); } } } function d3_layout_hierarchyVisitAfter(node, callback) { var nodes = [ node ], nodes2 = []; while ((node = nodes.pop()) != null) { nodes2.push(node); if ((children = node.children) &amp;&amp; (n = children.length)) { var i = -1, n, children; while (++i &lt; n) nodes.push(children[i]); } } while ((node = nodes2.pop()) != null) { callback(node); } } function d3_layout_hierarchyChildren(d) { return d.children; } function d3_layout_hierarchyValue(d) { return d.value; } function d3_layout_hierarchySort(a, b) { return b.value - a.value; } function d3_layout_hierarchyLinks(nodes) { return d3.merge(nodes.map(function(parent) { return (parent.children || []).map(function(child) { return { source: parent, target: child }; }); })); } d3.layout.partition = function() { var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ]; function position(node, x, dx, dy) { var children = node.children; node.x = x; node.y = node.depth dy; node.dx = dx; node.dy = dy; if (children &amp;&amp; (n = children.length)) { var i = -1, n, c, d; dx = node.value ? dx / node.value : 0; while (++i &lt; n) { position(c = children[i], x, d = c.value dx, dy); x += d; } } } function depth(node) { var children = node.children, d = 0; if (children &amp;&amp; (n = children.length)) { var i = -1, n; while (++i &lt; n) d = Math.max(d, depth(children[i])); } return 1 + d; } function partition(d, i) { var nodes = hierarchy.call(this, d, i); position(nodes[0], 0, size[0], size[1] / depth(nodes[0])); return nodes; } partition.size = function(x) { if (!arguments.length) return size; size = x; return partition; }; return d3_layout_hierarchyRebind(partition, hierarchy); }; d3.layout.pie = function() { var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0; function pie(data) { var n = data.length, values = data.map(function(d, i) { return +value.call(pie, d, i); }), a = +(typeof startAngle === “function” ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === “function” ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === “function” ? padAngle.apply(this, arguments) : padAngle)), pa = p (da &lt; 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n pa) / sum : 0, index = d3.range(n), arcs = [], v; if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) { return values[j] - values[i]; } : function(i, j) { return sort(data[i], data[j]); }); index.forEach(function(i) { arcs[i] = { data: data[i], value: v = values[i], startAngle: a, endAngle: a += v k + pa, padAngle: p }; }); return arcs; } pie.value = function(_) { if (!arguments.length) return value; value = ; return pie; }; pie.sort = function() { if (!arguments.length) return sort; sort = ; return pie; }; pie.startAngle = function() { if (!arguments.length) return startAngle; startAngle = ; return pie; }; pie.endAngle = function() { if (!arguments.length) return endAngle; endAngle = ; return pie; }; pie.padAngle = function() { if (!arguments.length) return padAngle; padAngle = _; return pie; }; return pie; }; var d3_layout_pieSortByValue = {}; d3.layout.stack = function() { var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY; function stack(data, index) { if (!(n = data.length)) return data; var series = data.map(function(d, i) { return values.call(stack, d, i); }); var points = series.map(function(d) { return d.map(function(v, i) { return [ x.call(stack, v, i), y.call(stack, v, i) ]; }); }); var orders = order.call(stack, points, index); series = d3.permute(series, orders); points = d3.permute(points, orders); var offsets = offset.call(stack, points, index); var m = series[0].length, n, i, j, o; for (j = 0; j &lt; m; ++j) { out.call(stack, series[0][j], o = offsets[j], points[0][j][1]); for (i = 1; i &lt; n; ++i) { out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]); } } return data; } stack.values = function(x) { if (!arguments.length) return values; values = x; return stack; }; stack.order = function(x) { if (!arguments.length) return order; order = typeof x === “function” ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault; return stack; }; stack.offset = function(x) { if (!arguments.length) return offset; offset = typeof x === “function” ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero; return stack; }; stack.x = function(z) { if (!arguments.length) return x; x = z; return stack; }; stack.y = function(z) { if (!arguments.length) return y; y = z; return stack; }; stack.out = function(z) { if (!arguments.length) return out; out = z; return stack; }; return stack; }; function d3_layout_stackX(d) { return d.x; } function d3_layout_stackY(d) { return d.y; } function d3_layout_stackOut(d, y0, y) { d.y0 = y0; d.y = y; } var d3_layout_stackOrders = d3.map({ “inside-out”: function(data) { var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) { return max[a] - max[b]; }), top = 0, bottom = 0, tops = [], bottoms = []; for (i = 0; i &lt; n; ++i) { j = index[i]; if (top &lt; bottom) { top += sums[j]; tops.push(j); } else { bottom += sums[j]; bottoms.push(j); } } return bottoms.reverse().concat(tops); }, reverse: function(data) { return d3.range(data.length).reverse(); }, “default”: d3_layout_stackOrderDefault }); var d3_layout_stackOffsets = d3.map({ silhouette: function(data) { var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = []; for (j = 0; j &lt; m; ++j) { for (i = 0, o = 0; i &lt; n; i++) o += data[i][j][1]; if (o &gt; max) max = o; sums.push(o); } for (j = 0; j &lt; m; ++j) { y0[j] = (max - sums[j]) / 2; } return y0; }, wiggle: function(data) { var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = []; y0[0] = o = o0 = 0; for (j = 1; j &lt; m; ++j) { for (i = 0, s1 = 0; i &lt; n; ++i) s1 += data[i][j][1]; for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i &lt; n; ++i) { for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 dx); k &lt; i; ++k) { s3 += (data[k][j][1] - data[k][j - 1][1]) / dx; } s2 += s3 data[i][j][1]; } y0[j] = o -= s1 ? s2 / s1 dx : 0; if (o &lt; o0) o0 = o; } for (j = 0; j &lt; m; ++j) y0[j] -= o0; return y0; }, expand: function(data) { var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = []; for (j = 0; j &lt; m; ++j) { for (i = 0, o = 0; i &lt; n; i++) o += data[i][j][1]; if (o) for (i = 0; i &lt; n; i++) data[i][j][1] /= o; else for (i = 0; i &lt; n; i++) data[i][j][1] = k; } for (j = 0; j &lt; m; ++j) y0[j] = 0; return y0; }, zero: d3_layout_stackOffsetZero }); function d3_layout_stackOrderDefault(data) { return d3.range(data.length); } function d3_layout_stackOffsetZero(data) { var j = -1, m = data[0].length, y0 = []; while (++j &lt; m) y0[j] = 0; return y0; } function d3_layout_stackMaxIndex(array) { var i = 1, j = 0, v = array[0][1], k, n = array.length; for (;i &lt; n; ++i) { if ((k = array[i][1]) &gt; v) { j = i; v = k; } } return j; } function d3_layout_stackReduceSum(d) { return d.reduce(d3_layout_stackSum, 0); } function d3_layout_stackSum(p, d) { return p + d[1]; } d3.layout.histogram = function() { var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges; function histogram(data, i) { var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x; while (++i &lt; m) { bin = bins[i] = []; bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]); bin.y = 0; } if (m &gt; 0) { i = -1; while (++i &lt; n) { x = values[i]; if (x &gt;= range[0] &amp;&amp; x &lt;= range[1]) { bin = bins[d3.bisect(thresholds, x, 1, m) - 1]; bin.y += k; bin.push(data[i]); } } } return bins; } histogram.value = function(x) { if (!arguments.length) return valuer; valuer = x; return histogram; }; histogram.range = function(x) { if (!arguments.length) return ranger; ranger = d3_functor(x); return histogram; }; histogram.bins = function(x) { if (!arguments.length) return binner; binner = typeof x === “number” ? function(range) { return d3_layout_histogramBinFixed(range, x); } : d3_functor(x); return histogram; }; histogram.frequency = function(x) { if (!arguments.length) return frequency; frequency = !!x; return histogram; }; return histogram; }; function d3_layout_histogramBinSturges(range, values) { return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1)); } function d3_layout_histogramBinFixed(range, n) { var x = -1, b = +range[0], m = (range[1] - b) / n, f = []; while (++x &lt;= n) f[x] = m x + b; return f; } function d3_layout_histogramRange(values) { return [ d3.min(values), d3.max(values) ]; } d3.layout.pack = function() { var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius; function pack(d, i) { var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === “function” ? radius : function() { return radius; }; root.x = root.y = 0; d3_layout_hierarchyVisitAfter(root, function(d) { d.r = +r(d.value); }); d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings); if (padding) { var dr = padding (radius ? 1 : Math.max(2 root.r / w, 2 root.r / h)) / 2; d3_layout_hierarchyVisitAfter(root, function(d) { d.r += dr; }); d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings); d3_layout_hierarchyVisitAfter(root, function(d) { d.r -= dr; }); } d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 root.r / w, 2 root.r / h)); return nodes; } pack.size = function(_) { if (!arguments.length) return size; size = ; return pack; }; pack.radius = function() { if (!arguments.length) return radius; radius = _ == null || typeof _ === “function” ? _ : +; return pack; }; pack.padding = function() { if (!arguments.length) return padding; padding = +_; return pack; }; return d3_layout_hierarchyRebind(pack, hierarchy); }; function d3_layout_packSort(a, b) { return a.value - b.value; } function d3_layout_packInsert(a, b) { var c = a._pack_next; a._pack_next = b; b._pack_prev = a; b._pack_next = c; c._pack_prev = b; } function d3_layout_packSplice(a, b) { a._pack_next = b; b._pack_prev = a; } function d3_layout_packIntersects(a, b) { var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r; return .999 dr dr &gt; dx dx + dy dy; } function d3_layout_packSiblings(node) { if (!(nodes = node.children) || !(n = nodes.length)) return; var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n; function bound(node) { xMin = Math.min(node.x - node.r, xMin); xMax = Math.max(node.x + node.r, xMax); yMin = Math.min(node.y - node.r, yMin); yMax = Math.max(node.y + node.r, yMax); } nodes.forEach(d3_layout_packLink); a = nodes[0]; a.x = -a.r; a.y = 0; bound(a); if (n &gt; 1) { b = nodes[1]; b.x = b.r; b.y = 0; bound(b); if (n &gt; 2) { c = nodes[2]; d3_layout_packPlace(a, b, c); bound(c); d3_layout_packInsert(a, c); a._pack_prev = c; d3_layout_packInsert(c, b); b = a._pack_next; for (i = 3; i &lt; n; i++) { d3_layout_packPlace(a, b, c = nodes[i]); var isect = 0, s1 = 1, s2 = 1; for (j = b._pack_next; j !== b; j = j._pack_next, s1++) { if (d3_layout_packIntersects(j, c)) { isect = 1; break; } } if (isect == 1) { for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) { if (d3_layout_packIntersects(k, c)) { break; } } } if (isect) { if (s1 &lt; s2 || s1 == s2 &amp;&amp; b.r &lt; a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b); i–; } else { d3_layout_packInsert(a, c); b = c; bound(c); } } } } var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0; for (i = 0; i &lt; n; i++) { c = nodes[i]; c.x -= cx; c.y -= cy; cr = Math.max(cr, c.r + Math.sqrt(c.x c.x + c.y c.y)); } node.r = cr; nodes.forEach(d3_layout_packUnlink); } function d3_layout_packLink(node) { node._pack_next = node._pack_prev = node; } function d3_layout_packUnlink(node) { delete node._pack_next; delete node._pack_prev; } function d3_layout_packTransform(node, x, y, k) { var children = node.children; node.x = x += k node.x; node.y = y += k node.y; node.r = k; if (children) { var i = -1, n = children.length; while (++i &lt; n) d3_layout_packTransform(children[i], x, y, k); } } function d3_layout_packPlace(a, b, c) { var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y; if (db &amp;&amp; (dx || dy)) { var da = b.r + c.r, dc = dx dx + dy dy; da = da; db = db; var x = .5 + (db - da) / (2 dc), y = Math.sqrt(Math.max(0, 2 da (db + dc) - (db -= dc) db - da da)) / (2 dc); c.x = a.x + x dx + y dy; c.y = a.y + x dy - y dx; } else { c.x = a.x + db; c.y = a.y; } } d3.layout.tree = function() { var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null; function tree(d, i) { var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0); d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z; d3_layout_hierarchyVisitBefore(root1, secondWalk); if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else { var left = root0, right = root0, bottom = root0; d3_layout_hierarchyVisitBefore(root0, function(node) { if (node.x &lt; left.x) left = node; if (node.x &gt; right.x) right = node; if (node.depth &gt; bottom.depth) bottom = node; }); var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1); d3_layout_hierarchyVisitBefore(root0, function(node) { node.x = (node.x + tx) kx; node.y = node.depth ky; }); } return nodes; } function wrapTree(root0) { var root1 = { A: null, children: [ root0 ] }, queue = [ root1 ], node1; while ((node1 = queue.pop()) != null) { for (var children = node1.children, child, i = 0, n = children.length; i &lt; n; ++i) { queue.push((children[i] = child = { _: children[i], parent: node1, children: (child = children[i].children) &amp;&amp; child.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: i }).a = child); } } return root1.children[0]; } function firstWalk(v) { var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null; if (children.length) { d3_layout_treeShift(v); var midpoint = (children[0].z + children[children.length - 1].z) / 2; if (w) { v.z = w.z + separation(v., w.); v.m = v.z - midpoint; } else { v.z = midpoint; } } else if (w) { v.z = w.z + separation(v., w.); } v.parent.A = apportion(v, w, v.parent.A || siblings[0]); } function secondWalk(v) { v._.x = v.z + v.parent.m; v.m += v.parent.m; } function apportion(v, w, ancestor) { if (w) { var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift; while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim &amp;&amp; vip) { vom = d3_layout_treeLeft(vom); vop = d3_layout_treeRight(vop); vop.a = v; shift = vim.z + sim - vip.z - sip + separation(vim., vip.); if (shift &gt; 0) { d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift); sip += shift; sop += shift; } sim += vim.m; sip += vip.m; som += vom.m; sop += vop.m; } if (vim &amp;&amp; !d3_layout_treeRight(vop)) { vop.t = vim; vop.m += sim - sop; } if (vip &amp;&amp; !d3_layout_treeLeft(vom)) { vom.t = vip; vom.m += sip - som; ancestor = v; } } return ancestor; } function sizeNode(node) { node.x = size[0]; node.y = node.depth size[1]; } tree.separation = function(x) { if (!arguments.length) return separation; separation = x; return tree; }; tree.size = function(x) { if (!arguments.length) return nodeSize ? null : size; nodeSize = (size = x) == null ? sizeNode : null; return tree; }; tree.nodeSize = function(x) { if (!arguments.length) return nodeSize ? size : null; nodeSize = (size = x) == null ? null : sizeNode; return tree; }; return d3_layout_hierarchyRebind(tree, hierarchy); }; function d3_layout_treeSeparation(a, b) { return a.parent == b.parent ? 1 : 2; } function d3_layout_treeLeft(v) { var children = v.children; return children.length ? children[0] : v.t; } function d3_layout_treeRight(v) { var children = v.children, n; return (n = children.length) ? children[n - 1] : v.t; } function d3_layout_treeMove(wm, wp, shift) { var change = shift / (wp.i - wm.i); wp.c -= change; wp.s += shift; wm.c += change; wp.z += shift; wp.m += shift; } function d3_layout_treeShift(v) { var shift = 0, change = 0, children = v.children, i = children.length, w; while (–i &gt;= 0) { w = children[i]; w.z += shift; w.m += shift; shift += w.s + (change += w.c); } } function d3_layout_treeAncestor(vim, v, ancestor) { return vim.a.parent === v.parent ? vim.a : ancestor; } d3.layout.cluster = function() { var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false; function cluster(d, i) { var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0; d3_layout_hierarchyVisitAfter(root, function(node) { var children = node.children; if (children &amp;&amp; children.length) { node.x = d3_layout_clusterX(children); node.y = d3_layout_clusterY(children); } else { node.x = previousNode ? x += separation(node, previousNode) : 0; node.y = 0; previousNode = node; } }); var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2; d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) { node.x = (node.x - root.x) size[0]; node.y = (root.y - node.y) size[1]; } : function(node) { node.x = (node.x - x0) / (x1 - x0) size[0]; node.y = (1 - (root.y ? node.y / root.y : 1)) size[1]; }); return nodes; } cluster.separation = function(x) { if (!arguments.length) return separation; separation = x; return cluster; }; cluster.size = function(x) { if (!arguments.length) return nodeSize ? null : size; nodeSize = (size = x) == null; return cluster; }; cluster.nodeSize = function(x) { if (!arguments.length) return nodeSize ? size : null; nodeSize = (size = x) != null; return cluster; }; return d3_layout_hierarchyRebind(cluster, hierarchy); }; function d3_layout_clusterY(children) { return 1 + d3.max(children, function(child) { return child.y; }); } function d3_layout_clusterX(children) { return children.reduce(function(x, child) { return x + child.x; }, 0) / children.length; } function d3_layout_clusterLeft(node) { var children = node.children; return children &amp;&amp; children.length ? d3_layout_clusterLeft(children[0]) : node; } function d3_layout_clusterRight(node) { var children = node.children, n; return children &amp;&amp; (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node; } d3.layout.treemap = function() { var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = “squarify”, ratio = .5 (1 + Math.sqrt(5)); function scale(children, k) { var i = -1, n = children.length, child, area; while (++i &lt; n) { area = (child = children[i]).value (k &lt; 0 ? 0 : k); child.area = isNaN(area) || area &lt;= 0 ? 0 : area; } } function squarify(node) { var children = node.children; if (children &amp;&amp; children.length) { var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === “slice” ? rect.dx : mode === “dice” ? rect.dy : mode === “slice-dice” ? node.depth &amp; 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n; scale(remaining, rect.dx rect.dy / node.value); row.area = 0; while ((n = remaining.length) &gt; 0) { row.push(child = remaining[n - 1]); row.area += child.area; if (mode !== “squarify” || (score = worst(row, u)) &lt;= best) { remaining.pop(); best = score; } else { row.area -= row.pop().area; position(row, u, rect, false); u = Math.min(rect.dx, rect.dy); row.length = row.area = 0; best = Infinity; } } if (row.length) { position(row, u, rect, true); row.length = row.area = 0; } children.forEach(squarify); } } function stickify(node) { var children = node.children; if (children &amp;&amp; children.length) { var rect = pad(node), remaining = children.slice(), child, row = []; scale(remaining, rect.dx rect.dy / node.value); row.area = 0; while (child = remaining.pop()) { row.push(child); row.area += child.area; if (child.z != null) { position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length); row.length = row.area = 0; } } children.forEach(stickify); } } function worst(row, u) { var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length; while (++i &lt; n) { if (!(r = row[i].area)) continue; if (r &lt; rmin) rmin = r; if (r &gt; rmax) rmax = r; } s = s; u = u; return s ? Math.max(u rmax ratio / s, s / (u rmin ratio)) : Infinity; } function position(row, u, rect, flush) { var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o; if (u == rect.dx) { if (flush || v &gt; rect.dy) v = rect.dy; while (++i &lt; n) { o = row[i]; o.x = x; o.y = y; o.dy = v; x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0); } o.z = true; o.dx += rect.x + rect.dx - x; rect.y += v; rect.dy -= v; } else { if (flush || v &gt; rect.dx) v = rect.dx; while (++i &lt; n) { o = row[i]; o.x = x; o.y = y; o.dx = v; y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0); } o.z = false; o.dy += rect.y + rect.dy - y; rect.x += v; rect.dx -= v; } } function treemap(d) { var nodes = stickies || hierarchy(d), root = nodes[0]; root.x = root.y = 0; if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0; if (stickies) hierarchy.revalue(root); scale([ root ], root.dx root.dy / root.value); (stickies ? stickify : squarify)(root); if (sticky) stickies = nodes; return nodes; } treemap.size = function(x) { if (!arguments.length) return size; size = x; return treemap; }; treemap.padding = function(x) { if (!arguments.length) return padding; function padFunction(node) { var p = x.call(treemap, node, node.depth); return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === “number” ? [ p, p, p, p ] : p); } function padConstant(node) { return d3_layout_treemapPad(node, x); } var type; pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === “function” ? padFunction : type === “number” ? (x = [ x, x, x, x ], padConstant) : padConstant; return treemap; }; treemap.round = function(x) { if (!arguments.length) return round != Number; round = x ? Math.round : Number; return treemap; }; treemap.sticky = function(x) { if (!arguments.length) return sticky; sticky = x; stickies = null; return treemap; }; treemap.ratio = function(x) { if (!arguments.length) return ratio; ratio = x; return treemap; }; treemap.mode = function(x) { if (!arguments.length) return mode; mode = x + “”; return treemap; }; return d3_layout_hierarchyRebind(treemap, hierarchy); }; function d3_layout_treemapPadNull(node) { return { x: node.x, y: node.y, dx: node.dx, dy: node.dy }; } function d3_layout_treemapPad(node, padding) { var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2]; if (dx &lt; 0) { x += dx / 2; dx = 0; } if (dy &lt; 0) { y += dy / 2; dy = 0; } return { x: x, y: y, dx: dx, dy: dy }; } d3.random = { normal: function(µ, σ) { var n = arguments.length; if (n &lt; 2) σ = 1; if (n &lt; 1) µ = 0; return function() { var x, y, r; do { x = Math.random() 2 - 1; y = Math.random() 2 - 1; r = x x + y y; } while (!r || r &gt; 1); return µ + σ x Math.sqrt(-2 Math.log(r) / r); }; }, logNormal: function() { var random = d3.random.normal.apply(d3, arguments); return function() { return Math.exp(random()); }; }, bates: function(m) { var random = d3.random.irwinHall(m); return function() { return random() / m; }; }, irwinHall: function(m) { return function() { for (var s = 0, j = 0; j &lt; m; j++) s += Math.random(); return s; }; } }; d3.scale = {}; function d3_scaleExtent(domain) { var start = domain[0], stop = domain[domain.length - 1]; return start &lt; stop ? [ start, stop ] : [ stop, start ]; } function d3_scaleRange(scale) { return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range()); } function d3_scale_bilinear(domain, range, uninterpolate, interpolate) { var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]); return function(x) { return i(u(x)); }; } function d3_scale_nice(domain, nice) { var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx; if (x1 &lt; x0) { dx = i0, i0 = i1, i1 = dx; dx = x0, x0 = x1, x1 = dx; } domain[i0] = nice.floor(x0); domain[i1] = nice.ceil(x1); return domain; } function d3_scale_niceStep(step) { return step ? { floor: function(x) { return Math.floor(x / step) step; }, ceil: function(x) { return Math.ceil(x / step) step; } } : d3_scale_niceIdentity; } var d3_scale_niceIdentity = { floor: d3_identity, ceil: d3_identity }; function d3_scale_polylinear(domain, range, uninterpolate, interpolate) { var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1; if (domain[k] &lt; domain[0]) { domain = domain.slice().reverse(); range = range.slice().reverse(); } while (++j &lt;= k) { u.push(uninterpolate(domain[j - 1], domain[j])); i.push(interpolate(range[j - 1], range[j])); } return function(x) { var j = d3.bisect(domain, x, 1, k) - 1; return ij); }; } d3.scale.linear = function() { return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false); }; function d3_scale_linear(domain, range, interpolate, clamp) { var output, input; function rescale() { var linear = Math.min(domain.length, range.length) &gt; 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber; output = linear(domain, range, uninterpolate, interpolate); input = linear(range, domain, uninterpolate, d3_interpolate); return scale; } function scale(x) { return output(x); } scale.invert = function(y) { return input(y); }; scale.domain = function(x) { if (!arguments.length) return domain; domain = x.map(Number); return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.rangeRound = function(x) { return scale.range(x).interpolate(d3_interpolateRound); }; scale.clamp = function(x) { if (!arguments.length) return clamp; clamp = x; return rescale(); }; scale.interpolate = function(x) { if (!arguments.length) return interpolate; interpolate = x; return rescale(); }; scale.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; scale.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; scale.nice = function(m) { d3_scale_linearNice(domain, m); return rescale(); }; scale.copy = function() { return d3_scale_linear(domain, range, interpolate, clamp); }; return rescale(); } function d3_scale_linearRebind(scale, linear) { return d3.rebind(scale, linear, “range”, “rangeRound”, “interpolate”, “clamp”); } function d3_scale_linearNice(domain, m) { d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2])); d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2])); return domain; } function d3_scale_linearTickRange(domain, m) { if (m == null) m = 10; var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span step; if (err &lt;= .15) step = 10; else if (err &lt;= .35) step = 5; else if (err &lt;= .75) step = 2; extent[0] = Math.ceil(extent[0] / step) step; extent[1] = Math.floor(extent[1] / step) step + step .5; extent[2] = step; return extent; } function d3_scale_linearTicks(domain, m) { return d3.range.apply(d3, d3_scale_linearTickRange(domain, m)); } function d3_scale_linearTickFormat(domain, m, format) { var range = d3_scale_linearTickRange(domain, m); if (format) { var match = d3_format_re.exec(format); match.shift(); if (match[8] === “s”) { var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1]))); if (!match[7]) match[7] = “.” + d3_scale_linearPrecision(prefix.scale(range[2])); match[8] = “f”; format = d3.format(match.join(“”)); return function(d) { return format(prefix.scale(d)) + prefix.symbol; }; } if (!match[7]) match[7] = “.” + d3_scale_linearFormatPrecision(match[8], range); format = match.join(“”); } else { format = “,.” + d3_scale_linearPrecision(range[2]) + “f”; } return d3.format(format); } var d3_scale_linearFormatSignificant = { s: 1, g: 1, p: 1, r: 1, e: 1 }; function d3_scale_linearPrecision(value) { return -Math.floor(Math.log(value) / Math.LN10 + .01); } function d3_scale_linearFormatPrecision(type, range) { var p = d3_scale_linearPrecision(range[2]); return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== “e”) : p - (type === “%”) 2; } d3.scale.log = function() { return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]); }; function d3_scale_log(linear, base, positive, domain) { function log(x) { return (positive ? Math.log(x &lt; 0 ? 0 : x) : -Math.log(x &gt; 0 ? 0 : -x)) / Math.log(base); } function pow(x) { return positive ? Math.pow(base, x) : -Math.pow(base, -x); } function scale(x) { return linear(log(x)); } scale.invert = function(x) { return pow(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return domain; positive = x[0] &gt;= 0; linear.domain((domain = x.map(Number)).map(log)); return scale; }; scale.base = function() { if (!arguments.length) return base; base = +; linear.domain(domain.map(log)); return scale; }; scale.nice = function() { var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative); linear.domain(niced); domain = niced.map(pow); return scale; }; scale.ticks = function() { var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base; if (isFinite(j - i)) { if (positive) { for (;i &lt; j; i++) for (var k = 1; k &lt; n; k++) ticks.push(pow(i) k); ticks.push(pow(i)); } else { ticks.push(pow(i)); for (;i++ &lt; j; ) for (var k = n - 1; k &gt; 0; k–) ticks.push(pow(i) k); } for (i = 0; ticks[i] &lt; u; i++) {} for (j = ticks.length; ticks[j - 1] &gt; v; j–) {} ticks = ticks.slice(i, j); } return ticks; }; scale.tickFormat = function(n, format) { if (!arguments.length) return d3_scale_logFormat; if (arguments.length &lt; 2) format = d3_scale_logFormat; else if (typeof format !== “function”) format = d3.format(format); var k = Math.max(1, base n / scale.ticks().length); return function(d) { var i = d / pow(Math.round(log(d))); if (i base &lt; base - .5) i = base; return i &lt;= k ? format(d) : “”; }; }; scale.copy = function() { return d3_scale_log(linear.copy(), base, positive, domain); }; return d3_scale_linearRebind(scale, linear); } var d3_scale_logFormat = d3.format(“.0e”), d3_scale_logNiceNegative = { floor: function(x) { return -Math.ceil(-x); }, ceil: function(x) { return -Math.floor(-x); } }; d3.scale.pow = function() { return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]); }; function d3_scale_pow(linear, exponent, domain) { var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent); function scale(x) { return linear(powp(x)); } scale.invert = function(x) { return powb(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return domain; linear.domain((domain = x.map(Number)).map(powp)); return scale; }; scale.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; scale.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; scale.nice = function(m) { return scale.domain(d3_scale_linearNice(domain, m)); }; scale.exponent = function(x) { if (!arguments.length) return exponent; powp = d3_scale_powPow(exponent = x); powb = d3_scale_powPow(1 / exponent); linear.domain(domain.map(powp)); return scale; }; scale.copy = function() { return d3_scale_pow(linear.copy(), exponent, domain); }; return d3_scale_linearRebind(scale, linear); } function d3_scale_powPow(e) { return function(x) { return x &lt; 0 ? -Math.pow(-x, e) : Math.pow(x, e); }; } d3.scale.sqrt = function() { return d3.scale.pow().exponent(.5); }; d3.scale.ordinal = function() { return d3_scale_ordinal([], { t: “range”, a: [ [] ] }); }; function d3_scale_ordinal(domain, ranger) { var index, range, rangeBand; function scale(x) { return range[((index.get(x) || (ranger.t === “range” ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length]; } function steps(start, step) { return d3.range(domain.length).map(function(i) { return start + step i; }); } scale.domain = function(x) { if (!arguments.length) return domain; domain = []; index = new d3_Map(); var i = -1, n = x.length, xi; while (++i &lt; n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi)); return scale[ranger.t].apply(scale, ranger.a); }; scale.range = function(x) { if (!arguments.length) return range; range = x; rangeBand = 0; ranger = { t: “range”, a: arguments }; return scale; }; scale.rangePoints = function(x, padding) { if (arguments.length &lt; 2) padding = 0; var start = x[0], stop = x[1], step = domain.length &lt; 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding); range = steps(start + step padding / 2, step); rangeBand = 0; ranger = { t: “rangePoints”, a: arguments }; return scale; }; scale.rangeRoundPoints = function(x, padding) { if (arguments.length &lt; 2) padding = 0; var start = x[0], stop = x[1], step = domain.length &lt; 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0; range = steps(start + Math.round(step padding / 2 + (stop - start - (domain.length - 1 + padding) step) / 2), step); rangeBand = 0; ranger = { t: “rangeRoundPoints”, a: arguments }; return scale; }; scale.rangeBands = function(x, padding, outerPadding) { if (arguments.length &lt; 2) padding = 0; if (arguments.length &lt; 3) outerPadding = padding; var reverse = x[1] &lt; x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 outerPadding); range = steps(start + step outerPadding, step); if (reverse) range.reverse(); rangeBand = step (1 - padding); ranger = { t: “rangeBands”, a: arguments }; return scale; }; scale.rangeRoundBands = function(x, padding, outerPadding) { if (arguments.length &lt; 2) padding = 0; if (arguments.length &lt; 3) outerPadding = padding; var reverse = x[1] &lt; x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 outerPadding)); range = steps(start + Math.round((stop - start - (domain.length - padding) step) / 2), step); if (reverse) range.reverse(); rangeBand = Math.round(step (1 - padding)); ranger = { t: “rangeRoundBands”, a: arguments }; return scale; }; scale.rangeBand = function() { return rangeBand; }; scale.rangeExtent = function() { return d3_scaleExtent(ranger.a[0]); }; scale.copy = function() { return d3_scale_ordinal(domain, ranger); }; return scale.domain(domain); } d3.scale.category10 = function() { return d3.scale.ordinal().range(d3_category10); }; d3.scale.category20 = function() { return d3.scale.ordinal().range(d3_category20); }; d3.scale.category20b = function() { return d3.scale.ordinal().range(d3_category20b); }; d3.scale.category20c = function() { return d3.scale.ordinal().range(d3_category20c); }; var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString); var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString); var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString); var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString); d3.scale.quantile = function() { return d3_scale_quantile([], []); }; function d3_scale_quantile(domain, range) { var thresholds; function rescale() { var k = 0, q = range.length; thresholds = []; while (++k &lt; q) thresholds[k - 1] = d3.quantile(domain, k / q); return scale; } function scale(x) { if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)]; } scale.domain = function(x) { if (!arguments.length) return domain; domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending); return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.quantiles = function() { return thresholds; }; scale.invertExtent = function(y) { y = range.indexOf(y); return y &lt; 0 ? [ NaN, NaN ] : [ y &gt; 0 ? thresholds[y - 1] : domain[0], y &lt; thresholds.length ? thresholds[y] : domain[domain.length - 1] ]; }; scale.copy = function() { return d3_scale_quantile(domain, range); }; return rescale(); } d3.scale.quantize = function() { return d3_scale_quantize(0, 1, [ 0, 1 ]); }; function d3_scale_quantize(x0, x1, range) { var kx, i; function scale(x) { return range[Math.max(0, Math.min(i, Math.floor(kx (x - x0))))]; } function rescale() { kx = range.length / (x1 - x0); i = range.length - 1; return scale; } scale.domain = function(x) { if (!arguments.length) return [ x0, x1 ]; x0 = +x[0]; x1 = +x[x.length - 1]; return rescale(); }; scale.range = function(x) { if (!arguments.length) return range; range = x; return rescale(); }; scale.invertExtent = function(y) { y = range.indexOf(y); y = y &lt; 0 ? NaN : y / kx + x0; return [ y, y + 1 / kx ]; }; scale.copy = function() { return d3_scale_quantize(x0, x1, range); }; return rescale(); } d3.scale.threshold = function() { return d3_scale_threshold([ .5 ], [ 0, 1 ]); }; function d3_scale_threshold(domain, range) { function scale(x) { if (x &lt;= x) return range[d3.bisect(domain, x)]; } scale.domain = function(_) { if (!arguments.length) return domain; domain = ; return scale; }; scale.range = function() { if (!arguments.length) return range; range = _; return scale; }; scale.invertExtent = function(y) { y = range.indexOf(y); return [ domain[y - 1], domain[y] ]; }; scale.copy = function() { return d3_scale_threshold(domain, range); }; return scale; } d3.scale.identity = function() { return d3_scale_identity([ 0, 1 ]); }; function d3_scale_identity(domain) { function identity(x) { return +x; } identity.invert = identity; identity.domain = identity.range = function(x) { if (!arguments.length) return domain; domain = x.map(identity); return identity; }; identity.ticks = function(m) { return d3_scale_linearTicks(domain, m); }; identity.tickFormat = function(m, format) { return d3_scale_linearTickFormat(domain, m, format); }; identity.copy = function() { return d3_scale_identity(domain); }; return identity; } d3.svg = {}; function d3_zero() { return 0; } d3.svg.arc = function() { var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle; function arc() { var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 &gt; a1 ? 0 : 1; if (r1 &lt; r0) rc = r1, r1 = r0, r0 = rc; if (da &gt;= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : “”) + “Z”; var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = []; if (ap = (+padAngle.apply(this, arguments) || 0) / 2) { rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 r0 + r1 r1) : +padRadius.apply(this, arguments); if (!cw) p1 = -1; if (r1) p1 = d3_asin(rp / r1 Math.sin(ap)); if (r0) p0 = d3_asin(rp / r0 Math.sin(ap)); } if (r1) { x0 = r1 Math.cos(a0 + p1); y0 = r1 Math.sin(a0 + p1); x1 = r1 Math.cos(a1 - p1); y1 = r1 Math.sin(a1 - p1); var l1 = Math.abs(a1 - a0 - 2 p1) &lt;= π ? 0 : 1; if (p1 &amp;&amp; d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) { var h1 = (a0 + a1) / 2; x0 = r1 Math.cos(h1); y0 = r1 Math.sin(h1); x1 = y1 = null; } } else { x0 = y0 = 0; } if (r0) { x2 = r0 Math.cos(a1 - p0); y2 = r0 Math.sin(a1 - p0); x3 = r0 Math.cos(a0 + p0); y3 = r0 Math.sin(a0 + p0); var l0 = Math.abs(a0 - a1 + 2 p0) &lt;= π ? 0 : 1; if (p0 &amp;&amp; d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) { var h0 = (a0 + a1) / 2; x2 = r0 Math.cos(h0); y2 = r0 Math.sin(h0); x3 = y3 = null; } } else { x2 = y2 = 0; } if (da &gt; ε &amp;&amp; (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) &gt; .001) { cr = r0 &lt; r1 ^ cw ? 0 : 1; var rc1 = rc, rc0 = rc; if (da &lt; π) { var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax bx + ay by) / (Math.sqrt(ax ax + ay ay) Math.sqrt(bx bx + by by))) / 2), lc = Math.sqrt(oc[0] oc[0] + oc[1] oc[1]); rc0 = Math.min(rc, (r0 - lc) / (kc - 1)); rc1 = Math.min(rc, (r1 - lc) / (kc + 1)); } if (x1 != null) { var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw); if (rc === rc1) { path.push(“M”, t30[0], “A”, rc1, “,”, rc1, “ 0 0,”, cr, “ “, t30[1], “A”, r1, “,”, r1, “ 0 “, 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), “,”, cw, “ “, t12[1], “A”, rc1, “,”, rc1, “ 0 0,”, cr, “ “, t12[0]); } else { path.push(“M”, t30[0], “A”, rc1, “,”, rc1, “ 0 1,”, cr, “ “, t12[0]); } } else { path.push(“M”, x0, “,”, y0); } if (x3 != null) { var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw); if (rc === rc0) { path.push(“L”, t21[0], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t21[1], “A”, r0, “,”, r0, “ 0 “, cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), “,”, 1 - cw, “ “, t03[1], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t03[0]); } else { path.push(“L”, t21[0], “A”, rc0, “,”, rc0, “ 0 0,”, cr, “ “, t03[0]); } } else { path.push(“L”, x2, “,”, y2); } } else { path.push(“M”, x0, “,”, y0); if (x1 != null) path.push(“A”, r1, “,”, r1, “ 0 “, l1, “,”, cw, “ “, x1, “,”, y1); path.push(“L”, x2, “,”, y2); if (x3 != null) path.push(“A”, r0, “,”, r0, “ 0 “, l0, “,”, 1 - cw, “ “, x3, “,”, y3); } path.push(“Z”); return path.join(“”); } function circleSegment(r1, cw) { return “M0,” + r1 + “A” + r1 + “,” + r1 + “ 0 1,” + cw + “ 0,” + -r1 + “A” + r1 + “,” + r1 + “ 0 1,” + cw + “ 0,” + r1; } arc.innerRadius = function(v) { if (!arguments.length) return innerRadius; innerRadius = d3_functor(v); return arc; }; arc.outerRadius = function(v) { if (!arguments.length) return outerRadius; outerRadius = d3_functor(v); return arc; }; arc.cornerRadius = function(v) { if (!arguments.length) return cornerRadius; cornerRadius = d3_functor(v); return arc; }; arc.padRadius = function(v) { if (!arguments.length) return padRadius; padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v); return arc; }; arc.startAngle = function(v) { if (!arguments.length) return startAngle; startAngle = d3_functor(v); return arc; }; arc.endAngle = function(v) { if (!arguments.length) return endAngle; endAngle = d3_functor(v); return arc; }; arc.padAngle = function(v) { if (!arguments.length) return padAngle; padAngle = d3_functor(v); return arc; }; arc.centroid = function() { var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ; return [ Math.cos(a) r, Math.sin(a) r ]; }; return arc; }; var d3_svg_arcAuto = “auto”; function d3_svg_arcInnerRadius(d) { return d.innerRadius; } function d3_svg_arcOuterRadius(d) { return d.outerRadius; } function d3_svg_arcStartAngle(d) { return d.startAngle; } function d3_svg_arcEndAngle(d) { return d.endAngle; } function d3_svg_arcPadAngle(d) { return d &amp;&amp; d.padAngle; } function d3_svg_arcSweep(x0, y0, x1, y1) { return (x0 - x1) y0 - (y0 - y1) x0 &gt; 0 ? 0 : 1; } function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) { var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 x01 + y01 y01), ox = lo y01, oy = -lo x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx dx + dy dy, r = r1 - rc, D = x1 y2 - x2 y1, d = (dy &lt; 0 ? -1 : 1) Math.sqrt(Math.max(0, r r d2 - D D)), cx0 = (D dy - dx d) / d2, cy0 = (-D dx - dy d) / d2, cx1 = (D dy + dx d) / d2, cy1 = (-D dx + dy d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3; if (dx0 dx0 + dy0 dy0 &gt; dx1 dx1 + dy1 dy1) cx0 = cx1, cy0 = cy1; return [ [ cx0 - ox, cy0 - oy ], [ cx0 r1 / r, cy0 r1 / r ] ]; } function d3_svg_line(projection) { var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7; function line(data) { var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y); function segment() { segments.push(“M”, interpolate(projection(points), tension)); } while (++i &lt; n) { if (defined.call(this, d = data[i], i)) { points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]); } else if (points.length) { segment(); points = []; } } if (points.length) segment(); return segments.length ? segments.join(“”) : null; } line.x = function(_) { if (!arguments.length) return x; x = ; return line; }; line.y = function() { if (!arguments.length) return y; y = ; return line; }; line.defined = function() { if (!arguments.length) return defined; defined = ; return line; }; line.interpolate = function() { if (!arguments.length) return interpolateKey; if (typeof _ === “function”) interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key; return line; }; line.tension = function(_) { if (!arguments.length) return tension; tension = _; return line; }; return line; } d3.svg.line = function() { return d3_svg_line(d3_identity); }; var d3_svg_lineInterpolators = d3.map({ linear: d3_svg_lineLinear, “linear-closed”: d3_svg_lineLinearClosed, step: d3_svg_lineStep, “step-before”: d3_svg_lineStepBefore, “step-after”: d3_svg_lineStepAfter, basis: d3_svg_lineBasis, “basis-open”: d3_svg_lineBasisOpen, “basis-closed”: d3_svg_lineBasisClosed, bundle: d3_svg_lineBundle, cardinal: d3_svg_lineCardinal, “cardinal-open”: d3_svg_lineCardinalOpen, “cardinal-closed”: d3_svg_lineCardinalClosed, monotone: d3_svg_lineMonotone }); d3_svg_lineInterpolators.forEach(function(key, value) { value.key = key; value.closed = /-closed$/.test(key); }); function d3_svg_lineLinear(points) { return points.length &gt; 1 ? points.join(“L”) : points + “Z”; } function d3_svg_lineLinearClosed(points) { return points.join(“L”) + “Z”; } function d3_svg_lineStep(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“H”, (p[0] + (p = points[i])[0]) / 2, “V”, p[1]); if (n &gt; 1) path.push(“H”, p[0]); return path.join(“”); } function d3_svg_lineStepBefore(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“V”, (p = points[i])[1], “H”, p[0]); return path.join(“”); } function d3_svg_lineStepAfter(points) { var i = 0, n = points.length, p = points[0], path = [ p[0], “,”, p[1] ]; while (++i &lt; n) path.push(“H”, (p = points[i])[0], “V”, p[1]); return path.join(“”); } function d3_svg_lineCardinalOpen(points, tension) { return points.length &lt; 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension)); } function d3_svg_lineCardinalClosed(points, tension) { return points.length &lt; 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension)); } function d3_svg_lineCardinal(points, tension) { return points.length &lt; 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension)); } function d3_svg_lineHermite(points, tangents) { if (tangents.length &lt; 1 || points.length != tangents.length &amp;&amp; points.length != tangents.length + 2) { return d3_svg_lineLinear(points); } var quad = points.length != tangents.length, path = “”, p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1; if (quad) { path += “Q” + (p[0] - t0[0] 2 / 3) + “,” + (p[1] - t0[1] 2 / 3) + “,” + p[0] + “,” + p[1]; p0 = points[1]; pi = 2; } if (tangents.length &gt; 1) { t = tangents[1]; p = points[pi]; pi++; path += “C” + (p0[0] + t0[0]) + “,” + (p0[1] + t0[1]) + “,” + (p[0] - t[0]) + “,” + (p[1] - t[1]) + “,” + p[0] + “,” + p[1]; for (var i = 2; i &lt; tangents.length; i++, pi++) { p = points[pi]; t = tangents[i]; path += “S” + (p[0] - t[0]) + “,” + (p[1] - t[1]) + “,” + p[0] + “,” + p[1]; } } if (quad) { var lp = points[pi]; path += “Q” + (p[0] + t[0] 2 / 3) + “,” + (p[1] + t[1] 2 / 3) + “,” + lp[0] + “,” + lp[1]; } return path; } function d3_svg_lineCardinalTangents(points, tension) { var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length; while (++i &lt; n) { p0 = p1; p1 = p2; p2 = points[i]; tangents.push([ a (p2[0] - p0[0]), a (p2[1] - p0[1]) ]); } return tangents; } function d3_svg_lineBasis(points) { if (points.length &lt; 3) return d3_svg_lineLinear(points); var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, “,”, y0, “L”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ]; points.push(points[n - 1]); while (++i &lt;= n) { pi = points[i]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } points.pop(); path.push(“L”, pi); return path.join(“”); } function d3_svg_lineBasisOpen(points) { if (points.length &lt; 4) return d3_svg_lineLinear(points); var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ]; while (++i &lt; 3) { pi = points[i]; px.push(pi[0]); py.push(pi[1]); } path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + “,” + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)); –i; while (++i &lt; n) { pi = points[i]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } return path.join(“”); } function d3_svg_lineBasisClosed(points) { var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = []; while (++i &lt; 4) { pi = points[i % n]; px.push(pi[0]); py.push(pi[1]); } path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ]; –i; while (++i &lt; m) { pi = points[i % n]; px.shift(); px.push(pi[0]); py.shift(); py.push(pi[1]); d3_svg_lineBasisBezier(path, px, py); } return path.join(“”); } function d3_svg_lineBundle(points, tension) { var n = points.length - 1; if (n) { var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t; while (++i &lt;= n) { p = points[i]; t = i / n; p[0] = tension p[0] + (1 - tension) (x0 + t dx); p[1] = tension p[1] + (1 - tension) (y0 + t dy); } } return d3_svg_lineBasis(points); } function d3_svg_lineDot4(a, b) { return a[0] b[0] + a[1] b[1] + a[2] b[2] + a[3] b[3]; } var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ]; function d3_svg_lineBasisBezier(path, x, y) { path.push(“C”, d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), “,”, d3_svg_lineDot4(d3_svg_lineBasisBezier3, y)); } function d3_svg_lineSlope(p0, p1) { return (p1[1] - p0[1]) / (p1[0] - p0[0]); } function d3_svg_lineFiniteDifferences(points) { var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1); while (++i &lt; j) { m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2; } m[i] = d; return m; } function d3_svg_lineMonotoneTangents(points) { var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1; while (++i &lt; j) { d = d3_svg_lineSlope(points[i], points[i + 1]); if (abs(d) &lt; ε) { m[i] = m[i + 1] = 0; } else { a = m[i] / d; b = m[i + 1] / d; s = a a + b b; if (s &gt; 9) { s = d 3 / Math.sqrt(s); m[i] = s a; m[i + 1] = s b; } } } i = -1; while (++i &lt;= j) { s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 (1 + m[i] m[i])); tangents.push([ s || 0, m[i] s || 0 ]); } return tangents; } function d3_svg_lineMonotone(points) { return points.length &lt; 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points)); } d3.svg.line.radial = function() { var line = d3_svg_line(d3_svg_lineRadial); line.radius = line.x, delete line.x; line.angle = line.y, delete line.y; return line; }; function d3_svg_lineRadial(points) { var point, i = -1, n = points.length, r, a; while (++i &lt; n) { point = points[i]; r = point[0]; a = point[1] - halfπ; point[0] = r Math.cos(a); point[1] = r Math.sin(a); } return points; } function d3_svg_area(projection) { var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = “L”, tension = .7; function area(data) { var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() { return x; } : d3_functor(x1), fy1 = y0 === y1 ? function() { return y; } : d3_functor(y1), x, y; function segment() { segments.push(“M”, interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), “Z”); } while (++i &lt; n) { if (defined.call(this, d = data[i], i)) { points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]); points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]); } else if (points0.length) { segment(); points0 = []; points1 = []; } } if (points0.length) segment(); return segments.length ? segments.join(“”) : null; } area.x = function(_) { if (!arguments.length) return x1; x0 = x1 = ; return area; }; area.x0 = function() { if (!arguments.length) return x0; x0 = ; return area; }; area.x1 = function() { if (!arguments.length) return x1; x1 = ; return area; }; area.y = function() { if (!arguments.length) return y1; y0 = y1 = ; return area; }; area.y0 = function() { if (!arguments.length) return y0; y0 = ; return area; }; area.y1 = function() { if (!arguments.length) return y1; y1 = ; return area; }; area.defined = function() { if (!arguments.length) return defined; defined = ; return area; }; area.interpolate = function() { if (!arguments.length) return interpolateKey; if (typeof _ === “function”) interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key; interpolateReverse = interpolate.reverse || interpolate; L = interpolate.closed ? “M” : “L”; return area; }; area.tension = function(_) { if (!arguments.length) return tension; tension = _; return area; }; return area; } d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter; d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore; d3.svg.area = function() { return d3_svg_area(d3_identity); }; d3.svg.area.radial = function() { var area = d3_svg_area(d3_svg_lineRadial); area.radius = area.x, delete area.x; area.innerRadius = area.x0, delete area.x0; area.outerRadius = area.x1, delete area.x1; area.angle = area.y, delete area.y; area.startAngle = area.y0, delete area.y0; area.endAngle = area.y1, delete area.y1; return area; }; d3.svg.chord = function() { var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle; function chord(d, i) { var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i); return “M” + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + “Z”; } function subgroup(self, f, d, i) { var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ; return { r: r, a0: a0, a1: a1, p0: [ r Math.cos(a0), r Math.sin(a0) ], p1: [ r Math.cos(a1), r Math.sin(a1) ] }; } function equals(a, b) { return a.a0 == b.a0 &amp;&amp; a.a1 == b.a1; } function arc(r, p, a) { return “A” + r + “,” + r + “ 0 “ + +(a &gt; π) + “,1 “ + p; } function curve(r0, p0, r1, p1) { return “Q 0,0 “ + p1; } chord.radius = function(v) { if (!arguments.length) return radius; radius = d3_functor(v); return chord; }; chord.source = function(v) { if (!arguments.length) return source; source = d3_functor(v); return chord; }; chord.target = function(v) { if (!arguments.length) return target; target = d3_functor(v); return chord; }; chord.startAngle = function(v) { if (!arguments.length) return startAngle; startAngle = d3_functor(v); return chord; }; chord.endAngle = function(v) { if (!arguments.length) return endAngle; endAngle = d3_functor(v); return chord; }; return chord; }; function d3_svg_chordRadius(d) { return d.radius; } d3.svg.diagonal = function() { var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection; function diagonal(d, i) { var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, { x: p0.x, y: m }, { x: p3.x, y: m }, p3 ]; p = p.map(projection); return “M” + p[0] + “C” + p[1] + “ “ + p[2] + “ “ + p[3]; } diagonal.source = function(x) { if (!arguments.length) return source; source = d3_functor(x); return diagonal; }; diagonal.target = function(x) { if (!arguments.length) return target; target = d3_functor(x); return diagonal; }; diagonal.projection = function(x) { if (!arguments.length) return projection; projection = x; return diagonal; }; return diagonal; }; function d3_svg_diagonalProjection(d) { return [ d.x, d.y ]; } d3.svg.diagonal.radial = function() { var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection; diagonal.projection = function(x) { return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection; }; return diagonal; }; function d3_svg_diagonalRadialProjection(projection) { return function() { var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ; return [ r Math.cos(a), r Math.sin(a) ]; }; } d3.svg.symbol = function() { var type = d3_svg_symbolType, size = d3_svg_symbolSize; function symbol(d, i) { return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i)); } symbol.type = function(x) { if (!arguments.length) return type; type = d3_functor(x); return symbol; }; symbol.size = function(x) { if (!arguments.length) return size; size = d3_functor(x); return symbol; }; return symbol; }; function d3_svg_symbolSize() { return 64; } function d3_svg_symbolType() { return “circle”; } function d3_svg_symbolCircle(size) { var r = Math.sqrt(size / π); return “M0,” + r + “A” + r + “,” + r + “ 0 1,1 0,” + -r + “A” + r + “,” + r + “ 0 1,1 0,” + r + “Z”; } var d3_svg_symbols = d3.map({ circle: d3_svg_symbolCircle, cross: function(size) { var r = Math.sqrt(size / 5) / 2; return “M” + -3 r + “,” + -r + “H” + -r + “V” + -3 r + “H” + r + “V” + -r + “H” + 3 r + “V” + r + “H” + r + “V” + 3 r + “H” + -r + “V” + r + “H” + -3 r + “Z”; }, diamond: function(size) { var ry = Math.sqrt(size / (2 d3_svg_symbolTan30)), rx = ry d3_svg_symbolTan30; return “M0,” + -ry + “L” + rx + “,0” + “ 0,” + ry + “ “ + -rx + “,0” + “Z”; }, square: function(size) { var r = Math.sqrt(size) / 2; return “M” + -r + “,” + -r + “L” + r + “,” + -r + “ “ + r + “,” + r + “ “ + -r + “,” + r + “Z”; }, “triangle-down”: function(size) { var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx d3_svg_symbolSqrt3 / 2; return “M0,” + ry + “L” + rx + “,” + -ry + “ “ + -rx + “,” + -ry + “Z”; }, “triangle-up”: function(size) { var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx d3_svg_symbolSqrt3 / 2; return “M0,” + -ry + “L” + rx + “,” + ry + “ “ + -rx + “,” + ry + “Z”; } }); d3.svg.symbolTypes = d3_svg_symbols.keys(); var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 d3_radians); d3_selectionPrototype.transition = function(name) { var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || { time: Date.now(), ease: d3_ease_cubicInOut, delay: 0, duration: 250 }; for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) d3_transitionNode(node, i, ns, id, transition); subgroup.push(node); } } return d3_transition(subgroups, ns, id); }; d3_selectionPrototype.interrupt = function(name) { return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name))); }; var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace()); function d3_selection_interruptNS(ns) { return function() { var lock, activeId, active; if ((lock = this[ns]) &amp;&amp; (active = lock[activeId = lock.active])) { active.timer.c = null; active.timer.t = NaN; if (–lock.count) delete lock[activeId]; else delete this[ns]; lock.active += .5; active.event &amp;&amp; active.event.interrupt.call(this, this.data, active.index); } }; } function d3_transition(groups, ns, id) { d3_subclass(groups, d3_transitionPrototype); groups.namespace = ns; groups.id = id; return groups; } var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit; d3_transitionPrototype.call = d3_selectionPrototype.call; d3_transitionPrototype.empty = d3_selectionPrototype.empty; d3_transitionPrototype.node = d3_selectionPrototype.node; d3_transitionPrototype.size = d3_selectionPrototype.size; d3.transition = function(selection, name) { return selection &amp;&amp; selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection); }; d3.transition.prototype = d3_transitionPrototype; d3_transitionPrototype.select = function(selector) { var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { subgroups.push(subgroup = []); for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if ((node = group[i]) &amp;&amp; (subnode = selector.call(node, node.data, i, j))) { if (“data“ in node) subnode.data = node.data; d3_transitionNode(subnode, i, ns, id, node[ns][id]); subgroup.push(subnode); } else { subgroup.push(null); } } } return d3_transition(subgroups, ns, id); }; d3_transitionPrototype.selectAll = function(selector) { var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j &lt; m; ) { for (var group = this[j], i = -1, n = group.length; ++i &lt; n; ) { if (node = group[i]) { transition = node[ns][id]; subnodes = selector.call(node, node.data, i, j); subgroups.push(subgroup = []); for (var k = -1, o = subnodes.length; ++k &lt; o; ) { if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition); subgroup.push(subnode); } } } } return d3_transition(subgroups, ns, id); }; d3_transitionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== “function”) filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { if ((node = group[i]) &amp;&amp; filter.call(node, node.data, i, j)) { subgroup.push(node); } } } return d3_transition(subgroups, this.namespace, this.id); }; d3_transitionPrototype.tween = function(name, tween) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 2) return this.node()[ns][id].tween.get(name); return d3_selection_each(this, tween == null ? function(node) { node[ns][id].tween.remove(name); } : function(node) { node[ns][id].tween.set(name, tween); }); }; function d3_transition_tween(groups, name, value, tween) { var id = groups.id, ns = groups.namespace; return d3_selection_each(groups, typeof value === “function” ? function(node, i, j) { node[ns][id].tween.set(name, tween(value.call(node, node.data, i, j))); } : (value = tween(value), function(node) { node[ns][id].tween.set(name, value); })); } d3_transitionPrototype.attr = function(nameNS, value) { if (arguments.length &lt; 2) { for (value in nameNS) this.attr(value, nameNS[value]); return this; } var interpolate = nameNS == “transform” ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrTween(b) { return b == null ? attrNull : (b += “”, function() { var a = this.getAttribute(name), i; return a !== b &amp;&amp; (i = interpolate(a, b), function(t) { this.setAttribute(name, i(t)); }); }); } function attrTweenNS(b) { return b == null ? attrNullNS : (b += “”, function() { var a = this.getAttributeNS(name.space, name.local), i; return a !== b &amp;&amp; (i = interpolate(a, b), function(t) { this.setAttributeNS(name.space, name.local, i(t)); }); }); } return d3_transition_tween(this, “attr.” + nameNS, value, name.local ? attrTweenNS : attrTween); }; d3_transitionPrototype.attrTween = function(nameNS, tween) { var name = d3.ns.qualify(nameNS); function attrTween(d, i) { var f = tween.call(this, d, i, this.getAttribute(name)); return f &amp;&amp; function(t) { this.setAttribute(name, f(t)); }; } function attrTweenNS(d, i) { var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local)); return f &amp;&amp; function(t) { this.setAttributeNS(name.space, name.local, f(t)); }; } return this.tween(“attr.” + nameNS, name.local ? attrTweenNS : attrTween); }; d3_transitionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n &lt; 3) { if (typeof name !== “string”) { if (n &lt; 2) value = “”; for (priority in name) this.style(priority, name[priority], value); return this; } priority = “”; } function styleNull() { this.style.removeProperty(name); } function styleString(b) { return b == null ? styleNull : (b += “”, function() { var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i; return a !== b &amp;&amp; (i = d3_interpolate(a, b), function(t) { this.style.setProperty(name, i(t), priority); }); }); } return d3_transition_tween(this, “style.” + name, value, styleString); }; d3_transitionPrototype.styleTween = function(name, tween, priority) { if (arguments.length &lt; 3) priority = “”; function styleTween(d, i) { var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name)); return f &amp;&amp; function(t) { this.style.setProperty(name, f(t), priority); }; } return this.tween(“style.” + name, styleTween); }; d3_transitionPrototype.text = function(value) { return d3_transition_tween(this, “text”, value, d3_transition_text); }; function d3_transition_text(b) { if (b == null) b = “”; return function() { this.textContent = b; }; } d3_transitionPrototype.remove = function() { var ns = this.namespace; return this.each(“end.transition”, function() { var p; if (this[ns].count &lt; 2 &amp;&amp; (p = this.parentNode)) p.removeChild(this); }); }; d3_transitionPrototype.ease = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].ease; if (typeof value !== “function”) value = d3.ease.apply(d3, arguments); return d3_selection_each(this, function(node) { node[ns][id].ease = value; }); }; d3_transitionPrototype.delay = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].delay; return d3_selection_each(this, typeof value === “function” ? function(node, i, j) { node[ns][id].delay = +value.call(node, node.data, i, j); } : (value = +value, function(node) { node[ns][id].delay = value; })); }; d3_transitionPrototype.duration = function(value) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 1) return this.node()[ns][id].duration; return d3_selection_each(this, typeof value === “function” ? function(node, i, j) { node[ns][id].duration = Math.max(1, value.call(node, node.data, i, j)); } : (value = Math.max(1, value), function(node) { node[ns][id].duration = value; })); }; d3_transitionPrototype.each = function(type, listener) { var id = this.id, ns = this.namespace; if (arguments.length &lt; 2) { var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId; try { d3_transitionInheritId = id; d3_selection_each(this, function(node, i, j) { d3_transitionInherit = node[ns][id]; type.call(node, node.data, i, j); }); } finally { d3_transitionInherit = inherit; d3_transitionInheritId = inheritId; } } else { d3_selection_each(this, function(node) { var transition = node[ns][id]; (transition.event || (transition.event = d3.dispatch(“start”, “end”, “interrupt”))).on(type, listener); }); } return this; }; d3_transitionPrototype.transition = function() { var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition; for (var j = 0, m = this.length; j &lt; m; j++) { subgroups.push(subgroup = []); for (var group = this[j], i = 0, n = group.length; i &lt; n; i++) { if (node = group[i]) { transition = node[ns][id0]; d3_transitionNode(node, i, ns, id1, { time: transition.time, ease: transition.ease, delay: transition.delay + transition.duration, duration: transition.duration }); } subgroup.push(node); } } return d3_transition(subgroups, ns, id1); }; function d3_transitionNamespace(name) { return name == null ? “transition“ : “transition_” + name + ““; } function d3_transitionNode(node, i, ns, id, inherit) { var lock = node[ns] || (node[ns] = { active: 0, count: 0 }), transition = lock[id], time, timer, duration, ease, tweens; function schedule(elapsed) { var delay = transition.delay; timer.t = delay + time; if (delay &lt;= elapsed) return start(elapsed - delay); timer.c = start; } function start(elapsed) { var activeId = lock.active, active = lock[activeId]; if (active) { active.timer.c = null; active.timer.t = NaN; –lock.count; delete lock[activeId]; active.event &amp;&amp; active.event.interrupt.call(node, node.data, active.index); } for (var cancelId in lock) { if (+cancelId &lt; id) { var cancel = lock[cancelId]; cancel.timer.c = null; cancel.timer.t = NaN; –lock.count; delete lock[cancelId]; } } timer.c = tick; d3_timer(function() { if (timer.c &amp;&amp; tick(elapsed || 1)) { timer.c = null; timer.t = NaN; } return 1; }, 0, time); lock.active = id; transition.event &amp;&amp; transition.event.start.call(node, node.data, i); tweens = []; transition.tween.forEach(function(key, value) { if (value = value.call(node, node.data, i)) { tweens.push(value); } }); ease = transition.ease; duration = transition.duration; } function tick(elapsed) { var t = elapsed / duration, e = ease(t), n = tweens.length; while (n &gt; 0) { tweens[–n].call(node, e); } if (t &gt;= 1) { transition.event &amp;&amp; transition.event.end.call(node, node.data, i); if (–lock.count) delete lock[id]; else delete node[ns]; return 1; } } if (!transition) { time = inherit.time; timer = d3_timer(schedule, 0, time); transition = lock[id] = { tween: new d3_Map(), time: time, timer: timer, delay: inherit.delay, duration: inherit.duration, ease: inherit.ease, index: i }; inherit = null; ++lock.count; } } d3.svg.axis = function() { var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_; function axis(g) { g.each(function() { var g = d3.select(this); var scale0 = this.chart || scale, scale1 = this.chart = scale.copy(); var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(“.tick”).data(ticks, scale1), tickEnter = tick.enter().insert(“g”, “.domain”).attr(“class”, “tick”).style(“opacity”, ε), tickExit = d3.transition(tick.exit()).style(“opacity”, ε).remove(), tickUpdate = d3.transition(tick.order()).style(“opacity”, 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform; var range = d3_scaleRange(scale1), path = g.selectAll(“.domain”).data([ 0 ]), pathUpdate = (path.enter().append(“path”).attr(“class”, “domain”), d3.transition(path)); tickEnter.append(“line”); tickEnter.append(“text”); var lineEnter = tickEnter.select(“line”), lineUpdate = tickUpdate.select(“line”), text = tick.select(“text”).text(tickFormat), textEnter = tickEnter.select(“text”), textUpdate = tickUpdate.select(“text”), sign = orient === “top” || orient === “left” ? -1 : 1, x1, x2, y1, y2; if (orient === “bottom” || orient === “top”) { tickTransform = d3_svg_axisX, x1 = “x”, y1 = “y”, x2 = “x2”, y2 = “y2”; text.attr(“dy”, sign &lt; 0 ? “0em” : “.71em”).style(“text-anchor”, “middle”); pathUpdate.attr(“d”, “M” + range[0] + “,” + sign outerTickSize + “V0H” + range[1] + “V” + sign outerTickSize); } else { tickTransform = d3_svg_axisY, x1 = “y”, y1 = “x”, x2 = “y2”, y2 = “x2”; text.attr(“dy”, “.32em”).style(“text-anchor”, sign &lt; 0 ? “end” : “start”); pathUpdate.attr(“d”, “M” + sign outerTickSize + “,” + range[0] + “H0V” + range[1] + “H” + sign outerTickSize); } lineEnter.attr(y2, sign innerTickSize); textEnter.attr(y1, sign tickSpacing); lineUpdate.attr(x2, 0).attr(y2, sign innerTickSize); textUpdate.attr(x1, 0).attr(y1, sign tickSpacing); if (scale1.rangeBand) { var x = scale1, dx = x.rangeBand() / 2; scale0 = scale1 = function(d) { return x(d) + dx; }; } else if (scale0.rangeBand) { scale0 = scale1; } else { tickExit.call(tickTransform, scale1, scale0); } tickEnter.call(tickTransform, scale0, scale1); tickUpdate.call(tickTransform, scale1, scale1); }); } axis.scale = function(x) { if (!arguments.length) return scale; scale = x; return axis; }; axis.orient = function(x) { if (!arguments.length) return orient; orient = x in d3_svg_axisOrients ? x + “” : d3_svg_axisDefaultOrient; return axis; }; axis.ticks = function() { if (!arguments.length) return tickArguments_; tickArguments_ = d3_array(arguments); return axis; }; axis.tickValues = function(x) { if (!arguments.length) return tickValues; tickValues = x; return axis; }; axis.tickFormat = function(x) { if (!arguments.length) return tickFormat_; tickFormat_ = x; return axis; }; axis.tickSize = function(x) { var n = arguments.length; if (!n) return innerTickSize; innerTickSize = +x; outerTickSize = +arguments[n - 1]; return axis; }; axis.innerTickSize = function(x) { if (!arguments.length) return innerTickSize; innerTickSize = +x; return axis; }; axis.outerTickSize = function(x) { if (!arguments.length) return outerTickSize; outerTickSize = +x; return axis; }; axis.tickPadding = function(x) { if (!arguments.length) return tickPadding; tickPadding = +x; return axis; }; axis.tickSubdivide = function() { return arguments.length &amp;&amp; axis; }; return axis; }; var d3_svg_axisDefaultOrient = “bottom”, d3_svg_axisOrients = { top: 1, right: 1, bottom: 1, left: 1 }; function d3_svg_axisX(selection, x0, x1) { selection.attr(“transform”, function(d) { var v0 = x0(d); return “translate(“ + (isFinite(v0) ? v0 : x1(d)) + “,0)”; }); } function d3_svg_axisY(selection, y0, y1) { selection.attr(“transform”, function(d) { var v0 = y0(d); return “translate(0,” + (isFinite(v0) ? v0 : y1(d)) + “)”; }); } d3.svg.brush = function() { var event = d3_eventDispatch(brush, “brushstart”, “brush”, “brushend”), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0]; function brush(g) { g.each(function() { var g = d3.select(this).style(“pointer-events”, “all”).style(“-webkit-tap-highlight-color”, “rgba(0,0,0,0)”).on(“mousedown.brush”, brushstart).on(“touchstart.brush”, brushstart); var background = g.selectAll(“.background”).data([ 0 ]); background.enter().append(“rect”).attr(“class”, “background”).style(“visibility”, “hidden”).style(“cursor”, “crosshair”); g.selectAll(“.extent”).data([ 0 ]).enter().append(“rect”).attr(“class”, “extent”).style(“cursor”, “move”); var resize = g.selectAll(“.resize”).data(resizes, d3_identity); resize.exit().remove(); resize.enter().append(“g”).attr(“class”, function(d) { return “resize “ + d; }).style(“cursor”, function(d) { return d3_svg_brushCursor[d]; }).append(“rect”).attr(“x”, function(d) { return /[ew]$/.test(d) ? -3 : null; }).attr(“y”, function(d) { return /^[ns]/.test(d) ? -3 : null; }).attr(“width”, 6).attr(“height”, 6).style(“visibility”, “hidden”); resize.style(“display”, brush.empty() ? “none” : null); var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range; if (x) { range = d3_scaleRange(x); backgroundUpdate.attr(“x”, range[0]).attr(“width”, range[1] - range[0]); redrawX(gUpdate); } if (y) { range = d3_scaleRange(y); backgroundUpdate.attr(“y”, range[0]).attr(“height”, range[1] - range[0]); redrawY(gUpdate); } redraw(gUpdate); }); } brush.event = function(g) { g.each(function() { var event_ = event.of(this, arguments), extent1 = { x: xExtent, y: yExtent, i: xExtentDomain, j: yExtentDomain }, extent0 = this.chart || extent1; this.chart = extent1; if (d3_transitionInheritId) { d3.select(this).transition().each(“start.brush”, function() { xExtentDomain = extent0.i; yExtentDomain = extent0.j; xExtent = extent0.x; yExtent = extent0.y; event_({ type: “brushstart” }); }).tween(“brush:brush”, function() { var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y); xExtentDomain = yExtentDomain = null; return function(t) { xExtent = extent1.x = xi(t); yExtent = extent1.y = yi(t); event_({ type: “brush”, mode: “resize” }); }; }).each(“end.brush”, function() { xExtentDomain = extent1.i; yExtentDomain = extent1.j; event_({ type: “brush”, mode: “resize” }); event_({ type: “brushend” }); }); } else { event_({ type: “brushstart” }); event_({ type: “brush”, mode: “resize” }); event_({ type: “brushend” }); } }); }; function redraw(g) { g.selectAll(“.resize”).attr(“transform”, function(d) { return “translate(“ + xExtent[+/e$/.test(d)] + “,” + yExtent[+/^s/.test(d)] + “)”; }); } function redrawX(g) { g.select(“.extent”).attr(“x”, xExtent[0]); g.selectAll(“.extent,.n&gt;rect,.s&gt;rect”).attr(“width”, xExtent[1] - xExtent[0]); } function redrawY(g) { g.select(“.extent”).attr(“y”, yExtent[0]); g.selectAll(“.extent,.e&gt;rect,.w&gt;rect”).attr(“height”, yExtent[1] - yExtent[0]); } function brushstart() { var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) &amp;&amp; x, resizingY = !/^(e|w)$/.test(resizing) &amp;&amp; y, dragging = eventTarget.classed(“extent”), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset; var w = d3.select(d3_window(target)).on(“keydown.brush”, keydown).on(“keyup.brush”, keyup); if (d3.event.changedTouches) { w.on(“touchmove.brush”, brushmove).on(“touchend.brush”, brushend); } else { w.on(“mousemove.brush”, brushmove).on(“mouseup.brush”, brushend); } g.interrupt().selectAll(““).interrupt(); if (dragging) { origin[0] = xExtent[0] - origin[0]; origin[1] = yExtent[0] - origin[1]; } else if (resizing) { var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing); offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ]; origin[0] = xExtent[ex]; origin[1] = yExtent[ey]; } else if (d3.event.altKey) center = origin.slice(); g.style(“pointer-events”, “none”).selectAll(“.resize”).style(“display”, null); d3.select(“body”).style(“cursor”, eventTarget.style(“cursor”)); event_({ type: “brushstart” }); brushmove(); function keydown() { if (d3.event.keyCode == 32) { if (!dragging) { center = null; origin[0] -= xExtent[1]; origin[1] -= yExtent[1]; dragging = 2; } d3_eventPreventDefault(); } } function keyup() { if (d3.event.keyCode == 32 &amp;&amp; dragging == 2) { origin[0] += xExtent[1]; origin[1] += yExtent[1]; dragging = 0; d3_eventPreventDefault(); } } function brushmove() { var point = d3.mouse(target), moved = false; if (offset) { point[0] += offset[0]; point[1] += offset[1]; } if (!dragging) { if (d3.event.altKey) { if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ]; origin[0] = xExtent[+(point[0] &lt; center[0])]; origin[1] = yExtent[+(point[1] &lt; center[1])]; } else center = null; } if (resizingX &amp;&amp; move1(point, x, 0)) { redrawX(g); moved = true; } if (resizingY &amp;&amp; move1(point, y, 1)) { redrawY(g); moved = true; } if (moved) { redraw(g); event_({ type: “brush”, mode: dragging ? “move” : “resize” }); } } function move1(point, scale, i) { var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max; if (dragging) { r0 -= position; r1 -= size + position; } min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i]; if (dragging) { max = (min += position) + size; } else { if (center) position = Math.max(r0, Math.min(r1, 2 center[i] - min)); if (position &lt; min) { max = min; min = position; } else { max = position; } } if (extent[0] != min || extent[1] != max) { if (i) yExtentDomain = null; else xExtentDomain = null; extent[0] = min; extent[1] = max; return true; } } function brushend() { brushmove(); g.style(“pointer-events”, “all”).selectAll(“.resize”).style(“display”, brush.empty() ? “none” : null); d3.select(“body”).style(“cursor”, null); w.on(“mousemove.brush”, null).on(“mouseup.brush”, null).on(“touchmove.brush”, null).on(“touchend.brush”, null).on(“keydown.brush”, null).on(“keyup.brush”, null); dragRestore(); event_({ type: “brushend” }); } } brush.x = function(z) { if (!arguments.length) return x; x = z; resizes = d3_svg_brushResizes[!x &lt;&lt; 1 | !y]; return brush; }; brush.y = function(z) { if (!arguments.length) return y; y = z; resizes = d3_svg_brushResizes[!x &lt;&lt; 1 | !y]; return brush; }; brush.clamp = function(z) { if (!arguments.length) return x &amp;&amp; y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null; if (x &amp;&amp; y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z; return brush; }; brush.extent = function(z) { var x0, x1, y0, y1, t; if (!arguments.length) { if (x) { if (xExtentDomain) { x0 = xExtentDomain[0], x1 = xExtentDomain[1]; } else { x0 = xExtent[0], x1 = xExtent[1]; if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1); if (x1 &lt; x0) t = x0, x0 = x1, x1 = t; } } if (y) { if (yExtentDomain) { y0 = yExtentDomain[0], y1 = yExtentDomain[1]; } else { y0 = yExtent[0], y1 = yExtent[1]; if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1); if (y1 &lt; y0) t = y0, y0 = y1, y1 = t; } } return x &amp;&amp; y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y &amp;&amp; [ y0, y1 ]; } if (x) { x0 = z[0], x1 = z[1]; if (y) x0 = x0[0], x1 = x1[0]; xExtentDomain = [ x0, x1 ]; if (x.invert) x0 = x(x0), x1 = x(x1); if (x1 &lt; x0) t = x0, x0 = x1, x1 = t; if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ]; } if (y) { y0 = z[0], y1 = z[1]; if (x) y0 = y0[1], y1 = y1[1]; yExtentDomain = [ y0, y1 ]; if (y.invert) y0 = y(y0), y1 = y(y1); if (y1 &lt; y0) t = y0, y0 = y1, y1 = t; if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ]; } return brush; }; brush.clear = function() { if (!brush.empty()) { xExtent = [ 0, 0 ], yExtent = [ 0, 0 ]; xExtentDomain = yExtentDomain = null; } return brush; }; brush.empty = function() { return !!x &amp;&amp; xExtent[0] == xExtent[1] || !!y &amp;&amp; yExtent[0] == yExtent[1]; }; return d3.rebind(brush, event, “on”); }; var d3_svg_brushCursor = { n: “ns-resize”, e: “ew-resize”, s: “ns-resize”, w: “ew-resize”, nw: “nwse-resize”, ne: “nesw-resize”, se: “nwse-resize”, sw: “nesw-resize” }; var d3_svg_brushResizes = [ [ “n”, “e”, “s”, “w”, “nw”, “ne”, “se”, “sw” ], [ “e”, “w” ], [ “n”, “s” ], [] ]; var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat; var d3_time_formatUtc = d3_time_format.utc; var d3_time_formatIso = d3_time_formatUtc(“%Y-%m-%dT%H:%M:%S.%LZ”); d3_time_format.iso = Date.prototype.toISOString &amp;&amp; +new Date(“2000-01-01T00:00:00.000Z”) ? d3_time_formatIsoNative : d3_time_formatIso; function d3_time_formatIsoNative(date) { return date.toISOString(); } d3_time_formatIsoNative.parse = function(string) { var date = new Date(string); return isNaN(date) ? null : date; }; d3_time_formatIsoNative.toString = d3_time_formatIso.toString; d3_time.second = d3_time_interval(function(date) { return new d3_date(Math.floor(date / 1e3) 1e3); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 1e3); }, function(date) { return date.getSeconds(); }); d3_time.seconds = d3_time.second.range; d3_time.seconds.utc = d3_time.second.utc.range; d3_time.minute = d3_time_interval(function(date) { return new d3_date(Math.floor(date / 6e4) 6e4); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 6e4); }, function(date) { return date.getMinutes(); }); d3_time.minutes = d3_time.minute.range; d3_time.minutes.utc = d3_time.minute.utc.range; d3_time.hour = d3_time_interval(function(date) { var timezone = date.getTimezoneOffset() / 60; return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) 36e5); }, function(date, offset) { date.setTime(date.getTime() + Math.floor(offset) 36e5); }, function(date) { return date.getHours(); }); d3_time.hours = d3_time.hour.range; d3_time.hours.utc = d3_time.hour.utc.range; d3_time.month = d3_time_interval(function(date) { date = d3_time.day(date); date.setDate(1); return date; }, function(date, offset) { date.setMonth(date.getMonth() + offset); }, function(date) { return date.getMonth(); }); d3_time.months = d3_time.month.range; d3_time.months.utc = d3_time.month.utc.range; function d3_time_scale(linear, methods, format) { function scale(x) { return linear(x); } scale.invert = function(x) { return d3_time_scaleDate(linear.invert(x)); }; scale.domain = function(x) { if (!arguments.length) return linear.domain().map(d3_time_scaleDate); linear.domain(x); return scale; }; function tickMethod(extent, count) { var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target); return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) { return d / 31536e6; }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] &lt; d3_time_scaleSteps[i] / target ? i - 1 : i]; } scale.nice = function(interval, skip) { var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === “number” &amp;&amp; tickMethod(extent, interval); if (method) interval = method[0], skip = method[1]; function skipped(date) { return !isNaN(date) &amp;&amp; !interval.range(date, d3_time_scaleDate(+date + 1), skip).length; } return scale.domain(d3_scale_nice(domain, skip &gt; 1 ? { floor: function(date) { while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1); return date; }, ceil: function(date) { while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1); return date; } } : interval)); }; scale.ticks = function(interval, skip) { var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === “number” ? tickMethod(extent, interval) : !interval.range &amp;&amp; [ { range: interval }, skip ]; if (method) interval = method[0], skip = method[1]; return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip &lt; 1 ? 1 : skip); }; scale.tickFormat = function() { return format; }; scale.copy = function() { return d3_time_scale(linear.copy(), methods, format); }; return d3_scale_linearRebind(scale, linear); } function d3_time_scaleDate(t) { return new Date(t); } var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ]; var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ]; var d3_time_scaleLocalFormat = d3_time_format.multi([ [ “.%L”, function(d) { return d.getMilliseconds(); } ], [ “:%S”, function(d) { return d.getSeconds(); } ], [ “%I:%M”, function(d) { return d.getMinutes(); } ], [ “%I %p”, function(d) { return d.getHours(); } ], [ “%a %d”, function(d) { return d.getDay() &amp;&amp; d.getDate() != 1; } ], [ “%b %d”, function(d) { return d.getDate() != 1; } ], [ “%B”, function(d) { return d.getMonth(); } ], [ “%Y”, d3_true ] ]); var d3_time_scaleMilliseconds = { range: function(start, stop, step) { return d3.range(Math.ceil(start / step) step, +stop, step).map(d3_time_scaleDate); }, floor: d3_identity, ceil: d3_identity }; d3_time_scaleLocalMethods.year = d3_time.year; d3_time.scale = function() { return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat); }; var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) { return [ m[0].utc, m[1] ]; }); var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ “.%L”, function(d) { return d.getUTCMilliseconds(); } ], [ “:%S”, function(d) { return d.getUTCSeconds(); } ], [ “%I:%M”, function(d) { return d.getUTCMinutes(); } ], [ “%I %p”, function(d) { return d.getUTCHours(); } ], [ “%a %d”, function(d) { return d.getUTCDay() &amp;&amp; d.getUTCDate() != 1; } ], [ “%b %d”, function(d) { return d.getUTCDate() != 1; } ], [ “%B”, function(d) { return d.getUTCMonth(); } ], [ “%Y”, d3_true ] ]); d3_time_scaleUtcMethods.year = d3_time.year.utc; d3_time.scale.utc = function() { return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat); }; d3.text = d3_xhrType(function(request) { return request.responseText; }); d3.json = function(url, callback) { return d3_xhr(url, “application/json”, d3_json, callback); }; function d3_json(request) { return JSON.parse(request.responseText); } d3.html = function(url, callback) { return d3_xhr(url, “text/html”, d3_html, callback); }; function d3_html(request) { var range = d3_document.createRange(); range.selectNode(d3_document.body); return range.createContextualFragment(request.responseText); } d3.xml = d3_xhrType(function(request) { return request.responseXML; }); if (true) this.d3 = d3, !(WEBPACK_AMD_DEFINE_FACTORY = (d3), WEBPACK_AMD_DEFINE_RESULT = (typeof WEBPACK_AMD_DEFINE_FACTORY === ‘function’ ? (WEBPACK_AMD_DEFINE_FACTORY.call(exports, webpack_require, exports, module)) : WEBPACK_AMD_DEFINE_FACTORY), WEBPACK_AMD_DEFINE_RESULT !== undefined &amp;&amp; (module.exports = WEBPACK_AMD_DEFINE_RESULT)); else if (typeof module === “object” &amp;&amp; module.exports) module.exports = d3; else this.d3 = d3; }();/*/ }),/ 3 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _d = webpack_require__(2); var _d2 = _interopRequireDefault(_d); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; } function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var Barchart = // svg: d3 object with the svg in question // exp_array: list of (feature_name, weight) function Barchart(svg, exp_array) { var two_sided = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : true; var titles = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : undefined; var colors = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : [‘red’, ‘green’]; var show_numbers = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; var bar_height = arguments.length &gt; 6 &amp;&amp; arguments[6] !== undefined ? arguments[6] : 5; _classCallCheck(this, Barchart); var svg_width = Math.min(600, parseInt(svg.style(‘width’))); var bar_width = two_sided ? svg_width / 2 : svg_width; if (titles === undefined) { titles = two_sided ? [‘Cons’, ‘Pros’] : ‘Pros’; } if (show_numbers) { bar_width = bar_width - 30; } var x_offset = two_sided ? svg_width / 2 : 10; // 13.1 is +- the width of W, the widest letter. if (two_sided &amp;&amp; titles.length == 2) { svg.append(‘text’).attr(‘x’, svg_width / 4).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, ‘middle’).style(‘fill’, colors[0]).text(titles[0]); svg.append(‘text’).attr(‘x’, svg_width / 4 3).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, ‘middle’).style(‘fill’, colors[1]).text(titles[1]); } else { var pos = two_sided ? svg_width / 2 : x_offset; var anchor = two_sided ? ‘middle’ : ‘begin’; svg.append(‘text’).attr(‘x’, pos).attr(‘y’, 15).attr(‘font-size’, ‘20’).attr(‘text-anchor’, anchor).text(titles); } var yshift = 20; var space_between_bars = 0; var text_height = 16; var space_between_bar_and_text = 3; var total_bar_height = text_height + space_between_bar_and_text + bar_height + space_between_bars; var total_height = total_bar_height exp_array.length; this.svg_height = total_height + yshift; var yscale = _d2.default.scale.linear().domain([0, exp_array.length]).range([yshift, yshift + total_height]); var names = exp_array.map(function (v) { return v[0]; }); var weights = exp_array.map(function (v) { return v[1]; }); var max_weight = Math.max.apply(Math, _toConsumableArray(weights.map(function (v) { return Math.abs(v); }))); var xscale = _d2.default.scale.linear().domain([0, Math.max(1, max_weight)]).range([0, bar_width]); for (var i = 0; i &lt; exp_array.length; ++i) { var name = names[i]; var weight = weights[i]; var size = xscale(Math.abs(weight)); var to_the_right = weight &gt; 0 || !two_sided; var text = svg.append(‘text’).attr(‘x’, to_the_right ? x_offset + 2 : x_offset - 2).attr(‘y’, yscale(i) + text_height).attr(‘text-anchor’, to_the_right ? ‘begin’ : ‘end’).attr(‘font-size’, ‘14’).text(name); while (text.node().getBBox()[‘width’] + 1 &gt; bar_width) { var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + ‘…’); if (text === ‘…’) { break; } } var bar = svg.append(‘rect’).attr(‘height’, bar_height).attr(‘x’, to_the_right ? x_offset : x_offset - size).attr(‘y’, text_height + yscale(i) + space_between_bar_and_text) // + bar_height) .attr(‘width’, size).style(‘fill’, weight &gt; 0 ? colors[1] : colors[0]); if (show_numbers) { var bartext = svg.append(‘text’).attr(‘x’, to_the_right ? x_offset + size + 1 : x_offset - size - 1).attr(‘text-anchor’, weight &gt; 0 || !two_sided ? ‘begin’ : ‘end’).attr(‘y’, bar_height + yscale(i) + text_height + space_between_bar_and_text).attr(‘font-size’, ‘10’).text(Math.abs(weight).toFixed(2)); } } var line = svg.append(“line”).attr(“x1”, x_offset).attr(“x2”, x_offset).attr(“y1”, bar_height + yshift).attr(“y2”, Math.max(bar_height, yscale(exp_array.length))).style(“stroke-width”, 2).style(“stroke”, “black”); }; exports.default = Barchart;// }),/ 4 /// (function(module, exports, webpack_require) { var WEBPACK_AMD_DEFINE_RESULT;/ WEBPACK VAR INJECTION */(function(global, module) {/ @license Lodash https://lodash.com/ Copyright JS Foundation and other contributors https://js.foundation/ Released under MIT license https://lodash.com/license Based on Underscore.js 1.8.3 http://underscorejs.org/LICENSE Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors / ;(function() { /** Used as a safe reference for undefined in pre-ES5 environments. / var undefined; / Used as the semantic version number. */ var VERSION = ‘4.17.11’; / Used as the size to enable large array optimizations. / var LARGE_ARRAY_SIZE = 200; /** Error message constants. / var CORE_ERROR_TEXT = ‘Unsupported core-js use. Try https://npms.io/search?q=ponyfill.&#39;, FUNC_ERROR_TEXT = ‘Expected a function’; / Used to stand-in for undefined hash values. */ var HASH_UNDEFINED = ‘lodash_hash_undefined‘; / Used as the maximum memoize cache size. / var MAX_MEMOIZE_SIZE = 500; /** Used as the internal argument placeholder. / var PLACEHOLDER = ‘lodash_placeholder‘; / Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4; / Used to compose bitmasks for value comparisons. / var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2; /** Used to compose bitmasks for function metadata. / var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512; / Used as default options for _.truncate. */ var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = ‘…’; / Used to detect hot functions by number of calls within a span of milliseconds. / var HOT_COUNT = 800, HOT_SPAN = 16; /** Used to indicate the type of lazy iteratees. / var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3; / Used as references for various Number constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0; / Used as references for the maximum length and index of an array. / var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH &gt;&gt;&gt; 1; /** Used to associate wrap methods with their bit flags. / var wrapFlags = [ [‘ary’, WRAP_ARY_FLAG], [‘bind’, WRAP_BIND_FLAG], [‘bindKey’, WRAP_BIND_KEY_FLAG], [‘curry’, WRAP_CURRY_FLAG], [‘curryRight’, WRAP_CURRY_RIGHT_FLAG], [‘flip’, WRAP_FLIP_FLAG], [‘partial’, WRAP_PARTIAL_FLAG], [‘partialRight’, WRAP_PARTIAL_RIGHT_FLAG], [‘rearg’, WRAP_REARG_FLAG] ]; / Object#toString result references. */ var argsTag = ‘[object Arguments]’, arrayTag = ‘[object Array]’, asyncTag = ‘[object AsyncFunction]’, boolTag = ‘[object Boolean]’, dateTag = ‘[object Date]’, domExcTag = ‘[object DOMException]’, errorTag = ‘[object Error]’, funcTag = ‘[object Function]’, genTag = ‘[object GeneratorFunction]’, mapTag = ‘[object Map]’, numberTag = ‘[object Number]’, nullTag = ‘[object Null]’, objectTag = ‘[object Object]’, promiseTag = ‘[object Promise]’, proxyTag = ‘[object Proxy]’, regexpTag = ‘[object RegExp]’, setTag = ‘[object Set]’, stringTag = ‘[object String]’, symbolTag = ‘[object Symbol]’, undefinedTag = ‘[object Undefined]’, weakMapTag = ‘[object WeakMap]’, weakSetTag = ‘[object WeakSet]’; var arrayBufferTag = ‘[object ArrayBuffer]’, dataViewTag = ‘[object DataView]’, float32Tag = ‘[object Float32Array]’, float64Tag = ‘[object Float64Array]’, int8Tag = ‘[object Int8Array]’, int16Tag = ‘[object Int16Array]’, int32Tag = ‘[object Int32Array]’, uint8Tag = ‘[object Uint8Array]’, uint8ClampedTag = ‘[object Uint8ClampedArray]’, uint16Tag = ‘[object Uint16Array]’, uint32Tag = ‘[object Uint32Array]’; / Used to match empty string literals in compiled template source. / var reEmptyStringLeading = /\b__p += ‘’;/g, reEmptyStringMiddle = /\b(p +=) ‘’ +/g, reEmptyStringTrailing = /(e(.?)|\b__t)) +\n’’;/g; / Used to match HTML entities and HTML characters. */ var reEscapedHtml = /&amp;(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&amp;&lt;&gt;”‘]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source); / Used to match template delimiters. / var reEscape = /&lt;%-([\s\S]+?)%&gt;/g, reEvaluate = /&lt;%([\s\S]+?)%&gt;/g, reInterpolate = /&lt;%=([\s\S]+?)%&gt;/g; /** Used to match property names within property paths. / var reIsDeepProp = /.|[(?:[^[]]|([“‘])(?:(?!\1)[^\]|\.)?\1)]/, reIsPlainProp = /^\w$/, rePropName = /[^.[]]+|[(?:(-?\d+(?:.\d+)?)|([“‘])((?:(?!\2)[^\]|\.)?)\2)]|(?=(?:.|[])(?:.|[]|$))/g; / Used to match RegExp syntax characters. / var reRegExpChar = /[\^$.+?()[]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source); / Used to match leading and trailing whitespace. / var reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/; /** Used to match wrap detail comments. / var reWrapComment = /{(?:\n\/* [wrapped with .+] *\/)?\n?/, reWrapDetails = /{\n\/* [wrapped with (.+)] */, reSplitDetails = /,? &amp; /; / Used to match words composed of alphanumeric characters. */ var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g; / Used to match backslashes in property paths. / var reEscapeChar = /\(\)?/g; /** Used to match ES template delimiters. / var reEsTemplate = /\${([^\}](?:\.[^\}]))}/g; /** Used to match RegExp flags from their coerced string values. / var reFlags = /\w$/; /** Used to detect bad signed hexadecimal string values. / var reIsBadHex = /^[-+]0x[0-9a-f]+$/i; / Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i; / Used to detect host constructors (Safari). / var reIsHostCtor = /^[object .+?Constructor]$/; /** Used to detect octal string values. / var reIsOctal = /^0o[0-7]+$/i; / Used to detect unsigned integer values. / var reIsUint = /^(?:0|[1-9]\d)$/; / Used to match Latin Unicode letters (excluding mathematical operators). / var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g; /** Used to ensure capturing order of template delimiters. / var reNoMatch = /($^)/; / Used to match unescaped characters in compiled string literals. */ var reUnescapedString = /[‘\n\r\u2028\u2029\]/g; / Used to compose unicode character classes. / var rsAstralRange = ‘\ud800-\udfff’, rsComboMarksRange = ‘\u0300-\u036f’, reComboHalfMarksRange = ‘\ufe20-\ufe2f’, rsComboSymbolsRange = ‘\u20d0-\u20ff’, rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = ‘\u2700-\u27bf’, rsLowerRange = ‘a-z\xdf-\xf6\xf8-\xff’, rsMathOpRange = ‘\xac\xb1\xd7\xf7’, rsNonCharRange = ‘\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf’, rsPunctuationRange = ‘\u2000-\u206f’, rsSpaceRange = ‘ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000’, rsUpperRange = ‘A-Z\xc0-\xd6\xd8-\xde’, rsVarRange = ‘\ufe0e\ufe0f’, rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange; /** Used to compose unicode capture groups. / var rsApos = “[‘\u2019]”, rsAstral = ‘[‘ + rsAstralRange + ‘]’, rsBreak = ‘[‘ + rsBreakRange + ‘]’, rsCombo = ‘[‘ + rsComboRange + ‘]’, rsDigits = ‘\d+’, rsDingbat = ‘[‘ + rsDingbatRange + ‘]’, rsLower = ‘[‘ + rsLowerRange + ‘]’, rsMisc = ‘[^’ + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ‘]’, rsFitz = ‘\ud83c[\udffb-\udfff]’, rsModifier = ‘(?:’ + rsCombo + ‘|’ + rsFitz + ‘)’, rsNonAstral = ‘[^’ + rsAstralRange + ‘]’, rsRegional = ‘(?:\ud83c[\udde6-\uddff]){2}’, rsSurrPair = ‘[\ud800-\udbff][\udc00-\udfff]’, rsUpper = ‘[‘ + rsUpperRange + ‘]’, rsZWJ = ‘\u200d’; / Used to compose unicode regexes. / var rsMiscLower = ‘(?:’ + rsLower + ‘|’ + rsMisc + ‘)’, rsMiscUpper = ‘(?:’ + rsUpper + ‘|’ + rsMisc + ‘)’, rsOptContrLower = ‘(?:’ + rsApos + ‘(?:d|ll|m|re|s|t|ve))?’, rsOptContrUpper = ‘(?:’ + rsApos + ‘(?:D|LL|M|RE|S|T|VE))?’, reOptMod = rsModifier + ‘?’, rsOptVar = ‘[‘ + rsVarRange + ‘]?’, rsOptJoin = ‘(?:’ + rsZWJ + ‘(?:’ + [rsNonAstral, rsRegional, rsSurrPair].join(‘|’) + ‘)’ + rsOptVar + reOptMod + ‘)‘, rsOrdLower = ‘\d(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])’, rsOrdUpper = ‘\d(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])’, rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = ‘(?:’ + [rsDingbat, rsRegional, rsSurrPair].join(‘|’) + ‘)’ + rsSeq, rsSymbol = ‘(?:’ + [rsNonAstral + rsCombo + ‘?’, rsCombo, rsRegional, rsSurrPair, rsAstral].join(‘|’) + ‘)’; / Used to match apostrophes. / var reApos = RegExp(rsApos, ‘g’); /** Used to match combining diacritical marks and combining diacritical marks for symbols. / var reComboMark = RegExp(rsCombo, ‘g’); / Used to match string symbols. */ var reUnicode = RegExp(rsFitz + ‘(?=’ + rsFitz + ‘)|’ + rsSymbol + rsSeq, ‘g’); / Used to match complex or compound words. / var reUnicodeWord = RegExp([ rsUpper + ‘?’ + rsLower + ‘+’ + rsOptContrLower + ‘(?=’ + [rsBreak, rsUpper, ‘$’].join(‘|’) + ‘)’, rsMiscUpper + ‘+’ + rsOptContrUpper + ‘(?=’ + [rsBreak, rsUpper + rsMiscLower, ‘$’].join(‘|’) + ‘)’, rsUpper + ‘?’ + rsMiscLower + ‘+’ + rsOptContrLower, rsUpper + ‘+’ + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join(‘|’), ‘g’); /** Used to detect strings with zero-width joiners or code points from the astral planes. / var reHasUnicode = RegExp(‘[‘ + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ‘]’); / Used to detect strings that need a more robust regexp to match words. */ var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/; / Used to assign default context object properties. / var contextProps = [ ‘Array’, ‘Buffer’, ‘DataView’, ‘Date’, ‘Error’, ‘Float32Array’, ‘Float64Array’, ‘Function’, ‘Int8Array’, ‘Int16Array’, ‘Int32Array’, ‘Map’, ‘Math’, ‘Object’, ‘Promise’, ‘RegExp’, ‘Set’, ‘String’, ‘Symbol’, ‘TypeError’, ‘Uint8Array’, ‘Uint8ClampedArray’, ‘Uint16Array’, ‘Uint32Array’, ‘WeakMap’, ‘_’, ‘clearTimeout’, ‘isFinite’, ‘parseInt’, ‘setTimeout’ ]; /** Used to make template sourceURLs easier to identify. / var templateCounter = -1; / Used to identify toStringTag values of typed arrays. */ var typedArrayTags = {}; typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true; typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false; / Used to identify toStringTag values supported by _.clone. / var cloneableTags = {}; cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true; cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false; /** Used to map Latin Unicode letters to basic Latin letters. / var deburredLetters = { // Latin-1 Supplement block. ‘\xc0’: ‘A’, ‘\xc1’: ‘A’, ‘\xc2’: ‘A’, ‘\xc3’: ‘A’, ‘\xc4’: ‘A’, ‘\xc5’: ‘A’, ‘\xe0’: ‘a’, ‘\xe1’: ‘a’, ‘\xe2’: ‘a’, ‘\xe3’: ‘a’, ‘\xe4’: ‘a’, ‘\xe5’: ‘a’, ‘\xc7’: ‘C’, ‘\xe7’: ‘c’, ‘\xd0’: ‘D’, ‘\xf0’: ‘d’, ‘\xc8’: ‘E’, ‘\xc9’: ‘E’, ‘\xca’: ‘E’, ‘\xcb’: ‘E’, ‘\xe8’: ‘e’, ‘\xe9’: ‘e’, ‘\xea’: ‘e’, ‘\xeb’: ‘e’, ‘\xcc’: ‘I’, ‘\xcd’: ‘I’, ‘\xce’: ‘I’, ‘\xcf’: ‘I’, ‘\xec’: ‘i’, ‘\xed’: ‘i’, ‘\xee’: ‘i’, ‘\xef’: ‘i’, ‘\xd1’: ‘N’, ‘\xf1’: ‘n’, ‘\xd2’: ‘O’, ‘\xd3’: ‘O’, ‘\xd4’: ‘O’, ‘\xd5’: ‘O’, ‘\xd6’: ‘O’, ‘\xd8’: ‘O’, ‘\xf2’: ‘o’, ‘\xf3’: ‘o’, ‘\xf4’: ‘o’, ‘\xf5’: ‘o’, ‘\xf6’: ‘o’, ‘\xf8’: ‘o’, ‘\xd9’: ‘U’, ‘\xda’: ‘U’, ‘\xdb’: ‘U’, ‘\xdc’: ‘U’, ‘\xf9’: ‘u’, ‘\xfa’: ‘u’, ‘\xfb’: ‘u’, ‘\xfc’: ‘u’, ‘\xdd’: ‘Y’, ‘\xfd’: ‘y’, ‘\xff’: ‘y’, ‘\xc6’: ‘Ae’, ‘\xe6’: ‘ae’, ‘\xde’: ‘Th’, ‘\xfe’: ‘th’, ‘\xdf’: ‘ss’, // Latin Extended-A block. ‘\u0100’: ‘A’, ‘\u0102’: ‘A’, ‘\u0104’: ‘A’, ‘\u0101’: ‘a’, ‘\u0103’: ‘a’, ‘\u0105’: ‘a’, ‘\u0106’: ‘C’, ‘\u0108’: ‘C’, ‘\u010a’: ‘C’, ‘\u010c’: ‘C’, ‘\u0107’: ‘c’, ‘\u0109’: ‘c’, ‘\u010b’: ‘c’, ‘\u010d’: ‘c’, ‘\u010e’: ‘D’, ‘\u0110’: ‘D’, ‘\u010f’: ‘d’, ‘\u0111’: ‘d’, ‘\u0112’: ‘E’, ‘\u0114’: ‘E’, ‘\u0116’: ‘E’, ‘\u0118’: ‘E’, ‘\u011a’: ‘E’, ‘\u0113’: ‘e’, ‘\u0115’: ‘e’, ‘\u0117’: ‘e’, ‘\u0119’: ‘e’, ‘\u011b’: ‘e’, ‘\u011c’: ‘G’, ‘\u011e’: ‘G’, ‘\u0120’: ‘G’, ‘\u0122’: ‘G’, ‘\u011d’: ‘g’, ‘\u011f’: ‘g’, ‘\u0121’: ‘g’, ‘\u0123’: ‘g’, ‘\u0124’: ‘H’, ‘\u0126’: ‘H’, ‘\u0125’: ‘h’, ‘\u0127’: ‘h’, ‘\u0128’: ‘I’, ‘\u012a’: ‘I’, ‘\u012c’: ‘I’, ‘\u012e’: ‘I’, ‘\u0130’: ‘I’, ‘\u0129’: ‘i’, ‘\u012b’: ‘i’, ‘\u012d’: ‘i’, ‘\u012f’: ‘i’, ‘\u0131’: ‘i’, ‘\u0134’: ‘J’, ‘\u0135’: ‘j’, ‘\u0136’: ‘K’, ‘\u0137’: ‘k’, ‘\u0138’: ‘k’, ‘\u0139’: ‘L’, ‘\u013b’: ‘L’, ‘\u013d’: ‘L’, ‘\u013f’: ‘L’, ‘\u0141’: ‘L’, ‘\u013a’: ‘l’, ‘\u013c’: ‘l’, ‘\u013e’: ‘l’, ‘\u0140’: ‘l’, ‘\u0142’: ‘l’, ‘\u0143’: ‘N’, ‘\u0145’: ‘N’, ‘\u0147’: ‘N’, ‘\u014a’: ‘N’, ‘\u0144’: ‘n’, ‘\u0146’: ‘n’, ‘\u0148’: ‘n’, ‘\u014b’: ‘n’, ‘\u014c’: ‘O’, ‘\u014e’: ‘O’, ‘\u0150’: ‘O’, ‘\u014d’: ‘o’, ‘\u014f’: ‘o’, ‘\u0151’: ‘o’, ‘\u0154’: ‘R’, ‘\u0156’: ‘R’, ‘\u0158’: ‘R’, ‘\u0155’: ‘r’, ‘\u0157’: ‘r’, ‘\u0159’: ‘r’, ‘\u015a’: ‘S’, ‘\u015c’: ‘S’, ‘\u015e’: ‘S’, ‘\u0160’: ‘S’, ‘\u015b’: ‘s’, ‘\u015d’: ‘s’, ‘\u015f’: ‘s’, ‘\u0161’: ‘s’, ‘\u0162’: ‘T’, ‘\u0164’: ‘T’, ‘\u0166’: ‘T’, ‘\u0163’: ‘t’, ‘\u0165’: ‘t’, ‘\u0167’: ‘t’, ‘\u0168’: ‘U’, ‘\u016a’: ‘U’, ‘\u016c’: ‘U’, ‘\u016e’: ‘U’, ‘\u0170’: ‘U’, ‘\u0172’: ‘U’, ‘\u0169’: ‘u’, ‘\u016b’: ‘u’, ‘\u016d’: ‘u’, ‘\u016f’: ‘u’, ‘\u0171’: ‘u’, ‘\u0173’: ‘u’, ‘\u0174’: ‘W’, ‘\u0175’: ‘w’, ‘\u0176’: ‘Y’, ‘\u0177’: ‘y’, ‘\u0178’: ‘Y’, ‘\u0179’: ‘Z’, ‘\u017b’: ‘Z’, ‘\u017d’: ‘Z’, ‘\u017a’: ‘z’, ‘\u017c’: ‘z’, ‘\u017e’: ‘z’, ‘\u0132’: ‘IJ’, ‘\u0133’: ‘ij’, ‘\u0152’: ‘Oe’, ‘\u0153’: ‘oe’, ‘\u0149’: “‘n”, ‘\u017f’: ‘s’ }; / Used to map characters to HTML entities. */ var htmlEscapes = { ‘&amp;’: ‘&amp;’, ‘&lt;’: ‘&lt;’, ‘&gt;’: ‘&gt;’, ‘“‘: ‘&quot;’, “‘“: ‘&#39;’ }; / Used to map HTML entities to characters. / var htmlUnescapes = { ‘&amp;’: ‘&amp;’, ‘&lt;’: ‘&lt;’, ‘&gt;’: ‘&gt;’, ‘&quot;’: ‘“‘, ‘&#39;’: “‘“ }; /** Used to escape characters for inclusion in compiled string literals. / var stringEscapes = { ‘\‘: ‘\‘, “‘“: “‘“, ‘\n’: ‘n’, ‘\r’: ‘r’, ‘\u2028’: ‘u2028’, ‘\u2029’: ‘u2029’ }; / Built-in method references without a dependency on root. */ var freeParseFloat = parseFloat, freeParseInt = parseInt; / Detect free variable global from Node.js. / var freeGlobal = typeof global == ‘object’ &amp;&amp; global &amp;&amp; global.Object === Object &amp;&amp; global; /** Detect free variable self. / var freeSelf = typeof self == ‘object’ &amp;&amp; self &amp;&amp; self.Object === Object &amp;&amp; self; / Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function(‘return this’)(); / Detect free variable exports. / var freeExports = typeof exports == ‘object’ &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports; /** Detect free variable module. / var freeModule = freeExports &amp;&amp; typeof module == ‘object’ &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module; / Detect the popular CommonJS extension module.exports. */ var moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports; / Detect free variable process from Node.js. / var freeProcess = moduleExports &amp;&amp; freeGlobal.process; /** Used to access faster Node.js helpers. / var nodeUtil = (function() { try { // Use util.types for Node.js 10+. var types = freeModule &amp;&amp; freeModule.require &amp;&amp; freeModule.require(‘util’).types; if (types) { return types; } // Legacy process.binding(&#39;util&#39;) for Node.js &lt; 10. return freeProcess &amp;&amp; freeProcess.binding &amp;&amp; freeProcess.binding(‘util’); } catch (e) {} }()); / Node.js helper references. / var nodeIsArrayBuffer = nodeUtil &amp;&amp; nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil &amp;&amp; nodeUtil.isDate, nodeIsMap = nodeUtil &amp;&amp; nodeUtil.isMap, nodeIsRegExp = nodeUtil &amp;&amp; nodeUtil.isRegExp, nodeIsSet = nodeUtil &amp;&amp; nodeUtil.isSet, nodeIsTypedArray = nodeUtil &amp;&amp; nodeUtil.isTypedArray; /————————————————————————–/ / A faster alternative to Function#apply, this function invokes func with the this binding of thisArg and the arguments of args. @private @param {Function} func The function to invoke. @param {} thisArg The this binding of func. @param {Array} args The arguments to invoke func with. @returns {} Returns the result of func. */ function apply(func, thisArg, args) { switch (args.length) { case 0: return func.call(thisArg); case 1: return func.call(thisArg, args[0]); case 2: return func.call(thisArg, args[0], args[1]); case 3: return func.call(thisArg, args[0], args[1], args[2]); } return func.apply(thisArg, args); } / A specialized version of baseAggregator for arrays. @private @param {Array} [array] The array to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform keys. @param {Object} accumulator The initial aggregated object. @returns {Function} Returns accumulator. / function arrayAggregator(array, setter, iteratee, accumulator) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { var value = array[index]; setter(accumulator, value, iteratee(value), array); } return accumulator; } /** A specialized version of _.forEach for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns array. / function arrayEach(array, iteratee) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (iteratee(array[index], index, array) === false) { break; } } return array; } /** A specialized version of _.forEachRight for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns array. / function arrayEachRight(array, iteratee) { var length = array == null ? 0 : array.length; while (length–) { if (iteratee(array[length], length, array) === false) { break; } } return array; } /** A specialized version of _.every for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if all elements pass the predicate check, else false. / function arrayEvery(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (!predicate(array[index], index, array)) { return false; } } return true; } / A specialized version of _.filter for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {Array} Returns the new filtered array. / function arrayFilter(array, predicate) { var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (predicate(value, index, array)) { result[resIndex++] = value; } } return result; } / A specialized version of _.includes for arrays without support for specifying an index to search from. @private @param {Array} [array] The array to inspect. @param {} target The value to search for. @returns {boolean} Returns true if target is found, else false. / function arrayIncludes(array, value) { var length = array == null ? 0 : array.length; return !!length &amp;&amp; baseIndexOf(array, value, 0) &gt; -1; } /** This function is like arrayIncludes except that it accepts a comparator. @private @param {Array} [array] The array to inspect. @param {} target The value to search for. @param {Function} comparator The comparator invoked per element. @returns {boolean} Returns true if target is found, else false. / function arrayIncludesWith(array, value, comparator) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (comparator(value, array[index])) { return true; } } return false; } / A specialized version of _.map for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the new mapped array. / function arrayMap(array, iteratee) { var index = -1, length = array == null ? 0 : array.length, result = Array(length); while (++index &lt; length) { result[index] = iteratee(array[index], index, array); } return result; } / Appends the elements of values to array. @private @param {Array} array The array to modify. @param {Array} values The values to append. @returns {Array} Returns array. / function arrayPush(array, values) { var index = -1, length = values.length, offset = array.length; while (++index &lt; length) { array[offset + index] = values[index]; } return array; } /** A specialized version of _.reduce for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} [accumulator] The initial value. @param {boolean} [initAccum] Specify using the first element of array as the initial value. @returns {} Returns the accumulated value. / function arrayReduce(array, iteratee, accumulator, initAccum) { var index = -1, length = array == null ? 0 : array.length; if (initAccum &amp;&amp; length) { accumulator = array[++index]; } while (++index &lt; length) { accumulator = iteratee(accumulator, array[index], index, array); } return accumulator; } / A specialized version of _.reduceRight for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} [accumulator] The initial value. @param {boolean} [initAccum] Specify using the last element of array as the initial value. @returns {} Returns the accumulated value. */ function arrayReduceRight(array, iteratee, accumulator, initAccum) { var length = array == null ? 0 : array.length; if (initAccum &amp;&amp; length) { accumulator = array[–length]; } while (length–) { accumulator = iteratee(accumulator, array[length], length, array); } return accumulator; } / A specialized version of _.some for arrays without support for iteratee shorthands. @private @param {Array} [array] The array to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if any element passes the predicate check, else false. / function arraySome(array, predicate) { var index = -1, length = array == null ? 0 : array.length; while (++index &lt; length) { if (predicate(array[index], index, array)) { return true; } } return false; } /** Gets the size of an ASCII string. @private @param {string} string The string inspect. @returns {number} Returns the string size. / var asciiSize = baseProperty(‘length’); /** Converts an ASCII string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function asciiToArray(string) { return string.split(‘’); } /** Splits an ASCII string into an array of its words. @private @param {string} The string to inspect. @returns {Array} Returns the words of string. / function asciiWords(string) { return string.match(reAsciiWord) || []; } /** The base implementation of methods like _.findKey and _.findLastKey, without support for iteratee shorthands, which iterates over collection using eachFunc. @private @param {Array|Object} collection The collection to inspect. @param {Function} predicate The function invoked per iteration. @param {Function} eachFunc The function to iterate over collection. @returns {} Returns the found element or its key, else undefined. / function baseFindKey(collection, predicate, eachFunc) { var result; eachFunc(collection, function(value, key, collection) { if (predicate(value, key, collection)) { result = key; return false; } }); return result; } / The base implementation of _.findIndex and _.findLastIndex without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} predicate The function invoked per iteration. @param {number} fromIndex The index to search from. @param {boolean} [fromRight] Specify iterating from right to left. @returns {number} Returns the index of the matched value, else -1. / function baseFindIndex(array, predicate, fromIndex, fromRight) { var length = array.length, index = fromIndex + (fromRight ? 1 : -1); while ((fromRight ? index– : ++index &lt; length)) { if (predicate(array[index], index, array)) { return index; } } return -1; } / The base implementation of _.indexOf without fromIndex bounds checks. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function baseIndexOf(array, value, fromIndex) { return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex); } /** This function is like baseIndexOf except that it accepts a comparator. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @param {Function} comparator The comparator invoked per element. @returns {number} Returns the index of the matched value, else -1. / function baseIndexOfWith(array, value, fromIndex, comparator) { var index = fromIndex - 1, length = array.length; while (++index &lt; length) { if (comparator(array[index], value)) { return index; } } return -1; } /** The base implementation of _.isNaN without support for number objects. @private @param {} value The value to check. @returns {boolean} Returns true if value is NaN, else false. / function baseIsNaN(value) { return value !== value; } / The base implementation of _.mean and _.meanBy without support for iteratee shorthands. @private @param {Array} array The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {number} Returns the mean. / function baseMean(array, iteratee) { var length = array == null ? 0 : array.length; return length ? (baseSum(array, iteratee) / length) : NAN; } / The base implementation of _.property without support for deep paths. @private @param {string} key The key of the property to get. @returns {Function} Returns the new accessor function. / function baseProperty(key) { return function(object) { return object == null ? undefined : object[key]; }; } / The base implementation of _.propertyOf without support for deep paths. @private @param {Object} object The object to query. @returns {Function} Returns the new accessor function. / function basePropertyOf(object) { return function(key) { return object == null ? undefined : object[key]; }; } / The base implementation of _.reduce and _.reduceRight, without support for iteratee shorthands, which iterates over collection using eachFunc. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @param {} accumulator The initial value. @param {boolean} initAccum Specify using the first or last element of collection as the initial value. @param {Function} eachFunc The function to iterate over collection. @returns {} Returns the accumulated value. / function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) { eachFunc(collection, function(value, index, collection) { accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection); }); return accumulator; } / The base implementation of _.sortBy which uses comparer to define the sort order of array and replaces criteria objects with their corresponding values. @private @param {Array} array The array to sort. @param {Function} comparer The function to define sort order. @returns {Array} Returns array. */ function baseSortBy(array, comparer) { var length = array.length; array.sort(comparer); while (length–) { array[length] = array[length].value; } return array; } / The base implementation of _.sum and _.sumBy without support for iteratee shorthands. @private @param {Array} array The array to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {number} Returns the sum. / function baseSum(array, iteratee) { var result, index = -1, length = array.length; while (++index &lt; length) { var current = iteratee(array[index]); if (current !== undefined) { result = result === undefined ? current : (result + current); } } return result; } / The base implementation of _.times without support for iteratee shorthands or max array length checks. @private @param {number} n The number of times to invoke iteratee. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the array of results. / function baseTimes(n, iteratee) { var index = -1, result = Array(n); while (++index &lt; n) { result[index] = iteratee(index); } return result; } / The base implementation of _.toPairs and _.toPairsIn which creates an array of key-value pairs for object corresponding to the property names of props. @private @param {Object} object The object to query. @param {Array} props The property names to get values for. @returns {Object} Returns the key-value pairs. / function baseToPairs(object, props) { return arrayMap(props, function(key) { return [key, object[key]]; }); } / The base implementation of _.unary without support for storing metadata. @private @param {Function} func The function to cap arguments for. @returns {Function} Returns the new capped function. / function baseUnary(func) { return function(value) { return func(value); }; } / The base implementation of _.values and _.valuesIn which creates an array of object property values corresponding to the property names of props. @private @param {Object} object The object to query. @param {Array} props The property names to get values for. @returns {Object} Returns the array of property values. / function baseValues(object, props) { return arrayMap(props, function(key) { return object[key]; }); } /** Checks if a cache value for key exists. @private @param {Object} cache The cache to query. @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function cacheHas(cache, key) { return cache.has(key); } / Used by _.trim and _.trimStart to get the index of the first string symbol that is not found in the character symbols. @private @param {Array} strSymbols The string symbols to inspect. @param {Array} chrSymbols The character symbols to find. @returns {number} Returns the index of the first unmatched string symbol. / function charsStartIndex(strSymbols, chrSymbols) { var index = -1, length = strSymbols.length; while (++index &lt; length &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], 0) &gt; -1) {} return index; } / Used by _.trim and _.trimEnd to get the index of the last string symbol that is not found in the character symbols. @private @param {Array} strSymbols The string symbols to inspect. @param {Array} chrSymbols The character symbols to find. @returns {number} Returns the index of the last unmatched string symbol. / function charsEndIndex(strSymbols, chrSymbols) { var index = strSymbols.length; while (index– &amp;&amp; baseIndexOf(chrSymbols, strSymbols[index], 0) &gt; -1) {} return index; } / Gets the number of placeholder occurrences in array. @private @param {Array} array The array to inspect. @param {} placeholder The placeholder to search for. @returns {number} Returns the placeholder count. / function countHolders(array, placeholder) { var length = array.length, result = 0; while (length–) { if (array[length] === placeholder) { ++result; } } return result; } / Used by _.deburr to convert Latin-1 Supplement and Latin Extended-A letters to basic Latin letters. @private @param {string} letter The matched letter to deburr. @returns {string} Returns the deburred letter. / var deburrLetter = basePropertyOf(deburredLetters); /** Used by _.escape to convert characters to HTML entities. @private @param {string} chr The matched character to escape. @returns {string} Returns the escaped character. / var escapeHtmlChar = basePropertyOf(htmlEscapes); /** Used by _.template to escape characters for inclusion in compiled string literals. @private @param {string} chr The matched character to escape. @returns {string} Returns the escaped character. / function escapeStringChar(chr) { return ‘\‘ + stringEscapes[chr]; } /** Gets the value at key of object. @private @param {Object} [object] The object to query. @param {string} key The key of the property to get. @returns {} Returns the property value. / function getValue(object, key) { return object == null ? undefined : object[key]; } /** Checks if string contains Unicode symbols. @private @param {string} string The string to inspect. @returns {boolean} Returns true if a symbol is found, else false. / function hasUnicode(string) { return reHasUnicode.test(string); } /** Checks if string contains a word composed of Unicode symbols. @private @param {string} string The string to inspect. @returns {boolean} Returns true if a word is found, else false. / function hasUnicodeWord(string) { return reHasUnicodeWord.test(string); } /** Converts iterator to an array. @private @param {Object} iterator The iterator to convert. @returns {Array} Returns the converted array. / function iteratorToArray(iterator) { var data, result = []; while (!(data = iterator.next()).done) { result.push(data.value); } return result; } /** Converts map to its key-value pairs. @private @param {Object} map The map to convert. @returns {Array} Returns the key-value pairs. / function mapToArray(map) { var index = -1, result = Array(map.size); map.forEach(function(value, key) { result[++index] = [key, value]; }); return result; } /** Creates a unary function that invokes func with its argument transformed. @private @param {Function} func The function to wrap. @param {Function} transform The argument transform. @returns {Function} Returns the new function. / function overArg(func, transform) { return function(arg) { return func(transform(arg)); }; } / Replaces all placeholder elements in array with an internal placeholder and returns an array of their indexes. @private @param {Array} array The array to modify. @param {} placeholder The placeholder to replace. @returns {Array} Returns the new array of placeholder indexes. */ function replaceHolders(array, placeholder) { var index = -1, length = array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (value === placeholder || value === PLACEHOLDER) { array[index] = PLACEHOLDER; result[resIndex++] = index; } } return result; } / Converts set to an array of its values. @private @param {Object} set The set to convert. @returns {Array} Returns the values. / function setToArray(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = value; }); return result; } / Converts set to its value-value pairs. @private @param {Object} set The set to convert. @returns {Array} Returns the value-value pairs. / function setToPairs(set) { var index = -1, result = Array(set.size); set.forEach(function(value) { result[++index] = [value, value]; }); return result; } / A specialized version of _.indexOf which performs strict equality comparisons of values, i.e. ===. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function strictIndexOf(array, value, fromIndex) { var index = fromIndex - 1, length = array.length; while (++index &lt; length) { if (array[index] === value) { return index; } } return -1; } / A specialized version of _.lastIndexOf which performs strict equality comparisons of values, i.e. ===. @private @param {Array} array The array to inspect. @param {} value The value to search for. @param {number} fromIndex The index to search from. @returns {number} Returns the index of the matched value, else -1. / function strictLastIndexOf(array, value, fromIndex) { var index = fromIndex + 1; while (index–) { if (array[index] === value) { return index; } } return index; } / Gets the number of symbols in string. @private @param {string} string The string to inspect. @returns {number} Returns the string size. / function stringSize(string) { return hasUnicode(string) ? unicodeSize(string) : asciiSize(string); } / Converts string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function stringToArray(string) { return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string); } / Used by _.unescape to convert HTML entities to characters. @private @param {string} chr The matched character to unescape. @returns {string} Returns the unescaped character. / var unescapeHtmlChar = basePropertyOf(htmlUnescapes); / Gets the size of a Unicode string. @private @param {string} string The string inspect. @returns {number} Returns the string size. / function unicodeSize(string) { var result = reUnicode.lastIndex = 0; while (reUnicode.test(string)) { ++result; } return result; } / Converts a Unicode string to an array. @private @param {string} string The string to convert. @returns {Array} Returns the converted array. / function unicodeToArray(string) { return string.match(reUnicode) || []; } / Splits a Unicode string into an array of its words. @private @param {string} The string to inspect. @returns {Array} Returns the words of string. / function unicodeWords(string) { return string.match(reUnicodeWord) || []; } /————————————————————————–/ / Create a new pristine lodash function using the context object. @static @memberOf _ @since 1.1.0 @category Util @param {Object} [context=root] The context object. @returns {Function} Returns a new lodash function. @example _.mixin({ ‘foo’: _.constant(‘foo’) }); var lodash = _.runInContext(); lodash.mixin({ ‘bar’: lodash.constant(‘bar’) }); .isFunction(.foo); // =&gt; true .isFunction(.bar); // =&gt; false lodash.isFunction(lodash.foo); // =&gt; false lodash.isFunction(lodash.bar); // =&gt; true // Create a suped-up defer in Node.js. var defer = _.runInContext({ ‘setTimeout’: setImmediate }).defer; / var runInContext = (function runInContext(context) { context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps)); / Built-in constructor references. */ var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError; / Used for built-in method references. / var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype; /** Used to detect overreaching core-js shims. / var coreJsData = context[‘core-js_shared‘]; / Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString; / Used to check objects for own properties. / var hasOwnProperty = objectProto.hasOwnProperty; /** Used to generate unique IDs. / var idCounter = 0; / Used to detect methods masquerading as native. */ var maskSrcKey = (function() { var uid = /[^.]+$/.exec(coreJsData &amp;&amp; coreJsData.keys &amp;&amp; coreJsData.keys.IE_PROTO || ‘’); return uid ? (‘Symbol(src)_1.’ + uid) : ‘’; }()); / Used to resolve the toStringTag of values. / var nativeObjectToString = objectProto.toString; / Used to infer the Object constructor. */ var objectCtorString = funcToString.call(Object); / Used to restore the original _ reference in _.noConflict. / var oldDash = root._; /** Used to detect if a method is native. / var reIsNative = RegExp(‘^’ + funcToString.call(hasOwnProperty).replace(reRegExpChar, ‘\$&amp;’) .replace(/hasOwnProperty|(function).?(?=\()| for .+?(?=\])/g, ‘$1.?’) + ‘$’ ); / Built-in value references. */ var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined; var defineProperty = (function() { try { var func = getNative(Object, ‘defineProperty’); func({}, ‘’, {}); return func; } catch (e) {} }()); / Mocked built-ins. / var ctxClearTimeout = context.clearTimeout !== root.clearTimeout &amp;&amp; context.clearTimeout, ctxNow = Date &amp;&amp; Date.now !== root.Date.now &amp;&amp; Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout &amp;&amp; context.setTimeout; / Built-in method references for those with the same name as other lodash methods. / var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse; / Built-in method references that are verified to be native. / var DataView = getNative(context, ‘DataView’), Map = getNative(context, ‘Map’), Promise = getNative(context, ‘Promise’), Set = getNative(context, ‘Set’), WeakMap = getNative(context, ‘WeakMap’), nativeCreate = getNative(Object, ‘create’); /** Used to store function metadata. / var metaMap = WeakMap &amp;&amp; new WeakMap; / Used to lookup unminified function names. */ var realNames = {}; / Used to detect maps, sets, and weakmaps. / var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap); /** Used to convert symbols to primitives and strings. / var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined; /————————————————————————/ / Creates a lodash object which wraps value to enable implicit method chain sequences. Methods that operate on and return arrays, collections, and functions can be chained together. Methods that retrieve a single value or may return a primitive value will automatically end the chain sequence and return the unwrapped value. Otherwise, the value must be unwrapped with _#value. Explicit chain sequences, which must be unwrapped with _#value, may be enabled using _.chain. The execution of chained methods is lazy, that is, it’s deferred until _#value is implicitly or explicitly called. Lazy evaluation allows several methods to support shortcut fusion. Shortcut fusion is an optimization to merge iteratee calls; this avoids the creation of intermediate arrays and can greatly reduce the number of iteratee executions. Sections of a chain sequence qualify for shortcut fusion if the section is applied to an array and iteratees accept only one argument. The heuristic for whether a section qualifies for shortcut fusion is subject to change. Chaining is supported in custom builds as long as the _#value method is directly or indirectly included in the build. In addition to lodash methods, wrappers have Array and String methods. The wrapper Array methods are: concat, join, pop, push, shift, sort, splice, and unshift The wrapper String methods are: replace and split The wrapper methods that support shortcut fusion are: at, compact, drop, dropRight, dropWhile, filter, find, findLast, head, initial, last, map, reject, reverse, slice, tail, take, takeRight, takeRightWhile, takeWhile, and toArray The chainable wrapper methods are: after, ary, assign, assignIn, assignInWith, assignWith, at, before, bind, bindAll, bindKey, castArray, chain, chunk, commit, compact, concat, conforms, constant, countBy, create, curry, debounce, defaults, defaultsDeep, defer, delay, difference, differenceBy, differenceWith, drop, dropRight, dropRightWhile, dropWhile, extend, extendWith, fill, filter, flatMap, flatMapDeep, flatMapDepth, flatten, flattenDeep, flattenDepth, flip, flow, flowRight, fromPairs, functions, functionsIn, groupBy, initial, intersection, intersectionBy, intersectionWith, invert, invertBy, invokeMap, iteratee, keyBy, keys, keysIn, map, mapKeys, mapValues, matches, matchesProperty, memoize, merge, mergeWith, method, methodOf, mixin, negate, nthArg, omit, omitBy, once, orderBy, over, overArgs, overEvery, overSome, partial, partialRight, partition, pick, pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy, pullAllWith, pullAt, push, range, rangeRight, rearg, reject, remove, rest, reverse, sampleSize, set, setWith, shuffle, slice, sort, sortBy, splice, spread, tail, take, takeRight, takeRightWhile, takeWhile, tap, throttle, thru, toArray, toPairs, toPairsIn, toPath, toPlainObject, transform, unary, union, unionBy, unionWith, uniq, uniqBy, uniqWith, unset, unshift, unzip, unzipWith, update, updateWith, values, valuesIn, without, wrap, xor, xorBy, xorWith, zip, zipObject, zipObjectDeep, and zipWith The wrapper methods that are not chainable by default are: add, attempt, camelCase, capitalize, ceil, clamp, clone, cloneDeep, cloneDeepWith, cloneWith, conformsTo, deburr, defaultTo, divide, each, eachRight, endsWith, eq, escape, escapeRegExp, every, find, findIndex, findKey, findLast, findLastIndex, findLastKey, first, floor, forEach, forEachRight, forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has, hasIn, head, identity, includes, indexOf, inRange, invoke, isArguments, isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual, isEqualWith, isError, isFinite, isFunction, isInteger, isLength, isMap, isMatch, isMatchWith, isNaN, isNative, isNil, isNull, isNumber, isObject, isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet, isString, isUndefined, isTypedArray, isWeakMap, isWeakSet, join, kebabCase, last, lastIndexOf, lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy, min, minBy, multiply, noConflict, noop, now, nth, pad, padEnd, padStart, parseInt, pop, random, reduce, reduceRight, repeat, result, round, runInContext, sample, shift, size, snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex, sortedLastIndexBy, startCase, startsWith, stubArray, stubFalse, stubObject, stubString, stubTrue, subtract, sum, sumBy, template, times, toFinite, toInteger, toJSON, toLength, toLower, toNumber, toSafeInteger, toString, toUpper, trim, trimEnd, trimStart, truncate, unescape, uniqueId, upperCase, upperFirst, value, and words @name _ @constructor @category Seq @param {} value The value to wrap in a lodash instance. @returns {Object} Returns the new lodash wrapper instance. @example function square(n) { return n n; } var wrapped = ([1, 2, 3]); // Returns an unwrapped value. * wrapped.reduce(.add); // =&gt; 6 // Returns a wrapped value. var squares = wrapped.map(square); _.isArray(squares); // =&gt; false _.isArray(squares.value()); // =&gt; true */ function lodash(value) { if (isObjectLike(value) &amp;&amp; !isArray(value) &amp;&amp; !(value instanceof LazyWrapper)) { if (value instanceof LodashWrapper) { return value; } if (hasOwnProperty.call(value, ‘wrapped‘)) { return wrapperClone(value); } } return new LodashWrapper(value); } / The base implementation of _.create without support for assigning properties to the created object. @private @param {Object} proto The object to inherit from. @returns {Object} Returns the new object. / var baseCreate = (function() { function object() {} return function(proto) { if (!isObject(proto)) { return {}; } if (objectCreate) { return objectCreate(proto); } object.prototype = proto; var result = new object; object.prototype = undefined; return result; }; }()); /** The function whose prototype chain sequence wrappers inherit from. @private / function baseLodash() { // No operation performed. } /** The base constructor for creating lodash wrapper objects. @private @param {} value The value to wrap. @param {boolean} [chainAll] Enable explicit method chain sequences. / function LodashWrapper(value, chainAll) { this.wrapped = value; this.actions = []; this.chain = !!chainAll; this.index = 0; this.values = undefined; } / By default, the template delimiters used by lodash are like those in embedded Ruby (ERB) as well as ES2015 template strings. Change the following template settings to use alternative delimiters. @static @memberOf _ @type {Object} / lodash.templateSettings = { / Used to detect data property values to be HTML-escaped. @memberOf _.templateSettings @type {RegExp} / ‘escape’: reEscape, /** Used to detect code to be evaluated. @memberOf _.templateSettings @type {RegExp} / ‘evaluate’: reEvaluate, / Used to detect data property values to inject. @memberOf _.templateSettings @type {RegExp} */ ‘interpolate’: reInterpolate, / Used to reference the data object in the template text. @memberOf _.templateSettings @type {string} / ‘variable’: ‘’, /** Used to import variables into the compiled template. @memberOf _.templateSettings @type {Object} / ‘imports’: { / A reference to the lodash function. @memberOf _.templateSettings.imports @type {Function} / ‘_’: lodash } }; // Ensure wrappers are instances of baseLodash. lodash.prototype = baseLodash.prototype; lodash.prototype.constructor = lodash; LodashWrapper.prototype = baseCreate(baseLodash.prototype); LodashWrapper.prototype.constructor = LodashWrapper; /————————————————————————*/ / Creates a lazy wrapper object which wraps value to enable lazy evaluation. @private @constructor @param {} value The value to wrap. / function LazyWrapper(value) { this.wrapped = value; this.actions = []; this.dir = 1; this.filtered = false; this.iteratees = []; this.takeCount = MAX_ARRAY_LENGTH; this.views = []; } /** Creates a clone of the lazy wrapper object. @private @name clone @memberOf LazyWrapper @returns {Object} Returns the cloned LazyWrapper object. / function lazyClone() { var result = new LazyWrapper(this.wrapped); result.actions = copyArray(this.actions); result.dir = this.dir; result.filtered = this.filtered; result.iteratees = copyArray(this.iteratees); result.takeCount = this.takeCount; result.views = copyArray(this.views); return result; } / Reverses the direction of lazy iteration. @private @name reverse @memberOf LazyWrapper @returns {Object} Returns the new reversed LazyWrapper object. / function lazyReverse() { if (this.filtered) { var result = new LazyWrapper(this); result.dir = -1; result.filtered = true; } else { result = this.clone(); result.dir = -1; } return result; } / Extracts the unwrapped value from its lazy wrapper. @private @name value @memberOf LazyWrapper @returns {} Returns the unwrapped value. / function lazyValue() { var array = this.wrapped.value(), dir = this.dir, isArr = isArray(array), isRight = dir &lt; 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.views), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.iteratees, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.takeCount); if (!isArr || (!isRight &amp;&amp; arrLength == length &amp;&amp; takeCount == length)) { return baseWrapperValue(array, this.actions); } var result = []; outer: while (length– &amp;&amp; resIndex &lt; takeCount) { index += dir; var iterIndex = -1, value = array[index]; while (++iterIndex &lt; iterLength) { var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value); if (type == LAZY_MAP_FLAG) { value = computed; } else if (!computed) { if (type == LAZY_FILTER_FLAG) { continue outer; } else { break outer; } } } result[resIndex++] = value; } return result; } // Ensure LazyWrapper is an instance of baseLodash. LazyWrapper.prototype = baseCreate(baseLodash.prototype); LazyWrapper.prototype.constructor = LazyWrapper; /————————————————————————/ / Creates a hash object. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function Hash(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } / Removes all key-value entries from the hash. @private @name clear @memberOf Hash / function hashClear() { this.data = nativeCreate ? nativeCreate(null) : {}; this.size = 0; } / Removes key and its value from the hash. @private @name delete @memberOf Hash @param {Object} hash The hash to modify. @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. */ function hashDelete(key) { var result = this.has(key) &amp;&amp; delete this.data[key]; this.size -= result ? 1 : 0; return result; } / Gets the hash value for key. @private @name get @memberOf Hash @param {string} key The key of the value to get. @returns {} Returns the entry value. / function hashGet(key) { var data = this.data; if (nativeCreate) { var result = data[key]; return result === HASH_UNDEFINED ? undefined : result; } return hasOwnProperty.call(data, key) ? data[key] : undefined; } /** Checks if a hash value for key exists. @private @name has @memberOf Hash @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function hashHas(key) { var data = this.data; return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key); } /** Sets the hash key to value. @private @name set @memberOf Hash @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the hash instance. / function hashSet(key, value) { var data = this.data; this.size += this.has(key) ? 0 : 1; data[key] = (nativeCreate &amp;&amp; value === undefined) ? HASH_UNDEFINED : value; return this; } // Add methods to Hash. Hash.prototype.clear = hashClear; Hash.prototype[‘delete’] = hashDelete; Hash.prototype.get = hashGet; Hash.prototype.has = hashHas; Hash.prototype.set = hashSet; /————————————————————————/ /** Creates an list cache object. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function ListCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } /** Removes all key-value entries from the list cache. @private @name clear @memberOf ListCache / function listCacheClear() { this.data = []; this.size = 0; } /** Removes key and its value from the list cache. @private @name delete @memberOf ListCache @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function listCacheDelete(key) { var data = this.data, index = assocIndexOf(data, key); if (index &lt; 0) { return false; } var lastIndex = data.length - 1; if (index == lastIndex) { data.pop(); } else { splice.call(data, index, 1); } –this.size; return true; } /** Gets the list cache value for key. @private @name get @memberOf ListCache @param {string} key The key of the value to get. @returns {} Returns the entry value. / function listCacheGet(key) { var data = this.data, index = assocIndexOf(data, key); return index &lt; 0 ? undefined : data[index][1]; } / Checks if a list cache value for key exists. @private @name has @memberOf ListCache @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function listCacheHas(key) { return assocIndexOf(this.data, key) &gt; -1; } / Sets the list cache key to value. @private @name set @memberOf ListCache @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the list cache instance. / function listCacheSet(key, value) { var data = this.data, index = assocIndexOf(data, key); if (index &lt; 0) { ++this.size; data.push([key, value]); } else { data[index][1] = value; } return this; } // Add methods to ListCache. ListCache.prototype.clear = listCacheClear; ListCache.prototype[‘delete’] = listCacheDelete; ListCache.prototype.get = listCacheGet; ListCache.prototype.has = listCacheHas; ListCache.prototype.set = listCacheSet; /————————————————————————/ / Creates a map cache object to store key-value pairs. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function MapCache(entries) { var index = -1, length = entries == null ? 0 : entries.length; this.clear(); while (++index &lt; length) { var entry = entries[index]; this.set(entry[0], entry[1]); } } / Removes all key-value entries from the map. @private @name clear @memberOf MapCache / function mapCacheClear() { this.size = 0; this.data = { ‘hash’: new Hash, ‘map’: new (Map || ListCache), ‘string’: new Hash }; } / Removes key and its value from the map. @private @name delete @memberOf MapCache @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function mapCacheDelete(key) { var result = getMapData(this, key)‘delete’; this.size -= result ? 1 : 0; return result; } / Gets the map value for key. @private @name get @memberOf MapCache @param {string} key The key of the value to get. @returns {} Returns the entry value. / function mapCacheGet(key) { return getMapData(this, key).get(key); } /** Checks if a map value for key exists. @private @name has @memberOf MapCache @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function mapCacheHas(key) { return getMapData(this, key).has(key); } /** Sets the map key to value. @private @name set @memberOf MapCache @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the map cache instance. / function mapCacheSet(key, value) { var data = getMapData(this, key), size = data.size; data.set(key, value); this.size += data.size == size ? 0 : 1; return this; } // Add methods to MapCache. MapCache.prototype.clear = mapCacheClear; MapCache.prototype[‘delete’] = mapCacheDelete; MapCache.prototype.get = mapCacheGet; MapCache.prototype.has = mapCacheHas; MapCache.prototype.set = mapCacheSet; /————————————————————————/ /** Creates an array cache object to store unique values. @private @constructor @param {Array} [values] The values to cache. / function SetCache(values) { var index = -1, length = values == null ? 0 : values.length; this.data = new MapCache; while (++index &lt; length) { this.add(values[index]); } } / Adds value to the array cache. @private @name add @memberOf SetCache @alias push @param {} value The value to cache. @returns {Object} Returns the cache instance. / function setCacheAdd(value) { this.data.set(value, HASH_UNDEFINED); return this; } / Checks if value is in the array cache. @private @name has @memberOf SetCache @param {} value The value to search for. @returns {number} Returns true if value is found, else false. / function setCacheHas(value) { return this.data.has(value); } // Add methods to SetCache. SetCache.prototype.add = SetCache.prototype.push = setCacheAdd; SetCache.prototype.has = setCacheHas; /————————————————————————/ /** Creates a stack cache object to store key-value pairs. @private @constructor @param {Array} [entries] The key-value pairs to cache. / function Stack(entries) { var data = this.data = new ListCache(entries); this.size = data.size; } /** Removes all key-value entries from the stack. @private @name clear @memberOf Stack / function stackClear() { this.data = new ListCache; this.size = 0; } /** Removes key and its value from the stack. @private @name delete @memberOf Stack @param {string} key The key of the value to remove. @returns {boolean} Returns true if the entry was removed, else false. / function stackDelete(key) { var data = this.data, result = data‘delete’; this.size = data.size; return result; } /** Gets the stack value for key. @private @name get @memberOf Stack @param {string} key The key of the value to get. @returns {} Returns the entry value. / function stackGet(key) { return this.data.get(key); } / Checks if a stack value for key exists. @private @name has @memberOf Stack @param {string} key The key of the entry to check. @returns {boolean} Returns true if an entry for key exists, else false. / function stackHas(key) { return this.data.has(key); } / Sets the stack key to value. @private @name set @memberOf Stack @param {string} key The key of the value to set. @param {} value The value to set. @returns {Object} Returns the stack cache instance. / function stackSet(key, value) { var data = this.data; if (data instanceof ListCache) { var pairs = data.data; if (!Map || (pairs.length &lt; LARGE_ARRAY_SIZE - 1)) { pairs.push([key, value]); this.size = ++data.size; return this; } data = this.data = new MapCache(pairs); } data.set(key, value); this.size = data.size; return this; } // Add methods to Stack. Stack.prototype.clear = stackClear; Stack.prototype[‘delete’] = stackDelete; Stack.prototype.get = stackGet; Stack.prototype.has = stackHas; Stack.prototype.set = stackSet; /————————————————————————/ / Creates an array of the enumerable property names of the array-like value. @private @param {} value The value to query. @param {boolean} inherited Specify returning inherited property names. @returns {Array} Returns the array of property names. / function arrayLikeKeys(value, inherited) { var isArr = isArray(value), isArg = !isArr &amp;&amp; isArguments(value), isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value), isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) { if ((inherited || hasOwnProperty.call(value, key)) &amp;&amp; !(skipIndexes &amp;&amp; ( // Safari 9 has enumerable arguments.length in strict mode. key == ‘length’ || // Node.js 0.10 has enumerable non-index properties on buffers. (isBuff &amp;&amp; (key == ‘offset’ || key == ‘parent’)) || // PhantomJS 2 has enumerable non-index properties on typed arrays. (isType &amp;&amp; (key == ‘buffer’ || key == ‘byteLength’ || key == ‘byteOffset’)) || // Skip index properties. isIndex(key, length) ))) { result.push(key); } } return result; } / A specialized version of _.sample for arrays. @private @param {Array} array The array to sample. @returns {} Returns the random element. / function arraySample(array) { var length = array.length; return length ? array[baseRandom(0, length - 1)] : undefined; } /** A specialized version of _.sampleSize for arrays. @private @param {Array} array The array to sample. @param {number} n The number of elements to sample. @returns {Array} Returns the random elements. / function arraySampleSize(array, n) { return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length)); } / A specialized version of _.shuffle for arrays. @private @param {Array} array The array to shuffle. @returns {Array} Returns the new shuffled array. / function arrayShuffle(array) { return shuffleSelf(copyArray(array)); } / This function is like assignValue except that it doesn’t assign undefined values. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function assignMergeValue(object, key, value) { if ((value !== undefined &amp;&amp; !eq(object[key], value)) || (value === undefined &amp;&amp; !(key in object))) { baseAssignValue(object, key, value); } } /** Assigns value to key of object if the existing value is not equivalent using SameValueZero for equality comparisons. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function assignValue(object, key, value) { var objValue = object[key]; if (!(hasOwnProperty.call(object, key) &amp;&amp; eq(objValue, value)) || (value === undefined &amp;&amp; !(key in object))) { baseAssignValue(object, key, value); } } /** Gets the index at which the key is found in array of key-value pairs. @private @param {Array} array The array to inspect. @param {} key The key to search for. @returns {number} Returns the index of the matched value, else -1. / function assocIndexOf(array, key) { var length = array.length; while (length–) { if (eq(array[length][0], key)) { return length; } } return -1; } /** Aggregates elements of collection on accumulator with keys transformed by iteratee and values set by setter. @private @param {Array|Object} collection The collection to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform keys. @param {Object} accumulator The initial aggregated object. @returns {Function} Returns accumulator. / function baseAggregator(collection, setter, iteratee, accumulator) { baseEach(collection, function(value, key, collection) { setter(accumulator, value, iteratee(value), collection); }); return accumulator; } /** The base implementation of _.assign without support for multiple sources or customizer functions. @private @param {Object} object The destination object. @param {Object} source The source object. @returns {Object} Returns object. / function baseAssign(object, source) { return object &amp;&amp; copyObject(source, keys(source), object); } /** The base implementation of _.assignIn without support for multiple sources or customizer functions. @private @param {Object} object The destination object. @param {Object} source The source object. @returns {Object} Returns object. / function baseAssignIn(object, source) { return object &amp;&amp; copyObject(source, keysIn(source), object); } /** The base implementation of assignValue and assignMergeValue without value checks. @private @param {Object} object The object to modify. @param {string} key The key of the property to assign. @param {} value The value to assign. / function baseAssignValue(object, key, value) { if (key == ‘proto‘ &amp;&amp; defineProperty) { defineProperty(object, key, { ‘configurable’: true, ‘enumerable’: true, ‘value’: value, ‘writable’: true }); } else { object[key] = value; } } / The base implementation of _.at without support for individual paths. @private @param {Object} object The object to iterate over. @param {string[]} paths The property paths to pick. @returns {Array} Returns the picked elements. */ function baseAt(object, paths) { var index = -1, length = paths.length, result = Array(length), skip = object == null; while (++index &lt; length) { result[index] = skip ? undefined : get(object, paths[index]); } return result; } / The base implementation of _.clamp which doesn’t coerce arguments. @private @param {number} number The number to clamp. @param {number} [lower] The lower bound. @param {number} upper The upper bound. @returns {number} Returns the clamped number. / function baseClamp(number, lower, upper) { if (number === number) { if (upper !== undefined) { number = number &lt;= upper ? number : upper; } if (lower !== undefined) { number = number &gt;= lower ? number : lower; } } return number; } / The base implementation of _.clone and _.cloneDeep which tracks traversed objects. @private @param {} value The value to clone. @param {boolean} bitmask The bitmask flags. 1 - Deep clone 2 - Flatten inherited properties 4 - Clone symbols @param {Function} [customizer] The function to customize cloning. @param {string} [key] The key of value. @param {Object} [object] The parent object of value. @param {Object} [stack] Tracks traversed objects and their clone counterparts. @returns {} Returns the cloned value. */ function baseClone(value, bitmask, customizer, key, object, stack) { var result, isDeep = bitmask &amp; CLONE_DEEP_FLAG, isFlat = bitmask &amp; CLONE_FLAT_FLAG, isFull = bitmask &amp; CLONE_SYMBOLS_FLAG; if (customizer) { result = object ? customizer(value, key, object, stack) : customizer(value); } if (result !== undefined) { return result; } if (!isObject(value)) { return value; } var isArr = isArray(value); if (isArr) { result = initCloneArray(value); if (!isDeep) { return copyArray(value, result); } } else { var tag = getTag(value), isFunc = tag == funcTag || tag == genTag; if (isBuffer(value)) { return cloneBuffer(value, isDeep); } if (tag == objectTag || tag == argsTag || (isFunc &amp;&amp; !object)) { result = (isFlat || isFunc) ? {} : initCloneObject(value); if (!isDeep) { return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value)); } } else { if (!cloneableTags[tag]) { return object ? value : {}; } result = initCloneByTag(value, tag, isDeep); } } // Check for circular references and return its corresponding clone. stack || (stack = new Stack); var stacked = stack.get(value); if (stacked) { return stacked; } stack.set(value, result); if (isSet(value)) { value.forEach(function(subValue) { result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack)); }); return result; } if (isMap(value)) { value.forEach(function(subValue, key) { result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack)); }); return result; } var keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : (isFlat ? keysIn : keys); var props = isArr ? undefined : keysFunc(value); arrayEach(props || value, function(subValue, key) { if (props) { key = subValue; subValue = value[key]; } // Recursively populate clone (susceptible to call stack limits). assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack)); }); return result; } / The base implementation of _.conforms which doesn’t clone source. @private @param {Object} source The object of property predicates to conform to. @returns {Function} Returns the new spec function. / function baseConforms(source) { var props = keys(source); return function(object) { return baseConformsTo(object, source, props); }; } / The base implementation of _.conformsTo which accepts props to check. @private @param {Object} object The object to inspect. @param {Object} source The object of property predicates to conform to. @returns {boolean} Returns true if object conforms, else false. */ function baseConformsTo(object, source, props) { var length = props.length; if (object == null) { return !length; } object = Object(object); while (length–) { var key = props[length], predicate = source[key], value = object[key]; if ((value === undefined &amp;&amp; !(key in object)) || !predicate(value)) { return false; } } return true; } / The base implementation of _.delay and _.defer which accepts args to provide to func. @private @param {Function} func The function to delay. @param {number} wait The number of milliseconds to delay invocation. @param {Array} args The arguments to provide to func. @returns {number|Object} Returns the timer id or timeout object. / function baseDelay(func, wait, args) { if (typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } return setTimeout(function() { func.apply(undefined, args); }, wait); } /** The base implementation of methods like _.difference without support for excluding multiple arrays or iteratee shorthands. @private @param {Array} array The array to inspect. @param {Array} values The values to exclude. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of filtered values. / function baseDifference(array, values, iteratee, comparator) { var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length; if (!length) { return result; } if (iteratee) { values = arrayMap(values, baseUnary(iteratee)); } if (comparator) { includes = arrayIncludesWith; isCommon = false; } else if (values.length &gt;= LARGE_ARRAY_SIZE) { includes = cacheHas; isCommon = false; values = new SetCache(values); } outer: while (++index &lt; length) { var value = array[index], computed = iteratee == null ? value : iteratee(value); value = (comparator || value !== 0) ? value : 0; if (isCommon &amp;&amp; computed === computed) { var valuesIndex = valuesLength; while (valuesIndex–) { if (values[valuesIndex] === computed) { continue outer; } } result.push(value); } else if (!includes(values, computed, comparator)) { result.push(value); } } return result; } /** The base implementation of _.forEach without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array|Object} Returns collection. / var baseEach = createBaseEach(baseForOwn); / The base implementation of _.forEachRight without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array|Object} Returns collection. */ var baseEachRight = createBaseEach(baseForOwnRight, true); / The base implementation of _.every without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if all elements pass the predicate check, else false / function baseEvery(collection, predicate) { var result = true; baseEach(collection, function(value, index, collection) { result = !!predicate(value, index, collection); return result; }); return result; } / The base implementation of methods like _.max and _.min which accepts a comparator to determine the extremum value. @private @param {Array} array The array to iterate over. @param {Function} iteratee The iteratee invoked per iteration. @param {Function} comparator The comparator used to compare values. @returns {} Returns the extremum value. / function baseExtremum(array, iteratee, comparator) { var index = -1, length = array.length; while (++index &lt; length) { var value = array[index], current = iteratee(value); if (current != null &amp;&amp; (computed === undefined ? (current === current &amp;&amp; !isSymbol(current)) : comparator(current, computed) )) { var computed = current, result = value; } } return result; } / The base implementation of _.fill without an iteratee call guard. @private @param {Array} array The array to fill. @param {} value The value to fill array with. @param {number} [start=0] The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns array. / function baseFill(array, value, start, end) { var length = array.length; start = toInteger(start); if (start &lt; 0) { start = -start &gt; length ? 0 : (length + start); } end = (end === undefined || end &gt; length) ? length : toInteger(end); if (end &lt; 0) { end += length; } end = start &gt; end ? 0 : toLength(end); while (start &lt; end) { array[start++] = value; } return array; } / The base implementation of _.filter without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {Array} Returns the new filtered array. */ function baseFilter(collection, predicate) { var result = []; baseEach(collection, function(value, index, collection) { if (predicate(value, index, collection)) { result.push(value); } }); return result; } / The base implementation of _.flatten with support for restricting flattening. @private @param {Array} array The array to flatten. @param {number} depth The maximum recursion depth. @param {boolean} [predicate=isFlattenable] The function invoked per iteration. @param {boolean} [isStrict] Restrict to values that pass predicate checks. @param {Array} [result=[]] The initial result value. @returns {Array} Returns the new flattened array. / function baseFlatten(array, depth, predicate, isStrict, result) { var index = -1, length = array.length; predicate || (predicate = isFlattenable); result || (result = []); while (++index &lt; length) { var value = array[index]; if (depth &gt; 0 &amp;&amp; predicate(value)) { if (depth &gt; 1) { // Recursively flatten arrays (susceptible to call stack limits). baseFlatten(value, depth - 1, predicate, isStrict, result); } else { arrayPush(result, value); } } else if (!isStrict) { result[result.length] = value; } } return result; } / The base implementation of baseForOwn which iterates over object properties returned by keysFunc and invokes iteratee for each property. Iteratee functions may exit iteration early by explicitly returning false. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @param {Function} keysFunc The function to get the keys of object. @returns {Object} Returns object. / var baseFor = createBaseFor(); / This function is like baseFor except that it iterates over properties in the opposite order. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @param {Function} keysFunc The function to get the keys of object. @returns {Object} Returns object. / var baseForRight = createBaseFor(true); /** The base implementation of _.forOwn without support for iteratee shorthands. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Object} Returns object. / function baseForOwn(object, iteratee) { return object &amp;&amp; baseFor(object, iteratee, keys); } / The base implementation of _.forOwnRight without support for iteratee shorthands. @private @param {Object} object The object to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Object} Returns object. */ function baseForOwnRight(object, iteratee) { return object &amp;&amp; baseForRight(object, iteratee, keys); } / The base implementation of _.functions which creates an array of object function property names filtered from props. @private @param {Object} object The object to inspect. @param {Array} props The property names to filter. @returns {Array} Returns the function names. / function baseFunctions(object, props) { return arrayFilter(props, function(key) { return isFunction(object[key]); }); } / The base implementation of _.get without support for default values. @private @param {Object} object The object to query. @param {Array|string} path The path of the property to get. @returns {} Returns the resolved value. / function baseGet(object, path) { path = castPath(path, object); var index = 0, length = path.length; while (object != null &amp;&amp; index &lt; length) { object = object[toKey(path[index++])]; } return (index &amp;&amp; index == length) ? object : undefined; } / The base implementation of getAllKeys and getAllKeysIn which uses keysFunc and symbolsFunc to get the enumerable property names and symbols of object. @private @param {Object} object The object to query. @param {Function} keysFunc The function to get the keys of object. @param {Function} symbolsFunc The function to get the symbols of object. @returns {Array} Returns the array of property names and symbols. / function baseGetAllKeys(object, keysFunc, symbolsFunc) { var result = keysFunc(object); return isArray(object) ? result : arrayPush(result, symbolsFunc(object)); } / The base implementation of getTag without fallbacks for buggy environments. @private @param {} value The value to query. @returns {string} Returns the toStringTag. */ function baseGetTag(value) { if (value == null) { return value === undefined ? undefinedTag : nullTag; } return (symToStringTag &amp;&amp; symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value); } / The base implementation of _.gt which doesn’t coerce arguments. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {boolean} Returns true if value is greater than other, else false. / function baseGt(value, other) { return value &gt; other; } / The base implementation of _.has without support for deep paths. @private @param {Object} [object] The object to query. @param {Array|string} key The key to check. @returns {boolean} Returns true if key exists, else false. */ function baseHas(object, key) { return object != null &amp;&amp; hasOwnProperty.call(object, key); } / The base implementation of _.hasIn without support for deep paths. @private @param {Object} [object] The object to query. @param {Array|string} key The key to check. @returns {boolean} Returns true if key exists, else false. / function baseHasIn(object, key) { return object != null &amp;&amp; key in Object(object); } /** The base implementation of _.inRange which doesn’t coerce arguments. @private @param {number} number The number to check. @param {number} start The start of the range. @param {number} end The end of the range. @returns {boolean} Returns true if number is in the range, else false. / function baseInRange(number, start, end) { return number &gt;= nativeMin(start, end) &amp;&amp; number &lt; nativeMax(start, end); } /** The base implementation of methods like _.intersection, without support for iteratee shorthands, that accepts an array of arrays to inspect. @private @param {Array} arrays The arrays to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of shared values. / function baseIntersection(arrays, iteratee, comparator) { var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = []; while (othIndex–) { var array = arrays[othIndex]; if (othIndex &amp;&amp; iteratee) { array = arrayMap(array, baseUnary(iteratee)); } maxLength = nativeMin(array.length, maxLength); caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= 120 &amp;&amp; array.length &gt;= 120)) ? new SetCache(othIndex &amp;&amp; array) : undefined; } array = arrays[0]; var index = -1, seen = caches[0]; outer: while (++index &lt; length &amp;&amp; result.length &lt; maxLength) { var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator) )) { othIndex = othLength; while (–othIndex) { var cache = caches[othIndex]; if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)) ) { continue outer; } } if (seen) { seen.push(computed); } result.push(value); } } return result; } / The base implementation of _.invert and _.invertBy which inverts object with values transformed by iteratee and set by setter. @private @param {Object} object The object to iterate over. @param {Function} setter The function to set accumulator values. @param {Function} iteratee The iteratee to transform values. @param {Object} accumulator The initial inverted object. @returns {Function} Returns accumulator. / function baseInverter(object, setter, iteratee, accumulator) { baseForOwn(object, function(value, key, object) { setter(accumulator, iteratee(value), key, object); }); return accumulator; } / The base implementation of _.invoke without support for individual method arguments. @private @param {Object} object The object to query. @param {Array|string} path The path of the method to invoke. @param {Array} args The arguments to invoke the method with. @returns {} Returns the result of the invoked method. / function baseInvoke(object, path, args) { path = castPath(path, object); object = parent(object, path); var func = object == null ? object : object[toKey(last(path))]; return func == null ? undefined : apply(func, object, args); } / The base implementation of _.isArguments. @private @param {} value The value to check. @returns {boolean} Returns true if value is an arguments object, */ function baseIsArguments(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == argsTag; } / The base implementation of _.isArrayBuffer without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is an array buffer, else false. / function baseIsArrayBuffer(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == arrayBufferTag; } /** The base implementation of _.isDate without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a date object, else false. / function baseIsDate(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == dateTag; } / The base implementation of _.isEqual which supports partial comparisons and tracks traversed objects. @private @param {} value The value to compare. @param {} other The other value to compare. @param {boolean} bitmask The bitmask flags. 1 - Unordered comparison 2 - Partial comparison @param {Function} [customizer] The function to customize comparisons. @param {Object} [stack] Tracks traversed value and other objects. @returns {boolean} Returns true if the values are equivalent, else false. */ function baseIsEqual(value, other, bitmask, customizer, stack) { if (value === other) { return true; } if (value == null || other == null || (!isObjectLike(value) &amp;&amp; !isObjectLike(other))) { return value !== value &amp;&amp; other !== other; } return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack); } / A specialized version of baseIsEqual for arrays and objects which performs deep comparisons and tracks traversed objects enabling objects with circular references to be compared. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} [stack] Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) { var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other); objTag = objTag == argsTag ? objectTag : objTag; othTag = othTag == argsTag ? objectTag : othTag; var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag; if (isSameTag &amp;&amp; isBuffer(object)) { if (!isBuffer(other)) { return false; } objIsArr = true; objIsObj = false; } if (isSameTag &amp;&amp; !objIsObj) { stack || (stack = new Stack); return (objIsArr || isTypedArray(object)) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack); } if (!(bitmask &amp; COMPARE_PARTIAL_FLAG)) { var objIsWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, ‘wrapped‘), othIsWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, ‘wrapped‘); if (objIsWrapped || othIsWrapped) { var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other; stack || (stack = new Stack); return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack); } } if (!isSameTag) { return false; } stack || (stack = new Stack); return equalObjects(object, other, bitmask, customizer, equalFunc, stack); } /** The base implementation of _.isMap without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a map, else false. / function baseIsMap(value) { return isObjectLike(value) &amp;&amp; getTag(value) == mapTag; } / The base implementation of _.isMatch without support for iteratee shorthands. @private @param {Object} object The object to inspect. @param {Object} source The object of property values to match. @param {Array} matchData The property names, values, and compare flags to match. @param {Function} [customizer] The function to customize comparisons. @returns {boolean} Returns true if object is a match, else false. */ function baseIsMatch(object, source, matchData, customizer) { var index = matchData.length, length = index, noCustomizer = !customizer; if (object == null) { return !length; } object = Object(object); while (index–) { var data = matchData[index]; if ((noCustomizer &amp;&amp; data[2]) ? data[1] !== object[data[0]] : !(data[0] in object) ) { return false; } } while (++index &lt; length) { data = matchData[index]; var key = data[0], objValue = object[key], srcValue = data[1]; if (noCustomizer &amp;&amp; data[2]) { if (objValue === undefined &amp;&amp; !(key in object)) { return false; } } else { var stack = new Stack; if (customizer) { var result = customizer(objValue, srcValue, key, object, source, stack); } if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result )) { return false; } } } return true; } / The base implementation of _.isNative without bad shim checks. @private @param {} value The value to check. @returns {boolean} Returns true if value is a native function, else false. / function baseIsNative(value) { if (!isObject(value) || isMasked(value)) { return false; } var pattern = isFunction(value) ? reIsNative : reIsHostCtor; return pattern.test(toSource(value)); } / The base implementation of _.isRegExp without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a regexp, else false. */ function baseIsRegExp(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == regexpTag; } / The base implementation of _.isSet without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a set, else false. / function baseIsSet(value) { return isObjectLike(value) &amp;&amp; getTag(value) == setTag; } /** The base implementation of _.isTypedArray without Node.js optimizations. @private @param {} value The value to check. @returns {boolean} Returns true if value is a typed array, else false. / function baseIsTypedArray(value) { return isObjectLike(value) &amp;&amp; isLength(value.length) &amp;&amp; !!typedArrayTags[baseGetTag(value)]; } / The base implementation of _.iteratee. @private @param {} [value=_.identity] The value to convert to an iteratee. @returns {Function} Returns the iteratee. */ function baseIteratee(value) { // Don’t store the typeof result in a variable to avoid a JIT bug in Safari 9. // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details. if (typeof value == ‘function’) { return value; } if (value == null) { return identity; } if (typeof value == ‘object’) { return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value); } return property(value); } / The base implementation of _.keys which doesn’t treat sparse arrays as dense. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function baseKeys(object) { if (!isPrototype(object)) { return nativeKeys(object); } var result = []; for (var key in Object(object)) { if (hasOwnProperty.call(object, key) &amp;&amp; key != ‘constructor’) { result.push(key); } } return result; } / The base implementation of _.keysIn which doesn’t treat sparse arrays as dense. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function baseKeysIn(object) { if (!isObject(object)) { return nativeKeysIn(object); } var isProto = isPrototype(object), result = []; for (var key in object) { if (!(key == ‘constructor’ &amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) { result.push(key); } } return result; } / The base implementation of _.lt which doesn’t coerce arguments. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {boolean} Returns true if value is less than other, else false. / function baseLt(value, other) { return value &lt; other; } / The base implementation of _.map without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} iteratee The function invoked per iteration. @returns {Array} Returns the new mapped array. */ function baseMap(collection, iteratee) { var index = -1, result = isArrayLike(collection) ? Array(collection.length) : []; baseEach(collection, function(value, key, collection) { result[++index] = iteratee(value, key, collection); }); return result; } / The base implementation of _.matches which doesn’t clone source. @private @param {Object} source The object of property values to match. @returns {Function} Returns the new spec function. / function baseMatches(source) { var matchData = getMatchData(source); if (matchData.length == 1 &amp;&amp; matchData[0][2]) { return matchesStrictComparable(matchData[0][0], matchData[0][1]); } return function(object) { return object === source || baseIsMatch(object, source, matchData); }; } / The base implementation of _.matchesProperty which doesn’t clone srcValue. @private @param {string} path The path of the property to get. @param {} srcValue The value to match. @returns {Function} Returns the new spec function. / function baseMatchesProperty(path, srcValue) { if (isKey(path) &amp;&amp; isStrictComparable(srcValue)) { return matchesStrictComparable(toKey(path), srcValue); } return function(object) { var objValue = get(object, path); return (objValue === undefined &amp;&amp; objValue === srcValue) ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG); }; } / The base implementation of _.merge without support for multiple sources. @private @param {Object} object The destination object. @param {Object} source The source object. @param {number} srcIndex The index of source. @param {Function} [customizer] The function to customize merged values. @param {Object} [stack] Tracks traversed source values and their merged counterparts. / function baseMerge(object, source, srcIndex, customizer, stack) { if (object === source) { return; } baseFor(source, function(srcValue, key) { if (isObject(srcValue)) { stack || (stack = new Stack); baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); } else { var newValue = customizer ? customizer(safeGet(object, key), srcValue, (key + ‘’), object, source, stack) : undefined; if (newValue === undefined) { newValue = srcValue; } assignMergeValue(object, key, newValue); } }, keysIn); } / A specialized version of baseMerge for arrays and objects which performs deep merges and tracks traversed objects enabling objects with circular references to be merged. @private @param {Object} object The destination object. @param {Object} source The source object. @param {string} key The key of the value to merge. @param {number} srcIndex The index of source. @param {Function} mergeFunc The function to merge values. @param {Function} [customizer] The function to customize assigned values. @param {Object} [stack] Tracks traversed source values and their merged counterparts. / function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) { var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue); if (stacked) { assignMergeValue(object, key, stacked); return; } var newValue = customizer ? customizer(objValue, srcValue, (key + ‘’), object, source, stack) : undefined; var isCommon = newValue === undefined; if (isCommon) { var isArr = isArray(srcValue), isBuff = !isArr &amp;&amp; isBuffer(srcValue), isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue); newValue = srcValue; if (isArr || isBuff || isTyped) { if (isArray(objValue)) { newValue = objValue; } else if (isArrayLikeObject(objValue)) { newValue = copyArray(objValue); } else if (isBuff) { isCommon = false; newValue = cloneBuffer(srcValue, true); } else if (isTyped) { isCommon = false; newValue = cloneTypedArray(srcValue, true); } else { newValue = []; } } else if (isPlainObject(srcValue) || isArguments(srcValue)) { newValue = objValue; if (isArguments(objValue)) { newValue = toPlainObject(objValue); } else if (!isObject(objValue) || isFunction(objValue)) { newValue = initCloneObject(srcValue); } } else { isCommon = false; } } if (isCommon) { // Recursively merge objects and arrays (susceptible to call stack limits). stack.set(srcValue, newValue); mergeFunc(newValue, srcValue, srcIndex, customizer, stack); stack‘delete’; } assignMergeValue(object, key, newValue); } / The base implementation of _.nth which doesn’t coerce arguments. @private @param {Array} array The array to query. @param {number} n The index of the element to return. @returns {} Returns the nth element of array. / function baseNth(array, n) { var length = array.length; if (!length) { return; } n += n &lt; 0 ? length : 0; return isIndex(n, length) ? array[n] : undefined; } / The base implementation of _.orderBy without param guards. @private @param {Array|Object} collection The collection to iterate over. @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by. @param {string[]} orders The sort orders of iteratees. @returns {Array} Returns the new sorted array. / function baseOrderBy(collection, iteratees, orders) { var index = -1; iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee())); var result = baseMap(collection, function(value, key, collection) { var criteria = arrayMap(iteratees, function(iteratee) { return iteratee(value); }); return { ‘criteria’: criteria, ‘index’: ++index, ‘value’: value }; }); return baseSortBy(result, function(object, other) { return compareMultiple(object, other, orders); }); } / The base implementation of _.pick without support for individual property identifiers. @private @param {Object} object The source object. @param {string[]} paths The property paths to pick. @returns {Object} Returns the new object. / function basePick(object, paths) { return basePickBy(object, paths, function(value, path) { return hasIn(object, path); }); } / The base implementation of _.pickBy without support for iteratee shorthands. @private @param {Object} object The source object. @param {string[]} paths The property paths to pick. @param {Function} predicate The function invoked per property. @returns {Object} Returns the new object. / function basePickBy(object, paths, predicate) { var index = -1, length = paths.length, result = {}; while (++index &lt; length) { var path = paths[index], value = baseGet(object, path); if (predicate(value, path)) { baseSet(result, castPath(path, object), value); } } return result; } / A specialized version of baseProperty which supports deep paths. @private @param {Array|string} path The path of the property to get. @returns {Function} Returns the new accessor function. / function basePropertyDeep(path) { return function(object) { return baseGet(object, path); }; } / The base implementation of _.pullAllBy without support for iteratee shorthands. @private @param {Array} array The array to modify. @param {Array} values The values to remove. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns array. / function basePullAll(array, values, iteratee, comparator) { var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array; if (array === values) { values = copyArray(values); } if (iteratee) { seen = arrayMap(array, baseUnary(iteratee)); } while (++index &lt; length) { var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -1) { if (seen !== array) { splice.call(seen, fromIndex, 1); } splice.call(array, fromIndex, 1); } } return array; } / The base implementation of _.pullAt without support for individual indexes or capturing the removed elements. @private @param {Array} array The array to modify. @param {number[]} indexes The indexes of elements to remove. @returns {Array} Returns array. / function basePullAt(array, indexes) { var length = array ? indexes.length : 0, lastIndex = length - 1; while (length–) { var index = indexes[length]; if (length == lastIndex || index !== previous) { var previous = index; if (isIndex(index)) { splice.call(array, index, 1); } else { baseUnset(array, index); } } } return array; } / The base implementation of _.random without support for returning floating-point numbers. @private @param {number} lower The lower bound. @param {number} upper The upper bound. @returns {number} Returns the random number. / function baseRandom(lower, upper) { return lower + nativeFloor(nativeRandom() * (upper - lower + 1)); } / The base implementation of _.range and _.rangeRight which doesn’t coerce arguments. @private @param {number} start The start of the range. @param {number} end The end of the range. @param {number} step The value to increment or decrement by. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Array} Returns the range of numbers. / function baseRange(start, end, step, fromRight) { var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); while (length–) { result[fromRight ? length : ++index] = start; start += step; } return result; } / The base implementation of _.repeat which doesn’t coerce arguments. @private @param {string} string The string to repeat. @param {number} n The number of times to repeat the string. @returns {string} Returns the repeated string. */ function baseRepeat(string, n) { var result = ‘’; if (!string || n &lt; 1 || n &gt; MAX_SAFE_INTEGER) { return result; } // Leverage the exponentiation by squaring algorithm for a faster repeat. // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details. do { if (n % 2) { result += string; } n = nativeFloor(n / 2); if (n) { string += string; } } while (n); return result; } / The base implementation of _.rest which doesn’t validate or coerce arguments. @private @param {Function} func The function to apply a rest parameter to. @param {number} [start=func.length-1] The start position of the rest parameter. @returns {Function} Returns the new function. / function baseRest(func, start) { return setToString(overRest(func, start, identity), func + ‘’); } /** The base implementation of _.sample. @private @param {Array|Object} collection The collection to sample. @returns {} Returns the random element. / function baseSample(collection) { return arraySample(values(collection)); } / The base implementation of _.sampleSize without param guards. @private @param {Array|Object} collection The collection to sample. @param {number} n The number of elements to sample. @returns {Array} Returns the random elements. */ function baseSampleSize(collection, n) { var array = values(collection); return shuffleSelf(array, baseClamp(n, 0, array.length)); } / The base implementation of _.set. @private @param {Object} object The object to modify. @param {Array|string} path The path of the property to set. @param {} value The value to set. @param {Function} [customizer] The function to customize path creation. @returns {Object} Returns object. / function baseSet(object, path, value, customizer) { if (!isObject(object)) { return object; } path = castPath(path, object); var index = -1, length = path.length, lastIndex = length - 1, nested = object; while (nested != null &amp;&amp; ++index &lt; length) { var key = toKey(path[index]), newValue = value; if (index != lastIndex) { var objValue = nested[key]; newValue = customizer ? customizer(objValue, key, nested) : undefined; if (newValue === undefined) { newValue = isObject(objValue) ? objValue : (isIndex(path[index + 1]) ? [] : {}); } } assignValue(nested, key, newValue); nested = nested[key]; } return object; } / The base implementation of setData without support for hot loop shorting. @private @param {Function} func The function to associate metadata with. @param {} data The metadata. @returns {Function} Returns func. / var baseSetData = !metaMap ? identity : function(func, data) { metaMap.set(func, data); return func; }; / The base implementation of setToString without support for hot loop shorting. @private @param {Function} func The function to modify. @param {Function} string The toString result. @returns {Function} Returns func. / var baseSetToString = !defineProperty ? identity : function(func, string) { return defineProperty(func, ‘toString’, { ‘configurable’: true, ‘enumerable’: false, ‘value’: constant(string), ‘writable’: true }); }; /** The base implementation of _.shuffle. @private @param {Array|Object} collection The collection to shuffle. @returns {Array} Returns the new shuffled array. / function baseShuffle(collection) { return shuffleSelf(values(collection)); } /** The base implementation of _.slice without an iteratee call guard. @private @param {Array} array The array to slice. @param {number} [start=0] The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns the slice of array. / function baseSlice(array, start, end) { var index = -1, length = array.length; if (start &lt; 0) { start = -start &gt; length ? 0 : (length + start); } end = end &gt; length ? length : end; if (end &lt; 0) { end += length; } length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0); start &gt;&gt;&gt;= 0; var result = Array(length); while (++index &lt; length) { result[index] = array[index + start]; } return result; } /** The base implementation of _.some without support for iteratee shorthands. @private @param {Array|Object} collection The collection to iterate over. @param {Function} predicate The function invoked per iteration. @returns {boolean} Returns true if any element passes the predicate check, else false. / function baseSome(collection, predicate) { var result; baseEach(collection, function(value, index, collection) { result = predicate(value, index, collection); return !result; }); return !!result; } /** The base implementation of _.sortedIndex and _.sortedLastIndex which performs a binary search of array to determine the index at which value should be inserted into array in order to maintain its sort order. @private @param {Array} array The sorted array to inspect. @param {} value The value to evaluate. @param {boolean} [retHighest] Specify returning the highest qualified index. @returns {number} Returns the index at which value should be inserted into array. / function baseSortedIndex(array, value, retHighest) { var low = 0, high = array == null ? low : array.length; if (typeof value == ‘number’ &amp;&amp; value === value &amp;&amp; high &lt;= HALF_MAX_ARRAY_LENGTH) { while (low &lt; high) { var mid = (low + high) &gt;&gt;&gt; 1, computed = array[mid]; if (computed !== null &amp;&amp; !isSymbol(computed) &amp;&amp; (retHighest ? (computed &lt;= value) : (computed &lt; value))) { low = mid + 1; } else { high = mid; } } return high; } return baseSortedIndexBy(array, value, identity, retHighest); } /** The base implementation of _.sortedIndexBy and _.sortedLastIndexBy which invokes iteratee for value and each element of array to compute their sort ranking. The iteratee is invoked with one argument; (value). @private @param {Array} array The sorted array to inspect. @param {} value The value to evaluate. @param {Function} iteratee The iteratee invoked per element. @param {boolean} [retHighest] Specify returning the highest qualified index. @returns {number} Returns the index at which value should be inserted into array. / function baseSortedIndexBy(array, value, iteratee, retHighest) { value = iteratee(value); var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; while (low &lt; high) { var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed); if (valIsNaN) { var setLow = retHighest || othIsReflexive; } else if (valIsUndefined) { setLow = othIsReflexive &amp;&amp; (retHighest || othIsDefined); } else if (valIsNull) { setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; (retHighest || !othIsNull); } else if (valIsSymbol) { setLow = othIsReflexive &amp;&amp; othIsDefined &amp;&amp; !othIsNull &amp;&amp; (retHighest || !othIsSymbol); } else if (othIsNull || othIsSymbol) { setLow = false; } else { setLow = retHighest ? (computed &lt;= value) : (computed &lt; value); } if (setLow) { low = mid + 1; } else { high = mid; } } return nativeMin(high, MAX_ARRAY_INDEX); } / The base implementation of _.sortedUniq and _.sortedUniqBy without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} [iteratee] The iteratee invoked per element. @returns {Array} Returns the new duplicate free array. / function baseSortedUniq(array, iteratee) { var index = -1, length = array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index], computed = iteratee ? iteratee(value) : value; if (!index || !eq(computed, seen)) { var seen = computed; result[resIndex++] = value === 0 ? 0 : value; } } return result; } / The base implementation of _.toNumber which doesn’t ensure correct conversions of binary, hexadecimal, or octal string values. @private @param {} value The value to process. @returns {number} Returns the number. / function baseToNumber(value) { if (typeof value == ‘number’) { return value; } if (isSymbol(value)) { return NAN; } return +value; } / The base implementation of _.toString which doesn’t convert nullish values to empty strings. @private @param {} value The value to process. @returns {string} Returns the string. / function baseToString(value) { // Exit early for strings to avoid a performance hit in some environments. if (typeof value == ‘string’) { return value; } if (isArray(value)) { // Recursively convert values (susceptible to call stack limits). return arrayMap(value, baseToString) + ‘’; } if (isSymbol(value)) { return symbolToString ? symbolToString.call(value) : ‘’; } var result = (value + ‘’); return (result == ‘0’ &amp;&amp; (1 / value) == -INFINITY) ? ‘-0’ : result; } / The base implementation of _.uniqBy without support for iteratee shorthands. @private @param {Array} array The array to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new duplicate free array. / function baseUniq(array, iteratee, comparator) { var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result; if (comparator) { isCommon = false; includes = arrayIncludesWith; } else if (length &gt;= LARGE_ARRAY_SIZE) { var set = iteratee ? null : createSet(array); if (set) { return setToArray(set); } isCommon = false; includes = cacheHas; seen = new SetCache; } else { seen = iteratee ? [] : result; } outer: while (++index &lt; length) { var value = array[index], computed = iteratee ? iteratee(value) : value; value = (comparator || value !== 0) ? value : 0; if (isCommon &amp;&amp; computed === computed) { var seenIndex = seen.length; while (seenIndex–) { if (seen[seenIndex] === computed) { continue outer; } } if (iteratee) { seen.push(computed); } result.push(value); } else if (!includes(seen, computed, comparator)) { if (seen !== result) { seen.push(computed); } result.push(value); } } return result; } / The base implementation of _.unset. @private @param {Object} object The object to modify. @param {Array|string} path The property path to unset. @returns {boolean} Returns true if the property is deleted, else false. */ function baseUnset(object, path) { path = castPath(path, object); object = parent(object, path); return object == null || delete object[toKey(last(path))]; } / The base implementation of _.update. @private @param {Object} object The object to modify. @param {Array|string} path The path of the property to update. @param {Function} updater The function to produce the updated value. @param {Function} [customizer] The function to customize path creation. @returns {Object} Returns object. / function baseUpdate(object, path, updater, customizer) { return baseSet(object, path, updater(baseGet(object, path)), customizer); } /** The base implementation of methods like _.dropWhile and _.takeWhile without support for iteratee shorthands. @private @param {Array} array The array to query. @param {Function} predicate The function invoked per iteration. @param {boolean} [isDrop] Specify dropping elements instead of taking them. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Array} Returns the slice of array. / function baseWhile(array, predicate, isDrop, fromRight) { var length = array.length, index = fromRight ? length : -1; while ((fromRight ? index– : ++index &lt; length) &amp;&amp; predicate(array[index], index, array)) {} return isDrop ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length)) : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index)); } /** The base implementation of wrapperValue which returns the result of performing a sequence of actions on the unwrapped value, where each successive action is supplied the return value of the previous. @private @param {} value The unwrapped value. @param {Array} actions Actions to perform to resolve the unwrapped value. @returns {} Returns the resolved value. / function baseWrapperValue(value, actions) { var result = value; if (result instanceof LazyWrapper) { result = result.value(); } return arrayReduce(actions, function(result, action) { return action.func.apply(action.thisArg, arrayPush([result], action.args)); }, result); } / The base implementation of methods like _.xor, without support for iteratee shorthands, that accepts an array of arrays to inspect. @private @param {Array} arrays The arrays to inspect. @param {Function} [iteratee] The iteratee invoked per element. @param {Function} [comparator] The comparator invoked per element. @returns {Array} Returns the new array of values. */ function baseXor(arrays, iteratee, comparator) { var length = arrays.length; if (length &lt; 2) { return length ? baseUniq(arrays[0]) : []; } var index = -1, result = Array(length); while (++index &lt; length) { var array = arrays[index], othIndex = -1; while (++othIndex &lt; length) { if (othIndex != index) { result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator); } } } return baseUniq(baseFlatten(result, 1), iteratee, comparator); } / This base implementation of _.zipObject which assigns values using assignFunc. @private @param {Array} props The property identifiers. @param {Array} values The property values. @param {Function} assignFunc The function to assign values. @returns {Object} Returns the new object. / function baseZipObject(props, values, assignFunc) { var index = -1, length = props.length, valsLength = values.length, result = {}; while (++index &lt; length) { var value = index &lt; valsLength ? values[index] : undefined; assignFunc(result, props[index], value); } return result; } / Casts value to an empty array if it’s not an array like object. @private @param {} value The value to inspect. @returns {Array|Object} Returns the cast array-like object. */ function castArrayLikeObject(value) { return isArrayLikeObject(value) ? value : []; } / Casts value to identity if it’s not a function. @private @param {} value The value to inspect. @returns {Function} Returns cast function. / function castFunction(value) { return typeof value == ‘function’ ? value : identity; } /** Casts value to a path array if it’s not one. @private @param {} value The value to inspect. @param {Object} [object] The object to query keys on. @returns {Array} Returns the cast property path array. / function castPath(value, object) { if (isArray(value)) { return value; } return isKey(value, object) ? [value] : stringToPath(toString(value)); } /** A baseRest alias which can be replaced with identity by module replacement plugins. @private @type {Function} @param {Function} func The function to apply a rest parameter to. @returns {Function} Returns the new function. / var castRest = baseRest; /** Casts array to a slice if it’s needed. @private @param {Array} array The array to inspect. @param {number} start The start position. @param {number} [end=array.length] The end position. @returns {Array} Returns the cast slice. / function castSlice(array, start, end) { var length = array.length; end = end === undefined ? length : end; return (!start &amp;&amp; end &gt;= length) ? array : baseSlice(array, start, end); } /** A simple wrapper around the global clearTimeout. @private @param {number|Object} id The timer id or timeout object of the timer to clear. / var clearTimeout = ctxClearTimeout || function(id) { return root.clearTimeout(id); }; / Creates a clone of buffer. @private @param {Buffer} buffer The buffer to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Buffer} Returns the cloned buffer. */ function cloneBuffer(buffer, isDeep) { if (isDeep) { return buffer.slice(); } var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length); buffer.copy(result); return result; } / Creates a clone of arrayBuffer. @private @param {ArrayBuffer} arrayBuffer The array buffer to clone. @returns {ArrayBuffer} Returns the cloned array buffer. / function cloneArrayBuffer(arrayBuffer) { var result = new arrayBuffer.constructor(arrayBuffer.byteLength); new Uint8Array(result).set(new Uint8Array(arrayBuffer)); return result; } / Creates a clone of dataView. @private @param {Object} dataView The data view to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the cloned data view. */ function cloneDataView(dataView, isDeep) { var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer; return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength); } / Creates a clone of regexp. @private @param {Object} regexp The regexp to clone. @returns {Object} Returns the cloned regexp. / function cloneRegExp(regexp) { var result = new regexp.constructor(regexp.source, reFlags.exec(regexp)); result.lastIndex = regexp.lastIndex; return result; } / Creates a clone of the symbol object. @private @param {Object} symbol The symbol object to clone. @returns {Object} Returns the cloned symbol object. / function cloneSymbol(symbol) { return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}; } / Creates a clone of typedArray. @private @param {Object} typedArray The typed array to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the cloned typed array. / function cloneTypedArray(typedArray, isDeep) { var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer; return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length); } /** Compares values to sort them in ascending order. @private @param {} value The value to compare. @param {} other The other value to compare. @returns {number} Returns the sort order indicator for value. / function compareAscending(value, other) { if (value !== other) { var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value); var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other); if ((!othIsNull &amp;&amp; !othIsSymbol &amp;&amp; !valIsSymbol &amp;&amp; value &gt; other) || (valIsSymbol &amp;&amp; othIsDefined &amp;&amp; othIsReflexive &amp;&amp; !othIsNull &amp;&amp; !othIsSymbol) || (valIsNull &amp;&amp; othIsDefined &amp;&amp; othIsReflexive) || (!valIsDefined &amp;&amp; othIsReflexive) || !valIsReflexive) { return 1; } if ((!valIsNull &amp;&amp; !valIsSymbol &amp;&amp; !othIsSymbol &amp;&amp; value &lt; other) || (othIsSymbol &amp;&amp; valIsDefined &amp;&amp; valIsReflexive &amp;&amp; !valIsNull &amp;&amp; !valIsSymbol) || (othIsNull &amp;&amp; valIsDefined &amp;&amp; valIsReflexive) || (!othIsDefined &amp;&amp; valIsReflexive) || !othIsReflexive) { return -1; } } return 0; } / Used by _.orderBy to compare multiple properties of a value to another and stable sort them. If orders is unspecified, all values are sorted in ascending order. Otherwise, specify an order of “desc” for descending or “asc” for ascending sort order of corresponding values. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {boolean[]|string[]} orders The order to sort by for each property. @returns {number} Returns the sort order indicator for object. / function compareMultiple(object, other, orders) { var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; while (++index &lt; length) { var result = compareAscending(objCriteria[index], othCriteria[index]); if (result) { if (index &gt;= ordersLength) { return result; } var order = orders[index]; return result (order == ‘desc’ ? -1 : 1); } } // Fixes an Array#sort bug in the JS engine embedded in Adobe applications // that causes it, under certain circumstances, to provide the same value for // object and other. See https://github.com/jashkenas/underscore/pull/1247 // for more details. // // This also ensures a stable sort in V8 and other engines. // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details. return object.index - other.index; } / Creates an array that is the composition of partially applied arguments, placeholders, and provided arguments into a single array of arguments. @private @param {Array} args The provided arguments. @param {Array} partials The arguments to prepend to those provided. @param {Array} holders The partials placeholder indexes. @params {boolean} [isCurried] Specify composing for a curried function. @returns {Array} Returns the new array of composed arguments. / function composeArgs(args, partials, holders, isCurried) { var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; while (++leftIndex &lt; leftLength) { result[leftIndex] = partials[leftIndex]; } while (++argsIndex &lt; holdersLength) { if (isUncurried || argsIndex &lt; argsLength) { result[holders[argsIndex]] = args[argsIndex]; } } while (rangeLength–) { result[leftIndex++] = args[argsIndex++]; } return result; } / This function is like composeArgs except that the arguments composition is tailored for _.partialRight. @private @param {Array} args The provided arguments. @param {Array} partials The arguments to append to those provided. @param {Array} holders The partials placeholder indexes. @params {boolean} [isCurried] Specify composing for a curried function. @returns {Array} Returns the new array of composed arguments. / function composeArgsRight(args, partials, holders, isCurried) { var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; while (++argsIndex &lt; rangeLength) { result[argsIndex] = args[argsIndex]; } var offset = argsIndex; while (++rightIndex &lt; rightLength) { result[offset + rightIndex] = partials[rightIndex]; } while (++holdersIndex &lt; holdersLength) { if (isUncurried || argsIndex &lt; argsLength) { result[offset + holders[holdersIndex]] = args[argsIndex++]; } } return result; } / Copies the values of source to array. @private @param {Array} source The array to copy values from. @param {Array} [array=[]] The array to copy values to. @returns {Array} Returns array. / function copyArray(source, array) { var index = -1, length = source.length; array || (array = Array(length)); while (++index &lt; length) { array[index] = source[index]; } return array; } /** Copies properties of source to object. @private @param {Object} source The object to copy properties from. @param {Array} props The property identifiers to copy. @param {Object} [object={}] The object to copy properties to. @param {Function} [customizer] The function to customize copied values. @returns {Object} Returns object. / function copyObject(source, props, object, customizer) { var isNew = !object; object || (object = {}); var index = -1, length = props.length; while (++index &lt; length) { var key = props[index]; var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined; if (newValue === undefined) { newValue = source[key]; } if (isNew) { baseAssignValue(object, key, newValue); } else { assignValue(object, key, newValue); } } return object; } / Copies own symbols of source to object. @private @param {Object} source The object to copy symbols from. @param {Object} [object={}] The object to copy symbols to. @returns {Object} Returns object. */ function copySymbols(source, object) { return copyObject(source, getSymbols(source), object); } / Copies own and inherited symbols of source to object. @private @param {Object} source The object to copy symbols from. @param {Object} [object={}] The object to copy symbols to. @returns {Object} Returns object. / function copySymbolsIn(source, object) { return copyObject(source, getSymbolsIn(source), object); } /** Creates a function like _.groupBy. @private @param {Function} setter The function to set accumulator values. @param {Function} [initializer] The accumulator object initializer. @returns {Function} Returns the new aggregator function. / function createAggregator(setter, initializer) { return function(collection, iteratee) { var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {}; return func(collection, setter, getIteratee(iteratee, 2), accumulator); }; } / Creates a function like _.assign. @private @param {Function} assigner The function to assign values. @returns {Function} Returns the new assigner function. / function createAssigner(assigner) { return baseRest(function(object, sources) { var index = -1, length = sources.length, customizer = length &gt; 1 ? sources[length - 1] : undefined, guard = length &gt; 2 ? sources[2] : undefined; customizer = (assigner.length &gt; 3 &amp;&amp; typeof customizer == ‘function’) ? (length–, customizer) : undefined; if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) { customizer = length &lt; 3 ? undefined : customizer; length = 1; } object = Object(object); while (++index &lt; length) { var source = sources[index]; if (source) { assigner(object, source, index, customizer); } } return object; }); } / Creates a baseEach or baseEachRight function. @private @param {Function} eachFunc The function to iterate over a collection. @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new base function. / function createBaseEach(eachFunc, fromRight) { return function(collection, iteratee) { if (collection == null) { return collection; } if (!isArrayLike(collection)) { return eachFunc(collection, iteratee); } var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); while ((fromRight ? index– : ++index &lt; length)) { if (iteratee(iterable[index], index, iterable) === false) { break; } } return collection; }; } /** Creates a base function for methods like _.forIn and _.forOwn. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new base function. / function createBaseFor(fromRight) { return function(object, iteratee, keysFunc) { var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; while (length–) { var key = props[fromRight ? length : ++index]; if (iteratee(iterable[key], key, iterable) === false) { break; } } return object; }; } /** Creates a function that wraps func to invoke it with the optional this binding of thisArg. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} [thisArg] The this binding of func. @returns {Function} Returns the new wrapped function. / function createBind(func, bitmask, thisArg) { var isBind = bitmask &amp; WRAP_BIND_FLAG, Ctor = createCtor(func); function wrapper() { var fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; return fn.apply(isBind ? thisArg : this, arguments); } return wrapper; } /** Creates a function like _.lowerFirst. @private @param {string} methodName The name of the String case method to use. @returns {Function} Returns the new case function. / function createCaseFirst(methodName) { return function(string) { string = toString(string); var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined; var chr = strSymbols ? strSymbols[0] : string.charAt(0); var trailing = strSymbols ? castSlice(strSymbols, 1).join(‘’) : string.slice(1); return chrmethodName + trailing; }; } /** Creates a function like _.camelCase. @private @param {Function} callback The function to combine each word. @returns {Function} Returns the new compounder function. / function createCompounder(callback) { return function(string) { return arrayReduce(words(deburr(string).replace(reApos, ‘’)), callback, ‘’); }; } /** Creates a function that produces an instance of Ctor regardless of whether it was invoked as part of a new expression or by call or apply. @private @param {Function} Ctor The constructor to wrap. @returns {Function} Returns the new wrapped function. / function createCtor(Ctor) { return function() { // Use a switch statement to work with class constructors. See // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist // for more details. var args = arguments; switch (args.length) { case 0: return new Ctor; case 1: return new Ctor(args[0]); case 2: return new Ctor(args[0], args[1]); case 3: return new Ctor(args[0], args[1], args[2]); case 4: return new Ctor(args[0], args[1], args[2], args[3]); case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]); case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]); case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]); } var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args); // Mimic the constructor’s return behavior. // See https://es5.github.io/#x13.2.2 for more details. return isObject(result) ? result : thisBinding; }; } / Creates a function that wraps func to enable currying. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {number} arity The arity of func. @returns {Function} Returns the new wrapped function. / function createCurry(func, bitmask, arity) { var Ctor = createCtor(func); function wrapper() { var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); while (index–) { args[index] = arguments[index]; } var holders = (length &lt; 3 &amp;&amp; args[0] !== placeholder &amp;&amp; args[length - 1] !== placeholder) ? [] : replaceHolders(args, placeholder); length -= holders.length; if (length &lt; arity) { return createRecurry( func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length); } var fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; return apply(fn, this, args); } return wrapper; } / Creates a _.find or _.findLast function. @private @param {Function} findIndexFunc The function to find the collection index. @returns {Function} Returns the new find function. / function createFind(findIndexFunc) { return function(collection, predicate, fromIndex) { var iterable = Object(collection); if (!isArrayLike(collection)) { var iteratee = getIteratee(predicate, 3); collection = keys(collection); predicate = function(key) { return iteratee(iterable[key], key, iterable); }; } var index = findIndexFunc(collection, predicate, fromIndex); return index &gt; -1 ? iterable[iteratee ? collection[index] : index] : undefined; }; } / Creates a _.flow or _.flowRight function. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new flow function. / function createFlow(fromRight) { return flatRest(function(funcs) { var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru; if (fromRight) { funcs.reverse(); } while (index–) { var func = funcs[index]; if (typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } if (prereq &amp;&amp; !wrapper &amp;&amp; getFuncName(func) == ‘wrapper’) { var wrapper = new LodashWrapper([], true); } } index = wrapper ? index : length; while (++index &lt; length) { func = funcs[index]; var funcName = getFuncName(func), data = funcName == ‘wrapper’ ? getData(func) : undefined; if (data &amp;&amp; isLaziable(data[0]) &amp;&amp; data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &amp;&amp; !data[4].length &amp;&amp; data[9] == 1 ) { wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]); } else { wrapper = (func.length == 1 &amp;&amp; isLaziable(func)) ? wrapperfuncName : wrapper.thru(func); } } return function() { var args = arguments, value = args[0]; if (wrapper &amp;&amp; args.length == 1 &amp;&amp; isArray(value)) { return wrapper.plant(value).value(); } var index = 0, result = length ? funcs[index].apply(this, args) : value; while (++index &lt; length) { result = funcs[index].call(this, result); } return result; }; }); } / Creates a function that wraps func to invoke it with optional this binding of thisArg, partial application, and currying. @private @param {Function|string} func The function or method name to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to prepend to those provided to the new function. @param {Array} [holders] The partials placeholder indexes. @param {Array} [partialsRight] The arguments to append to those provided to the new function. @param {Array} [holdersRight] The partialsRight placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. / function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) { var isAry = bitmask &amp; WRAP_ARY_FLAG, isBind = bitmask &amp; WRAP_BIND_FLAG, isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG, isCurried = bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask &amp; WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func); function wrapper() { var length = arguments.length, args = Array(length), index = length; while (index–) { args[index] = arguments[index]; } if (isCurried) { var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder); } if (partials) { args = composeArgs(args, partials, holders, isCurried); } if (partialsRight) { args = composeArgsRight(args, partialsRight, holdersRight, isCurried); } length -= holdersCount; if (isCurried &amp;&amp; length &lt; arity) { var newHolders = replaceHolders(args, placeholder); return createRecurry( func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length ); } var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func; length = args.length; if (argPos) { args = reorder(args, argPos); } else if (isFlip &amp;&amp; length &gt; 1) { args.reverse(); } if (isAry &amp;&amp; ary &lt; length) { args.length = ary; } if (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) { fn = Ctor || createCtor(fn); } return fn.apply(thisBinding, args); } return wrapper; } /** Creates a function like _.invertBy. @private @param {Function} setter The function to set accumulator values. @param {Function} toIteratee The function to resolve iteratees. @returns {Function} Returns the new inverter function. / function createInverter(setter, toIteratee) { return function(object, iteratee) { return baseInverter(object, setter, toIteratee(iteratee), {}); }; } / Creates a function that performs a mathematical operation on two values. @private @param {Function} operator The function to perform the operation. @param {number} [defaultValue] The value used for undefined arguments. @returns {Function} Returns the new mathematical operation function. */ function createMathOperation(operator, defaultValue) { return function(value, other) { var result; if (value === undefined &amp;&amp; other === undefined) { return defaultValue; } if (value !== undefined) { result = value; } if (other !== undefined) { if (result === undefined) { return other; } if (typeof value == ‘string’ || typeof other == ‘string’) { value = baseToString(value); other = baseToString(other); } else { value = baseToNumber(value); other = baseToNumber(other); } result = operator(value, other); } return result; }; } / Creates a function like _.over. @private @param {Function} arrayFunc The function to iterate over iteratees. @returns {Function} Returns the new over function. / function createOver(arrayFunc) { return flatRest(function(iteratees) { iteratees = arrayMap(iteratees, baseUnary(getIteratee())); return baseRest(function(args) { var thisArg = this; return arrayFunc(iteratees, function(iteratee) { return apply(iteratee, thisArg, args); }); }); }); } / Creates the padding for string based on length. The chars string is truncated if the number of characters exceeds length. @private @param {number} length The padding length. @param {string} [chars=’ ‘] The string used as padding. @returns {string} Returns the padding for string. / function createPadding(length, chars) { chars = chars === undefined ? ‘ ‘ : baseToString(chars); var charsLength = chars.length; if (charsLength &lt; 2) { return charsLength ? baseRepeat(chars, length) : chars; } var result = baseRepeat(chars, nativeCeil(length / stringSize(chars))); return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join(‘’) : result.slice(0, length); } / Creates a function that wraps func to invoke it with the this binding of thisArg and partials prepended to the arguments it receives. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {} thisArg The this binding of func. @param {Array} partials The arguments to prepend to those provided to the new function. @returns {Function} Returns the new wrapped function. / function createPartial(func, bitmask, thisArg, partials) { var isBind = bitmask &amp; WRAP_BIND_FLAG, Ctor = createCtor(func); function wrapper() { var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this &amp;&amp; this !== root &amp;&amp; this instanceof wrapper) ? Ctor : func; while (++leftIndex &lt; leftLength) { args[leftIndex] = partials[leftIndex]; } while (argsLength–) { args[leftIndex++] = arguments[++argsIndex]; } return apply(fn, isBind ? thisArg : this, args); } return wrapper; } / Creates a _.range or _.rangeRight function. @private @param {boolean} [fromRight] Specify iterating from right to left. @returns {Function} Returns the new range function. / function createRange(fromRight) { return function(start, end, step) { if (step &amp;&amp; typeof step != ‘number’ &amp;&amp; isIterateeCall(start, end, step)) { end = step = undefined; } // Ensure the sign of -0 is preserved. start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } step = step === undefined ? (start &lt; end ? 1 : -1) : toFinite(step); return baseRange(start, end, step, fromRight); }; } / Creates a function that performs a relational operation on two values. @private @param {Function} operator The function to perform the operation. @returns {Function} Returns the new relational operation function. / function createRelationalOperation(operator) { return function(value, other) { if (!(typeof value == ‘string’ &amp;&amp; typeof other == ‘string’)) { value = toNumber(value); other = toNumber(other); } return operator(value, other); }; } / Creates a function that wraps func to continue currying. @private @param {Function} func The function to wrap. @param {number} bitmask The bitmask flags. See createWrap for more details. @param {Function} wrapFunc The function to create the func wrapper. @param {} placeholder The placeholder value. @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to prepend to those provided to the new function. @param {Array} [holders] The partials placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. / function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) { var isCurry = bitmask &amp; WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials; bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG); bitmask &amp;= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG); if (!(bitmask &amp; WRAP_CURRY_BOUND_FLAG)) { bitmask &amp;= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG); } var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ]; var result = wrapFunc.apply(undefined, newData); if (isLaziable(func)) { setData(result, newData); } result.placeholder = placeholder; return setWrapToString(result, func, bitmask); } / Creates a function like _.round. @private @param {string} methodName The name of the Math method to use when rounding. @returns {Function} Returns the new round function. / function createRound(methodName) { var func = Math[methodName]; return function(number, precision) { number = toNumber(number); precision = precision == null ? 0 : nativeMin(toInteger(precision), 292); if (precision) { // Shift with exponential notation to avoid floating-point issues. // See MDN for more details. var pair = (toString(number) + ‘e’).split(‘e’), value = func(pair[0] + ‘e’ + (+pair[1] + precision)); pair = (toString(value) + ‘e’).split(‘e’); return +(pair[0] + ‘e’ + (+pair[1] - precision)); } return func(number); }; } / Creates a set object of values. @private @param {Array} values The values to add to the set. @returns {Object} Returns the new set. / var createSet = !(Set &amp;&amp; (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) { return new Set(values); }; / Creates a _.toPairs or _.toPairsIn function. @private @param {Function} keysFunc The function to get the keys of a given object. @returns {Function} Returns the new pairs function. / function createToPairs(keysFunc) { return function(object) { var tag = getTag(object); if (tag == mapTag) { return mapToArray(object); } if (tag == setTag) { return setToPairs(object); } return baseToPairs(object, keysFunc(object)); }; } / Creates a function that either curries or invokes func with optional this binding and partially applied arguments. @private @param {Function|string} func The function or method name to wrap. @param {number} bitmask The bitmask flags. 1 - _.bind 2 - _.bindKey 4 - _.curry or _.curryRight of a bound function 8 - _.curry 16 - _.curryRight 32 - _.partial 64 - _.partialRight 128 - _.rearg 256 - _.ary 512 - _.flip @param {} [thisArg] The this binding of func. @param {Array} [partials] The arguments to be partially applied. @param {Array} [holders] The partials placeholder indexes. @param {Array} [argPos] The argument positions of the new function. @param {number} [ary] The arity cap of func. @param {number} [arity] The arity of func. @returns {Function} Returns the new wrapped function. */ function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) { var isBindKey = bitmask &amp; WRAP_BIND_KEY_FLAG; if (!isBindKey &amp;&amp; typeof func != ‘function’) { throw new TypeError(FUNC_ERROR_TEXT); } var length = partials ? partials.length : 0; if (!length) { bitmask &amp;= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG); partials = holders = undefined; } ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0); arity = arity === undefined ? arity : toInteger(arity); length -= holders ? holders.length : 0; if (bitmask &amp; WRAP_PARTIAL_RIGHT_FLAG) { var partialsRight = partials, holdersRight = holders; partials = holders = undefined; } var data = isBindKey ? undefined : getData(func); var newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ]; if (data) { mergeData(newData, data); } func = newData[0]; bitmask = newData[1]; thisArg = newData[2]; partials = newData[3]; holders = newData[4]; arity = newData[9] = newData[9] === undefined ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0); if (!arity &amp;&amp; bitmask &amp; (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) { bitmask &amp;= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG); } if (!bitmask || bitmask == WRAP_BIND_FLAG) { var result = createBind(func, bitmask, thisArg); } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) { result = createCurry(func, bitmask, arity); } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &amp;&amp; !holders.length) { result = createPartial(func, bitmask, thisArg, partials); } else { result = createHybrid.apply(undefined, newData); } var setter = data ? baseSetData : setData; return setWrapToString(setter(result, newData), func, bitmask); } / Used by _.defaults to customize its _.assignIn use to assign properties of source objects to the destination object for all destination properties that resolve to undefined. @private @param {} objValue The destination value. @param {} srcValue The source value. @param {string} key The key of the property to assign. @param {Object} object The parent object of objValue. @returns {} Returns the value to assign. / function customDefaultsAssignIn(objValue, srcValue, key, object) { if (objValue === undefined || (eq(objValue, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) { return srcValue; } return objValue; } / Used by _.defaultsDeep to customize its _.merge use to merge source objects into destination objects that are passed thru. @private @param {} objValue The destination value. @param {} srcValue The source value. @param {string} key The key of the property to merge. @param {Object} object The parent object of objValue. @param {Object} source The parent object of srcValue. @param {Object} [stack] Tracks traversed source values and their merged counterparts. @returns {} Returns the value to assign. / function customDefaultsMerge(objValue, srcValue, key, object, source, stack) { if (isObject(objValue) &amp;&amp; isObject(srcValue)) { // Recursively merge objects and arrays (susceptible to call stack limits). stack.set(srcValue, objValue); baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack); stack‘delete’; } return objValue; } / Used by _.omit to customize its _.cloneDeep use to only clone plain objects. @private @param {} value The value to inspect. @param {string} key The key of the property to inspect. @returns {} Returns the uncloned value or undefined to defer cloning to _.cloneDeep. / function customOmitClone(value) { return isPlainObject(value) ? undefined : value; } / A specialized version of baseIsEqualDeep for arrays with support for partial deep comparisons. @private @param {Array} array The array to compare. @param {Array} other The other array to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed array and other objects. @returns {boolean} Returns true if the arrays are equivalent, else false. / function equalArrays(array, other, bitmask, customizer, equalFunc, stack) { var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length; if (arrLength != othLength &amp;&amp; !(isPartial &amp;&amp; othLength &gt; arrLength)) { return false; } // Assume cyclic values are equal. var stacked = stack.get(array); if (stacked &amp;&amp; stack.get(other)) { return stacked == other; } var index = -1, result = true, seen = (bitmask &amp; COMPARE_UNORDERED_FLAG) ? new SetCache : undefined; stack.set(array, other); stack.set(other, array); // Ignore non-index properties. while (++index &lt; arrLength) { var arrValue = array[index], othValue = other[index]; if (customizer) { var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack); } if (compared !== undefined) { if (compared) { continue; } result = false; break; } // Recursively compare arrays (susceptible to call stack limits). if (seen) { if (!arraySome(other, function(othValue, othIndex) { if (!cacheHas(seen, othIndex) &amp;&amp; (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) { return seen.push(othIndex); } })) { result = false; break; } } else if (!( arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack) )) { result = false; break; } } stack‘delete’; stack‘delete’; return result; } / A specialized version of baseIsEqualDeep for comparing objects of the same toStringTag. Note: This function only supports comparing values with tags of Boolean, Date, Error, Number, RegExp, or String. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {string} tag The toStringTag of the objects to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) { switch (tag) { case dataViewTag: if ((object.byteLength != other.byteLength) || (object.byteOffset != other.byteOffset)) { return false; } object = object.buffer; other = other.buffer; case arrayBufferTag: if ((object.byteLength != other.byteLength) || !equalFunc(new Uint8Array(object), new Uint8Array(other))) { return false; } return true; case boolTag: case dateTag: case numberTag: // Coerce booleans to 1 or 0 and dates to milliseconds. // Invalid dates are coerced to NaN. return eq(+object, +other); case errorTag: return object.name == other.name &amp;&amp; object.message == other.message; case regexpTag: case stringTag: // Coerce regexes to strings and treat strings, primitives and objects, // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring // for more details. return object == (other + ‘’); case mapTag: var convert = mapToArray; case setTag: var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG; convert || (convert = setToArray); if (object.size != other.size &amp;&amp; !isPartial) { return false; } // Assume cyclic values are equal. var stacked = stack.get(object); if (stacked) { return stacked == other; } bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits). stack.set(object, other); var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack); stack‘delete’; return result; case symbolTag: if (symbolValueOf) { return symbolValueOf.call(object) == symbolValueOf.call(other); } } return false; } / A specialized version of baseIsEqualDeep for objects with support for partial deep comparisons. @private @param {Object} object The object to compare. @param {Object} other The other object to compare. @param {number} bitmask The bitmask flags. See baseIsEqual for more details. @param {Function} customizer The function to customize comparisons. @param {Function} equalFunc The function to determine equivalents of values. @param {Object} stack Tracks traversed object and other objects. @returns {boolean} Returns true if the objects are equivalent, else false. / function equalObjects(object, other, bitmask, customizer, equalFunc, stack) { var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length; if (objLength != othLength &amp;&amp; !isPartial) { return false; } var index = objLength; while (index–) { var key = objProps[index]; if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) { return false; } } // Assume cyclic values are equal. var stacked = stack.get(object); if (stacked &amp;&amp; stack.get(other)) { return stacked == other; } var result = true; stack.set(object, other); stack.set(other, object); var skipCtor = isPartial; while (++index &lt; objLength) { key = objProps[index]; var objValue = object[key], othValue = other[key]; if (customizer) { var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack); } // Recursively compare objects (susceptible to call stack limits). if (!(compared === undefined ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)) : compared )) { result = false; break; } skipCtor || (skipCtor = key == ‘constructor’); } if (result &amp;&amp; !skipCtor) { var objCtor = object.constructor, othCtor = other.constructor; // Non Object object instances with different constructors are not equal. if (objCtor != othCtor &amp;&amp; (‘constructor’ in object &amp;&amp; ‘constructor’ in other) &amp;&amp; !(typeof objCtor == ‘function’ &amp;&amp; objCtor instanceof objCtor &amp;&amp; typeof othCtor == ‘function’ &amp;&amp; othCtor instanceof othCtor)) { result = false; } } stack‘delete’; stack‘delete’; return result; } / A specialized version of baseRest which flattens the rest array. @private @param {Function} func The function to apply a rest parameter to. @returns {Function} Returns the new function. / function flatRest(func) { return setToString(overRest(func, undefined, flatten), func + ‘’); } / Creates an array of own enumerable property names and symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names and symbols. / function getAllKeys(object) { return baseGetAllKeys(object, keys, getSymbols); } / Creates an array of own and inherited enumerable property names and symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names and symbols. / function getAllKeysIn(object) { return baseGetAllKeys(object, keysIn, getSymbolsIn); } /** Gets metadata for func. @private @param {Function} func The function to query. @returns {} Returns the metadata for func. / var getData = !metaMap ? noop : function(func) { return metaMap.get(func); }; / Gets the name of func. @private @param {Function} func The function to query. @returns {string} Returns the function name. / function getFuncName(func) { var result = (func.name + ‘’), array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; while (length–) { var data = array[length], otherFunc = data.func; if (otherFunc == null || otherFunc == func) { return data.name; } } return result; } / Gets the argument placeholder value for func. @private @param {Function} func The function to inspect. @returns {} Returns the placeholder value. / function getHolder(func) { var object = hasOwnProperty.call(lodash, ‘placeholder’) ? lodash : func; return object.placeholder; } /** Gets the appropriate “iteratee” function. If _.iteratee is customized, this function returns the custom method, otherwise it returns baseIteratee. If arguments are provided, the chosen function is invoked with them and its result is returned. @private @param {} [value] The value to convert to an iteratee. @param {number} [arity] The arity of the created iteratee. @returns {Function} Returns the chosen function or its result. / function getIteratee() { var result = lodash.iteratee || iteratee; result = result === iteratee ? baseIteratee : result; return arguments.length ? result(arguments[0], arguments[1]) : result; } / Gets the data for map. @private @param {Object} map The map to query. @param {string} key The reference key. @returns {} Returns the map data. / function getMapData(map, key) { var data = map.data; return isKeyable(key) ? data[typeof key == ‘string’ ? ‘string’ : ‘hash’] : data.map; } / Gets the property names, values, and compare flags of object. @private @param {Object} object The object to query. @returns {Array} Returns the match data of object. / function getMatchData(object) { var result = keys(object), length = result.length; while (length–) { var key = result[length], value = object[key]; result[length] = [key, value, isStrictComparable(value)]; } return result; } / Gets the native function at key of object. @private @param {Object} object The object to query. @param {string} key The key of the method to get. @returns {} Returns the function if it’s native, else undefined. / function getNative(object, key) { var value = getValue(object, key); return baseIsNative(value) ? value : undefined; } / A specialized version of baseGetTag which ignores Symbol.toStringTag values. @private @param {} value The value to query. @returns {string} Returns the raw toStringTag. / function getRawTag(value) { var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag]; try { value[symToStringTag] = undefined; var unmasked = true; } catch (e) {} var result = nativeObjectToString.call(value); if (unmasked) { if (isOwn) { value[symToStringTag] = tag; } else { delete value[symToStringTag]; } } return result; } /** Creates an array of the own enumerable symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of symbols. / var getSymbols = !nativeGetSymbols ? stubArray : function(object) { if (object == null) { return []; } object = Object(object); return arrayFilter(nativeGetSymbols(object), function(symbol) { return propertyIsEnumerable.call(object, symbol); }); }; /** Creates an array of the own and inherited enumerable symbols of object. @private @param {Object} object The object to query. @returns {Array} Returns the array of symbols. / var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) { var result = []; while (object) { arrayPush(result, getSymbols(object)); object = getPrototype(object); } return result; }; /** Gets the toStringTag of value. @private @param {} value The value to query. @returns {string} Returns the toStringTag. / var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js &lt; 6. if ((DataView &amp;&amp; getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) || (Map &amp;&amp; getTag(new Map) != mapTag) || (Promise &amp;&amp; getTag(Promise.resolve()) != promiseTag) || (Set &amp;&amp; getTag(new Set) != setTag) || (WeakMap &amp;&amp; getTag(new WeakMap) != weakMapTag)) { getTag = function(value) { var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : ‘’; if (ctorString) { switch (ctorString) { case dataViewCtorString: return dataViewTag; case mapCtorString: return mapTag; case promiseCtorString: return promiseTag; case setCtorString: return setTag; case weakMapCtorString: return weakMapTag; } } return result; }; } / Gets the view, applying any transforms to the start and end positions. @private @param {number} start The start of the view. @param {number} end The end of the view. @param {Array} transforms The transformations to apply to the view. @returns {Object} Returns an object containing the start and end positions of the view. */ function getView(start, end, transforms) { var index = -1, length = transforms.length; while (++index &lt; length) { var data = transforms[index], size = data.size; switch (data.type) { case ‘drop’: start += size; break; case ‘dropRight’: end -= size; break; case ‘take’: end = nativeMin(end, start + size); break; case ‘takeRight’: start = nativeMax(start, end - size); break; } } return { ‘start’: start, ‘end’: end }; } / Extracts wrapper details from the source body comment. @private @param {string} source The source to inspect. @returns {Array} Returns the wrapper details. / function getWrapDetails(source) { var match = source.match(reWrapDetails); return match ? match[1].split(reSplitDetails) : []; } / Checks if path exists on object. @private @param {Object} object The object to query. @param {Array|string} path The path to check. @param {Function} hasFunc The function to check properties. @returns {boolean} Returns true if path exists, else false. / function hasPath(object, path, hasFunc) { path = castPath(path, object); var index = -1, length = path.length, result = false; while (++index &lt; length) { var key = toKey(path[index]); if (!(result = object != null &amp;&amp; hasFunc(object, key))) { break; } object = object[key]; } if (result || ++index != length) { return result; } length = object == null ? 0 : object.length; return !!length &amp;&amp; isLength(length) &amp;&amp; isIndex(key, length) &amp;&amp; (isArray(object) || isArguments(object)); } / Initializes an array clone. @private @param {Array} array The array to clone. @returns {Array} Returns the initialized clone. / function initCloneArray(array) { var length = array.length, result = new array.constructor(length); // Add properties assigned by RegExp#exec. if (length &amp;&amp; typeof array[0] == ‘string’ &amp;&amp; hasOwnProperty.call(array, ‘index’)) { result.index = array.index; result.input = array.input; } return result; } / Initializes an object clone. @private @param {Object} object The object to clone. @returns {Object} Returns the initialized clone. / function initCloneObject(object) { return (typeof object.constructor == ‘function’ &amp;&amp; !isPrototype(object)) ? baseCreate(getPrototype(object)) : {}; } / Initializes an object clone based on its toStringTag. Note: This function only supports cloning values with tags of Boolean, Date, Error, Map, Number, RegExp, Set, or String. @private @param {Object} object The object to clone. @param {string} tag The toStringTag of the object to clone. @param {boolean} [isDeep] Specify a deep clone. @returns {Object} Returns the initialized clone. / function initCloneByTag(object, tag, isDeep) { var Ctor = object.constructor; switch (tag) { case arrayBufferTag: return cloneArrayBuffer(object); case boolTag: case dateTag: return new Ctor(+object); case dataViewTag: return cloneDataView(object, isDeep); case float32Tag: case float64Tag: case int8Tag: case int16Tag: case int32Tag: case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag: return cloneTypedArray(object, isDeep); case mapTag: return new Ctor; case numberTag: case stringTag: return new Ctor(object); case regexpTag: return cloneRegExp(object); case setTag: return new Ctor; case symbolTag: return cloneSymbol(object); } } /** Inserts wrapper details in a comment at the top of the source body. @private @param {string} source The source to modify. @returns {Array} details The details to insert. @returns {string} Returns the modified source. / function insertWrapDetails(source, details) { var length = details.length; if (!length) { return source; } var lastIndex = length - 1; details[lastIndex] = (length &gt; 1 ? ‘&amp; ‘ : ‘’) + details[lastIndex]; details = details.join(length &gt; 2 ? ‘, ‘ : ‘ ‘); return source.replace(reWrapComment, ‘{\n/ [wrapped with ‘ + details + ‘] /\n’); } / Checks if value is a flattenable arguments object or array. @private @param {} value The value to check. @returns {boolean} Returns true if value is flattenable, else false. */ function isFlattenable(value) { return isArray(value) || isArguments(value) || !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]); } / Checks if value is a valid array-like index. @private @param {} value The value to check. @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index. @returns {boolean} Returns true if value is a valid index, else false. / function isIndex(value, length) { var type = typeof value; length = length == null ? MAX_SAFE_INTEGER : length; return !!length &amp;&amp; (type == ‘number’ || (type != ‘symbol’ &amp;&amp; reIsUint.test(value))) &amp;&amp; (value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length); } / Checks if the given arguments are from an iteratee call. @private @param {} value The potential iteratee value argument. @param {} index The potential iteratee index or key argument. @param {} object The potential iteratee object argument. @returns {boolean} Returns true if the arguments are from an iteratee call, else false. / function isIterateeCall(value, index, object) { if (!isObject(object)) { return false; } var type = typeof index; if (type == ‘number’ ? (isArrayLike(object) &amp;&amp; isIndex(index, object.length)) : (type == ‘string’ &amp;&amp; index in object) ) { return eq(object[index], value); } return false; } / Checks if value is a property name and not a property path. @private @param {} value The value to check. @param {Object} [object] The object to query keys on. @returns {boolean} Returns true if value is a property name, else false. / function isKey(value, object) { if (isArray(value)) { return false; } var type = typeof value; if (type == ‘number’ || type == ‘symbol’ || type == ‘boolean’ || value == null || isSymbol(value)) { return true; } return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null &amp;&amp; value in Object(object)); } / Checks if value is suitable for use as unique object key. @private @param {} value The value to check. @returns {boolean} Returns true if value is suitable, else false. */ function isKeyable(value) { var type = typeof value; return (type == ‘string’ || type == ‘number’ || type == ‘symbol’ || type == ‘boolean’) ? (value !== ‘proto‘) : (value === null); } / Checks if func has a lazy counterpart. @private @param {Function} func The function to check. @returns {boolean} Returns true if func has a lazy counterpart, else false. / function isLaziable(func) { var funcName = getFuncName(func), other = lodash[funcName]; if (typeof other != ‘function’ || !(funcName in LazyWrapper.prototype)) { return false; } if (func === other) { return true; } var data = getData(other); return !!data &amp;&amp; func === data[0]; } /** Checks if func has its source masked. @private @param {Function} func The function to check. @returns {boolean} Returns true if func is masked, else false. / function isMasked(func) { return !!maskSrcKey &amp;&amp; (maskSrcKey in func); } /** Checks if func is capable of being masked. @private @param {} value The value to check. @returns {boolean} Returns true if func is maskable, else false. / var isMaskable = coreJsData ? isFunction : stubFalse; / Checks if value is likely a prototype object. @private @param {} value The value to check. @returns {boolean} Returns true if value is a prototype, else false. */ function isPrototype(value) { var Ctor = value &amp;&amp; value.constructor, proto = (typeof Ctor == ‘function’ &amp;&amp; Ctor.prototype) || objectProto; return value === proto; } / Checks if value is suitable for strict equality comparisons, i.e. ===. @private @param {} value The value to check. @returns {boolean} Returns true if value if suitable for strict equality comparisons, else false. / function isStrictComparable(value) { return value === value &amp;&amp; !isObject(value); } / A specialized version of matchesProperty for source values suitable for strict equality comparisons, i.e. ===. @private @param {string} key The key of the property to get. @param {} srcValue The value to match. @returns {Function} Returns the new spec function. */ function matchesStrictComparable(key, srcValue) { return function(object) { if (object == null) { return false; } return object[key] === srcValue &amp;&amp; (srcValue !== undefined || (key in Object(object))); }; } / A specialized version of _.memoize which clears the memoized function’s cache when it exceeds MAX_MEMOIZE_SIZE. @private @param {Function} func The function to have its output memoized. @returns {Function} Returns the new memoized function. / function memoizeCapped(func) { var result = memoize(func, function(key) { if (cache.size === MAX_MEMOIZE_SIZE) { cache.clear(); } return key; }); var cache = result.cache; return result; } /** Merges the function metadata of source into data. Merging metadata reduces the number of wrappers used to invoke a function. This is possible because methods like _.bind, _.curry, and _.partial may be applied regardless of execution order. Methods like _.ary and _.rearg modify function arguments, making the order in which they are executed important, preventing the merging of metadata. However, we make an exception for a safe combined case where curried functions have _.ary and or _.rearg applied. @private @param {Array} data The destination metadata. @param {Array} source The source metadata. @returns {Array} Returns data. / function mergeData(data, source) { var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask &lt; (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG); var isCombo = ((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_CURRY_FLAG)) || ((srcBitmask == WRAP_ARY_FLAG) &amp;&amp; (bitmask == WRAP_REARG_FLAG) &amp;&amp; (data[7].length &lt;= source[8])) || ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) &amp;&amp; (source[7].length &lt;= source[8]) &amp;&amp; (bitmask == WRAP_CURRY_FLAG)); // Exit early if metadata can’t be merged. if (!(isCommon || isCombo)) { return data; } // Use source thisArg if available. if (srcBitmask &amp; WRAP_BIND_FLAG) { data[2] = source[2]; // Set when currying a bound function. newBitmask |= bitmask &amp; WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG; } // Compose partial arguments. var value = source[3]; if (value) { var partials = data[3]; data[3] = partials ? composeArgs(partials, value, source[4]) : value; data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]; } // Compose partial right arguments. value = source[5]; if (value) { partials = data[5]; data[5] = partials ? composeArgsRight(partials, value, source[6]) : value; data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]; } // Use source argPos if available. value = source[7]; if (value) { data[7] = value; } // Use source ary if it’s smaller. if (srcBitmask &amp; WRAP_ARY_FLAG) { data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]); } // Use source arity if one is not provided. if (data[9] == null) { data[9] = source[9]; } // Use source func and merge bitmasks. data[0] = source[0]; data[1] = newBitmask; return data; } / This function is like Object.keys except that it includes inherited enumerable properties. @private @param {Object} object The object to query. @returns {Array} Returns the array of property names. / function nativeKeysIn(object) { var result = []; if (object != null) { for (var key in Object(object)) { result.push(key); } } return result; } / Converts value to a string using Object.prototype.toString. @private @param {} value The value to convert. @returns {string} Returns the converted string. / function objectToString(value) { return nativeObjectToString.call(value); } /** A specialized version of baseRest which transforms the rest array. @private @param {Function} func The function to apply a rest parameter to. @param {number} [start=func.length-1] The start position of the rest parameter. @param {Function} transform The rest array transform. @returns {Function} Returns the new function. / function overRest(func, start, transform) { start = nativeMax(start === undefined ? (func.length - 1) : start, 0); return function() { var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); while (++index &lt; length) { array[index] = args[start + index]; } index = -1; var otherArgs = Array(start + 1); while (++index &lt; start) { otherArgs[index] = args[index]; } otherArgs[start] = transform(array); return apply(func, this, otherArgs); }; } /** Gets the parent value at path of object. @private @param {Object} object The object to query. @param {Array} path The path to get the parent value of. @returns {} Returns the parent value. / function parent(object, path) { return path.length &lt; 2 ? object : baseGet(object, baseSlice(path, 0, -1)); } /** Reorder array according to the specified indexes where the element at the first index is assigned as the first element, the element at the second index is assigned as the second element, and so on. @private @param {Array} array The array to reorder. @param {Array} indexes The arranged array indexes. @returns {Array} Returns array. / function reorder(array, indexes) { var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); while (length–) { var index = indexes[length]; array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined; } return array; } / Gets the value at key, unless key is “proto“. @private @param {Object} object The object to query. @param {string} key The key of the property to get. @returns {} Returns the property value. / function safeGet(object, key) { if (key == ‘proto‘) { return; } return object[key]; } / Sets metadata for func. Note: If this function becomes hot, i.e. is invoked a lot in a short period of time, it will trip its breaker and transition to an identity function to avoid garbage collection pauses in V8. See V8 issue 2070 for more details. @private @param {Function} func The function to associate metadata with. @param {} data The metadata. @returns {Function} Returns func. / var setData = shortOut(baseSetData); / A simple wrapper around the global setTimeout. @private @param {Function} func The function to delay. @param {number} wait The number of milliseconds to delay invocation. @returns {number|Object} Returns the timer id or timeout object. */ var setTimeout = ctxSetTimeout || function(func, wait) { return root.setTimeout(func, wait); }; / Sets the toString method of func to return string. @private @param {Function} func The function to modify. @param {Function} string The toString result. @returns {Function} Returns func. / var setToString = shortOut(baseSetToString); /** Sets the toString method of wrapper to mimic the source of reference with wrapper details in a comment at the top of the source body. @private @param {Function} wrapper The function to modify. @param {Function} reference The reference function. @param {number} bitmask The bitmask flags. See createWrap for more details. @returns {Function} Returns wrapper. / function setWrapToString(wrapper, reference, bitmask) { var source = (reference + ‘’); return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask))); } / Creates a function that’ll short out and invoke identity instead of func when it’s called HOT_COUNT or more times in HOT_SPAN milliseconds. @private @param {Function} func The function to restrict. @returns {Function} Returns the new shortable function. / function shortOut(func) { var count = 0, lastCalled = 0; return function() { var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled); lastCalled = stamp; if (remaining &gt; 0) { if (++count &gt;= HOT_COUNT) { return arguments[0]; } } else { count = 0; } return func.apply(undefined, arguments); }; } / A specialized version of _.shuffle which mutates and sets the size of array. @private @param {Array} array The array to shuffle. @param {number} [size=array.length] The size of array. @returns {Array} Returns array. / function shuffleSelf(array, size) { var index = -1, length = array.length, lastIndex = length - 1; size = size === undefined ? length : size; while (++index &lt; size) { var rand = baseRandom(index, lastIndex), value = array[rand]; array[rand] = array[index]; array[index] = value; } array.length = size; return array; } /** Converts string to a property path array. @private @param {string} string The string to convert. @returns {Array} Returns the property path array. / var stringToPath = memoizeCapped(function(string) { var result = []; if (string.charCodeAt(0) === 46 / . /) { result.push(‘’); } string.replace(rePropName, function(match, number, quote, subString) { result.push(quote ? subString.replace(reEscapeChar, ‘$1’) : (number || match)); }); return result; }); /** Converts value to a string key if it’s not a string or symbol. @private @param {} value The value to inspect. @returns {string|symbol} Returns the key. / function toKey(value) { if (typeof value == ‘string’ || isSymbol(value)) { return value; } var result = (value + ‘’); return (result == ‘0’ &amp;&amp; (1 / value) == -INFINITY) ? ‘-0’ : result; } / Converts func to its source code. @private @param {Function} func The function to convert. @returns {string} Returns the source code. / function toSource(func) { if (func != null) { try { return funcToString.call(func); } catch (e) {} try { return (func + ‘’); } catch (e) {} } return ‘’; } / Updates wrapper details based on bitmask flags. @private @returns {Array} details The details to modify. @param {number} bitmask The bitmask flags. See createWrap for more details. @returns {Array} Returns details. / function updateWrapDetails(details, bitmask) { arrayEach(wrapFlags, function(pair) { var value = ‘_.’ + pair[0]; if ((bitmask &amp; pair[1]) &amp;&amp; !arrayIncludes(details, value)) { details.push(value); } }); return details.sort(); } /** Creates a clone of wrapper. @private @param {Object} wrapper The wrapper to clone. @returns {Object} Returns the cloned wrapper. / function wrapperClone(wrapper) { if (wrapper instanceof LazyWrapper) { return wrapper.clone(); } var result = new LodashWrapper(wrapper.wrapped, wrapper.chain); result.actions = copyArray(wrapper.actions); result.index = wrapper.index; result.values = wrapper.values; return result; } /————————————————————————/ /** Creates an array of elements split into groups the length of size. If array can’t be split evenly, the final chunk will be the remaining elements. @static @memberOf _ @since 3.0.0 @category Array @param {Array} array The array to process. @param {number} [size=1] The length of each chunk @param- {Object} [guard] Enables use as an iteratee for methods like _.map. @returns {Array} Returns the new array of chunks. @example _.chunk([‘a’, ‘b’, ‘c’, ‘d’], 2); // =&gt; [[‘a’, ‘b’], [‘c’, ‘d’]] _.chunk([‘a’, ‘b’, ‘c’, ‘d’], 3); // =&gt; [[‘a’, ‘b’, ‘c’], [‘d’]] / function chunk(array, size, guard) { if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) { size = 1; } else { size = nativeMax(toInteger(size), 0); } var length = array == null ? 0 : array.length; if (!length || size &lt; 1) { return []; } var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); while (index &lt; length) { result[resIndex++] = baseSlice(array, index, (index += size)); } return result; } /** Creates an array with all falsey values removed. The values false, null, 0, &quot;&quot;, undefined, and NaN are falsey. @static @memberOf _ @since 0.1.0 @category Array @param {Array} array The array to compact. @returns {Array} Returns the new array of filtered values. @example _.compact([0, 1, false, 2, ‘’, 3]); // =&gt; [1, 2, 3] / function compact(array) { var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; while (++index &lt; length) { var value = array[index]; if (value) { result[resIndex++] = value; } } return result; } /** Creates a new array concatenating array with any additional arrays and/or values. @static @memberOf _ @since 4.0.0 @category Array @param {Array} array The array to concatenate. @param {…} [values] The values to concatenate. @returns {Array} Returns the new concatenated array. @example var array = [1]; var other = .concat(array, 2, [3], [[4]]); console.log(other); // =&gt; [1, 2, 3, [4]] console.log(array); // =&gt; [1] / function concat() { var length = arguments.length; if (!length) { return []; } var args = Array(length - 1), array = arguments[0], index = length; while (index–) { args[index - 1] = arguments[index]; } return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1)); } /** Creates an array of array values not included in the other given arrays using SameValueZero for equality comparisons. The order and references of result values are determined by the first array. * Note: Unlike `.pullAll, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @returns {Array} Returns the new array of filtered values. * @see _.without, _.xor * @example * * _.difference([2, 1], [2, 3]); * // =&gt; [1] */ var difference = baseRest(function(array, values) { return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : []; }); /** * This method is like.differenceexcept that it acceptsiterateewhich * is invoked for each element ofarrayandvaluesto generate the criterion * by which they&#39;re compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * * **Note:** Unlike.pullAllBy, this method returns a new array. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [1.2] * * // The_.propertyiteratee shorthand. * _.differenceBy([{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], [{ &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 2 }] */ var differenceBy = baseRest(function(array, values) { var iteratee = last(values); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : []; }); /** * This method is like.differenceexcept that it acceptscomparator* which is invoked to compare elements ofarraytovalues. The order and * references of result values are determined by the first array. The comparator * is invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike.pullAllWith, this method returns a new array. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {...Array} [values] The values to exclude. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * * _.differenceWith(objects, [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }], _.isEqual); * // =&gt; [{ &#39;x&#39;: 2, &#39;y&#39;: 1 }] */ var differenceWith = baseRest(function(array, values) { var comparator = last(values); if (isArrayLikeObject(comparator)) { comparator = undefined; } return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : []; }); /** * Creates a slice ofarraywithnelements dropped from the beginning. * * @static * @memberOf _ * @since 0.5.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to drop. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.drop([1, 2, 3]); * // =&gt; [2, 3] * * _.drop([1, 2, 3], 2); * // =&gt; [3] * * _.drop([1, 2, 3], 5); * // =&gt; [] * * _.drop([1, 2, 3], 0); * // =&gt; [1, 2, 3] */ function drop(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, n &lt; 0 ? 0 : n, length); } /** * Creates a slice ofarraywithnelements dropped from the end. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to drop. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.dropRight([1, 2, 3]); * // =&gt; [1, 2] * * _.dropRight([1, 2, 3], 2); * // =&gt; [1] * * _.dropRight([1, 2, 3], 5); * // =&gt; [] * * _.dropRight([1, 2, 3], 0); * // =&gt; [1, 2, 3] */ function dropRight(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); n = length - n; return baseSlice(array, 0, n &lt; 0 ? 0 : n); } /** * Creates a slice ofarrayexcluding elements dropped from the end. * Elements are dropped untilpredicatereturns falsey. The predicate is * invoked with three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.dropRightWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesiteratee shorthand. * _.dropRightWhile(users, { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.dropRightWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;barney&#39;] * * // The_.propertyiteratee shorthand. * _.dropRightWhile(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;, &#39;pebbles&#39;] */ function dropRightWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), true, true) : []; } /** * Creates a slice ofarrayexcluding elements dropped from the beginning. * Elements are dropped untilpredicatereturns falsey. The predicate is * invoked with three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.dropWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.matchesiteratee shorthand. * _.dropWhile(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.dropWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.propertyiteratee shorthand. * _.dropWhile(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;, &#39;pebbles&#39;] */ function dropWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), true) : []; } /** * Fills elements ofarraywithvaluefromstartup to, but not * including,end. * * **Note:** This method mutatesarray. * * @static * @memberOf _ * @since 3.2.0 * @category Array * @param {Array} array The array to fill. * @param {*} value The value to fillarraywith. * @param {number} [start=0] The start position. * @param {number} [end=array.length] The end position. * @returns {Array} Returnsarray. * @example * * var array = [1, 2, 3]; * * _.fill(array, &#39;a&#39;); * console.log(array); * // =&gt; [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;] * * _.fill(Array(3), 2); * // =&gt; [2, 2, 2] * * _.fill([4, 6, 8, 10], &#39;*&#39;, 1, 3); * // =&gt; [4, &#39;*&#39;, &#39;*&#39;, 10] */ function fill(array, value, start, end) { var length = array == null ? 0 : array.length; if (!length) { return []; } if (start &amp;&amp; typeof start != &#39;number&#39; &amp;&amp; isIterateeCall(array, value, start)) { start = 0; end = length; } return baseFill(array, value, start, end); } /** * This method is like_.findexcept that it returns the index of the first * elementpredicatereturns truthy for instead of the element itself. * * @static * @memberOf _ * @since 1.1.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=0] The index to search from. * @returns {number} Returns the index of the found element, else-1. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.findIndex(users, function(o) { return o.user == &#39;barney&#39;; }); * // =&gt; 0 * * // The_.matchesiteratee shorthand. * _.findIndex(users, { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }); * // =&gt; 1 * * // The_.matchesPropertyiteratee shorthand. * _.findIndex(users, [&#39;active&#39;, false]); * // =&gt; 0 * * // The_.propertyiteratee shorthand. * _.findIndex(users, &#39;active&#39;); * // =&gt; 2 */ function findIndex(array, predicate, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) { index = nativeMax(length + index, 0); } return baseFindIndex(array, getIteratee(predicate, 3), index); } /** * This method is like_.findIndexexcept that it iterates over elements * ofcollectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=array.length-1] The index to search from. * @returns {number} Returns the index of the found element, else-1. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.findLastIndex(users, function(o) { return o.user == &#39;pebbles&#39;; }); * // =&gt; 2 * * // The_.matchesiteratee shorthand. * _.findLastIndex(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }); * // =&gt; 0 * * // The_.matchesPropertyiteratee shorthand. * _.findLastIndex(users, [&#39;active&#39;, false]); * // =&gt; 2 * * // The_.propertyiteratee shorthand. * _.findLastIndex(users, &#39;active&#39;); * // =&gt; 0 */ function findLastIndex(array, predicate, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = length - 1; if (fromIndex !== undefined) { index = toInteger(fromIndex); index = fromIndex &lt; 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1); } return baseFindIndex(array, getIteratee(predicate, 3), index, true); } /** * Flattensarraya single level deep. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to flatten. * @returns {Array} Returns the new flattened array. * @example * * _.flatten([1, [2, [3, [4]], 5]]); * // =&gt; [1, 2, [3, [4]], 5] */ function flatten(array) { var length = array == null ? 0 : array.length; return length ? baseFlatten(array, 1) : []; } /** * Recursively flattensarray. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to flatten. * @returns {Array} Returns the new flattened array. * @example * * _.flattenDeep([1, [2, [3, [4]], 5]]); * // =&gt; [1, 2, 3, 4, 5] */ function flattenDeep(array) { var length = array == null ? 0 : array.length; return length ? baseFlatten(array, INFINITY) : []; } /** * Recursively flattenarrayup todepthtimes. * * @static * @memberOf _ * @since 4.4.0 * @category Array * @param {Array} array The array to flatten. * @param {number} [depth=1] The maximum recursion depth. * @returns {Array} Returns the new flattened array. * @example * * var array = [1, [2, [3, [4]], 5]]; * * _.flattenDepth(array, 1); * // =&gt; [1, 2, [3, [4]], 5] * * _.flattenDepth(array, 2); * // =&gt; [1, 2, 3, [4], 5] */ function flattenDepth(array, depth) { var length = array == null ? 0 : array.length; if (!length) { return []; } depth = depth === undefined ? 1 : toInteger(depth); return baseFlatten(array, depth); } /** * The inverse of_.toPairs; this method returns an object composed * from key-valuepairs. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} pairs The key-value pairs. * @returns {Object} Returns the new object. * @example * * _.fromPairs([[&#39;a&#39;, 1], [&#39;b&#39;, 2]]); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ function fromPairs(pairs) { var index = -1, length = pairs == null ? 0 : pairs.length, result = {}; while (++index &lt; length) { var pair = pairs[index]; result[pair[0]] = pair[1]; } return result; } /** * Gets the first element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @alias first * @category Array * @param {Array} array The array to query. * @returns {*} Returns the first element ofarray. * @example * * _.head([1, 2, 3]); * // =&gt; 1 * * _.head([]); * // =&gt; undefined */ function head(array) { return (array &amp;&amp; array.length) ? array[0] : undefined; } /** * Gets the index at which the first occurrence ofvalueis found inarray* using [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. IffromIndexis negative, it&#39;s used as the * offset from the end ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=0] The index to search from. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.indexOf([1, 2, 1, 2], 2); * // =&gt; 1 * * // Search from thefromIndex. * _.indexOf([1, 2, 1, 2], 2, 2); * // =&gt; 3 */ function indexOf(array, value, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = fromIndex == null ? 0 : toInteger(fromIndex); if (index &lt; 0) { index = nativeMax(length + index, 0); } return baseIndexOf(array, value, index); } /** * Gets all but the last element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @returns {Array} Returns the slice ofarray. * @example * * _.initial([1, 2, 3]); * // =&gt; [1, 2] */ function initial(array) { var length = array == null ? 0 : array.length; return length ? baseSlice(array, 0, -1) : []; } /** * Creates an array of unique values that are included in all given arrays * using [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. The order and references of result values are * determined by the first array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of intersecting values. * @example * * _.intersection([2, 1], [2, 3]); * // =&gt; [2] */ var intersection = baseRest(function(arrays) { var mapped = arrayMap(arrays, castArrayLikeObject); return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped) : []; }); /** * This method is like_.intersectionexcept that it acceptsiteratee* which is invoked for each element of eacharraysto generate the criterion * by which they&#39;re compared. The order and references of result values are * determined by the first array. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of intersecting values. * @example * * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [2.1] * * // The_.propertyiteratee shorthand. * _.intersectionBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }] */ var intersectionBy = baseRest(function(arrays) { var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject); if (iteratee === last(mapped)) { iteratee = undefined; } else { mapped.pop(); } return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []; }); /** * This method is like_.intersectionexcept that it acceptscomparator* which is invoked to compare elements ofarrays. The order and references * of result values are determined by the first array. The comparator is * invoked with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of intersecting values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.intersectionWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }] */ var intersectionWith = baseRest(function(arrays) { var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; if (comparator) { mapped.pop(); } return (mapped.length &amp;&amp; mapped[0] === arrays[0]) ? baseIntersection(mapped, undefined, comparator) : []; }); /** * Converts all elements inarrayinto a string separated byseparator. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to convert. * @param {string} [separator=&#39;,&#39;] The element separator. * @returns {string} Returns the joined string. * @example * * _.join([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;~&#39;); * // =&gt; &#39;a~b~c&#39; */ function join(array, separator) { return array == null ? &#39;&#39; : nativeJoin.call(array, separator); } /** * Gets the last element ofarray. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @returns {*} Returns the last element ofarray. * @example * * _.last([1, 2, 3]); * // =&gt; 3 */ function last(array) { var length = array == null ? 0 : array.length; return length ? array[length - 1] : undefined; } /** * This method is like_.indexOfexcept that it iterates over elements of *arrayfrom right to left. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=array.length-1] The index to search from. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.lastIndexOf([1, 2, 1, 2], 2); * // =&gt; 3 * * // Search from thefromIndex. * _.lastIndexOf([1, 2, 1, 2], 2, 2); * // =&gt; 1 */ function lastIndexOf(array, value, fromIndex) { var length = array == null ? 0 : array.length; if (!length) { return -1; } var index = length; if (fromIndex !== undefined) { index = toInteger(fromIndex); index = index &lt; 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1); } return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true); } /** * Gets the element at indexnofarray. Ifnis negative, the nth * element from the end is returned. * * @static * @memberOf _ * @since 4.11.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=0] The index of the element to return. * @returns {*} Returns the nth element ofarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; * * _.nth(array, 1); * // =&gt; &#39;b&#39; * * _.nth(array, -2); * // =&gt; &#39;c&#39;; */ function nth(array, n) { return (array &amp;&amp; array.length) ? baseNth(array, toInteger(n)) : undefined; } /** * Removes all given values fromarrayusing * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike.without, this method mutatesarray. Use.remove* to remove elements from an array by predicate. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to modify. * @param {...*} [values] The values to remove. * @returns {Array} Returnsarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; * * _.pull(array, &#39;a&#39;, &#39;c&#39;); * console.log(array); * // =&gt; [&#39;b&#39;, &#39;b&#39;] */ var pull = baseRest(pullAll); /** * This method is like.pullexcept that it accepts an array of values to remove. * * **Note:** Unlike.difference, this method mutatesarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @returns {Array} Returnsarray. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; * * _.pullAll(array, [&#39;a&#39;, &#39;c&#39;]); * console.log(array); * // =&gt; [&#39;b&#39;, &#39;b&#39;] */ function pullAll(array, values) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values) : array; } /** * This method is like.pullAllexcept that it acceptsiterateewhich is * invoked for each element ofarrayandvaluesto generate the criterion * by which they&#39;re compared. The iteratee is invoked with one argument: (value). * * **Note:** Unlike.differenceBy, this method mutatesarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returnsarray. * @example * * var array = [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }, { &#39;x&#39;: 3 }, { &#39;x&#39;: 1 }]; * * _.pullAllBy(array, [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 3 }], &#39;x&#39;); * console.log(array); * // =&gt; [{ &#39;x&#39;: 2 }] */ function pullAllBy(array, values, iteratee) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values, getIteratee(iteratee, 2)) : array; } /** * This method is like.pullAllexcept that it acceptscomparatorwhich * is invoked to compare elements ofarraytovalues. The comparator is * invoked with two arguments: (arrVal, othVal). * * **Note:** Unlike.differenceWith, this method mutatesarray. * * @static * @memberOf _ * @since 4.6.0 * @category Array * @param {Array} array The array to modify. * @param {Array} values The values to remove. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returnsarray. * @example * * var array = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 3, &#39;y&#39;: 4 }, { &#39;x&#39;: 5, &#39;y&#39;: 6 }]; * * _.pullAllWith(array, [{ &#39;x&#39;: 3, &#39;y&#39;: 4 }], _.isEqual); * console.log(array); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 5, &#39;y&#39;: 6 }] */ function pullAllWith(array, values, comparator) { return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length) ? basePullAll(array, values, undefined, comparator) : array; } /** * Removes elements fromarraycorresponding toindexesand returns an * array of removed elements. * * **Note:** Unlike_.at, this method mutatesarray. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to modify. * @param {...(number|number[])} [indexes] The indexes of elements to remove. * @returns {Array} Returns the new array of removed elements. * @example * * var array = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; * var pulled = _.pullAt(array, [1, 3]); * * console.log(array); * // =&gt; [&#39;a&#39;, &#39;c&#39;] * * console.log(pulled); * // =&gt; [&#39;b&#39;, &#39;d&#39;] */ var pullAt = flatRest(function(array, indexes) { var length = array == null ? 0 : array.length, result = baseAt(array, indexes); basePullAt(array, arrayMap(indexes, function(index) { return isIndex(index, length) ? +index : index; }).sort(compareAscending)); return result; }); /** * Removes all elements fromarraythatpredicatereturns truthy for * and returns an array of the removed elements. The predicate is invoked * with three arguments: (value, index, array). * * **Note:** Unlike.filter, this method mutatesarray. Use.pull* to pull elements from an array by value. * * @static * @memberOf _ * @since 2.0.0 * @category Array * @param {Array} array The array to modify. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new array of removed elements. * @example * * var array = [1, 2, 3, 4]; * var evens = _.remove(array, function(n) { * return n % 2 == 0; * }); * * console.log(array); * // =&gt; [1, 3] * * console.log(evens); * // =&gt; [2, 4] */ function remove(array, predicate) { var result = []; if (!(array &amp;&amp; array.length)) { return result; } var index = -1, indexes = [], length = array.length; predicate = getIteratee(predicate, 3); while (++index &lt; length) { var value = array[index]; if (predicate(value, index, array)) { result.push(value); indexes.push(index); } } basePullAt(array, indexes); return result; } /** * Reversesarrayso that the first element becomes the last, the second * element becomes the second to last, and so on. * * **Note:** This method mutatesarrayand is based on * [Array#reverse](https://mdn.io/Array/reverse). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to modify. * @returns {Array} Returnsarray. * @example * * var array = [1, 2, 3]; * * _.reverse(array); * // =&gt; [3, 2, 1] * * console.log(array); * // =&gt; [3, 2, 1] */ function reverse(array) { return array == null ? array : nativeReverse.call(array); } /** * Creates a slice ofarrayfromstartup to, but not including,end. * * **Note:** This method is used instead of * [Array#slice](https://mdn.io/Array/slice) to ensure dense arrays are * returned. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to slice. * @param {number} [start=0] The start position. * @param {number} [end=array.length] The end position. * @returns {Array} Returns the slice ofarray. */ function slice(array, start, end) { var length = array == null ? 0 : array.length; if (!length) { return []; } if (end &amp;&amp; typeof end != &#39;number&#39; &amp;&amp; isIterateeCall(array, start, end)) { start = 0; end = length; } else { start = start == null ? 0 : toInteger(start); end = end === undefined ? length : toInteger(end); } return baseSlice(array, start, end); } /** * Uses a binary search to determine the lowest index at whichvalue* should be inserted intoarrayin order to maintain its sort order. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * _.sortedIndex([30, 50], 40); * // =&gt; 1 */ function sortedIndex(array, value) { return baseSortedIndex(array, value); } /** * This method is like_.sortedIndexexcept that it acceptsiteratee* which is invoked forvalueand each element ofarrayto compute their * sort ranking. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * var objects = [{ &#39;x&#39;: 4 }, { &#39;x&#39;: 5 }]; * * _.sortedIndexBy(objects, { &#39;x&#39;: 4 }, function(o) { return o.x; }); * // =&gt; 0 * * // The_.propertyiteratee shorthand. * _.sortedIndexBy(objects, { &#39;x&#39;: 4 }, &#39;x&#39;); * // =&gt; 0 */ function sortedIndexBy(array, value, iteratee) { return baseSortedIndexBy(array, value, getIteratee(iteratee, 2)); } /** * This method is like_.indexOfexcept that it performs a binary * search on a sortedarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.sortedIndexOf([4, 5, 5, 5, 6], 5); * // =&gt; 1 */ function sortedIndexOf(array, value) { var length = array == null ? 0 : array.length; if (length) { var index = baseSortedIndex(array, value); if (index &lt; length &amp;&amp; eq(array[index], value)) { return index; } } return -1; } /** * This method is like_.sortedIndexexcept that it returns the highest * index at whichvalueshould be inserted intoarrayin order to * maintain its sort order. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * _.sortedLastIndex([4, 5, 5, 5, 6], 5); * // =&gt; 4 */ function sortedLastIndex(array, value) { return baseSortedIndex(array, value, true); } /** * This method is like_.sortedLastIndexexcept that it acceptsiteratee* which is invoked forvalueand each element ofarrayto compute their * sort ranking. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The sorted array to inspect. * @param {*} value The value to evaluate. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the index at whichvalueshould be inserted * intoarray. * @example * * var objects = [{ &#39;x&#39;: 4 }, { &#39;x&#39;: 5 }]; * * _.sortedLastIndexBy(objects, { &#39;x&#39;: 4 }, function(o) { return o.x; }); * // =&gt; 1 * * // The_.propertyiteratee shorthand. * _.sortedLastIndexBy(objects, { &#39;x&#39;: 4 }, &#39;x&#39;); * // =&gt; 1 */ function sortedLastIndexBy(array, value, iteratee) { return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true); } /** * This method is like_.lastIndexOfexcept that it performs a binary * search on a sortedarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {*} value The value to search for. * @returns {number} Returns the index of the matched value, else-1. * @example * * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5); * // =&gt; 3 */ function sortedLastIndexOf(array, value) { var length = array == null ? 0 : array.length; if (length) { var index = baseSortedIndex(array, value, true) - 1; if (eq(array[index], value)) { return index; } } return -1; } /** * This method is like_.uniqexcept that it&#39;s designed and optimized * for sorted arrays. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @returns {Array} Returns the new duplicate free array. * @example * * _.sortedUniq([1, 1, 2]); * // =&gt; [1, 2] */ function sortedUniq(array) { return (array &amp;&amp; array.length) ? baseSortedUniq(array) : []; } /** * This method is like_.uniqByexcept that it&#39;s designed and optimized * for sorted arrays. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [iteratee] The iteratee invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor); * // =&gt; [1.1, 2.3] */ function sortedUniqBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []; } /** * Gets all but the first element ofarray. * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to query. * @returns {Array} Returns the slice ofarray. * @example * * _.tail([1, 2, 3]); * // =&gt; [2, 3] */ function tail(array) { var length = array == null ? 0 : array.length; return length ? baseSlice(array, 1, length) : []; } /** * Creates a slice ofarraywithnelements taken from the beginning. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to take. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.take([1, 2, 3]); * // =&gt; [1] * * _.take([1, 2, 3], 2); * // =&gt; [1, 2] * * _.take([1, 2, 3], 5); * // =&gt; [1, 2, 3] * * _.take([1, 2, 3], 0); * // =&gt; [] */ function take(array, n, guard) { if (!(array &amp;&amp; array.length)) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); return baseSlice(array, 0, n &lt; 0 ? 0 : n); } /** * Creates a slice ofarraywithnelements taken from the end. * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {number} [n=1] The number of elements to take. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the slice ofarray. * @example * * _.takeRight([1, 2, 3]); * // =&gt; [3] * * _.takeRight([1, 2, 3], 2); * // =&gt; [2, 3] * * _.takeRight([1, 2, 3], 5); * // =&gt; [1, 2, 3] * * _.takeRight([1, 2, 3], 0); * // =&gt; [] */ function takeRight(array, n, guard) { var length = array == null ? 0 : array.length; if (!length) { return []; } n = (guard || n === undefined) ? 1 : toInteger(n); n = length - n; return baseSlice(array, n &lt; 0 ? 0 : n, length); } /** * Creates a slice ofarraywith elements taken from the end. Elements are * taken untilpredicatereturns falsey. The predicate is invoked with * three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false } * ]; * * _.takeRightWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.matchesiteratee shorthand. * _.takeRightWhile(users, { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;pebbles&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.takeRightWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;, &#39;pebbles&#39;] * * // The_.propertyiteratee shorthand. * _.takeRightWhile(users, &#39;active&#39;); * // =&gt; [] */ function takeRightWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3), false, true) : []; } /** * Creates a slice ofarraywith elements taken from the beginning. Elements * are taken untilpredicatereturns falsey. The predicate is invoked with * three arguments: (value, index, array). * * @static * @memberOf _ * @since 3.0.0 * @category Array * @param {Array} array The array to query. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the slice ofarray. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;active&#39;: true } * ]; * * _.takeWhile(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.takeWhile(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.takeWhile(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;barney&#39;, &#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.takeWhile(users, &#39;active&#39;); * // =&gt; [] */ function takeWhile(array, predicate) { return (array &amp;&amp; array.length) ? baseWhile(array, getIteratee(predicate, 3)) : []; } /** * Creates an array of unique values, in order, from all given arrays using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of combined values. * @example * * _.union([2], [1, 2]); * // =&gt; [2, 1] */ var union = baseRest(function(arrays) { return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true)); }); /** * This method is like_.unionexcept that it acceptsiterateewhich is * invoked for each element of eacharraysto generate the criterion by * which uniqueness is computed. Result values are chosen from the first * array in which the value occurs. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of combined values. * @example * * _.unionBy([2.1], [1.2, 2.3], Math.floor); * // =&gt; [2.1, 1.2] * * // The_.propertyiteratee shorthand. * _.unionBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }] */ var unionBy = baseRest(function(arrays) { var iteratee = last(arrays); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)); }); /** * This method is like_.unionexcept that it acceptscomparatorwhich * is invoked to compare elements ofarrays. Result values are chosen from * the first array in which the value occurs. The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of combined values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.unionWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 1 }] */ var unionWith = baseRest(function(arrays) { var comparator = last(arrays); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator); }); /** * Creates a duplicate-free version of an array, using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons, in which only the first occurrence of each element * is kept. The order of result values is determined by the order they occur * in the array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @returns {Array} Returns the new duplicate free array. * @example * * _.uniq([2, 1, 2]); * // =&gt; [2, 1] */ function uniq(array) { return (array &amp;&amp; array.length) ? baseUniq(array) : []; } /** * This method is like_.uniqexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * uniqueness is computed. The order of result values is determined by the * order they occur in the array. The iteratee is invoked with one argument: * (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * _.uniqBy([2.1, 1.2, 2.3], Math.floor); * // =&gt; [2.1, 1.2] * * // The_.propertyiteratee shorthand. * _.uniqBy([{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 1 }, { &#39;x&#39;: 2 }] */ function uniqBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : []; } /** * This method is like_.uniqexcept that it acceptscomparatorwhich * is invoked to compare elements ofarray. The order of result values is * determined by the order they occur in the array.The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {Array} array The array to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new duplicate free array. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.uniqWith(objects, _.isEqual); * // =&gt; [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }] */ function uniqWith(array, comparator) { comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return (array &amp;&amp; array.length) ? baseUniq(array, undefined, comparator) : []; } /** * This method is like_.zipexcept that it accepts an array of grouped * elements and creates an array regrouping the elements to their pre-zip * configuration. * * @static * @memberOf _ * @since 1.2.0 * @category Array * @param {Array} array The array of grouped elements to process. * @returns {Array} Returns the new array of regrouped elements. * @example * * var zipped = _.zip([&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]); * // =&gt; [[&#39;a&#39;, 1, true], [&#39;b&#39;, 2, false]] * * _.unzip(zipped); * // =&gt; [[&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]] */ function unzip(array) { if (!(array &amp;&amp; array.length)) { return []; } var length = 0; array = arrayFilter(array, function(group) { if (isArrayLikeObject(group)) { length = nativeMax(group.length, length); return true; } }); return baseTimes(length, function(index) { return arrayMap(array, baseProperty(index)); }); } /** * This method is like_.unzipexcept that it acceptsiterateeto specify * how regrouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * * @static * @memberOf _ * @since 3.8.0 * @category Array * @param {Array} array The array of grouped elements to process. * @param {Function} [iteratee=_.identity] The function to combine * regrouped values. * @returns {Array} Returns the new array of regrouped elements. * @example * * var zipped = _.zip([1, 2], [10, 20], [100, 200]); * // =&gt; [[1, 10, 100], [2, 20, 200]] * * _.unzipWith(zipped, _.add); * // =&gt; [3, 30, 300] */ function unzipWith(array, iteratee) { if (!(array &amp;&amp; array.length)) { return []; } var result = unzip(array); if (iteratee == null) { return result; } return arrayMap(result, function(group) { return apply(iteratee, undefined, group); }); } /** * Creates an array excluding all given values using * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * for equality comparisons. * * **Note:** Unlike_.pull, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {Array} array The array to inspect. * @param {...*} [values] The values to exclude. * @returns {Array} Returns the new array of filtered values. * @see _.difference, _.xor * @example * * _.without([2, 1, 2, 3], 1, 2); * // =&gt; [3] */ var without = baseRest(function(array, values) { return isArrayLikeObject(array) ? baseDifference(array, values) : []; }); /** * Creates an array of unique values that is the * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference) * of the given arrays. The order of result values is determined by the order * they occur in the arrays. * * @static * @memberOf _ * @since 2.4.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @returns {Array} Returns the new array of filtered values. * @see _.difference, _.without * @example * * _.xor([2, 1], [2, 3]); * // =&gt; [1, 3] */ var xor = baseRest(function(arrays) { return baseXor(arrayFilter(arrays, isArrayLikeObject)); }); /** * This method is like_.xorexcept that it acceptsiterateewhich is * invoked for each element of eacharraysto generate the criterion by * which by which they&#39;re compared. The order of result values is determined * by the order they occur in the arrays. The iteratee is invoked with one * argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor); * // =&gt; [1.2, 3.4] * * // The_.propertyiteratee shorthand. * _.xorBy([{ &#39;x&#39;: 1 }], [{ &#39;x&#39;: 2 }, { &#39;x&#39;: 1 }], &#39;x&#39;); * // =&gt; [{ &#39;x&#39;: 2 }] */ var xorBy = baseRest(function(arrays) { var iteratee = last(arrays); if (isArrayLikeObject(iteratee)) { iteratee = undefined; } return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2)); }); /** * This method is like_.xorexcept that it acceptscomparatorwhich is * invoked to compare elements ofarrays. The order of result values is * determined by the order they occur in the arrays. The comparator is invoked * with two arguments: (arrVal, othVal). * * @static * @memberOf _ * @since 4.0.0 * @category Array * @param {...Array} [arrays] The arrays to inspect. * @param {Function} [comparator] The comparator invoked per element. * @returns {Array} Returns the new array of filtered values. * @example * * var objects = [{ &#39;x&#39;: 1, &#39;y&#39;: 2 }, { &#39;x&#39;: 2, &#39;y&#39;: 1 }]; * var others = [{ &#39;x&#39;: 1, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 2 }]; * * _.xorWith(objects, others, _.isEqual); * // =&gt; [{ &#39;x&#39;: 2, &#39;y&#39;: 1 }, { &#39;x&#39;: 1, &#39;y&#39;: 1 }] */ var xorWith = baseRest(function(arrays) { var comparator = last(arrays); comparator = typeof comparator == &#39;function&#39; ? comparator : undefined; return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator); }); /** * Creates an array of grouped elements, the first of which contains the * first elements of the given arrays, the second of which contains the * second elements of the given arrays, and so on. * * @static * @memberOf _ * @since 0.1.0 * @category Array * @param {...Array} [arrays] The arrays to process. * @returns {Array} Returns the new array of grouped elements. * @example * * _.zip([&#39;a&#39;, &#39;b&#39;], [1, 2], [true, false]); * // =&gt; [[&#39;a&#39;, 1, true], [&#39;b&#39;, 2, false]] */ var zip = baseRest(unzip); /** * This method is like_.fromPairsexcept that it accepts two arrays, * one of property identifiers and one of corresponding values. * * @static * @memberOf _ * @since 0.4.0 * @category Array * @param {Array} [props=[]] The property identifiers. * @param {Array} [values=[]] The property values. * @returns {Object} Returns the new object. * @example * * _.zipObject([&#39;a&#39;, &#39;b&#39;], [1, 2]); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ function zipObject(props, values) { return baseZipObject(props || [], values || [], assignValue); } /** * This method is like_.zipObjectexcept that it supports property paths. * * @static * @memberOf _ * @since 4.1.0 * @category Array * @param {Array} [props=[]] The property identifiers. * @param {Array} [values=[]] The property values. * @returns {Object} Returns the new object. * @example * * _.zipObjectDeep([&#39;a.b[0].c&#39;, &#39;a.b[1].d&#39;], [1, 2]); * // =&gt; { &#39;a&#39;: { &#39;b&#39;: [{ &#39;c&#39;: 1 }, { &#39;d&#39;: 2 }] } } */ function zipObjectDeep(props, values) { return baseZipObject(props || [], values || [], baseSet); } /** * This method is like_.zipexcept that it acceptsiterateeto specify * how grouped values should be combined. The iteratee is invoked with the * elements of each group: (...group). * * @static * @memberOf _ * @since 3.8.0 * @category Array * @param {...Array} [arrays] The arrays to process. * @param {Function} [iteratee=_.identity] The function to combine * grouped values. * @returns {Array} Returns the new array of grouped elements. * @example * * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) { * return a + b + c; * }); * // =&gt; [111, 222] */ var zipWith = baseRest(function(arrays) { var length = arrays.length, iteratee = length &gt; 1 ? arrays[length - 1] : undefined; iteratee = typeof iteratee == &#39;function&#39; ? (arrays.pop(), iteratee) : undefined; return unzipWith(arrays, iteratee); }); /*------------------------------------------------------------------------*/ /** * Creates alodashwrapper instance that wrapsvaluewith explicit method * chain sequences enabled. The result of such sequences must be unwrapped * with_#value. * * @static * @memberOf _ * @since 1.3.0 * @category Seq * @param {*} value The value to wrap. * @returns {Object} Returns the newlodashwrapper instance. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1 } * ]; * * var youngest = _ * .chain(users) * .sortBy(&#39;age&#39;) * .map(function(o) { * return o.user + &#39; is &#39; + o.age; * }) * .head() * .value(); * // =&gt; &#39;pebbles is 1&#39; */ function chain(value) { var result = lodash(value); result.__chain__ = true; return result; } /** * This method invokesinterceptorand returnsvalue. The interceptor * is invoked with one argument; (value). The purpose of this method is to * &quot;tap into&quot; a method chain sequence in order to modify intermediate results. * * @static * @memberOf _ * @since 0.1.0 * @category Seq * @param {*} value The value to provide tointerceptor. * @param {Function} interceptor The function to invoke. * @returns {*} Returnsvalue. * @example * * _([1, 2, 3]) * .tap(function(array) { * // Mutate input array. * array.pop(); * }) * .reverse() * .value(); * // =&gt; [2, 1] */ function tap(value, interceptor) { interceptor(value); return value; } /** * This method is like_.tapexcept that it returns the result ofinterceptor. * The purpose of this method is to &quot;pass thru&quot; values replacing intermediate * results in a method chain sequence. * * @static * @memberOf _ * @since 3.0.0 * @category Seq * @param {*} value The value to provide tointerceptor. * @param {Function} interceptor The function to invoke. * @returns {*} Returns the result ofinterceptor. * @example * * _(&#39; abc &#39;) * .chain() * .trim() * .thru(function(value) { * return [value]; * }) * .value(); * // =&gt; [&#39;abc&#39;] */ function thru(value, interceptor) { return interceptor(value); } /** * This method is the wrapper version of_.at. * * @name at * @memberOf _ * @since 1.0.0 * @category Seq * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Object} Returns the newlodashwrapper instance. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }, 4] }; * * _(object).at([&#39;a[0].b.c&#39;, &#39;a[1]&#39;]).value(); * // =&gt; [3, 4] */ var wrapperAt = flatRest(function(paths) { var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) { return baseAt(object, paths); }; if (length &gt; 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) { return this.thru(interceptor); } value = value.slice(start, +start + (length ? 1 : 0)); value.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [interceptor], &#39;thisArg&#39;: undefined }); return new LodashWrapper(value, this.__chain__).thru(function(array) { if (length &amp;&amp; !array.length) { array.push(undefined); } return array; }); }); /** * Creates alodashwrapper instance with explicit method chain sequences enabled. * * @name chain * @memberOf _ * @since 0.1.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 } * ]; * * // A sequence without explicit chaining. * _(users).head(); * // =&gt; { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } * * // A sequence with explicit chaining. * _(users) * .chain() * .head() * .pick(&#39;user&#39;) * .value(); * // =&gt; { &#39;user&#39;: &#39;barney&#39; } */ function wrapperChain() { return chain(this); } /** * Executes the chain sequence and returns the wrapped result. * * @name commit * @memberOf _ * @since 3.2.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var array = [1, 2]; * var wrapped = _(array).push(3); * * console.log(array); * // =&gt; [1, 2] * * wrapped = wrapped.commit(); * console.log(array); * // =&gt; [1, 2, 3] * * wrapped.last(); * // =&gt; 3 * * console.log(array); * // =&gt; [1, 2, 3] */ function wrapperCommit() { return new LodashWrapper(this.value(), this.__chain__); } /** * Gets the next value on a wrapped object following the * [iterator protocol](https://mdn.io/iteration_protocols#iterator). * * @name next * @memberOf _ * @since 4.0.0 * @category Seq * @returns {Object} Returns the next iterator value. * @example * * var wrapped = _([1, 2]); * * wrapped.next(); * // =&gt; { &#39;done&#39;: false, &#39;value&#39;: 1 } * * wrapped.next(); * // =&gt; { &#39;done&#39;: false, &#39;value&#39;: 2 } * * wrapped.next(); * // =&gt; { &#39;done&#39;: true, &#39;value&#39;: undefined } */ function wrapperNext() { if (this.__values__ === undefined) { this.__values__ = toArray(this.value()); } var done = this.__index__ &gt;= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++]; return { &#39;done&#39;: done, &#39;value&#39;: value }; } /** * Enables the wrapper to be iterable. * * @name Symbol.iterator * @memberOf _ * @since 4.0.0 * @category Seq * @returns {Object} Returns the wrapper object. * @example * * var wrapped = _([1, 2]); * * wrapped[Symbol.iterator]() === wrapped; * // =&gt; true * * Array.from(wrapped); * // =&gt; [1, 2] */ function wrapperToIterator() { return this; } /** * Creates a clone of the chain sequence plantingvalueas the wrapped value. * * @name plant * @memberOf _ * @since 3.2.0 * @category Seq * @param {*} value The value to plant. * @returns {Object} Returns the newlodashwrapper instance. * @example * * function square(n) { * return n * n; * } * * var wrapped = _([1, 2]).map(square); * var other = wrapped.plant([3, 4]); * * other.value(); * // =&gt; [9, 16] * * wrapped.value(); * // =&gt; [1, 4] */ function wrapperPlant(value) { var result, parent = this; while (parent instanceof baseLodash) { var clone = wrapperClone(parent); clone.__index__ = 0; clone.__values__ = undefined; if (result) { previous.__wrapped__ = clone; } else { result = clone; } var previous = clone; parent = parent.__wrapped__; } previous.__wrapped__ = value; return result; } /** * This method is the wrapper version of_.reverse. * * **Note:** This method mutates the wrapped array. * * @name reverse * @memberOf _ * @since 0.1.0 * @category Seq * @returns {Object} Returns the newlodashwrapper instance. * @example * * var array = [1, 2, 3]; * * _(array).reverse().value() * // =&gt; [3, 2, 1] * * console.log(array); * // =&gt; [3, 2, 1] */ function wrapperReverse() { var value = this.__wrapped__; if (value instanceof LazyWrapper) { var wrapped = value; if (this.__actions__.length) { wrapped = new LazyWrapper(this); } wrapped = wrapped.reverse(); wrapped.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [reverse], &#39;thisArg&#39;: undefined }); return new LodashWrapper(wrapped, this.__chain__); } return this.thru(reverse); } /** * Executes the chain sequence to resolve the unwrapped value. * * @name value * @memberOf _ * @since 0.1.0 * @alias toJSON, valueOf * @category Seq * @returns {*} Returns the resolved unwrapped value. * @example * * _([1, 2, 3]).value(); * // =&gt; [1, 2, 3] */ function wrapperValue() { return baseWrapperValue(this.__wrapped__, this.__actions__); } /*------------------------------------------------------------------------*/ /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The corresponding value of * each key is the number of times the key was returned byiteratee. The * iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 0.5.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * _.countBy([6.1, 4.2, 6.3], Math.floor); * // =&gt; { &#39;4&#39;: 1, &#39;6&#39;: 2 } * * // The_.propertyiteratee shorthand. * _.countBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); * // =&gt; { &#39;3&#39;: 2, &#39;5&#39;: 1 } */ var countBy = createAggregator(function(result, value, key) { if (hasOwnProperty.call(result, key)) { ++result[key]; } else { baseAssignValue(result, key, 1); } }); /** * Checks ifpredicatereturns truthy for **all** elements ofcollection. * Iteration is stopped oncepredicatereturns falsey. The predicate is * invoked with three arguments: (value, index|key, collection). * * **Note:** This method returnstruefor * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of * elements of empty collections. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {boolean} Returnstrueif all elements pass the predicate check, * elsefalse. * @example * * _.every([true, 1, null, &#39;yes&#39;], Boolean); * // =&gt; false * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.every(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; false * * // The_.matchesPropertyiteratee shorthand. * _.every(users, [&#39;active&#39;, false]); * // =&gt; true * * // The_.propertyiteratee shorthand. * _.every(users, &#39;active&#39;); * // =&gt; false */ function every(collection, predicate, guard) { var func = isArray(collection) ? arrayEvery : baseEvery; if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) { predicate = undefined; } return func(collection, getIteratee(predicate, 3)); } /** * Iterates over elements ofcollection, returning an array of all elements *predicatereturns truthy for. The predicate is invoked with three * arguments: (value, index|key, collection). * * **Note:** Unlike_.remove, this method returns a new array. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new filtered array. * @see _.reject * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * _.filter(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.filter(users, { &#39;age&#39;: 36, &#39;active&#39;: true }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.filter(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.filter(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;] */ function filter(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, getIteratee(predicate, 3)); } /** * Iterates over elements ofcollection, returning the first element *predicatereturns truthy for. The predicate is invoked with three * arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=0] The index to search from. * @returns {*} Returns the matched element, elseundefined. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1, &#39;active&#39;: true } * ]; * * _.find(users, function(o) { return o.age &lt; 40; }); * // =&gt; object for &#39;barney&#39; * * // The_.matchesiteratee shorthand. * _.find(users, { &#39;age&#39;: 1, &#39;active&#39;: true }); * // =&gt; object for &#39;pebbles&#39; * * // The_.matchesPropertyiteratee shorthand. * _.find(users, [&#39;active&#39;, false]); * // =&gt; object for &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.find(users, &#39;active&#39;); * // =&gt; object for &#39;barney&#39; */ var find = createFind(findIndex); /** * This method is like_.findexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @category Collection * @param {Array|Object} collection The collection to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param {number} [fromIndex=collection.length-1] The index to search from. * @returns {*} Returns the matched element, elseundefined. * @example * * _.findLast([1, 2, 3, 4], function(n) { * return n % 2 == 1; * }); * // =&gt; 3 */ var findLast = createFind(findLastIndex); /** * Creates a flattened array of values by running each element incollection* thruiterateeand flattening the mapped results. The iteratee is invoked * with three arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [n, n]; * } * * _.flatMap([1, 2], duplicate); * // =&gt; [1, 1, 2, 2] */ function flatMap(collection, iteratee) { return baseFlatten(map(collection, iteratee), 1); } /** * This method is like_.flatMapexcept that it recursively flattens the * mapped results. * * @static * @memberOf _ * @since 4.7.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [[[n, n]]]; * } * * _.flatMapDeep([1, 2], duplicate); * // =&gt; [1, 1, 2, 2] */ function flatMapDeep(collection, iteratee) { return baseFlatten(map(collection, iteratee), INFINITY); } /** * This method is like_.flatMapexcept that it recursively flattens the * mapped results up todepthtimes. * * @static * @memberOf _ * @since 4.7.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {number} [depth=1] The maximum recursion depth. * @returns {Array} Returns the new flattened array. * @example * * function duplicate(n) { * return [[[n, n]]]; * } * * _.flatMapDepth([1, 2], duplicate, 2); * // =&gt; [[1, 1], [2, 2]] */ function flatMapDepth(collection, iteratee, depth) { depth = depth === undefined ? 1 : toInteger(depth); return baseFlatten(map(collection, iteratee), depth); } /** * Iterates over elements ofcollectionand invokesiterateefor each element. * The iteratee is invoked with three arguments: (value, index|key, collection). * Iteratee functions may exit iteration early by explicitly returningfalse. * * **Note:** As with other &quot;Collections&quot; methods, objects with a &quot;length&quot; * property are iterated like arrays. To avoid this behavior use.forIn* or.forOwnfor object iteration. * * @static * @memberOf _ * @since 0.1.0 * @alias each * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array|Object} Returnscollection. * @see _.forEachRight * @example * * _.forEach([1, 2], function(value) { * console.log(value); * }); * // =&gt; Logs1then2. * * _.forEach({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39; then &#39;b&#39; (iteration order is not guaranteed). */ function forEach(collection, iteratee) { var func = isArray(collection) ? arrayEach : baseEach; return func(collection, getIteratee(iteratee, 3)); } /** * This method is like_.forEachexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 2.0.0 * @alias eachRight * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array|Object} Returnscollection. * @see _.forEach * @example * * _.forEachRight([1, 2], function(value) { * console.log(value); * }); * // =&gt; Logs2then1. */ function forEachRight(collection, iteratee) { var func = isArray(collection) ? arrayEachRight : baseEachRight; return func(collection, getIteratee(iteratee, 3)); } /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The order of grouped values * is determined by the order they occur incollection. The corresponding * value of each key is an array of elements responsible for generating the * key. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * _.groupBy([6.1, 4.2, 6.3], Math.floor); * // =&gt; { &#39;4&#39;: [4.2], &#39;6&#39;: [6.1, 6.3] } * * // The_.propertyiteratee shorthand. * _.groupBy([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], &#39;length&#39;); * // =&gt; { &#39;3&#39;: [&#39;one&#39;, &#39;two&#39;], &#39;5&#39;: [&#39;three&#39;] } */ var groupBy = createAggregator(function(result, value, key) { if (hasOwnProperty.call(result, key)) { result[key].push(value); } else { baseAssignValue(result, key, [value]); } }); /** * Checks ifvalueis incollection. Ifcollectionis a string, it&#39;s * checked for a substring ofvalue, otherwise * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * is used for equality comparisons. IffromIndexis negative, it&#39;s used as * the offset from the end ofcollection. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object|string} collection The collection to inspect. * @param {*} value The value to search for. * @param {number} [fromIndex=0] The index to search from. * @param- {Object} [guard] Enables use as an iteratee for methods like_.reduce. * @returns {boolean} Returnstrueifvalueis found, elsefalse. * @example * * _.includes([1, 2, 3], 1); * // =&gt; true * * _.includes([1, 2, 3], 1, 2); * // =&gt; false * * _.includes({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, 1); * // =&gt; true * * _.includes(&#39;abcd&#39;, &#39;bc&#39;); * // =&gt; true */ function includes(collection, value, fromIndex, guard) { collection = isArrayLike(collection) ? collection : values(collection); fromIndex = (fromIndex &amp;&amp; !guard) ? toInteger(fromIndex) : 0; var length = collection.length; if (fromIndex &lt; 0) { fromIndex = nativeMax(length + fromIndex, 0); } return isString(collection) ? (fromIndex &lt;= length &amp;&amp; collection.indexOf(value, fromIndex) &gt; -1) : (!!length &amp;&amp; baseIndexOf(collection, value, fromIndex) &gt; -1); } /** * Invokes the method atpathof each element incollection, returning * an array of the results of each invoked method. Any additional arguments * are provided to each invoked method. Ifpathis a function, it&#39;s invoked * for, andthisbound to, each element incollection. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Array|Function|string} path The path of the method to invoke or * the function invoked per iteration. * @param {...*} [args] The arguments to invoke each method with. * @returns {Array} Returns the array of results. * @example * * _.invokeMap([[5, 1, 7], [3, 2, 1]], &#39;sort&#39;); * // =&gt; [[1, 5, 7], [1, 2, 3]] * * _.invokeMap([123, 456], String.prototype.split, &#39;&#39;); * // =&gt; [[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [&#39;4&#39;, &#39;5&#39;, &#39;6&#39;]] */ var invokeMap = baseRest(function(collection, path, args) { var index = -1, isFunc = typeof path == &#39;function&#39;, result = isArrayLike(collection) ? Array(collection.length) : []; baseEach(collection, function(value) { result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args); }); return result; }); /** * Creates an object composed of keys generated from the results of running * each element ofcollectionthruiteratee. The corresponding value of * each key is the last element responsible for generating the key. The * iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The iteratee to transform keys. * @returns {Object} Returns the composed aggregate object. * @example * * var array = [ * { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, * { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } * ]; * * _.keyBy(array, function(o) { * return String.fromCharCode(o.code); * }); * // =&gt; { &#39;a&#39;: { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, &#39;d&#39;: { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } } * * _.keyBy(array, &#39;dir&#39;); * // =&gt; { &#39;left&#39;: { &#39;dir&#39;: &#39;left&#39;, &#39;code&#39;: 97 }, &#39;right&#39;: { &#39;dir&#39;: &#39;right&#39;, &#39;code&#39;: 100 } } */ var keyBy = createAggregator(function(result, value, key) { baseAssignValue(result, key, value); }); /** * Creates an array of values by running each element incollectionthru *iteratee. The iteratee is invoked with three arguments: * (value, index|key, collection). * * Many lodash methods are guarded to work as iteratees for methods like *.every,.filter,.map,.mapValues,.reject, and.some. * * The guarded methods are: *ary,chunk,curry,curryRight,drop,dropRight,every, *fill,invert,parseInt,random,range,rangeRight,repeat, *sampleSize,slice,some,sortBy,split,take,takeRight, *template,trim,trimEnd,trimStart, andwords* * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the new mapped array. * @example * * function square(n) { * return n * n; * } * * _.map([4, 8], square); * // =&gt; [16, 64] * * _.map({ &#39;a&#39;: 4, &#39;b&#39;: 8 }, square); * // =&gt; [16, 64] (iteration order is not guaranteed) * * var users = [ * { &#39;user&#39;: &#39;barney&#39; }, * { &#39;user&#39;: &#39;fred&#39; } * ]; * * // The_.propertyiteratee shorthand. * _.map(users, &#39;user&#39;); * // =&gt; [&#39;barney&#39;, &#39;fred&#39;] */ function map(collection, iteratee) { var func = isArray(collection) ? arrayMap : baseMap; return func(collection, getIteratee(iteratee, 3)); } /** * This method is like_.sortByexcept that it allows specifying the sort * orders of the iteratees to sort by. Ifordersis unspecified, all values * are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for * descending or &quot;asc&quot; for ascending sort order of corresponding values. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]] * The iteratees to sort by. * @param {string[]} [orders] The sort orders ofiteratees. * @param- {Object} [guard] Enables use as an iteratee for methods like_.reduce. * @returns {Array} Returns the new sorted array. * @example * * var users = [ * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 48 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 34 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 } * ]; * * // Sort byuserin ascending order and byagein descending order. * _.orderBy(users, [&#39;user&#39;, &#39;age&#39;], [&#39;asc&#39;, &#39;desc&#39;]); * // =&gt; objects for [[&#39;barney&#39;, 36], [&#39;barney&#39;, 34], [&#39;fred&#39;, 48], [&#39;fred&#39;, 40]] */ function orderBy(collection, iteratees, orders, guard) { if (collection == null) { return []; } if (!isArray(iteratees)) { iteratees = iteratees == null ? [] : [iteratees]; } orders = guard ? undefined : orders; if (!isArray(orders)) { orders = orders == null ? [] : [orders]; } return baseOrderBy(collection, iteratees, orders); } /** * Creates an array of elements split into two groups, the first of which * contains elementspredicatereturns truthy for, the second of which * contains elementspredicatereturns falsey for. The predicate is * invoked with one argument: (value). * * @static * @memberOf _ * @since 3.0.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of grouped elements. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1, &#39;active&#39;: false } * ]; * * _.partition(users, function(o) { return o.active; }); * // =&gt; objects for [[&#39;fred&#39;], [&#39;barney&#39;, &#39;pebbles&#39;]] * * // The_.matchesiteratee shorthand. * _.partition(users, { &#39;age&#39;: 1, &#39;active&#39;: false }); * // =&gt; objects for [[&#39;pebbles&#39;], [&#39;barney&#39;, &#39;fred&#39;]] * * // The_.matchesPropertyiteratee shorthand. * _.partition(users, [&#39;active&#39;, false]); * // =&gt; objects for [[&#39;barney&#39;, &#39;pebbles&#39;], [&#39;fred&#39;]] * * // The_.propertyiteratee shorthand. * _.partition(users, &#39;active&#39;); * // =&gt; objects for [[&#39;fred&#39;], [&#39;barney&#39;, &#39;pebbles&#39;]] */ var partition = createAggregator(function(result, value, key) { result[key ? 0 : 1].push(value); }, function() { return [[], []]; }); /** * Reducescollectionto a value which is the accumulated result of running * each element incollectionthruiteratee, where each successive * invocation is supplied the return value of the previous. Ifaccumulator* is not given, the first element ofcollectionis used as the initial * value. The iteratee is invoked with four arguments: * (accumulator, value, index|key, collection). * * Many lodash methods are guarded to work as iteratees for methods like *.reduce,.reduceRight, and_.transform. * * The guarded methods are: *assign,defaults,defaultsDeep,includes,merge,orderBy, * andsortBy* * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The initial value. * @returns {*} Returns the accumulated value. * @see _.reduceRight * @example * * _.reduce([1, 2], function(sum, n) { * return sum + n; * }, 0); * // =&gt; 3 * * _.reduce({ &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }, function(result, value, key) { * (result[value] || (result[value] = [])).push(key); * return result; * }, {}); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } (iteration order is not guaranteed) */ function reduce(collection, iteratee, accumulator) { var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length &lt; 3; return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach); } /** * This method is like_.reduceexcept that it iterates over elements of *collectionfrom right to left. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The initial value. * @returns {*} Returns the accumulated value. * @see _.reduce * @example * * var array = [[0, 1], [2, 3], [4, 5]]; * * _.reduceRight(array, function(flattened, other) { * return flattened.concat(other); * }, []); * // =&gt; [4, 5, 2, 3, 0, 1] */ function reduceRight(collection, iteratee, accumulator) { var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length &lt; 3; return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight); } /** * The opposite of_.filter; this method returns the elements ofcollection* thatpredicatedoes **not** return truthy for. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {Array} Returns the new filtered array. * @see _.filter * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: false }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: true } * ]; * * _.reject(users, function(o) { return !o.active; }); * // =&gt; objects for [&#39;fred&#39;] * * // The_.matchesiteratee shorthand. * _.reject(users, { &#39;age&#39;: 40, &#39;active&#39;: true }); * // =&gt; objects for [&#39;barney&#39;] * * // The_.matchesPropertyiteratee shorthand. * _.reject(users, [&#39;active&#39;, false]); * // =&gt; objects for [&#39;fred&#39;] * * // The_.propertyiteratee shorthand. * _.reject(users, &#39;active&#39;); * // =&gt; objects for [&#39;barney&#39;] */ function reject(collection, predicate) { var func = isArray(collection) ? arrayFilter : baseFilter; return func(collection, negate(getIteratee(predicate, 3))); } /** * Gets a random element fromcollection. * * @static * @memberOf _ * @since 2.0.0 * @category Collection * @param {Array|Object} collection The collection to sample. * @returns {*} Returns the random element. * @example * * _.sample([1, 2, 3, 4]); * // =&gt; 2 */ function sample(collection) { var func = isArray(collection) ? arraySample : baseSample; return func(collection); } /** * Getsnrandom elements at unique keys fromcollectionup to the * size ofcollection. * * @static * @memberOf _ * @since 4.0.0 * @category Collection * @param {Array|Object} collection The collection to sample. * @param {number} [n=1] The number of elements to sample. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the random elements. * @example * * _.sampleSize([1, 2, 3], 2); * // =&gt; [3, 1] * * _.sampleSize([1, 2, 3], 4); * // =&gt; [2, 3, 1] */ function sampleSize(collection, n, guard) { if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } var func = isArray(collection) ? arraySampleSize : baseSampleSize; return func(collection, n); } /** * Creates an array of shuffled values, using a version of the * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to shuffle. * @returns {Array} Returns the new shuffled array. * @example * * _.shuffle([1, 2, 3, 4]); * // =&gt; [4, 1, 3, 2] */ function shuffle(collection) { var func = isArray(collection) ? arrayShuffle : baseShuffle; return func(collection); } /** * Gets the size ofcollectionby returning its length for array-like * values or the number of own enumerable string keyed properties for objects. * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object|string} collection The collection to inspect. * @returns {number} Returns the collection size. * @example * * _.size([1, 2, 3]); * // =&gt; 3 * * _.size({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; 2 * * _.size(&#39;pebbles&#39;); * // =&gt; 7 */ function size(collection) { if (collection == null) { return 0; } if (isArrayLike(collection)) { return isString(collection) ? stringSize(collection) : collection.length; } var tag = getTag(collection); if (tag == mapTag || tag == setTag) { return collection.size; } return baseKeys(collection).length; } /** * Checks ifpredicatereturns truthy for **any** element ofcollection. * Iteration is stopped oncepredicatereturns truthy. The predicate is * invoked with three arguments: (value, index|key, collection). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {boolean} Returnstrueif any element passes the predicate check, * elsefalse. * @example * * _.some([null, 0, &#39;yes&#39;, false], Boolean); * // =&gt; true * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.some(users, { &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: false }); * // =&gt; false * * // The_.matchesPropertyiteratee shorthand. * _.some(users, [&#39;active&#39;, false]); * // =&gt; true * * // The_.propertyiteratee shorthand. * _.some(users, &#39;active&#39;); * // =&gt; true */ function some(collection, predicate, guard) { var func = isArray(collection) ? arraySome : baseSome; if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) { predicate = undefined; } return func(collection, getIteratee(predicate, 3)); } /** * Creates an array of elements, sorted in ascending order by the results of * running each element in a collection thru each iteratee. This method * performs a stable sort, that is, it preserves the original sort order of * equal elements. The iteratees are invoked with one argument: (value). * * @static * @memberOf _ * @since 0.1.0 * @category Collection * @param {Array|Object} collection The collection to iterate over. * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to sort by. * @returns {Array} Returns the new sorted array. * @example * * var users = [ * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 48 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36 }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 34 } * ]; * * _.sortBy(users, [function(o) { return o.user; }]); * // =&gt; objects for [[&#39;barney&#39;, 36], [&#39;barney&#39;, 34], [&#39;fred&#39;, 48], [&#39;fred&#39;, 40]] * * _.sortBy(users, [&#39;user&#39;, &#39;age&#39;]); * // =&gt; objects for [[&#39;barney&#39;, 34], [&#39;barney&#39;, 36], [&#39;fred&#39;, 40], [&#39;fred&#39;, 48]] */ var sortBy = baseRest(function(collection, iteratees) { if (collection == null) { return []; } var length = iteratees.length; if (length &gt; 1 &amp;&amp; isIterateeCall(collection, iteratees[0], iteratees[1])) { iteratees = []; } else if (length &gt; 2 &amp;&amp; isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) { iteratees = [iteratees[0]]; } return baseOrderBy(collection, baseFlatten(iteratees, 1), []); }); /*------------------------------------------------------------------------*/ /** * Gets the timestamp of the number of milliseconds that have elapsed since * the Unix epoch (1 January 1970 00:00:00 UTC). * * @static * @memberOf _ * @since 2.4.0 * @category Date * @returns {number} Returns the timestamp. * @example * * _.defer(function(stamp) { * console.log(_.now() - stamp); * }, _.now()); * // =&gt; Logs the number of milliseconds it took for the deferred invocation. */ var now = ctxNow || function() { return root.Date.now(); }; /*------------------------------------------------------------------------*/ /** * The opposite of_.before; this method creates a function that invokes *funconce it&#39;s callednor more times. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {number} n The number of calls beforefuncis invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * var saves = [&#39;profile&#39;, &#39;settings&#39;]; * * var done = _.after(saves.length, function() { * console.log(&#39;done saving!&#39;); * }); * * _.forEach(saves, function(type) { * asyncSave({ &#39;type&#39;: type, &#39;complete&#39;: done }); * }); * // =&gt; Logs &#39;done saving!&#39; after the two async saves have completed. */ function after(n, func) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } n = toInteger(n); return function() { if (--n &lt; 1) { return func.apply(this, arguments); } }; } /** * Creates a function that invokesfunc, with up tonarguments, * ignoring any additional arguments. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to cap arguments for. * @param {number} [n=func.length] The arity cap. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new capped function. * @example * * _.map([&#39;6&#39;, &#39;8&#39;, &#39;10&#39;], _.ary(parseInt, 1)); * // =&gt; [6, 8, 10] */ function ary(func, n, guard) { n = guard ? undefined : n; n = (func &amp;&amp; n == null) ? func.length : n; return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n); } /** * Creates a function that invokesfunc, with thethisbinding and arguments * of the created function, while it&#39;s called less thanntimes. Subsequent * calls to the created function return the result of the lastfuncinvocation. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {number} n The number of calls at whichfuncis no longer invoked. * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * jQuery(element).on(&#39;click&#39;, _.before(5, addContactToList)); * // =&gt; Allows adding up to 4 contacts to the list. */ function before(n, func) { var result; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } n = toInteger(n); return function() { if (--n &gt; 0) { result = func.apply(this, arguments); } if (n &lt;= 1) { func = undefined; } return result; }; } /** * Creates a function that invokesfuncwith thethisbinding ofthisArg* andpartialsprepended to the arguments it receives. * * The.bind.placeholdervalue, which defaults toin monolithic builds, * may be used as a placeholder for partially applied arguments. * * **Note:** Unlike nativeFunction#bind, this method doesn&#39;t set the &quot;length&quot; * property of bound functions. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to bind. * @param {*} thisArg Thethisbinding offunc. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new bound function. * @example * * function greet(greeting, punctuation) { * return greeting + &#39; &#39; + this.user + punctuation; * } * * var object = { &#39;user&#39;: &#39;fred&#39; }; * * var bound = _.bind(greet, object, &#39;hi&#39;); * bound(&#39;!&#39;); * // =&gt; &#39;hi fred!&#39; * * // Bound with placeholders. * var bound = _.bind(greet, object, _, &#39;!&#39;); * bound(&#39;hi&#39;); * // =&gt; &#39;hi fred!&#39; */ var bind = baseRest(function(func, thisArg, partials) { var bitmask = WRAP_BIND_FLAG; if (partials.length) { var holders = replaceHolders(partials, getHolder(bind)); bitmask |= WRAP_PARTIAL_FLAG; } return createWrap(func, bitmask, thisArg, partials, holders); }); /** * Creates a function that invokes the method atobject[key]withpartials* prepended to the arguments it receives. * * This method differs from.bindby allowing bound functions to reference * methods that may be redefined or don&#39;t yet exist. See * [Peter Michaux&#39;s article](http://peter.michaux.ca/articles/lazy-function-definition-pattern) * for more details. * * The.bindKey.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * @static * @memberOf _ * @since 0.10.0 * @category Function * @param {Object} object The object to invoke the method on. * @param {string} key The key of the method. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new bound function. * @example * * var object = { * &#39;user&#39;: &#39;fred&#39;, * &#39;greet&#39;: function(greeting, punctuation) { * return greeting + &#39; &#39; + this.user + punctuation; * } * }; * * var bound = _.bindKey(object, &#39;greet&#39;, &#39;hi&#39;); * bound(&#39;!&#39;); * // =&gt; &#39;hi fred!&#39; * * object.greet = function(greeting, punctuation) { * return greeting + &#39;ya &#39; + this.user + punctuation; * }; * * bound(&#39;!&#39;); * // =&gt; &#39;hiya fred!&#39; * * // Bound with placeholders. * var bound = _.bindKey(object, &#39;greet&#39;, _, &#39;!&#39;); * bound(&#39;hi&#39;); * // =&gt; &#39;hiya fred!&#39; */ var bindKey = baseRest(function(object, key, partials) { var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG; if (partials.length) { var holders = replaceHolders(partials, getHolder(bindKey)); bitmask |= WRAP_PARTIAL_FLAG; } return createWrap(key, bitmask, object, partials, holders); }); /** * Creates a function that accepts arguments offuncand either invokes *funcreturning its result, if at leastaritynumber of arguments have * been provided, or returns a function that accepts the remainingfunc* arguments, and so on. The arity offuncmay be specified iffunc.length* is not sufficient. * * The.curry.placeholdervalue, which defaults toin monolithic builds, * may be used as a placeholder for provided arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of curried functions. * * @static * @memberOf _ * @since 2.0.0 * @category Function * @param {Function} func The function to curry. * @param {number} [arity=func.length] The arity offunc. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new curried function. * @example * * var abc = function(a, b, c) { * return [a, b, c]; * }; * * var curried = _.curry(abc); * * curried(1)(2)(3); * // =&gt; [1, 2, 3] * * curried(1, 2)(3); * // =&gt; [1, 2, 3] * * curried(1, 2, 3); * // =&gt; [1, 2, 3] * * // Curried with placeholders. * curried(1)(_, 3)(2); * // =&gt; [1, 2, 3] */ function curry(func, arity, guard) { arity = guard ? undefined : arity; var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity); result.placeholder = curry.placeholder; return result; } /** * This method is like.curryexcept that arguments are applied tofunc* in the manner of.partialRightinstead of.partial. * * The.curryRight.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for provided arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of curried functions. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to curry. * @param {number} [arity=func.length] The arity offunc. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the new curried function. * @example * * var abc = function(a, b, c) { * return [a, b, c]; * }; * * var curried = _.curryRight(abc); * * curried(3)(2)(1); * // =&gt; [1, 2, 3] * * curried(2, 3)(1); * // =&gt; [1, 2, 3] * * curried(1, 2, 3); * // =&gt; [1, 2, 3] * * // Curried with placeholders. * curried(3)(1, _)(2); * // =&gt; [1, 2, 3] */ function curryRight(func, arity, guard) { arity = guard ? undefined : arity; var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity); result.placeholder = curryRight.placeholder; return result; } /** * Creates a debounced function that delays invokingfuncuntil afterwait* milliseconds have elapsed since the last time the debounced function was * invoked. The debounced function comes with acancelmethod to cancel * delayedfuncinvocations and aflushmethod to immediately invoke them. * Provideoptionsto indicate whetherfuncshould be invoked on the * leading and/or trailing edge of thewaittimeout. Thefuncis invoked * with the last arguments provided to the debounced function. Subsequent * calls to the debounced function return the result of the lastfunc* invocation. * * **Note:** Ifleadingandtrailingoptions aretrue,funcis * invoked on the trailing edge of the timeout only if the debounced function * is invoked more than once during thewaittimeout. * * Ifwaitis0andleadingisfalse,funcinvocation is deferred * until to the next tick, similar tosetTimeoutwith a timeout of0. * * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between.debounceand.throttle. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to debounce. * @param {number} [wait=0] The number of milliseconds to delay. * @param {Object} [options={}] The options object. * @param {boolean} [options.leading=false] * Specify invoking on the leading edge of the timeout. * @param {number} [options.maxWait] * The maximum timefuncis allowed to be delayed before it&#39;s invoked. * @param {boolean} [options.trailing=true] * Specify invoking on the trailing edge of the timeout. * @returns {Function} Returns the new debounced function. * @example * * // Avoid costly calculations while the window size is in flux. * jQuery(window).on(&#39;resize&#39;, _.debounce(calculateLayout, 150)); * * // InvokesendMailwhen clicked, debouncing subsequent calls. * jQuery(element).on(&#39;click&#39;, _.debounce(sendMail, 300, { * &#39;leading&#39;: true, * &#39;trailing&#39;: false * })); * * // EnsurebatchLogis invoked once after 1 second of debounced calls. * var debounced = _.debounce(batchLog, 250, { &#39;maxWait&#39;: 1000 }); * var source = new EventSource(&#39;/stream&#39;); * jQuery(source).on(&#39;message&#39;, debounced); * * // Cancel the trailing debounced invocation. * jQuery(window).on(&#39;popstate&#39;, debounced.cancel); */ function debounce(func, wait, options) { var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } wait = toNumber(wait) || 0; if (isObject(options)) { leading = !!options.leading; maxing = &#39;maxWait&#39; in options; maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait; trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing; } function invokeFunc(time) { var args = lastArgs, thisArg = lastThis; lastArgs = lastThis = undefined; lastInvokeTime = time; result = func.apply(thisArg, args); return result; } function leadingEdge(time) { // Reset anymaxWaittimer. lastInvokeTime = time; // Start the timer for the trailing edge. timerId = setTimeout(timerExpired, wait); // Invoke the leading edge. return leading ? invokeFunc(time) : result; } function remainingWait(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall; return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting; } function shouldInvoke(time) { var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we&#39;re at the // trailing edge, the system time has gone backwards and we&#39;re treating // it as the trailing edge, or we&#39;ve hit themaxWaitlimit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)); } function timerExpired() { var time = now(); if (shouldInvoke(time)) { return trailingEdge(time); } // Restart the timer. timerId = setTimeout(timerExpired, remainingWait(time)); } function trailingEdge(time) { timerId = undefined; // Only invoke if we havelastArgswhich meansfunchas been // debounced at least once. if (trailing &amp;&amp; lastArgs) { return invokeFunc(time); } lastArgs = lastThis = undefined; return result; } function cancel() { if (timerId !== undefined) { clearTimeout(timerId); } lastInvokeTime = 0; lastArgs = lastCallTime = lastThis = timerId = undefined; } function flush() { return timerId === undefined ? result : trailingEdge(now()); } function debounced() { var time = now(), isInvoking = shouldInvoke(time); lastArgs = arguments; lastThis = this; lastCallTime = time; if (isInvoking) { if (timerId === undefined) { return leadingEdge(lastCallTime); } if (maxing) { // Handle invocations in a tight loop. timerId = setTimeout(timerExpired, wait); return invokeFunc(lastCallTime); } } if (timerId === undefined) { timerId = setTimeout(timerExpired, wait); } return result; } debounced.cancel = cancel; debounced.flush = flush; return debounced; } /** * Defers invoking thefuncuntil the current call stack has cleared. Any * additional arguments are provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to defer. * @param {...*} [args] The arguments to invokefuncwith. * @returns {number} Returns the timer id. * @example * * _.defer(function(text) { * console.log(text); * }, &#39;deferred&#39;); * // =&gt; Logs &#39;deferred&#39; after one millisecond. */ var defer = baseRest(function(func, args) { return baseDelay(func, 1, args); }); /** * Invokesfuncafterwaitmilliseconds. Any additional arguments are * provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to delay. * @param {number} wait The number of milliseconds to delay invocation. * @param {...*} [args] The arguments to invokefuncwith. * @returns {number} Returns the timer id. * @example * * _.delay(function(text) { * console.log(text); * }, 1000, &#39;later&#39;); * // =&gt; Logs &#39;later&#39; after one second. */ var delay = baseRest(function(func, wait, args) { return baseDelay(func, toNumber(wait) || 0, args); }); /** * Creates a function that invokesfuncwith arguments reversed. * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to flip arguments for. * @returns {Function} Returns the new flipped function. * @example * * var flipped = _.flip(function() { * return _.toArray(arguments); * }); * * flipped(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; [&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;] */ function flip(func) { return createWrap(func, WRAP_FLIP_FLAG); } /** * Creates a function that memoizes the result offunc. Ifresolveris * provided, it determines the cache key for storing the result based on the * arguments provided to the memoized function. By default, the first argument * provided to the memoized function is used as the map cache key. Thefunc* is invoked with thethisbinding of the memoized function. * * **Note:** The cache is exposed as thecacheproperty on the memoized * function. Its creation may be customized by replacing the_.memoize.Cache* constructor with one whose instances implement the * [Map](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object) * method interface ofclear,delete,get,has, andset. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to have its output memoized. * @param {Function} [resolver] The function to resolve the cache key. * @returns {Function} Returns the new memoized function. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * var other = { &#39;c&#39;: 3, &#39;d&#39;: 4 }; * * var values = _.memoize(_.values); * values(object); * // =&gt; [1, 2] * * values(other); * // =&gt; [3, 4] * * object.a = 2; * values(object); * // =&gt; [1, 2] * * // Modify the result cache. * values.cache.set(object, [&#39;a&#39;, &#39;b&#39;]); * values(object); * // =&gt; [&#39;a&#39;, &#39;b&#39;] * * // Replace_.memoize.Cache. * _.memoize.Cache = WeakMap; */ function memoize(func, resolver) { if (typeof func != &#39;function&#39; || (resolver != null &amp;&amp; typeof resolver != &#39;function&#39;)) { throw new TypeError(FUNC_ERROR_TEXT); } var memoized = function() { var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache; if (cache.has(key)) { return cache.get(key); } var result = func.apply(this, args); memoized.cache = cache.set(key, result) || cache; return result; }; memoized.cache = new (memoize.Cache || MapCache); return memoized; } // ExposeMapCache. memoize.Cache = MapCache; /** * Creates a function that negates the result of the predicatefunc. The *funcpredicate is invoked with thethisbinding and arguments of the * created function. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} predicate The predicate to negate. * @returns {Function} Returns the new negated function. * @example * * function isEven(n) { * return n % 2 == 0; * } * * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven)); * // =&gt; [1, 3, 5] */ function negate(predicate) { if (typeof predicate != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } return function() { var args = arguments; switch (args.length) { case 0: return !predicate.call(this); case 1: return !predicate.call(this, args[0]); case 2: return !predicate.call(this, args[0], args[1]); case 3: return !predicate.call(this, args[0], args[1], args[2]); } return !predicate.apply(this, args); }; } /** * Creates a function that is restricted to invokingfunconce. Repeat calls * to the function return the value of the first invocation. Thefuncis * invoked with thethisbinding and arguments of the created function. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to restrict. * @returns {Function} Returns the new restricted function. * @example * * var initialize = _.once(createApplication); * initialize(); * initialize(); * // =&gt;createApplicationis invoked once */ function once(func) { return before(2, func); } /** * Creates a function that invokesfuncwith its arguments transformed. * * @static * @since 4.0.0 * @memberOf _ * @category Function * @param {Function} func The function to wrap. * @param {...(Function|Function[])} [transforms=[_.identity]] * The argument transforms. * @returns {Function} Returns the new function. * @example * * function doubled(n) { * return n * 2; * } * * function square(n) { * return n * n; * } * * var func = _.overArgs(function(x, y) { * return [x, y]; * }, [square, doubled]); * * func(9, 3); * // =&gt; [81, 6] * * func(10, 5); * // =&gt; [100, 10] */ var overArgs = castRest(function(func, transforms) { transforms = (transforms.length == 1 &amp;&amp; isArray(transforms[0])) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee())); var funcsLength = transforms.length; return baseRest(function(args) { var index = -1, length = nativeMin(args.length, funcsLength); while (++index &lt; length) { args[index] = transforms[index].call(this, args[index]); } return apply(func, this, args); }); }); /** * Creates a function that invokesfuncwithpartialsprepended to the * arguments it receives. This method is like.bindexcept it does **not** * alter thethisbinding. * * The.partial.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of partially * applied functions. * * @static * @memberOf _ * @since 0.2.0 * @category Function * @param {Function} func The function to partially apply arguments to. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new partially applied function. * @example * * function greet(greeting, name) { * return greeting + &#39; &#39; + name; * } * * var sayHelloTo = _.partial(greet, &#39;hello&#39;); * sayHelloTo(&#39;fred&#39;); * // =&gt; &#39;hello fred&#39; * * // Partially applied with placeholders. * var greetFred = _.partial(greet, _, &#39;fred&#39;); * greetFred(&#39;hi&#39;); * // =&gt; &#39;hi fred&#39; */ var partial = baseRest(function(func, partials) { var holders = replaceHolders(partials, getHolder(partial)); return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders); }); /** * This method is like.partialexcept that partially applied arguments * are appended to the arguments it receives. * * The.partialRight.placeholdervalue, which defaults to_in monolithic * builds, may be used as a placeholder for partially applied arguments. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of partially * applied functions. * * @static * @memberOf _ * @since 1.0.0 * @category Function * @param {Function} func The function to partially apply arguments to. * @param {...*} [partials] The arguments to be partially applied. * @returns {Function} Returns the new partially applied function. * @example * * function greet(greeting, name) { * return greeting + &#39; &#39; + name; * } * * var greetFred = _.partialRight(greet, &#39;fred&#39;); * greetFred(&#39;hi&#39;); * // =&gt; &#39;hi fred&#39; * * // Partially applied with placeholders. * var sayHelloTo = _.partialRight(greet, &#39;hello&#39;, _); * sayHelloTo(&#39;fred&#39;); * // =&gt; &#39;hello fred&#39; */ var partialRight = baseRest(function(func, partials) { var holders = replaceHolders(partials, getHolder(partialRight)); return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders); }); /** * Creates a function that invokesfuncwith arguments arranged according * to the specifiedindexeswhere the argument value at the first index is * provided as the first argument, the argument value at the second index is * provided as the second argument, and so on. * * @static * @memberOf _ * @since 3.0.0 * @category Function * @param {Function} func The function to rearrange arguments for. * @param {...(number|number[])} indexes The arranged argument indexes. * @returns {Function} Returns the new function. * @example * * var rearged = _.rearg(function(a, b, c) { * return [a, b, c]; * }, [2, 0, 1]); * * rearged(&#39;b&#39;, &#39;c&#39;, &#39;a&#39;) * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] */ var rearg = flatRest(function(func, indexes) { return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes); }); /** * Creates a function that invokesfuncwith thethisbinding of the * created function and arguments fromstartand beyond provided as * an array. * * **Note:** This method is based on the * [rest parameter](https://mdn.io/rest_parameters). * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to apply a rest parameter to. * @param {number} [start=func.length-1] The start position of the rest parameter. * @returns {Function} Returns the new function. * @example * * var say = _.rest(function(what, names) { * return what + &#39; &#39; + _.initial(names).join(&#39;, &#39;) + * (_.size(names) &gt; 1 ? &#39;, &amp; &#39; : &#39;&#39;) + _.last(names); * }); * * say(&#39;hello&#39;, &#39;fred&#39;, &#39;barney&#39;, &#39;pebbles&#39;); * // =&gt; &#39;hello fred, barney, &amp; pebbles&#39; */ function rest(func, start) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } start = start === undefined ? start : toInteger(start); return baseRest(func, start); } /** * Creates a function that invokesfuncwith thethisbinding of the * create function and an array of arguments much like * [Function#apply](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply). * * **Note:** This method is based on the * [spread operator](https://mdn.io/spread_operator). * * @static * @memberOf _ * @since 3.2.0 * @category Function * @param {Function} func The function to spread arguments over. * @param {number} [start=0] The start position of the spread. * @returns {Function} Returns the new function. * @example * * var say = _.spread(function(who, what) { * return who + &#39; says &#39; + what; * }); * * say([&#39;fred&#39;, &#39;hello&#39;]); * // =&gt; &#39;fred says hello&#39; * * var numbers = Promise.all([ * Promise.resolve(40), * Promise.resolve(36) * ]); * * numbers.then(_.spread(function(x, y) { * return x + y; * })); * // =&gt; a Promise of 76 */ function spread(func, start) { if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } start = start == null ? 0 : nativeMax(toInteger(start), 0); return baseRest(function(args) { var array = args[start], otherArgs = castSlice(args, 0, start); if (array) { arrayPush(otherArgs, array); } return apply(func, this, otherArgs); }); } /** * Creates a throttled function that only invokesfuncat most once per * everywaitmilliseconds. The throttled function comes with acancel* method to cancel delayedfuncinvocations and aflushmethod to * immediately invoke them. Provideoptionsto indicate whetherfunc* should be invoked on the leading and/or trailing edge of thewait* timeout. Thefuncis invoked with the last arguments provided to the * throttled function. Subsequent calls to the throttled function return the * result of the lastfuncinvocation. * * **Note:** Ifleadingandtrailingoptions aretrue,funcis * invoked on the trailing edge of the timeout only if the throttled function * is invoked more than once during thewaittimeout. * * Ifwaitis0andleadingisfalse,funcinvocation is deferred * until to the next tick, similar tosetTimeoutwith a timeout of0. * * See [David Corbacho&#39;s article](https://css-tricks.com/debouncing-throttling-explained-examples/) * for details over the differences between.throttleand.debounce. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {Function} func The function to throttle. * @param {number} [wait=0] The number of milliseconds to throttle invocations to. * @param {Object} [options={}] The options object. * @param {boolean} [options.leading=true] * Specify invoking on the leading edge of the timeout. * @param {boolean} [options.trailing=true] * Specify invoking on the trailing edge of the timeout. * @returns {Function} Returns the new throttled function. * @example * * // Avoid excessively updating the position while scrolling. * jQuery(window).on(&#39;scroll&#39;, _.throttle(updatePosition, 100)); * * // InvokerenewTokenwhen the click event is fired, but not more than once every 5 minutes. * var throttled = _.throttle(renewToken, 300000, { &#39;trailing&#39;: false }); * jQuery(element).on(&#39;click&#39;, throttled); * * // Cancel the trailing throttled invocation. * jQuery(window).on(&#39;popstate&#39;, throttled.cancel); */ function throttle(func, wait, options) { var leading = true, trailing = true; if (typeof func != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } if (isObject(options)) { leading = &#39;leading&#39; in options ? !!options.leading : leading; trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing; } return debounce(func, wait, { &#39;leading&#39;: leading, &#39;maxWait&#39;: wait, &#39;trailing&#39;: trailing }); } /** * Creates a function that accepts up to one argument, ignoring any * additional arguments. * * @static * @memberOf _ * @since 4.0.0 * @category Function * @param {Function} func The function to cap arguments for. * @returns {Function} Returns the new capped function. * @example * * _.map([&#39;6&#39;, &#39;8&#39;, &#39;10&#39;], _.unary(parseInt)); * // =&gt; [6, 8, 10] */ function unary(func) { return ary(func, 1); } /** * Creates a function that providesvaluetowrapperas its first * argument. Any additional arguments provided to the function are appended * to those provided to thewrapper. The wrapper is invoked with thethis* binding of the created function. * * @static * @memberOf _ * @since 0.1.0 * @category Function * @param {*} value The value to wrap. * @param {Function} [wrapper=identity] The wrapper function. * @returns {Function} Returns the new function. * @example * * var p = _.wrap(_.escape, function(func, text) { * return &#39;&lt;p&gt;&#39; + func(text) + &#39;&lt;/p&gt;&#39;; * }); * * p(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; &#39;&lt;p&gt;fred, barney, &amp;amp; pebbles&lt;/p&gt;&#39; */ function wrap(value, wrapper) { return partial(castFunction(wrapper), value); } /*------------------------------------------------------------------------*/ /** * Castsvalueas an array if it&#39;s not one. * * @static * @memberOf _ * @since 4.4.0 * @category Lang * @param {*} value The value to inspect. * @returns {Array} Returns the cast array. * @example * * _.castArray(1); * // =&gt; [1] * * _.castArray({ &#39;a&#39;: 1 }); * // =&gt; [{ &#39;a&#39;: 1 }] * * _.castArray(&#39;abc&#39;); * // =&gt; [&#39;abc&#39;] * * _.castArray(null); * // =&gt; [null] * * _.castArray(undefined); * // =&gt; [undefined] * * _.castArray(); * // =&gt; [] * * var array = [1, 2, 3]; * console.log(_.castArray(array) === array); * // =&gt; true */ function castArray() { if (!arguments.length) { return []; } var value = arguments[0]; return isArray(value) ? value : [value]; } /** * Creates a shallow clone ofvalue. * * **Note:** This method is loosely based on the * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm) * and supports cloning arrays, array buffers, booleans, date objects, maps, * numbers,Objectobjects, regexes, sets, strings, symbols, and typed * arrays. The own enumerable properties ofargumentsobjects are cloned * as plain objects. An empty object is returned for uncloneable values such * as error objects, functions, DOM nodes, and WeakMaps. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to clone. * @returns {*} Returns the cloned value. * @see _.cloneDeep * @example * * var objects = [{ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }]; * * var shallow = _.clone(objects); * console.log(shallow[0] === objects[0]); * // =&gt; true */ function clone(value) { return baseClone(value, CLONE_SYMBOLS_FLAG); } /** * This method is like_.cloneexcept that it acceptscustomizerwhich * is invoked to produce the cloned value. Ifcustomizerreturnsundefined, * cloning is handled by the method instead. Thecustomizeris invoked with * up to four arguments; (value [, index|key, object, stack]). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the cloned value. * @see _.cloneDeepWith * @example * * function customizer(value) { * if (_.isElement(value)) { * return value.cloneNode(false); * } * } * * var el = _.cloneWith(document.body, customizer); * * console.log(el === document.body); * // =&gt; false * console.log(el.nodeName); * // =&gt; &#39;BODY&#39; * console.log(el.childNodes.length); * // =&gt; 0 */ function cloneWith(value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseClone(value, CLONE_SYMBOLS_FLAG, customizer); } /** * This method is like_.cloneexcept that it recursively clonesvalue. * * @static * @memberOf _ * @since 1.0.0 * @category Lang * @param {*} value The value to recursively clone. * @returns {*} Returns the deep cloned value. * @see _.clone * @example * * var objects = [{ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }]; * * var deep = _.cloneDeep(objects); * console.log(deep[0] === objects[0]); * // =&gt; false */ function cloneDeep(value) { return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG); } /** * This method is like_.cloneWithexcept that it recursively clonesvalue. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to recursively clone. * @param {Function} [customizer] The function to customize cloning. * @returns {*} Returns the deep cloned value. * @see _.cloneWith * @example * * function customizer(value) { * if (_.isElement(value)) { * return value.cloneNode(true); * } * } * * var el = _.cloneDeepWith(document.body, customizer); * * console.log(el === document.body); * // =&gt; false * console.log(el.nodeName); * // =&gt; &#39;BODY&#39; * console.log(el.childNodes.length); * // =&gt; 20 */ function cloneDeepWith(value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer); } /** * Checks ifobjectconforms tosourceby invoking the predicate * properties ofsourcewith the corresponding property values ofobject. * * **Note:** This method is equivalent to_.conformswhensourceis * partially applied. * * @static * @memberOf _ * @since 4.14.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property predicates to conform to. * @returns {boolean} Returnstrueifobjectconforms, elsefalse. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * * _.conformsTo(object, { &#39;b&#39;: function(n) { return n &gt; 1; } }); * // =&gt; true * * _.conformsTo(object, { &#39;b&#39;: function(n) { return n &gt; 2; } }); * // =&gt; false */ function conformsTo(object, source) { return source == null || baseConformsTo(object, source, keys(source)); } /** * Performs a * [SameValueZero](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero) * comparison between two values to determine if they are equivalent. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * var object = { &#39;a&#39;: 1 }; * var other = { &#39;a&#39;: 1 }; * * _.eq(object, object); * // =&gt; true * * _.eq(object, other); * // =&gt; false * * _.eq(&#39;a&#39;, &#39;a&#39;); * // =&gt; true * * _.eq(&#39;a&#39;, Object(&#39;a&#39;)); * // =&gt; false * * _.eq(NaN, NaN); * // =&gt; true */ function eq(value, other) { return value === other || (value !== value &amp;&amp; other !== other); } /** * Checks ifvalueis greater thanother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis greater thanother, * elsefalse. * @see _.lt * @example * * _.gt(3, 1); * // =&gt; true * * _.gt(3, 3); * // =&gt; false * * _.gt(1, 3); * // =&gt; false */ var gt = createRelationalOperation(baseGt); /** * Checks ifvalueis greater than or equal toother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis greater than or equal to *other, elsefalse. * @see _.lte * @example * * _.gte(3, 1); * // =&gt; true * * _.gte(3, 3); * // =&gt; true * * _.gte(1, 3); * // =&gt; false */ var gte = createRelationalOperation(function(value, other) { return value &gt;= other; }); /** * Checks ifvalueis likely anargumentsobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis anargumentsobject, * elsefalse. * @example * * _.isArguments(function() { return arguments; }()); * // =&gt; true * * _.isArguments([1, 2, 3]); * // =&gt; false */ var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) { return isObjectLike(value) &amp;&amp; hasOwnProperty.call(value, &#39;callee&#39;) &amp;&amp; !propertyIsEnumerable.call(value, &#39;callee&#39;); }; /** * Checks ifvalueis classified as anArrayobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array, elsefalse. * @example * * _.isArray([1, 2, 3]); * // =&gt; true * * _.isArray(document.body.children); * // =&gt; false * * _.isArray(&#39;abc&#39;); * // =&gt; false * * _.isArray(_.noop); * // =&gt; false */ var isArray = Array.isArray; /** * Checks ifvalueis classified as anArrayBufferobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array buffer, elsefalse. * @example * * _.isArrayBuffer(new ArrayBuffer(2)); * // =&gt; true * * _.isArrayBuffer(new Array(2)); * // =&gt; false */ var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer; /** * Checks ifvalueis array-like. A value is considered array-like if it&#39;s * not a function and has avalue.lengththat&#39;s an integer greater than or * equal to0and less than or equal toNumber.MAX_SAFE_INTEGER. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis array-like, elsefalse. * @example * * _.isArrayLike([1, 2, 3]); * // =&gt; true * * _.isArrayLike(document.body.children); * // =&gt; true * * _.isArrayLike(&#39;abc&#39;); * // =&gt; true * * _.isArrayLike(_.noop); * // =&gt; false */ function isArrayLike(value) { return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value); } /** * This method is like_.isArrayLikeexcept that it also checks ifvalue* is an object. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an array-like object, * elsefalse. * @example * * _.isArrayLikeObject([1, 2, 3]); * // =&gt; true * * _.isArrayLikeObject(document.body.children); * // =&gt; true * * _.isArrayLikeObject(&#39;abc&#39;); * // =&gt; false * * _.isArrayLikeObject(_.noop); * // =&gt; false */ function isArrayLikeObject(value) { return isObjectLike(value) &amp;&amp; isArrayLike(value); } /** * Checks ifvalueis classified as a boolean primitive or object. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a boolean, elsefalse. * @example * * _.isBoolean(false); * // =&gt; true * * _.isBoolean(null); * // =&gt; false */ function isBoolean(value) { return value === true || value === false || (isObjectLike(value) &amp;&amp; baseGetTag(value) == boolTag); } /** * Checks ifvalueis a buffer. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a buffer, elsefalse. * @example * * _.isBuffer(new Buffer(2)); * // =&gt; true * * _.isBuffer(new Uint8Array(2)); * // =&gt; false */ var isBuffer = nativeIsBuffer || stubFalse; /** * Checks ifvalueis classified as aDateobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a date object, elsefalse. * @example * * _.isDate(new Date); * // =&gt; true * * _.isDate(&#39;Mon April 23 2012&#39;); * // =&gt; false */ var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate; /** * Checks ifvalueis likely a DOM element. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a DOM element, elsefalse. * @example * * _.isElement(document.body); * // =&gt; true * * _.isElement(&#39;&lt;body&gt;&#39;); * // =&gt; false */ function isElement(value) { return isObjectLike(value) &amp;&amp; value.nodeType === 1 &amp;&amp; !isPlainObject(value); } /** * Checks ifvalueis an empty object, collection, map, or set. * * Objects are considered empty if they have no own enumerable string keyed * properties. * * Array-like values such asargumentsobjects, arrays, buffers, strings, or * jQuery-like collections are considered empty if they have alengthof0. * Similarly, maps and sets are considered empty if they have asizeof0. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis empty, elsefalse. * @example * * _.isEmpty(null); * // =&gt; true * * _.isEmpty(true); * // =&gt; true * * _.isEmpty(1); * // =&gt; true * * _.isEmpty([1, 2, 3]); * // =&gt; false * * _.isEmpty({ &#39;a&#39;: 1 }); * // =&gt; false */ function isEmpty(value) { if (value == null) { return true; } if (isArrayLike(value) &amp;&amp; (isArray(value) || typeof value == &#39;string&#39; || typeof value.splice == &#39;function&#39; || isBuffer(value) || isTypedArray(value) || isArguments(value))) { return !value.length; } var tag = getTag(value); if (tag == mapTag || tag == setTag) { return !value.size; } if (isPrototype(value)) { return !baseKeys(value).length; } for (var key in value) { if (hasOwnProperty.call(value, key)) { return false; } } return true; } /** * Performs a deep comparison between two values to determine if they are * equivalent. * * **Note:** This method supports comparing arrays, array buffers, booleans, * date objects, error objects, maps, numbers,Objectobjects, regexes, * sets, strings, symbols, and typed arrays.Objectobjects are compared * by their own, not inherited, enumerable properties. Functions and DOM * nodes are compared by strict equality, i.e.===. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * var object = { &#39;a&#39;: 1 }; * var other = { &#39;a&#39;: 1 }; * * _.isEqual(object, other); * // =&gt; true * * object === other; * // =&gt; false */ function isEqual(value, other) { return baseIsEqual(value, other); } /** * This method is like_.isEqualexcept that it acceptscustomizerwhich * is invoked to compare values. Ifcustomizerreturnsundefined, comparisons * are handled by the method instead. Thecustomizeris invoked with up to * six arguments: (objValue, othValue [, index|key, object, other, stack]). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @param {Function} [customizer] The function to customize comparisons. * @returns {boolean} Returnstrueif the values are equivalent, elsefalse. * @example * * function isGreeting(value) { * return /^h(?:i|ello)$/.test(value); * } * * function customizer(objValue, othValue) { * if (isGreeting(objValue) &amp;&amp; isGreeting(othValue)) { * return true; * } * } * * var array = [&#39;hello&#39;, &#39;goodbye&#39;]; * var other = [&#39;hi&#39;, &#39;goodbye&#39;]; * * _.isEqualWith(array, other, customizer); * // =&gt; true */ function isEqualWith(value, other, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; var result = customizer ? customizer(value, other) : undefined; return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result; } /** * Checks ifvalueis anError,EvalError,RangeError,ReferenceError, *SyntaxError,TypeError, orURIErrorobject. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an error object, elsefalse. * @example * * _.isError(new Error); * // =&gt; true * * _.isError(Error); * // =&gt; false */ function isError(value) { if (!isObjectLike(value)) { return false; } var tag = baseGetTag(value); return tag == errorTag || tag == domExcTag || (typeof value.message == &#39;string&#39; &amp;&amp; typeof value.name == &#39;string&#39; &amp;&amp; !isPlainObject(value)); } /** * Checks ifvalueis a finite primitive number. * * **Note:** This method is based on * [Number.isFinite](https://mdn.io/Number/isFinite). * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a finite number, elsefalse. * @example * * _.isFinite(3); * // =&gt; true * * _.isFinite(Number.MIN_VALUE); * // =&gt; true * * _.isFinite(Infinity); * // =&gt; false * * _.isFinite(&#39;3&#39;); * // =&gt; false */ function isFinite(value) { return typeof value == &#39;number&#39; &amp;&amp; nativeIsFinite(value); } /** * Checks ifvalueis classified as aFunctionobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a function, elsefalse. * @example * * _.isFunction(_); * // =&gt; true * * _.isFunction(/abc/); * // =&gt; false */ function isFunction(value) { if (!isObject(value)) { return false; } // The use ofObject#toStringavoids issues with thetypeofoperator // in Safari 9 which returns &#39;object&#39; for typed arrays and other constructors. var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag; } /** * Checks ifvalueis an integer. * * **Note:** This method is based on * [Number.isInteger](https://mdn.io/Number/isInteger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an integer, elsefalse. * @example * * _.isInteger(3); * // =&gt; true * * _.isInteger(Number.MIN_VALUE); * // =&gt; false * * _.isInteger(Infinity); * // =&gt; false * * _.isInteger(&#39;3&#39;); * // =&gt; false */ function isInteger(value) { return typeof value == &#39;number&#39; &amp;&amp; value == toInteger(value); } /** * Checks ifvalueis a valid array-like length. * * **Note:** This method is loosely based on * [ToLength](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a valid length, elsefalse. * @example * * _.isLength(3); * // =&gt; true * * _.isLength(Number.MIN_VALUE); * // =&gt; false * * _.isLength(Infinity); * // =&gt; false * * _.isLength(&#39;3&#39;); * // =&gt; false */ function isLength(value) { return typeof value == &#39;number&#39; &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER; } /** * Checks ifvalueis the * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types) * ofObject. (e.g. arrays, functions, objects, regexes,new Number(0), andnew String(‘’)) * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis an object, elsefalse. * @example * * _.isObject({}); * // =&gt; true * * _.isObject([1, 2, 3]); * // =&gt; true * * _.isObject(_.noop); * // =&gt; true * * _.isObject(null); * // =&gt; false */ function isObject(value) { var type = typeof value; return value != null &amp;&amp; (type == &#39;object&#39; || type == &#39;function&#39;); } /** * Checks ifvalueis object-like. A value is object-like if it&#39;s notnull* and has atypeofresult of &quot;object&quot;. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis object-like, elsefalse. * @example * * _.isObjectLike({}); * // =&gt; true * * _.isObjectLike([1, 2, 3]); * // =&gt; true * * _.isObjectLike(_.noop); * // =&gt; false * * _.isObjectLike(null); * // =&gt; false */ function isObjectLike(value) { return value != null &amp;&amp; typeof value == &#39;object&#39;; } /** * Checks ifvalueis classified as aMapobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a map, elsefalse. * @example * * _.isMap(new Map); * // =&gt; true * * _.isMap(new WeakMap); * // =&gt; false */ var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap; /** * Performs a partial deep comparison betweenobjectandsourceto * determine ifobjectcontains equivalent property values. * * **Note:** This method is equivalent to.matcheswhensourceis * partially applied. * * Partial comparisons will match empty array and empty objectsource* values against any array or object value, respectively. See.isEqual* for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property values to match. * @returns {boolean} Returnstrueifobjectis a match, elsefalse. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2 }; * * _.isMatch(object, { &#39;b&#39;: 2 }); * // =&gt; true * * _.isMatch(object, { &#39;b&#39;: 1 }); * // =&gt; false */ function isMatch(object, source) { return object === source || baseIsMatch(object, source, getMatchData(source)); } /** * This method is like_.isMatchexcept that it acceptscustomizerwhich * is invoked to compare values. Ifcustomizerreturnsundefined, comparisons * are handled by the method instead. Thecustomizeris invoked with five * arguments: (objValue, srcValue, index|key, object, source). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {Object} object The object to inspect. * @param {Object} source The object of property values to match. * @param {Function} [customizer] The function to customize comparisons. * @returns {boolean} Returnstrueifobjectis a match, elsefalse. * @example * * function isGreeting(value) { * return /^h(?:i|ello)$/.test(value); * } * * function customizer(objValue, srcValue) { * if (isGreeting(objValue) &amp;&amp; isGreeting(srcValue)) { * return true; * } * } * * var object = { &#39;greeting&#39;: &#39;hello&#39; }; * var source = { &#39;greeting&#39;: &#39;hi&#39; }; * * _.isMatchWith(object, source, customizer); * // =&gt; true */ function isMatchWith(object, source, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return baseIsMatch(object, source, getMatchData(source), customizer); } /** * Checks ifvalueisNaN. * * **Note:** This method is based on * [Number.isNaN](https://mdn.io/Number/isNaN) and is not the same as * global [isNaN](https://mdn.io/isNaN) which returnstruefor *undefinedand other non-number values. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} ReturnstrueifvalueisNaN, elsefalse. * @example * * _.isNaN(NaN); * // =&gt; true * * _.isNaN(new Number(NaN)); * // =&gt; true * * isNaN(undefined); * // =&gt; true * * _.isNaN(undefined); * // =&gt; false */ function isNaN(value) { // AnNaNprimitive is the only value that is not equal to itself. // Perform thetoStringTagcheck first to avoid errors with some // ActiveX objects in IE. return isNumber(value) &amp;&amp; value != +value; } /** * Checks ifvalueis a pristine native function. * * **Note:** This method can&#39;t reliably detect native functions in the presence * of the core-js package because core-js circumvents this kind of detection. * Despite multiple requests, the core-js maintainer has made it clear: any * attempt to fix the detection will be obstructed. As a result, we&#39;re left * with little choice but to throw an error. Unfortunately, this also affects * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill), * which rely on core-js. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a native function, * elsefalse. * @example * * _.isNative(Array.prototype.push); * // =&gt; true * * _.isNative(_); * // =&gt; false */ function isNative(value) { if (isMaskable(value)) { throw new Error(CORE_ERROR_TEXT); } return baseIsNative(value); } /** * Checks ifvalueisnull. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueisnull, elsefalse. * @example * * _.isNull(null); * // =&gt; true * * _.isNull(void 0); * // =&gt; false */ function isNull(value) { return value === null; } /** * Checks ifvalueisnullorundefined. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis nullish, elsefalse. * @example * * _.isNil(null); * // =&gt; true * * _.isNil(void 0); * // =&gt; true * * _.isNil(NaN); * // =&gt; false */ function isNil(value) { return value == null; } /** * Checks ifvalueis classified as aNumberprimitive or object. * * **Note:** To excludeInfinity,-Infinity, andNaN, which are * classified as numbers, use the_.isFinitemethod. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a number, elsefalse. * @example * * _.isNumber(3); * // =&gt; true * * _.isNumber(Number.MIN_VALUE); * // =&gt; true * * _.isNumber(Infinity); * // =&gt; true * * _.isNumber(&#39;3&#39;); * // =&gt; false */ function isNumber(value) { return typeof value == &#39;number&#39; || (isObjectLike(value) &amp;&amp; baseGetTag(value) == numberTag); } /** * Checks ifvalueis a plain object, that is, an object created by the *Objectconstructor or one with a[[Prototype]]ofnull. * * @static * @memberOf _ * @since 0.8.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a plain object, elsefalse. * @example * * function Foo() { * this.a = 1; * } * * _.isPlainObject(new Foo); * // =&gt; false * * _.isPlainObject([1, 2, 3]); * // =&gt; false * * _.isPlainObject({ &#39;x&#39;: 0, &#39;y&#39;: 0 }); * // =&gt; true * * _.isPlainObject(Object.create(null)); * // =&gt; true */ function isPlainObject(value) { if (!isObjectLike(value) || baseGetTag(value) != objectTag) { return false; } var proto = getPrototype(value); if (proto === null) { return true; } var Ctor = hasOwnProperty.call(proto, &#39;constructor&#39;) &amp;&amp; proto.constructor; return typeof Ctor == &#39;function&#39; &amp;&amp; Ctor instanceof Ctor &amp;&amp; funcToString.call(Ctor) == objectCtorString; } /** * Checks ifvalueis classified as aRegExpobject. * * @static * @memberOf _ * @since 0.1.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a regexp, elsefalse. * @example * * _.isRegExp(/abc/); * // =&gt; true * * _.isRegExp(&#39;/abc/&#39;); * // =&gt; false */ var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp; /** * Checks ifvalueis a safe integer. An integer is safe if it&#39;s an IEEE-754 * double precision number which isn&#39;t the result of a rounded unsafe integer. * * **Note:** This method is based on * [Number.isSafeInteger](https://mdn.io/Number/isSafeInteger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a safe integer, elsefalse. * @example * * _.isSafeInteger(3); * // =&gt; true * * _.isSafeInteger(Number.MIN_VALUE); * // =&gt; false * * _.isSafeInteger(Infinity); * // =&gt; false * * _.isSafeInteger(&#39;3&#39;); * // =&gt; false */ function isSafeInteger(value) { return isInteger(value) &amp;&amp; value &gt;= -MAX_SAFE_INTEGER &amp;&amp; value &lt;= MAX_SAFE_INTEGER; } /** * Checks ifvalueis classified as aSetobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a set, elsefalse. * @example * * _.isSet(new Set); * // =&gt; true * * _.isSet(new WeakSet); * // =&gt; false */ var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet; /** * Checks ifvalueis classified as aStringprimitive or object. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a string, elsefalse. * @example * * _.isString(&#39;abc&#39;); * // =&gt; true * * _.isString(1); * // =&gt; false */ function isString(value) { return typeof value == &#39;string&#39; || (!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag); } /** * Checks ifvalueis classified as aSymbolprimitive or object. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a symbol, elsefalse. * @example * * _.isSymbol(Symbol.iterator); * // =&gt; true * * _.isSymbol(&#39;abc&#39;); * // =&gt; false */ function isSymbol(value) { return typeof value == &#39;symbol&#39; || (isObjectLike(value) &amp;&amp; baseGetTag(value) == symbolTag); } /** * Checks ifvalueis classified as a typed array. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a typed array, elsefalse. * @example * * _.isTypedArray(new Uint8Array); * // =&gt; true * * _.isTypedArray([]); * // =&gt; false */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray; /** * Checks ifvalueisundefined. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueisundefined, elsefalse. * @example * * _.isUndefined(void 0); * // =&gt; true * * _.isUndefined(null); * // =&gt; false */ function isUndefined(value) { return value === undefined; } /** * Checks ifvalueis classified as aWeakMapobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a weak map, elsefalse. * @example * * _.isWeakMap(new WeakMap); * // =&gt; true * * _.isWeakMap(new Map); * // =&gt; false */ function isWeakMap(value) { return isObjectLike(value) &amp;&amp; getTag(value) == weakMapTag; } /** * Checks ifvalueis classified as aWeakSetobject. * * @static * @memberOf _ * @since 4.3.0 * @category Lang * @param {*} value The value to check. * @returns {boolean} Returnstrueifvalueis a weak set, elsefalse. * @example * * _.isWeakSet(new WeakSet); * // =&gt; true * * _.isWeakSet(new Set); * // =&gt; false */ function isWeakSet(value) { return isObjectLike(value) &amp;&amp; baseGetTag(value) == weakSetTag; } /** * Checks ifvalueis less thanother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis less thanother, * elsefalse. * @see _.gt * @example * * _.lt(1, 3); * // =&gt; true * * _.lt(3, 3); * // =&gt; false * * _.lt(3, 1); * // =&gt; false */ var lt = createRelationalOperation(baseLt); /** * Checks ifvalueis less than or equal toother. * * @static * @memberOf _ * @since 3.9.0 * @category Lang * @param {*} value The value to compare. * @param {*} other The other value to compare. * @returns {boolean} Returnstrueifvalueis less than or equal to *other, elsefalse. * @see _.gte * @example * * _.lte(1, 3); * // =&gt; true * * _.lte(3, 3); * // =&gt; true * * _.lte(3, 1); * // =&gt; false */ var lte = createRelationalOperation(function(value, other) { return value &lt;= other; }); /** * Convertsvalueto an array. * * @static * @since 0.1.0 * @memberOf _ * @category Lang * @param {*} value The value to convert. * @returns {Array} Returns the converted array. * @example * * _.toArray({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; [1, 2] * * _.toArray(&#39;abc&#39;); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] * * _.toArray(1); * // =&gt; [] * * _.toArray(null); * // =&gt; [] */ function toArray(value) { if (!value) { return []; } if (isArrayLike(value)) { return isString(value) ? stringToArray(value) : copyArray(value); } if (symIterator &amp;&amp; value[symIterator]) { return iteratorToArray(value[symIterator]()); } var tag = getTag(value), func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values); return func(value); } /** * Convertsvalueto a finite number. * * @static * @memberOf _ * @since 4.12.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted number. * @example * * _.toFinite(3.2); * // =&gt; 3.2 * * _.toFinite(Number.MIN_VALUE); * // =&gt; 5e-324 * * _.toFinite(Infinity); * // =&gt; 1.7976931348623157e+308 * * _.toFinite(&#39;3.2&#39;); * // =&gt; 3.2 */ function toFinite(value) { if (!value) { return value === 0 ? value : 0; } value = toNumber(value); if (value === INFINITY || value === -INFINITY) { var sign = (value &lt; 0 ? -1 : 1); return sign * MAX_INTEGER; } return value === value ? value : 0; } /** * Convertsvalueto an integer. * * **Note:** This method is loosely based on * [ToInteger](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toInteger(3.2); * // =&gt; 3 * * _.toInteger(Number.MIN_VALUE); * // =&gt; 0 * * _.toInteger(Infinity); * // =&gt; 1.7976931348623157e+308 * * _.toInteger(&#39;3.2&#39;); * // =&gt; 3 */ function toInteger(value) { var result = toFinite(value), remainder = result % 1; return result === result ? (remainder ? result - remainder : result) : 0; } /** * Convertsvalueto an integer suitable for use as the length of an * array-like object. * * **Note:** This method is based on * [ToLength](http://ecma-international.org/ecma-262/7.0/#sec-tolength). * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toLength(3.2); * // =&gt; 3 * * _.toLength(Number.MIN_VALUE); * // =&gt; 0 * * _.toLength(Infinity); * // =&gt; 4294967295 * * _.toLength(&#39;3.2&#39;); * // =&gt; 3 */ function toLength(value) { return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0; } /** * Convertsvalueto a number. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to process. * @returns {number} Returns the number. * @example * * _.toNumber(3.2); * // =&gt; 3.2 * * _.toNumber(Number.MIN_VALUE); * // =&gt; 5e-324 * * _.toNumber(Infinity); * // =&gt; Infinity * * _.toNumber(&#39;3.2&#39;); * // =&gt; 3.2 */ function toNumber(value) { if (typeof value == &#39;number&#39;) { return value; } if (isSymbol(value)) { return NAN; } if (isObject(value)) { var other = typeof value.valueOf == &#39;function&#39; ? value.valueOf() : value; value = isObject(other) ? (other + &#39;&#39;) : other; } if (typeof value != &#39;string&#39;) { return value === 0 ? value : +value; } value = value.replace(reTrim, &#39;&#39;); var isBinary = reIsBinary.test(value); return (isBinary || reIsOctal.test(value)) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : (reIsBadHex.test(value) ? NAN : +value); } /** * Convertsvalueto a plain object flattening inherited enumerable string * keyed properties ofvalueto own properties of the plain object. * * @static * @memberOf _ * @since 3.0.0 * @category Lang * @param {*} value The value to convert. * @returns {Object} Returns the converted plain object. * @example * * function Foo() { * this.b = 2; * } * * Foo.prototype.c = 3; * * _.assign({ &#39;a&#39;: 1 }, new Foo); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } * * _.assign({ &#39;a&#39;: 1 }, _.toPlainObject(new Foo)); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 } */ function toPlainObject(value) { return copyObject(value, keysIn(value)); } /** * Convertsvalueto a safe integer. A safe integer can be compared and * represented correctly. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {number} Returns the converted integer. * @example * * _.toSafeInteger(3.2); * // =&gt; 3 * * _.toSafeInteger(Number.MIN_VALUE); * // =&gt; 0 * * _.toSafeInteger(Infinity); * // =&gt; 9007199254740991 * * _.toSafeInteger(&#39;3.2&#39;); * // =&gt; 3 */ function toSafeInteger(value) { return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : (value === 0 ? value : 0); } /** * Convertsvalueto a string. An empty string is returned fornull* andundefinedvalues. The sign of-0is preserved. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param {*} value The value to convert. * @returns {string} Returns the converted string. * @example * * _.toString(null); * // =&gt; &#39;&#39; * * _.toString(-0); * // =&gt; &#39;-0&#39; * * _.toString([1, 2, 3]); * // =&gt; &#39;1,2,3&#39; */ function toString(value) { return value == null ? &#39;&#39; : baseToString(value); } /*------------------------------------------------------------------------*/ /** * Assigns own enumerable string keyed properties of source objects to the * destination object. Source objects are applied from left to right. * Subsequent sources overwrite property assignments of previous sources. * * **Note:** This method mutatesobjectand is loosely based on * [Object.assign](https://mdn.io/Object/assign). * * @static * @memberOf _ * @since 0.10.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.assignIn * @example * * function Foo() { * this.a = 1; * } * * function Bar() { * this.c = 3; * } * * Foo.prototype.b = 2; * Bar.prototype.d = 4; * * _.assign({ &#39;a&#39;: 0 }, new Foo, new Bar); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ var assign = createAssigner(function(object, source) { if (isPrototype(source) || isArrayLike(source)) { copyObject(source, keys(source), object); return; } for (var key in source) { if (hasOwnProperty.call(source, key)) { assignValue(object, key, source[key]); } } }); /** * This method is like_.assignexcept that it iterates over own and * inherited source properties. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @alias extend * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.assign * @example * * function Foo() { * this.a = 1; * } * * function Bar() { * this.c = 3; * } * * Foo.prototype.b = 2; * Bar.prototype.d = 4; * * _.assignIn({ &#39;a&#39;: 0 }, new Foo, new Bar); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4 } */ var assignIn = createAssigner(function(object, source) { copyObject(source, keysIn(source), object); }); /** * This method is like_.assignInexcept that it acceptscustomizer* which is invoked to produce the assigned values. Ifcustomizerreturns *undefined, assignment is handled by the method instead. Thecustomizer* is invoked with five arguments: (objValue, srcValue, key, object, source). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @alias extendWith * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @see _.assignWith * @example * * function customizer(objValue, srcValue) { * return _.isUndefined(objValue) ? srcValue : objValue; * } * * var defaults = _.partialRight(_.assignInWith, customizer); * * defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var assignInWith = createAssigner(function(object, source, srcIndex, customizer) { copyObject(source, keysIn(source), object, customizer); }); /** * This method is like_.assignexcept that it acceptscustomizer* which is invoked to produce the assigned values. Ifcustomizerreturns *undefined, assignment is handled by the method instead. Thecustomizer* is invoked with five arguments: (objValue, srcValue, key, object, source). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @see _.assignInWith * @example * * function customizer(objValue, srcValue) { * return _.isUndefined(objValue) ? srcValue : objValue; * } * * var defaults = _.partialRight(_.assignWith, customizer); * * defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var assignWith = createAssigner(function(object, source, srcIndex, customizer) { copyObject(source, keys(source), object, customizer); }); /** * Creates an array of values corresponding topathsofobject. * * @static * @memberOf _ * @since 1.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Array} Returns the picked values. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }, 4] }; * * _.at(object, [&#39;a[0].b.c&#39;, &#39;a[1]&#39;]); * // =&gt; [3, 4] */ var at = flatRest(baseAt); /** * Creates an object that inherits from theprototypeobject. If a *propertiesobject is given, its own enumerable string keyed properties * are assigned to the created object. * * @static * @memberOf _ * @since 2.3.0 * @category Object * @param {Object} prototype The object to inherit from. * @param {Object} [properties] The properties to assign to the object. * @returns {Object} Returns the new object. * @example * * function Shape() { * this.x = 0; * this.y = 0; * } * * function Circle() { * Shape.call(this); * } * * Circle.prototype = _.create(Shape.prototype, { * &#39;constructor&#39;: Circle * }); * * var circle = new Circle; * circle instanceof Circle; * // =&gt; true * * circle instanceof Shape; * // =&gt; true */ function create(prototype, properties) { var result = baseCreate(prototype); return properties == null ? result : baseAssign(result, properties); } /** * Assigns own and inherited enumerable string keyed properties of source * objects to the destination object for all destination properties that * resolve toundefined. Source objects are applied from left to right. * Once a property is set, additional values of the same property are ignored. * * **Note:** This method mutatesobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.defaultsDeep * @example * * _.defaults({ &#39;a&#39;: 1 }, { &#39;b&#39;: 2 }, { &#39;a&#39;: 3 }); * // =&gt; { &#39;a&#39;: 1, &#39;b&#39;: 2 } */ var defaults = baseRest(function(object, sources) { object = Object(object); var index = -1; var length = sources.length; var guard = length &gt; 2 ? sources[2] : undefined; if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) { length = 1; } while (++index &lt; length) { var source = sources[index]; var props = keysIn(source); var propsIndex = -1; var propsLength = props.length; while (++propsIndex &lt; propsLength) { var key = props[propsIndex]; var value = object[key]; if (value === undefined || (eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) { object[key] = source[key]; } } } return object; }); /** * This method is like_.defaultsexcept that it recursively assigns * default properties. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 3.10.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @see _.defaults * @example * * _.defaultsDeep({ &#39;a&#39;: { &#39;b&#39;: 2 } }, { &#39;a&#39;: { &#39;b&#39;: 1, &#39;c&#39;: 3 } }); * // =&gt; { &#39;a&#39;: { &#39;b&#39;: 2, &#39;c&#39;: 3 } } */ var defaultsDeep = baseRest(function(args) { args.push(undefined, customDefaultsMerge); return apply(mergeWith, undefined, args); }); /** * This method is like_.findexcept that it returns the key of the first * elementpredicatereturns truthy for instead of the element itself. * * @static * @memberOf _ * @since 1.1.0 * @category Object * @param {Object} object The object to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {string|undefined} Returns the key of the matched element, * elseundefined. * @example * * var users = { * &#39;barney&#39;: { &#39;age&#39;: 36, &#39;active&#39;: true }, * &#39;fred&#39;: { &#39;age&#39;: 40, &#39;active&#39;: false }, * &#39;pebbles&#39;: { &#39;age&#39;: 1, &#39;active&#39;: true } * }; * * _.findKey(users, function(o) { return o.age &lt; 40; }); * // =&gt; &#39;barney&#39; (iteration order is not guaranteed) * * // The_.matchesiteratee shorthand. * _.findKey(users, { &#39;age&#39;: 1, &#39;active&#39;: true }); * // =&gt; &#39;pebbles&#39; * * // The_.matchesPropertyiteratee shorthand. * _.findKey(users, [&#39;active&#39;, false]); * // =&gt; &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.findKey(users, &#39;active&#39;); * // =&gt; &#39;barney&#39; */ function findKey(object, predicate) { return baseFindKey(object, getIteratee(predicate, 3), baseForOwn); } /** * This method is like_.findKeyexcept that it iterates over elements of * a collection in the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to inspect. * @param {Function} [predicate=_.identity] The function invoked per iteration. * @returns {string|undefined} Returns the key of the matched element, * elseundefined. * @example * * var users = { * &#39;barney&#39;: { &#39;age&#39;: 36, &#39;active&#39;: true }, * &#39;fred&#39;: { &#39;age&#39;: 40, &#39;active&#39;: false }, * &#39;pebbles&#39;: { &#39;age&#39;: 1, &#39;active&#39;: true } * }; * * _.findLastKey(users, function(o) { return o.age &lt; 40; }); * // =&gt; returns &#39;pebbles&#39; assuming.findKeyreturns &#39;barney&#39; * * // The.matchesiteratee shorthand. * _.findLastKey(users, { &#39;age&#39;: 36, &#39;active&#39;: true }); * // =&gt; &#39;barney&#39; * * // The_.matchesPropertyiteratee shorthand. * _.findLastKey(users, [&#39;active&#39;, false]); * // =&gt; &#39;fred&#39; * * // The_.propertyiteratee shorthand. * _.findLastKey(users, &#39;active&#39;); * // =&gt; &#39;pebbles&#39; */ function findLastKey(object, predicate) { return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight); } /** * Iterates over own and inherited enumerable string keyed properties of an * object and invokesiterateefor each property. The iteratee is invoked * with three arguments: (value, key, object). Iteratee functions may exit * iteration early by explicitly returningfalse. * * @static * @memberOf _ * @since 0.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forInRight * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forIn(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39;, &#39;b&#39;, then &#39;c&#39; (iteration order is not guaranteed). */ function forIn(object, iteratee) { return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn); } /** * This method is like_.forInexcept that it iterates over properties of *objectin the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forIn * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forInRight(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;c&#39;, &#39;b&#39;, then &#39;a&#39; assuming_.forInlogs &#39;a&#39;, &#39;b&#39;, then &#39;c&#39;. */ function forInRight(object, iteratee) { return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn); } /** * Iterates over own enumerable string keyed properties of an object and * invokesiterateefor each property. The iteratee is invoked with three * arguments: (value, key, object). Iteratee functions may exit iteration * early by explicitly returningfalse. * * @static * @memberOf _ * @since 0.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forOwnRight * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forOwn(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;a&#39; then &#39;b&#39; (iteration order is not guaranteed). */ function forOwn(object, iteratee) { return object &amp;&amp; baseForOwn(object, getIteratee(iteratee, 3)); } /** * This method is like_.forOwnexcept that it iterates over properties of *objectin the opposite order. * * @static * @memberOf _ * @since 2.0.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returnsobject. * @see _.forOwn * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.forOwnRight(new Foo, function(value, key) { * console.log(key); * }); * // =&gt; Logs &#39;b&#39; then &#39;a&#39; assuming_.forOwnlogs &#39;a&#39; then &#39;b&#39;. */ function forOwnRight(object, iteratee) { return object &amp;&amp; baseForOwnRight(object, getIteratee(iteratee, 3)); } /** * Creates an array of function property names from own enumerable properties * ofobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to inspect. * @returns {Array} Returns the function names. * @see _.functionsIn * @example * * function Foo() { * this.a = _.constant(&#39;a&#39;); * this.b = _.constant(&#39;b&#39;); * } * * Foo.prototype.c = _.constant(&#39;c&#39;); * * _.functions(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;] */ function functions(object) { return object == null ? [] : baseFunctions(object, keys(object)); } /** * Creates an array of function property names from own and inherited * enumerable properties ofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to inspect. * @returns {Array} Returns the function names. * @see _.functions * @example * * function Foo() { * this.a = _.constant(&#39;a&#39;); * this.b = _.constant(&#39;b&#39;); * } * * Foo.prototype.c = _.constant(&#39;c&#39;); * * _.functionsIn(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] */ function functionsIn(object) { return object == null ? [] : baseFunctions(object, keysIn(object)); } /** * Gets the value atpathofobject. If the resolved value is *undefined, thedefaultValueis returned in its place. * * @static * @memberOf _ * @since 3.7.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the property to get. * @param {*} [defaultValue] The value returned forundefinedresolved values. * @returns {*} Returns the resolved value. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.get(object, &#39;a[0].b.c&#39;); * // =&gt; 3 * * _.get(object, [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;]); * // =&gt; 3 * * _.get(object, &#39;a.b.c&#39;, &#39;default&#39;); * // =&gt; &#39;default&#39; */ function get(object, path, defaultValue) { var result = object == null ? undefined : baseGet(object, path); return result === undefined ? defaultValue : result; } /** * Checks ifpathis a direct property ofobject. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path to check. * @returns {boolean} Returnstrueifpathexists, elsefalse. * @example * * var object = { &#39;a&#39;: { &#39;b&#39;: 2 } }; * var other = _.create({ &#39;a&#39;: _.create({ &#39;b&#39;: 2 }) }); * * _.has(object, &#39;a&#39;); * // =&gt; true * * _.has(object, &#39;a.b&#39;); * // =&gt; true * * _.has(object, [&#39;a&#39;, &#39;b&#39;]); * // =&gt; true * * _.has(other, &#39;a&#39;); * // =&gt; false */ function has(object, path) { return object != null &amp;&amp; hasPath(object, path, baseHas); } /** * Checks ifpathis a direct or inherited property ofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path to check. * @returns {boolean} Returnstrueifpathexists, elsefalse. * @example * * var object = _.create({ &#39;a&#39;: _.create({ &#39;b&#39;: 2 }) }); * * _.hasIn(object, &#39;a&#39;); * // =&gt; true * * _.hasIn(object, &#39;a.b&#39;); * // =&gt; true * * _.hasIn(object, [&#39;a&#39;, &#39;b&#39;]); * // =&gt; true * * _.hasIn(object, &#39;b&#39;); * // =&gt; false */ function hasIn(object, path) { return object != null &amp;&amp; hasPath(object, path, baseHasIn); } /** * Creates an object composed of the inverted keys and values ofobject. * Ifobjectcontains duplicate values, subsequent values overwrite * property assignments of previous values. * * @static * @memberOf _ * @since 0.7.0 * @category Object * @param {Object} object The object to invert. * @returns {Object} Returns the new inverted object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }; * * _.invert(object); * // =&gt; { &#39;1&#39;: &#39;c&#39;, &#39;2&#39;: &#39;b&#39; } */ var invert = createInverter(function(result, value, key) { if (value != null &amp;&amp; typeof value.toString != &#39;function&#39;) { value = nativeObjectToString.call(value); } result[value] = key; }, constant(identity)); /** * This method is like_.invertexcept that the inverted object is generated * from the results of running each element ofobjectthruiteratee. The * corresponding inverted value of each inverted key is an array of keys * responsible for generating the inverted value. The iteratee is invoked * with one argument: (value). * * @static * @memberOf _ * @since 4.1.0 * @category Object * @param {Object} object The object to invert. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {Object} Returns the new inverted object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }; * * _.invertBy(object); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } * * _.invertBy(object, function(value) { * return &#39;group&#39; + value; * }); * // =&gt; { &#39;group1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;group2&#39;: [&#39;b&#39;] } */ var invertBy = createInverter(function(result, value, key) { if (value != null &amp;&amp; typeof value.toString != &#39;function&#39;) { value = nativeObjectToString.call(value); } if (hasOwnProperty.call(result, value)) { result[value].push(key); } else { result[value] = [key]; } }, getIteratee); /** * Invokes the method atpathofobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {*} Returns the result of the invoked method. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: [1, 2, 3, 4] } }] }; * * _.invoke(object, &#39;a[0].b.c.slice&#39;, 1, 3); * // =&gt; [2, 3] */ var invoke = baseRest(baseInvoke); /** * Creates an array of the own enumerable property names ofobject. * * **Note:** Non-object values are coerced to objects. See the * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys) * for more details. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keys(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;] (iteration order is not guaranteed) * * _.keys(&#39;hi&#39;); * // =&gt; [&#39;0&#39;, &#39;1&#39;] */ function keys(object) { return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object); } /** * Creates an array of the own and inherited enumerable property names ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @memberOf _ * @since 3.0.0 * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property names. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.keysIn(new Foo); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] (iteration order is not guaranteed) */ function keysIn(object) { return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object); } /** * The opposite of_.mapValues; this method creates an object with the * same values asobjectand keys generated by running each own enumerable * string keyed property ofobjectthruiteratee. The iteratee is invoked * with three arguments: (value, key, object). * * @static * @memberOf _ * @since 3.8.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returns the new mapped object. * @see _.mapValues * @example * * _.mapKeys({ &#39;a&#39;: 1, &#39;b&#39;: 2 }, function(value, key) { * return key + value; * }); * // =&gt; { &#39;a1&#39;: 1, &#39;b2&#39;: 2 } */ function mapKeys(object, iteratee) { var result = {}; iteratee = getIteratee(iteratee, 3); baseForOwn(object, function(value, key, object) { baseAssignValue(result, iteratee(value, key, object), value); }); return result; } /** * Creates an object with the same keys asobjectand values generated * by running each own enumerable string keyed property ofobjectthru *iteratee. The iteratee is invoked with three arguments: * (value, key, object). * * @static * @memberOf _ * @since 2.4.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Object} Returns the new mapped object. * @see _.mapKeys * @example * * var users = { * &#39;fred&#39;: { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }, * &#39;pebbles&#39;: { &#39;user&#39;: &#39;pebbles&#39;, &#39;age&#39;: 1 } * }; * * _.mapValues(users, function(o) { return o.age; }); * // =&gt; { &#39;fred&#39;: 40, &#39;pebbles&#39;: 1 } (iteration order is not guaranteed) * * // The_.propertyiteratee shorthand. * _.mapValues(users, &#39;age&#39;); * // =&gt; { &#39;fred&#39;: 40, &#39;pebbles&#39;: 1 } (iteration order is not guaranteed) */ function mapValues(object, iteratee) { var result = {}; iteratee = getIteratee(iteratee, 3); baseForOwn(object, function(value, key, object) { baseAssignValue(result, key, iteratee(value, key, object)); }); return result; } /** * This method is like_.assignexcept that it recursively merges own and * inherited enumerable string keyed properties of source objects into the * destination object. Source properties that resolve toundefinedare * skipped if a destination value exists. Array and plain object properties * are merged recursively. Other objects and value types are overridden by * assignment. Source objects are applied from left to right. Subsequent * sources overwrite property assignments of previous sources. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 0.5.0 * @category Object * @param {Object} object The destination object. * @param {...Object} [sources] The source objects. * @returns {Object} Returnsobject. * @example * * var object = { * &#39;a&#39;: [{ &#39;b&#39;: 2 }, { &#39;d&#39;: 4 }] * }; * * var other = { * &#39;a&#39;: [{ &#39;c&#39;: 3 }, { &#39;e&#39;: 5 }] * }; * * _.merge(object, other); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: 2, &#39;c&#39;: 3 }, { &#39;d&#39;: 4, &#39;e&#39;: 5 }] } */ var merge = createAssigner(function(object, source, srcIndex) { baseMerge(object, source, srcIndex); }); /** * This method is like_.mergeexcept that it acceptscustomizerwhich * is invoked to produce the merged values of the destination and source * properties. Ifcustomizerreturnsundefined, merging is handled by the * method instead. Thecustomizeris invoked with six arguments: * (objValue, srcValue, key, object, source, stack). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The destination object. * @param {...Object} sources The source objects. * @param {Function} customizer The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * function customizer(objValue, srcValue) { * if (_.isArray(objValue)) { * return objValue.concat(srcValue); * } * } * * var object = { &#39;a&#39;: [1], &#39;b&#39;: [2] }; * var other = { &#39;a&#39;: [3], &#39;b&#39;: [4] }; * * _.mergeWith(object, other, customizer); * // =&gt; { &#39;a&#39;: [1, 3], &#39;b&#39;: [2, 4] } */ var mergeWith = createAssigner(function(object, source, srcIndex, customizer) { baseMerge(object, source, srcIndex, customizer); }); /** * The opposite of.pick; this method creates an object composed of the * own and inherited enumerable property paths ofobjectthat are not omitted. * * **Note:** This method is considerably slower than.pick. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The source object. * @param {...(string|string[])} [paths] The property paths to omit. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.omit(object, [&#39;a&#39;, &#39;c&#39;]); * // =&gt; { &#39;b&#39;: &#39;2&#39; } */ var omit = flatRest(function(object, paths) { var result = {}; if (object == null) { return result; } var isDeep = false; paths = arrayMap(paths, function(path) { path = castPath(path, object); isDeep || (isDeep = path.length &gt; 1); return path; }); copyObject(object, getAllKeysIn(object), result); if (isDeep) { result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone); } var length = paths.length; while (length--) { baseUnset(result, paths[length]); } return result; }); /** * The opposite of_.pickBy; this method creates an object composed of * the own and inherited enumerable string keyed properties ofobjectthat *predicatedoesn&#39;t return truthy for. The predicate is invoked with two * arguments: (value, key). * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The source object. * @param {Function} [predicate=_.identity] The function invoked per property. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.omitBy(object, _.isNumber); * // =&gt; { &#39;b&#39;: &#39;2&#39; } */ function omitBy(object, predicate) { return pickBy(object, negate(getIteratee(predicate))); } /** * Creates an object composed of the pickedobjectproperties. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The source object. * @param {...(string|string[])} [paths] The property paths to pick. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.pick(object, [&#39;a&#39;, &#39;c&#39;]); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ var pick = flatRest(function(object, paths) { return object == null ? {} : basePick(object, paths); }); /** * Creates an object composed of theobjectpropertiespredicatereturns * truthy for. The predicate is invoked with two arguments: (value, key). * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The source object. * @param {Function} [predicate=_.identity] The function invoked per property. * @returns {Object} Returns the new object. * @example * * var object = { &#39;a&#39;: 1, &#39;b&#39;: &#39;2&#39;, &#39;c&#39;: 3 }; * * _.pickBy(object, _.isNumber); * // =&gt; { &#39;a&#39;: 1, &#39;c&#39;: 3 } */ function pickBy(object, predicate) { if (object == null) { return {}; } var props = arrayMap(getAllKeysIn(object), function(prop) { return [prop]; }); predicate = getIteratee(predicate); return basePickBy(object, props, function(value, path) { return predicate(value, path[0]); }); } /** * This method is like_.getexcept that if the resolved value is a * function it&#39;s invoked with thethisbinding of its parent object and * its result is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @param {Array|string} path The path of the property to resolve. * @param {*} [defaultValue] The value returned forundefinedresolved values. * @returns {*} Returns the resolved value. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c1&#39;: 3, &#39;c2&#39;: _.constant(4) } }] }; * * _.result(object, &#39;a[0].b.c1&#39;); * // =&gt; 3 * * _.result(object, &#39;a[0].b.c2&#39;); * // =&gt; 4 * * _.result(object, &#39;a[0].b.c3&#39;, &#39;default&#39;); * // =&gt; &#39;default&#39; * * _.result(object, &#39;a[0].b.c3&#39;, _.constant(&#39;default&#39;)); * // =&gt; &#39;default&#39; */ function result(object, path, defaultValue) { path = castPath(path, object); var index = -1, length = path.length; // Ensure the loop is entered when path is empty. if (!length) { length = 1; object = undefined; } while (++index &lt; length) { var value = object == null ? undefined : object[toKey(path[index])]; if (value === undefined) { index = length; value = defaultValue; } object = isFunction(value) ? value.call(object) : value; } return object; } /** * Sets the value atpathofobject. If a portion ofpathdoesn&#39;t exist, * it&#39;s created. Arrays are created for missing index properties while objects * are created for all other missing properties. Use_.setWithto customize *pathcreation. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 3.7.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {*} value The value to set. * @returns {Object} Returnsobject. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.set(object, &#39;a[0].b.c&#39;, 4); * console.log(object.a[0].b.c); * // =&gt; 4 * * _.set(object, [&#39;x&#39;, &#39;0&#39;, &#39;y&#39;, &#39;z&#39;], 5); * console.log(object.x[0].y.z); * // =&gt; 5 */ function set(object, path, value) { return object == null ? object : baseSet(object, path, value); } /** * This method is like_.setexcept that it acceptscustomizerwhich is * invoked to produce the objects ofpath. Ifcustomizerreturnsundefined* path creation is handled by the method instead. Thecustomizeris invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {*} value The value to set. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * var object = {}; * * _.setWith(object, &#39;[0][1]&#39;, &#39;a&#39;, Object); * // =&gt; { &#39;0&#39;: { &#39;1&#39;: &#39;a&#39; } } */ function setWith(object, path, value, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return object == null ? object : baseSet(object, path, value, customizer); } /** * Creates an array of own enumerable string keyed-value pairs forobject* which can be consumed by_.fromPairs. Ifobjectis a map or set, its * entries are returned. * * @static * @memberOf _ * @since 4.0.0 * @alias entries * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the key-value pairs. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.toPairs(new Foo); * // =&gt; [[&#39;a&#39;, 1], [&#39;b&#39;, 2]] (iteration order is not guaranteed) */ var toPairs = createToPairs(keys); /** * Creates an array of own and inherited enumerable string keyed-value pairs * forobjectwhich can be consumed by_.fromPairs. Ifobjectis a map * or set, its entries are returned. * * @static * @memberOf _ * @since 4.0.0 * @alias entriesIn * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the key-value pairs. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.toPairsIn(new Foo); * // =&gt; [[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]] (iteration order is not guaranteed) */ var toPairsIn = createToPairs(keysIn); /** * An alternative to_.reduce; this method transformsobjectto a new *accumulatorobject which is the result of running each of its own * enumerable string keyed properties thruiteratee, with each invocation * potentially mutating theaccumulatorobject. Ifaccumulatoris not * provided, a new object with the same[[Prototype]]will be used. The * iteratee is invoked with four arguments: (accumulator, value, key, object). * Iteratee functions may exit iteration early by explicitly returningfalse. * * @static * @memberOf _ * @since 1.3.0 * @category Object * @param {Object} object The object to iterate over. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @param {*} [accumulator] The custom accumulator value. * @returns {*} Returns the accumulated value. * @example * * _.transform([2, 3, 4], function(result, n) { * result.push(n *= n); * return n % 2 == 0; * }, []); * // =&gt; [4, 9] * * _.transform({ &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 1 }, function(result, value, key) { * (result[value] || (result[value] = [])).push(key); * }, {}); * // =&gt; { &#39;1&#39;: [&#39;a&#39;, &#39;c&#39;], &#39;2&#39;: [&#39;b&#39;] } */ function transform(object, iteratee, accumulator) { var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object); iteratee = getIteratee(iteratee, 4); if (accumulator == null) { var Ctor = object &amp;&amp; object.constructor; if (isArrLike) { accumulator = isArr ? new Ctor : []; } else if (isObject(object)) { accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}; } else { accumulator = {}; } } (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) { return iteratee(accumulator, value, index, object); }); return accumulator; } /** * Removes the property atpathofobject. * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.0.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to unset. * @returns {boolean} Returnstrueif the property is deleted, elsefalse. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 7 } }] }; * _.unset(object, &#39;a[0].b.c&#39;); * // =&gt; true * * console.log(object); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: {} }] }; * * _.unset(object, [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;]); * // =&gt; true * * console.log(object); * // =&gt; { &#39;a&#39;: [{ &#39;b&#39;: {} }] }; */ function unset(object, path) { return object == null ? true : baseUnset(object, path); } /** * This method is like.setexcept that acceptsupdaterto produce the * value to set. Use.updateWithto customizepathcreation. Theupdater* is invoked with one argument: (value). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.6.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {Function} updater The function to produce the updated value. * @returns {Object} Returnsobject. * @example * * var object = { &#39;a&#39;: [{ &#39;b&#39;: { &#39;c&#39;: 3 } }] }; * * _.update(object, &#39;a[0].b.c&#39;, function(n) { return n * n; }); * console.log(object.a[0].b.c); * // =&gt; 9 * * _.update(object, &#39;x[0].y.z&#39;, function(n) { return n ? n + 1 : 0; }); * console.log(object.x[0].y.z); * // =&gt; 0 */ function update(object, path, updater) { return object == null ? object : baseUpdate(object, path, castFunction(updater)); } /** * This method is like_.updateexcept that it acceptscustomizerwhich is * invoked to produce the objects ofpath. Ifcustomizerreturnsundefined* path creation is handled by the method instead. Thecustomizeris invoked * with three arguments: (nsValue, key, nsObject). * * **Note:** This method mutatesobject. * * @static * @memberOf _ * @since 4.6.0 * @category Object * @param {Object} object The object to modify. * @param {Array|string} path The path of the property to set. * @param {Function} updater The function to produce the updated value. * @param {Function} [customizer] The function to customize assigned values. * @returns {Object} Returnsobject. * @example * * var object = {}; * * _.updateWith(object, &#39;[0][1]&#39;, _.constant(&#39;a&#39;), Object); * // =&gt; { &#39;0&#39;: { &#39;1&#39;: &#39;a&#39; } } */ function updateWith(object, path, updater, customizer) { customizer = typeof customizer == &#39;function&#39; ? customizer : undefined; return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer); } /** * Creates an array of the own enumerable string keyed property values ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @since 0.1.0 * @memberOf _ * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property values. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.values(new Foo); * // =&gt; [1, 2] (iteration order is not guaranteed) * * _.values(&#39;hi&#39;); * // =&gt; [&#39;h&#39;, &#39;i&#39;] */ function values(object) { return object == null ? [] : baseValues(object, keys(object)); } /** * Creates an array of the own and inherited enumerable string keyed property * values ofobject. * * **Note:** Non-object values are coerced to objects. * * @static * @memberOf _ * @since 3.0.0 * @category Object * @param {Object} object The object to query. * @returns {Array} Returns the array of property values. * @example * * function Foo() { * this.a = 1; * this.b = 2; * } * * Foo.prototype.c = 3; * * _.valuesIn(new Foo); * // =&gt; [1, 2, 3] (iteration order is not guaranteed) */ function valuesIn(object) { return object == null ? [] : baseValues(object, keysIn(object)); } /*------------------------------------------------------------------------*/ /** * Clampsnumberwithin the inclusivelowerandupperbounds. * * @static * @memberOf _ * @since 4.0.0 * @category Number * @param {number} number The number to clamp. * @param {number} [lower] The lower bound. * @param {number} upper The upper bound. * @returns {number} Returns the clamped number. * @example * * _.clamp(-10, -5, 5); * // =&gt; -5 * * _.clamp(10, -5, 5); * // =&gt; 5 */ function clamp(number, lower, upper) { if (upper === undefined) { upper = lower; lower = undefined; } if (upper !== undefined) { upper = toNumber(upper); upper = upper === upper ? upper : 0; } if (lower !== undefined) { lower = toNumber(lower); lower = lower === lower ? lower : 0; } return baseClamp(toNumber(number), lower, upper); } /** * Checks ifnis betweenstartand up to, but not including,end. If *endis not specified, it&#39;s set tostartwithstartthen set to0. * Ifstartis greater thanendthe params are swapped to support * negative ranges. * * @static * @memberOf _ * @since 3.3.0 * @category Number * @param {number} number The number to check. * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @returns {boolean} Returnstrueifnumberis in the range, elsefalse. * @see _.range, _.rangeRight * @example * * _.inRange(3, 2, 4); * // =&gt; true * * _.inRange(4, 8); * // =&gt; true * * _.inRange(4, 2); * // =&gt; false * * _.inRange(2, 2); * // =&gt; false * * _.inRange(1.2, 2); * // =&gt; true * * _.inRange(5.2, 4); * // =&gt; false * * _.inRange(-3, -2, -6); * // =&gt; true */ function inRange(number, start, end) { start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } number = toNumber(number); return baseInRange(number, start, end); } /** * Produces a random number between the inclusivelowerandupperbounds. * If only one argument is provided a number between0and the given number * is returned. Iffloatingistrue, or eitherlowerorupperare * floats, a floating-point number is returned instead of an integer. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @memberOf _ * @since 0.7.0 * @category Number * @param {number} [lower=0] The lower bound. * @param {number} [upper=1] The upper bound. * @param {boolean} [floating] Specify returning a floating-point number. * @returns {number} Returns the random number. * @example * * _.random(0, 5); * // =&gt; an integer between 0 and 5 * * _.random(5); * // =&gt; also an integer between 0 and 5 * * _.random(5, true); * // =&gt; a floating-point number between 0 and 5 * * _.random(1.2, 5.2); * // =&gt; a floating-point number between 1.2 and 5.2 */ function random(lower, upper, floating) { if (floating &amp;&amp; typeof floating != &#39;boolean&#39; &amp;&amp; isIterateeCall(lower, upper, floating)) { upper = floating = undefined; } if (floating === undefined) { if (typeof upper == &#39;boolean&#39;) { floating = upper; upper = undefined; } else if (typeof lower == &#39;boolean&#39;) { floating = lower; lower = undefined; } } if (lower === undefined &amp;&amp; upper === undefined) { lower = 0; upper = 1; } else { lower = toFinite(lower); if (upper === undefined) { upper = lower; lower = 0; } else { upper = toFinite(upper); } } if (lower &gt; upper) { var temp = lower; lower = upper; upper = temp; } if (floating || lower % 1 || upper % 1) { var rand = nativeRandom(); return nativeMin(lower + (rand * (upper - lower + freeParseFloat(&#39;1e-&#39; + ((rand + &#39;&#39;).length - 1)))), upper); } return baseRandom(lower, upper); } /*------------------------------------------------------------------------*/ /** * Convertsstringto [camel case](https://en.wikipedia.org/wiki/CamelCase). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the camel cased string. * @example * * _.camelCase(&#39;Foo Bar&#39;); * // =&gt; &#39;fooBar&#39; * * _.camelCase(&#39;--foo-bar--&#39;); * // =&gt; &#39;fooBar&#39; * * _.camelCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;fooBar&#39; */ var camelCase = createCompounder(function(result, word, index) { word = word.toLowerCase(); return result + (index ? capitalize(word) : word); }); /** * Converts the first character ofstringto upper case and the remaining * to lower case. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to capitalize. * @returns {string} Returns the capitalized string. * @example * * _.capitalize(&#39;FRED&#39;); * // =&gt; &#39;Fred&#39; */ function capitalize(string) { return upperFirst(toString(string).toLowerCase()); } /** * Deburrsstringby converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to deburr. * @returns {string} Returns the deburred string. * @example * * _.deburr(&#39;déjà vu&#39;); * // =&gt; &#39;deja vu&#39; */ function deburr(string) { string = toString(string); return string &amp;&amp; string.replace(reLatin, deburrLetter).replace(reComboMark, &#39;&#39;); } /** * Checks ifstringends with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=string.length] The position to search up to. * @returns {boolean} Returnstrueifstringends withtarget, * elsefalse. * @example * * _.endsWith(&#39;abc&#39;, &#39;c&#39;); * // =&gt; true * * _.endsWith(&#39;abc&#39;, &#39;b&#39;); * // =&gt; false * * _.endsWith(&#39;abc&#39;, &#39;b&#39;, 2); * // =&gt; true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position &gt;= 0 &amp;&amp; string.slice(position, end) == target; } /** * Converts the characters &quot;&amp;&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &#39;&quot;&#39;, and &quot;&#39;&quot; instringto their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the &quot;&gt;&quot; character is escaped for symmetry, characters like * &quot;&gt;&quot; and &quot;/&quot; don&#39;t need escaping in HTML and have no special meaning * unless they&#39;re part of a tag or unquoted attribute value. See * [Mathias Bynens&#39;s article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under &quot;semi-related fun fact&quot;) for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=&#39;&#39;] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; &#39;fred, barney, &amp;amp; pebbles&#39; */ function escape(string) { string = toString(string); return (string &amp;&amp; reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes theRegExpspecial characters &quot;^&quot;, &quot;$&quot;, &quot;\&quot;, &quot;.&quot;, &quot;*&quot;, &quot;+&quot;, * &quot;?&quot;, &quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, and &quot;|&quot; instring. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp(&#39;[lodash](https://lodash.com/)&#39;); * // =&gt; &#39;\[lodash\]\(https://lodash\.com/\)&#39; */ function escapeRegExp(string) { string = toString(string); return (string &amp;&amp; reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, &#39;\\$&amp;&#39;) : string; } /** * Convertsstringto * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase(&#39;Foo Bar&#39;); * // =&gt; &#39;foo-bar&#39; * * _.kebabCase(&#39;fooBar&#39;); * // =&gt; &#39;foo-bar&#39; * * _.kebabCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;foo-bar&#39; */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? &#39;-&#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Convertsstring, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase(&#39;--Foo-Bar--&#39;); * // =&gt; &#39;foo bar&#39; * * _.lowerCase(&#39;fooBar&#39;); * // =&gt; &#39;foo bar&#39; * * _.lowerCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;foo bar&#39; */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Converts the first character ofstringto lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst(&#39;Fred&#39;); * // =&gt; &#39;fred&#39; * * _.lowerFirst(&#39;FRED&#39;); * // =&gt; &#39;fRED&#39; */ var lowerFirst = createCaseFirst(&#39;toLowerCase&#39;); /** * Padsstringon the left and right sides if it&#39;s shorter thanlength. * Padding characters are truncated if they can&#39;t be evenly divided bylength. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad(&#39;abc&#39;, 8); * // =&gt; &#39; abc &#39; * * _.pad(&#39;abc&#39;, 8, &#39;_-&#39;); * // =&gt; &#39;_-abc_-_&#39; * * _.pad(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength &gt;= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Padsstringon the right side if it&#39;s shorter thanlength. Padding * characters are truncated if they exceedlength. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd(&#39;abc&#39;, 6); * // =&gt; &#39;abc &#39; * * _.padEnd(&#39;abc&#39;, 6, &#39;_-&#39;); * // =&gt; &#39;abc_-_&#39; * * _.padEnd(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length &amp;&amp; strLength &lt; length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Padsstringon the left side if it&#39;s shorter thanlength. Padding * characters are truncated if they exceedlength. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=&#39; &#39;] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart(&#39;abc&#39;, 6); * // =&gt; &#39; abc&#39; * * _.padStart(&#39;abc&#39;, 6, &#39;_-&#39;); * // =&gt; &#39;_-_abc&#39; * * _.padStart(&#39;abc&#39;, 3); * // =&gt; &#39;abc&#39; */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length &amp;&amp; strLength &lt; length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Convertsstringto an integer of the specified radix. Ifradixis *undefinedor0, aradixof10is used unlessvalueis a * hexadecimal, in which case aradixof16is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) ofparseInt. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpretvalueby. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {number} Returns the converted integer. * @example * * _.parseInt(&#39;08&#39;); * // =&gt; 8 * * _.map([&#39;6&#39;, &#39;08&#39;, &#39;10&#39;], _.parseInt); * // =&gt; [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, &#39;&#39;), radix || 0); } /** * Repeats the given stringntimes. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the repeated string. * @example * * _.repeat(&#39;*&#39;, 3); * // =&gt; &#39;***&#39; * * _.repeat(&#39;abc&#39;, 2); * // =&gt; &#39;abcabc&#39; * * _.repeat(&#39;abc&#39;, 0); * // =&gt; &#39;&#39; */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches forpatterninstringwithreplacement. * * **Note:** This method is based on * [String#replace](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace(&#39;Hi Fred&#39;, &#39;Fred&#39;, &#39;Barney&#39;); * // =&gt; &#39;Hi Barney&#39; */ function replace() { var args = arguments, string = toString(args[0]); return args.length &lt; 3 ? string : string.replace(args[1], args[2]); } /** * Convertsstringto * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase(&#39;Foo Bar&#39;); * // =&gt; &#39;foo_bar&#39; * * _.snakeCase(&#39;fooBar&#39;); * // =&gt; &#39;foo_bar&#39; * * _.snakeCase(&#39;--FOO-BAR--&#39;); * // =&gt; &#39;foo_bar&#39; */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? &#39;_&#39; : &#39;&#39;) + word.toLowerCase(); }); /** * Splitsstringbyseparator. * * **Note:** This method is based on * [String#split](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split(&#39;a-b-c&#39;, &#39;-&#39;, 2); * // =&gt; [&#39;a&#39;, &#39;b&#39;] */ function split(string, separator, limit) { if (limit &amp;&amp; typeof limit != &#39;number&#39; &amp;&amp; isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit &gt;&gt;&gt; 0; if (!limit) { return []; } string = toString(string); if (string &amp;&amp; ( typeof separator == &#39;string&#39; || (separator != null &amp;&amp; !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator &amp;&amp; hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Convertsstringto * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase(&#39;--foo-bar--&#39;); * // =&gt; &#39;Foo Bar&#39; * * _.startCase(&#39;fooBar&#39;); * // =&gt; &#39;Foo Bar&#39; * * _.startCase(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;FOO BAR&#39; */ var startCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + upperFirst(word); }); /** * Checks ifstringstarts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returnstrueifstringstarts withtarget, * elsefalse. * @example * * _.startsWith(&#39;abc&#39;, &#39;a&#39;); * // =&gt; true * * _.startsWith(&#39;abc&#39;, &#39;b&#39;); * // =&gt; false * * _.startsWith(&#39;abc&#39;, &#39;b&#39;, 1); * // =&gt; true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in &quot;interpolate&quot; delimiters, HTML-escape interpolated data properties in * &quot;escape&quot; delimiters, and execute JavaScript in &quot;evaluate&quot; delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over.templateSettingsvalues. * * **Note:** In the development build.templateutilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash&#39;s custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome&#39;s extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=&#39;&#39;] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML &quot;escape&quot; delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The &quot;evaluate&quot; delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The &quot;interpolate&quot; delimiter. * @param {string} [options.sourceURL=&#39;lodash.templateSources[n]&#39;] * The sourceURL of the compiled template. * @param {string} [options.variable=&#39;obj&#39;] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Function} Returns the compiled template function. * @example * * // Use the &quot;interpolate&quot; delimiter to create a compiled template. * var compiled = _.template(&#39;hello &lt;%= user %&gt;!&#39;); * compiled({ &#39;user&#39;: &#39;fred&#39; }); * // =&gt; &#39;hello fred!&#39; * * // Use the HTML &quot;escape&quot; delimiter to escape data property values. * var compiled = _.template(&#39;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&#39;); * compiled({ &#39;value&#39;: &#39;&lt;script&gt;&#39; }); * // =&gt; &#39;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&#39; * * // Use the &quot;evaluate&quot; delimiter to execute JavaScript and generate HTML. * var compiled = _.template(&#39;&lt;% _.forEach(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;&#39;); * compiled({ &#39;users&#39;: [&#39;fred&#39;, &#39;barney&#39;] }); * // =&gt; &#39;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#39; * * // Use the internalprintfunction in &quot;evaluate&quot; delimiters. * var compiled = _.template(&#39;&lt;% print(&quot;hello &quot; + user); %&gt;!&#39;); * compiled({ &#39;user&#39;: &#39;barney&#39; }); * // =&gt; &#39;hello barney!&#39; * * // Use the ES template literal delimiter as an &quot;interpolate&quot; delimiter. * // Disable support by replacing the &quot;interpolate&quot; delimiter. * var compiled = _.template(&#39;hello ${ user }!&#39;); * compiled({ &#39;user&#39;: &#39;pebbles&#39; }); * // =&gt; &#39;hello pebbles!&#39; * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(&#39;&lt;%= &quot;\\&lt;%- value %\\&gt;&quot; %&gt;&#39;); * compiled({ &#39;value&#39;: &#39;ignored&#39; }); * // =&gt; &#39;&lt;%- value %&gt;&#39; * * // Use theimportsoption to importjQueryasjq. * var text = &#39;&lt;% jq.each(users, function(user) { %&gt;&lt;li&gt;&lt;%- user %&gt;&lt;/li&gt;&lt;% }); %&gt;&#39;; * var compiled = _.template(text, { &#39;imports&#39;: { &#39;jq&#39;: jQuery } }); * compiled({ &#39;users&#39;: [&#39;fred&#39;, &#39;barney&#39;] }); * // =&gt; &#39;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#39; * * // Use thesourceURLoption to specify a custom sourceURL for the template. * var compiled = _.template(&#39;hello &lt;%= user %&gt;!&#39;, { &#39;sourceURL&#39;: &#39;/basic/greeting.jst&#39; }); * compiled(data); * // =&gt; Find the source of &quot;greeting.jst&quot; under the Sources tab or Resources panel of the web inspector. * * // Use thevariableoption to ensure a with-statement isn&#39;t used in the compiled template. * var compiled = _.template(&#39;hi &lt;%= data.user %&gt;!&#39;, { &#39;variable&#39;: &#39;data&#39; }); * compiled.source; * // =&gt; function(data) { * // var __t, __p = &#39;&#39;; * // __p += &#39;hi &#39; + ((__t = ( data.user )) == null ? &#39;&#39; : __t) + &#39;!&#39;; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template(&#39;hello !&#39;); * compiled({ &#39;user&#39;: &#39;mustache&#39; }); * // =&gt; &#39;hello mustache!&#39; * * // Use thesourceproperty to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), &#39;jst.js&#39;), &#39;\ * var JST = {\ * &quot;main&quot;: &#39; + _.template(mainText).source + &#39;\ * };\ * &#39;); */ function template(string, options, guard) { // Based on John Resig&#39;stmplimplementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova&#39;s doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard &amp;&amp; isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = &quot;__p += &#39;&quot;; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + &#39;|&#39; + interpolate.source + &#39;|&#39; + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + &#39;|&#39; + (options.evaluate || reNoMatch).source + &#39;|$&#39; , &#39;g&#39;); // Use a sourceURL for easier debugging. var sourceURL = &#39;//# sourceURL=&#39; + (&#39;sourceURL&#39; in options ? options.sourceURL : (&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;) ) + &#39;\n&#39;; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can&#39;t be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += &quot;&#39; +\n__e(&quot; + escapeValue + &quot;) +\n&#39;&quot;; } if (evaluateValue) { isEvaluating = true; source += &quot;&#39;;\n&quot; + evaluateValue + &quot;;\n__p += &#39;&quot;; } if (interpolateValue) { source += &quot;&#39; +\n((__t = (&quot; + interpolateValue + &quot;)) == null ? &#39;&#39; : __t) +\n&#39;&quot;; } index = offset + match.length; // The JS engine embedded in Adobe products needsmatchreturned in // order to produce the correctoffsetvalue. return match; }); source += &quot;&#39;;\n&quot;; // Ifvariableis not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = &#39;with (obj) {\n&#39; + source + &#39;\n}\n&#39;; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, &#39;&#39;) : source) .replace(reEmptyStringMiddle, &#39;$1&#39;) .replace(reEmptyStringTrailing, &#39;$1;&#39;); // Frame code as the function body. source = &#39;function(&#39; + (variable || &#39;obj&#39;) + &#39;) {\n&#39; + (variable ? &#39;&#39; : &#39;obj || (obj = {});\n&#39; ) + &quot;var __t, __p = &#39;&#39;&quot; + (isEscaping ? &#39;, __e = _.escape&#39; : &#39;&#39; ) + (isEvaluating ? &#39;, __j = Array.prototype.join;\n&#39; + &quot;function print() { __p += __j.call(arguments, &#39;&#39;) }\n&quot; : &#39;;\n&#39; ) + source + &#39;return __p\n}&#39;; var result = attempt(function() { return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues); }); // Provide the compiled function&#39;s source by itstoStringmethod or // thesourceproperty as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Convertsstring, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower(&#39;--Foo-Bar--&#39;); * // =&gt; &#39;--foo-bar--&#39; * * _.toLower(&#39;fooBar&#39;); * // =&gt; &#39;foobar&#39; * * _.toLower(&#39;__FOO_BAR__&#39;); * // =&gt; &#39;__foo_bar__&#39; */ function toLower(value) { return toString(value).toLowerCase(); } /** * Convertsstring, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper(&#39;--foo-bar--&#39;); * // =&gt; &#39;--FOO-BAR--&#39; * * _.toUpper(&#39;fooBar&#39;); * // =&gt; &#39;FOOBAR&#39; * * _.toUpper(&#39;__foo_bar__&#39;); * // =&gt; &#39;__FOO_BAR__&#39; */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trim(&#39; abc &#39;); * // =&gt; &#39;abc&#39; * * _.trim(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;abc&#39; * * _.map([&#39; foo &#39;, &#39; bar &#39;], _.trim); * // =&gt; [&#39;foo&#39;, &#39;bar&#39;] */ function trim(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrim, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(&#39;&#39;); } /** * Removes trailing whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(&#39; abc &#39;); * // =&gt; &#39; abc&#39; * * _.trimEnd(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;-_-abc&#39; */ function trimEnd(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrimEnd, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(&#39;&#39;); } /** * Removes leading whitespace or specified characters fromstring. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(&#39; abc &#39;); * // =&gt; &#39;abc &#39; * * _.trimStart(&#39;-_-abc-_-&#39;, &#39;_-&#39;); * // =&gt; &#39;abc-_-&#39; */ function trimStart(string, chars, guard) { string = toString(string); if (string &amp;&amp; (guard || chars === undefined)) { return string.replace(reTrimStart, &#39;&#39;); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(&#39;&#39;); } /** * Truncatesstringif it&#39;s longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to &quot;...&quot;. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission=&#39;...&#39;] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;); * // =&gt; &#39;hi-diddly-ho there, neighbo...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;length&#39;: 24, * &#39;separator&#39;: &#39; &#39; * }); * // =&gt; &#39;hi-diddly-ho there,...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;length&#39;: 24, * &#39;separator&#39;: /,? +/ * }); * // =&gt; &#39;hi-diddly-ho there...&#39; * * _.truncate(&#39;hi-diddly-ho there, neighborino&#39;, { * &#39;omission&#39;: &#39; [...]&#39; * }); * // =&gt; &#39;hi-diddly-ho there, neig [...]&#39; */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = &#39;separator&#39; in options ? options.separator : separator; length = &#39;length&#39; in options ? toInteger(options.length) : length; omission = &#39;omission&#39; in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length &gt;= strLength) { return string; } var end = length - stringSize(omission); if (end &lt; 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join(&#39;&#39;) : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + &#39;g&#39;); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index &gt; -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of_.escape; this method converts the HTML entities *&amp;,&lt;,&gt;,&quot;, and&#39;instringto * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=&#39;&#39;] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape(&#39;fred, barney, &amp;amp; pebbles&#39;); * // =&gt; &#39;fred, barney, &amp; pebbles&#39; */ function unescape(string) { string = toString(string); return (string &amp;&amp; reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Convertsstring, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase(&#39;--foo-bar&#39;); * // =&gt; &#39;FOO BAR&#39; * * _.upperCase(&#39;fooBar&#39;); * // =&gt; &#39;FOO BAR&#39; * * _.upperCase(&#39;__foo_bar__&#39;); * // =&gt; &#39;FOO BAR&#39; */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? &#39; &#39; : &#39;&#39;) + word.toUpperCase(); }); /** * Converts the first character ofstringto upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst(&#39;fred&#39;); * // =&gt; &#39;Fred&#39; * * _.upperFirst(&#39;FRED&#39;); * // =&gt; &#39;FRED&#39; */ var upperFirst = createCaseFirst(&#39;toUpperCase&#39;); /** * Splitsstringinto an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=&#39;&#39;] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like_.map. * @returns {Array} Returns the words ofstring. * @example * * _.words(&#39;fred, barney, &amp; pebbles&#39;); * // =&gt; [&#39;fred&#39;, &#39;barney&#39;, &#39;pebbles&#39;] * * _.words(&#39;fred, barney, &amp; pebbles&#39;, /[^, ]+/g); * // =&gt; [&#39;fred&#39;, &#39;barney&#39;, &#39;&amp;&#39;, &#39;pebbles&#39;] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invokefunc, returning either the result or the caught error * object. Any additional arguments are provided tofuncwhen it&#39;s invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invokefuncwith. * @returns {*} Returns thefuncresult or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, &#39;&gt;_&gt;&#39;); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn&#39;t set the &quot;length&quot; property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returnsobject. * @example * * var view = { * &#39;label&#39;: &#39;docs&#39;, * &#39;click&#39;: function() { * console.log(&#39;clicked &#39; + this.label); * } * }; * * _.bindAll(view, [&#39;click&#39;]); * jQuery(element).on(&#39;click&#39;, view.click); * // =&gt; Logs &#39;clicked docs&#39; when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates overpairsand invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with thethisbinding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ &#39;a&#39;: 1 }), _.constant(&#39;matches A&#39;)], * [_.conforms({ &#39;b&#39;: _.isNumber }), _.constant(&#39;matches B&#39;)], * [_.stubTrue, _.constant(&#39;no match&#39;)] * ]); * * func({ &#39;a&#39;: 1, &#39;b&#39;: 2 }); * // =&gt; &#39;matches A&#39; * * func({ &#39;a&#39;: 0, &#39;b&#39;: 1 }); * // =&gt; &#39;matches B&#39; * * func({ &#39;a&#39;: &#39;1&#39;, &#39;b&#39;: &#39;2&#39; }); * // =&gt; &#39;no match&#39; */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != &#39;function&#39;) { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index &lt; length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties ofsourcewith * the corresponding property values of a given object, returningtrueif * all predicates return truthy, elsefalse. * * **Note:** The created function is equivalent to_.conformsTowith *sourcepartially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 2, &#39;b&#39;: 1 }, * { &#39;a&#39;: 1, &#39;b&#39;: 2 } * ]; * * _.filter(objects, _.conforms({ &#39;b&#39;: function(n) { return n &gt; 1; } })); * // =&gt; [{ &#39;a&#39;: 1, &#39;b&#39;: 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returnsvalue. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ &#39;a&#39;: 1 })); * * console.log(objects); * // =&gt; [{ &#39;a&#39;: 1 }, { &#39;a&#39;: 1 }] * * console.log(objects[0] === objects[1]); * // =&gt; true */ function constant(value) { return function() { return value; }; } /** * Checksvalueto determine whether a default value should be returned in * its place. ThedefaultValueis returned ifvalueisNaN,null, * orundefined. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // =&gt; 1 * * _.defaultTo(undefined, 10); * // =&gt; 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with thethisbinding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // =&gt; 9 */ var flow = createFlow(); /** * This method is like_.flowexcept that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // =&gt; 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returnsvalue. * @example * * var object = { &#39;a&#39;: 1 }; * * console.log(_.identity(object) === object); * // =&gt; true */ function identity(value) { return value; } /** * Creates a function that invokesfuncwith the arguments of the created * function. Iffuncis a property name, the created function returns the * property value for a given element. Iffuncis an array or object, the * created function returnstruefor elements that contain the equivalent * source properties, otherwise it returnsfalse. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }, * { &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40, &#39;active&#39;: false } * ]; * * // The_.matchesiteratee shorthand. * _.filter(users, _.iteratee({ &#39;user&#39;: &#39;barney&#39;, &#39;active&#39;: true })); * // =&gt; [{ &#39;user&#39;: &#39;barney&#39;, &#39;age&#39;: 36, &#39;active&#39;: true }] * * // The_.matchesPropertyiteratee shorthand. * _.filter(users, _.iteratee([&#39;user&#39;, &#39;fred&#39;])); * // =&gt; [{ &#39;user&#39;: &#39;fred&#39;, &#39;age&#39;: 40 }] * * // The_.propertyiteratee shorthand. * _.map(users, _.iteratee(&#39;user&#39;)); * // =&gt; [&#39;barney&#39;, &#39;fred&#39;] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter([&#39;abc&#39;, &#39;def&#39;], /ef/); * // =&gt; [&#39;def&#39;] */ function iteratee(func) { return baseIteratee(typeof func == &#39;function&#39; ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object andsource, returningtrueif the given object has equivalent * property values, elsefalse. * * **Note:** The created function is equivalent to.isMatchwithsource* partially applied. * * Partial comparisons will match empty array and empty objectsource* values against any array or object value, respectively. See.isEqual* for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 }, * { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } * ]; * * _.filter(objects, _.matches({ &#39;a&#39;: 4, &#39;c&#39;: 6 })); * // =&gt; [{ &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value atpathof a given object tosrcValue, returningtrueif the * object value is equivalent, elsefalse. * * **Note:** Partial comparisons will match empty array and empty object *srcValuevalues against any array or object value, respectively. See *_.isEqualfor a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3 }, * { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } * ]; * * _.find(objects, _.matchesProperty(&#39;a&#39;, 4)); * // =&gt; { &#39;a&#39;: 4, &#39;b&#39;: 5, &#39;c&#39;: 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method atpathof a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { &#39;a&#39;: { &#39;b&#39;: _.constant(2) } }, * { &#39;a&#39;: { &#39;b&#39;: _.constant(1) } } * ]; * * _.map(objects, _.method(&#39;a.b&#39;)); * // =&gt; [2, 1] * * _.map(objects, _.method([&#39;a&#39;, &#39;b&#39;])); * // =&gt; [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of_.method; this method creates a function that invokes * the method at a given path ofobject. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { &#39;a&#39;: array, &#39;b&#39;: array, &#39;c&#39;: array }; * * _.map([&#39;a[2]&#39;, &#39;c[0]&#39;], _.methodOf(object)); * // =&gt; [2, 0] * * _.map([[&#39;a&#39;, &#39;2&#39;], [&#39;c&#39;, &#39;0&#39;]], _.methodOf(object)); * // =&gt; [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. Ifobjectis a function, then methods * are added to its prototype as well. * * **Note:** Use_.runInContextto create a pristinelodashfunction to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returnsobject. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ &#39;vowels&#39;: vowels }); * _.vowels(&#39;fred&#39;); * // =&gt; [&#39;e&#39;] * * _(&#39;fred&#39;).vowels().value(); * // =&gt; [&#39;e&#39;] * * _.mixin({ &#39;vowels&#39;: vowels }, { &#39;chain&#39;: false }); * _(&#39;fred&#39;).vowels(); * // =&gt; [&#39;e&#39;] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null &amp;&amp; !(isObject(source) &amp;&amp; (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) &amp;&amp; &#39;chain&#39; in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ &#39;func&#39;: func, &#39;args&#39;: arguments, &#39;thisArg&#39;: object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the_variable to its previous value and returns a reference to * thelodashfunction. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns thelodashfunction. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returnsundefined. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // =&gt; [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at indexn. Ifnis negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; &#39;b&#39; * * var func = _.nthArg(-2); * func(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); * // =&gt; &#39;c&#39; */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokesiterateeswith the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // =&gt; [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of thepredicatesreturn * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func(&#39;1&#39;); * // =&gt; true * * func(null); * // =&gt; false * * func(NaN); * // =&gt; false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of thepredicatesreturn * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func(&#39;1&#39;); * // =&gt; true * * func(null); * // =&gt; true * * func(NaN); * // =&gt; false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value atpathof a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { &#39;a&#39;: { &#39;b&#39;: 2 } }, * { &#39;a&#39;: { &#39;b&#39;: 1 } } * ]; * * _.map(objects, _.property(&#39;a.b&#39;)); * // =&gt; [2, 1] * * _.map(_.sortBy(objects, _.property([&#39;a&#39;, &#39;b&#39;])), &#39;a.b&#39;); * // =&gt; [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of_.property; this method creates a function that returns * the value at a given path ofobject. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { &#39;a&#39;: array, &#39;b&#39;: array, &#39;c&#39;: array }; * * _.map([&#39;a[2]&#39;, &#39;c[0]&#39;], _.propertyOf(object)); * // =&gt; [2, 0] * * _.map([[&#39;a&#39;, &#39;2&#39;], [&#39;c&#39;, &#39;0&#39;]], _.propertyOf(object)); * // =&gt; [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from *startup to, but not including,end. A step of-1is used if a negative *startis specified without anendorstep. Ifendis not specified, * it&#39;s set tostartwithstartthen set to0. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // =&gt; [0, 1, 2, 3] * * _.range(-4); * // =&gt; [0, -1, -2, -3] * * _.range(1, 5); * // =&gt; [1, 2, 3, 4] * * _.range(0, 20, 5); * // =&gt; [0, 5, 10, 15] * * _.range(0, -4, -1); * // =&gt; [0, -1, -2, -3] * * _.range(1, 4, 0); * // =&gt; [1, 1, 1] * * _.range(0); * // =&gt; [] */ var range = createRange(); /** * This method is like_.rangeexcept that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // =&gt; [3, 2, 1, 0] * * _.rangeRight(-4); * // =&gt; [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // =&gt; [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // =&gt; [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // =&gt; [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // =&gt; [1, 1, 1] * * _.rangeRight(0); * // =&gt; [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // =&gt; [[], []] * * console.log(arrays[0] === arrays[1]); * // =&gt; false */ function stubArray() { return []; } /** * This method returnsfalse. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returnsfalse. * @example * * _.times(2, _.stubFalse); * // =&gt; [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // =&gt; [{}, {}] * * console.log(objects[0] === objects[1]); * // =&gt; false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // =&gt; [&#39;&#39;, &#39;&#39;] */ function stubString() { return &#39;&#39;; } /** * This method returnstrue. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returnstrue. * @example * * _.times(2, _.stubTrue); * // =&gt; [true, true] */ function stubTrue() { return true; } /** * Invokes the iterateentimes, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invokeiteratee. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // =&gt; [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;] * * _.times(4, _.constant(0)); * // =&gt; [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n &lt; 1 || n &gt; MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index &lt; n) { iteratee(index); } return result; } /** * Convertsvalueto a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath(&#39;a.b.c&#39;); * // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] * * _.toPath(&#39;a[0].b.c&#39;); * // =&gt; [&#39;a&#39;, &#39;0&#39;, &#39;b&#39;, &#39;c&#39;] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. Ifprefixis given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=&#39;&#39;] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId(&#39;contact_&#39;); * // =&gt; &#39;contact_104&#39; * * _.uniqueId(); * // =&gt; &#39;105&#39; */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // =&gt; 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computesnumberrounded up toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // =&gt; 5 * * _.ceil(6.004, 2); * // =&gt; 6.01 * * _.ceil(6040, -2); * // =&gt; 6100 */ var ceil = createRound(&#39;ceil&#39;); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // =&gt; 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computesnumberrounded down toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // =&gt; 4 * * _.floor(0.046, 2); * // =&gt; 0.04 * * _.floor(4060, -2); * // =&gt; 4000 */ var floor = createRound(&#39;floor&#39;); /** * Computes the maximum value ofarray. Ifarrayis empty or falsey, *undefinedis returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // =&gt; 8 * * _.max([]); * // =&gt; undefined */ function max(array) { return (array &amp;&amp; array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like_.maxexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ &#39;n&#39;: 1 }, { &#39;n&#39;: 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // =&gt; { &#39;n&#39;: 2 } * * // The_.propertyiteratee shorthand. * _.maxBy(objects, &#39;n&#39;); * // =&gt; { &#39;n&#39;: 2 } */ function maxBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values inarray. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // =&gt; 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like_.meanexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ &#39;n&#39;: 4 }, { &#39;n&#39;: 2 }, { &#39;n&#39;: 8 }, { &#39;n&#39;: 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // =&gt; 5 * * // The_.propertyiteratee shorthand. * _.meanBy(objects, &#39;n&#39;); * // =&gt; 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value ofarray. Ifarrayis empty or falsey, *undefinedis returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // =&gt; 2 * * _.min([]); * // =&gt; undefined */ function min(array) { return (array &amp;&amp; array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like_.minexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ &#39;n&#39;: 1 }, { &#39;n&#39;: 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // =&gt; { &#39;n&#39;: 1 } * * // The_.propertyiteratee shorthand. * _.minBy(objects, &#39;n&#39;); * // =&gt; { &#39;n&#39;: 1 } */ function minBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // =&gt; 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computesnumberrounded toprecision. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // =&gt; 4 * * _.round(4.006, 2); * // =&gt; 4.01 * * _.round(4060, -2); * // =&gt; 4100 */ var round = createRound(&#39;round&#39;); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // =&gt; 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values inarray. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // =&gt; 20 */ function sum(array) { return (array &amp;&amp; array.length) ? baseSum(array, identity) : 0; } /** * This method is like_.sumexcept that it acceptsiterateewhich is * invoked for each element inarrayto generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ &#39;n&#39;: 4 }, { &#39;n&#39;: 2 }, { &#39;n&#39;: 8 }, { &#39;n&#39;: 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // =&gt; 20 * * // The_.propertyiteratee shorthand. * _.sumBy(objects, &#39;n&#39;); * // =&gt; 20 */ function sumBy(array, iteratee) { return (array &amp;&amp; array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods tolodash.prototype. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { &#39;chain&#39;: false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach([&#39;bind&#39;, &#39;bindKey&#39;, &#39;curry&#39;, &#39;curryRight&#39;, &#39;partial&#39;, &#39;partialRight&#39;], function(methodName) { lodash[methodName].placeholder = lodash; }); // AddLazyWrappermethods for.dropand.takevariants. arrayEach([&#39;drop&#39;, &#39;take&#39;], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ &amp;&amp; !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ &#39;size&#39;: nativeMin(n, MAX_ARRAY_LENGTH), &#39;type&#39;: methodName + (result.__dir__ &lt; 0 ? &#39;Right&#39; : &#39;&#39;) }); } return result; }; LazyWrapper.prototype[methodName + &#39;Right&#39;] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // AddLazyWrappermethods that accept aniterateevalue. arrayEach([&#39;filter&#39;, &#39;map&#39;, &#39;takeWhile&#39;], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ &#39;iteratee&#39;: getIteratee(iteratee, 3), &#39;type&#39;: type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // AddLazyWrappermethods for.headand.last. arrayEach([&#39;head&#39;, &#39;last&#39;], function(methodName, index) { var takeName = &#39;take&#39; + (index ? &#39;Right&#39; : &#39;&#39;); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // AddLazyWrappermethods for.initialand.tail. arrayEach([&#39;initial&#39;, &#39;tail&#39;], function(methodName, index) { var dropName = &#39;drop&#39; + (index ? &#39;&#39; : &#39;Right&#39;); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == &#39;function&#39;) { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ &amp;&amp; (start &gt; 0 || end &lt; 0)) { return new LazyWrapper(result); } if (start &lt; 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end &lt; 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // AddLazyWrappermethods tolodash.prototype. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? (&#39;take&#39; + (methodName == &#39;last&#39; ? &#39;Right&#39; : &#39;&#39;)) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker &amp;&amp; chainAll) ? result[0] : result; }; if (useLazy &amp;&amp; checkIteratee &amp;&amp; typeof iteratee == &#39;function&#39; &amp;&amp; iteratee.length != 1) { // Avoid lazy use if the iteratee has a &quot;length&quot; value other than1. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped &amp;&amp; !chainAll, onlyLazy = isLazy &amp;&amp; !isHybrid; if (!retUnwrapped &amp;&amp; useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ &#39;func&#39;: thru, &#39;args&#39;: [interceptor], &#39;thisArg&#39;: undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped &amp;&amp; onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // AddArraymethods tolodash.prototype. arrayEach([&#39;pop&#39;, &#39;push&#39;, &#39;shift&#39;, &#39;sort&#39;, &#39;splice&#39;, &#39;unshift&#39;], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? &#39;tap&#39; : &#39;thru&#39;, retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped &amp;&amp; !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + &#39;&#39;), names = realNames[key] || (realNames[key] = []); names.push({ &#39;name&#39;: methodName, &#39;func&#39;: lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ &#39;name&#39;: &#39;wrapper&#39;, &#39;func&#39;: undefined }]; // Add methods toLazyWrapper. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to thelodashwrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use.noConflict` to remove Lodash from the global object. root. = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the “underscore” module. !(WEBPACK_AMD_DEFINE_RESULT = function() { return _; }.call(exports, webpack_require, exports, module), WEBPACK_AMD_DEFINE_RESULT !== undefined &amp;&amp; (module.exports = WEBPACK_AMD_DEFINE_RESULT)); } // Check for exports after define in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = ; // Export for CommonJS support. freeExports. = ; } else { // Export to the global object. root. = _; } }.call(this)); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }()), webpack_require(5)(module)))// }),/ 5 /// (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; }// }),/ 6 /// (function(module, exports, webpack_require) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arrSymbol.iterator, _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[“return”]) _i“return”; } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(“Invalid attempt to destructure non-iterable instance”); } }; }(); var _d2 = webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : ‘Prediction probabilities’; _classCallCheck(this, PredictProba); var width = parseInt(svg.style(‘width’)); this.names = class_names; this.names.push(‘Other’); if (class_names.length &lt; 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === ‘’ ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars (bar_height + space_between_bars) + bar_yshift; svg.style(‘height’, this.svg_height + ‘px’); var this_object = this; if (title !== ‘’) { svg.append(‘text’).text(title).attr(‘x’, 20).attr(‘y’, 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) i + bar_yshift; }; var bar = svg.append(“g”); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)Symbol.iterator, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == ‘Other’ &amp;&amp; this.names.length &gt; 20) { color = ‘#5F9EA0’; } var rect = bar.append(“rect”); rect.attr(“x”, bar_x).attr(“y”, bar_y(i)).attr(“height”, bar_height).attr(“width”, x_scale(data[i])).style(“fill”, color); bar.append(“rect”).attr(“x”, bar_x).attr(“y”, bar_y(i)).attr(“height”, bar_height).attr(“width”, bar_width - 1).attr(“fill-opacity”, 0).attr(“stroke”, “black”); var text = bar.append(“text”); text.classed(“prob_text”, true); text.attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”); text = bar.append(“text”); text.attr(“x”, bar_x + x_scale(data[i]) + 5).attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”).text(data[i].toFixed(2)); text = bar.append(“text”); text.attr(“x”, bar_x - 10).attr(“y”, bar_y(i) + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(names[i]); while (text.node().getBBox()[‘width’] + 1 &gt; class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + ‘…’); if (cur_text === ‘’) { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length &lt;= 6) { return [class_names, predict_proba]; } var class_dict = (0, _lodash.range)(predict_proba.length).map(function (i) { return { ‘name’: class_names[i], ‘prob’: predict_proba[i], ‘i’: i }; }); var sorted = (0, _lodash.sortBy)(class_dict, function (d) { return -d.prob; }); var other = new Set(); (0, _lodash.range)(4, sorted.length).map(function (d) { return other.add(sorted[d].name); }); var other_prob = 0; var ret_probs = []; var ret_names = []; var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = (0, _lodash.range)(sorted.length)Symbol.iterator, _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var d = _step2.value; if (other.has(sorted[d].name)) { other_prob += sorted[d].prob; } else { ret_probs.push(sorted[d].prob); ret_names.push(sorted[d].name); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } ; ret_names.push(“Other”); ret_probs.push(other_prob); return [ret_names, ret_probs]; }; return PredictProba; }(); exports.default = PredictProba;// }),/ 7 /// (function(module, exports, webpack_require__) { ‘use strict’; Object.defineProperty(exports, “esModule”, { value: true }); var _d = webpack_require__(2); var _d2 = _interopRequireDefault(_d); var _lodash = webpack_require(4); function _interopRequireDefault(obj) { return obj &amp;&amp; obj.esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(“Cannot call a class as a function”); } } var PredictedValue = // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictedValue(svg, predicted_value, min_value, max_value) { var title = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : ‘Predicted value’; var log_coords = arguments.length &gt; 5 &amp;&amp; arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style(‘width’)); this.color = _d2.default.scale.category10(); this.color(‘predicted_value’); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 num_digits; var corner_padding = 5.5 num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width 2 - corner_padding 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === ‘’ ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== ‘’) { svg.append(‘text’).text(title).attr(‘x’, 20).attr(‘y’, 20); } var bar_y = bar_yshift; var bar = svg.append(“g”); //filled in bar representing predicted value in range var rect = bar.append(“rect”); rect.attr(“x”, bar_x).attr(“y”, bar_y).attr(“height”, bar_height).attr(“width”, x_scale(width_proportion)).style(“fill”, this.color); //empty box representing range bar.append(“rect”).attr(“x”, bar_x).attr(“y”, bar_y).attr(“height”, bar_height).attr(“width”, x_scale(1)).attr(“fill-opacity”, 0).attr(“stroke”, “black”); var text = bar.append(“text”); text.classed(“prob_text”, true); text.attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).style(“font”, “14px tahoma, sans-serif”); //text for min value text = bar.append(“text”); text.attr(“x”, bar_x - corner_padding).attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append(“text”); text.attr(“x”, bar_x - corner_padding).attr(“y”, bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr(“fill”, “black”).attr(“text-anchor”, “end”).style(“font”, “14px tahoma, sans-serif”).text(“(min)”); //text for predicted value // console.log(‘bar height: ‘ + bar_height) text = bar.append(“text”); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr(“x”, bar_x + x_scale(width_proportion)).attr(“y”, bar_y + bar_height + v_adjust_predicted_value_text).attr(“fill”, “black”).attr(“text-anchor”, “middle”).style(“font”, “14px tahoma, sans-serif”); //text for max value text = bar.append(“text”); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr(“x”, bar_x + bar_width + corner_padding).attr(“y”, bar_y + bar_height - 3).attr(“fill”, “black”).attr(“text-anchor”, “begin”).style(“font”, “14px tahoma, sans-serif”); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append(“text”); text.attr(“x”, bar_x + bar_width + corner_padding).attr(“y”, bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr(“fill”, “black”).attr(“text-anchor”, “begin”).style(“font”, “14px tahoma, sans-serif”).text(“(max)”); //readjust svg size // let svg_width = width + 1 h_adjust; // svg.style(‘width’, svg_width + ‘px’); this.svg_height = n_bars bar_height + bar_yshift + 2 text.node().getBBox().height + 10; svg.style(‘height’, this.svg_height + ‘px’); if (log_coords) { console.log(“svg width: “ + svg_width); console.log(“svg height: “ + this.svg_height); console.log(“bar_y: “ + bar_y); console.log(“bar_x: “ + bar_x); console.log(“Min value: “ + min_value); console.log(“Max value: “ + max_value); console.log(“Pred value: “ + predicted_value); } }; exports.default = PredictedValue;/**/ }),/ 8 //***/ (function(module, exports, webpack_require__) { / WEBPACK VAR INJECTION /(function(global) {“use strict”; webpack_require(9); webpack_require(335); webpack_require(336); if (global._babelPolyfill) { throw new Error(“only one instance of babel-polyfill is allowed”); } global._babelPolyfill = true; var DEFINE_PROPERTY = “defineProperty”; function define(O, key, value) { O[key] || ObjectDEFINE_PROPERTY; } define(String.prototype, “padLeft”, “”.padStart); define(String.prototype, “padRight”, “”.padEnd); “pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill”.split(“,”).forEach(function (key) { [][key] &amp;&amp; define(Array, key, Function.call.bind([][key])); }); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))// }),/ 9 /// (function(module, exports, webpack_require) { webpack_require(10); webpack_require(59); webpack_require(60); webpack_require(61); webpack_require(62); webpack_require(64); webpack_require(67); webpack_require(68); webpack_require(69); webpack_require(70); webpack_require(71); webpack_require(72); webpack_require(73); webpack_require(74); webpack_require(75); webpack_require(77); webpack_require(79); webpack_require(81); webpack_require(83); webpack_require(86); webpack_require(87); webpack_require(88); webpack_require(92); webpack_require(94); webpack_require(96); webpack_require(99); webpack_require(100); webpack_require(101); webpack_require(102); webpack_require(104); webpack_require(105); webpack_require(106); webpack_require(107); webpack_require(108); webpack_require(109); webpack_require(110); webpack_require(112); webpack_require(113); webpack_require(114); webpack_require(116); webpack_require(117); webpack_require(118); webpack_require(120); webpack_require(122); webpack_require(123); webpack_require(124); webpack_require(125); webpack_require(126); webpack_require(127); webpack_require(128); webpack_require(129); webpack_require(130); webpack_require(131); webpack_require(132); webpack_require(133); webpack_require(134); webpack_require(139); webpack_require(140); webpack_require(144); webpack_require(145); webpack_require(146); webpack_require(147); webpack_require(149); webpack_require(150); webpack_require(151); webpack_require(152); webpack_require(153); webpack_require(154); webpack_require(155); webpack_require(156); webpack_require(157); webpack_require(158); webpack_require(159); webpack_require(160); webpack_require(161); webpack_require(162); webpack_require(163); webpack_require(165); webpack_require(166); webpack_require(168); webpack_require(169); webpack_require(175); webpack_require(176); webpack_require(178); webpack_require(179); webpack_require(180); webpack_require(184); webpack_require(185); webpack_require(186); webpack_require(187); webpack_require(188); webpack_require(190); webpack_require(191); webpack_require(192); webpack_require(193); webpack_require(196); webpack_require(198); webpack_require(199); webpack_require(200); webpack_require(202); webpack_require(204); webpack_require(206); webpack_require(208); webpack_require(209); webpack_require(210); webpack_require(214); webpack_require(215); webpack_require(216); webpack_require(218); webpack_require(228); webpack_require(232); webpack_require(233); webpack_require(235); webpack_require(236); webpack_require(240); webpack_require(241); webpack_require(243); webpack_require(244); webpack_require(245); webpack_require(246); webpack_require(247); webpack_require(248); webpack_require(249); webpack_require(250); webpack_require(251); webpack_require(252); webpack_require(253); webpack_require(254); webpack_require(255); webpack_require(256); webpack_require(257); webpack_require(258); webpack_require(259); webpack_require(260); webpack_require(261); webpack_require(263); webpack_require(264); webpack_require(265); webpack_require(266); webpack_require(267); webpack_require(269); webpack_require(270); webpack_require(271); webpack_require(273); webpack_require(274); webpack_require(275); webpack_require(276); webpack_require(277); webpack_require(278); webpack_require(279); webpack_require(280); webpack_require(282); webpack_require(283); webpack_require(285); webpack_require(286); webpack_require(287); webpack_require(288); webpack_require(291); webpack_require(292); webpack_require(294); webpack_require(295); webpack_require(296); webpack_require(297); webpack_require(299); webpack_require(300); webpack_require(301); webpack_require(302); webpack_require(303); webpack_require(304); webpack_require(305); webpack_require(306); webpack_require(307); webpack_require(308); webpack_require(310); webpack_require(311); webpack_require(312); webpack_require(313); webpack_require(314); webpack_require(315); webpack_require(316); webpack_require(317); webpack_require(318); webpack_require(319); webpack_require(320); webpack_require(322); webpack_require(323); webpack_require(324); webpack_require(325); webpack_require(326); webpack_require(327); webpack_require(328); webpack_require(329); webpack_require(330); webpack_require(331); webpack_require(332); webpack_require(333); webpack_require(334); module.exports = webpack_require(16);// }),/ 10 /// (function(module, exports, webpack_require) { ‘use strict’; // ECMAScript 6 symbols shim var global = webpack_require(11); var has = webpack_require(12); var DESCRIPTORS = webpack_require(13); var $export = webpack_require(15); var redefine = webpack_require(25); var META = webpack_require(32).KEY; var $fails = webpack_require(14); var shared = webpack_require(28); var setToStringTag = webpack_require(33); var uid = webpack_require(26); var wks = webpack_require(34); var wksExt = webpack_require(35); var wksDefine = webpack_require(36); var enumKeys = webpack_require(37); var isArray = webpack_require(52); var anObject = webpack_require(19); var isObject = webpack_require(20); var toIObject = webpack_require(40); var toPrimitive = webpack_require(23); var createDesc = webpack_require(24); var _create = webpack_require(53); var gOPNExt = webpack_require(56); var $GOPD = webpack_require(58); var $DP = webpack_require(18); var $keys = webpack_require(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON &amp;&amp; $JSON.stringify; var PROTOTYPE = ‘prototype’; var HIDDEN = wks(‘_hidden’); var TO_PRIMITIVE = wks(‘toPrimitive’); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared(‘symbol-registry’); var AllSymbols = shared(‘symbols’); var OPSymbols = shared(‘op-symbols’); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == ‘function’; var QObject = global.QObject; // Don’t use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS &amp;&amp; $fails(function () { return _create(dP({}, ‘a’, { get: function () { return dP(this, ‘a’, { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc &amp;&amp; it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE &amp;&amp; typeof $Symbol.iterator == ‘symbol’ ? function (it) { return typeof it == ‘symbol’; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) &amp;&amp; it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l &gt; i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto &amp;&amp; has(AllSymbols, key) &amp;&amp; !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) &amp;&amp; this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto &amp;&amp; has(AllSymbols, key) &amp;&amp; !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D &amp;&amp; has(AllSymbols, key) &amp;&amp; !(has(it, HIDDEN) &amp;&amp; it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length &gt; i) { if (!has(AllSymbols, key = names[i++]) &amp;&amp; key != HIDDEN &amp;&amp; key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length &gt; i) { if (has(AllSymbols, key = names[i++]) &amp;&amp; (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError(‘Symbol is not a constructor!’); var tag = uid(arguments.length &gt; 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) &amp;&amp; has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS &amp;&amp; setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], ‘toString’, function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; webpack_require(57).f = gOPNExt.f = $getOwnPropertyNames; webpack_require(51).f = $propertyIsEnumerable; webpack_require(50).f = $getOwnPropertySymbols; if (DESCRIPTORS &amp;&amp; !webpack_require(29)) { redefine(ObjectProto, ‘propertyIsEnumerable’, $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 ‘hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables’ ).split(‘,’), j = 0; es6Symbols.length &gt; j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length &gt; k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F !USE_NATIVE, ‘Symbol’, { // 19.4.2.1 Symbol.for(key) ‘for’: function (key) { return has(SymbolRegistry, key += ‘’) ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ‘ is not a symbol!’); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F !USE_NATIVE, ‘Object’, { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON &amp;&amp; $export($export.S + $export.F (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != ‘[null]’ || _stringify({ a: S }) != ‘{}’ || _stringify(Object(S)) != ‘{}’; })), ‘JSON’, { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length &gt; i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) &amp;&amp; it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == ‘function’) value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype@@toPrimitive $Symbol[PROTOTYPE][TO_PRIMITIVE] || webpack_require(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, ‘Symbol’); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, ‘Math’, true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, ‘JSON’, true);// }),/ 11 /// (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != ‘undefined’ &amp;&amp; window.Math == Math ? window : typeof self != ‘undefined’ &amp;&amp; self.Math == Math ? self // eslint-disable-next-line no-new-func : Function(‘return this’)(); if (typeof g == ‘number’) g = global; // eslint-disable-line no-undef// }),/ 12 /// (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); };// }),/ 13 /// (function(module, exports, webpack_require) { // Thank’s IE8 for his funny defineProperty module.exports = !webpack_require(14)(function () { return Object.defineProperty({}, ‘a’, { get: function () { return 7; } }).a != 7; });// }),/ 14 /// (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } };// }),/ 15 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var core = webpack_require(16); var hide = webpack_require(17); var redefine = webpack_require(25); var ctx = webpack_require(30); var PROTOTYPE = ‘prototype’; var $export = function (type, name, source) { var IS_FORCED = type &amp; $export.F; var IS_GLOBAL = type &amp; $export.G; var IS_STATIC = type &amp; $export.S; var IS_PROTO = type &amp; $export.P; var IS_BIND = type &amp; $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED &amp;&amp; target &amp;&amp; target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND &amp;&amp; own ? ctx(out, global) : IS_PROTO &amp;&amp; typeof out == ‘function’ ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type &amp; $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO &amp;&amp; expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for library module.exports = $export;// }),/ 16 /// (function(module, exports) { var core = module.exports = { version: ‘2.6.5’ }; if (typeof e == ‘number’) e = core; // eslint-disable-line no-undef// }),/ 17 /// (function(module, exports, webpack_require) { var dP = webpack_require(18); var createDesc = webpack_require(24); module.exports = webpack_require(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; };// }),/ 18 /// (function(module, exports, webpack_require) { var anObject = webpack_require(19); var IE8_DOM_DEFINE = webpack_require(21); var toPrimitive = webpack_require(23); var dP = Object.defineProperty; exports.f = webpack_require(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { / empty / } if (‘get’ in Attributes || ‘set’ in Attributes) throw TypeError(‘Accessors not supported!’); if (‘value’ in Attributes) O[P] = Attributes.value; return O; };// }),/ 19 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ‘ is not an object!’); return it; };// }),/ 20 /// (function(module, exports) { module.exports = function (it) { return typeof it === ‘object’ ? it !== null : typeof it === ‘function’; };// }),/ 21 /// (function(module, exports, webpack_require) { module.exports = !webpack_require(13) &amp;&amp; !webpack_require(14)(function () { return Object.defineProperty(webpack_require(22)(‘div’), ‘a’, { get: function () { return 7; } }).a != 7; });// }),/ 22 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var document = webpack_require(11).document; // typeof document.createElement is ‘object’ in old IE var is = isObject(document) &amp;&amp; isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; };// }),/ 23 /// (function(module, exports, webpack_require) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = webpack_require(20); // instead of the ES6 spec version, we didn’t implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S &amp;&amp; typeof (fn = it.toString) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; if (!S &amp;&amp; typeof (fn = it.toString) == ‘function’ &amp;&amp; !isObject(val = fn.call(it))) return val; throw TypeError(“Can’t convert object to primitive value”); };// }),/ 24 /// (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap &amp; 1), configurable: !(bitmap &amp; 2), writable: !(bitmap &amp; 4), value: value }; };// }),/ 25 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var hide = webpack_require(17); var has = webpack_require(12); var SRC = webpack_require(26)(‘src’); var $toString = webpack_require(27); var TO_STRING = ‘toString’; var TPL = (‘’ + $toString).split(TO_STRING); webpack_require(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == ‘function’; if (isFunction) has(val, ‘name’) || hide(val, ‘name’, key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? ‘’ + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == ‘function’ &amp;&amp; this[SRC] || $toString.call(this); });// }),/ 26 /// (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return ‘Symbol(‘.concat(key === undefined ? ‘’ : key, ‘)_’, (++id + px).toString(36)); };// }),/ 27 /// (function(module, exports, webpack_require) { module.exports = webpack_require(28)(‘native-function-to-string’, Function.toString);// }),/ 28 /// (function(module, exports, webpack_require) { var core = webpack_require(16); var global = webpack_require(11); var SHARED = ‘core-js_shared‘; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })(‘versions’, []).push({ version: core.version, mode: webpack_require(29) ? ‘pure’ : ‘global’, copyright: ‘© 2019 Denis Pushkarev (zloirock.ru)’ });// }),/ 29 /// (function(module, exports) { module.exports = false;// }),/ 30 /// (function(module, exports, webpack_require) { // optional / simple context binding var aFunction = webpack_require(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/ …args /) { return fn.apply(that, arguments); }; };// }),/ 31 /// (function(module, exports) { module.exports = function (it) { if (typeof it != ‘function’) throw TypeError(it + ‘ is not a function!’); return it; };// }),/ 32 /// (function(module, exports, webpack_require) { var META = webpack_require(26)(‘meta’); var isObject = webpack_require(20); var has = webpack_require(12); var setDesc = webpack_require(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !webpack_require(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: ‘O’ + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == ‘symbol’ ? it : (typeof it == ‘string’ ? ‘S’ : ‘P’) + it; if (!has(it, META)) { // can’t set metadata to uncaught frozen object if (!isExtensible(it)) return ‘F’; // not necessary to add metadata if (!create) return ‘E’; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can’t set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE &amp;&amp; meta.NEED &amp;&amp; isExtensible(it) &amp;&amp; !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze };// }),/ 33 /// (function(module, exports, webpack_require) { var def = webpack_require(18).f; var has = webpack_require(12); var TAG = webpack_require(34)(‘toStringTag’); module.exports = function (it, tag, stat) { if (it &amp;&amp; !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); };// }),/ 34 /// (function(module, exports, webpack_require) { var store = webpack_require(28)(‘wks’); var uid = webpack_require(26); var Symbol = webpack_require(11).Symbol; var USE_SYMBOL = typeof Symbol == ‘function’; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL &amp;&amp; Symbol[name] || (USE_SYMBOL ? Symbol : uid)(‘Symbol.’ + name)); }; $exports.store = store;// }),/ 35 /// (function(module, exports, webpack_require) { exports.f = webpack_require(34);// }),/ 36 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var core = webpack_require(16); var LIBRARY = webpack_require(29); var wksExt = webpack_require(35); var defineProperty = webpack_require(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != ‘_’ &amp;&amp; !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); };// }),/ 37 /// (function(module, exports, webpack_require) { // all enumerable object keys, includes symbols var getKeys = webpack_require(38); var gOPS = webpack_require(50); var pIE = webpack_require(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length &gt; i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; };// }),/ 38 /// (function(module, exports, webpack_require) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = webpack_require(39); var enumBugKeys = webpack_require(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); };// }),/ 39 /// (function(module, exports, webpack_require) { var has = webpack_require(12); var toIObject = webpack_require(40); var arrayIndexOf = webpack_require(44)(false); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) &amp;&amp; result.push(key); // Don’t enum bug &amp; hidden keys while (names.length &gt; i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; };// }),/ 40 /// (function(module, exports, webpack_require) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = webpack_require(41); var defined = webpack_require(43); module.exports = function (it) { return IObject(defined(it)); };// }),/ 41 /// (function(module, exports, webpack_require) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = webpack_require(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object(‘z’).propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == ‘String’ ? it.split(‘’) : Object(it); };// }),/ 42 /// (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); };// }),/ 43 /// (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError(“Can’t call method on “ + it); return it; };// }),/ 44 /// (function(module, exports, webpack_require) { // false -&gt; Array#indexOf // true -&gt; Array#includes var toIObject = webpack_require(40); var toLength = webpack_require(45); var toAbsoluteIndex = webpack_require(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES &amp;&amp; el != el) while (length &gt; index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length &gt; index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES &amp;&amp; -1; }; };// }),/ 45 /// (function(module, exports, webpack_require) { // 7.1.15 ToLength var toInteger = webpack_require(46); var min = Math.min; module.exports = function (it) { return it &gt; 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 };// }),/ 46 /// (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it &gt; 0 ? floor : ceil)(it); };// }),/ 47 /// (function(module, exports, webpack_require) { var toInteger = webpack_require(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index &lt; 0 ? max(index + length, 0) : min(index, length); };// }),/ 48 /// (function(module, exports, webpack_require) { var shared = webpack_require(28)(‘keys’); var uid = webpack_require(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); };// }),/ 49 /// (function(module, exports) { // IE 8- don’t enum bug keys module.exports = ( ‘constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf’ ).split(‘,’);// }),/ 50 /// (function(module, exports) { exports.f = Object.getOwnPropertySymbols;// }),/ 51 /// (function(module, exports) { exports.f = {}.propertyIsEnumerable;// }),/ 52 /// (function(module, exports, webpack_require) { // 7.2.2 IsArray(argument) var cof = webpack_require(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == ‘Array’; };// }),/ 53 /// (function(module, exports, webpack_require) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = webpack_require(19); var dPs = webpack_require(54); var enumBugKeys = webpack_require(49); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); var Empty = function () { / empty / }; var PROTOTYPE = ‘prototype’; // Create object with fake null prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = webpack_require(22)(‘iframe’); var i = enumBugKeys.length; var lt = ‘&lt;’; var gt = ‘&gt;’; var iframeDocument; iframe.style.display = ‘none’; webpack_require(55).appendChild(iframe); iframe.src = ‘javascript:’; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + ‘script’ + gt + ‘document.F=Object’ + lt + ‘/script’ + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i–) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add “proto“ for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); };// }),/ 54 /// (function(module, exports, webpack_require) { var dP = webpack_require(18); var anObject = webpack_require(19); var getKeys = webpack_require(38); module.exports = webpack_require(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length &gt; i) dP.f(O, P = keys[i++], Properties[P]); return O; };// }),/ 55 /// (function(module, exports, webpack_require) { var document = webpack_require(11).document; module.exports = document &amp;&amp; document.documentElement;// }),/ 56 /// (function(module, exports, webpack_require) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = webpack_require(40); var gOPN = webpack_require(57).f; var toString = {}.toString; var windowNames = typeof window == ‘object’ &amp;&amp; window &amp;&amp; Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames &amp;&amp; toString.call(it) == ‘[object Window]’ ? getWindowNames(it) : gOPN(toIObject(it)); };// }),/ 57 /// (function(module, exports, webpack_require) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = webpack_require(39); var hiddenKeys = webpack_require(49).concat(‘length’, ‘prototype’); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); };// }),/ 58 /// (function(module, exports, webpack_require) { var pIE = webpack_require(51); var createDesc = webpack_require(24); var toIObject = webpack_require(40); var toPrimitive = webpack_require(23); var has = webpack_require(12); var IE8_DOM_DEFINE = webpack_require(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = webpack_require(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { / empty / } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); };// }),/ 59 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, ‘Object’, { create: webpack_require(53) });// }),/ 60 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F !webpack_require(13), ‘Object’, { defineProperty: webpack_require(18).f });/**/ }),/ 61 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F !webpack_require(13), ‘Object’, { defineProperties: webpack_require(54) });/*/ }),/ 62 /// (function(module, exports, webpack_require) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = webpack_require(40); var $getOwnPropertyDescriptor = webpack_require(58).f; webpack_require(63)(‘getOwnPropertyDescriptor’, function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; });// }),/ 63 /// (function(module, exports, webpack_require) { // most Object methods by ES6 should accept primitives var $export = webpack_require(15); var core = webpack_require(16); var fails = webpack_require(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F fails(function () { fn(1); }), ‘Object’, exp); };/*/ }),/ 64 /// (function(module, exports, webpack_require) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = webpack_require(65); var $getPrototypeOf = webpack_require(66); webpack_require(63)(‘getPrototypeOf’, function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; });// }),/ 65 /// (function(module, exports, webpack_require) { // 7.1.13 ToObject(argument) var defined = webpack_require(43); module.exports = function (it) { return Object(defined(it)); };// }),/ 66 /// (function(module, exports, webpack_require) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = webpack_require(12); var toObject = webpack_require(65); var IE_PROTO = webpack_require(48)(‘IE_PROTO’); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == ‘function’ &amp;&amp; O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; };// }),/ 67 /// (function(module, exports, webpack_require) { // 19.1.2.14 Object.keys(O) var toObject = webpack_require(65); var $keys = webpack_require(38); webpack_require(63)(‘keys’, function () { return function keys(it) { return $keys(toObject(it)); }; });// }),/ 68 /// (function(module, exports, webpack_require) { // 19.1.2.7 Object.getOwnPropertyNames(O) webpack_require(63)(‘getOwnPropertyNames’, function () { return webpack_require(56).f; });// }),/ 69 /// (function(module, exports, webpack_require) { // 19.1.2.5 Object.freeze(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘freeze’, function ($freeze) { return function freeze(it) { return $freeze &amp;&amp; isObject(it) ? $freeze(meta(it)) : it; }; });// }),/ 70 /// (function(module, exports, webpack_require) { // 19.1.2.17 Object.seal(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘seal’, function ($seal) { return function seal(it) { return $seal &amp;&amp; isObject(it) ? $seal(meta(it)) : it; }; });// }),/ 71 /// (function(module, exports, webpack_require) { // 19.1.2.15 Object.preventExtensions(O) var isObject = webpack_require(20); var meta = webpack_require(32).onFreeze; webpack_require(63)(‘preventExtensions’, function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions &amp;&amp; isObject(it) ? $preventExtensions(meta(it)) : it; }; });// }),/ 72 /// (function(module, exports, webpack_require) { // 19.1.2.12 Object.isFrozen(O) var isObject = webpack_require(20); webpack_require(63)(‘isFrozen’, function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; });// }),/ 73 /// (function(module, exports, webpack_require) { // 19.1.2.13 Object.isSealed(O) var isObject = webpack_require(20); webpack_require(63)(‘isSealed’, function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; });// }),/ 74 /// (function(module, exports, webpack_require) { // 19.1.2.11 Object.isExtensible(O) var isObject = webpack_require(20); webpack_require(63)(‘isExtensible’, function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; });// }),/ 75 /// (function(module, exports, webpack_require) { // 19.1.3.1 Object.assign(target, source) var $export = webpack_require(15); $export($export.S + $export.F, ‘Object’, { assign: webpack_require(76) });// }),/ 76 /// (function(module, exports, webpack_require) { ‘use strict’; // 19.1.2.1 Object.assign(target, source, …) var getKeys = webpack_require(38); var gOPS = webpack_require(50); var pIE = webpack_require(51); var toObject = webpack_require(65); var IObject = webpack_require(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || webpack_require(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = ‘abcdefghijklmnopqrst’; A[S] = 7; K.split(‘’).forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join(‘’) != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen &gt; index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length &gt; j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign;// }),/ 77 /// (function(module, exports, webpack_require) { // 19.1.3.10 Object.is(value1, value2) var $export = webpack_require(15); $export($export.S, ‘Object’, { is: webpack_require(78) });// }),/ 78 /// (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x &amp;&amp; y != y; };// }),/ 79 /// (function(module, exports, webpack_require) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = webpack_require(15); $export($export.S, ‘Object’, { setPrototypeOf: webpack_require(80).set });// }),/ 80 /// (function(module, exports, webpack_require) { // Works with proto only. Old v8 can’t work with null proto objects. / eslint-disable no-proto / var isObject = webpack_require(20); var anObject = webpack_require(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) &amp;&amp; proto !== null) throw TypeError(proto + “: can’t set as prototype!”); }; module.exports = { set: Object.setPrototypeOf || (‘proto‘ in {} ? // eslint-disable-line function (test, buggy, set) { try { set = webpack_require(30)(Function.call, webpack_require(58).f(Object.prototype, ‘proto‘).set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.proto = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check };// }),/ 81 /// (function(module, exports, webpack_require) { ‘use strict’; // 19.1.3.6 Object.prototype.toString() var classof = webpack_require(82); var test = {}; test[webpack_require(34)(‘toStringTag’)] = ‘z’; if (test + ‘’ != ‘[object z]’) { webpack_require(25)(Object.prototype, ‘toString’, function toString() { return ‘[object ‘ + classof(this) + ‘]’; }, true); }// }),/ 82 /// (function(module, exports, webpack_require) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = webpack_require(42); var TAG = webpack_require(34)(‘toStringTag’); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == ‘Arguments’; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { / empty / } }; module.exports = function (it) { var O, T, B; return it === undefined ? ‘Undefined’ : it === null ? ‘Null’ // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == ‘string’ ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == ‘Object’ &amp;&amp; typeof O.callee == ‘function’ ? ‘Arguments’ : B; };// }),/ 83 /// (function(module, exports, webpack_require) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args…) var $export = webpack_require(15); $export($export.P, ‘Function’, { bind: webpack_require(84) });// }),/ 84 /// (function(module, exports, webpack_require) { ‘use strict’; var aFunction = webpack_require(31); var isObject = webpack_require(20); var invoke = webpack_require(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i &lt; len; i++) n[i] = ‘a[‘ + i + ‘]’; // eslint-disable-next-line no-new-func factories[len] = Function(‘F,a’, ‘return new F(‘ + n.join(‘,’) + ‘)’); } return factorieslen; }; module.exports = Function.bind || function bind(that / , …args /) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/ args… /) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; };// }),/ 85 /// (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); };// }),/ 86 /// (function(module, exports, webpack_require) { var dP = webpack_require(18).f; var FProto = Function.prototype; var nameRE = /^\sfunction ([^ (])/; var NAME = ‘name’; // 19.2.4.2 name NAME in FProto || webpack_require(13) &amp;&amp; dP(FProto, NAME, { configurable: true, get: function () { try { return (‘’ + this).match(nameRE)[1]; } catch (e) { return ‘’; } } });// }),/ 87 /// (function(module, exports, webpack_require) { ‘use strict’; var isObject = webpack_require(20); var getPrototypeOf = webpack_require(66); var HAS_INSTANCE = webpack_require(34)(‘hasInstance’); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype@@hasInstance if (!(HAS_INSTANCE in FunctionProto)) webpack_require(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != ‘function’ || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native @@hasInstance logic enough instanceof, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } });// }),/ 88 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseInt = webpack_require(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F (parseInt != $parseInt), { parseInt: $parseInt });/*/ }),/ 89 /// (function(module, exports, webpack_require) { var $parseInt = webpack_require(11).parseInt; var $trim = webpack_require(90).trim; var ws = webpack_require(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + ‘08’) !== 8 || $parseInt(ws + ‘0x16’) !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix &gt;&gt;&gt; 0) || (hex.test(string) ? 16 : 10)); } : $parseInt;// }),/ 90 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var defined = webpack_require(43); var fails = webpack_require(14); var spaces = webpack_require(91); var space = ‘[‘ + spaces + ‘]’; var non = ‘\u200b\u0085’; var ltrim = RegExp(‘^’ + space + space + ‘‘); var rtrim = RegExp(space + space + ‘$’); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spacesKEY || nonKEY != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F FORCE, ‘String’, exp); }; // 1 -&gt; String#trimLeft // 2 -&gt; String#trimRight // 3 -&gt; String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE &amp; 1) string = string.replace(ltrim, ‘’); if (TYPE &amp; 2) string = string.replace(rtrim, ‘’); return string; }; module.exports = exporter;/*/ }),/ 91 /// (function(module, exports) { module.exports = ‘\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003’ + ‘\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF’;// }),/ 92 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseFloat = webpack_require(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F (parseFloat != $parseFloat), { parseFloat: $parseFloat });/*/ }),/ 93 /// (function(module, exports, webpack_require) { var $parseFloat = webpack_require(11).parseFloat; var $trim = webpack_require(90).trim; module.exports = 1 / $parseFloat(webpack_require(91) + ‘-0’) !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 &amp;&amp; string.charAt(0) == ‘-‘ ? -0 : result; } : $parseFloat;// }),/ 94 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var has = webpack_require(12); var cof = webpack_require(42); var inheritIfRequired = webpack_require(95); var toPrimitive = webpack_require(23); var fails = webpack_require(14); var gOPN = webpack_require(57).f; var gOPD = webpack_require(58).f; var dP = webpack_require(18).f; var $trim = webpack_require(90).trim; var NUMBER = ‘Number’; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(webpack_require(53)(proto)) == NUMBER; var TRIM = ‘trim’ in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == ‘string’ &amp;&amp; it.length &gt; 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number(‘+0x1’) should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i &lt; l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code &lt; 48 || code &gt; maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(‘ 0o1’) || !$Number(‘0b1’) || $Number(‘+0x1’)) { $Number = function Number(value) { var it = arguments.length &lt; 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case &amp;&amp; (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = webpack_require(13) ? gOPN(Base) : ( // ES3: ‘MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,’ + // ES6 (in case, if modules with ES6 Number statics required before): ‘EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,’ + ‘MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger’ ).split(‘,’), j = 0, key; keys.length &gt; j; j++) { if (has(Base, key = keys[j]) &amp;&amp; !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; webpack_require(25)(global, NUMBER, $Number); }// }),/ 95 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var setPrototypeOf = webpack_require(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C &amp;&amp; typeof S == ‘function’ &amp;&amp; (P = S.prototype) !== C.prototype &amp;&amp; isObject(P) &amp;&amp; setPrototypeOf) { setPrototypeOf(that, P); } return that; };// }),/ 96 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toInteger = webpack_require(46); var aNumberValue = webpack_require(97); var repeat = webpack_require(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = ‘Number.toFixed: incorrect invocation!’; var ZERO = ‘0’; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i &lt; 6) { c2 += n data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (–i &gt;= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) 1e7; } }; var numToString = function () { var i = 6; var s = ‘’; while (–i &gt;= 0) { if (s !== ‘’ || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === ‘’ ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc x) : pow(x x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 &gt;= 4096) { n += 12; x2 /= 4096; } while (x2 &gt;= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F (!!$toFixed &amp;&amp; ( 0.00008.toFixed(3) !== ‘0.000’ || 0.9.toFixed(0) !== ‘1’ || 1.255.toFixed(2) !== ‘1.25’ || 1000000000000000128.0.toFixed(0) !== ‘1000000000000000128’ ) || !webpack_require(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), ‘Number’, { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ‘’; var m = ZERO; var e, z, j, k; if (f &lt; 0 || f &gt; 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return ‘NaN’; if (x &lt;= -1e21 || x &gt;= 1e21) return String(x); if (x &lt; 0) { s = ‘-‘; x = -x; } if (x &gt; 1e-21) { e = log(x pow(2, 69, 1)) - 69; z = e &lt; 0 ? x pow(2, -e, 1) : x / pow(2, e, 1); z = 0x10000000000000; e = 52 - e; if (e &gt; 0) { multiply(0, z); j = f; while (j &gt;= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j &gt;= 23) { divide(1 &lt;&lt; 23); j -= 23; } divide(1 &lt;&lt; j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 &lt;&lt; -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f &gt; 0) { k = m.length; m = s + (k &lt;= f ? ‘0.’ + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + ‘.’ + m.slice(k - f)); } else { m = s + m; } return m; } });// }),/ 97 /// (function(module, exports, webpack_require) { var cof = webpack_require(42); module.exports = function (it, msg) { if (typeof it != ‘number’ &amp;&amp; cof(it) != ‘Number’) throw TypeError(msg); return +it; };// }),/ 98 /// (function(module, exports, webpack_require) { ‘use strict’; var toInteger = webpack_require(46); var defined = webpack_require(43); module.exports = function repeat(count) { var str = String(defined(this)); var res = ‘’; var n = toInteger(count); if (n &lt; 0 || n == Infinity) throw RangeError(“Count can’t be negative”); for (;n &gt; 0; (n &gt;&gt;&gt;= 1) &amp;&amp; (str += str)) if (n &amp; 1) res += str; return res; };// }),/ 99 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $fails = webpack_require(14); var aNumberValue = webpack_require(97); var $toPrecision = 1.0.toPrecision; $export($export.P + $export.F ($fails(function () { // IE7- return $toPrecision.call(1, undefined) !== ‘1’; }) || !$fails(function () { // V8 ~ Android 4.3- $toPrecision.call({}); })), ‘Number’, { toPrecision: function toPrecision(precision) { var that = aNumberValue(this, ‘Number#toPrecision: incorrect invocation!’); return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); } });/*/ }),/ 100 /// (function(module, exports, webpack_require) { // 20.1.2.1 Number.EPSILON var $export = webpack_require(15); $export($export.S, ‘Number’, { EPSILON: Math.pow(2, -52) });// }),/ 101 /// (function(module, exports, webpack_require) { // 20.1.2.2 Number.isFinite(number) var $export = webpack_require(15); var _isFinite = webpack_require(11).isFinite; $export($export.S, ‘Number’, { isFinite: function isFinite(it) { return typeof it == ‘number’ &amp;&amp; _isFinite(it); } });// }),/ 102 /// (function(module, exports, webpack_require) { // 20.1.2.3 Number.isInteger(number) var $export = webpack_require(15); $export($export.S, ‘Number’, { isInteger: webpack_require(103) });// }),/ 103 /// (function(module, exports, webpack_require) { // 20.1.2.3 Number.isInteger(number) var isObject = webpack_require(20); var floor = Math.floor; module.exports = function isInteger(it) { return !isObject(it) &amp;&amp; isFinite(it) &amp;&amp; floor(it) === it; };// }),/ 104 /// (function(module, exports, webpack_require) { // 20.1.2.4 Number.isNaN(number) var $export = webpack_require(15); $export($export.S, ‘Number’, { isNaN: function isNaN(number) { // eslint-disable-next-line no-self-compare return number != number; } });// }),/ 105 /// (function(module, exports, webpack_require) { // 20.1.2.5 Number.isSafeInteger(number) var $export = webpack_require(15); var isInteger = webpack_require(103); var abs = Math.abs; $export($export.S, ‘Number’, { isSafeInteger: function isSafeInteger(number) { return isInteger(number) &amp;&amp; abs(number) &lt;= 0x1fffffffffffff; } });// }),/ 106 /// (function(module, exports, webpack_require) { // 20.1.2.6 Number.MAX_SAFE_INTEGER var $export = webpack_require(15); $export($export.S, ‘Number’, { MAX_SAFE_INTEGER: 0x1fffffffffffff });// }),/ 107 /// (function(module, exports, webpack_require) { // 20.1.2.10 Number.MIN_SAFE_INTEGER var $export = webpack_require(15); $export($export.S, ‘Number’, { MIN_SAFE_INTEGER: -0x1fffffffffffff });// }),/ 108 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseFloat = webpack_require(93); // 20.1.2.12 Number.parseFloat(string) $export($export.S + $export.F (Number.parseFloat != $parseFloat), ‘Number’, { parseFloat: $parseFloat });/*/ }),/ 109 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $parseInt = webpack_require(89); // 20.1.2.13 Number.parseInt(string, radix) $export($export.S + $export.F (Number.parseInt != $parseInt), ‘Number’, { parseInt: $parseInt });/*/ }),/ 110 /// (function(module, exports, webpack_require) { // 20.2.2.3 Math.acosh(x) var $export = webpack_require(15); var log1p = webpack_require(111); var sqrt = Math.sqrt; var $acosh = Math.acosh; $export($export.S + $export.F !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509 &amp;&amp; Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -&gt; NaN &amp;&amp; $acosh(Infinity) == Infinity ), ‘Math’, { acosh: function acosh(x) { return (x = +x) &lt; 1 ? NaN : x &gt; 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) sqrt(x + 1)); } });// }),/ 111 /// (function(module, exports) { // 20.2.2.20 Math.log1p(x) module.exports = Math.log1p || function log1p(x) { return (x = +x) &gt; -1e-8 &amp;&amp; x &lt; 1e-8 ? x - x x / 2 : Math.log(1 + x); };/*/ }),/ 112 /// (function(module, exports, webpack_require) { // 20.2.2.5 Math.asinh(x) var $export = webpack_require(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x &lt; 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x x + 1)); } // Tor Browser bug: Math.asinh(0) -&gt; -0 $export($export.S + $export.F !($asinh &amp;&amp; 1 / $asinh(0) &gt; 0), ‘Math’, { asinh: asinh });// }),/ 113 /// (function(module, exports, webpack_require) { // 20.2.2.7 Math.atanh(x) var $export = webpack_require(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -&gt; 0 $export($export.S + $export.F !($atanh &amp;&amp; 1 / $atanh(-0) &lt; 0), ‘Math’, { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } });/*/ }),/ 114 /// (function(module, exports, webpack_require) { // 20.2.2.9 Math.cbrt(x) var $export = webpack_require(15); var sign = webpack_require(115); $export($export.S, ‘Math’, { cbrt: function cbrt(x) { return sign(x = +x) Math.pow(Math.abs(x), 1 / 3); } });/*/ }),/ 115 /// (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x &lt; 0 ? -1 : 1; };// }),/ 116 /// (function(module, exports, webpack_require) { // 20.2.2.11 Math.clz32(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { clz32: function clz32(x) { return (x &gt;&gt;&gt;= 0) ? 31 - Math.floor(Math.log(x + 0.5) Math.LOG2E) : 32; } });/*/ }),/ 117 /// (function(module, exports, webpack_require) { // 20.2.2.12 Math.cosh(x) var $export = webpack_require(15); var exp = Math.exp; $export($export.S, ‘Math’, { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } });// }),/ 118 /// (function(module, exports, webpack_require) { // 20.2.2.14 Math.expm1(x) var $export = webpack_require(15); var $expm1 = webpack_require(119); $export($export.S + $export.F ($expm1 != Math.expm1), ‘Math’, { expm1: $expm1 });/*/ }),/ 119 /// (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) &gt; 22025.465794806719 || $expm1(10) &lt; 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x &gt; -1e-6 &amp;&amp; x &lt; 1e-6 ? x + x x / 2 : Math.exp(x) - 1; } : $expm1;/*/ }),/ 120 /// (function(module, exports, webpack_require) { // 20.2.2.16 Math.fround(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { fround: webpack_require(121) });// }),/ 121 /// (function(module, exports, webpack_require) { // 20.2.2.16 Math.fround(x) var sign = webpack_require(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs &lt; MIN32) return $sign roundTiesToEven($abs / MIN32 / EPSILON32) MIN32 EPSILON32; a = (1 + EPSILON32 / EPSILON) $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result &gt; MAX32 || result != result) return $sign Infinity; return $sign result; };/*/ }),/ 122 /// (function(module, exports, webpack_require) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = webpack_require(15); var abs = Math.abs; $export($export.S, ‘Math’, { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i &lt; aLen) { arg = abs(arguments[i++]); if (larg &lt; arg) { div = larg / arg; sum = sum div div + 1; larg = arg; } else if (arg &gt; 0) { div = arg / larg; sum += div div; } else sum += arg; } return larg === Infinity ? Infinity : larg Math.sqrt(sum); } });// }),/ 123 /// (function(module, exports, webpack_require) { // 20.2.2.18 Math.imul(x, y) var $export = webpack_require(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F webpack_require(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), ‘Math’, { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 &amp; xn; var yl = UINT16 &amp; yn; return 0 | xl yl + ((UINT16 &amp; xn &gt;&gt;&gt; 16) yl + xl (UINT16 &amp; yn &gt;&gt;&gt; 16) &lt;&lt; 16 &gt;&gt;&gt; 0); } });// }),/ 124 /// (function(module, exports, webpack_require) { // 20.2.2.21 Math.log10(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log10: function log10(x) { return Math.log(x) Math.LOG10E; } });/*/ }),/ 125 /// (function(module, exports, webpack_require) { // 20.2.2.20 Math.log1p(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log1p: webpack_require(111) });// }),/ 126 /// (function(module, exports, webpack_require) { // 20.2.2.22 Math.log2(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { log2: function log2(x) { return Math.log(x) / Math.LN2; } });// }),/ 127 /// (function(module, exports, webpack_require) { // 20.2.2.28 Math.sign(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { sign: webpack_require(115) });// }),/ 128 /// (function(module, exports, webpack_require) { // 20.2.2.30 Math.sinh(x) var $export = webpack_require(15); var expm1 = webpack_require(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F webpack_require(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), ‘Math’, { sinh: function sinh(x) { return Math.abs(x = +x) &lt; 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) (Math.E / 2); } });// }),/ 129 /// (function(module, exports, webpack_require) { // 20.2.2.33 Math.tanh(x) var $export = webpack_require(15); var expm1 = webpack_require(119); var exp = Math.exp; $export($export.S, ‘Math’, { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } });// }),/ 130 /// (function(module, exports, webpack_require) { // 20.2.2.34 Math.trunc(x) var $export = webpack_require(15); $export($export.S, ‘Math’, { trunc: function trunc(it) { return (it &gt; 0 ? Math.floor : Math.ceil)(it); } });// }),/ 131 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var toAbsoluteIndex = webpack_require(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F (!!$fromCodePoint &amp;&amp; $fromCodePoint.length != 1), ‘String’, { // 21.1.2.2 String.fromCodePoint(…codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen &gt; i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ‘ is not a valid code point’); res.push(code &lt; 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) &gt;&gt; 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(‘’); } });/*/ }),/ 132 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var toIObject = webpack_require(40); var toLength = webpack_require(45); $export($export.S, ‘String’, { // 21.1.2.4 String.raw(callSite, …substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len &gt; i) { res.push(String(tpl[i++])); if (i &lt; aLen) res.push(String(arguments[i])); } return res.join(‘’); } });// }),/ 133 /// (function(module, exports, webpack_require) { ‘use strict’; // 21.1.3.25 String.prototype.trim() webpack_require(90)(‘trim’, function ($trim) { return function trim() { return $trim(this, 3); }; });// }),/ 134 /// (function(module, exports, webpack_require) { ‘use strict’; var $at = webpack_require(135)(true); // 21.1.3.27 String.prototype@@iterator webpack_require(136)(String, ‘String’, function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index &gt;= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; });// }),/ 135 /// (function(module, exports, webpack_require) { var toInteger = webpack_require(46); var defined = webpack_require(43); // true -&gt; String#at // false -&gt; String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i &lt; 0 || i &gt;= l) return TO_STRING ? ‘’ : undefined; a = s.charCodeAt(i); return a &lt; 0xd800 || a &gt; 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) &lt; 0xdc00 || b &gt; 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 &lt;&lt; 10) + (b - 0xdc00) + 0x10000; }; };// }),/ 136 /// (function(module, exports, webpack_require) { ‘use strict’; var LIBRARY = webpack_require(29); var $export = webpack_require(15); var redefine = webpack_require(25); var hide = webpack_require(17); var Iterators = webpack_require(137); var $iterCreate = webpack_require(138); var setToStringTag = webpack_require(33); var getPrototypeOf = webpack_require(66); var ITERATOR = webpack_require(34)(‘iterator’); var BUGGY = !([].keys &amp;&amp; ‘next’ in [].keys()); // Safari has buggy iterators w/o next var FF_ITERATOR = ‘@@iterator’; var KEYS = ‘keys’; var VALUES = ‘values’; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY &amp;&amp; kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ‘ Iterator’; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT &amp;&amp; proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(‘entries’) : undefined; var $anyNative = NAME == ‘Array’ ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype &amp;&amp; IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY &amp;&amp; typeof IteratorPrototype[ITERATOR] != ‘function’) hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES &amp;&amp; $native &amp;&amp; $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) &amp;&amp; (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F (BUGGY || VALUES_BUG), NAME, methods); } return methods; };/*/ }),/ 137 /// (function(module, exports) { module.exports = {};// }),/ 138 /// (function(module, exports, webpack_require) { ‘use strict’; var create = webpack_require(53); var descriptor = webpack_require(24); var setToStringTag = webpack_require(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%@@iterator webpack_require(17)(IteratorPrototype, webpack_require(34)(‘iterator’), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ‘ Iterator’); };// }),/ 139 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $at = webpack_require(135)(false); $export($export.P, ‘String’, { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } });// }),/ 140 /// (function(module, exports, webpack_require) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) ‘use strict’; var $export = webpack_require(15); var toLength = webpack_require(45); var context = webpack_require(141); var ENDS_WITH = ‘endsWith’; var $endsWith = ‘’[ENDS_WITH]; $export($export.P + $export.F webpack_require(143)(ENDS_WITH), ‘String’, { endsWith: function endsWith(searchString / , endPosition = @length /) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length &gt; 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } });/*/ }),/ 141 /// (function(module, exports, webpack_require) { // helper for String#{startsWith, endsWith, includes} var isRegExp = webpack_require(142); var defined = webpack_require(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError(‘String#’ + NAME + “ doesn’t accept regex!”); return String(defined(that)); };// }),/ 142 /// (function(module, exports, webpack_require) { // 7.2.8 IsRegExp(argument) var isObject = webpack_require(20); var cof = webpack_require(42); var MATCH = webpack_require(34)(‘match’); module.exports = function (it) { var isRegExp; return isObject(it) &amp;&amp; ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == ‘RegExp’); };// }),/ 143 /// (function(module, exports, webpack_require) { var MATCH = webpack_require(34)(‘match’); module.exports = function (KEY) { var re = /./; try { ‘/./‘KEY; } catch (e) { try { re[MATCH] = false; return !’/./‘KEY; } catch (f) { / empty / } } return true; };// }),/ 144 /// (function(module, exports, webpack_require) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) ‘use strict’; var $export = webpack_require(15); var context = webpack_require(141); var INCLUDES = ‘includes’; $export($export.P + $export.F webpack_require(143)(INCLUDES), ‘String’, { includes: function includes(searchString / , position = 0 /) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length &gt; 1 ? arguments[1] : undefined); } });/*/ }),/ 145 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); $export($export.P, ‘String’, { // 21.1.3.13 String.prototype.repeat(count) repeat: webpack_require(98) });// }),/ 146 /// (function(module, exports, webpack_require) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) ‘use strict’; var $export = webpack_require(15); var toLength = webpack_require(45); var context = webpack_require(141); var STARTS_WITH = ‘startsWith’; var $startsWith = ‘’[STARTS_WITH]; $export($export.P + $export.F webpack_require(143)(STARTS_WITH), ‘String’, { startsWith: function startsWith(searchString / , position = 0 /) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length &gt; 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } });/*/ }),/ 147 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.2 String.prototype.anchor(name) webpack_require(148)(‘anchor’, function (createHTML) { return function anchor(name) { return createHTML(this, ‘a’, ‘name’, name); }; });// }),/ 148 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var fails = webpack_require(14); var defined = webpack_require(43); var quot = /“/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ‘&lt;’ + tag; if (attribute !== ‘’) p1 += ‘ ‘ + attribute + ‘=”‘ + String(value).replace(quot, ‘&quot;’) + ‘“‘; return p1 + ‘&gt;’ + S + ‘&lt;/‘ + tag + ‘&gt;’; }; module.exports = function (NAME, exec) { var O = {}; O[NAME] = exec(createHTML); $export($export.P + $export.F fails(function () { var test = ‘’NAME; return test !== test.toLowerCase() || test.split(‘“‘).length &gt; 3; }), ‘String’, O); };/*/ }),/ 149 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.3 String.prototype.big() webpack_require(148)(‘big’, function (createHTML) { return function big() { return createHTML(this, ‘big’, ‘’, ‘’); }; });// }),/ 150 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.4 String.prototype.blink() webpack_require(148)(‘blink’, function (createHTML) { return function blink() { return createHTML(this, ‘blink’, ‘’, ‘’); }; });// }),/ 151 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.5 String.prototype.bold() webpack_require(148)(‘bold’, function (createHTML) { return function bold() { return createHTML(this, ‘b’, ‘’, ‘’); }; });// }),/ 152 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.6 String.prototype.fixed() webpack_require(148)(‘fixed’, function (createHTML) { return function fixed() { return createHTML(this, ‘tt’, ‘’, ‘’); }; });// }),/ 153 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.7 String.prototype.fontcolor(color) webpack_require(148)(‘fontcolor’, function (createHTML) { return function fontcolor(color) { return createHTML(this, ‘font’, ‘color’, color); }; });// }),/ 154 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.8 String.prototype.fontsize(size) webpack_require(148)(‘fontsize’, function (createHTML) { return function fontsize(size) { return createHTML(this, ‘font’, ‘size’, size); }; });// }),/ 155 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.9 String.prototype.italics() webpack_require(148)(‘italics’, function (createHTML) { return function italics() { return createHTML(this, ‘i’, ‘’, ‘’); }; });// }),/ 156 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.10 String.prototype.link(url) webpack_require(148)(‘link’, function (createHTML) { return function link(url) { return createHTML(this, ‘a’, ‘href’, url); }; });// }),/ 157 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.11 String.prototype.small() webpack_require(148)(‘small’, function (createHTML) { return function small() { return createHTML(this, ‘small’, ‘’, ‘’); }; });// }),/ 158 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.12 String.prototype.strike() webpack_require(148)(‘strike’, function (createHTML) { return function strike() { return createHTML(this, ‘strike’, ‘’, ‘’); }; });// }),/ 159 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.13 String.prototype.sub() webpack_require(148)(‘sub’, function (createHTML) { return function sub() { return createHTML(this, ‘sub’, ‘’, ‘’); }; });// }),/ 160 /// (function(module, exports, webpack_require) { ‘use strict’; // B.2.3.14 String.prototype.sup() webpack_require(148)(‘sup’, function (createHTML) { return function sup() { return createHTML(this, ‘sup’, ‘’, ‘’); }; });// }),/ 161 /// (function(module, exports, webpack_require) { // 20.3.3.1 / 15.9.4.4 Date.now() var $export = webpack_require(15); $export($export.S, ‘Date’, { now: function () { return new Date().getTime(); } });// }),/ 162 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); $export($export.P + $export.F webpack_require(14)(function () { return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1; }), ‘Date’, { // eslint-disable-next-line no-unused-vars toJSON: function toJSON(key) { var O = toObject(this); var pv = toPrimitive(O); return typeof pv == ‘number’ &amp;&amp; !isFinite(pv) ? null : O.toISOString(); } });/*/ }),/ 163 /// (function(module, exports, webpack_require) { // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString() var $export = webpack_require(15); var toISOString = webpack_require(164); // PhantomJS / old WebKit has a broken implementations $export($export.P + $export.F (Date.prototype.toISOString !== toISOString), ‘Date’, { toISOString: toISOString });/*/ }),/ 164 /// (function(module, exports, webpack_require) { ‘use strict’; // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString() var fails = webpack_require(14); var getTime = Date.prototype.getTime; var $toISOString = Date.prototype.toISOString; var lz = function (num) { return num &gt; 9 ? num : ‘0’ + num; }; // PhantomJS / old WebKit has a broken implementations module.exports = (fails(function () { return $toISOString.call(new Date(-5e13 - 1)) != ‘0385-07-25T07:06:39.999Z’; }) || !fails(function () { $toISOString.call(new Date(NaN)); })) ? function toISOString() { if (!isFinite(getTime.call(this))) throw RangeError(‘Invalid time value’); var d = this; var y = d.getUTCFullYear(); var m = d.getUTCMilliseconds(); var s = y &lt; 0 ? ‘-‘ : y &gt; 9999 ? ‘+’ : ‘’; return s + (‘00000’ + Math.abs(y)).slice(s ? -6 : -4) + ‘-‘ + lz(d.getUTCMonth() + 1) + ‘-‘ + lz(d.getUTCDate()) + ‘T’ + lz(d.getUTCHours()) + ‘:’ + lz(d.getUTCMinutes()) + ‘:’ + lz(d.getUTCSeconds()) + ‘.’ + (m &gt; 99 ? m : ‘0’ + lz(m)) + ‘Z’; } : $toISOString;// }),/ 165 /// (function(module, exports, webpack_require) { var DateProto = Date.prototype; var INVALID_DATE = ‘Invalid Date’; var TO_STRING = ‘toString’; var $toString = DateProto[TO_STRING]; var getTime = DateProto.getTime; if (new Date(NaN) + ‘’ != INVALID_DATE) { webpack_require(25)(DateProto, TO_STRING, function toString() { var value = getTime.call(this); // eslint-disable-next-line no-self-compare return value === value ? $toString.call(this) : INVALID_DATE; }); }// }),/ 166 /// (function(module, exports, webpack_require) { var TO_PRIMITIVE = webpack_require(34)(‘toPrimitive’); var proto = Date.prototype; if (!(TO_PRIMITIVE in proto)) webpack_require(17)(proto, TO_PRIMITIVE, webpack_require(167));// }),/ 167 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toPrimitive = webpack_require(23); var NUMBER = ‘number’; module.exports = function (hint) { if (hint !== ‘string’ &amp;&amp; hint !== NUMBER &amp;&amp; hint !== ‘default’) throw TypeError(‘Incorrect hint’); return toPrimitive(anObject(this), hint != NUMBER); };// }),/ 168 /// (function(module, exports, webpack_require) { // 22.1.2.2 / 15.4.3.2 Array.isArray(arg) var $export = webpack_require(15); $export($export.S, ‘Array’, { isArray: webpack_require(52) });// }),/ 169 /// (function(module, exports, webpack_require) { ‘use strict’; var ctx = webpack_require(30); var $export = webpack_require(15); var toObject = webpack_require(65); var call = webpack_require(170); var isArrayIter = webpack_require(171); var toLength = webpack_require(45); var createProperty = webpack_require(172); var getIterFn = webpack_require(173); $export($export.S + $export.F !webpack_require(174)(function (iter) { Array.from(iter); }), ‘Array’, { // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined) from: function from(arrayLike / , mapfn = undefined, thisArg = undefined /) { var O = toObject(arrayLike); var C = typeof this == ‘function’ ? this : Array; var aLen = arguments.length; var mapfn = aLen &gt; 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var index = 0; var iterFn = getIterFn(O); var length, result, step, iterator; if (mapping) mapfn = ctx(mapfn, aLen &gt; 2 ? arguments[2] : undefined, 2); // if object isn’t iterable or it’s array with default iterator - use simple case if (iterFn != undefined &amp;&amp; !(C == Array &amp;&amp; isArrayIter(iterFn))) { for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) { createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value); } } else { length = toLength(O.length); for (result = new C(length); length &gt; index; index++) { createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]); } } result.length = index; return result; } });/*/ }),/ 170 /// (function(module, exports, webpack_require) { // call something on iterator step with safe closing on error var anObject = webpack_require(19); module.exports = function (iterator, fn, value, entries) { try { return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion) } catch (e) { var ret = iterator[‘return’]; if (ret !== undefined) anObject(ret.call(iterator)); throw e; } };// }),/ 171 /// (function(module, exports, webpack_require) { // check on default Array iterator var Iterators = webpack_require(137); var ITERATOR = webpack_require(34)(‘iterator’); var ArrayProto = Array.prototype; module.exports = function (it) { return it !== undefined &amp;&amp; (Iterators.Array === it || ArrayProto[ITERATOR] === it); };// }),/ 172 /// (function(module, exports, webpack_require) { ‘use strict’; var $defineProperty = webpack_require(18); var createDesc = webpack_require(24); module.exports = function (object, index, value) { if (index in object) $defineProperty.f(object, index, createDesc(0, value)); else object[index] = value; };// }),/ 173 /// (function(module, exports, webpack_require) { var classof = webpack_require(82); var ITERATOR = webpack_require(34)(‘iterator’); var Iterators = webpack_require(137); module.exports = webpack_require(16).getIteratorMethod = function (it) { if (it != undefined) return it[ITERATOR] || it[‘@@iterator’] || Iterators[classof(it)]; };// }),/ 174 /// (function(module, exports, webpack_require) { var ITERATOR = webpack_require(34)(‘iterator’); var SAFE_CLOSING = false; try { var riter = [7]ITERATOR; riter[‘return’] = function () { SAFE_CLOSING = true; }; // eslint-disable-next-line no-throw-literal Array.from(riter, function () { throw 2; }); } catch (e) { / empty / } module.exports = function (exec, skipClosing) { if (!skipClosing &amp;&amp; !SAFE_CLOSING) return false; var safe = false; try { var arr = [7]; var iter = arrITERATOR; iter.next = function () { return { done: safe = true }; }; arr[ITERATOR] = function () { return iter; }; exec(arr); } catch (e) { / empty / } return safe; };// }),/ 175 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var createProperty = webpack_require(172); // WebKit Array.of isn’t generic $export($export.S + $export.F webpack_require(14)(function () { function F() { / empty / } return !(Array.of.call(F) instanceof F); }), ‘Array’, { // 22.1.2.3 Array.of( …items) of: function of(/ …args /) { var index = 0; var aLen = arguments.length; var result = new (typeof this == ‘function’ ? this : Array)(aLen); while (aLen &gt; index) createProperty(result, index, arguments[index++]); result.length = aLen; return result; } });/*/ }),/ 176 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.13 Array.prototype.join(separator) var $export = webpack_require(15); var toIObject = webpack_require(40); var arrayJoin = [].join; // fallback for not array-like strings $export($export.P + $export.F (webpack_require(41) != Object || !webpack_require(177)(arrayJoin)), ‘Array’, { join: function join(separator) { return arrayJoin.call(toIObject(this), separator === undefined ? ‘,’ : separator); } });/*/ }),/ 177 /// (function(module, exports, webpack_require) { ‘use strict’; var fails = webpack_require(14); module.exports = function (method, arg) { return !!method &amp;&amp; fails(function () { // eslint-disable-next-line no-useless-call arg ? method.call(null, function () { / empty / }, 1) : method.call(null); }); };// }),/ 178 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var html = webpack_require(55); var cof = webpack_require(42); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects $export($export.P + $export.F webpack_require(14)(function () { if (html) arraySlice.call(html); }), ‘Array’, { slice: function slice(begin, end) { var len = toLength(this.length); var klass = cof(this); end = end === undefined ? len : end; if (klass == ‘Array’) return arraySlice.call(this, begin, end); var start = toAbsoluteIndex(begin, len); var upTo = toAbsoluteIndex(end, len); var size = toLength(upTo - start); var cloned = new Array(size); var i = 0; for (; i &lt; size; i++) cloned[i] = klass == ‘String’ ? this.charAt(start + i) : this[start + i]; return cloned; } });/*/ }),/ 179 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var aFunction = webpack_require(31); var toObject = webpack_require(65); var fails = webpack_require(14); var $sort = [].sort; var test = [1, 2, 3]; $export($export.P + $export.F (fails(function () { // IE8- test.sort(undefined); }) || !fails(function () { // V8 bug test.sort(null); // Old WebKit }) || !webpack_require(177)($sort)), ‘Array’, { // 22.1.3.25 Array.prototype.sort(comparefn) sort: function sort(comparefn) { return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn)); } });/*/ }),/ 180 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $forEach = webpack_require(181)(0); var STRICT = webpack_require(177)([].forEach, true); $export($export.P + $export.F !STRICT, ‘Array’, { // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg]) forEach: function forEach(callbackfn / , thisArg /) { return $forEach(this, callbackfn, arguments[1]); } });/*/ }),/ 181 /// (function(module, exports, webpack_require) { // 0 -&gt; Array#forEach // 1 -&gt; Array#map // 2 -&gt; Array#filter // 3 -&gt; Array#some // 4 -&gt; Array#every // 5 -&gt; Array#find // 6 -&gt; Array#findIndex var ctx = webpack_require(30); var IObject = webpack_require(41); var toObject = webpack_require(65); var toLength = webpack_require(45); var asc = webpack_require(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length &gt; index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; };// }),/ 182 /// (function(module, exports, webpack_require) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = webpack_require(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); };// }),/ 183 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); var isArray = webpack_require(52); var SPECIES = webpack_require(34)(‘species’); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == ‘function’ &amp;&amp; (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; };// }),/ 184 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $map = webpack_require(181)(1); $export($export.P + $export.F !webpack_require(177)([].map, true), ‘Array’, { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn / , thisArg /) { return $map(this, callbackfn, arguments[1]); } });/*/ }),/ 185 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $filter = webpack_require(181)(2); $export($export.P + $export.F !webpack_require(177)([].filter, true), ‘Array’, { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn / , thisArg /) { return $filter(this, callbackfn, arguments[1]); } });/*/ }),/ 186 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $some = webpack_require(181)(3); $export($export.P + $export.F !webpack_require(177)([].some, true), ‘Array’, { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn / , thisArg /) { return $some(this, callbackfn, arguments[1]); } });/*/ }),/ 187 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $every = webpack_require(181)(4); $export($export.P + $export.F !webpack_require(177)([].every, true), ‘Array’, { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn / , thisArg /) { return $every(this, callbackfn, arguments[1]); } });/*/ }),/ 188 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $reduce = webpack_require(189); $export($export.P + $export.F !webpack_require(177)([].reduce, true), ‘Array’, { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn / , initialValue /) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } });/*/ }),/ 189 /// (function(module, exports, webpack_require) { var aFunction = webpack_require(31); var toObject = webpack_require(65); var IObject = webpack_require(41); var toLength = webpack_require(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen &lt; 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index &lt; 0 : length &lt;= index) { throw TypeError(‘Reduce of empty array with no initial value’); } } for (;isRight ? index &gt;= 0 : length &gt; index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; };// }),/ 190 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $reduce = webpack_require(189); $export($export.P + $export.F !webpack_require(177)([].reduceRight, true), ‘Array’, { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn / , initialValue /) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } });/*/ }),/ 191 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $indexOf = webpack_require(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native &amp;&amp; 1 / [1].indexOf(1, -0) &lt; 0; $export($export.P + $export.F (NEGATIVE_ZERO || !webpack_require(177)($native)), ‘Array’, { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement / , fromIndex = 0 /) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } });/*/ }),/ 192 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toIObject = webpack_require(40); var toInteger = webpack_require(46); var toLength = webpack_require(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native &amp;&amp; 1 / [1].lastIndexOf(1, -0) &lt; 0; $export($export.P + $export.F (NEGATIVE_ZERO || !webpack_require(177)($native)), ‘Array’, { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement / , fromIndex = @[-1] /) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length &gt; 1) index = Math.min(index, toInteger(arguments[1])); if (index &lt; 0) index = length + index; for (;index &gt;= 0; index–) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } });// }),/ 193 /// (function(module, exports, webpack_require) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = webpack_require(15); $export($export.P, ‘Array’, { copyWithin: webpack_require(194) }); webpack_require(195)(‘copyWithin’);// }),/ 194 /// (function(module, exports, webpack_require) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) ‘use strict’; var toObject = webpack_require(65); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); module.exports = [].copyWithin || function copyWithin(target / = 0 /, start / = 0, end = @length /) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length &gt; 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from &lt; to &amp;&amp; to &lt; from + count) { inc = -1; from += count - 1; to += count - 1; } while (count– &gt; 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; };// }),/ 195 /// (function(module, exports, webpack_require) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = webpack_require(34)(‘unscopables’); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) webpack_require(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; };// }),/ 196 /// (function(module, exports, webpack_require) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = webpack_require(15); $export($export.P, ‘Array’, { fill: webpack_require(197) }); webpack_require(195)(‘fill’);// }),/ 197 /// (function(module, exports, webpack_require) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) ‘use strict’; var toObject = webpack_require(65); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); module.exports = function fill(value / , start = 0, end = @length /) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen &gt; 1 ? arguments[1] : undefined, length); var end = aLen &gt; 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos &gt; index) O[index++] = value; return O; };// }),/ 198 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = webpack_require(15); var $find = webpack_require(181)(5); var KEY = ‘find’; var forced = true; // Shouldn’t skip holes if (KEY in []) Array(1)KEY { forced = false; }); $export($export.P + $export.F forced, ‘Array’, { find: function find(callbackfn / , that = undefined /) { return $find(this, callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(KEY);/*/ }),/ 199 /// (function(module, exports, webpack_require) { ‘use strict’; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = webpack_require(15); var $find = webpack_require(181)(6); var KEY = ‘findIndex’; var forced = true; // Shouldn’t skip holes if (KEY in []) Array(1)KEY { forced = false; }); $export($export.P + $export.F forced, ‘Array’, { findIndex: function findIndex(callbackfn / , that = undefined /) { return $find(this, callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(KEY);/*/ }),/ 200 /// (function(module, exports, webpack_require) { webpack_require(201)(‘Array’);// }),/ 201 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var dP = webpack_require(18); var DESCRIPTORS = webpack_require(13); var SPECIES = webpack_require(34)(‘species’); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS &amp;&amp; C &amp;&amp; !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); };// }),/ 202 /// (function(module, exports, webpack_require) { ‘use strict’; var addToUnscopables = webpack_require(195); var step = webpack_require(203); var Iterators = webpack_require(137); var toIObject = webpack_require(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype@@iterator module.exports = webpack_require(136)(Array, ‘Array’, function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index &gt;= O.length) { this._t = undefined; return step(1); } if (kind == ‘keys’) return step(0, index); if (kind == ‘values’) return step(0, O[index]); return step(0, [index, O[index]]); }, ‘values’); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables(‘keys’); addToUnscopables(‘values’); addToUnscopables(‘entries’);// }),/ 203 /// (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; };// }),/ 204 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var inheritIfRequired = webpack_require(95); var dP = webpack_require(18).f; var gOPN = webpack_require(57).f; var isRegExp = webpack_require(142); var $flags = webpack_require(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // “new” creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (webpack_require(13) &amp;&amp; (!CORRECT_NEW || webpack_require(14)(function () { re2[webpack_require(34)(‘match’)] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, ‘i’) != ‘/a/i’; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE &amp;&amp; piRE &amp;&amp; p.constructor === $RegExp &amp;&amp; fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE &amp;&amp; !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE &amp;&amp; fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length &gt; i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; webpack_require(25)(global, ‘RegExp’, $RegExp); } webpack_require(201)(‘RegExp’);// }),/ 205 /// (function(module, exports, webpack_require) { ‘use strict’; // 21.2.5.3 get RegExp.prototype.flags var anObject = webpack_require(19); module.exports = function () { var that = anObject(this); var result = ‘’; if (that.global) result += ‘g’; if (that.ignoreCase) result += ‘i’; if (that.multiline) result += ‘m’; if (that.unicode) result += ‘u’; if (that.sticky) result += ‘y’; return result; };// }),/ 206 /// (function(module, exports, webpack_require) { ‘use strict’; var regexpExec = webpack_require(207); webpack_require(15)({ target: ‘RegExp’, proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec });// }),/ 207 /// (function(module, exports, webpack_require) { ‘use strict’; var regexpFlags = webpack_require(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = ‘lastIndex’; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b/g; nativeExec.call(re1, ‘a’); nativeExec.call(re2, ‘a’); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim’s String#split patch. var NPCG_INCLUDED = /()??/.exec(‘’)[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp(‘^’ + re.source + ‘$(?!\s)’, regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG &amp;&amp; match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED &amp;&amp; match &amp;&amp; match.length &gt; 1) { // Fix browsers whose exec methods don’t consistently return undefined // for NPCG, like IE8. NOTE: This doesn’ work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i &lt; arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec;/*/ }),/ 208 /// (function(module, exports, webpack_require) { ‘use strict’; webpack_require(209); var anObject = webpack_require(19); var $flags = webpack_require(205); var DESCRIPTORS = webpack_require(13); var TO_STRING = ‘toString’; var $toString = /./[TO_STRING]; var define = function (fn) { webpack_require(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (webpack_require(14)(function () { return $toString.call({ source: ‘a’, flags: ‘b’ }) != ‘/a/b’; })) { define(function toString() { var R = anObject(this); return ‘/‘.concat(R.source, ‘/‘, ‘flags’ in R ? R.flags : !DESCRIPTORS &amp;&amp; R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); }// }),/ 209 /// (function(module, exports, webpack_require) { // 21.2.5.3 get RegExp.prototype.flags() if (webpack_require(13) &amp;&amp; /./g.flags != ‘g’) webpack_require(18).f(RegExp.prototype, ‘flags’, { configurable: true, get: webpack_require(205) });// }),/ 210 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toLength = webpack_require(45); var advanceStringIndex = webpack_require(211); var regExpExec = webpack_require(212); // @@match logic webpack_require(213)(‘match’, 1, function (defined, MATCH, $match, maybeCallNative) { return [ // String.prototype.match method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)MATCH); }, // RegExp.prototype[@@match] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === ‘’) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; });// }),/ 211 /// (function(module, exports, webpack_require) { ‘use strict’; var at = webpack_require(135)(true); // AdvanceStringIndex abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); };// }),/ 212 /// (function(module, exports, webpack_require) { ‘use strict’; var classof = webpack_require(82); var builtinExec = RegExp.prototype.exec; // RegExpExec abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === ‘function’) { var result = exec.call(R, S); if (typeof result !== ‘object’) { throw new TypeError(‘RegExp exec method returned something other than an Object or null’); } return result; } if (classof(R) !== ‘RegExp’) { throw new TypeError(‘RegExp#exec called on incompatible receiver’); } return builtinExec.call(R, S); };// }),/ 213 /// (function(module, exports, webpack_require) { ‘use strict’; webpack_require(206); var redefine = webpack_require(25); var hide = webpack_require(17); var fails = webpack_require(14); var defined = webpack_require(43); var wks = webpack_require(34); var regexpExec = webpack_require(207); var SPECIES = wks(‘species’); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a “grops” property. var re = /./; re.exec = function () { var result = []; result.groups = { a: ‘7’ }; return result; }; return ‘’.replace(re, ‘$‘) !== ‘7’; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy “split” implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = ‘ab’.split(re); return result.length === 2 &amp;&amp; result[0] === ‘a’ &amp;&amp; result[1] === ‘b’; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ‘’KEY != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === ‘split’) { // RegExp[@@split] doesn’t call the regex’s exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } reSYMBOL; return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === ‘replace’ &amp;&amp; !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === ‘split’ &amp;&amp; !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ‘’[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL &amp;&amp; !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype@@replace // 21.2.5.11 RegExp.prototype@@split ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype@@match // 21.2.5.9 RegExp.prototype@@search : function (string) { return rxfn.call(string, this); } ); } };// }),/ 214 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var toObject = webpack_require(65); var toLength = webpack_require(45); var toInteger = webpack_require(46); var advanceStringIndex = webpack_require(211); var regExpExec = webpack_require(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&amp;`’]|\d\d?|&lt;[^&gt;]&gt;)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&amp;&#39;]|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)(&#39;replace&#39;, 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ //String.prototype.replacemethod // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, //RegExp.prototype[@@replace]method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === &#39;function&#39;; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === &#39;&#39;) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = &#39;&#39;; var nextSourcePosition = 0; for (var i = 0; i &lt; results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reasonnativeSlice.call(result, 1, result.length)(called in // the slice polyfill when slicing native arrays) &quot;doesn&#39;t work&quot; in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j &lt; result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position &gt;= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case &#39;$&#39;: return &#39;$&#39;; case &#39;&amp;&#39;: return matched; case &#39;‘: return str.slice(0, position); case “‘“: return str.slice(tailPos); case ‘&lt;’: capture = namedCaptures[ch.slice(1, -1)]; break; default: // \d\d? var n = +ch; if (n === 0) return match; if (n &gt; m) { var f = floor(n / 10); if (f === 0) return match; if (f &lt;= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1); return match; } capture = captures[n - 1]; } return capture === undefined ? ‘’ : capture; }); } });/*/ }),/ 215 /// (function(module, exports, webpack_require) { ‘use strict’; var anObject = webpack_require(19); var sameValue = webpack_require(78); var regExpExec = webpack_require(212); // @@search logic webpack_require(213)(‘search’, 1, function (defined, SEARCH, $search, maybeCallNative) { return [ // String.prototype.search method // https://tc39.github.io/ecma262/#sec-string.prototype.search function search(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[SEARCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)SEARCH); }, // RegExp.prototype[@@search] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search function (regexp) { var res = maybeCallNative($search, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var previousLastIndex = rx.lastIndex; if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0; var result = regExpExec(rx, S); if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex; return result === null ? -1 : result.index; } ]; });// }),/ 216 /// (function(module, exports, webpack_require) { ‘use strict’; var isRegExp = webpack_require(142); var anObject = webpack_require(19); var speciesConstructor = webpack_require(217); var advanceStringIndex = webpack_require(211); var toLength = webpack_require(45); var callRegExpExec = webpack_require(212); var regexpExec = webpack_require(207); var fails = webpack_require(14); var $min = Math.min; var $push = [].push; var $SPLIT = ‘split’; var LENGTH = ‘length’; var LAST_INDEX = ‘lastIndex’; var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp(‘x’, ‘y’) -&gt; /x/y and it causes SyntaxError var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, ‘y’); }); // @@split logic webpack_require(213)(‘split’, 2, function (defined, SPLIT, $split, maybeCallNative) { var internalSplit; if ( ‘abbc’$SPLIT/)[1] == ‘c’ || ‘test’$SPLIT/, -1)[LENGTH] != 4 || ‘ab’$SPLIT/)[LENGTH] != 2 || ‘.’$SPLIT(.?)/)[LENGTH] != 4 || ‘.’$SPLIT()/)[LENGTH] &gt; 1 || ‘’$SPLIT[LENGTH] ) { // based on es5-shim implementation, need to rework it internalSplit = function (separator, limit) { var string = String(this); if (separator === undefined &amp;&amp; limit === 0) return []; // If separator is not a regex, use native split if (!isRegExp(separator)) return $split.call(string, separator, limit); var output = []; var flags = (separator.ignoreCase ? ‘i’ : ‘’) + (separator.multiline ? ‘m’ : ‘’) + (separator.unicode ? ‘u’ : ‘’) + (separator.sticky ? ‘y’ : ‘’); var lastLastIndex = 0; var splitLimit = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0; // Make global and avoid lastIndex issues by working with a copy var separatorCopy = new RegExp(separator.source, flags + ‘g’); var match, lastIndex, lastLength; while (match = regexpExec.call(separatorCopy, string)) { lastIndex = separatorCopy[LAST_INDEX]; if (lastIndex &gt; lastLastIndex) { output.push(string.slice(lastLastIndex, match.index)); if (match[LENGTH] &gt; 1 &amp;&amp; match.index &lt; string[LENGTH]) $push.apply(output, match.slice(1)); lastLength = match[0][LENGTH]; lastLastIndex = lastIndex; if (output[LENGTH] &gt;= splitLimit) break; } if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop } if (lastLastIndex === string[LENGTH]) { if (lastLength || !separatorCopy.test(‘’)) output.push(‘’); } else output.push(string.slice(lastLastIndex)); return output[LENGTH] &gt; splitLimit ? output.slice(0, splitLimit) : output; }; // Chakra, V8 } else if (‘0’$SPLIT[LENGTH]) { internalSplit = function (separator, limit) { return separator === undefined &amp;&amp; limit === 0 ? [] : $split.call(this, separator, limit); }; } else { internalSplit = $split; } return [ // String.prototype.split method // https://tc39.github.io/ecma262/#sec-string.prototype.split function split(separator, limit) { var O = defined(this); var splitter = separator == undefined ? undefined : separator[SPLIT]; return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit); }, // RegExp.prototype[@@split] method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split // // NOTE: This cannot be properly polyfilled in engines that don’t support // the ‘y’ flag. function (regexp, limit) { var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var C = speciesConstructor(rx, RegExp); var unicodeMatching = rx.unicode; var flags = (rx.ignoreCase ? ‘i’ : ‘’) + (rx.multiline ? ‘m’ : ‘’) + (rx.unicode ? ‘u’ : ‘’) + (SUPPORTS_Y ? ‘y’ : ‘g’); // ^(? + rx + ) is needed, in combination with some S slicing, to // simulate the ‘y’ flag. var splitter = new C(SUPPORTS_Y ? rx : ‘^(?:’ + rx.source + ‘)’, flags); var lim = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q &lt; S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i &lt;= z.length - 1; i++) { A.push(z[i]); if (A.length === lim) return A; } q = p = e; } } A.push(S.slice(p)); return A; } ]; });// }),/ 217 /// (function(module, exports, webpack_require) { // 7.3.20 SpeciesConstructor(O, defaultConstructor) var anObject = webpack_require(19); var aFunction = webpack_require(31); var SPECIES = webpack_require(34)(‘species’); module.exports = function (O, D) { var C = anObject(O).constructor; var S; return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S); };// }),/ 218 /// (function(module, exports, webpack_require) { ‘use strict’; var LIBRARY = webpack_require(29); var global = webpack_require(11); var ctx = webpack_require(30); var classof = webpack_require(82); var $export = webpack_require(15); var isObject = webpack_require(20); var aFunction = webpack_require(31); var anInstance = webpack_require(219); var forOf = webpack_require(220); var speciesConstructor = webpack_require(217); var task = webpack_require(221).set; var microtask = webpack_require(222)(); var newPromiseCapabilityModule = webpack_require(223); var perform = webpack_require(224); var userAgent = webpack_require(225); var promiseResolve = webpack_require(226); var PROMISE = ‘Promise’; var TypeError = global.TypeError; var process = global.process; var versions = process &amp;&amp; process.versions; var v8 = versions &amp;&amp; versions.v8 || ‘’; var $Promise = global[PROMISE]; var isNode = classof(process) == ‘process’; var empty = function () { / empty / }; var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper; var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f; var USE_NATIVE = !!function () { try { // correct subclassing with @@species support var promise = $Promise.resolve(1); var FakePromise = (promise.constructor = {})[webpack_require(34)(‘species’)] = function (exec) { exec(empty, empty); }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test return (isNode || typeof PromiseRejectionEvent == ‘function’) &amp;&amp; promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables // https://bugs.chromium.org/p/chromium/issues/detail?id=830565 // we can’t detect it synchronously, so just check versions &amp;&amp; v8.indexOf(‘6.6’) !== 0 &amp;&amp; userAgent.indexOf(‘Chrome/66’) === -1; } catch (e) { / empty / } }(); // helpers var isThenable = function (it) { var then; return isObject(it) &amp;&amp; typeof (then = it.then) == ‘function’ ? then : false; }; var notify = function (promise, isReject) { if (promise._n) return; promise._n = true; var chain = promise._c; microtask(function () { var value = promise._v; var ok = promise._s == 1; var i = 0; var run = function (reaction) { var handler = ok ? reaction.ok : reaction.fail; var resolve = reaction.resolve; var reject = reaction.reject; var domain = reaction.domain; var result, then, exited; try { if (handler) { if (!ok) { if (promise._h == 2) onHandleUnhandled(promise); promise._h = 1; } if (handler === true) result = value; else { if (domain) domain.enter(); result = handler(value); // may throw if (domain) { domain.exit(); exited = true; } } if (result === reaction.promise) { reject(TypeError(‘Promise-chain cycle’)); } else if (then = isThenable(result)) { then.call(result, resolve, reject); } else resolve(result); } else reject(value); } catch (e) { if (domain &amp;&amp; !exited) domain.exit(); reject(e); } }; while (chain.length &gt; i) run(chain[i++]); // variable length - can’t use forEach promise._c = []; promise._n = false; if (isReject &amp;&amp; !promise._h) onUnhandled(promise); }); }; var onUnhandled = function (promise) { task.call(global, function () { var value = promise._v; var unhandled = isUnhandled(promise); var result, handler, console; if (unhandled) { result = perform(function () { if (isNode) { process.emit(‘unhandledRejection’, value, promise); } else if (handler = global.onunhandledrejection) { handler({ promise: promise, reason: value }); } else if ((console = global.console) &amp;&amp; console.error) { console.error(‘Unhandled promise rejection’, value); } }); // Browsers should not trigger rejectionHandled event if it was handled here, NodeJS - should promise._h = isNode || isUnhandled(promise) ? 2 : 1; } promise._a = undefined; if (unhandled &amp;&amp; result.e) throw result.v; }); }; var isUnhandled = function (promise) { return promise._h !== 1 &amp;&amp; (promise._a || promise._c).length === 0; }; var onHandleUnhandled = function (promise) { task.call(global, function () { var handler; if (isNode) { process.emit(‘rejectionHandled’, promise); } else if (handler = global.onrejectionhandled) { handler({ promise: promise, reason: promise._v }); } }); }; var $reject = function (value) { var promise = this; if (promise._d) return; promise._d = true; promise = promise._w || promise; // unwrap promise._v = value; promise._s = 2; if (!promise._a) promise._a = promise._c.slice(); notify(promise, true); }; var $resolve = function (value) { var promise = this; var then; if (promise._d) return; promise._d = true; promise = promise._w || promise; // unwrap try { if (promise === value) throw TypeError(“Promise can’t be resolved itself”); if (then = isThenable(value)) { microtask(function () { var wrapper = { _w: promise, _d: false }; // wrap try { then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1)); } catch (e) { $reject.call(wrapper, e); } }); } else { promise._v = value; promise._s = 1; notify(promise, false); } } catch (e) { $reject.call({ _w: promise, _d: false }, e); // wrap } }; // constructor polyfill if (!USE_NATIVE) { // 25.4.3.1 Promise(executor) $Promise = function Promise(executor) { anInstance(this, $Promise, PROMISE, ‘_h’); aFunction(executor); Internal.call(this); try { executor(ctx($resolve, this, 1), ctx($reject, this, 1)); } catch (err) { $reject.call(this, err); } }; // eslint-disable-next-line no-unused-vars Internal = function Promise(executor) { this._c = []; // &lt;- awaiting reactions this._a = undefined; // &lt;- checked in isUnhandled reactions this._s = 0; // &lt;- state this._d = false; // &lt;- done this._v = undefined; // &lt;- value this._h = 0; // &lt;- rejection state, 0 - default, 1 - handled, 2 - unhandled this._n = false; // &lt;- notify }; Internal.prototype = webpack_require(227)($Promise.prototype, { // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected) then: function then(onFulfilled, onRejected) { var reaction = newPromiseCapability(speciesConstructor(this, $Promise)); reaction.ok = typeof onFulfilled == ‘function’ ? onFulfilled : true; reaction.fail = typeof onRejected == ‘function’ &amp;&amp; onRejected; reaction.domain = isNode ? process.domain : undefined; this._c.push(reaction); if (this._a) this._a.push(reaction); if (this._s) notify(this, false); return reaction.promise; }, // 25.4.5.1 Promise.prototype.catch(onRejected) ‘catch’: function (onRejected) { return this.then(undefined, onRejected); } }); OwnPromiseCapability = function () { var promise = new Internal(); this.promise = promise; this.resolve = ctx($resolve, promise, 1); this.reject = ctx($reject, promise, 1); }; newPromiseCapabilityModule.f = newPromiseCapability = function (C) { return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C); }; } $export($export.G + $export.W + $export.F !USE_NATIVE, { Promise: $Promise }); webpack_require(33)($Promise, PROMISE); webpack_require(201)(PROMISE); Wrapper = webpack_require(16)[PROMISE]; // statics $export($export.S + $export.F !USE_NATIVE, PROMISE, { // 25.4.4.5 Promise.reject(r) reject: function reject(r) { var capability = newPromiseCapability(this); var $$reject = capability.reject; $$reject(r); return capability.promise; } }); $export($export.S + $export.F (LIBRARY || !USE_NATIVE), PROMISE, { // 25.4.4.6 Promise.resolve(x) resolve: function resolve(x) { return promiseResolve(LIBRARY &amp;&amp; this === Wrapper ? $Promise : this, x); } }); $export($export.S + $export.F !(USE_NATIVE &amp;&amp; webpack_require(174)(function (iter) { $Promise.all(iter)‘catch’; })), PROMISE, { // 25.4.4.1 Promise.all(iterable) all: function all(iterable) { var C = this; var capability = newPromiseCapability(C); var resolve = capability.resolve; var reject = capability.reject; var result = perform(function () { var values = []; var index = 0; var remaining = 1; forOf(iterable, false, function (promise) { var $index = index++; var alreadyCalled = false; values.push(undefined); remaining++; C.resolve(promise).then(function (value) { if (alreadyCalled) return; alreadyCalled = true; values[$index] = value; –remaining || resolve(values); }, reject); }); –remaining || resolve(values); }); if (result.e) reject(result.v); return capability.promise; }, // 25.4.4.4 Promise.race(iterable) race: function race(iterable) { var C = this; var capability = newPromiseCapability(C); var reject = capability.reject; var result = perform(function () { forOf(iterable, false, function (promise) { C.resolve(promise).then(capability.resolve, reject); }); }); if (result.e) reject(result.v); return capability.promise; } });// }),/ 219 /// (function(module, exports) { module.exports = function (it, Constructor, name, forbiddenField) { if (!(it instanceof Constructor) || (forbiddenField !== undefined &amp;&amp; forbiddenField in it)) { throw TypeError(name + ‘: incorrect invocation!’); } return it; };// }),/ 220 /// (function(module, exports, webpack_require) { var ctx = webpack_require(30); var call = webpack_require(170); var isArrayIter = webpack_require(171); var anObject = webpack_require(19); var toLength = webpack_require(45); var getIterFn = webpack_require(173); var BREAK = {}; var RETURN = {}; var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) { var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable); var f = ctx(fn, that, entries ? 2 : 1); var index = 0; var length, step, iterator, result; if (typeof iterFn != ‘function’) throw TypeError(iterable + ‘ is not iterable!’); // fast case for arrays with default iterator if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length &gt; index; index++) { result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]); if (result === BREAK || result === RETURN) return result; } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) { result = call(iterator, f, step.value, entries); if (result === BREAK || result === RETURN) return result; } }; exports.BREAK = BREAK; exports.RETURN = RETURN;// }),/ 221 /// (function(module, exports, webpack_require) { var ctx = webpack_require(30); var invoke = webpack_require(85); var html = webpack_require(55); var cel = webpack_require(22); var global = webpack_require(11); var process = global.process; var setTask = global.setImmediate; var clearTask = global.clearImmediate; var MessageChannel = global.MessageChannel; var Dispatch = global.Dispatch; var counter = 0; var queue = {}; var ONREADYSTATECHANGE = ‘onreadystatechange’; var defer, channel, port; var run = function () { var id = +this; // eslint-disable-next-line no-prototype-builtins if (queue.hasOwnProperty(id)) { var fn = queue[id]; delete queue[id]; fn(); } }; var listener = function (event) { run.call(event.data); }; // Node.js 0.9+ &amp; IE10+ has setImmediate, otherwise: if (!setTask || !clearTask) { setTask = function setImmediate(fn) { var args = []; var i = 1; while (arguments.length &gt; i) args.push(arguments[i++]); queue[++counter] = function () { // eslint-disable-next-line no-new-func invoke(typeof fn == ‘function’ ? fn : Function(fn), args); }; defer(counter); return counter; }; clearTask = function clearImmediate(id) { delete queue[id]; }; // Node.js 0.8- if (webpack_require(42)(process) == ‘process’) { defer = function (id) { process.nextTick(ctx(run, id, 1)); }; // Sphere (JS game engine) Dispatch API } else if (Dispatch &amp;&amp; Dispatch.now) { defer = function (id) { Dispatch.now(ctx(run, id, 1)); }; // Browsers with MessageChannel, includes WebWorkers } else if (MessageChannel) { channel = new MessageChannel(); port = channel.port2; channel.port1.onmessage = listener; defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers // IE8 has postMessage, but it’s sync &amp; typeof its postMessage is ‘object’ } else if (global.addEventListener &amp;&amp; typeof postMessage == ‘function’ &amp;&amp; !global.importScripts) { defer = function (id) { global.postMessage(id + ‘’, ‘‘); }; global.addEventListener(‘message’, listener, false); // IE8- } else if (ONREADYSTATECHANGE in cel(‘script’)) { defer = function (id) { html.appendChild(cel(‘script’))[ONREADYSTATECHANGE] = function () { html.removeChild(this); run.call(id); }; }; // Rest old browsers } else { defer = function (id) { setTimeout(ctx(run, id, 1), 0); }; } } module.exports = { set: setTask, clear: clearTask };/*/ }),/ 222 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var macrotask = webpack_require(221).set; var Observer = global.MutationObserver || global.WebKitMutationObserver; var process = global.process; var Promise = global.Promise; var isNode = webpack_require(42)(process) == ‘process’; module.exports = function () { var head, last, notify; var flush = function () { var parent, fn; if (isNode &amp;&amp; (parent = process.domain)) parent.exit(); while (head) { fn = head.fn; head = head.next; try { fn(); } catch (e) { if (head) notify(); else last = undefined; throw e; } } last = undefined; if (parent) parent.enter(); }; // Node.js if (isNode) { notify = function () { process.nextTick(flush); }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339 } else if (Observer &amp;&amp; !(global.navigator &amp;&amp; global.navigator.standalone)) { var toggle = true; var node = document.createTextNode(‘’); new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new notify = function () { node.data = toggle = !toggle; }; // environments with maybe non-completely correct, but existent Promise } else if (Promise &amp;&amp; Promise.resolve) { // Promise.resolve without an argument throws an error in LG WebOS 2 var promise = Promise.resolve(undefined); notify = function () { promise.then(flush); }; // for other environments - macrotask based on: // - setImmediate // - MessageChannel // - window.postMessag // - onreadystatechange // - setTimeout } else { notify = function () { // strange IE + webpack dev server bug - use .call(global) macrotask.call(global, flush); }; } return function (fn) { var task = { fn: fn, next: undefined }; if (last) last.next = task; if (!head) { head = task; notify(); } last = task; }; };// }),/ 223 /// (function(module, exports, webpack_require) { ‘use strict’; // 25.4.1.5 NewPromiseCapability(C) var aFunction = webpack_require(31); function PromiseCapability(C) { var resolve, reject; this.promise = new C(function ($$resolve, $$reject) { if (resolve !== undefined || reject !== undefined) throw TypeError(‘Bad Promise constructor’); resolve = $$resolve; reject = $$reject; }); this.resolve = aFunction(resolve); this.reject = aFunction(reject); } module.exports.f = function (C) { return new PromiseCapability(C); };// }),/ 224 /// (function(module, exports) { module.exports = function (exec) { try { return { e: false, v: exec() }; } catch (e) { return { e: true, v: e }; } };// }),/ 225 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var navigator = global.navigator; module.exports = navigator &amp;&amp; navigator.userAgent || ‘’;// }),/ 226 /// (function(module, exports, webpack_require) { var anObject = webpack_require(19); var isObject = webpack_require(20); var newPromiseCapability = webpack_require(223); module.exports = function (C, x) { anObject(C); if (isObject(x) &amp;&amp; x.constructor === C) return x; var promiseCapability = newPromiseCapability.f(C); var resolve = promiseCapability.resolve; resolve(x); return promiseCapability.promise; };// }),/ 227 /// (function(module, exports, webpack_require) { var redefine = webpack_require(25); module.exports = function (target, src, safe) { for (var key in src) redefine(target, key, src[key], safe); return target; };// }),/ 228 /// (function(module, exports, webpack_require) { ‘use strict’; var strong = webpack_require(229); var validate = webpack_require(230); var MAP = ‘Map’; // 23.1 Map Objects module.exports = webpack_require(231)(MAP, function (get) { return function Map() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.1.3.6 Map.prototype.get(key) get: function get(key) { var entry = strong.getEntry(validate(this, MAP), key); return entry &amp;&amp; entry.v; }, // 23.1.3.9 Map.prototype.set(key, value) set: function set(key, value) { return strong.def(validate(this, MAP), key === 0 ? 0 : key, value); } }, strong, true);// }),/ 229 /// (function(module, exports, webpack_require) { ‘use strict’; var dP = webpack_require(18).f; var create = webpack_require(53); var redefineAll = webpack_require(227); var ctx = webpack_require(30); var anInstance = webpack_require(219); var forOf = webpack_require(220); var $iterDefine = webpack_require(136); var step = webpack_require(203); var setSpecies = webpack_require(201); var DESCRIPTORS = webpack_require(13); var fastKey = webpack_require(32).fastKey; var validate = webpack_require(230); var SIZE = DESCRIPTORS ? ‘_s’ : ‘size’; var getEntry = function (that, key) { // fast case var index = fastKey(key); var entry; if (index !== ‘F’) return that._i[index]; // frozen object case for (entry = that._f; entry; entry = entry.n) { if (entry.k == key) return entry; } }; module.exports = { getConstructor: function (wrapper, NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, NAME, ‘_i’); that._t = NAME; // collection type that._i = create(null); // index that._f = undefined; // first entry that._l = undefined; // last entry that[SIZE] = 0; // size if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); }); redefineAll(C.prototype, { // 23.1.3.1 Map.prototype.clear() // 23.2.3.2 Set.prototype.clear() clear: function clear() { for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) { entry.r = true; if (entry.p) entry.p = entry.p.n = undefined; delete data[entry.i]; } that._f = that._l = undefined; that[SIZE] = 0; }, // 23.1.3.3 Map.prototype.delete(key) // 23.2.3.4 Set.prototype.delete(value) ‘delete’: function (key) { var that = validate(this, NAME); var entry = getEntry(that, key); if (entry) { var next = entry.n; var prev = entry.p; delete that._i[entry.i]; entry.r = true; if (prev) prev.n = next; if (next) next.p = prev; if (that._f == entry) that._f = next; if (that._l == entry) that._l = prev; that[SIZE]–; } return !!entry; }, // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined) // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined) forEach: function forEach(callbackfn / , that = undefined /) { validate(this, NAME); var f = ctx(callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined, 3); var entry; while (entry = entry ? entry.n : this._f) { f(entry.v, entry.k, this); // revert to the last existing entry while (entry &amp;&amp; entry.r) entry = entry.p; } }, // 23.1.3.7 Map.prototype.has(key) // 23.2.3.7 Set.prototype.has(value) has: function has(key) { return !!getEntry(validate(this, NAME), key); } }); if (DESCRIPTORS) dP(C.prototype, ‘size’, { get: function () { return validate(this, NAME)[SIZE]; } }); return C; }, def: function (that, key, value) { var entry = getEntry(that, key); var prev, index; // change existing entry if (entry) { entry.v = value; // create new entry } else { that._l = entry = { i: index = fastKey(key, true), // &lt;- index k: key, // &lt;- key v: value, // &lt;- value p: prev = that._l, // &lt;- previous entry n: undefined, // &lt;- next entry r: false // &lt;- removed }; if (!that._f) that._f = entry; if (prev) prev.n = entry; that[SIZE]++; // add to index if (index !== ‘F’) that._i[index] = entry; } return that; }, getEntry: getEntry, setStrong: function (C, NAME, IS_MAP) { // add .keys, .values, .entries, [@@iterator] // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11 $iterDefine(C, NAME, function (iterated, kind) { this._t = validate(iterated, NAME); // target this._k = kind; // kind this._l = undefined; // previous }, function () { var that = this; var kind = that._k; var entry = that._l; // revert to the last existing entry while (entry &amp;&amp; entry.r) entry = entry.p; // get next entry if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) { // or finish the iteration that._t = undefined; return step(1); } // return step by kind if (kind == ‘keys’) return step(0, entry.k); if (kind == ‘values’) return step(0, entry.v); return step(0, [entry.k, entry.v]); }, IS_MAP ? ‘entries’ : ‘values’, !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2 setSpecies(NAME); } };// }),/ 230 /// (function(module, exports, webpack_require) { var isObject = webpack_require(20); module.exports = function (it, TYPE) { if (!isObject(it) || it._t !== TYPE) throw TypeError(‘Incompatible receiver, ‘ + TYPE + ‘ required!’); return it; };// }),/ 231 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var $export = webpack_require(15); var redefine = webpack_require(25); var redefineAll = webpack_require(227); var meta = webpack_require(32); var forOf = webpack_require(220); var anInstance = webpack_require(219); var isObject = webpack_require(20); var fails = webpack_require(14); var $iterDetect = webpack_require(174); var setToStringTag = webpack_require(33); var inheritIfRequired = webpack_require(95); module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) { var Base = global[NAME]; var C = Base; var ADDER = IS_MAP ? ‘set’ : ‘add’; var proto = C &amp;&amp; C.prototype; var O = {}; var fixMethod = function (KEY) { var fn = proto[KEY]; redefine(proto, KEY, KEY == ‘delete’ ? function (a) { return IS_WEAK &amp;&amp; !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘has’ ? function has(a) { return IS_WEAK &amp;&amp; !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘get’ ? function get(a) { return IS_WEAK &amp;&amp; !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a); } : KEY == ‘add’ ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; } : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; } ); }; if (typeof C != ‘function’ || !(IS_WEAK || proto.forEach &amp;&amp; !fails(function () { new C().entries().next(); }))) { // create collection constructor C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER); redefineAll(C.prototype, methods); meta.NEED = true; } else { var instance = new C(); // early implementations not supports chaining var HASNT_CHAINING = instanceADDER != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); }); // most early implementations doesn’t supports iterables, most modern - not close it correctly var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new // for early implementations -0 and +0 not the same var BUGGY_ZERO = !IS_WEAK &amp;&amp; fails(function () { // V8 ~ Chromium 42- fails only with 5+ elements var $instance = new C(); var index = 5; while (index–) $instanceADDER; return !$instance.has(-0); }); if (!ACCEPT_ITERABLES) { C = wrapper(function (target, iterable) { anInstance(target, C, NAME); var that = inheritIfRequired(new Base(), target, C); if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); return that; }); C.prototype = proto; proto.constructor = C; } if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) { fixMethod(‘delete’); fixMethod(‘has’); IS_MAP &amp;&amp; fixMethod(‘get’); } if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method if (IS_WEAK &amp;&amp; proto.clear) delete proto.clear; } setToStringTag(C, NAME); O[NAME] = C; $export($export.G + $export.W + $export.F (C != Base), O); if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP); return C; };/*/ }),/ 232 /// (function(module, exports, webpack_require) { ‘use strict’; var strong = webpack_require(229); var validate = webpack_require(230); var SET = ‘Set’; // 23.2 Set Objects module.exports = webpack_require(231)(SET, function (get) { return function Set() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.2.3.1 Set.prototype.add(value) add: function add(value) { return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value); } }, strong);// }),/ 233 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var each = webpack_require(181)(0); var redefine = webpack_require(25); var meta = webpack_require(32); var assign = webpack_require(76); var weak = webpack_require(234); var isObject = webpack_require(20); var validate = webpack_require(230); var NATIVE_WEAK_MAP = webpack_require(230); var IS_IE11 = !global.ActiveXObject &amp;&amp; ‘ActiveXObject’ in global; var WEAK_MAP = ‘WeakMap’; var getWeak = meta.getWeak; var isExtensible = Object.isExtensible; var uncaughtFrozenStore = weak.ufstore; var InternalMap; var wrapper = function (get) { return function WeakMap() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }; var methods = { // 23.3.3.3 WeakMap.prototype.get(key) get: function get(key) { if (isObject(key)) { var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key); return data ? data[this._i] : undefined; } }, // 23.3.3.5 WeakMap.prototype.set(key, value) set: function set(key, value) { return weak.def(validate(this, WEAK_MAP), key, value); } }; // 23.3 WeakMap Objects var $WeakMap = module.exports = webpack_require(231)(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix if (NATIVE_WEAK_MAP &amp;&amp; IS_IE11) { InternalMap = weak.getConstructor(wrapper, WEAK_MAP); assign(InternalMap.prototype, methods); meta.NEED = true; each([‘delete’, ‘has’, ‘get’, ‘set’], function (key) { var proto = $WeakMap.prototype; var method = proto[key]; redefine(proto, key, function (a, b) { // store frozen objects on internal weakmap shim if (isObject(a) &amp;&amp; !isExtensible(a)) { if (!this._f) this._f = new InternalMap(); var result = this._fkey; return key == ‘set’ ? this : result; // store all the rest on native weakmap } return method.call(this, a, b); }); }); }// }),/ 234 /// (function(module, exports, webpack_require) { ‘use strict’; var redefineAll = webpack_require(227); var getWeak = webpack_require(32).getWeak; var anObject = webpack_require(19); var isObject = webpack_require(20); var anInstance = webpack_require(219); var forOf = webpack_require(220); var createArrayMethod = webpack_require(181); var $has = webpack_require(12); var validate = webpack_require(230); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var id = 0; // fallback for uncaught frozen keys var uncaughtFrozenStore = function (that) { return that._l || (that._l = new UncaughtFrozenStore()); }; var UncaughtFrozenStore = function () { this.a = []; }; var findUncaughtFrozen = function (store, key) { return arrayFind(store.a, function (it) { return it[0] === key; }); }; UncaughtFrozenStore.prototype = { get: function (key) { var entry = findUncaughtFrozen(this, key); if (entry) return entry[1]; }, has: function (key) { return !!findUncaughtFrozen(this, key); }, set: function (key, value) { var entry = findUncaughtFrozen(this, key); if (entry) entry[1] = value; else this.a.push([key, value]); }, ‘delete’: function (key) { var index = arrayFindIndex(this.a, function (it) { return it[0] === key; }); if (~index) this.a.splice(index, 1); return !!~index; } }; module.exports = { getConstructor: function (wrapper, NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, NAME, ‘_i’); that._t = NAME; // collection type that._i = id++; // collection id that._l = undefined; // leak store for uncaught frozen objects if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that); }); redefineAll(C.prototype, { // 23.3.3.2 WeakMap.prototype.delete(key) // 23.4.3.3 WeakSet.prototype.delete(value) ‘delete’: function (key) { if (!isObject(key)) return false; var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, NAME))‘delete’; return data &amp;&amp; $has(data, this._i) &amp;&amp; delete data[this._i]; }, // 23.3.3.4 WeakMap.prototype.has(key) // 23.4.3.4 WeakSet.prototype.has(value) has: function has(key) { if (!isObject(key)) return false; var data = getWeak(key); if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key); return data &amp;&amp; $has(data, this._i); } }); return C; }, def: function (that, key, value) { var data = getWeak(anObject(key), true); if (data === true) uncaughtFrozenStore(that).set(key, value); else data[that._i] = value; return that; }, ufstore: uncaughtFrozenStore };// }),/ 235 /// (function(module, exports, webpack_require) { ‘use strict’; var weak = webpack_require(234); var validate = webpack_require(230); var WEAK_SET = ‘WeakSet’; // 23.4 WeakSet Objects webpack_require(231)(WEAK_SET, function (get) { return function WeakSet() { return get(this, arguments.length &gt; 0 ? arguments[0] : undefined); }; }, { // 23.4.3.1 WeakSet.prototype.add(value) add: function add(value) { return weak.def(validate(this, WEAK_SET), value, true); } }, weak, false, true);// }),/ 236 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var $typed = webpack_require(237); var buffer = webpack_require(238); var anObject = webpack_require(19); var toAbsoluteIndex = webpack_require(47); var toLength = webpack_require(45); var isObject = webpack_require(20); var ArrayBuffer = webpack_require(11).ArrayBuffer; var speciesConstructor = webpack_require(217); var $ArrayBuffer = buffer.ArrayBuffer; var $DataView = buffer.DataView; var $isView = $typed.ABV &amp;&amp; ArrayBuffer.isView; var $slice = $ArrayBuffer.prototype.slice; var VIEW = $typed.VIEW; var ARRAY_BUFFER = ‘ArrayBuffer’; $export($export.G + $export.W + $export.F (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer }); $export($export.S + $export.F !$typed.CONSTR, ARRAY_BUFFER, { // 24.1.3.1 ArrayBuffer.isView(arg) isView: function isView(it) { return $isView &amp;&amp; $isView(it) || isObject(it) &amp;&amp; VIEW in it; } }); $export($export.P + $export.U + $export.F webpack_require(14)(function () { return !new $ArrayBuffer(2).slice(1, undefined).byteLength; }), ARRAY_BUFFER, { // 24.1.4.3 ArrayBuffer.prototype.slice(start, end) slice: function slice(start, end) { if ($slice !== undefined &amp;&amp; end === undefined) return $slice.call(anObject(this), start); // FF fix var len = anObject(this).byteLength; var first = toAbsoluteIndex(start, len); var fin = toAbsoluteIndex(end === undefined ? len : end, len); var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first)); var viewS = new $DataView(this); var viewT = new $DataView(result); var index = 0; while (first &lt; fin) { viewT.setUint8(index++, viewS.getUint8(first++)); } return result; } }); webpack_require(201)(ARRAY_BUFFER);/*/ }),/ 237 /// (function(module, exports, webpack_require) { var global = webpack_require(11); var hide = webpack_require(17); var uid = webpack_require(26); var TYPED = uid(‘typed_array’); var VIEW = uid(‘view’); var ABV = !!(global.ArrayBuffer &amp;&amp; global.DataView); var CONSTR = ABV; var i = 0; var l = 9; var Typed; var TypedArrayConstructors = ( ‘Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array’ ).split(‘,’); while (i &lt; l) { if (Typed = global[TypedArrayConstructors[i++]]) { hide(Typed.prototype, TYPED, true); hide(Typed.prototype, VIEW, true); } else CONSTR = false; } module.exports = { ABV: ABV, CONSTR: CONSTR, TYPED: TYPED, VIEW: VIEW };// }),/ 238 /// (function(module, exports, webpack_require) { ‘use strict’; var global = webpack_require(11); var DESCRIPTORS = webpack_require(13); var LIBRARY = webpack_require(29); var $typed = webpack_require(237); var hide = webpack_require(17); var redefineAll = webpack_require(227); var fails = webpack_require(14); var anInstance = webpack_require(219); var toInteger = webpack_require(46); var toLength = webpack_require(45); var toIndex = webpack_require(239); var gOPN = webpack_require(57).f; var dP = webpack_require(18).f; var arrayFill = webpack_require(197); var setToStringTag = webpack_require(33); var ARRAY_BUFFER = ‘ArrayBuffer’; var DATA_VIEW = ‘DataView’; var PROTOTYPE = ‘prototype’; var WRONG_LENGTH = ‘Wrong length!’; var WRONG_INDEX = ‘Wrong index!’; var $ArrayBuffer = global[ARRAY_BUFFER]; var $DataView = global[DATA_VIEW]; var Math = global.Math; var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names var Infinity = global.Infinity; var BaseBuffer = $ArrayBuffer; var abs = Math.abs; var pow = Math.pow; var floor = Math.floor; var log = Math.log; var LN2 = Math.LN2; var BUFFER = ‘buffer’; var BYTE_LENGTH = ‘byteLength’; var BYTE_OFFSET = ‘byteOffset’; var $BUFFER = DESCRIPTORS ? ‘_b’ : BUFFER; var $LENGTH = DESCRIPTORS ? ‘_l’ : BYTE_LENGTH; var $OFFSET = DESCRIPTORS ? ‘_o’ : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754 function packIEEE754(value, mLen, nBytes) { var buffer = new Array(nBytes); var eLen = nBytes 8 - mLen - 1; var eMax = (1 &lt;&lt; eLen) - 1; var eBias = eMax &gt;&gt; 1; var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0; var i = 0; var s = value &lt; 0 || value === 0 &amp;&amp; 1 / value &lt; 0 ? 1 : 0; var e, m, c; value = abs(value); // eslint-disable-next-line no-self-compare if (value != value || value === Infinity) { // eslint-disable-next-line no-self-compare m = value != value ? 1 : 0; e = eMax; } else { e = floor(log(value) / LN2); if (value (c = pow(2, -e)) &lt; 1) { e–; c = 2; } if (e + eBias &gt;= 1) { value += rt / c; } else { value += rt pow(2, 1 - eBias); } if (value c &gt;= 2) { e++; c /= 2; } if (e + eBias &gt;= eMax) { m = 0; e = eMax; } else if (e + eBias &gt;= 1) { m = (value c - 1) pow(2, mLen); e = e + eBias; } else { m = value pow(2, eBias - 1) pow(2, mLen); e = 0; } } for (; mLen &gt;= 8; buffer[i++] = m &amp; 255, m /= 256, mLen -= 8); e = e &lt;&lt; mLen | m; eLen += mLen; for (; eLen &gt; 0; buffer[i++] = e &amp; 255, e /= 256, eLen -= 8); buffer[–i] |= s 128; return buffer; } function unpackIEEE754(buffer, mLen, nBytes) { var eLen = nBytes 8 - mLen - 1; var eMax = (1 &lt;&lt; eLen) - 1; var eBias = eMax &gt;&gt; 1; var nBits = eLen - 7; var i = nBytes - 1; var s = buffer[i–]; var e = s &amp; 127; var m; s &gt;&gt;= 7; for (; nBits &gt; 0; e = e 256 + buffer[i], i–, nBits -= 8); m = e &amp; (1 &lt;&lt; -nBits) - 1; e &gt;&gt;= -nBits; nBits += mLen; for (; nBits &gt; 0; m = m 256 + buffer[i], i–, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) m pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] &lt;&lt; 24 | bytes[2] &lt;&lt; 16 | bytes[1] &lt;&lt; 8 | bytes[0]; } function packI8(it) { return [it &amp; 0xff]; } function packI16(it) { return [it &amp; 0xff, it &gt;&gt; 8 &amp; 0xff]; } function packI32(it) { return [it &amp; 0xff, it &gt;&gt; 8 &amp; 0xff, it &gt;&gt; 16 &amp; 0xff, it &gt;&gt; 24 &amp; 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes &gt; view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes &gt; view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i &lt; bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset &lt; 0 || offset &gt; bufferLength) throw RangeError(‘Wrong offset!’); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength &gt; bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, ‘_l’); addGetter($DataView, BUFFER, ‘_b’); addGetter($DataView, BYTE_LENGTH, ‘_l’); addGetter($DataView, BYTE_OFFSET, ‘_o’); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] &lt;&lt; 24 &gt;&gt; 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset / , littleEndian /) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] &lt;&lt; 8 | bytes[0]) &lt;&lt; 16 &gt;&gt; 16; }, getUint16: function getUint16(byteOffset / , littleEndian /) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] &lt;&lt; 8 | bytes[0]; }, getInt32: function getInt32(byteOffset / , littleEndian /) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset / , littleEndian /) { return unpackI32(get(this, 4, byteOffset, arguments[1])) &gt;&gt;&gt; 0; }, getFloat32: function getFloat32(byteOffset / , littleEndian /) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset / , littleEndian /) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value / , littleEndian /) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value / , littleEndian /) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value / , littleEndian /) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value / , littleEndian /) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length &gt; j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value &lt;&lt; 24 &gt;&gt; 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value &lt;&lt; 24 &gt;&gt; 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView;/*/ }),/ 239 /// (function(module, exports, webpack_require) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = webpack_require(46); var toLength = webpack_require(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError(‘Wrong length!’); return length; };// }),/ 240 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); $export($export.G + $export.W + $export.F !webpack_require(237).ABV, { DataView: webpack_require(238).DataView });/*/ }),/ 241 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int8’, 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 242 /// (function(module, exports, webpack_require) { ‘use strict’; if (webpack_require(13)) { var LIBRARY = webpack_require(29); var global = webpack_require(11); var fails = webpack_require(14); var $export = webpack_require(15); var $typed = webpack_require(237); var $buffer = webpack_require(238); var ctx = webpack_require(30); var anInstance = webpack_require(219); var propertyDesc = webpack_require(24); var hide = webpack_require(17); var redefineAll = webpack_require(227); var toInteger = webpack_require(46); var toLength = webpack_require(45); var toIndex = webpack_require(239); var toAbsoluteIndex = webpack_require(47); var toPrimitive = webpack_require(23); var has = webpack_require(12); var classof = webpack_require(82); var isObject = webpack_require(20); var toObject = webpack_require(65); var isArrayIter = webpack_require(171); var create = webpack_require(53); var getPrototypeOf = webpack_require(66); var gOPN = webpack_require(57).f; var getIterFn = webpack_require(173); var uid = webpack_require(26); var wks = webpack_require(34); var createArrayMethod = webpack_require(181); var createArrayIncludes = webpack_require(44); var speciesConstructor = webpack_require(217); var ArrayIterators = webpack_require(202); var Iterators = webpack_require(137); var $iterDetect = webpack_require(174); var setSpecies = webpack_require(201); var arrayFill = webpack_require(197); var arrayCopyWithin = webpack_require(194); var $DP = webpack_require(18); var $GOPD = webpack_require(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = ‘ArrayBuffer’; var SHARED_BUFFER = ‘Shared’ + ARRAY_BUFFER; var BYTES_PER_ELEMENT = ‘BYTES_PER_ELEMENT’; var PROTOTYPE = ‘prototype’; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks(‘iterator’); var TAG = wks(‘toStringTag’); var TYPED_CONSTRUCTOR = uid(‘typed_constructor’); var DEF_CONSTRUCTOR = uid(‘def_constructor’); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = ‘Wrong length!’; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array &amp;&amp; !!Uint8Array[PROTOTYPE].set &amp;&amp; fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset &lt; 0 || offset % BYTES) throw RangeError(‘Wrong offset!’); return offset; }; var validate = function (it) { if (isObject(it) &amp;&amp; TYPED_ARRAY in it) return it; throw TypeError(it + ‘ is not a typed array!’); }; var allocate = function (C, length) { if (!(isObject(C) &amp;&amp; TYPED_CONSTRUCTOR in C)) { throw TypeError(‘It is not a typed array constructor!’); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length &gt; index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source / , mapfn, thisArg /) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen &gt; 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined &amp;&amp; !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping &amp;&amp; aLen &gt; 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length &gt; i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/ …items /) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length &gt; index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array &amp;&amp; fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start / , end /) { return arrayCopyWithin.call(validate(this), target, start, arguments.length &gt; 2 ? arguments[2] : undefined); }, every: function every(callbackfn / , thisArg /) { return arrayEvery(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, fill: function fill(value / , start, end /) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn / , thisArg /) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined)); }, find: function find(predicate / , thisArg /) { return arrayFind(validate(this), predicate, arguments.length &gt; 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate / , thisArg /) { return arrayFindIndex(validate(this), predicate, arguments.length &gt; 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn / , thisArg /) { arrayForEach(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement / , fromIndex /) { return arrayIndexOf(validate(this), searchElement, arguments.length &gt; 1 ? arguments[1] : undefined); }, includes: function includes(searchElement / , fromIndex /) { return arrayIncludes(validate(this), searchElement, arguments.length &gt; 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement / , fromIndex /) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn / , thisArg /) { return $map(validate(this), mapfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn / , initialValue /) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn / , initialValue /) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index &lt; middle) { value = that[index]; that[index++] = that[–length]; that[length] = value; } return that; }, some: function some(callbackfn / , thisArg /) { return arraySome(validate(this), callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike / , offset /) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset &gt; length) throw RangeError(WRONG_LENGTH); while (index &lt; len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) &amp;&amp; target[TYPED_ARRAY] &amp;&amp; typeof key != ‘symbol’ &amp;&amp; key in target &amp;&amp; String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) &amp;&amp; isObject(desc) &amp;&amp; has(desc, ‘value’) &amp;&amp; !has(desc, ‘get’) &amp;&amp; !has(desc, ‘set’) // TODO: add validation descriptor w/o calling accessors &amp;&amp; !desc.configurable &amp;&amp; (!has(desc, ‘writable’) || desc.writable) &amp;&amp; (!has(desc, ‘enumerable’) || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F !ALL_CONSTRUCTORS, ‘Object’, { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { / noop / }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, ‘buffer’, ‘b’); addGetter($TypedArrayPrototype$, ‘byteOffset’, ‘o’); addGetter($TypedArrayPrototype$, ‘byteLength’, ‘l’); addGetter($TypedArrayPrototype$, ‘length’, ‘e’); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? ‘Clamped’ : ‘’) + ‘Array’; var GETTER = ‘get’ + KEY; var SETTER = ‘set’ + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray &amp;&amp; getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray &amp;&amp; TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) &lt; 0 ? 0 : value &gt; 0xff ? 0xff : value &amp; 0xff; data.vSETTER; }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, ‘_d’); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength &lt; 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) BYTES; if (byteLength + offset &gt; $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, ‘_d’, { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index &lt; length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, ‘constructor’, TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // ws module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator &amp;&amp; ($nativeIterator.name == ‘values’ || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY &amp;&amp; TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY &amp;&amp; !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { / empty / };/*/ }),/ 243 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint8’, 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 244 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint8’, 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true);// }),/ 245 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int16’, 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 246 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint16’, 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 247 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Int32’, 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 248 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Uint32’, 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 249 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Float32’, 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 250 /// (function(module, exports, webpack_require) { webpack_require(242)(‘Float64’, 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; });// }),/ 251 /// (function(module, exports, webpack_require) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = webpack_require(15); var aFunction = webpack_require(31); var anObject = webpack_require(19); var rApply = (webpack_require(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F !webpack_require(14)(function () { rApply(function () { / empty / }); }), ‘Reflect’, { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } });/*/ }),/ 252 /// (function(module, exports, webpack_require) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = webpack_require(15); var create = webpack_require(53); var aFunction = webpack_require(31); var anObject = webpack_require(19); var isObject = webpack_require(20); var fails = webpack_require(14); var bind = webpack_require(84); var rConstruct = (webpack_require(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as new.target, but does not create this from it var NEW_TARGET_BUG = fails(function () { function F() { / empty / } return !(rConstruct(function () { / empty / }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { / empty / }); }); $export($export.S + $export.F (NEW_TARGET_BUG || ARGS_BUG), ‘Reflect’, { construct: function construct(Target, args / , newTarget /) { aFunction(Target); anObject(args); var newTarget = arguments.length &lt; 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG &amp;&amp; !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } });/*/ }),/ 253 /// (function(module, exports, webpack_require) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = webpack_require(18); var $export = webpack_require(15); var anObject = webpack_require(19); var toPrimitive = webpack_require(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F webpack_require(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), ‘Reflect’, { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } });/*/ }),/ 254 /// (function(module, exports, webpack_require) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = webpack_require(15); var gOPD = webpack_require(58).f; var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc &amp;&amp; !desc.configurable ? false : delete target[propertyKey]; } });// }),/ 255 /// (function(module, exports, webpack_require) { ‘use strict’; // 26.1.5 Reflect.enumerate(target) var $export = webpack_require(15); var anObject = webpack_require(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; webpack_require(138)(Enumerate, ‘Object’, function () { var that = this; var keys = that._k; var key; do { if (that._i &gt;= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, ‘Reflect’, { enumerate: function enumerate(target) { return new Enumerate(target); } });// }),/ 256 /// (function(module, exports, webpack_require) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = webpack_require(58); var getPrototypeOf = webpack_require(66); var has = webpack_require(12); var $export = webpack_require(15); var isObject = webpack_require(20); var anObject = webpack_require(19); function get(target, propertyKey / , receiver /) { var receiver = arguments.length &lt; 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, ‘value’) ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, ‘Reflect’, { get: get });// }),/ 257 /// (function(module, exports, webpack_require) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = webpack_require(58); var $export = webpack_require(15); var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } });// }),/ 258 /// (function(module, exports, webpack_require) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = webpack_require(15); var getProto = webpack_require(66); var anObject = webpack_require(19); $export($export.S, ‘Reflect’, { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } });// }),/ 259 /// (function(module, exports, webpack_require) { // 26.1.9 Reflect.has(target, propertyKey) var $export = webpack_require(15); $export($export.S, ‘Reflect’, { has: function has(target, propertyKey) { return propertyKey in target; } });// }),/ 260 /// (function(module, exports, webpack_require) { // 26.1.10 Reflect.isExtensible(target) var $export = webpack_require(15); var anObject = webpack_require(19); var $isExtensible = Object.isExtensible; $export($export.S, ‘Reflect’, { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } });// }),/ 261 /// (function(module, exports, webpack_require) { // 26.1.11 Reflect.ownKeys(target) var $export = webpack_require(15); $export($export.S, ‘Reflect’, { ownKeys: webpack_require(262) });// }),/ 262 /// (function(module, exports, webpack_require) { // all object keys, includes non-enumerable and symbols var gOPN = webpack_require(57); var gOPS = webpack_require(50); var anObject = webpack_require(19); var Reflect = webpack_require(11).Reflect; module.exports = Reflect &amp;&amp; Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; };// }),/ 263 /// (function(module, exports, webpack_require) { // 26.1.12 Reflect.preventExtensions(target) var $export = webpack_require(15); var anObject = webpack_require(19); var $preventExtensions = Object.preventExtensions; $export($export.S, ‘Reflect’, { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } });// }),/ 264 /// (function(module, exports, webpack_require) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = webpack_require(18); var gOPD = webpack_require(58); var getPrototypeOf = webpack_require(66); var has = webpack_require(12); var $export = webpack_require(15); var createDesc = webpack_require(24); var anObject = webpack_require(19); var isObject = webpack_require(20); function set(target, propertyKey, V / , receiver /) { var receiver = arguments.length &lt; 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, ‘value’)) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, ‘Reflect’, { set: set });// }),/ 265 /// (function(module, exports, webpack_require) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = webpack_require(15); var setProto = webpack_require(80); if (setProto) $export($export.S, ‘Reflect’, { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } });// }),/ 266 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/Array.prototype.includes var $export = webpack_require(15); var $includes = webpack_require(44)(true); $export($export.P, ‘Array’, { includes: function includes(el / , fromIndex = 0 /) { return $includes(this, el, arguments.length &gt; 1 ? arguments[1] : undefined); } }); webpack_require(195)(‘includes’);// }),/ 267 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = webpack_require(15); var flattenIntoArray = webpack_require(268); var toObject = webpack_require(65); var toLength = webpack_require(45); var aFunction = webpack_require(31); var arraySpeciesCreate = webpack_require(182); $export($export.P, ‘Array’, { flatMap: function flatMap(callbackfn / , thisArg /) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); webpack_require(195)(‘flatMap’);// }),/ 268 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = webpack_require(52); var isObject = webpack_require(20); var toLength = webpack_require(45); var ctx = webpack_require(30); var IS_CONCAT_SPREADABLE = webpack_require(34)(‘isConcatSpreadable’); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex &lt; sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable &amp;&amp; depth &gt; 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex &gt;= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray;// }),/ 269 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = webpack_require(15); var flattenIntoArray = webpack_require(268); var toObject = webpack_require(65); var toLength = webpack_require(45); var toInteger = webpack_require(46); var arraySpeciesCreate = webpack_require(182); $export($export.P, ‘Array’, { flatten: function flatten(/ depthArg = 1 /) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); webpack_require(195)(‘flatten’);// }),/ 270 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/mathiasbynens/String.prototype.at var $export = webpack_require(15); var $at = webpack_require(135)(true); $export($export.P, ‘String’, { at: function at(pos) { return $at(this, pos); } });// }),/ 271 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-string-pad-start-end var $export = webpack_require(15); var $pad = webpack_require(272); var userAgent = webpack_require(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10.\d+(.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F WEBKIT_BUG, ‘String’, { padStart: function padStart(maxLength / , fillString = ‘ ‘ /) { return $pad(this, maxLength, arguments.length &gt; 1 ? arguments[1] : undefined, true); } });/*/ }),/ 272 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = webpack_require(45); var repeat = webpack_require(98); var defined = webpack_require(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ‘ ‘ : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength &lt;= stringLength || fillStr == ‘’) return S; var fillLen = intMaxLength - stringLength; var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length)); if (stringFiller.length &gt; fillLen) stringFiller = stringFiller.slice(0, fillLen); return left ? stringFiller + S : S + stringFiller; };// }),/ 273 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-string-pad-start-end var $export = webpack_require(15); var $pad = webpack_require(272); var userAgent = webpack_require(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10.\d+(.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F WEBKIT_BUG, ‘String’, { padEnd: function padEnd(maxLength / , fillString = ‘ ‘ /) { return $pad(this, maxLength, arguments.length &gt; 1 ? arguments[1] : undefined, false); } });/*/ }),/ 274 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/sebmarkbage/ecmascript-string-left-right-trim webpack_require(90)(‘trimLeft’, function ($trim) { return function trimLeft() { return $trim(this, 1); }; }, ‘trimStart’);// }),/ 275 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/sebmarkbage/ecmascript-string-left-right-trim webpack_require(90)(‘trimRight’, function ($trim) { return function trimRight() { return $trim(this, 2); }; }, ‘trimEnd’);// }),/ 276 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/String.prototype.matchAll/ var $export = webpack_require(15); var defined = webpack_require(43); var toLength = webpack_require(45); var isRegExp = webpack_require(142); var getFlags = webpack_require(205); var RegExpProto = RegExp.prototype; var $RegExpStringIterator = function (regexp, string) { this._r = regexp; this._s = string; }; webpack_require(138)($RegExpStringIterator, ‘RegExp String’, function next() { var match = this._r.exec(this._s); return { value: match, done: match === null }; }); $export($export.P, ‘String’, { matchAll: function matchAll(regexp) { defined(this); if (!isRegExp(regexp)) throw TypeError(regexp + ‘ is not a regexp!’); var S = String(this); var flags = ‘flags’ in RegExpProto ? String(regexp.flags) : getFlags.call(regexp); var rx = new RegExp(regexp.source, ~flags.indexOf(‘g’) ? flags : ‘g’ + flags); rx.lastIndex = toLength(regexp.lastIndex); return new $RegExpStringIterator(rx, S); } });// }),/ 277 /// (function(module, exports, webpack_require) { webpack_require(36)(‘asyncIterator’);// }),/ 278 /// (function(module, exports, webpack_require) { webpack_require(36)(‘observable’);// }),/ 279 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-getownpropertydescriptors var $export = webpack_require(15); var ownKeys = webpack_require(262); var toIObject = webpack_require(40); var gOPD = webpack_require(58); var createProperty = webpack_require(172); $export($export.S, ‘Object’, { getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) { var O = toIObject(object); var getDesc = gOPD.f; var keys = ownKeys(O); var result = {}; var i = 0; var key, desc; while (keys.length &gt; i) { desc = getDesc(O, key = keys[i++]); if (desc !== undefined) createProperty(result, key, desc); } return result; } });// }),/ 280 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-values-entries var $export = webpack_require(15); var $values = webpack_require(281)(false); $export($export.S, ‘Object’, { values: function values(it) { return $values(it); } });// }),/ 281 /// (function(module, exports, webpack_require) { var getKeys = webpack_require(38); var toIObject = webpack_require(40); var isEnum = webpack_require(51).f; module.exports = function (isEntries) { return function (it) { var O = toIObject(it); var keys = getKeys(O); var length = keys.length; var i = 0; var result = []; var key; while (length &gt; i) if (isEnum.call(O, key = keys[i++])) { result.push(isEntries ? [key, O[key]] : O[key]); } return result; }; };// }),/ 282 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-object-values-entries var $export = webpack_require(15); var $entries = webpack_require(281)(true); $export($export.S, ‘Object’, { entries: function entries(it) { return $entries(it); } });// }),/ 283 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var aFunction = webpack_require(31); var $defineProperty = webpack_require(18); // B.2.2.2 Object.prototype.defineGetter(P, getter) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { defineGetter: function defineGetter(P, getter) { $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true }); } });// }),/ 284 /// (function(module, exports, webpack_require) { ‘use strict’; // Forced replacement prototype accessors methods module.exports = webpack_require(29) || !webpack_require(14)(function () { var K = Math.random(); // In FF throws only define methods // eslint-disable-next-line no-undef, no-useless-call defineSetter.call(null, K, function () { / empty / }); delete webpack_require(11)[K]; });// }),/ 285 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var aFunction = webpack_require(31); var $defineProperty = webpack_require(18); // B.2.2.3 Object.prototype.defineSetter(P, setter) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { defineSetter: function defineSetter(P, setter) { $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true }); } });// }),/ 286 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); var getPrototypeOf = webpack_require(66); var getOwnPropertyDescriptor = webpack_require(58).f; // B.2.2.4 Object.prototype.lookupGetter(P) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { lookupGetter: function lookupGetter(P) { var O = toObject(this); var K = toPrimitive(P, true); var D; do { if (D = getOwnPropertyDescriptor(O, K)) return D.get; } while (O = getPrototypeOf(O)); } });// }),/ 287 /// (function(module, exports, webpack_require) { ‘use strict’; var $export = webpack_require(15); var toObject = webpack_require(65); var toPrimitive = webpack_require(23); var getPrototypeOf = webpack_require(66); var getOwnPropertyDescriptor = webpack_require(58).f; // B.2.2.5 Object.prototype.lookupSetter(P) webpack_require(13) &amp;&amp; $export($export.P + webpack_require(284), ‘Object’, { lookupSetter: function lookupSetter(P) { var O = toObject(this); var K = toPrimitive(P, true); var D; do { if (D = getOwnPropertyDescriptor(O, K)) return D.set; } while (O = getPrototypeOf(O)); } });// }),/ 288 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var $export = webpack_require(15); $export($export.P + $export.R, ‘Map’, { toJSON: webpack_require(289)(‘Map’) });// }),/ 289 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var classof = webpack_require(82); var from = webpack_require(290); module.exports = function (NAME) { return function toJSON() { if (classof(this) != NAME) throw TypeError(NAME + “#toJSON isn’t generic”); return from(this); }; };// }),/ 290 /// (function(module, exports, webpack_require) { var forOf = webpack_require(220); module.exports = function (iter, ITERATOR) { var result = []; forOf(iter, false, result.push, result, ITERATOR); return result; };// }),/ 291 /// (function(module, exports, webpack_require) { // https://github.com/DavidBruant/Map-Set.prototype.toJSON var $export = webpack_require(15); $export($export.P + $export.R, ‘Set’, { toJSON: webpack_require(289)(‘Set’) });// }),/ 292 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of webpack_require(293)(‘Map’);// }),/ 293 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-setmap-offrom/ var $export = webpack_require(15); module.exports = function (COLLECTION) { $export($export.S, COLLECTION, { of: function of() { var length = arguments.length; var A = new Array(length); while (length–) A[length] = arguments[length]; return new this(A); } }); };// }),/ 294 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of webpack_require(293)(‘Set’);// }),/ 295 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of webpack_require(293)(‘WeakMap’);// }),/ 296 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of webpack_require(293)(‘WeakSet’);// }),/ 297 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from webpack_require(298)(‘Map’);// }),/ 298 /// (function(module, exports, webpack_require) { ‘use strict’; // https://tc39.github.io/proposal-setmap-offrom/ var $export = webpack_require(15); var aFunction = webpack_require(31); var ctx = webpack_require(30); var forOf = webpack_require(220); module.exports = function (COLLECTION) { $export($export.S, COLLECTION, { from: function from(source / , mapFn, thisArg /) { var mapFn = arguments[1]; var mapping, A, n, cb; aFunction(this); mapping = mapFn !== undefined; if (mapping) aFunction(mapFn); if (source == undefined) return new this(); A = []; if (mapping) { n = 0; cb = ctx(mapFn, arguments[2], 2); forOf(source, false, function (nextItem) { A.push(cb(nextItem, n++)); }); } else { forOf(source, false, A.push, A); } return new this(A); } }); };// }),/ 299 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from webpack_require(298)(‘Set’);// }),/ 300 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from webpack_require(298)(‘WeakMap’);// }),/ 301 /// (function(module, exports, webpack_require) { // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from webpack_require(298)(‘WeakSet’);// }),/ 302 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-global var $export = webpack_require(15); $export($export.G, { global: webpack_require(11) });// }),/ 303 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-global var $export = webpack_require(15); $export($export.S, ‘System’, { global: webpack_require(11) });// }),/ 304 /// (function(module, exports, webpack_require) { // https://github.com/ljharb/proposal-is-error var $export = webpack_require(15); var cof = webpack_require(42); $export($export.S, ‘Error’, { isError: function isError(it) { return cof(it) === ‘Error’; } });// }),/ 305 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { clamp: function clamp(x, lower, upper) { return Math.min(upper, Math.max(lower, x)); } });// }),/ 306 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { DEG_PER_RAD: Math.PI / 180 });// }),/ 307 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var RAD_PER_DEG = 180 / Math.PI; $export($export.S, ‘Math’, { degrees: function degrees(radians) { return radians RAD_PER_DEG; } });/*/ }),/ 308 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var scale = webpack_require(309); var fround = webpack_require(121); $export($export.S, ‘Math’, { fscale: function fscale(x, inLow, inHigh, outLow, outHigh) { return fround(scale(x, inLow, inHigh, outLow, outHigh)); } });// }),/ 309 /// (function(module, exports) { // https://rwaldron.github.io/proposal-math-extensions/ module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) { if ( arguments.length === 0 // eslint-disable-next-line no-self-compare || x != x // eslint-disable-next-line no-self-compare || inLow != inLow // eslint-disable-next-line no-self-compare || inHigh != inHigh // eslint-disable-next-line no-self-compare || outLow != outLow // eslint-disable-next-line no-self-compare || outHigh != outHigh ) return NaN; if (x === Infinity || x === -Infinity) return x; return (x - inLow) (outHigh - outLow) / (inHigh - inLow) + outLow; };/*/ }),/ 310 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { iaddh: function iaddh(x0, x1, y0, y1) { var $x0 = x0 &gt;&gt;&gt; 0; var $x1 = x1 &gt;&gt;&gt; 0; var $y0 = y0 &gt;&gt;&gt; 0; return $x1 + (y1 &gt;&gt;&gt; 0) + (($x0 &amp; $y0 | ($x0 | $y0) &amp; ~($x0 + $y0 &gt;&gt;&gt; 0)) &gt;&gt;&gt; 31) | 0; } });// }),/ 311 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 &gt;&gt;&gt; 0; var $x1 = x1 &gt;&gt;&gt; 0; var $y0 = y0 &gt;&gt;&gt; 0; return $x1 - (y1 &gt;&gt;&gt; 0) - ((~$x0 &amp; $y0 | ~($x0 ^ $y0) &amp; $x0 - $y0 &gt;&gt;&gt; 0) &gt;&gt;&gt; 31) | 0; } });// }),/ 312 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u &amp; UINT16; var v0 = $v &amp; UINT16; var u1 = $u &gt;&gt; 16; var v1 = $v &gt;&gt; 16; var t = (u1 v0 &gt;&gt;&gt; 0) + (u0 v0 &gt;&gt;&gt; 16); return u1 v1 + (t &gt;&gt; 16) + ((u0 v1 &gt;&gt;&gt; 0) + (t &amp; UINT16) &gt;&gt; 16); } });// }),/ 313 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { RAD_PER_DEG: 180 / Math.PI });// }),/ 314 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, ‘Math’, { radians: function radians(degrees) { return degrees DEG_PER_RAD; } });/*/ }),/ 315 /// (function(module, exports, webpack_require) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = webpack_require(15); $export($export.S, ‘Math’, { scale: webpack_require(309) });// }),/ 316 /// (function(module, exports, webpack_require) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = webpack_require(15); $export($export.S, ‘Math’, { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u &amp; UINT16; var v0 = $v &amp; UINT16; var u1 = $u &gt;&gt;&gt; 16; var v1 = $v &gt;&gt;&gt; 16; var t = (u1 v0 &gt;&gt;&gt; 0) + (u0 v0 &gt;&gt;&gt; 16); return u1 v1 + (t &gt;&gt;&gt; 16) + ((u0 v1 &gt;&gt;&gt; 0) + (t &amp; UINT16) &gt;&gt;&gt; 16); } });// }),/ 317 /// (function(module, exports, webpack_require) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = webpack_require(15); $export($export.S, ‘Math’, { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x &gt; 0; } });// }),/ 318 /// (function(module, exports, webpack_require) { // https://github.com/tc39/proposal-promise-finally ‘use strict’; var $export = webpack_require(15); var core = webpack_require(16); var global = webpack_require(11); var speciesConstructor = webpack_require(217); var promiseResolve = webpack_require(226); $export($export.P + $export.R, ‘Promise’, { ‘finally’: function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == ‘function’; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } });// }),/ 319 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/tc39/proposal-promise-try var $export = webpack_require(15); var newPromiseCapability = webpack_require(223); var perform = webpack_require(224); $export($export.S, ‘Promise’, { ‘try’: function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } });// }),/ 320 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } });// }),/ 321 /// (function(module, exports, webpack_require) { var Map = webpack_require(228); var $export = webpack_require(15); var shared = webpack_require(28)(‘metadata’); var store = shared.store || (shared.store = new (webpack_require(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == ‘symbol’ ? it : String(it); }; var exp = function (O) { $export($export.S, ‘Reflect’, O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp };// }),/ 322 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target / , targetKey /) { var targetKey = arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap‘delete’) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata‘delete’; return !!targetMetadata.size || store‘delete’; } });// }),/ 323 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target / , targetKey /) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 324 /// (function(module, exports, webpack_require) { var Set = webpack_require(232); var from = webpack_require(290); var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target / , targetKey /) { return ordinaryMetadataKeys(anObject(target), arguments.length &lt; 2 ? undefined : toMetaKey(arguments[1])); } });// }),/ 325 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target / , targetKey /) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 326 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target / , targetKey /) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length &lt; 2 ? undefined : toMetaKey(arguments[1])); } });// }),/ 327 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var getPrototypeOf = webpack_require(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target / , targetKey /) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 328 /// (function(module, exports, webpack_require) { var metadata = webpack_require(321); var anObject = webpack_require(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target / , targetKey /) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length &lt; 3 ? undefined : toMetaKey(arguments[2])); } });// }),/ 329 /// (function(module, exports, webpack_require) { var $metadata = webpack_require(321); var anObject = webpack_require(19); var aFunction = webpack_require(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } });// }),/ 330 /// (function(module, exports, webpack_require) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = webpack_require(15); var microtask = webpack_require(222)(); var process = webpack_require(11).process; var isNode = webpack_require(42)(process) == ‘process’; $export($export.G, { asap: function asap(fn) { var domain = isNode &amp;&amp; process.domain; microtask(domain ? domain.bind(fn) : fn); } });// }),/ 331 /// (function(module, exports, webpack_require) { ‘use strict’; // https://github.com/zenparsing/es-observable var $export = webpack_require(15); var global = webpack_require(11); var core = webpack_require(16); var microtask = webpack_require(222)(); var OBSERVABLE = webpack_require(34)(‘observable’); var aFunction = webpack_require(31); var anObject = webpack_require(19); var anInstance = webpack_require(219); var redefineAll = webpack_require(227); var hide = webpack_require(17); var forOf = webpack_require(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === ‘function’) cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, ‘Observable’, ‘_f’)._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === ‘function’ ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i &lt; l;) items[i] = arguments[i++]; return new (typeof this === ‘function’ ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j &lt; items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); webpack_require(201)(‘Observable’);// }),/ 332 /// (function(module, exports, webpack_require) { // ie9- setTimeout &amp; setInterval additional parameters fix var global = webpack_require(11); var $export = webpack_require(15); var userAgent = webpack_require(225); var slice = [].slice; var MSIE = /MSIE ../.test(userAgent); // &lt;- dirty ie9- check var wrap = function (set) { return function (fn, time / , …args /) { var boundArgs = arguments.length &gt; 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == ‘function’ ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) });/*/ }),/ 333 /// (function(module, exports, webpack_require) { var $export = webpack_require(15); var $task = webpack_require(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear });// }),/ 334 /// (function(module, exports, webpack_require) { var $iterators = webpack_require(202); var getKeys = webpack_require(38); var redefine = webpack_require(25); var global = webpack_require(11); var hide = webpack_require(17); var Iterators = webpack_require(137); var wks = webpack_require(34); var ITERATOR = wks(‘iterator’); var TO_STRING_TAG = wks(‘toStringTag’); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i &lt; collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection &amp;&amp; Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } }// }),/ 335 /// (function(module, exports) { / WEBPACK VAR INJECTION */(function(global) {/ Copyright (c) 2014, Facebook, Inc. All rights reserved. This source code is licensed under the BSD-style license found in the https://raw.github.com/facebook/regenerator/master/LICENSE file. An additional grant of patent rights can be found in the PATENTS file in the same directory. / !(function(global) { “use strict”; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === “function” ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || “@@iterator”; var asyncIteratorSymbol = $Symbol.asyncIterator || “@@asyncIterator”; var toStringTagSymbol = $Symbol.toStringTag || “@@toStringTag”; var inModule = typeof module === “object”; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we’re in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don’t bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we’re in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there’s no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don’t have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: “normal”, arg: fn.call(obj, arg) }; } catch (err) { return { type: “throw”, arg: err }; } } var GenStateSuspendedStart = “suspendedStart”; var GenStateSuspendedYield = “suspendedYield”; var GenStateExecuting = “executing”; var GenStateCompleted = “completed”; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don’t natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([]))); if (NativeIteratorPrototype &amp;&amp; NativeIteratorPrototype !== Op &amp;&amp; hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = “GeneratorFunction”; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { [“next”, “throw”, “return”].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === “function” &amp;&amp; genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === “GeneratorFunction” : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.proto = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = “GeneratorFunction”; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, await x is transformed to // yield regeneratorRuntime.awrap(x), so that the runtime can test // hasOwn.call(value, &quot;__await&quot;) to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === “throw”) { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === “object” &amp;&amp; hasOwn.call(value, “await”)) { return Promise.resolve(value.await).then(function(value) { invoke(“next”, value, resolve, reject); }, function(err) { invoke(“throw”, err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise&lt;{value,done}&gt; result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === “object” &amp;&amp; global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error(“Generator is already running”); } if (state === GenStateCompleted) { if (method === “throw”) { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === “next”) { // Setting context._sent for legacy support of Babel’s // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === “throw”) { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === “return”) { context.abrupt(“return”, context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === “normal”) { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === “throw”) { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = “throw”; context.arg = record.arg; } } }; } // Call delegate.iteratorcontext.method and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield loop. context.delegate = null; if (context.method === “throw”) { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = “return”; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === “throw”) { // If maybeInvokeDelegate(context) changed context.method from // “return” to “throw”, let that override the TypeError below. return ContinueSentinel; } } context.method = “throw”; context.arg = new TypeError( “The iterator does not provide a ‘throw’ method”); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === “throw”) { context.method = “throw”; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = “throw”; context.arg = new TypeError(“iterator result is not an object”); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was “throw” but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was “next”, forget context.arg since it has been // “consumed” by the delegate iterator. If context.method was // “return”, allow the original .return call to continue in the // outer generator. if (context.method !== “return”) { context.method = “next”; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = “Generator”; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers’ implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn’t happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return “[object Generator]”; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = “normal”; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: “root” }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === “function”) { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i &lt; iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel’s // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = “next”; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === “t” &amp;&amp; hasOwn.call(this, name) &amp;&amp; !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === “throw”) { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = “throw”; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = “next”; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === “root”) { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle(“end”); } if (entry.tryLoc &lt;= this.prev) { var hasCatch = hasOwn.call(entry, “catchLoc”); var hasFinally = hasOwn.call(entry, “finallyLoc”); if (hasCatch &amp;&amp; hasFinally) { if (this.prev &lt; entry.catchLoc) { return handle(entry.catchLoc, true); } else if (this.prev &lt; entry.finallyLoc) { return handle(entry.finallyLoc); } } else if (hasCatch) { if (this.prev &lt; entry.catchLoc) { return handle(entry.catchLoc, true); } } else if (hasFinally) { if (this.prev &lt; entry.finallyLoc) { return handle(entry.finallyLoc); } } else { throw new Error(“try statement without catch or finally”); } } } }, abrupt: function(type, arg) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.tryLoc &lt;= this.prev &amp;&amp; hasOwn.call(entry, “finallyLoc”) &amp;&amp; this.prev &lt; entry.finallyLoc) { var finallyEntry = entry; break; } } if (finallyEntry &amp;&amp; (type === “break” || type === “continue”) &amp;&amp; finallyEntry.tryLoc &lt;= arg &amp;&amp; arg &lt;= finallyEntry.finallyLoc) { // Ignore the finally entry if control is not jumping to a // location outside the try/catch block. finallyEntry = null; } var record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = “next”; this.next = finallyEntry.finallyLoc; return ContinueSentinel; } return this.complete(record); }, complete: function(record, afterLoc) { if (record.type === “throw”) { throw record.arg; } if (record.type === “break” || record.type === “continue”) { this.next = record.arg; } else if (record.type === “return”) { this.rval = this.arg = record.arg; this.method = “return”; this.next = “end”; } else if (record.type === “normal” &amp;&amp; afterLoc) { this.next = afterLoc; } return ContinueSentinel; }, finish: function(finallyLoc) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; } } }, “catch”: function(tryLoc) { for (var i = this.tryEntries.length - 1; i &gt;= 0; –i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (record.type === “throw”) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } // The context.catch method must only be called with a location // argument that corresponds to a known catch block. throw new Error(“illegal catch attempt”); }, delegateYield: function(iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === “next”) { // Deliberately forget the last sent value so that we don’t // accidentally pass it on to the delegate. this.arg = undefined; } return ContinueSentinel; } }; })( // Among the various tricks for obtaining a reference to the global // object, this seems to be the most reliable technique that does not // use indirect eval (which violates Content Security Policy). typeof global === “object” ? global : typeof window === “object” ? window : typeof self === “object” ? self : this ); / WEBPACK VAR INJECTION /}.call(exports, (function() { return this; }())))/**/ }),/ 336 //***/ (function(module, exports, webpack_require__) { webpack_require(337); module.exports = webpack_require(16).RegExp.escape;// }),/ 337 /// (function(module, exports, webpack_require) { // https://github.com/benjamingr/RexExp.escape var $export = webpack_require(15); var $re = webpack_require(338)(/[\^$+?.()|[]{}]/g, ‘\$&amp;’); $export($export.S, ‘RegExp’, { escape: function escape(it) { return $re(it); } });/**/ }),/ 338 /// (function(module, exports) { module.exports = function (regExp, replace) { var replacer = replace === Object(replace) ? function (part) { return replace[part]; } : replace; return function (it) { return String(it).replace(regExp, replacer); }; };// }),/ 339 /// (function(module, exports, webpack_require) { // style-loader: Adds some css to the DOM by adding a tag // load the styles var content = webpack_require(340); if(typeof content === ‘string’) content = [[module.id, content, ‘’]]; // add the styles to the DOM var update = webpack_require(342)(content, {}); if(content.locals) module.exports = content.locals; // Hot Module Replacement if(false) { // When the styles change, update the tags if(!content.locals) { module.hot.accept(“!!./node_modules/css-loader/index.js!./style.css”, function() { var newContent = require(“!!./node_modules/css-loader/index.js!./style.css”); if(typeof newContent === ‘string’) newContent = [[module.id, newContent, ‘’]]; update(newContent); }); } // When the module is disposed, remove the tags module.hot.dispose(function() { update(); }); }// }),/ 340 /// (function(module, exports, webpack_require) { exports = module.exports = webpack_require(341)(); // imports // module exports.push([module.id, “.lime {\n all: initial;\n}\n.lime.top_div {\n display: flex;\n flex-wrap: wrap;\n}\n.lime.predict_proba {\n width: 245px;\n}\n.lime.predicted_value {\n width: 245px;\n}\n.lime.explanation {\n width: 350px;\n}\n\n.lime.text_div {\n max-height:300px;\n flex: 1 0 300px;\n overflow:scroll;\n}\n.lime.table_div {\n max-height:300px;\n flex: 1 0 300px;\n overflow:scroll;\n}\n.lime.table_div table {\n border-collapse: collapse;\n color: white;\n border-style: hidden;\n margin: 0 auto;\n}\n”, “”]); // exports// }),/ 341 /// (function(module, exports) { / MIT License http://www.opensource.org/licenses/mit-license.php Author Tobias Koppers @sokra / // css base code, injected by the css-loader module.exports = function() { var list = []; // return the list of modules as css string list.toString = function toString() { var result = []; for(var i = 0; i &lt; this.length; i++) { var item = this[i]; if(item[2]) { result.push(“@media “ + item[2] + “{“ + item[1] + “}”); } else { result.push(item[1]); } } return result.join(“”); }; // import a list of modules into the list list.i = function(modules, mediaQuery) { if(typeof modules === “string”) modules = [[null, modules, “”]]; var alreadyImportedModules = {}; for(var i = 0; i &lt; this.length; i++) { var id = this[i][0]; if(typeof id === “number”) alreadyImportedModules[id] = true; } for(i = 0; i &lt; modules.length; i++) { var item = modules[i]; // skip already imported module // this implementation is not 100% perfect for weird media query combinations // when a module is imported multiple times with different media queries. // I hope this will never occur (Hey this way we have smaller bundles) if(typeof item[0] !== “number” || !alreadyImportedModules[item[0]]) { if(mediaQuery &amp;&amp; !item[2]) { item[2] = mediaQuery; } else if(mediaQuery) { item[2] = “(“ + item[2] + “) and (“ + mediaQuery + “)”; } list.push(item); } } }; return list; };// }),/ 342 /// (function(module, exports, webpack_require) { / MIT License http://www.opensource.org/licenses/mit-license.php Author Tobias Koppers @sokra / var stylesInDom = {}, memoize = function(fn) { var memo; return function () { if (typeof memo === “undefined”) memo = fn.apply(this, arguments); return memo; }; }, isOldIE = memoize(function() { return /msie [6-9]\b/.test(self.navigator.userAgent.toLowerCase()); }), getHeadElement = memoize(function () { return document.head || document.getElementsByTagName(“head”)[0]; }), singletonElement = null, singletonCounter = 0, styleElementsInsertedAtTop = []; module.exports = function(list, options) { if(false) { if(typeof document !== “object”) throw new Error(“The style-loader cannot be used in a non-browser environment”); } options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of // tags it will allow on a page if (typeof options.singleton === “undefined”) options.singleton = isOldIE(); // By default, add tags to the bottom of . if (typeof options.insertAt === “undefined”) options.insertAt = “bottom”; var styles = listToStyles(list); addStylesToDom(styles, options); return function update(newList) { var mayRemove = []; for(var i = 0; i &lt; styles.length; i++) { var item = styles[i]; var domStyle = stylesInDom[item.id]; domStyle.refs–; mayRemove.push(domStyle); } if(newList) { var newStyles = listToStyles(newList); addStylesToDom(newStyles, options); } for(var i = 0; i &lt; mayRemove.length; i++) { var domStyle = mayRemove[i]; if(domStyle.refs === 0) { for(var j = 0; j &lt; domStyle.parts.length; j++) domStyle.partsj; delete stylesInDom[domStyle.id]; } } }; } function addStylesToDom(styles, options) { for(var i = 0; i &lt; styles.length; i++) { var item = styles[i]; var domStyle = stylesInDom[item.id]; if(domStyle) { domStyle.refs++; for(var j = 0; j &lt; domStyle.parts.length; j++) { domStyle.partsj; } for(; j &lt; item.parts.length; j++) { domStyle.parts.push(addStyle(item.parts[j], options)); } } else { var parts = []; for(var j = 0; j &lt; item.parts.length; j++) { parts.push(addStyle(item.parts[j], options)); } stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts}; } } } function listToStyles(list) { var styles = []; var newStyles = {}; for(var i = 0; i &lt; list.length; i++) { var item = list[i]; var id = item[0]; var css = item[1]; var media = item[2]; var sourceMap = item[3]; var part = {css: css, media: media, sourceMap: sourceMap}; if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]}); else newStyles[id].parts.push(part); } return styles; } function insertStyleElement(options, styleElement) { var head = getHeadElement(); var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1]; if (options.insertAt === “top”) { if(!lastStyleElementInsertedAtTop) { head.insertBefore(styleElement, head.firstChild); } else if(lastStyleElementInsertedAtTop.nextSibling) { head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling); } else { head.appendChild(styleElement); } styleElementsInsertedAtTop.push(styleElement); } else if (options.insertAt === “bottom”) { head.appendChild(styleElement); } else { throw new Error(“Invalid value for parameter ‘insertAt’. Must be ‘top’ or ‘bottom’.”); } } function removeStyleElement(styleElement) { styleElement.parentNode.removeChild(styleElement); var idx = styleElementsInsertedAtTop.indexOf(styleElement); if(idx &gt;= 0) { styleElementsInsertedAtTop.splice(idx, 1); } } function createStyleElement(options) { var styleElement = document.createElement(“style”); styleElement.type = “text/css”; insertStyleElement(options, styleElement); return styleElement; } function createLinkElement(options) { var linkElement = document.createElement(“link”); linkElement.rel = “stylesheet”; insertStyleElement(options, linkElement); return linkElement; } function addStyle(obj, options) { var styleElement, update, remove; if (options.singleton) { var styleIndex = singletonCounter++; styleElement = singletonElement || (singletonElement = createStyleElement(options)); update = applyToSingletonTag.bind(null, styleElement, styleIndex, false); remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true); } else if(obj.sourceMap &amp;&amp; typeof URL === “function” &amp;&amp; typeof URL.createObjectURL === “function” &amp;&amp; typeof URL.revokeObjectURL === “function” &amp;&amp; typeof Blob === “function” &amp;&amp; typeof btoa === “function”) { styleElement = createLinkElement(options); update = updateLink.bind(null, styleElement); remove = function() { removeStyleElement(styleElement); if(styleElement.href) URL.revokeObjectURL(styleElement.href); }; } else { styleElement = createStyleElement(options); update = applyToTag.bind(null, styleElement); remove = function() { removeStyleElement(styleElement); }; } update(obj); return function updateStyle(newObj) { if(newObj) { if(newObj.css === obj.css &amp;&amp; newObj.media === obj.media &amp;&amp; newObj.sourceMap === obj.sourceMap) return; update(obj = newObj); } else { remove(); } }; } var replaceText = (function () { var textStore = []; return function (index, replacement) { textStore[index] = replacement; return textStore.filter(Boolean).join(‘\n’); }; })(); function applyToSingletonTag(styleElement, index, remove, obj) { var css = remove ? “” : obj.css; if (styleElement.styleSheet) { styleElement.styleSheet.cssText = replaceText(index, css); } else { var cssNode = document.createTextNode(css); var childNodes = styleElement.childNodes; if (childNodes[index]) styleElement.removeChild(childNodes[index]); if (childNodes.length) { styleElement.insertBefore(cssNode, childNodes[index]); } else { styleElement.appendChild(cssNode); } } } function applyToTag(styleElement, obj) { var css = obj.css; var media = obj.media; if(media) { styleElement.setAttribute(“media”, media) } if(styleElement.styleSheet) { styleElement.styleSheet.cssText = css; } else { while(styleElement.firstChild) { styleElement.removeChild(styleElement.firstChild); } styleElement.appendChild(document.createTextNode(css)); } } function updateLink(linkElement, obj) { var css = obj.css; var sourceMap = obj.sourceMap; if(sourceMap) { // http://stackoverflow.com/a/26603875 css += “\n/# sourceMappingURL=data:application/json;base64,” + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + “ /“; } var blob = new Blob([css], { type: “text/css” }); var oldSrc = linkElement.href; linkElement.href = URL.createObjectURL(blob); if(oldSrc) URL.revokeObjectURL(oldSrc); }// })/**/ ]);//# sourceMappingURL=bundle.js.map var top_div = d3.select(‘#top_divK6NVO0YFXX9D0II’).classed(‘lime top_div’, true); var exp_div; var exp = new lime.Explanation([“negative”, “positive”]); exp_div = top_div.append(‘div’).classed(‘lime explanation’, true); exp.show([[“Site EUI (kBtu/ft²) &lt;= 0.31”, 38.1426324067597], [“Largest Property Use Type_Non-Refrigerated Warehouse &lt;= 0.00”, 19.24725294284597], [“Weather Normalized Site Electricity Intensity (kWh/ft²) &lt;= 0.07”, 16.828754851818754], [“Property Id &gt; 0.74”, -1.8919407093030411], [“0.53 &lt; log_Water Intensity (All Water Sources) (gal/ft²) &lt;= 0.55”, -1.5443315216681583], [“0.75 &lt; Year Built &lt;= 0.79”, -0.8955224969619892], [“0.57 &lt; log_Direct GHG Emissions (Metric Tons CO2e) &lt;= 0.60”, 0.7486740209365783], [“0.00 &lt; Water Intensity (All Water Sources) (gal/ft²) &lt;= 0.00”, -0.3827127709707665], [“DOF Gross Floor Area &lt;= 0.00”, -0.36467717672864336], [“Largest Property Use Type_Multifamily Housing &lt;= 1.00”, 0.0]], 1, exp_div); var raw_div = top_div.append(‘div’); exp.show_raw_tabular([[“Site EUI (kBtu/ft²)”, “0.00”, 38.1426324067597], [“Largest Property Use Type_Non-Refrigerated Warehouse”, “0.00”, 19.24725294284597], [“Weather Normalized Site Electricity Intensity (kWh/ft²)”, “0.00”, 16.828754851818754], [“Property Id”, “0.98”, -1.8919407093030411], [“log_Water Intensity (All Water Sources) (gal/ft²)”, “0.55”, -1.5443315216681583], [“Year Built”, “0.79”, -0.8955224969619892], [“log_Direct GHG Emissions (Metric Tons CO2e)”, “0.60”, 0.7486740209365783], [“Water Intensity (All Water Sources) (gal/ft²)”, “0.00”, -0.3827127709707665], [“DOF Gross Floor Area”, “0.00”, -0.36467717672864336], [“Largest Property Use Type_Multifamily Housing”, “1.00”, 0.0]], 1, raw_div); 可以看到，正确值和预测值都是100！ 来自LIME的图再次显示了对该实例的每个特征变量的预测的贡献。例如，因为Site EUI 低于0.31（实际为0），这对得分的更高估计有显着贡献。同样，Largest Property Use Type_Non-Refrigerated Warehouse 小于等于0也对最终预测做出了积极贡献。 观察这些细分图可以让我们了解模型如何进行预测。这对于有大量特征影响模型的情况可能是最有价值的，因为我们可以检查错误并且可能设计更好的特征或调整模型的超参数以改进下次的预测。 模型偏离最多的示例也可能是手动查看的有趣边缘情况。由于Site EUI升高，该模型大大低估了第一座建筑的能源之星得分。因此，我们可能想问一下，为什么建筑物在EUI如此高的情况下还具有如此高的能源之星分数。有了这个过程，我们尝试使用机器学习算法来理解问题似乎比简单地让模型做出预测并完全信任它们要好得多！虽然LIME并不完美，但它代表了向解释机器学习模型的正确方向迈出的一步。 7.4 检查整体中的单个决策树基于树的集合最酷的部分之一是我们可以查看任何单个估计器（estimator）。虽然我们的最终模型由800个决策树组成，并且查看单个决策树并不表示整个模型，但它仍然允许我们看到决策树是如何工作的。 想象出数百棵决策树，我们可以根据以前树木的错误进行最终预测（这是对梯度提升回归如何工作的显著简化）。 我们将首先从森林中提取一棵树，然后使用sklearn.tree.export_graphviz保存它。 这将树保存为.dot文件，可以使用Notebook中的命令行指令将其转换为png。 12345678910# 提取出一棵决策树single_tree = model_reduced.estimators_[105][0]# 保存为 .dot文件tree.export_graphviz(single_tree, out_file = 'images/tree.dot', rounded = True, feature_names = most_important_features, filled = True)single_tree DecisionTreeRegressor(criterion=&apos;friedman_mse&apos;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, presort=&apos;auto&apos;, random_state=&lt;mtrand.RandomState object at 0x00000226012DDC60&gt;, splitter=&apos;best&apos;) 然后，你可以使用graphviz包中的dot命令行工具将此.dot文件转换为各种格式，如PDF或PNG。下面这条cmd命令行指令将.dot文件转换为.png图像文件(需要先安装graphviz包)： dot -Tpng images/tree.dot -o images/tree.png 下面的代码是把生成的tree.png 显示出来， 12from IPython.display import ImageImage(filename="images/tree.png") 这是我们包含800棵决策树的整棵树！ 这有点难以辨认，因为树的最大深度为5。为了提高可读性，我们可以限制调用中的最大深度来导出树。 123tree.export_graphviz(single_tree, out_file = 'images/tree_small.dot', rounded = True, feature_names = most_important_features, filled = True, max_depth = 3) 在命令行执行以下命令将.dot文件转换为.png图像文件： dot -Tpng images/tree_small.dot -o images/tree_small.png 然后使用相同的代码把生成的tree_small.png 显示出来 123# 限制最大深度后的决策树长这样from IPython.display import ImageImage(filename="images/tree_small.png") 现在我们可以看一下树，并尝试用它来代表它的决定！思考决策树的最佳方式是作为一系列是/否问题，如流程图。我们从顶部开始，称为根，然后沿着树向下移动，行进方向由每个等式的答案确定。 例如，我们在这里提出的第一个问题是：Site EUI是否小于或等于0.104？如果答案是肯定的，那么我们向左移动并提出问题：Weather Normalized Site Electricity Intensity是否小于或等于0.085？ 我们继续这个迭代过程，直到我们到达树的底部并最终进入叶节点。这里，我们预测的值对应于节点中显示的值（此树中的值似乎是实际预测除以100）。 每个节点有四个不同的信息： The question：基于这个答案，我们向右或向左移动到树中的下一个节点 friedman_mse：给定节点中所有示例的错误误差 sample：节点中的样本数 值：节点中所有样本的目标预测值 我们可以看到： 随着我们增加树的深度，我们将能够更好地拟合数据。对于小树，每个叶节点中将有许多示例，并且因为模型为节点中的每个示例估计相同的值，所以可能存在更大的错误（除非所有示例具有相同的目标值）。 构造太大的树虽然可能导致过度拟合。 我们可以控制许多超参数，这些参数决定了树的深度和每个叶子中的例子数量。当我们使用交叉验证执行优化时，我们在前文看到了如何在选择其中一些超参数。 虽然我们显然无法检查模型中的每一棵树，但查看单个树确实可以让我们了解我们的模型如何进行预测。事实上，这种基于流程图的方法看起来很像人类做出决策，一次回答一个关于单个值的问题。基于决策树的集合简单地采用单个决策树的概念并组合许多个体的预测，以便创建具有比单个估计器更小的方差的模型。树木的集合往往非常准确，也很直观！ 8 得出结论并撰写详尽记录的报告8.1 得出结论机器学习流程的最后部分可能是最重要的：我们需要将我们学到的所有内容压缩成一个简短的摘要，仅突出最重要的发现。 使用纽约市的能源数据，可以建立一个模型，可以预测建筑物的Energy Star Score能源之星得分，误差在10分以内。 The Site EUI 和 Weather Normalized Electricity Intensity 是预测能源之星得分的最相关特征。 给定一个新建筑的数据，经过训练的模型可以准确地推断出该建筑的能源之星的得分。 8.2 记录文档Jupyter Notebooks的最佳方面之一是它们可以直接下载为pdf或html，然后与他人共享。如果有人要求提供详细信息，那么我们可以轻松地解释所有实施步骤，并展示我们（希望）有充分记录的工作。 机器学习项目的另一个重要方面是： 你已经注解了所有代码并使其易于跟进！ 你希望别人（或者你自己在几个月内）能够看到你的工作并完全理解你做出的决定。 理想情况下，你应该编写代码，以便再次使用它。 即使我们自己做项目，也可以练习正确的文档，当你想重新审视项目时，它会让你的生活更轻松。 一些有用的学习资源： Hands-On Machine Learning with Scikit-Learn and Tensorflow An Introduction to Statistical Learning Kaggle: The Home of Data Science and Machine Learning Datacamp: Good Beginner Tutorials for Practicing Coding with a Focus on Data Science Dataquest: Hands on Lessons for Data Science Programming 12]]></content>
      <categories>
        <category>Project Experience</category>
      </categories>
      <tags>
        <tag>Project Experience</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是字符串相关题目题解总结。 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑’*’： 如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符’‘考虑进去，它可以匹配任意次的字符，当然出现0次也可以： 而当模式中的第二个字符是时： 如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 1. 模式后移2字符，相当于x*被忽略； 2. 字符串后移1字符，模式后移2字符，正好匹配x*中的&apos;x&apos;位； 3. 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&apos;*&apos;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符&apos;.&apos;的情况。 1. 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为&apos;.&apos;的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 2. 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1.1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = left+(right-left)//2 if data[mid] == k: temp = 0 for i in range(left, right+1): if data[i] == k: temp += 1 return temp elif data[mid] &lt; k: left += 1 else: right -= 1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 0: return False Dict = &#123;&#125; for i in range(len(numbers)): if numbers[i] not in Dict: Dict[numbers[i]] = 1 else: Dict[numbers[i]] += 1 if Dict[numbers[i]] == 2: duplication[0] = numbers[i] return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1–&gt;0k+2–&gt;1n-1 –&gt; n-k-20 – &gt; n-k-1 k-1 –&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # 思路1 # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res # 思路2 res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表剑指offer题解 - 树剑指offer题解 - 数组剑指offer题解 - 字符串剑指offer题解 - 栈剑指offer题解 - 递归剑指offer题解 - 回溯剑指offer题解 - 其他 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) –&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
