<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构 - 排序算法]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 排序假设含有n个记录的序列为${r1,r_2,…,r_n}$，其相应的关键字分别为$(k_1,k_2,…,k_n)$，需确定$1,2,…,n$的一种排列$p_1,p_2,…,p_n$,使其相应的关键字满足$K{p1} \leq k{p2} \leq … \leq k{pn}$关系，即使得序列成为一个按关键字有序的序列${r{p1},r{p2},…,r_{pn}$，这样的操作就称为排序。 1.1 排序的稳定性假设$k_i = k_j (1 \leq i \leq n，1 \leq j \leq n，i \neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i＜j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。 1.2 内排序与外排序内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要内外存之间多次交换数据才能进行。 对于内排序来说，排序算法的性能主要受3个方面影响： 时间性能：内排序中主要进行两种操作，比较和移动。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间：辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性：算法本身的复杂度，而不是指算法的时间复杂度。 内排序按主要操作分类：插入排序交换排序选择排序归并排序 排序按复杂度分类简单算法：冒泡排序，简单选择排序，直接插入排序改进算法：希尔排序，堆排序，归并排序，快速排序 2 常见排序算法2.1 冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 2.1.1 冒泡排序初级版让每一个关键字，都和他后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。123456789def BubbleSort0(L): for i in range(len(L)): for j in range(i+1,len(L)): if L[i]&gt;L[j]: L[i],L[j] = L[j],L[i] return Lif __name__ == '__main__': result = BubbleSort0([9,1,5,8,3,7,4,6,2]) print(result) 2.1.2 冒泡排序正宗版123456789def BubbleSort(L): for i in range(len(L)): for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.3 冒泡排序优化当i=2时，我们已经对9与8,8与7，。。。，3与2作了比较，没有任何数据交换，说明此序列已经有序，不需要再继续后面的循环判断工作了。增加标记变量flag来实现这一算法的改进。12345678910111213def BubbleSort(L): flag = True for i in range(len(L)): if flag: flag = False for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] flag = True return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.4 冒泡排序的算法复杂度：最好情况：要排序的表本身就是有序的，需要$n-1$次比较，没有数据交换，时间复杂度为$O(n)$。最坏情况：待排序表示逆序的情况，需要比较$1+2+3+…+(n-1) = n(n-1)/2$次，并做等数量级的记录移动，总时间复杂度为$O(n^2)$. 2.2 简单选择排序通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i,(1≤i≤n)$个记录交换之。123456789101112def SelectSort(L): for i in range(len(L)): min = i for j in range(i+1,len(L)): if L[j] &lt; L[min]: min = j if min != i: L[i],L[min] = L[min],L[i] return Lif __name__ == '__main__': result = SelectSort([9,1,5,8,3,7,4,6,2]) print(result) 2.2.1 简单选择排序复杂度分析简单选择排序最大的特点是交换移动数据次数相当少。无论最好最差的情况，其比较次数都是一样多，第$i$躺排序需要进行$n-i$次关键字的比较，需要比较$(n-1)+(n-2)+…+1 = n(n-1)/2$次;而对于交换次数而言，最好的时候交换0次，最坏时候交换n-1次。总的时间复杂度仍为$O(n^2)$。性能略优于冒泡排序 2.3 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。12345678910111213def InsertSort(L): for i in range(1,len(L)): if L[i] &lt; L[i-1]: temp = L[i]#设置哨兵 k = i while temp &lt; L[k-1] and k &gt;= 1: L[k] = L[k-1]#记录后移 k -= 1 L[k] = temp#插入到正确位置 return Lif __name__ == '__main__': result = InsertSort([9,1,5,8,3,7,4,6,2]) print(result) 2.3.1 直接插入排序复杂度分析 空间复杂度：只需要一个记录的辅助空间，$O(1)$ 最好时间复杂度：待排序表是有序时，n-1次比较，0次移动，复杂度为$O(n)$ 最坏时间复杂度：待排序表示逆序时，需要比较$2+3+…+n=(n+2)(n-1)/2$次，移动$(n+4)(n-1)/2$次。 平均比较和移动次数$n^2/4$次。总的时间复杂度为$O(n^2)$，直接插入排序法比冒泡和简单选择排序的性能要好一些。 2.4 希尔排序希尔排序算法是突破O(n^2)这个时间复杂度的第一批算法。采用跳跃分割的策略：将相距某个“增量”的记录组成一个字序列，这样才能保证在子序列内分别进行插入排序后得到的结果就是基本有序而不是局部有序。 123456789101112131415def ShellSort(L): increment = len(L) // 2 while increment &gt; 0: for i in range(increment,len(L)): temp = L[i] k = i - increment while temp &lt; L[k] and k &gt;= 0: L[k+increment] = L[k] k -= increment L[k+increment] = temp increment = increment // 2 return Lif __name__ == '__main__': result = ShellSort([9,1,5,8,3,7,4,6,2]) print(result) 2.4.1 希尔排序复杂度分析增量的选取很关键，迄今为止还没有人找到一种最好的增量序列。增量序列的最后一个增量值必须等于1才行，由于记录是跳跃式的移动，希尔排序并不是一种稳定的算法。时间复杂度为$O(n^{3/2})%。优于直接排序的$O(n^2)$。 2.5 堆排序堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如果按照层序遍历的方式给结点从1进行编号，则结点之间满足以下关系： 2.5.1 堆排序算法堆排序就是利用堆（假设利用大顶堆求升序）进行排序的方法，他的基本思想是：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。1234567891011121314151617181920212223def HeapSort(L): for i in range(len(L)//2,-1,-1): HeapAdjust(L,i,len(L)) for j in range(1,len(L))[::-1]: L[j],L[0] = L[0],L[j] HeapAdjust(L,i,j) return Ldef HeapAdjust(L,parent,length): temp = L[parent] child = 2*parent+1 while child &lt; length: if child+1&lt;length and L[child]&lt;L[child+1]: child += 1 if temp &gt;= L[child]: break L[parent] = L[child] parent = child child = 2*parent+1 L[parent] = tempif __name__ == '__main__': result = HeapSort([9,1,5,8,3,7,4,6,2]) print(result) 2.5.2 堆排序复杂度分析运行时间主要消耗在初始构建堆和重建堆的反复筛选。 构建堆的时间复杂度为$O(n)$ 重建堆的时间复杂度为$O(nlogn)$ 总的时间复杂度为$O(nlogn)$ 空间复杂度，只需要一个用来交换的暂存单元，$O(1)$。 2.6 归并排序归并排序的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到[n//2]个长度为2或1的有序子序列；再两两合并，…，如此重复，直至得到一个长度为n的有序序列为止，这种方法称为2路归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940def MergeSort(L): temp = [0]*len(L) MSort(L,temp,0,len(L)-1) return Ldef MSort(L,temp,left,right): if left &gt;= right: return mid = (left+right)//2 MSort(L,temp,left,mid) MSort(L,temp,mid+1,right) Merge(L,temp,left,mid,right)def Merge(L,temp,left,mid,right): l,r = left,mid+1 k = 0 while l &lt;= mid and r &lt;= right: if L[l]&lt;L[r]: temp[k] = L[l] l += 1 else: temp[k] = L[r] r += 1 k += 1 while l &lt;= mid: temp[k] = L[l] l+=1 k+=1 while r &lt;= right: temp[k] = L[r] r += 1 k += 1 k = 0 while left &lt;= right: L[left] = temp[k] left += 1 k += 1 if __name__ == '__main__': result = MergeSort([9,1,5,8,3,7,4,6,2]) print(result) 2.6.1 归并排序复杂度分析一趟归并需要将待排序序列中的所有记录扫描一遍，耗费$O(n)$时间，而由完全二叉树的深度可知，整个归并排序需要进行$[log2^n]$次，因此总的时间复杂度为$O(nlogn)$，而且这是归并排序算法中最好、最坏、平均的时间性能。由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$log2^n$的栈空间，因此空间复杂度为$O(n+logn)$。由于Merge函数中有$if L[l]&lt;L[r]$语句，说明需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。归并排序是一种比较占用内存，但效率高且稳定的算法。 2.7 快速排序快速排序的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 1234567891011121314151617181920212223def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) Partition 函数要做的，就是先选取当中的一个关键字，比如选择第一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴( pivot) 。 2.7.1 快速排序复杂度分析快速排序的时间性能取决于快速排序递归的深度。 在最优情况下,Partition每次划分都很均匀，如果排序n个关键字，其递归树的深度就为$[log2^n]+1$，仅需递归$log2^n$次，需要时间为$T(n)$的话，第一次Partition应该是对整个数组扫描一遍，做n次比较。然后获得的枢轴将数组一份为二，那么各自还需要$T(n/2)$的时间。 在最优的情况下，快速排序算法的时间复杂度为$O(nlogn) $。 最坏时间复杂度为$O(n^2)$。 空间复杂度主要是递归造成的栈空间的使用: 最好情况，递归树的深度为$log2^n$ ，其空间复杂度也就为$O(logn)$ 最坏情况，需要进行$n - 1$ 递归调用，其空间复杂度为$O(n)$ 平均情况， 空间复杂度也为$O (logn) $。 由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 2.7.2 快速排序优化2.7.2.1 优化选取枢轴三数取中：即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数。三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey ，123456789101112131415161718192021222324252627282930def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.2 优化不必要的交换1234567891011121314151617181920212223242526272829303132def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] temp = pivotkey while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low] = L[high] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[high] = L[low] L[low] = temp return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.3 优化小数组时的排序方案2.7.2.4 优化递归操作2.8 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 2.8.1 桶排序复杂度分析假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果 对每个桶中的数字采用快速排序，那么整个算法的复杂度是$O(n + m n/mlog(n/m)) = O(n + nlogn - nlogm) $ 当m接近n的时候，桶排序复杂度接近$O(n)$。前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是： 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 其次待排序的元素都要在一定的范围内。 桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 参考 2.8.2 桶排序实现桶排序求前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路 使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路 桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result) 3 总结 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 哈希表]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 散列表散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。即:存储位置=f(关键字)采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表，关键字对应的记录存储位置称为散列地址。散列技术既是一种存储方法，也是一种查找方法。它也线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字关联。因此，散列主要是面向查找的存储结构，适合求解的问题是查找与给定值相等的记录。 1.1 散列冲突每个关键字 $key1 \not= key2$，但却有$f(key1) = f(key2)$，这种现象称为冲突，并把key1和key2称为这个散列函数的同义词。出现了冲突当然非常糟糕，那将造成数 据查找错误。 2 散列函数的构造方法2.1 构造原则 计算简单。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。 散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，并减少为处理冲突而耗费的时间。 2.2 构造方法2.2.1 直接定址法取关键字的某个线性函数值为散列函数，即：$f(key) = a * key + b$，（a、b为常数） 优点是简单、均匀、不会产生冲突 缺点是需要首先知道关键字的分布情况，适合查找表较小且连续的情况 2.2.2 数字分析法基于抽取的方法，即使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布 且关键字的若干位分布较均匀，就可以考虑用这个方法。 2.2.3 平均取中法先对关键字求平方，在抽取中间的k位作为散列地址。比如关键字是 1234， 那么它的平方就是 1522756，再抽取中间的 3 位就是 227 ，用做散列地址。适合于不知道关键字的分布，且位数不是很大的情况。 2.2.4 折叠法将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够 时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如我们的关键字是 9876543210 ，散列表表长为三位，我们将它分为四组， 9871654132110， 然后将它们叠加求和987+654+321+0=1962，再求后 3 位得到散列 地址为 962。有时可能这还不能够保证分布均匀 ， 不妨从一端向另一端来回折叠后对齐相加。 比如我们将 987 和 321 反转，再与 654 和 0 相加， 变成 789+654+123+0=1566，此时散列地址为 566.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。 2.2.5 除留余数法对于散列表长为m的散列函数公式为：$f(key) = key mod p, (p \leq m)$不仅可以对关键字直接取模，还可在折叠、平方取中后再取模。 2.2.6 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址。即：$f (key) =random (key)$这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 3 散列冲突的处理方法3.1 开放定址法 (线性探测法)一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1,2,3,…,m-1)$ 堆积：两个关键字同时争夺同一个地址。此时需要不断处理冲突，降低存入和查找的效率。 解决方法1：二次探测法，增加平方运算使关键字尽可能分散。即：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1^2, -1^2, 2^2, -2^2 ,…,q^2, -q^2, q \leq m/2)$ 解决方法2：随机探测法，在冲突时，对于位移量 $d_i$，采用随机函数计算得到。即：$f_i (key) = (f(key) + d_i) mod m, d_i )$是一个随机数列 3.2 再散列函数法换一个不同的函数重新计算散列地址。$f_i (key) = RH_i(key), i=1,2,…,ki )$$RH_i$为不同的散列函数，如除留余数、折叠、平方取中等。 3.3 链地址法不存在冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。但带来了查找时需要遍历单链装的性能损耗。 3.4 公共溢出区法为所有冲突的关键字建立一个公共的溢出区来存放。查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对， 如果相等，则查找成功； 如果不相等，则到溢出表去进顺序查找； 如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。 4 散列表查找性能时间复杂度为O(1)。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 贪心算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是贪心算法相关题目题解总结。 [TOC] 贪心思想概念 最优子结构：最优子结构反映了分解问题的方式，我们在解决问题的时候，都会尝试将问题分解进行解决，产生的子问题，进而会产生局部解（总体解的子结构）。通常而言局部解也不仅只有一个，当局部解是局部最优解，并且该局部最优解是全局最优解的一部分时，我们称子问题的最优解为最优子结构。 最优子结构的性质：问题的最优解由相关自问题的最优解组合而成，而这些子问题可以独立求解。（需要注意这里独立求解的含义：当前最优，不考虑后面的步骤）；最优子结构的形式（或者是否有最优子结构）取决于你分解问题的方式。合理的分解达到的效果是：与最终问题的目标存在紧密的关系。如果分解问题之后却无法导出最终问题的解，那么这种问题分解的方式就是无意义的。 基本思想 贪心算法的基本思想是找出整体当中每个小的局部的最优解，并且将所有的这些局部最优解合起来形成整体上的一个最优解。因此能够使用贪心算法的问题必须满足下面的两个性质： 整体的最优解可以通过局部的最优解来求出； 一个整体能够被分为多个局部，并且这些局部都能够求出最优解。使用贪心算法当中的两个典型问题是活动安排问题和背包问题。 主要步骤 建立对问题精确描述的数学模型，包括定义最优解的模型； 将问题分解为一系列子问题，同时定义子问题的最优解结构； 应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路设置最大和maxsub = nums[0]，中间和temp = 0；遍历数组加到temp中，若temp &gt; maxsub，则更新最大和maxsun；若temp &lt; 0，则置为0从新开始。 1234567891011121314151617class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 maxsub = nums[0] temp = 0 for i in range(len(nums)): temp += nums[i] if temp &gt; maxsub: maxsub = temp if temp &lt; 0: temp = 0 return maxsub 55. 跳跃游戏题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2:123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路贪心。使用一个变量保存当前能到达的最后位置的索引，向后遍历每个位置，如果该位置大于前面能到达的最大位置，则返回False，如果这个位置可以达到，则更新能达到的最后位置索引，更新策略是当前位置索引+这个数字能走多少步和原来能到的最大值。12345678910111213141516class Solution(object): def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 0: return True reach = 0 for i in range(len(nums)): if i &gt; reach: return False reach = max(reach, i+nums[i]) return True 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对数组进行遍历，定义到目前为止最大利润maxsum和加上当前利润的中间利润temp； 如果temp&gt;maxsum，则到目前最大利润maxsum = temp； 如果temp小于0，舍弃，temp = 0。 1234567891011121314151617class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxsum = 0 temp = 0 for i in range(1,len(prices)): temp += prices[i] - prices[i-1] if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ； 因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，从而在局部最优的情况下也保证全局最优。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxp = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: maxp += prices[i] - prices[i-1] return maxp 134. 加油站题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2:12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 解题思路12345678910111213141516171819202122class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ if len(gas) != len(cost) or len(gas) == 0: return -1 start = 0 rest = 0 overall = 0 for i in range(len(gas)): rest += gas[i]-cost[i] overall += gas[i]-cost[i] if rest &lt; 0: rest = 0 start = i+1 return start if overall &gt;= 0 else -1 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = “abc”, t = “ahbgdc”返回 true. 示例 2: s = “axc”, t = “ahbgdc”返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路双指针，遍历两个序列。 1234567891011121314151617181920class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if not s: return True if not t or len(s) &gt; len(t): return False i = j = 0 while i &lt; len(s) and j &lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s)if __name__ == '__main__': result = Solution().isSubsequence("ace","abcde") print(result) 406. 根据身高重建队列题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路 对people进行排序，h越大k越小的在前； 然后按顺序给个高的先排序，因为个高的排好后，再怎么对矮个排序，都不会影响个高人的相对位置。 12345678910111213class Solution(object): def reconstructQueue(self, people): """ :type people: List[List[int]] :rtype: List[List[int]] """ if len(people) &lt;= 1: return people people.sort(key = lambda x:[-x[0],x[1]]) res = [] for i in range(len(people)): res.insert(people[i][1],people[i]) return res 435. 无重叠区间题目描述给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 解题思路区间题目一般按照排序+贪心去求解： 先将区间按照起点升序； 令第一个区间为起始老区间，然后从第二个起进行遍历，如果遍历到的区间的起点比老区间的终点小，说明有重叠； 此时计数并移除区间，移除的为终点大的区间，即将老区间设置为终点小的区间； 如果没有重叠，则更新老区间为当前遍历到的区间。 12345678910111213141516171819202122232425# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def eraseOverlapIntervals(self, intervals): """ :type intervals: List[Interval] :rtype: int """ if len(intervals) &lt;= 1: return 0 intervals = sorted(intervals, key = lambda interval:interval.start) last = 0 count = 0 for i in range(1,len(intervals)): if intervals[i].start &lt; intervals[last].end: count += 1 if intervals[i].end &lt;intervals[last].end: last = i else: last = i return count 452. 用最少数量的箭引爆气球题目描述在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 Example: 输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 解题思路 使用排序+贪心。把所有坐标按照右边界进行排序，因为每个气球都要被打破，初始当前最远的位置curr_pos为第一个坐标的右边界，对坐标进行遍历； 如果当前遍历到的坐标左边界小于curr_pos，则说明有重叠，继续； 否则说明没有重叠，修改curr_pos为当前坐标的右边界，计数加1。 1234567891011121314151617181920class Solution(object): def findMinArrowShots(self, points): """ :type points: List[List[int]] :rtype: int """ if not points: return 0 points.sort(key=lambda x: x[1]) curr_pos = points[0][1] ans = 1 for i in range(len(points)): if curr_pos &gt;= points[i][0]: continue curr_pos = points[i][1] ans += 1 return ansif __name__ == '__main__': result = Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) print(result) 455. 分发饼干题目描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路对孩子胃口值g和饼干尺寸s排序，先用最小的饼干满足最小胃口值的孩子，如果最小饼干满足不了最小胃口值的孩子，则加大饼干值去满足该孩子。 1234567891011121314151617181920class Solution(object): def findContentChildren(self, g, s): """ :type g: List[int] :type s: List[int] :rtype: int """ if len(g)==0 or len(s)==0: return 0 g.sort() s.sort() child = i = 0 while child &lt; len(g) and i &lt; len(s): if s[i] &gt;= g[child]: child += 1 i += 1 return childif __name__ == '__main__': result = Solution().findContentChildren([10,9,8,7],[5,6,7,8]) print(result) 763. 划分字母区间题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1: 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意: S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。 解题思路 用字典记录每个字母在字符串中出现的最右位置； 然后对每个字母和位置进行遍历，找到最靠右位置end； 如果遍历到的当前位置和最靠右位置重合，说明已经找到了一个划分； 更新开始位置start，继续。 1234567891011121314151617181920class Solution(object): def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ if not S: return [] charIndex = &#123;c: i for i, c in enumerate(S)&#125; end = start = 0 ans = [] for i, c in enumerate(S): end = max(end,charIndex[c]) if i == end: ans.append(end-start+1) start = end + 1 return ansif __name__ == '__main__': result = Solution().partitionLabels("ababcbacadefegdehijhklij") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 动态规划]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是动态规划相关题目题解总结。 [TOC] 动态规划递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是动态规划保存了子问题的解，避免重复计算。 动态规划与分治算法类似，都是通过组合子问题的解来求解原问题的： 分治算法将问题划分为互不相关的子问题，再递归地求解子问题，最后将它们的解组合起来，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，需要反复求解那些公共子问题，而动态规划对于每个子子问题只求解一次，将其保存在一个表格里面，从而无需每次求解一个子子问题时都需要重新计算，避免了不必要的计算工作。 动态规划的应用场景 动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。 动态规划的一般步骤 定义一个状态，这是一个最优解的结构特征； 进行状态递推，得到递推公式； 进行初始化； 返回结果。 动态规划的实质就是分治思想和解决冗余。将原来具有指数级复杂性的算法改进成具有多项式时间的算法，这是动态规划算法的目的。由于在实现的过程中，需要存储各种状态，所以它的空间复杂性要大于其他算法，这是一种以空间换时间的技术。 动态规划三要素最优子结构性质、子问题重叠性、自底向上的求解方法。 最优子结构性质 最优子结构性质，就是问题的最优解包含其子问题的最优解。如果不具备该性质，就不能使用动态规划来解决。常用反证法分析论证问题是否具备最优子结构的性质； 有时对某个子问题的解不一定达到最优，但是当把它延伸成整个问题的解时反而成了最优解，这种问题不满足最优子结构性质，无法使用动态规划。 子问题重叠性质 动态规划对每个子问题只求解一次，并把其答案保存在表格里，因此可以避免重复计算； 子问题重叠性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。 自底向上的求解方法由于动态规划解决的问题具有子问题重叠的问题，求解时需要自底向上的方法： 首先选择合适的表格（一维或二维），将递归的停止条件填入表格的相应位置； 然后将问题的规模一级一级放大，求出每一级子问题的最优解，并将其填入表格的相应位置 ； 直到问题所要求的规模，此时求出的便是原问题的最优解。 除了自底向上的方法，还可以使用 “带备忘录的自顶向下方法”。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（用数组或列表保存）。当需要子问题的解时，过程首先检查是否已经保存过此解。如果是，直接返回保存的值，从而节省时间；否则，按通常方式计算这个子问题。这个递归过程是带备忘的，因为它记住了之前已经计算出的结果。 贪婪算法的局限性动态规划的一个关键特点是每次做选择之前，对所有选择的效果进行计算。在计算的结果上选择能够达到最优的选项，从而保证每次选择都是最优的。 但是这种策略在当选项的数量非常巨大的时候将不堪重负。例如下围棋的时候，如果采用动态规划策略，则需要先对每步可能的行棋的影响进行计算，然后比较选择最优的走法。但每一步可行进的走法实在太多，如果再考虑到一盘棋有几乎不计其数的步骤，所以计算任务非常大几乎不可能完成。这种情况就是上面介绍的动态规划的缺点。这个时候应该采用贪婪策略。 贪婪策略运行我们不对所有可能选择的影响计算一遍后作出决策。我们可以在进行选择的时候不进行任何计算，而根据当时的情况作出我们认为最好的选择，这样就避免了大量计算，从而大大提高了算法的效率。 【算法】详解动态规划算法导论——-动态规划是什么 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为： &amp; (i-j&lt;=2 | dp[j + 1][i - 1])) 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路动态规划：当我们想要获得0~n中最大的子串和时，如果0~n-1的连续和小于0，则连续和等于它自己nums[n]，如果为正，则连续和等于它自己加上0~n-1的连续和。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dp = [0]*len(nums) dp[0] = nums[0] for i in range(1,len(nums)): if dp[i-1] &lt; 0: dp[i] = nums[i] else: dp[i] = nums[i] + dp[i-1] return max(dp) temp比0小，那就从开始重新记录 12345678910111213141516171819class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] res = nums[0] temp = 0 for x in nums: temp += x if temp &gt; res: res = temp if temp &lt; 0: temp = 0 return res 讨论区里很精巧的解法。将每一个nums[i]的值，看成是存放前面连续的和大于0的序列；通过遍历，纠正错误存放的值；nums[i]中的每一个数存放的都是序号i前面连续数据的最大和。 123456789101112class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 for i in range(1,len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1] return max(nums) 62. 不同路径题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 解题思路动态规划。 当只有一行或者一列的时候，只有一种方式； 遍历其余位置，每一个位置只能由其左边或上边的元素达到，即迭代公式为: 遍历完成后，dp矩阵存放了每一个位置的走法数，因此返回最后一个数即为所求。 1234567891011121314151617181920class Solution(object): def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m &lt; 1 or n &lt; 1: return 0 if m == 1 or n == 1: return 1 dp = [[1]*n for i in range(m)] for i in range(m): dp[i][0] = 1 for i in range(n): dp[0][i] == 1 for i in range(1,m): for j in range(1,n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] 63. 不同路径 II题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解题思路有障碍物的地方走法为0。 12345678910111213141516171819202122232425262728293031class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ if len(obstacleGrid) == 0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for i in range(m)] for i in range(m): if obstacleGrid[i][0] == 0: dp[i][0] = 1 else: break for i in range(n): if obstacleGrid[0][i] == 0: dp[0][i] = 1 else: break for i in range(1,m): for j in range(1,n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1] 64. 最小路径和题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路每个位置的最小数字总和为当前位置数值加上 上方及左方数字总和 较小的数。 1234567891011121314151617181920212223class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for i in range(m)] dp[0][0] = grid[0][0] for i in range(1,m): dp[i][0] = grid[i][0] + dp[i-1][0] for i in range(1,n): dp[0][i] = grid[0][i] + dp[0][i-1] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1] 70. 爬楼梯题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1：12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2：123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归 (超时)1234567891011class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 动态规划1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n dp = [0]*n dp[0] = 1 dp[1] = 2 for i in range(2,n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n a, b = 1, 2 res = 0 for i in range(3, n+1): res = a + b a, b = b, res return res 91. 解码方法题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码：1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:123输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2:123输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 解题思路dp[i]代表解析是s[:i]字符串的所有可能的方式数目。则：12dp[i] = dp[i-1] if s[i] != '0' + dp[i-2] if '9' &lt; s[i-2:i] &lt; '27' 举例子：对于’226’： 令dp=[0,0,0,0]，初始化为[1,0,0,0]； 从第一个位置开始，输入’2’，不为0，dp=[1,1,0,0]； 第二个位置为’2’，不为0，所以dp=[1,1,1,0]，此时前两位为’22’，满足区间，所以变为[1,1,2,0]; 第三个位置为’6’，不为0，所以dp=[1,1,2,2]，此时前两位为’26’，满足区间，所以变为[1,1,2,3]。 12345678910111213141516class Solution(object): def numDecodings(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 dp = [0] * (len(s)+1) dp[0] = 1 for i in range(1, len(s)+1): if s[i-1] != '0': dp[i] = dp[i-1] if i != 1 and '09' &lt; s[i-2:i] &lt; '27': dp[i] += dp[i-2] return dp[len(s)] 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 解题思路12345678910111213141516171819202122232425262728给定一个数n，求1到n这些数可以构成多少棵二叉树。给定一个序列1.....n，为了构造所有二叉树，我们可以使用1......n中的每一个数i作为根节点，自然1......(i-1)必然位于树的左子树中，(i+1).....n位于树的右子树中。然后可以递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。使用两个状态来记录：dp(n)：长度为n的序列的所有唯一的二叉树。dp(i,n)，1&lt;=i&lt;=n：以i作为根节点的二叉树的数量。dp(n)就是我们要求解的答案，dp(n)可以由F(i,n)计算而来。dp(n)=F(1,n)+F(2,n)+...+F(n,n) (1)dp(0)=1,dp(1)=1对于给定的一个序列1.....n，我们取i作为它的根节点，那么以i作为根节点的二叉树的数量F(i)可以由下面的公式计算而来：F(i,n)=dp(i-1)*dp(n-i-1) 1&lt;=i&lt;=n (2)比i小的数1...i-1作为左子树，比i大的数i+1...n作为右子树，左子树的排列和右子树的排列的乘积是此时的数目。例如 i=3，n=3时， dp[3] = dp[0]*dp[2]+dp[1]*dp[1]+dp[2]dp[0]。即左右子树节点数量分别为(0,2),(1,1),(2,0)。综合公式（1）和公式（2），可以看出：dp(n) = dp(0) * dp(n-1) + dp(1) * dp(n-2) + … + dp(n-1) * dp(0)[参考](https://blog.csdn.net/u012501459/article/details/46622501) 1234567891011121314class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt;= 2: return dp[n] dp += [0] * (n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[n] 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:1234567891011输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 解题思路 遍历1~n选择一个数当作根节点，所以其左边的数字构成左子树，右边的数字构成右子树。 当左子树固定的时候，把所有可能的右子树都构成，然后再变换左子树。（两层for循环遍历leftnodes和rightnodes）。 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 120. 三角形最小路径和题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形：123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路新建dp和三角形一样大小，dp[i][j]为第i层第j个位置的最短路径，dp初始化为最下面一层，从倒数第二层自底向上遍历，则：1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j] 123456789101112131415161718class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = [] for i in range(len(triangle)): dp.append([0]*len(triangle[i])) dp[-1] = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j] return dp[0][0] 由于 dp[i][j] 只被用了一次，所以可以变为一维dp：1dp[i] = min(dp[i],dp[i+1]) + triangle[i][j] 1234567891011121314class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0] 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路维护两个变量，到目前为止的最小值和最大收益。 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 minprice = prices[0] for i in range(1, len(prices)): minprice = min(minprice, prices[i]) maxprofit = max(maxprofit, prices[i]-minprice) return maxprofit 动态规划dp[i]为前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1种的最小价格) dp[i] = max(dp[i-1]-min(prices[:i]) 123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0]*len(prices) for i in range(1,len(prices)): dp[i] = max(dp[i-1], prices[i]-min(prices[:i])) return dp[-1] 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路当今天价格比昨天价格高时，就做一次交易。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 for i in range(1,len(prices)): if prices[i]&gt;prices[i-1]: maxprofit += prices[i]-prices[i-1] return maxprofit 动态规划，dp[i]为到第i天的最大收益，当今天价格比昨天价格高时，就做一次交易，dp[i] = dp[i-1]+prices[i]-prices[i-1] if prices[i]&gt;prices[i-1] else 0. 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0] * len(prices) for i in range(1,len(prices)): dp[i] = dp[i-1] if prices[i] &gt; prices[i-1]: dp[i] += prices[i]-prices[i-1] return dp[-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。 示例 2：1234输入: s = "applepenapple", wordDict = ["apple", "pen"]输出: true解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 152. 乘积最大子序列题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1:123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路暴力，超时。12345678910111213141516171819class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = nums[0] for i in range(len(nums)): res = max(res, nums[i]) cur = nums[i] for j in range(i+1,len(nums)): cur *= nums[j] res = max(res, cur) return res 动态规划 考虑某个位置出现负数或0的情况。当遇到0时，整个乘积变为0；当遇到负数时，当前的最大乘积变为最小乘积，最小乘积变为最大乘积。 使用两个数组分别记录以某个位置i结尾时的最大乘积和最小乘积，另最大乘积为dpmax，最小乘积为dpmin： 当前最大值为已知最大值乘当前值，当前值，已知最小值乘当前值，三者中的最大值； 当前最小值为已知最小值乘当前值，当前值，已知最大值乘当前值，三者中的最小值； 结果为最大值数组中的最大值。 1234567891011121314151617181920class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = [0]*len(nums) dpmax = [0]*len(nums) dpmin[0] = dpmax[0] = nums[0] res = nums[0] for i in range(1,len(nums)): dpmin[i] = min(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) dpmax[i] = max(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) res = max(res, dpmax[i]) # return max(dpmax) return res 空间优化。123456789101112131415161718class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = dpmax = nums[0] res = nums[0] for i in range(1,len(nums)): lastmin = dpmin lastmax = dpmax dpmin = min(lastmax*nums[i], nums[i], lastmin*nums[i]) dpmax = max(lastmax*nums[i], nums[i], *nums[i]) res = max(res, dpmax) return res 198. 打家劫舍题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路动态规划，维护一个长为len(nums)的数组dp，dp[i]代表在i处能取得的最大金额，这个房子该不该偷，这么决定的因素是这个房子偷了的话的收益和不偷留着偷下一个房子的收益那个比较高： 房子i的金额+dp[i-2]的金额 大于 dp[i-1]时，偷； 房子i的金额+dp[i-2]的金额 小于 dp[i-1]时，不偷。 即递推式为：123dp[0] = nums[0] dp[1] = nums[1] dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 12345678910111213141516171819class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(2,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 213. 打家劫舍 II题目描述你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路本题相比第198题就多了不同时偷第一个和最后一个的约束条件。所以，两种偷的情况：第一种不偷最后一个房间，第二种不偷第一个房间，求这两种偷法能获得的最大值。 12345678910111213141516171819202122class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) return max(self.helper(nums[:len(nums)-1]), self.helper(nums[1:])) def helper(self, nums): if len(nums) == 2: return max(nums) dp = [0]*len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(1,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 221. 最大正方形题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例:12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路使用DP，设DP[i][j]为以i,j位置为右下角顶点的能构成的最大正方形的边长，DP数组的第一行和第一列和matrix相等，其他位置当matrix[i][j]==1时，能构成的正方形边长等于左边，上边，左上角能构成正方形边长的最小值+1.递推公式：12341 when i==0 or j == 0, dp[i][j] = matrix[i][j]2 when i &gt; 0 and j &gt; 0, if matrix[i][j] == 0 dp[i][j] = 0 if matrix[i][j] == 1 dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 参考 12345678910111213141516171819202122class Solution(object): def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0]) for i in range(len(matrix))] res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if i == 0 or j == 0: dp[i][j] = 1 if matrix[i][j] == '1' else 0 elif matrix[i][j] == '1': dp[i][j] = 1+ min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) res = max(res, dp[i][j]) return res*res 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:121 是丑数。n 不超过1690。 解题思路123456789101112131415161718192021222324class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n &lt;= 6: return n dp = [1] t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp.append(min(dp[t2]*2, dp[t3]*3, dp[t5]*5)) if dp[t2]*2 == dp[-1]: t2 += 1 if dp[t3]*3 == dp[-1]: t3 += 1 if dp[t5]*5 == dp[-1]: t5 += 1 return dp[-1] 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路dp[i] = 1+min(dp[i-1^2],dp[i-2^2],…,dp[i-k^2]) 12345678910111213141516171819class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0]*(n+1) for i in range(1, n+1): minval = float('inf') for j in range(1, int(i**0.5)+1): minval = min(minval, dp[i-j*j]) dp[i] = minval + 1 return dp[-1] 300. 最长上升子序列题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路使用dp保存包目前为止的最大递增子序列长度，最后求所有为止的最大值，而不是dp的最后元素1初始化dp[i]=12对每一个位置，如果当前位置比之前位置的大，则此时为递增子序列，更新之 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) res = 1 dp = [1]*len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(res, dp[i]) return res 303. 区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例：12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路先把到当前位置的和求出来，然后再调用的时候直接右边的和减去左边的和。 12345678910111213141516171819202122232425262728class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.data = [] total = 0 for num in nums: total += num self.data.append(total) def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i == 0: return self.data[j] else: return self.data[j]-self.data[i-1]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 304. 二维区域和检索 - 矩阵不可变题目描述给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例:1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 解题思路使用dp保存当前位置到左上角元素构成的矩形的所有元素和，添加了第一列和第一行全是0，这样能保证在求和的时候，每个位置的和是是左边的和+上边的和-左上元素的和+当前位置的值1Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA) 参考 123456789101112131415161718192021222324252627class NumMatrix(object): def __init__(self, matrix): """ :type matrix: List[List[int]] """ if not matrix or not matrix[0]: m, n = 0, 0 else: m, n = len(matrix), len(matrix[0]) self.dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m): for j in range(n): self.dp[i+1][j+1] = self.dp[i+1][j]+self.dp[i][j+1]-self.dp[i][j] + matrix[i][j] def sumRegion(self, row1, col1, row2, col2): """ :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int """ return self.dp[row2+1][col2+1]-self.dp[row2+1][col1]-self.dp[row1][col2+1]+self.dp[row1][col1] 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路使用两个数组1 sell[i]表示该天结束之后手里没有股票的情况下的最大收益，可能情况为该天手里有股票卖了，或者该天没进行交易，即 max(hold[i-1]+prices[i]， sell[i-1]);2 hold[i]表示该天结束之后手里有股票的情况下的最大收益，可能情况为手里有股票但是没进行交易，或者手里没有股票买进股票，今天买进的条件是昨天必须休息，即max(hold[i-1], sell[i-2]-prices[i])。 注意：第一天不可能有卖股票的操作，hold[0] = -prices[0]。 该算法的时间复杂度是O(n)，空间复杂度是O(n)。123456789101112131415161718class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 sell = [0 for _ in range(len(prices))] hold = [0 for _ in range(len(prices))] hold[0] = -prices[0] for i in range(1, len(prices)): sell[i] = max(sell[i-1], hold[i-1]+prices[i]) hold[i] = max(hold[i-1], (sell[i-2] if i&gt;=2 else 0)-prices[i]) return sell[-1] 优化空间复杂度到O(1)123456789101112131415161718192021class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 cursell = 0 precell = 0 hold = -prices[0] for i in range(1, len(prices)): temp = cursell cursell = max(cursell, hold+prices[i]) hold = max(hold, (presell if i&gt;= 2 else 0)-prices[i]) presell = temp return cursell 322. 零钱兑换题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 解题思路DP。构建一个amount+1的数组，保存面额从0到amount+1需要使用的最少硬币数量。对于每一个位置i，如果j-c &gt;= 0, dp[i] = min(dp[i],dp[i-c]+1) 1234567891011121314151617181920212223class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [float('inf')]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for c in coins: if i-c &gt;= 0: dp[i] = min(dp[i], dp[i-c]+1) return dp[-1] if dp[-1] != float('inf') else -1 f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1123456789101112131415161718192021222324class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [0 for _ in range(amount+1)] for i in range(1, amount+1): cost = float('inf') for c in coins: if i-c &gt;= 0: cost = min(cost, dp[i-c]+1) dp[i] = cost return dp[-1] if dp[-1] != float('inf') else -1 338. 比特位计数题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1:12输入: 2输出: [0,1,1] 示例 2:12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 builtin_popcount）来执行此操作。 解题思路找规律使用dp，如果i是偶数，它的二进制1的位数等于i//2中1的位数；如果i是奇数，那么它的二进制位数等于i-1的二进制位数+1.即 if i%2==0: dp[i] = dp[i//2]else: dp[i] = dp[i-1]+1 又因为i为奇数时，i-1为偶数，即dp[i-1]=dp[i//2]，此时dp[i] = dp[i//2]+1，综合起来可以写成dp[i] = dp[i//2] + (i&amp;1) 123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] dp = [0] * (num+1) for i in range(1, num+1): # if i % 2 == 0: # dp[i] = dp[i//2] # else: # dp[i] = dp[i-1] + 1 dp[i] = dp[i//2] + (i&amp;1) return dp 暴力，时间复杂度为O(n*sizeof(integer))123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] res = [] for i in range(num+1): count = 0 while i: if i&amp;1: count += 1 i &gt;&gt;= 1 res.append(count) return res 343. 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 解题思路使用dp，dp[i]表示i拆分后的最大乘积，将i分为两部分j和i-j，将这两部分相乘取最大的。 123456789101112131415161718192021class Solution(object): def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 dp = [0]*(n+1) dp[2] = 1 dp[3] = 2 for i in range(4, n+1): for j in range(1, i//2 + 1): dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j])) return dp[-1] 357. 计算各个位数不同的数字个数题目描述给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。 示例:123输入: 2输出: 91 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。 解题思路//dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1)); //加上dp[i-1]没什么可说的，加上之前的数字 //dp[i-1]-dp[i-2]的意思是我们之前判断各位不重复的数字 //我们要在这些数字后面填新的数字。当i=2时，说明之前选取的数字只有 //1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。 //当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的 //有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9） 123456789101112131415161718class Solution(object): def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0] * (n+1) dp[0] = 1 dp[1] = 10 for i in range(2, n+1): dp[i] = dp[i-1] + (dp[i-1]-dp[i-2]) * (10-(i-1)) return dp[-1] 368. 最大整除子集题目描述给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。 如果有多个目标子集，返回其中任何一个均可。 示例 1:12输入: [1,2,3]输出: [1,2] (当然, [1,3] 也正确) 示例 2:12输入: [1,2,4,8]输出: [1,2,4,8] 解题思路首先对数组进行排序，使用dp，dp[i]的含义是从0~i位置满足题目的数组最长长度，先用i遍历每个数字，然后用j从后向前（从前到后也可以）寻找能被nums[i]整除的数字，这样如果判断能整除的时候，在判断dp[i]&lt;d[j]+1，即判断对于以i为结尾的最长数组是否变长了。在变长的情况下，需要更新dp[i]，同时使用parent[i]更新i的前面能整除的数字。另外还要统计对于整个数组最长的子数组长度。 知道了对于每个位置最长的子数组之后，我们也就知道了对于0~n区间内最长的满足题目条件的数组，最后需要再次遍历，使用parent就能把正儿个数组统计输出出来。因为这个最大的索引mx_index是对n而言的，所以输出是逆序的。 参考 1234567891011121314151617181920212223242526272829303132class Solution(object): def largestDivisibleSubset(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] nums.sort() dp = [0] * len(nums) parent = [0] * len(nums) maxlen = 0 maxlenIndex = -1 for i in range(len(nums)): for j in range(i-1, -1, -1): # for j in range(i): if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j]+1: dp[i] = dp[j] + 1 parent[i] = j if dp[i] &gt; maxlen: maxlen = dp[i] maxlenIndex = i res = [] for i in range(maxlen+1): res.append(nums[maxlenIndex]) maxlenIndex = parent[maxlenIndex] return res[::-1] 375. 猜数字大小 II题目描述我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例:123456789n = 10, 我选择了8.第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。游戏结束。8 就是我选的数字。你最终要支付 5 + 7 + 9 = 21 块钱。 给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。 解题思路这题要求我们在猜测数字y未知的情况下（1~n任意一个数），要我们在最坏情况下我们支付最少的钱。也就是说要考虑所有y的情况。 我们假定选择了一个错误的数x，（1&lt;=x&lt;=n &amp;&amp; x!=y ）那么就知道接下来应该从[1,x-1 ] 或者[x+1,n]中进行查找。 假如我们已经解决了[1,x-1] 和 [x+1,n]计算问题，我们将其表示为solve(L,x-1) 和solve(x+1,n)，那么我们应该选择max(solve(L,x-1),solve(x+1,n)) 这样就是求最坏情况下的损失。总的损失就是 f(x) = x + max(solve(L,x-1),solve(x+1,n)) 那么将x从1~n进行遍历，取使得 f(x) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。 上面的说法其实是一个自顶向下的过程（Top-down），可以用递归来解决。很容易得到如下的代码（这里用了记忆化搜索）： 参考 123456789101112131415161718class Solution(object): def getMoneyAmount(self, n): """ :type n: int :rtype: int """ dp = [[0]*(n+1) for _ in range(n+1)] return self.solve(dp, 1, n) def solve(self, dp, left, right): if left &gt;= right: return 0 if dp[left][right]: return dp[left][right] dp[left][right] = min(i + max(self.solve(dp, left, i-1), self.solve(dp, i+1, right)) for i in range(left, right+1)) return dp[left][right] 376. 摆动序列题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 解题思路摆动为一升一降，一个up就要配一个down构成一组。注意去重 123456789101112131415161718192021class Solution(object): def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) up = 1 down = 1 for i in range(1, len(nums)): if nums[i] &gt; nums[i-1]: up = down + 1 elif nums[i] &lt; nums[i-1]: down = up + 1 return max(up, down) 377. 组合总和 Ⅳ题目描述给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶： 如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？ 解题思路使用dp[i]表示组合数为i时使用nums中的数组能组成组合数的个数，因为都是正数，所以长度最多是target,target个1组成。 从1遍历到target，对于每一个数i，遍历nums数组，如果i&gt;=x, dp[i] += dp[i - x]。比如说对于[1,2,3] 4，在计算dp[3]的时候，3可以拆分为1+x，而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了。 1234567891011121314151617181920class Solution(object): def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 dp = [0] * (target+1) dp[0] = 1 for i in range(1, target+1): for x in nums: if i &gt;= x: dp[i] += dp[i-x] return dp[-1] 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1:123s = "abc", t = "ahbgdc"返回 true. 示例 2:123s = "axc", t = "ahbgdc"返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路dp的tag不用dp。使用一个指针index记录最后s[:index]在t中存在的最后位置。 123456789101112131415161718192021class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(t) &lt; len(s): return False if len(s) == 0: return True index = 0 for i in range(len(t)): if t[i] == s[index]: index += 1 if index == len(s): return True return index == len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 回溯算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是回溯算法相关题目题解总结。 [TOC] 回溯算法回溯算法属于DFS。在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。 普通DFS主要用于可达性问题，这种问题只需要执行到特定的位置然后返回即可； 而Backtracking主要用于求解排列组合问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。 Backtracking的基本思想是： 从一条路往前走，能进则进，不能进则退回来，换一条路再试。 八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。 回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。 回溯算法说白了就是穷举法。 因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素； 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。 17. 电话号码的字母组合题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路回溯。要求所有位置都要有字母，即组合的长度为数字的长度。 123456789101112131415161718192021class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] dic = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; res = [] self.dfs(digits, 0, '', dic, res) return res def dfs(self, digits, index, path, dic, res): if len(path) == len(digits): if path: res.append(path) return if digits[index] not in dic: return [] for j in dic[digits[index]]: self.dfs(digits, index+1, path+j, dic, res) 123456789101112131415161718192021222324252627class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] Dict = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; strs = [] for x in digits: strs.append(Dict[x]) res = [] self.dfs(strs, 0, '', res) return res def dfs(self, strs, index, path, res): if len(path) == len(strs): res.append(path) return for j in strs[index]: self.dfs(strs, index+1, path+j, res) 22. 括号生成题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 解题思路回溯。如果左括号还有剩余，则放置左括号，如果有括号剩余数大于左括号，则可以放置有括号，停止条件为所有括号全部放置完。 12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n &lt;= 0: return [] res = [] self.dfs(n, n, '', res) return res def dfs(self, left, right, path, res): if left == 0 and right == 0: res.append(path) return if left &gt; 0: self.dfs(left-1, right, path+'(', res) if left &lt; right: self.dfs(left, right-1, path+')', res) 39. 组合总和题目描述给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题思路先进行排序在dfs。123456789101112131415161718192021class Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, start, templist, res): if residue == 0: res.append(templist) return for i in range(start, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i, templist+[candidates[i]], res) 40. 组合总和 II题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解题思路和39差不多，加判断条件防止res中出现重复项，调用时为i+1，防止重复的数字。12345678910111213141516171819202122class Solution(object): def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, index, templist, res): if residue == 0 and templist not in res: res.append(templist) return for i in range(index, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i+1, templist+[candidates[i]], res) 46. 全排列题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例:12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路12345678910111213141516171819202122class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(temp) == len(nums): res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res) 47. 全排列 II题目描述给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路123456789101112131415161718192021class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(nums) == len(temp) and temp not in res: res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, temp, res): if not nums and temp not in res: res.append(temp) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], temp+[nums[i]], res) 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 解题思路所有元素共有 n! 种排列。根据下图对’1234’的全排列，按照第一个字符可以分为4组，按照第二个字符可以分为3组，按照第三个字符可以分为2组，所以一共有4x3x2种排列方式。 要得到第九个排列’2314’，转换为数组下标也就是8，在level 1 中下标为1，level 2 中下标为1，level 3 中下标为0。具体过程为： 最高位可以取{1,2,3,4}，并且每个数在最高位出现3!=6次，第9个排序的最高位下标为：8//3!=1，也就是2； 次位可以取{1,3,4}，并且每个数在次位出现2!=2次，第9个排序的最高位下标为：(8%6)//2!=1，也就是3; 第三位可以取{1,4},并且每个数在第三位出现1次，第9个排列的第三位取值下标为：(8%6%2)//1=0，也就是1； 最后一位只有一个数字4。 用ki表示在数组中的取值下标，n表示集合中数字个数： k = k-1，此步是关键 k1 = k//(n-1)! k = k%(n-1)! k2 = k//(n-2)! k = k%(n-2)! … kn-1 = k//1 参考文章1234567891011121314151617181920212223class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' fact = [1]*n for i in range(1,n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' k = k-1 res = '' num = [str(i) for i in range(1,n+1)] for i in range(n, 0, -1): index = k // fact[i-1] res += num[index] k = k % fact[i-1] num.pop(index) return res 77. 组合题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路回溯法，我们抽取第一个字符，然后从后面n-1个字符中抽取k-1个；抽取第二个字符，再从后面的n-2个字符抽出k-1. 12345678910111213141516171819202122class Solution(object): def combine(self, n, k): """ :type n: int :type k: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0: return [] res = [] self.dfs(range(1, n+1), k, [], res) return res def dfs(self, nums, k, path, res): if k &gt; len(nums): return if k == 0: res.append(path) return for i in range(len(nums)): self.dfs(nums[i+1:], k-1, path+[nums[i]], res) 78. 子集题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路12345678910111213141516class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [[]] res = [] self.dfs(nums, 0, res, []) return res def dfs(self, nums, index, res, path): res.append(path) for i in range(index, len(nums)): self.dfs(nums, i+1, res, path+[nums[i]]) 79. 单词搜索题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例:12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = "ABCCED", 返回 true.给定 word = "SEE", 返回 true.给定 word = "ABCB", 返回 false. 解题思路Leetcode65题12345678910111213141516171819202122232425262728293031323334class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ if len(board) == 0: return False if len(word) == 0: return True visited = [[False]*len(board[0]) for i in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, word, i, j, 0, visited): return True return False def helper(self, board, word, i, j, pathlength, visited): if pathlength == len(word): return True curHaspath = False if 0&lt;=i&lt;len(board) and 0&lt;=j&lt;len(board[0]) and board[i][j] == word[pathlength] and not visited[i][j]: visited[i][j] = True pathlength += 1 curHaspath = self.helper(board,word,i+1,j,pathlength,visited) or self.helper(board,word,i-1,j,pathlength,visited) or self.helper(board,word,i,j+1,pathlength,visited) or self.helper(board,word,i,j-1,pathlength,visited) if not curHaspath: visited[i][j] = False pathlength -= 1 return curHaspath 89. 格雷编码题目描述格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路格雷码的生成过程：res[i] = i ^ (i//2)。如n = 3： res[0] = 0 = 000 res[1] = 1^(1//2) = 001^000 = 001 res[2] = 2^(2//2) = 010^001 = 011 res[3] = 3^(3//2) = 011^001 = 010 res[4] = 4^(4//2) = 100^010 = 110 res[5] = 5^(5//2) = 101^010 = 111 res[6] = 6^(6//2) = 110^011 = 101 res[7] = 7^(7//2) = 111^011 = 100 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] num = 1 for i in range(n): num *= 2 res = [0]*num while i &lt; num: res[i] = i ^ (i//2) i += 1 return res 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] res = [0]*(2**n) for i in range(len(res)): res[i] = i^(i//2) return res 90. 子集 II题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路123456789101112131415161718192021class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] nums.sort() res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, index, path, res): if path not in res: res.append(path) for i in range(index, len(nums)): if i &gt; index and nums[i] == nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) 93. 复原IP地址题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: “25525511135”输出: [“255.255.11.135”, “255.255.111.35”] 解题思路IP地址由四部分组成，每一部分的数字为0~255，使用回溯算法验证每一部分的数字大小,一部分数字做多为3位（range(1,4))，在使用完字符串中所有字符且当前IP地址为四部分时添加到结果中。每次dfs的时候都去检查一下所有的字符串的长度是不是能满足在最多4个3位数字组成。 123456789101112131415161718192021222324class Solution(object): def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ if not s or len(s) &lt; 4 or len(s) &gt; 12: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and len(temp) == 4: res.append('.'.join(temp)) return if len(temp) &gt;= 4 or len(s) &gt; (4-len(temp))*3: return for i in range(1, 4): if i &gt; len(s): continue number = int(s[:i]) if str(number) == s[:i] and number &lt;= 255: self.dfs(s[i:], temp + [s[:i]], res) 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: "aab"输出:[ ["aa","b"], ["a","a","b"]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 二分查找]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是二分查找相关题目题解总结。 [TOC] 二分查找二分查找也称折半查找，它是一种效率较高的查找方法。但是折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排序。 查找过程二分查找适用于有序的顺序表。首先将表中间位置记录的关键字和查找关键字比较；如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表；如果中间位置记录的关键字大于查找关键字，则进入前一子表，否则进入后一子表；重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止。 算法要求 必须采用顺序存储结构； 必须按关键字大小有序排序。 复杂度时间复杂度O(log2n)，空间复杂度为O(1)。 中值mid的计算有两种计算中值mid的方式： mid = (left+right) // 2; mid = left + (right-left)//2left+right 可能出现加法溢出，最好使用第二种方式。 返回值 如果成功查找到key： 返回key所在的位置。 如果循环退出时仍然没有找到key，表示查找失败，有两种可能返回值： -1:以一个错误码表示没有查找到key；pos：将key插入到原列表中合适的位置。 正常实现1234567891011121314class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == key: return mid elif nums[mid] &gt; key: right = mid - 1 else: left = mid + 1 return -1 二分查找的变种二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：123456789101112131415class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt; right: # 小于 而不是小于等于 mid = left + (right-left)//2 if nums[mid] &gt;= key: right = mid # mid 不是mid-1 else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().binarySearch([1,1,1,2,3,3,4,5,6,7],1) print(result) 与正常实现不同： right 的赋值表达式为 right = mid； 循环条件为left&lt;right; 最后返回left而不是-1。 解释： 在nums[mid] &gt;= key的情况下，可以推导出最左key位于[left,mid]区间中，right 的赋值表达式为 right = mid，因为mid位置也可能为解； 在right 的赋值表达式为 right = mid的情况下，如果循环条件为left&lt;=right，将会导致陷入死循环的情况； 当循环退出时，不表示没有查找成功，为了验证有没有查找到，应该在调用函数时判断一下返回值上的值和key是否相等。 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 123456789101112131415161718192021222324252627282930class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return -1 34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解题思路二分查找。 当nums[mid] == target时，说明target在数组中的[left,right]中，其中开始位置在[left,mid]，结束位置在[mid,right]中； 从头遍历[left,mid]，找到第一个等于target的位置作为开始位置； 从后遍历[mid,right]，从后找到第一个等于target的位置作为结束位置； 当nums[mid] &gt; target时，right = mid-1 当nums[mid] &lt; target时，left = mid+1 12345678910111213141516171819202122232425262728293031class Solution(object): def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1,-1] left, right = 0 ,len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: temp = [] for i in range(left,mid+1): if nums[i] == target: temp.append(i) break for i in range(right, mid-1,-1): if nums[i] == target: temp.append(i) break return temp elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return [-1,-1]if __name__ == '__main__': result = Solution().searchRange([5,7,7,8,8,10],8) print(result) 35. 搜索插入位置题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 2输出: 1 示例 3:12输入: [1,3,5,6], 7输出: 4 示例 4:12输入: [1,3,5,6], 0输出: 0 解题思路1234567891011121314151617181920212223class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return left 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: # return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2 示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 解题思路 二分查找。一个数x的开根号一定在[1,x//2+1]之间，因为在(x//2+1)^2 &gt; x，所以我们将二分查找的终点设为x//2+1; 对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 left &lt;= right 并且循环退出时，right 总是比 left 小 1，也就是说 right = 2，left = 3，因此最后的返回值应该为 right 而不是 left。 1234567891011121314151617181920class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x == 0: return 0 if x == 1: return 1 left, right = 1, x//2+1 while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在正式比较之前，先移动左指针，使它指向和右指针不同的数字上。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: while left &lt; right and nums[left] == nums[right]: left += 1 mid = left + (right-left)//2 if nums[mid] == target: return True if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 153. 寻找旋转排序数组中的最小值题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 示例 2: 输入: [4,5,6,7,0,1,2]输出: 0 解题思路数组分为两个升序的数组，使用二分查找。 当nums[mid]&gt;nums[mid+1]时，最小值为nums[mid+1]; 当nums[mid]&gt;nums[right]时,left = mid+1; 当nums[mid]&gt;nums[right]时,right = mid，因为mid位置可能就是最小值了； 由于right = mid，则循环条件为left&lt;right。 1234567891011121314151617181920212223class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] left, right = 0, len(nums)-1 while left &lt; right: mid = left + (right-left)//2 if mid+1 &lt;= len(nums)-1 and nums[mid] &gt; nums[mid+1]: return nums[mid+1] if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]if __name__ == '__main__': result = Solution().findMin([4,5,6,7,0,1,2]) print(result) 二刷12345678910111213141516171819202122class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if mid-1&gt;=0 and nums[mid-1] &gt; nums[mid]: return nums[mid] if nums[mid] &lt;= nums[right]: right = mid-1 else: left = mid + 1 return nums[left] 162. 寻找峰值题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 解题思路用两个mid，判断上坡还是下坡，上坡将left移到坡顶，下坡将right移到坡顶123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 left, right = 0, len(nums)-1 while left &lt; right: mid1 = left+(right-left)//2 mid2 = mid1 + 1 if nums[mid1] &lt; nums[mid2]: left = mid2 else: right = mid1 return left 278. 第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -false调用 isBadVersion(5) -true调用 isBadVersion(4) -true所以，4 是第一个错误的版本。 解题思路给定 n = 5，并且 version = 4 是第一个错误的版本时，输入分布为[1,2,3,4,5]，对应版本正误情况为[0,0,0,1,1]，题目要求出最靠左的1的位置。使用二分查找： 如果第mid个版本出错，则第一个出错版本在[left,mid]，有可能出现在mid位置，因此right = mid； 如果第mid个版本没错，则第一个出错版本在[mid+1,right]，因此left = mid+1; 当循环条件为left&lt;=right时，会陷入死循环。 总结：当right的赋值表达式为 right = mid 时，循环条件为 left &lt; right。 123456789101112131415161718192021222324252627# The isBadVersion API is already defined for you.# @param version, an integer# @return a booldef isBadVersion(version): if version in (1,2,3): return False elif version in (4,5): return Trueclass Solution(object): def firstBadVersion(self, n): """ :type n: int :rtype: int """ left, right = 1, n while left &lt; right: mid = left + (right-left)//2 if isBadVersion(mid): right = mid else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().firstBadVersion(5) print(result) 540. 有序数组中的单一元素题目描述给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例 2: 输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 解题思路如果题目不限制在 O(log n)时间复杂度运行，可使用异或运算。1234567891011def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for i in nums: res ^= i return res 使用二分查找法实现O(log n)时间复杂度和 O(1)空间复杂度。初始令左右指针分别为 0，len(nums)-1;当left&lt;= right时循环：mid = left+(right-left)//2 当nums[mid] == nums[mid-1]时，数组可以分为[left, mid-2], [mid+1, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-2]长度为偶数，则目标位于[mid+1, right]，令left = mid +1;当mid为偶数时，说明[left, mid-2]长度为奇数，则目标位于该数组内，令right = mid -1; 同理当nums[mid] == nums[mid+1]时，数组可以分为[left, mid-1], [mid+2, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-1]长度为奇数，则目标位于该数组内，令right = mid -1;当mid为偶数时，说明[left, mid-1]长度为偶数，则目标位于[mid+2, right]，令left = mid +1; 当nums[mid]与nums[mid - 1], nums[mid + 1]均不相等，则返回nums[mid]。 1234567891011121314151617181920212223242526class Solution(object): def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left) //2 if mid-1 &gt;= 0 and nums[mid] == nums[mid-1]: if mid %2 == 1: left = mid + 1 else: right = mid - 2 elif mid+1 &lt;= len(nums)-1 and nums[mid] == nums[mid+1]: if mid %2 == 1: right = mid - 1 else: left = mid + 2 else: return nums[mid]if __name__ == '__main__': result = Solution().singleNonDuplicate([3,3,7,7,10,11,11]) print(result) 744. 寻找比目标字母大的最小字母题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 示例: 输入:letters = [“c”, “f”, “j”]target = “a”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f” 输入:letters = [“c”, “f”, “j”]target = “g”输出: “j” 输入:letters = [“c”, “f”, “j”]target = “j”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “k”输出: “c” 注: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路二分搜索。注意当有重复字母时，如[“e”,”e”,”e”,”e”,”e”,”e”,”n”,”n”,”n”,”n”],”e”，当letters[mid] 小于及 等于 target时，left都要向前走一步;如果left大于右边界时，说明target比数组里的所有字母都大，返回letters[0];否则返回letters[left]。 1234567891011121314151617181920class Solution(object): def nextGreatestLetter(self, letters, target): """ :type letters: List[str] :type target: str :rtype: str """ if len(letters) == 0: return '' left, right = 0, len(letters)-1 while left &lt;= right: mid = left + (right-left)//2 if letters[mid] &lt;= target: left = mid + 1 else: right = mid - 1 return letters[0] if left == len(letters) else letters[left]if __name__ == '__main__': result = Solution().nextGreatestLetter(["e","e","e","e","e","e","n","n","n","n"],"e") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 搜索]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是搜索相关题目题解总结。 [TOC] 搜索本文内容主要包括广度优先搜索(breadth first search)，深度优先搜索(depth first search)。 广度优先搜索(BFS)主要思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点依次访问它们的邻接点，并使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起点，重复上述过程，直至图中所有顶点都被访问到。 注意：遍历过的节点不能再次被遍历。 每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。 实现 BFS 时需要考虑以下问题：队列：用来存储每一轮遍历得到的节点；标记：对于遍历过的节点，应该将它标记，防止重复遍历。 无向图的广度优先搜索 第1步：访问A。并将C，D，F加入到访问队列，[C,D,F] 第2步：访问C。并将 B加入到访问队列，[D,F,B] 第3步：访问D。由于D的邻接点C已经访问过，则不加入访问队列，[F,B]; 第4步：访问F。并将G加入访问队列，[B,G]; 第5步：访问B。 第6步：访问G。并将E加入到访问队列，[E]; 第7步：访问E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索 访问顺序：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 深度优先搜索(DFS)主要思想：假设初始状态所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历，直到所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问到。 深度优先搜索是一个递归的过程。 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种可达性问题。 实现 DFS 时需要考虑以下问题：栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。 无向图的深度优先搜索访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 参考 127. 单词接龙题目描述给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -“hot” -“dot” -“dog” -“cog”, 返回它的长度 5。 示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 解题思路使用BFS，最短路的思路。将beginWord放进队列，如果队列不为空，那么取出第一个数，将其周围的在字典的字符放进队列，直到周围的存在endword。1234567891011121314151617181920212223242526import collectionsclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) queue = collections.deque() queue.append([beginWord, 1]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i + 1:] if nextWord in wordList: wordList.remove(nextWord) queue.append([nextWord, length + 1]) return 0if __name__ == '__main__': result = Solution().ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]) print(result) 123456789101112131415161718192021222324class Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) stack = [(beginWord, 1)] while stack: word, length = stack.pop(0) if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i+1:] if nextWord in wordList: wordList.remove(nextWord) stack.append((nextWord, length+1)) return 0 130. 被围绕的区域题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例:1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为：1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路从边上开始搜索，如果是’O’,那么搜索’O’周围的元素，并将’O’置换为’D’。如果该’O’周围都是’X’，则会跳出，这样内部的’O’将不受影响。最后没有被’X’围住的’O’都置换成了’D’,被围住的’O’还是’O’，没有改变。然后遍历一遍，将’O’置换为’X’，将’D’置换为’O’。 在leetcode中文网站无法提交，英文网站正常。 迭代 BFS。123456789101112131415161718192021222324252627class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ import collections queue = collections.deque([]) for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board) - 1] or c in [0, len(board[0]) - 1]) and board[r][c] == "O": queue.append((r, c)) while queue: r, c = queue.popleft() if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == "O": board[r][c] = "D" queue.append((r - 1, c)) queue.append((r + 1, c)) queue.append((r, c - 1)) queue.append((r, c + 1)) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == "O": board[r][c] = "X" elif board[r][c] == "D": board[r][c] = "O" 递归 DFS1234567891011121314151617181920212223class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O': self.dfs(board, r, c) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == 'O': board[r][c] = 'X' elif board[r][c] == 'D': board[r][c] = 'O' def dfs(self, board, r, c): if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == 'O': board[r][c] = 'D' self.dfs(board, r-1, c) self.dfs(board, r+1, c) self.dfs(board, r, c-1) self.dfs(board, r, c+1) 133. 克隆图题目描述克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。 OJ的无向图序列化： 节点被唯一标记。 我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。 例如，序列化无向图 {0,1,2#1,2#2,2}。 该图总共有三个节点, 被两个分隔符 # 分为三部分。 第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。 第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。 第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。 我们将图形可视化如下： 解题思路由于遍历一个图有两种方式：bfs和dfs。所以深拷贝一个图也可以采用这两种方法。不管使用dfs还是bfs都需要一个哈希表map来存储原图中的节点和新图中的节点的一一映射。map的作用在于替代bfs和dfs中的visit数组，一旦map中出现了映射关系，就说明已经复制完成，也就是已经访问过了。 BFS12345678910111213141516171819202122232425262728# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None queue = [] dic = &#123;&#125; newhead = UndirectedGraphNode(node.label) dic[node] = newhead queue.append(node) while queue: curr = queue.pop() for neighbor in curr.neighbors: if neighbor not in dic: copy = UndirectedGraphNode(neighbor.label) dic[curr].neighbors.append(copy) dic[neighbor] = copy queue.append(neighbor) else: dic[curr].neighbors.append(dic[neighbor]) return newhead DFS12345678910111213141516171819202122# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None return self.dfs(node, &#123;&#125;) def dfs(self, input, dic): if input in dic: return dic[input] output = UndirectedGraphNode(input.label) dic[input] = output for neighbor in input.neighbors: output.neighbors.append(self.dfs(neighbor, dic)) return output 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 解题思路按层次遍历，没层取最右边元素。 BFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res DFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, 0, res) return [level[-1] for level in res] def dfs(self, root, level, res): if not root: return [] if level == len(res): res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 200. 岛屿的个数题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路给定由0和1组成的二维数组，求1的连通块。 BFS 超时12345678910111213141516171819202122232425262728class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.bfs(grid, i, j) count += 1 return count def bfs(self, grid, i, j): queue = collections.deque() queue.append((i,j)) grid[i][j] = '#' direction = [(0,1), (0,-1), (1,0), (-1,0)] while queue: i, j = queue.popleft() for d in direction: r, c = i + d[0], i + d[1] if 0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0]) and grid[r][c] == '1': grid[r][c] == '#' queue.append((r, c)) DFS12345678910111213141516171819202122class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0]) and grid[i][j] == '1': grid[i][j] = '#' self.dfs(grid, i-1, j) self.dfs(grid, i+1, j) self.dfs(grid, i, j-1) self.dfs(grid, i, j+1) 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路使用DFS，如n=12，首先计算出可能存在的平方数candidate = [1,4,9]，然后对当前残差及candidate进行遍历，直到残差等于candidate，则返回。 123456789101112131415161718192021222324252627282930313233class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ if n &lt; 0: return 0 if n &lt;= 1: return 1 candidate = [] i = 1 while i*i &lt;= n: candidate.append(i*i) i += 1 count = 0 toCheck = &#123;n&#125; while toCheck: count += 1 temp = set() for residue in toCheck: for cand in candidate: if residue == cand: return count if residue &lt; cand: break temp.add(residue-cand) toCheck = temp return countif __name__ == '__main__': result = Solution().numSquares(12) print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数学]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是数学相关题目题解总结。 [TOC] 2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路使用哨兵节点，设置进位carry，直接相加，当进位为1时加到下一位。 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next 第一次写的思路：先求和，在构建链表。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 num1, num2 = 0, 0 base = 1 while l1: num1 += l1.val * base base *= 10 l1 = l1.next base = 1 while l2: num2 += l2.val*base base *= 10 l2 = l2.next num = num1 + num2 if num == 0: root = ListNode(0) return root return self.helper(num) def helper(self, num): if num == 0: return None root = ListNode(num % 10) root.next = self.helper(num // 10) return root 7. 整数反转题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:1假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路123456789101112131415class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &lt; 0: x = -x flag = -1 res = 0 while x: res = res * 10 + x % 10 x = x // 10 return res * flag if -2**31 &lt;= res &lt;= 2**31-1 else 0 8. 字符串转换整数 (atoi)题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:12输入: "42"输出: 42 示例 2:1234输入: " -42"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: "4193 with words"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:1234输入: "words and 987"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: "-91283472332"输出: -2147483648解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路一个一个条件判断。。。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def myAtoi(self, str): """ :type str: str :rtype: int """ if not str: return 0 i = 0 while i &lt; len(str) and str[i] == ' ': i += 1 if i == len(str) or str[i] not in '1234567890+-': return 0 flag = 1 if str[i] in '+-': if i == len(str)-1 or str[i+1] not in '1234567890': return 0 elif str[i] == '-': flag = -1 i = i+1 start = i end = start while end &lt; len(str) and str[end] in '1234567890': end += 1 res = flag*int(str[start:end]) if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 9. 回文数题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:1234输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶: 你能不将整数转为字符串来解决这个问题吗？ 解题思路1234567891011121314151617class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False xhat = 0 temp = x while temp: xhat = xhat*10 + temp % 10 temp //= 10 return x == xhat 12345678910111213141516171819class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) left, right = 0, len(x)-1 while left &lt; right: if x[left] != x[right]: return False left += 1 right -= 1 return True 12. 整数转罗马数字题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:12输入: 3输出: "III" 示例 2:12输入: 4输出: "IV" 示例 3:12输入: 9输出: "IX" 示例 4:123输入: 58输出: "LVIII"解释: L = 50, V = 5, III = 3. 示例 5:123输入: 1994输出: "MCMXCIV"解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ if not num: return '' val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = '' for i in range(len(val)): while num &gt;= val[i]: res += st[i] num -= val[i] return res 13. 罗马数字转整数题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: "III"输出: 3 示例 2:12输入: "IV"输出: 4 示例 3:12输入: "IX"输出: 9 示例 4:123输入: "LVIII"输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: "MCMXCIV"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920212223class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if not s: return 0 val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] Dict = &#123;'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 'IV':4,'I':1&#125; res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in Dict: res += Dict[s[i:i+2]] i += 2 else: res += Dict[s[i]] i += 1 return res 1234567891011121314151617181920212223242526class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] strs = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in strs: index = strs.index(s[i:i+2]) res += vals[index] i += 2 else: index = strs.index(s[i]) res += vals[index] i += 1 return res 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 43. 字符串相乘题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1:12输入: num1 = "2", num2 = "3"输出: "6" 示例 2:12输入: num1 = "123", num2 = "456"输出: "56088" 说明：1234num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路按照乘法竖式计算，将num1和num2翻转，用num1中的每一个数和num2进行相乘，乘法过程中考虑进位和位数。 1234567891011121314151617181920212223class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ if num1 == '0' or num2 == '0': return '0' res = 0 for i, n1 in enumerate(num1[::-1]): carry = 0 temp = 0 for j, n2 in enumerate(num2[::-1]): multi = (ord(n1)-ord('0')) * (ord(n2)-ord('0')) carrytemp, val = multi//10, multi%10 temp += (val+carry) * (10**j) carry = carrytemp temp += carry * (10**len(num2)) res += temp * (10**i) return str(res) 二刷。 123456789101112131415161718192021222324252627282930class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ num1, num2 = num1[::-1], num2[::-1] temp = [0]*(len(num1)+len(num2)) for i in range(len(num1)): for j in range(len(num2)): temp[i+j] += (ord(num1[i])-ord('0')) * (ord(num2[j])-ord('0')) res = [] for i in range(len(temp)): digit = temp[i] % 10 carry = temp[i] // 10 if i &lt; len(temp)-1: temp[i+1] += carry res.insert(0, str(digit)) i = 0 while i&lt;len(res)-1 and res[i] == '0': i += 1 res = res[i:] return ''.join(res) 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：123456"123""132""213""231""312""321" 给定 n 和 k，返回第 k 个排列。 说明：12给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:12输入: n = 3, k = 3输出: "213" 示例 2:12输入: n = 4, k = 9输出: "2314" 解题思路以n=4, k=9为例，初始化k=k-1=8。 最高位可取数字为[1,2,3,4]，每一个取值都有3!=6种取法，那么第9个下标为k//(n-1)!=8//6=1，即2，可取数字删去2更新为[1,3,4]，k=k%(n-1)!=2； 次高位可取数字为[1,3,4]，每一个取值都有2!=2种取法，那么第九个下标为k//(n-1-1)!=2//2=1,即3，可取数字删去3更新为[1,4]，k=k%(n-1-1)!=0； 第三位可取数字为[1,4]，每一个取值都有1!=1中取法，那么第九个下标为k//(n-1-1-1)!=0//1=0，即1，可取数字删去1更新为[4]，k=k%(n-1-1-1)=0; 第四位为[4]。 123456789101112131415161718192021222324252627class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' num = [str(i) for i in range(1, n+1)] fact = [1] * n for i in range(1, n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' res = '' k = k-1 for i in range(n): index = k // fact[n-1-i] res += num[index] num.pop(index) k = k % fact[n-1-i] return res 66. 加一题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路数九。从最后一位开始遍历，若当前遍历的值为9，则置为0；如果不是9，则当前位加1跳出循环；最后判断最高位是否为0，若为0，则需要在增加数组长度，即在最高位之前插入1。 123456789101112131415161718192021class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] for i in range(len(digits))[::-1]: if digits[i] == 9: digits[i] = 0 continue else: digits[i] += 1 break if digits[0] == 0: digits.insert(0, 1) return digits 采用进位。初始化进位为0，首先对最后一位加1操作，从后向前遍历，当当前位加上进位等于10时，将改为置0，进位置1，如小于10，则将进位置0，跳出循环。 1234567891011121314151617181920212223242526class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] pos = len(digits)-1 carry = 0 digits[-1] += 1 while pos &gt;= 0: digits[pos] += carry if digits[pos] &gt;= 10: digits[pos] -= 10 carry = 1 else: carry = 0 break pos -= 1 if carry: digits.insert(0, 1) return digits 一刷。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] temp = 0 for x in digits: temp = temp*10 + x temp += 1 res = [] while temp: res.insert(0, temp%10) temp //= 10 return res 67. 二进制求和题目描述给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1:12输入: a = "11", b = "1"输出: "100" 示例 2:12输入: a = "1010", b = "1011"输出: "10101" 解题思路设置当前位和plus，从后向前遍历，将每一位(plus%2)加入到结果中，将进位(plus//2)赋给下一次迭代位和plus。 1234567891011121314151617181920212223242526class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ res = '' carry = 0 m, n, plus = len(a)-1, len(b)-1, 0 i, j = m, n res = '' while i &gt;= 0 or j &gt;= 0 or plus: if i &gt;= 0: plus += int(a[i]) i -= 1 if j &gt;= 0: plus += int(b[j]) j -= 1 res = str(plus%2) + res plus //= 2 return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:12输入: 4输出: 2 示例 2:1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路二分查找。 12345678910111213141516171819202122class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x &lt;= 1: return x left, right = 1, x while left &lt;= right: mid = left + (right-left)//2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: "0.5" 示例 2:12输入: numerator = 2, denominator = 1输出: "2" 示例 3:12输入: numerator = 2, denominator = 3输出: "0.(6)" 解题思路先处理分子，分母为零，负数的情况。然后使用字典将余数保存起来，当余数不为零时，在结果后加小数位数，当余数重复出现时，找到最开始重复的位置，加括号返回。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ if denominator == 0: return '' if numerator == 0: return '0' res = '' if numerator*denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) remainder = numerator % denominator if remainder == 0: return res res += '.' Dict = &#123;&#125; Dict[remainder] = len(res) while remainder: remainder *= 10 res += str(remainder // denominator) remainder %= denominator if remainder in Dict: start = Dict[remainder] res = res[:start] + '(' + res[start:] + ')' break else: Dict[remainder] = len(res) return res 168. Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如，123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1:12输入: 1输出: "A" 示例 2:12输入: 28输出: "AB" 示例 3:12输入: 701输出: "ZY" 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def convertToTitle(self, n): """ :type n: int :rtype: str """ res = '' while n: if n % 26 == 0: res = 'Z' + res n -= 26 else: res = chr(n % 26 -1 + ord('A')) + res n -= n % 26 n //= 26 return res 171. Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如，12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1:12输入: "A"输出: 1 示例 2:12输入: "AB"输出: 28 示例 3:12输入: "ZY"输出: 701 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 base = 1 for x in s[::-1]: res += (ord(x) - ord('A') + 1) * base base *= 26 return res 123456789101112class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 for x in s: res = res*26 + (ord(x) - ord('A') + 1) return res 172. 阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1:123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2:123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 6!=[123456]，其中25才有0，所以可以抛开其他数据，只看2,5出现的次数； 10!=[12345678910]，有2,5组成的有2,4(22),5,6(23),8(222),10(25)，一个2和一个5配对产生一个0，所以有两个配对有两个0。由于2一定比5多，只对5计数就可以了。 123456789101112class Solution(object): def trailingZeroes(self, n): """ :type n: int :rtype: int """ res = 0 while n: n //= 5 res += n return res 202. 快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例:1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路12345678910111213141516171819202122232425262728class Solution(object): def isHappy(self, n): """ :type n: int :rtype: bool """ if n == 0: return False if n == 1: return True seen = [n] while n != 1: lastN = n nextN = 0 while lastN: nextN += (lastN % 10) ** 2 lastN //= 10 n = nextN if n in seen: return False seen.append(n) return True 204. 计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路超时12345678910111213141516171819202122class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = 0 for i in range(2, n): flag = 1 for j in range(2, i): if i % j == 0: flag = 0 break if flag: res += 1 return res 厄拉多塞筛法.比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推. 首先生成了一个全部为1的列表 res= [1] * n 因为0和1不是质数,所以列表的前两个位置赋值为0 res[0],res[1] = 0,0 此时从index = 2开始遍历,res[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引,全部赋值为0.此时res[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推. 123456789101112131415161718class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = [1] * n res[0], res[1] = 0, 0 for i in range(2, int(n**0.5)+1): if res[i] == 1: res[i*i:n:i] = [0] * len(res[i*i:n:i]) return sum(res) 223. 矩形面积题目描述在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例:12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 解题思路分两种情况，第一种是不重叠，第二种重叠123456789101112131415161718class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): """ :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int """ if E &gt;= C or A &gt;= G or F &gt;= D or B &gt;= H: return (C-A)*(D-B) + (G-E)*(H-F) else: return (C-A)*(D-B) + (G-E)*(H-F) - (min(G,C)-max(A,E)) * (min(D,H)-max(B,F)) 231. 2的幂题目描述12345678910111213141516给定一个整数，编写一个函数来判断它是否是 2 的幂次方。示例 1:输入: 1输出: true解释: 20 = 1示例 2:输入: 16输出: true解释: 24 = 16示例 3:输入: 218输出: false 解题思路2的幂的二进制中只有一位是1.12345678910111213141516171819class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False res = 0 while n: if n &amp; 1: res += 1 if res &gt;= 2: return False n &gt;&gt;= 1 return True 2的幂的数 n和(n-1)相与一定是0，不为0则不是2的幂 如8(0000 1000) &amp; 7 (0000 0111) ==024(0001 1000) &amp; 23 (0001 0111) != 0 1234567891011class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False return n&amp;(n-1) == 0 258. 各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例:123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路暴力12345678910111213141516171819class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num while num &gt;= 10: lastn = num nextn = 0 while lastn: nextn += lastn % 10 lastn //= 10 num = nextn return num 余9法。1234567891011假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。 参考1234567891011121314class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num if num % 9 == 0: return 9 else: return num % 9 263. 丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:123输入: 6输出: true解释: 6 = 2 × 3 示例 2:123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3:123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明：121 是丑数。2 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路不断的除5,3,2，最后为1则为丑数 12345678910111213141516class Solution(object): def isUgly(self, num): """ :type num: int :rtype: bool """ if num == 0: return False for x in [5,3,2]: while num and num % x == 0: num //= x if num == 1: return True return False 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路1234567891011121314151617181920212223242526class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 dp = [0] * (n) dp[0] = 1 t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp[i] = min(dp[t2]*2, dp[t3]*3, dp[t5]*5) if dp[t2]*2 == dp[i]: t2 += 1 if dp[t3]*3 == dp[i]: t3 += 1 if dp[t5]*5 == dp[i]: t5 += 1 return dp[-1] 313. 超级丑数题目描述编写一段程序来查找第 n 个超级丑数。 超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。 示例:123输入: n = 12, primes = [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 说明:12341 是任何给定 primes 的超级丑数。 给定 primes 中的数字以升序排列。0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。第 n 个超级丑数确保在 32 位有符整数范围内。 解题思路123456789101112131415161718192021222324252627class Solution(object): def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ if n &lt;= 1: return n dp = [0] * n dp[0] = 1 t = [0] * len(primes) for i in range(1, n): temp = float('inf') for j in range(len(t)): temp = min(temp, dp[t[j]]*primes[j]) dp[i] = temp for j in range(len(t)): if temp == dp[t[j]]*primes[j]: t[j] += 1 return dp[-1] 319. 灯泡开关题目描述初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例:123456789输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 解题思路暴力超时。1234567891011121314151617181920class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 if n &lt;= 3: return 1 dp = [1] * n for i in range(1, n): for i in range(i, n, i+1): dp[i] *= -1 return dp.count(1) 数学法。开平方？12345678class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ return int(n**0.5) 326. 3的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27输出: true示例 2: 输入: 0输出: false示例 3: 输入: 9输出: true示例 4: 输入: 45输出: false进阶：你能不使用循环或者递归来完成本题吗？ 解题思路1234567891011121314class Solution(object): def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 0: return False while n % 3 == 0: n //= 3 return n == 1 365. 水壶问题题目描述有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空示例 1: (From the famous “Die Hard” example)12输入: x = 3, y = 5, z = 4输出: True 示例 2:12输入: x = 2, y = 6, z = 5输出: False 解题思路1234567891011121314151617这是一道脑筋急转弯题，我想很多人以前应该听过这道题目，有一个容量为3升和一个容量为5升的水罐，问我们如何准确的称出4升的水。我想很多人都知道怎么做，先把5升水罐装满水，倒到3升水罐里，这时5升水罐里还有2升水，然后把3升水罐里的水都倒掉，把5升水罐中的2升水倒入3升水罐中，这时候把5升水罐解满，然后往此时有2升水的3升水罐里倒水，这样5升水罐倒出1升后还剩4升即为所求。这个很多人都知道，但是这道题随意给我们了三个参数，问有没有解法，这就比较难了。这里我就照搬网上大神的讲解吧：这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为x和y，问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么我们可以用一个公式来表达：z = m * x + n * y其中m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即3升的水罐往外倒了两次水，5升水罐往里舀了两次水。那么问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立。根据裴蜀定理，ax + by = d的解为 d = gcd(x, y)，那么我们只要只要z % d == 0，上面的等式就有解，所以问题就迎刃而解了，我们只要看z是不是x和y的最大公约数的倍数就行了，别忘了还有个限制条件x + y &gt;= z，因为x和y不可能称出比它们之和还多的水，参见代码如下；时间复杂度很小，但是不会算，空间复杂度是O(1). 参考 123456789101112131415161718class Solution(object): def canMeasureWater(self, x, y, z): """ :type x: int :type y: int :type z: int :rtype: bool """ return z == 0 or (x+y &gt;= z and z % self.gcd(x, y) == 0) def gcd(self, x, y): res = x % y while res != 0: x, y = y, res res = x % y return y 367. 有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：12输入：16输出：True 示例 2：12输入：14输出：False 解题思路二分搜索12345678910111213141516171819202122class Solution(object): def isPerfectSquare(self, num): """ :type num: int :rtype: bool """ if num == 0: return False left, right = 1, int(num**0.5)+1 while left &lt;= right: mid = left + (right-left)//2 if mid*mid == num: return True elif mid*mid &gt; num: right = mid-1 else: left = mid+1 return False 372. 超级次方题目描述你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1:12输入: a = 2, b = [3]输出: 8 示例 2:12输入: a = 2, b = [1,0]输出: 1024 解题思路二分求幂123456789101112131415161718192021class Solution(object): def superPow(self, a, b): """ :type a: int :type b: List[int] :rtype: int """ res = 1 for n in b: res = self.pow(res, 10) * self.pow(a, n) % 1337 return res def pow(self, x, n): if x == 1 or n == 0: return 1 if n % 2: return self.pow(x, n-1) * x % 1337 else: return self.pow(x*x%1337, n//2) % 1337 396. 旋转函数题目描述给定一个长度为 n 的整数数组 A 。 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：1F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。 计算F(0), F(1), …, F(n-1)中的最大值。 注意:可以认为 n 的值小于 105。 示例:12345678A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。 解题思路看了数据规模是10^5，可以知道时间复杂度是O(N)量级，这就难办了。我们为了找规律，先把具体的数字抽象为A,B,C,D，那么我们可以得到：123456789101112F(0) = 0A + 1B + 2C +3DF(1) = 0D + 1A + 2B +3CF(2) = 0C + 1D + 2A +3BF(3) = 0B + 1C + 2D +3A 那么，我们通过仔细观察，我们可以得出下面的规律：123456789F(1) = F(0) + sum - 4DF(2) = F(1) + sum - 4CF(3) = F(2) + sum - 4B 那么我们就找到规律了,1F(i) = F(i-1) + sum - n * A[n-i]， 是个递推公式。我们最后求的是这个所有F(i)中的最大值。 时间复杂度是O(N)，空间复杂度是O(1). 参考12345678910111213141516class Solution(object): def maxRotateFunction(self, A): """ :type A: List[int] :rtype: int """ sumA = sum(A) f = sum(i*A[i] for i in range(len(A))) res = f for i in range(1, len(A)): f = f + sumA - len(A)*A[-i] res = max(res, f) return res 397. 整数替换题目描述给定一个正整数 n，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。n 变为 1 所需的最小替换次数是多少？ 示例 1:12345678输入:8输出:3解释:8 -&gt; 4 -&gt; 2 -&gt; 1 示例 2:12345678910输入:7输出:4解释:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1或7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 解题思路思路1：递归，速度很慢1234567891011121314151617class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n &lt;= 1: return 0 if n == 2: return 1 if n % 2 == 0: return 1 + self.integerReplacement(n//2) else: return 1 + min(self.integerReplacement(n-1), self.integerReplacement(n+1)) 思路2：位运算，速度很快当n是偶数时，直接除2；当n是奇数时，-1还是+1？奇数二进制数一定是01或者11结尾，如果把一个奇数化为4的倍数，变成1的步骤会更少（3除外）：15-&gt;16-&gt;8-&gt;4-&gt;2-&gt;115-&gt;14-&gt;7-&gt;6-&gt;3-&gt;2-&gt;1 因此：如果结尾是01，减1，如果结尾时11，加1，3的时候直接减1。 1234567891011121314151617181920212223class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 res = 0 while n &gt; 1: res += 1 if n % 2 == 0: n &gt;&gt;= 1 else: if n &amp; 2 and n != 3: n += 1 else: n -= 1 return res 400. 第N个数字题目描述在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1:12345输入:3输出:3 示例 2:12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 解题思路一位数字有9个，有9位；2位数字有910=90个，有290=180位；3位数字有9100=900个，有3900=2700位； 首先找到n是几位数字，然后找到n是所在位数的第几个数字，最后求在这个数字的第几位上。 1234567891011121314151617181920212223class Solution(object): def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt;= 9: return n bitlen = 1 count = 9 start = 1 while n &gt; bitlen*count: n -= bitlen*count bitlen += 1 count *= 10 start *= 10 res = start + (n-1) // bitlen return str(res)[(n-1) % bitlen]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 哈希表]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是哈希表相关题目题解总结。 [TOC] 哈希表哈希表使用O(N)的空间复杂度存储数据，并且以O(1)的时间复杂度求解问题。 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i 3. 无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2:123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3:1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 解题思路使用字典保存字符最后一次出现的位置，如果这个字符在前面出现过，即这个区间已经有重复的字符了，需要更新左边界，移动到当前遍历字符在字典中保存的位置的下一个位置，同时更新当前字符的位置（右边界）。 123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 left = 0 Dict = &#123;&#125; for right in range(len(s)): if s[right] in Dict: left = max(left, Dict[s[right]]+1) Dict[s[right]] = right res = max(res, right-left+1) return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 36. 有效的数独题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ ["5","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]]输出: true 示例 2:123456789101112131415输入:[ ["8","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 解题思路遍历每一个不为’.’的位置，将其值保存下来，并将其所在位置暂时替换为无关字符，然后判断其所在行、列和9宫格内是否重复，如果重复则直接返回，否则将其位置重新赋原来的值。1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False for x in range(len(board)): for y in range(len(board[0])): if board[x][y] == '.': continue val = board[x][y] board[x][y] = 'D' if not self.isValid(x, y, board, val): return False else: board[x][y] = val return True def isValid(self, x, y, board, val): for i in range(len(board)): if board[i][y] == val: return False for i in range(len(board[0])): if board[x][i] == val: return False for i in range(3): for j in range(3): if board[(x//3)*3+i][(y//3)*3+j] == val: return False return True 依次判断行、列和九宫格是否有重复的，使用set去重然后与没去重的比较长度。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False return self.isValidRow(board) and self.isValidCol(board) and self.isValidSpace(board) def isValidRow(self, board): for row in range(len(board)): temp = [board[row][col] for col in range(len(board[0])) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidCol(self, board): for col in range(len(board[0])): temp = [board[row][col] for row in range(len(board)) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidSpace(self, board): for i in range(0, len(board), 3): for j in range(0, len(board[0]), 3): temp = [] for row in range(3): for col in range(3): if board[row+i][col+j] != '.': temp.append(board[row+i][col+j]) if len(set(temp)) != len(temp): return False return True 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ for i in range(9): if not self.judge(board[i]): return False for i in range(9): temp = [] for j in range(9): temp.append(board[j][i]) if not self.judge(temp): return False for i in range(0,9,3): for j in range(0,9,3): temp = [] for row in range(3): for col in range(3): temp.append(board[row+i][col+j]) if not self.judge(temp): return False return True def judge(self, nums): Dict = &#123;&#125; for x in nums: if x == '.': continue if x in Dict: return False Dict[x] = 1 return True 49. 字母异位词分组题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: ["eat", "tea", "tan", "ate", "nat", "bat"],输出:[ ["ate","eat","tea"], ["nat","tan"], ["bat"]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路遍历字符串，对字符串进行排序，使用字典将同样的字符串放在一起。 123456789101112131415161718192021222324class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ if len(strs) == 0: return [] Dict = &#123;&#125; for x in strs: temp = ''.join(sorted(x)) if temp not in Dict: Dict[temp] = [x] else: Dict[temp].append(x) # res = []# for val in Dict.values():# res.append(val) # return res return list(Dict.values()) 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: "0.5" 示例 2:12输入: numerator = 2, denominator = 1输出: "2" 示例 3:12输入: numerator = 2, denominator = 3输出: "0.(6)" 解题思路用字典保存余数及余数对应的结果的长度，当余数存在于字典中时，说明为循环小数，循环起始位字典中保存的位置。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ res = '' if numerator * denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) residue = numerator % denominator if residue == 0: return res res += '.' Dict = &#123;&#125; Dict[residue] = len(res) while residue: numerator = residue * 10 res += str(numerator // denominator) residue = numerator % denominator if residue not in Dict: Dict[residue] = len(res) else: start = Dict[residue] res = res[:start] + '(' + res[start:] + ')' break return res 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"输出: ["AAAAACCCCC", "CCCCCAAAAA"] 解题思路12345678910111213141516class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 242. 有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1:12输入: s = "anagram", t = "nagaram"输出: true 示例 2:12输入: s = "rat", t = "car"输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路水123456789class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ return sorted(s) == sorted(t) 词频统计1234567891011121314151617181920212223class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(s) != len(t): return False scnt = [0] * 26 tcnt = [0] * 26 for i in range(len(s)): scnt[ord(s[i]) - 97] += 1 tcnt[ord(t[i]) - 97] += 1 for i in range(26): if scnt[i] != tcnt[i]: return False return True 274. H指数题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）” 示例:1234输入: citations = [3,0,6,1,5]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 解题思路好难理解。。。1234567891011121314151617class Solution(object): def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ if len(citations) == 0: return 0 maxi = len(citations) for x in sorted(citations):#假设h为N 那么所有的论文引用次数都大于等于N，如果存在引用次数小于N,h- if x &gt;= maxi: break else: maxi -= 1 return maxi 290. 单词模式题目描述给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。 这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。 示例1:12输入: pattern = "abba", str = "dog cat cat dog"输出: true 示例 2:12输入:pattern = "abba", str = "dog cat cat fish"输出: false 示例 3:12输入: pattern = "aaaa", str = "dog cat cat dog"输出: false 示例 4:12输入: pattern = "abba", str = "dog dog dog dog"输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路分别将pattern和str分割，如果长度不一致则返回False 使用hash表，遍历pattern，依次保存pattern和str的映射关系 如果某个pattern[i]不存在hash表中，需要首先判断对应的str[i]是否已经在hash表中，如果在说明该str[i]已经被其他pattern占用，返回False; 如果某个pattern[i]已经在hash中，那么只需要判断当前对应的str[i]是否和保存起来的str是否一致即可。 12345678910111213141516171819202122232425class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ pattern = list(pattern) str = str.split() if len(pattern) != len(str): return False Dict = &#123;&#125; for i in range(len(pattern)): if pattern[i] not in Dict: if str[i] in Dict.values(): return False Dict[pattern[i]] = str[i] else: if str[i] != Dict[pattern[i]]: return False return True]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 位运算]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是位运算相关题目题解总结。 [TOC] 位运算基本原理0s表示一串0，1s表示一串1。123x^0s = x x&amp;0s = 0 x|0s = xx^1s = ~x x&amp;1s = x x|1s = 1sx^x = 0 x&amp;x = x x|x = x 利用x^1s=~x的特点，可以将位级表示翻转； 利用x^x=0的特点，可以将三个数中重复的两个数去除，只留下另一个数； 利用x&amp;0s=0和x&amp;1s=x的特点，可以实现掩码操作，一个数num与mask进行位与操作，只保留num中与mask的1部分相对应的位；例如num:10101010和mask:00111100，进行位与操作得00101000。 利用x|0s=x和x|1s=1s的特点，可以实现设值操作，一个数num与mask进行位或操作，将num中与mask中的1部分相对应的位都设置为1；例如num:10101010和mask:00111100，进行位或操作得10111110。 位与运算技巧： n&amp;(n-1) 表示去掉n的位级表示中最低位的1。例如n:10110100，减去1得到10110011，将这两个数相与得到10110000。 n&amp;(-n)表示n的位级表示中的最低位的1，-n得到n的反码加1，对于二进制表示10110100，-n得到01001100，相与得到00000100。 n-n&amp;(~n+1)表示去掉n的位级表示中的最高位的1。例如n:10110100，则n-n&amp;(~n+1): ??? 移位运算： &gt;&gt;n为算术右移，相当于除以2^n； &gt;&gt;n为无符号右移，左边会补上0； &lt;&lt;n为算术左移，相当于乘以2^n。 mask计算： 要获取11111111，将0取反即可，~0； 要得到只有第i位为1的mask，将1向左移动i-1位即可，1&lt;&lt;(i-1)。例如1&lt;&lt;4得到只有第5位为1的mask：00010000； 要得到1到i位为1的mask，(1&lt;&lt;(i+1))-1即可，例如将1&lt;&lt;(4+1)-1=00010000-1=00001111； 要得到1到i位为0的mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。 参考 136. 只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 解题思路方法1：使用异或操作，一个数自己异或自己等于0, 一个数异或0等于数本身，即把所有数字进行异或操作，如果一个数出现两次，则变为0消失，最后剩下只出现一次的数字。 123456789101112class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for x in nums: res ^= x return res 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。1234567891011121314151617class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key in Dict: if Dict[key] == 1: return key 137. 只出现一次的数字 II题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,3,2]输出: 3 示例 2:12输入: [0,1,0,1,0,1,99]输出: 99 解题思路方法1：位运算，把32位的二进制数进行遍历，统计所有数字的每一位出现0或1的次数。因为每个数字出现3次或者1次，当某一位出现次数不为3时，则一定是出现1次，使用或操作将每个位置叠加起来。python的整形没有最大值，当输入是负数时，会认为是很大的正数，如果大于2^31-1时，则需要减去2^32。1234567891011121314151617181920class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count % 3 == 1: res |= mask mask &lt;&lt;= 1 return res if res &gt;&gt; 31 == 0 else res-(1&lt;&lt;32) 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。123456789101112131415161718class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val == 1: return key 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1:12输入: [3,2,3]输出: 3 示例 2:12输入: [2,2,1,1,1,2,2]输出: 2 解题思路方法1：将原数组排序nums.sort()， 返回nums[len(nums)//2]; 方法2：使用字典记录每个数出现的次数，返回出现次数大于len(nums)//2的数；优化：在计数时同时判断数字出现的次数，只用一个for循环； 方法3：位运算，遍历二进制的每一位，每一位上的1或0（代码使用1）出现次数大于一半，即为所求的值在该位上的值，统计每一位的1或0组合即可，减去2^32对负数进行处理。以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去2 ^ 32。 1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count &gt; len(nums)//2: res |= mask break mask &lt;&lt;= 1 return res if res&gt;&gt;31 == 0 else res - (1&lt;&lt;32) 方法4：摩尔投票法，待续。 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"输出: ["AAAAACCCCC", "CCCCCAAAAA"] 解题思路方法1：遍历+set，从头到尾把字符串遍历，然后判断这10个字母是否已经出现过，如果出现过，则加入结果中，否则，加入辅助集合中。用set是因为一个字符串可能出现多次，为了防止重复添加到结果中，使用set去重。时间空间复杂度均为O(N)。1234567891011121314151617class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ if len(s) &lt; 10: return [] res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 方法2：位运算，待续 190. 颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1：1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 解题思路使用python二进制转换。12345678class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = '&#123;0:032b&#125;'.format(n) # 032b的0用于填充，0:32b为' 10100101000001111010011100'，0:032b为'00000010100101000001111010011100' res = res[::-1] res = int(res,2) return res 位运算。从n的最后一位向前遍历，放到res的后面，并且res向左移动。 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 for i in range(32): res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return res 12345678910111213class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 count = 0 while n: res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 count += 1 res = res&lt;&lt;(32-count) return res 191. 位1的个数题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题思路123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 while n: if n&amp;1: res += 1 n &gt;&gt;= 1 return res 123456789101112131415class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 mask = 1 for i in range(32): if mask &amp; n: res += 1 mask &lt;&lt;= 1 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 双指针]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是双指针相关题目题解总结。 [TOC] 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 28. 实现strStr()题目描述实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1:12输入: haystack = "hello", needle = "ll"输出: 2 示例 2:12输入: haystack = "aaaaa", needle = "bba"输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路123456789101112131415161718class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if len(needle) == 0: return 0 if len(haystack) == 0 or len(haystack) &lt; len(needle): return -1 for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 80. 删除排序数组中的重复项 II题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) left = 0 for n in nums: if left &lt; 2 or n &gt; nums[left-2]: nums[left] = n left += 1 return left 88. 合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出:[1,2,2,3,5,6] 解题思路 从尾向前遍历，设置两个指针p1和p2遍历数组，p1，p2分别从m-1和n-1开始向前遍历； 每一次遍历将大的元素放到nums1后面（最后一位为m-n+1），并向前移动一步，直到一个数组先遍历完成； 若nums1首先遍历完成，则需要将nums2剩下的元素放到nums1的前面。 123456789101112131415161718192021222324252627class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ if len(nums1)&lt; m+n: return False p1,p2 = m-1,n-1 point = m+n-1 while p1&gt;= 0 and p2 &gt;= 0: if nums1[p1]&lt;nums2[p2]: nums1[point] = nums2[p2] p2 -= 1 else: nums1[point] = nums1[p1] p1 -= 1 point -= 1 if p2 &gt;= 0: nums1[:p2+1] = nums2[:p2+1]if __name__ == '__main__': result = Solution().merge([1,2,3,0,0,0],3,[2,5,6],3) print(result) 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 141. 环形链表题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用双指针，一个一次走两步，另一个一次走一步，若有环，则必然相遇。 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始， 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2。 解题思路使用两个指针left和right，left指向数组第一个元素并从头向后遍历，right指向数组最后一个元素并从尾向前遍历： 如果两个指针指向元素之和numbers[left]+numbers[right] == target, 则返回 [left+1,right+1]，结束； 如果两个指针指向元素之和numbers[left]+numbers[right] &gt; target，则right -= 1； 如果两个指针指向元素之和numbers[left]+numbers[right] &lt; target，则left += 1。 12345678910111213141516171819202122class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt; 2: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().twoSum([2,7,11,15], 9) print(result) 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路123456789101112131415161718192021class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt;= 1: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return [] 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路12345678910111213141516171819class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ left, right = 0, 0 res = float('inf') while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res != float('inf') else 0 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明: 元音字母不包含字母”y”。 解题思路元音字母有五个：aAeEIioOuU。使用双指针，left从头向后遍历，right从后向前遍历，分别找到元音字母时时进行一次交换。 1234567891011121314151617181920212223class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ vowels = 'aAeEiIoOuU' s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in vowels: left += 1 while right &gt; left and s[right] not in vowels: right -= 1 if left &lt; right: s[left],s[right] = s[right], s[left] left += 1 right -= 1 return ''.join(s)if __name__ == '__main__': result = Solution().reverseVowels("leetcode") print(result) 524. 通过删除字母匹配到字典里最长单词题目描述给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例 1: 输入:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出:“apple” 示例 2: 输入:s = “abpcplea”, d = [“a”,”b”,”c”]输出:“a” 说明: 所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 解题思路先把d中元素排序，以长度为主，字典序为辅；然后遍历d中字符串，依此判断是否满足条件，满足条件则返回；因为经过了排序，第一个满足条件的可以保证返回长度最长且字典顺序最小的字符串。 123456789101112131415161718192021222324252627282930313233class Solution(object): def findLongestWord(self, s, d): """ :type s: str :type d: List[str] :rtype: str """ if len(d) == 0 or len(s) == 0: return '' d = sorted(d, key=lambda x: (-len(x), x)) res = '' for x in d: if self.judge(s,x): return x return '' def judge(self,s,x): if len(s) &lt; len(x): return False p1,p2 = 0, 0 while p1 &lt; len(s) and p2 &lt; len(x): if s[p1] == x[p2]: p1 += 1 p2 += 1 else: p1 += 1 if p2 == len(x): return True return Falseif __name__ == '__main__': result = Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) print(result) 633. 平方数之和题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1： 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 解题思路假设\(a=0\)，则 \(b=\sqrt{c}\)，则最大整数为 \(\sqrt{c}\)，设置两个指针，left指向0并向前遍历，right指向\(\sqrt{c}\)并向后遍历： 如果 left*left+right*right = c， 返回True,结束； 如果 left*left+right*right &gt; c， right -= 1； 如果 left*left+right*right &lt; c， left += 1； 123456789101112131415161718192021class Solution(object): def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ if c &lt; 0: return False left, right = 0, int(pow(c,1.0/2)) while left &lt;= right: if left*left+right*right == c: return True elif left*left+right*right &gt; c: right -= 1 else: left += 1 return Falseif __name__ == '__main__': result = Solution().judgeSquareSum(6) print(result) 680. 验证回文字符串 Ⅱ题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意： 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路使用双指针，找到第一个不相等的位置后，去除left或着right后判断是否成为回文。 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): """ :type s: str :rtype: bool """ left, right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return self.isPalindrome(s[:left]+s[left+1:]) or self.isPalindrome(s[:right]+s[right+1:]) left += 1 right -= 1 return True def isPalindrome(self,s): left ,right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == '__main__': result = Solution().validPalindrome("aba") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 排序]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是排序相关题目题解总结。 [TOC] 排序快速排序用于求解 Kth 问题，使用快速排序的partition()进行实现，需要首先打乱数组，否则最坏情况下时间复杂度为O(N^2)。 堆排序用于求解 TopK 问题，通过维护一个大小为K的堆，堆中的元素就是TopK elements； 堆排序也可以用于求解 Kth 问题，堆顶元素就是 Kth elements； 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements； 因此快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 56. 合并区间题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 将区间按起始元素排序，新建返回res数组，遍历所有区间； 若res为空或res中最后一个区间的结束元素小于当前区间的起始元素，则无需合并，直接将该区间添加到res中；若res中最后一个区间的结束元素大于当前区间的起始元素，则需要合并，将res最后区间的结束元素置为原来的值与当前区间结束值的最大值。 1234567891011121314151617181920# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ intervals = sorted(intervals, key=lambda x:x.start) res = [] for t in intervals: if not res or res[-1].end &lt; t.start: res.append(t) else: res[-1].end = max(res[-1].end,t.end) return res 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 147. 对链表进行插入排序题目描述对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。 示例 1： 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路插入排序：插入排序的实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），用指针 head 逐一向后遍历 申请一个 dummyHead 节点，其下一个节点指向头结点。如果要在头结点出插入，dummyHead 会给我们带来便利； 当 head 的值不大于下一节点值，就进行遍历下一节点； 当 head 的值大于下一节点，那么就将 head 的下一节点取出，从前向后扫描，在第一个比它的值大的节点之前插入该节点。 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: temp = head.next q = dummy head.next = head.next.next while q.next and q.next.val &lt; temp.val: q = q.next temp.next = q.next q.next = temp return dummy.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head and head.next: if head.val &lt;= head.next.val: head = head.next else: pre = dummy while pre.next and pre.next.val &lt;= head.next.val: pre = pre.next temp = head.next head.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路使用归并排序，使用快慢指针找到中间结点后进行递归。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Nonehead = ListNode(4)head.next = ListNode(2)head.next.next = ListNode(1)head.next.next.next = ListNode(3)class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None # left = self.sortList(leftHead) # right = self.sortList(rightHead) # sortMerge = self.merge(left,right) # return sortMerge return self.merge(self.sortList(leftHead),self.sortList(rightHead)) def getmiddle(self,head): if not head: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self,leftHead,rightHead): dummyNode = ListNode(0) dummyHead = dummyNode i,j = leftHead, rightHead while i and j: if i.val &lt; j.val: dummyNode.next = i i = i.next else: dummyNode.next = j j = j.next dummyNode = dummyNode.next if i: dummyNode.next = i if j: dummyNode.next = j return dummyHead.nextif __name__ == '__main__': result = Solution().sortList(head) while result: print(result.val,end = ' ') result = result.next 179. 最大数题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2]输出: 210 示例 2: 输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路两层循环遍历，每一个数和之后的每一个数进行比较，交换大的数放在前面；两个数谁应该放在前面：拼接两个字符串进行比较 a+b&gt;b+a，则a在前面。 1234567891011121314151617class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ if len(nums) == 0: return '0' if len(nums) == 1: return str(nums[0]) for i in range(len(nums)-1): for j in range(i+1, len(nums)): if str(nums[i])+str(nums[j]) &lt; str(nums[j])+str(nums[i]): nums[i], nums[j] = nums[j], nums[i] return '0' if nums[0] == 0 else ''.join([str(x) for x in nums]) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路思路1：利用堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质；即子结点的键值或索引总是小于（或者大于）它的父节点。 通常堆是通过一维数组来实现的。在起始数组为 0 的情形中 父节点i的左子节点在位置 (2i+1)；父节点i的右子节点在位置 (2i+2)；子节点i的父节点在位置 floor((i-1)/2)。 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作 最大堆调整（Min_Heapify）：将堆的末端子结点作调整，使得子结点永远小于父结点；创建最大堆（Build_Min_Heap）：将堆所有数据重新排序;注：堆排序不是一种稳定排序。 用小根堆得办法寻找最大的K个数 用容量为K的最小堆来存储最大的K个数。最小堆的堆顶元素就是最大K个数中的最小的一个；每次扫描一个数据X，如果X比堆顶元素Y小，则不需要改变原来的堆。如果X比堆顶元素大；那么用X替换堆顶元素Y，在替换之后，X可能破坏了最小堆的结构，需要调整堆来维持堆的性质；调整过程时间复杂度为O(logK)。 全部的时间复杂度为O(N*logK)；这种方法当数据量比较大的时候，比较方便。因为对所有的数据只会遍历一次。 堆排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k,len(nums)+1): if change: for j in range(k//2,-1,-1): self.adjust(res,j,k) for j in range(k-1,0,-1): res[j],res[0] = res[0],res[j] self.adjust(res,0,j) change = False if i != len(nums) and nums[i] &gt; res[k-1]: res[k-1] = nums[i] change = True return res[k-1] def adjust(self,res,parent,length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1]&lt;res[child]: child = child+1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = tempif __name__ == '__main__': result = Solution().findKthLargest([3,2,3,1,2,4,5,5,6],4) print(result) 思路2：利用快速排序 快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：分割左边都是比它小的数，右边都是比它大的数。 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，因此达到整个数据变成有序序列。 举例：nums = [3,2,1,5,6,4] 首先以nums[0]=3为基准点，设置指针left指向第一个元素(0)，right指向最后一个元素(len(nums)-1)； 从右至左偏移right指针，寻找到第一个比基准点3小的元素，将该元素(这里为1)赋给left指针所指的位置，此时数组为[1,2,1,5,6,4]; 从左至右偏移left指针，寻找到第一个比基准点3大的元素，将该元素赋给right指针所指的位置，此时数组 不断循环步骤一二，知道left和right重合，将基准点3赋给重合位置，一轮排序结束数组为[1,2,3,5,6,4]; 经过递归过程，最后排序结束。 **快速排序1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left 思路3：归并排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = self.dfs(nums) return res[-k] def dfs(self, nums): if len(nums) &lt;= 1: return nums mid = len(nums)//2 left = self.dfs(nums[:mid]) right = self.dfs(nums[mid:]) return self.merge(left, right) def merge(self, left, right): res = [] i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 if i &lt; len(left): res += left[i:] else: res += right[j:] return res 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 451. 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 栈和队列]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是栈和队列相关题目题解总结。 [TOC] 栈和队列栈的顺序为后进先出，队列 的顺序为先进先出。 20. 有效的括号题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: "()"输出: true 示例 2:12输入: "()[]&#123;&#125;"输出: true 示例 3:12输入: "(]"输出: false 示例 4:12输入: "([)]"输出: false 示例 5:12输入: "&#123;[]&#125;"输出: true 解题思路使用栈，遍历字符串，当栈为空或者当前字符为左括号’(‘,’[‘,’{‘时或者为右括号但是栈顶字符与其不匹配，则将字符加入栈，否则栈顶字符出栈。最后判断栈是否为空。12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ if not s: return True Dict = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for c in s: if not stack or c not in Dict or stack[-1] != Dict[c]: stack.append(c) else: stack.pop() return True if not stack else False 71. 简化路径题目描述以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：123输入："/home/"输出："/home"解释：注意，最后一个目录名后面没有斜杠。 示例 2：123输入："/../"输出："/"解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：123输入："/home//foo/"输出："/home/foo"解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：12输入："/a/./b/../../c/"输出："/c" 示例 5：12输入："/a/../../b/../c//.//"输出："/c" 示例 6：12输入："/a//b////c/d//././/.."输出："/a/b/c" 解题思路将字符串按照‘/‘分隔得到了每个文件的目录，然后遍历每个目录进行入栈或者出栈。如果目录为空或者为当前目录’.’，则不进行任何操作；如果为’..’，表示返回上一级目录，如果栈中有上级目录，则将其弹出。 12345678910111213141516171819class Solution(object): def simplifyPath(self, path): """ :type path: str :rtype: str """ if not path: return '/' stack = [] path = path.split('/') for c in path: if not c or c == '.': continue if c == '..': if stack: stack.pop() else: stack.append(c) return '/'+'/'.join(stack) 150. 逆波兰表达式求值题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：123输入: ["2", "1", "+", "3", "*"]输出: 9解释: ((2 + 1) * 3) = 9 示例 2：123输入: ["4", "13", "5", "/", "+"]输出: 6解释: (4 + (13 / 5)) = 6 示例 3：12345678910输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 12345678910111213141516171819202122232425class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for c in tokens: if c not in ('+','-','*','/'): stack.append(c) else: a = int(stack.pop()) b = int(stack.pop()) if c == '+': stack.append(str(b+a)) if c == '-': stack.append(str(b-a)) if c == '*': stack.append(str(b*a)) if c == '/': if b*a &lt; 0 and b%a != 0: stack.append(str(b/a+1)) else: stack.append(str(b/a)) return int(stack[0]) 155. 最小栈题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.data = [] self.min = [] def push(self, x): """ :type x: int :rtype: void """ self.data.append(x) if not self.min or x &lt;= self.min[-1]: self.min.append(x) def pop(self): """ :rtype: void """ val = self.data.pop() if val == self.min[-1]: self.min.pop() def top(self): """ :rtype: int """ return self.data[-1] def getMin(self): """ :rtype: int """ return self.min[-1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是字符串相关题目题解总结。 [TOC] 6. Z 字形变换题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数：1string convert(string s, int numRows); 示例 1:12输入: s = "LEETCODEISHIRING", numRows = 3输出: "LCIRETOESIIGEDHN" 示例 2:12345678输入: s = "LEETCODEISHIRING", numRows = 4输出: "LDREOEIIECIHNTSG"解释:L D RE O E I IE C I H NT S G 解题思路将字符分为numRows保存，遍历字符串，从上到下和从下到上反复将字符加到对应的行里，当遍历到第一行时，index递增，当遍历到最后一行时，index递减。 12345678910111213141516171819202122232425class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): return s res = ['' for i in range(numRows)] index = 0 step = 1 for x in s: res[index] += x if index == 0: step = 1 elif index == numRows-1: step = -1 index += step return ''.join(res) 14. 最长公共前缀题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: ["flower","flow","flight"]输出: "fl" 示例 2:123输入: ["dog","racecar","car"]输出: ""解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路首先把第一个字符串作为答案，然后遍历后面的字符串，当后面的字符串长度小于第一个字符串时，需要对第一个字符串进行裁剪，然后依次判断每一个字符是否相等，不相等时将第一个字符串裁剪。 12345678910111213141516171819202122class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' res = strs[0] for i in range(1, len(strs)): if len(res) &gt; len(strs[i]): res = res[:len(strs[i])] for j in range(len(res)): if res[j] != strs[i][j]: res = res[:j] break if res == '': return '' return res 38. 报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。 11 被读作 “two 1s” (“两个一”）, 即 21。 21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:12输入: 1输出: "1" 示例 2:12输入: 4输出: "1211" 解题思路1234567891011121314151617181920212223class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return '1' pre = '1' for i in range(1, n): count = 1 res = '' for j in range(1, len(pre)): if pre[j] == pre[j-1]: count += 1 else: res += str(count) + pre[j-1] count = 1 res += str(count) + pre[-1] pre = res return res 58. 最后一个单词的长度题目描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: "Hello World"输出: 5 解题思路库函数。123456789101112class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 s = s.split() return len(s[-1]) if s else 0 双指针，一个指向最后一个单词的末尾，一个指向最后一个单词的开头。1234567891011121314151617181920class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 left, right = 0, len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 left = right while left &gt;= 0 and s[left] != ' ': left -= 1 return right - left 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: "aab"输出:[ ["aa","b"], ["a","a","b"]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。 示例 2：1234输入: s = "applepenapple", wordDict = ["apple", "pen"]输出: true解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 151. 翻转字符串里的单词题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例:12输入: "the sky is blue",输出: "blue is sky the". 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 解题思路库函数1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return ' '.join(s.split()[::-1]) 自己写的。先将头尾的空格去掉，新建一个字符串，将单词字符加入，去掉多余的空格。 然后先将整个字符串翻转，在将每个单词翻转。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ if not s: return "" left = 0 while left &lt; len(s) and s[left] == ' ': left += 1 right = len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 s = s[left:right+1] newstring = '' i = 0 while i &lt; len(s): if s[i] != ' ': newstring += s[i] i += 1 else: newstring += ' ' while i &lt; len(s) and s[i] == ' ': i += 1 newstring = list(newstring) self.reverse(newstring, 0, len(newstring)) start, end = 0, 0 while end &lt; len(newstring): while end &lt; len(newstring) and newstring[end] != ' ': end += 1 self.reverse(newstring, start, end) start = end + 1 end = start return ''.join(newstring) def reverse(self, s, start, end): left, right = start, end-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 165. 比较版本号题目描述比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1:12输入: version1 = "0.1", version2 = "1.1"输出: -1 示例 2:12输入: version1 = "1.0.1", version2 = "1"输出: 1 示例 3:12输入: version1 = "7.5.2.4", version2 = "7.5.3"输出: -1 示例 4：123输入：version1 = "1.01", version2 = "1.001"输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5：123输入：version1 = "1.0", version2 = "1.0.0"输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示： 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。 版本字符串不以点开始或结束，并且其中不会有两个连续的点。 解题思路先将两个版本号以’.’分隔为两个列表，然后按位比较，短的补零。1234567891011121314151617181920212223242526class Solution(object): def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ if not version1 or not version2: return 0 version1 = version1.split('.') version2 = version2.split('.') i = 0 while i &lt; len(version1) or i &lt; len(version2): v1 = version1[i] if i &lt; len(version1) else 0 v2 = version2[i] if i &lt; len(version2) else 0 if int(v1) &gt; int(v2): return 1 if int(v1) &lt; int(v2): return -1 i += 1 return 0 227. 基本计算器 II题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:12输入: "3+2*2"输出: 7 示例 2:12输入: " 3/2 "输出: 1 示例 3:12输入: " 3+5 / 2 "输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路用num保存上一个数字，用pre_op保存上一个操作符。当遇到新的操作符的时候，需要根据pre_op进行操作。乘除的优先级高于加减。所以有以下规则： 之前的运算符是+，那么需要把之前的数字num进栈，然后等待下一个操作数的到来。 之前的运算符是-，那么需要把之前的数字求反-num进栈，然后等待下一个操作数的到来。 之前的运算符是×，那么需要立刻出栈和之前的数字相乘，重新进栈，然后等待下一个操作数的到来。 之前的运算符是/，那么需要立刻出栈和之前的数字相除，重新进栈，然后等待下一个操作数的到来。 注意比较的都是之前的操作符和操作数，现在遇到的操作符是没有什么用的。 另外，坑爹的Python地板除。 参考 12345678910111213141516171819202122232425262728293031323334class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 stack = [] num = 0 pre_op = '+' for i in range(len(s)): if s[i] in '0123456789': num = num*10+int(s[i]) if i == len(s)-1 or s[i] in '+-*/': if pre_op == '+': stack.append(num) elif pre_op == '-': stack.append(-num) elif pre_op == '*': stack.append(stack.pop()*num) elif pre_op == '/': top = stack.pop() if top*num &lt; 0 and top % num != 0: stack.append(top // num + 1) else: stack.append(top // num) pre_op = s[i] num = 0 return sum(stack) 344. 反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：12输入：["h","e","l","l","o"]输出：["o","l","l","e","h"] 示例 2：12输入：["H","a","n","n","a","h"]输出：["h","a","n","n","a","H"] 解题思路12345678class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ s[:] = s[::-1] 1234567891011121314class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left, right = left + 1, right - 1 return 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:12输入: "hello"输出: "holle" 示例 2:12输入: "leetcode"输出: "leotcede" 说明:元音字母不包含字母”y”。 解题思路12345678910111213141516171819class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in 'aAeEiIoOuU': left += 1 while right &gt; left and s[right] not in 'aAeEiIoOuU': right -= 1 s[left], s[right] = s[right], s[left] left, right = left+1, right-1 return ''.join(s) 383. 赎金信题目描述给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。123canConstruct("a", "b") -&gt; falsecanConstruct("aa", "ab") -&gt; falsecanConstruct("aa", "aab") -&gt; true 解题思路遍历ransomNote，如果不在magazine，返回False，如果在，删除magazine中对应的字符。 需要转成list才可以用remove。 12345678910111213141516171819202122class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if len(ransomNote ) == 0: return True if len(magazine) == 0: return False magazine = list(magazine) for x in ransomNote: if x not in magazine: return False else: magazine.remove(x) return True 385. 迷你语法分析器题目描述给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。 列表中的每个元素只可能是整数或整数嵌套列表 提示：你可以假定这些字符串都是格式良好的： 字符串非空字符串不包含空格字符串只包含数字0-9, [, - ,, ] 示例 1：123456给定 s = "324",你应该返回一个 NestedInteger 对象，其中只包含整数值 324。``` 示例 2： 给定 s = “[123,[456,[789]]]”, 返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表： 一个 integer 包含值 123 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273###解题思路###不太理解。[参考](https://leetcode.com/problems/mini-parser/discuss/86221/Easy-Python-recursive-solution-and-stack-solution-please-be-careful-about-time-complexity)```python# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def __init__(self, value=None):# """# If value is not specified, initializes an empty list.# Otherwise initializes a single integer equal to value.# """## def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def add(self, elem):# """# Set this NestedInteger to hold a nested list and adds a nested integer elem to it.# :rtype void# """## def setInteger(self, value):# """# Set this NestedInteger to hold a single integer equal to value.# :rtype void# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class Solution(object): def deserialize(self, s): """ :type s: str :rtype: NestedInteger """ if len(s) == 0: return NestedInteger() if s[0] != '[': return NestedInteger(int(s)) res = NestedInteger() numP, start = 0, 1 for i in range(1, len(s)): if (numP == 0 and s[i] == ',') or i == len(s)-1: if start &lt; i: res.add(self.deserialize(s[start:i])) start = i + 1 elif s[i] == '[': numP += 1 elif s[i] == ']': numP -= 1 return res 387. 字符串中的第一个唯一字符题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = "leetcode"返回 0.s = "loveleetcode",返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路两次遍历 12345678910111213141516171819202122class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return -1 Dict = &#123;&#125; for x in s: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for i in range(len(s)): if Dict[s[i]] == 1: return i return -1 415. 字符串相加题目描述给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路123456789101112131415161718192021222324252627282930313233343536class Solution(object): def addStrings(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ midsum = [] num1, num2 = num1[::-1], num2[::-1] index = 0 while index &lt; len(num1) and index &lt; len(num2): midsum.append(ord(num1[index])-48 + ord(num2[index]) - 48) index += 1 if index == len(num1): for i in range(index, len(num2)): midsum.append(ord(num2[i]) - 48) else: for i in range(index, len(num1)): midsum.append(ord(num1[i]) - 48) res = '' plus = 0 for x in midsum: num = plus + x res = str(num % 10) + res plus = num // 10 if plus: res = str(plus) + res return res 434. 字符串中的单词数题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:12输入: "Hello, my name is John"输出: 5 解题思路12345678910class Solution(object): def countSegments(self, s): """ :type s: str :rtype: int """ s = s.split() return len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数组]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是数组相关题目题解总结。 [TOC] 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415161718class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt;= 1: return False Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i return False 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 31. 下一个排列题目描述解题思路先找到从后面开始数第一个降序的位置，在将这个位置之后的数字翻转，然后遍历翻转的部分数字，最后交换这个降序数字和后面第一个比他大的数。12345678910111213141516171819202122class Solution(object): def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums) &lt; 2: return index = len(nums) - 2 while index &gt;= 0: if nums[index] &lt; nums[index+1]: #从后找到第一个降序数字 break index -= 1 nums[index+1:] = nums[index+1:][::-1] #将降序数字后面的数字翻转 for i in range(index+1, len(nums)): if nums[i] &gt; nums[index]: #在翻转的数字中找到第一个大于降序数字的 nums[i], nums[index] = nums[index], nums[i] #交换 break 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 48. 旋转图像题目描述给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路1234567891011121314class Solution(object): def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ # 先沿着左上右下的对角线翻转 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] #在翻转每一行 for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 54. 螺旋矩阵题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2:1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路从左到右，从上到下，从右到左，从下到上，循环。123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if len(matrix) == 0: return [] top, buttom = 0, len(matrix)-1 left, right = 0, len(matrix[0])-1 res = [] while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1, buttom+1): res.append(matrix[i][right]) if top &lt; buttom: # 当top==buttom时，最后为一行，前面已经从左到右遍历过，不需重复遍历 for i in range(right-1, left-1, -1): res.append(matrix[buttom][i]) if left &lt; right: # 当left == right时， 最后为一列，前面已经从上到下遍历过了，不需重复遍历 for i in range(buttom-1, top, -1): res.append(matrix[i][left]) top, buttom = top+1, buttom-1 left, right = left+1, right-1 return res 59. 螺旋矩阵 II题目描述给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ if n == 0: return [] if n == 1: return [[1]] matrix = [[0]*n for i in range(n)] top, buttom = 0, n-1 left, right = 0, n-1 val = 1 while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): matrix[top][i] = val val += 1 for i in range(top+1, buttom+1): matrix[i][right] = val val += 1 if top &lt; buttom: for i in range(right-1, left-1, -1): matrix[buttom][i] = val val += 1 if left &lt; right: for i in range(buttom-1, top, -1): matrix[i][left] = val val += 1 top, buttom = top+1, buttom-1 left, right = left+1, right-1 return matrix 73. 矩阵置零题目描述给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1:123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2:123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路O(m+n)12345678910111213141516171819202122class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = [False] * len(matrix) col = [False] * len(matrix[0]) # 找出0的位置 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: row[i] = True col[j] = True # 将0所在的行和列置0 for i in range(len(matrix)): for j in range(len(matrix[0])): if row[i] or col[j]: matrix[i][j] = 0 将0所在的行或列的其他位置置为’#’，然后替换成0123456789101112131415161718192021222324class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ if len(matrix) == 0: return for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): if matrix[i][k] != 0: matrix[i][k] = '#' for k in range(len(matrix)): if matrix[k][j] != 0: matrix[k][j] = '#' for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == '#': matrix[i][j] = 0 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 118. 杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路12345678910111213141516171819202122class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(2, numRows+1): pre = res[-1] temp = [] i = 0 while i &lt; len(pre)-1: temp.append(pre[i]+pre[i+1]) i += 1 res.append([1]+temp+[1]) return res 119. 杨辉三角 II题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路123456789101112131415161718class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ if rowIndex == 0: return [1] res = [1] for i in range(2, rowIndex+2): temp = [] for i in range(len(res)-1): temp.append(res[i]+res[i+1]) res = [1]+temp+[1] return res 189. 旋转数组题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1:123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解题思路切片，拼接1234567891011121314class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return nums k = k%len(nums) nums[:] = nums[-k:]+nums[:-k] 先把所有的翻转，然后在对0~k和k~n分别进行翻转。12345678910111213141516171819202122class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return k = k%len(nums) self.reverse(nums, 0, len(nums)-1) self.reverse(nums, 0, k-1) self.reverse(nums, k, len(nums)-1) def reverse(self, nums, left, right): while left &lt; right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路双指针 123456789101112131415161718192021222324class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = float('inf') left, right = 0, 0 while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res!=float('inf') else 0 216. 组合总和 III题目描述找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2:12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0 or n &gt; 45: return [] nums = [x for x in range(1, 10)] res = [] self.dfs(nums, [], 0, k, n, res) return res def dfs(self, nums, path, index, k, target, res): if k == 0 and target == 0 and path: res.append(path) return for i in range(index, len(nums)): if nums[i] &gt; target: return self.dfs(nums, path+[nums[i]], i+1, k-1, target-nums[i], res) 217. 存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题思路12345678910111213class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 1: return False set1 = set(nums) return len(set1) != len(nums) 219. 存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1:12输入: nums = [1,2,3,1], k = 3输出: true 示例 2:12输入: nums = [1,0,1,1], k = 1输出: true 示例 3:12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路123456789101112131415161718192021class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ if len(nums) &lt;= 0 or k &lt;= 0: return False Dict = &#123;&#125; for i in range(len(nums)): if nums[i] not in Dict: Dict[nums[i]] = i else: if i - Dict[nums[i]] &lt;= k: return True Dict[nums[i]] = i return False 228. 汇总区间题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:123输入: [0,1,2,4,5,7]输出: ["0-&gt;2","4-&gt;5","7"]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:123输入: [0,2,3,4,6,8,9]输出: ["0","2-&gt;4","6","8-&gt;9"]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 解题思路1234567891011121314151617181920212223class Solution(object): def summaryRanges(self, nums): """ :type nums: List[int] :rtype: List[str] """ if len(nums) == 0: return [] res = [] i = 0 while i &lt; len(nums): j = i while j &lt; len(nums)-1 and nums[j+1] == nums[j]+1: j += 1 if i == j: res.append(str(nums[i])) else: res.append(str(nums[i])+'-&gt;'+str(nums[j])) i = j+1 return res 229. 求众数 II题目描述给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1:12输入: [3,2,3]输出: [3] 示例 2:12输入: [1,1,1,3,3,2,2,2]输出: [1,2] 解题思路1234567891011121314151617181920212223class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in set(nums): if Dict[x] &gt; len(nums)//3: res.append(x) return res 238. 除自身以外数组的乘积题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 解题思路123456789101112131415161718192021class Solution(object): def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] res = [1]*len(nums) for i in range(1, len(nums)): res[i] = res[i-1]*nums[i-1] temp = 1 for i in range(len(nums)-2, -1, -1): temp *= nums[i+1] res[i] *= temp return res 268. 缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:12输入: [3,0,1]输出: 2 示例 2:12输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路123456789101112131415class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = len(nums) for i in range(len(nums)): res ^= nums[i]^i return res 283. 移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路12345678910111213141516class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. """ if len(nums) &lt;= 1: return index = 0 for i in range(len(nums)): if nums[i] != 0: nums[index] = nums[i] index += 1 nums[index:] = [0] * (len(nums)-index) 287. 寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:12输入: [1,3,4,2,2]输出: 2 示例 2:12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路123456789101112131415161718192021class Solution(object): def findDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[fast] slow = nums[slow] return fast 289. 生命游戏题目描述根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例:1234567891011121314输入: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]输出: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] 进阶: 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def gameOfLife(self, board): """ :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. """ if len(board) == 0: return Live = [] Dead = [] for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: if self.judgeLive(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) else: if self.judgeDead(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) for pair in Live: board[pair[0]][pair[1]] = 1 for pair in Dead: board[pair[0]][pair[1]] = 0 def judgeLive(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if 2&lt;=count&lt;=3 else False def judgeDead(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if count==3 else False 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 381. O(1) 时间插入、删除和获取随机元素 - 允许重复题目描述设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。 remove(val)：当 val 存在时，从集合中移除一个 val。 getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例:1234567891011121314151617181920// 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection();// 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2);// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom();// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1);// getRandom 应有相同概率返回 1 和 2 。collection.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class RandomizedCollection(object): def __init__(self): """ Initialize your data structure here. """ self.data = [] def insert(self, val): """ Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.data: self.data.append(val) return True else: self.data.append(val) return False def remove(self, val): """ Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool """ if val not in self.data: return False else: self.data.remove(val) return True def getRandom(self): """ Get a random element from the collection. :rtype: int """ return random.choice(self.data)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 414. 第三大的数题目描述给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2:12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路123456789101112131415161718192021222324class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) s1, s2, s3 = float('-inf'), float('-inf'), float('-inf') for num in nums: if num &gt; s1: s1, s2, s3 = num, s1, s2 elif num &lt; s1 and num &gt; s2: s2, s3 = num, s2 elif num &lt; s2 and num &gt; s3: s3 = num return s3 if s3 != float('-inf') else max(s1, s2) 442. 数组中重复的数据题目描述给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例：12345输入:[4,3,2,7,8,2,3,1]输出:[2,3] 解题思路12345678910111213141516171819class Solution(object): def findDuplicates(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) &lt;= 1: return [] res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res 448. 找到所有数组中消失的数字题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路123456789101112131415161718192021class Solution(object): def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1] *= -1 res = [] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i+1) return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 链表]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是链表相关题目题解总结。 [TOC] 链表2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路设置哨兵节点，每次新建节点保存当前位的值，并将进位给下一次迭代用。 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = ListNode(0) cur = dummy plus = 0 while l1 or l2 or plus: if l1: plus += l1.val l1 = l1.next if l2: plus += l2.val l2 = l2.next cur.next = ListNode(plus%10) plus //= 10 cur = cur.next return dummy.next 19. 删除链表的倒数第N个节点题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 解题思路新建伪结点，先让原指针走n步，寻找到删除的位置，然后一起遍历，原指针走到尾了，伪指针走到要删除节点的前一个，将伪指针的下一个节点跳过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head or n &lt; 0: return None dummy = ListNode(0) dummy.next = head pre = dummy for i in range(n): head = head.next while head: head = head.next pre = pre.next pre.next = pre.next.next return dummy.next 21. 合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1: return l2 if not l2: return l1 dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val &lt; l2.val: pre.next = ListNode(l1.val) l1 = l1.next else: pre.next = ListNode(l2.val) l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路设置头节点，向后遍历。 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while pre.next and pre.next.next: cur = pre.next pre.next = pre.next.next cur.next = cur.next.next pre.next.next = cur pre = pre.next.next return dummy.next 61. 旋转链表题目描述给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题思路先求链表长度，当k&gt;length时，k对length求余，然后将链表后k个移到开头；使用快慢指针的方法找到后面k个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head length = 0 cur = head while cur: cur = cur.next length += 1 k = k % length if k == 0: return head fast, slow = head, head for i in range(k): fast = fast.next while fast.next: fast = fast.next slow = slow.next temp = slow.next slow.next = None fast.next = head # temp 就是结果，直接返回也可 head = temp return head 82. 删除排序链表中的重复元素 II题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2:12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解题思路要删除重复的节点，而头节点就有可能是重复的节点，因此新建头节点，同样的值略过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while head and head.next: if head.val != head.next.val: head = head.next pre = pre.next else: val = head.val while head and head.val == val: head = head.next pre.next = head return dummy.next 83. 删除排序链表中的重复元素题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2:12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路每次迭代判断当前节点和下一节点是否相等，若相等，该节点的下个节点等于下个节点的下个节点，相当于下个节点和当前节点相等，就跳过下个节点。 当当前节点和下一节点不相等时，当前节点往前走，判断下一节点。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head cur = head while cur.next: if cur.val == cur.next.val: cur.next = cur.next.next else: cur = cur.next return head 86. 分隔链表题目描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例:12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路用两个指针，分别保存比x小的及比x大的值，对原链表进行遍历根据值的大小拼接在相应的链表后面，最后在把两个链表拼接在一起就可以了。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) pre = dummy larger = ListNode(0) temp = larger while head: if head.val &lt; x: pre.next = head pre = pre.next else: node = ListNode(head.val) temp.next = node temp = temp.next head = head.next pre.next = larger.next return dummy.next 92. 反转链表 II题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy count = 1 while pre.next and count &lt; m: pre = pre.next count += 1 if count &lt; m: return head mNode = pre.next cur = mNode.next while cur and count &lt; n: Next = cur.next cur.next = pre.next pre.next = cur mNode.next = Next cur = Next count += 1 return dummy.next 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy for i in range(m-1): pre = pre.next cur = pre.next for i in range(n-m): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 109. 有序链表转换二叉搜索树题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路将链表转换为数组，然后构建二叉搜索树。 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ if not head: return None array = [] while head: array.append(head.val) head = head.next return self.helper(array) def helper(self, array): if len(array) == 0: return None mid = len(array)//2 root = TreeNode(array[mid]) root.left = self.helper(array[:mid]) root.right = self.helper(array[mid+1:]) return root 138. 复制带随机指针的链表题目描述给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深度拷贝。 解题思路首先复制label和next指针，然后复制random指针，最后拆分新旧链表。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def copyRandomList(self, head): """ :type head: RandomListNode :rtype: RandomListNode """ if not head: return head pre = head while pre: temp = pre.next pre.next = RandomListNode(pre.label) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next cur = res pre = head while pre: pre.next = pre.next.next if cur.next: cur.next = cur.next.next pre = pre.next cur = cur.next return res 二刷1234567891011121314151617181920212223242526272829303132333435363738394041"""# Definition for a Node.class Node(object): def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""class Solution(object): def copyRandomList(self, head): """ :type head: Node :rtype: Node """ if not head: return head pre = head while pre: temp = pre.next pre.next = Node(pre.val, None, None) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next pre = res while head: head.next = head.next.next if pre.next: pre.next = pre.next.next head = head.next pre = pre.next return res 141. 环形链表题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用快慢指针，如果有环一定相遇。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 142. 环形链表 II题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路快慢指针，找到换之后，一个指针从头遍历。 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: fast = head while fast != slow: fast = fast.next slow = slow.next return fast return None 集合。将访问过的节点保存起来，遍历节点，如果节点在字典中，则说明重复是为环的入口；否则没有环。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None Dict = set() while head: if head in Dict: return head Dict.add(head) head = head.next return None 143. 重排链表题目描述给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2:1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路 使用快慢指针先将链表从中间截断为两个链表，如果链表长度为奇数，则第一条链表长度多1；如1,2,3,4,5，拆分为1,2,3和4,5； 将第二条链表翻转；即4,5翻转为5,4 然后归并合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head or not head.next or not head.next.next: return fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next frontend = head backend = slow.next slow.next = None dummy = ListNode(0) dummy.next = backend cur = backend.next backend.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp backend = dummy.next p1 = frontend p2 = backend while p2: temp1 = p1.next temp2 = p2.next p1.next = p2 p2.next = temp1 p1 = temp1 p2 = temp2 147. 对链表进行插入排序题目描述对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2：12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路如果链表本来就是升序的，则往后遍历；否则如果一个节点的值小于前一个节点，寻找合适的位置插入。12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head while cur.next: if cur.val &lt; cur.next.val: cur = cur.next else: pre = dummy while pre.next and pre.next.val &lt; cur.next.val: pre = pre.next temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None left = self.sortList(leftHead) right = self.sortList(rightHead) return self.merge(left, right) def getmiddle(self, head): if not head or not head.next: return head fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self, left, right): dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 160. 相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1：123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路链表拼接 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None a, b = headA, headB while a or b: if not a: a = headB if not b: b = headA if a == b: return a a, b = a.next, b.next return None 第一次遍历，先计算两个链表的长度；第二次遍历，让长的先走长度差，然后同时移动，判断是否有相同节点。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None countA = countB = 0 a, b = headA, headB while a: a = a.next countA += 1 while b: b = b.next countB += 1 if countA &gt; countB: for i in range(countA-countB): headA = headA.next else: for i in range(countB-countA): headB = headB.next while headA and headB: if headA == headB: return headA headA, headB = headA.next, headB.next return None 206. 反转链表题目描述反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路迭代123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head return self.helper(head, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 234. 回文链表题目描述请判断一个链表是否为回文链表。 示例 1:12输入: 1-&gt;2输出: false 示例 2:12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None dummy = ListNode(0) dummy.next = right cur = right.next right.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp right = dummy.next while right: if right.val != left.val: return False right = right.next left = left.next return True 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True res = [] while head: res.append(head.val) head = head.next return res == res[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 分治算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是分治算法相关题目题解总结。 [TOC] 分治算法基本概念分治法字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或者更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。如快速排序，归并排序。 基本思想及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治法的策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 分治法使用场景分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题； 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑使用贪心法或者动态规划法； 第四条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可以使用分治法，但一般动态规划较好。 分治法的基本步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 分治法的应用二分搜索大整数乘法Strassen矩阵乘法棋盘覆盖合并排序快速排序线性时间选择最接近点对问题循环赛日程表汉诺塔 二分搜索 二分搜索的要求：线性表为有序表，并且要用向量作为表的存储结构； 二分搜索得基本思想：先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录位置。1234567891011121314151617class Solution(object): def searchRange(self, nums, key): """ :type nums: List[int] :type target: int :rtype: List[int] """ return self.bSearch(nums, 0, len(nums)-1,key) def bSearch(self, nums, left, right, key): mid = (left+right) // 2 if nums[mid] == key: return mid elif nums[mid] &gt; key: return self.bSearch(nums,left,mid-1,key) else: return self.bSearch(nums, mid+1,right,key) 汉诺塔从左到右 A B C 柱 大盘子在下, 小盘子在上, 借助B柱将所有盘子从A柱移动到C柱, 期间只有一个原则: 大盘子只能在小盘子的下面。求解思路： 当盘子只有一个的时候,只有一个动作 从 A 移动到 C 即结束； 当有N个盘子的时候, 中间的动作是从 A 移动到 C, 表示最下面的第N个盘子移动完毕； 中间动作之上都可以认为是: 从 A 移动到 B； 中间动作之下都可以认为是: 从 B 移动到 C。 12345678910class Solution(object): def move(self, n, a, b, c): if n == 1: print(a+'-&gt;'+c) else: self.move(n-1, a, c, b) print(a+'-&gt;'+ c) self.move(n-1, b, a, c)if __name__ == '__main__': Solution().move(3,'a','b','c') 参考https://www.cnblogs.com/xsyfl/p/6921687.htmlhttps://blog.csdn.net/not_guy/article/details/72823951 241. 为运算表达式设计优先级题目描述给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: “2-1-1”输出: [0, 2]解释:((2-1)-1) = 0(2-(1-1)) = 2 示例 2: 输入: “23-45”输出: [-34, -14, -10, -10, 10]解释:(2(3-(45))) = -34((23)-(45)) = -14((2(3-4))5) = -10(2((3-4)5)) = -10(((23)-4)5) = 10 解题思路如果字符串为数字直接返回；使用分治法，遍历字符串，当遇到运算符时，将字符串分为运算符前及运算符后两部分，根据运算符做相应运算。1234567891011121314151617181920212223242526272829class Solution(object): def diffWaysToCompute(self, input): """ :type input: str :rtype: List[int] """ if input.isdigit(): return [int(input)] res = [] for i in range(len(input)): if input[i] in '+-*': left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) for j in left: for k in right: res.append(self.helper(j, k, input[i])) return res def helper(self, j, k, op): if op == '+': return j + k elif op == '-': return j - k elif op == '*': return j * kif __name__ == '__main__': result = Solution().diffWaysToCompute("2*3-4*5") print(result) 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 解题思路摩尔投票法 维护一个候选数candidate和计数器counter。遍历数组中所有的元素， 设当前的元素为x，若 counter = 0,则 candidate = x, counter = 1; 否则， 根据candidate 与x是否相等来更新counter（相等+1，不等-1）在遍历一次，判断候选数是否为合法的主元素。为什么这样做是对的呢？因为若在有解的情况下，一个元素y出现&gt;n/2次，那么要抵消掉它，必然也要有相同的元素才行，而总的元素才n个，也就是说元素y在这样的计数中不会被抵消。保证有解的情况最后的候选数就是主要元素。1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ candidate = 0 count = 0 for x in nums: if count == 0: count = 1 candidate = x elif x == candidate: count += 1 else: count -= 1 return candidateif __name__ == '__main__': result = Solution().majorityElement([6,5,5]) print(result) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路 堆排序。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k, len(nums)+1): if change: for j in range(k//2, -1, -1): self.adjust(res, j, k) for j in range(k-1, 0, -1): res[j], res[0] = res[0], res[j] self.adjust(res, 0, j) change = False if i != len(nums) and nums[i] &gt; res[-1]: res[-1] = nums[i] change = True return res[-1] def adjust(self, res, parent, length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1] &lt; res[child]: child += 1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = temp 分治算法，这里使用快速排序算法。 通过一趟排序将要排序的数据分割成两个独立的两部分：左部分都是比它小的数，右部分都是比它大的数； 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，最终使整个数据变成有序序列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums[-k] def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 树]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是树相关题目题解总结。 [TOC] 94. 二叉树的中序遍历题目描述给定一个二叉树，返回它的中序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) return res 迭代123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] while True: while root: stack.append(root) root = root.left if not stack: return res root = stack.pop() res.append(root.val) root = root.right 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] self.allLeftIntoStack(root, stack) while stack: root = stack.pop() res.append(root.val) if root.right: self.allLeftIntoStack(root.right, stack) return res def allLeftIntoStack(self, root, stack): while root: stack.append(root) root = root.left 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:123456789101112131415161718输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路依次以1~n作为根节点，其左边的为左子树，右边的为右子树。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划 给定一个序列1,…,n，为了构造所有的二叉树，我们遍历以i为节点，则1,…,i-1为构成左子树，i+1,…,n构成右子树；然后通过递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。 设dp[n]为1,…,n组成二叉搜索树的个数，初始化dp[0]=1,dp[1]=1,dp[2]=2； dp[n] = F(1,n)+F(2,n)+…+F(n,n)F(i,n) = dp(i-1)dp(n-i-1), 如F(1,3) = dp[0]dp[2]F(i,n)为以i为根节点的二叉树个数。等于左右子树的排列的乘积。 dp[3] = dp[0]dp[2] + dp[1]dp[1] + dp[2]*dp[0] 因为dp[n] = dp[0]*dp[n-1] + dp[1][n-2] + … + dp[n-1]dp[0] 12345678910111213141516class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt; 3: return dp[n] dp += [0]*(n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[-1] 98. 验证二叉搜索树题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:12345输入: 2 / \ 1 3输出: true 示例 2:123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路根据二叉搜索树的定义，左子树的值在(left, root.val)之间，右子树的值在(root.val, right)，每次递归是判断当前节点值是否满足取值上界和下界，计算下一节点是要根据左右节点进行更新上下界。 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.dfs(root, float('-inf'), float('inf')) def dfs(self, root, left, right): if not root: return True if root.val &lt;= left or root.val &gt;= right: return False return self.dfs(root.left, left, root.val) and self.dfs(root.right, root.val, right) 先中序遍历（递归），判断数组是否升序。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] self.inorder(root, queue) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def inorder(self, root, queue): if not root: return self.inorder(root.left, queue) queue.append(root.val) self.inorder(root.right, queue) return queue 先中序遍历（迭代），判断数组是否升序。1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] stack = [] self.LeftintoStack(root, stack) while stack: root = stack.pop() queue.append(root.val) if root.right: self.LeftintoStack(root.right, stack) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def LeftintoStack(self, root, stack): if not root: return while root: stack.append(root) root = root.left 100. 相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1:1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2:1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3:1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题思路123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 101. 对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.judge(root.left, root.right) def judge(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.judge(left.left, right.right) and self.judge(left.right, right.left) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = collections.deque() queue.append([root.left, root.right]) while queue: pair = queue.popleft() left, right = pair[0], pair[1] if not left and not right: continue if not left or not right: return False if left.val != right.val: return False queue.append([left.left, right.right]) queue.append([left.right, right.left]) return True 102. 二叉树的层次遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其层次遍历结果：12345[ [3], [9,20], [15,7]] 解题思路迭代1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res 递归123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 103. 二叉树的锯齿形层次遍历题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]] 解题思路迭代123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res 递归123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 104. 二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解题思路递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res += 1 return res 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for node in queue: if node.left: temp.append(node.left) if node.right: temp.append(node.right) res += 1 queue = temp return res 105. 从前序与中序遍历序列构造二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if not preorder or not inorder: return None rootval = preorder[0] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root 106. 从中序与后序遍历序列构造二叉树题目描述根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ if not inorder or not postorder: return None rootval = postorder[-1] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root 107. 二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为：12345[ [15,7], [9,20], [3]] 解题思路递归1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res[::-1] def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res[::-1] 108. 将有序数组转换为二叉搜索树题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ if len(nums) == 0: return None mid = len(nums)//2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 110. 平衡二叉树题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7]12345 3 / \9 20 / \ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True leftdepth = self.getdepth(root.left) rightdepth = self.getdepth(root.right) if abs(leftdepth-rightdepth) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) def getdepth(self, root): if not root: return 0 return max(self.getdepth(root.left), self.getdepth(root.right)) + 1 111. 二叉树的最小深度题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回它的最小深度 2. 解题思路迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: res += 1 for i in range(len(queue)): node = queue.pop(0) if not node.left and not node.right: return res if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 递归1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if not root.left and root.right: return self.minDepth(root.right) + 1 if not root.right and root.left: return self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 112. 路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路递归12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False if not root.left and not root.right: return root.val == sum return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 回溯123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False return self.dfs(root, sum-root.val) def dfs(self, root, target): if not root: return False if target == 0 and not root.left and not root.right: return True left, right = False, False if root.left: left = self.dfs(root.left, target-root.left.val) if root.right: right = self.dfs(root.right, target-root.right.val) return left or right 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False queue = [(root, sum-root.val)] while queue: node, target = queue.pop(0) if not node: continue if not node.left and not node.right and target == 0: return True if node.left: queue.append((node.left, target-node.left.val)) if node.right: queue.append((node.right, target-node.right.val)) return False 113. 路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 解题思路回溯1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [root.val], res, sum) return res def dfs(self, root, path, res, target): if not root: return if sum(path) == target and not root.left and not root.right: res.append(path) if root.left: self.dfs(root.left, path+[root.left.val], res, target) if root.right: self.dfs(root.right, path+[root.right.val], res, target) 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [], res, sum) return res def dfs(self, root, path, res, target): if not root: return if not root.left and not root.right and target == root.val: path.append(root.val) res.append(path) if root.left: self.dfs(root.left, path+[root.val], res, target-root.val) if root.right: self.dfs(root.right, path+[root.val], res, target-root.val) 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] #if not root.left and not root.right and root.val == sum: # return [[root.val]] #temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) #return [[root.val]+i for i in temp] res = [] if not root.left and not root.right and root.val == sum: return [[root.val]] temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) for i in temp: res.append([root.val]+i) return res 迭代12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: node, target, temp = queue.pop(0) if not node.left and not node.right and target == sum: res.append(temp) if node.left: queue.append((node.left, target+node.left.val, temp+[node.left.val])) if node.right: queue.append((node.right, target+node.right.val, temp+[node.right.val])) return res 114. 二叉树展开为链表题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树12345 1 / \ 2 5 / \ \3 4 6 将其展开为：12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路先前序遍历，在讲所有节点的左子树置空，并将右子树置为下一节点。空间复杂度为O(n)。12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return root #迭代 res = [] stack = [root] while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) if node.left: stack.append(node.left) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] # 递归 res = [] self.preorder(root, res) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] def preorder(self, root, res): if not root: return res.append(root) self.preorder(root.left, res) self.preorder(root.right, res) 116. 填充同一层的兄弟节点题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。示例: 给定完美二叉树，12345 1 / \ 2 3 / \ / \4 5 6 7 调用你的函数后，该完美二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路递归，从根节点开始找到任意节点，将其左孩子指向其右孩子，如果该节点的next节点已经指向其他节点，说明需要连接两个子树；比如2-&gt;3，需要把2的左子树4指向5，同时需要将左右子树连接起来，即5-&gt;6。 1234567891011121314151617181920# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.right: root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) 迭代。层次遍历，将队列中的元素弹出时，如果他不是最后一个元素，则将其的next节点指向队列中的下一个节点。1234567891011121314151617181920212223242526# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = [root] while queue: length = len(queue) for i in range(length): node = queue.pop(0) if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 117. 填充同一层的兄弟节点 II题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例: 给定二叉树，12345 1 / \ 2 3 / \ \4 5 7 调用你的函数后，该二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路递归。主要先右再左，因为在递归左子树的时候，需要不断寻找同层的next节点，需要保证右子树先建立好next节点。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.left and root.right: root.left.next = root.right temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next elif root.left: temp = root.next while temp: if temp.left: root.left.next = temp.left; break if temp.right: root.left.next = temp.right; break temp = temp.next elif root.right: temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next self.connect(root.right) self.connect(root.left) 迭代。和上题思路代码一样123456789101112131415161718192021222324252627# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = collections.deque() queue.append(root) while queue: length = len(queue) for i in range(length): node = queue.popleft() if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 129. 求根到叶子节点数字之和题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2:123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 self.res = 0 self.dfs(root, root.val) return self.res def dfs(self, root, path): if not root.left and not root.right: self.res += path if root.left: self.dfs(root.left, path*10+root.left.val) if root.right: self.dfs(root.right, path*10+root.right.val) 迭代。栈123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 stack = [(root, root.val)] while stack: node, val = stack.pop() if not node.left and not node.right: res += val if node.left: stack.append((root.left, val*10+root.left.val)) if node.right: stack.append((root.right, val*10+root.right.val)) return res 迭代。队列 144. 二叉树的前序遍历题目描述给定一个二叉树，返回它的 前序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return res.append(root.val) self.dfs(root.left, res) self.dfs(root.right,res) 迭代。栈12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 迭代。队列1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] queue = collections.deque() queue.append(root) while queue: node = queue.pop() res.append(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return res 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.level(root, 0, res) return [res[i][-1] for i in range(len(res))] def level(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res 222. 完全二叉树的节点个数题目描述给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 解题思路分治递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 226. 翻转二叉树题目描述翻转一棵二叉树。 示例：1234567891011121314输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if not root: return root temp = root.left root.left = root.right root.right = temp self.invertTree(root.left) self.invertTree(root.right) return root 230. 二叉搜索树中第K小的元素题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 解题思路中序遍历。12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ if not root or k &lt;= 0: return 0 res = [] self.inorder(root, res) return res[k-1] def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) python3的yield。1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if not root or k &lt;= 0: return 0 iteration = self.inorder(root) res = 0 for i in range(k): res = next(iteration) return res def inorder(self, root): if root: yield from self.inorder(root.left) yield root.val yield from self.inorder(root.right) 235. 二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路首先保证p的值一定比q的小利用二叉搜索树的特性，左子树一定比根节点小，右子树一定比根节点大； p和q在root两侧，那么root就是公共祖先 pq均小于root，那么从左子树寻找 pq均大于root，那么从右子树寻找 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if p.val &gt; q.val: p, q = q, p node = root while True: if node.val == p.val or node.val == q.val: return node elif p.val &lt; node.val &lt; q.val: return node elif q.val &lt; node.val: node = node.left else: node = node.right 236. 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路递归。对以root为根的树进行查找p和q 如果root为空或root==p或root==q，直接返回root，表明当前树已经查询完成；否则对左右子树进行查找，根据左右子树的返回值进行判断： 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA 左右子树返回值均为null, p和q均不在树中, 返回null 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left and not right: return None elif left and right: return root else: return left if left else right 257. 二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 / \2 3 \ 5输出: ["1-&gt;2-&gt;5", "1-&gt;3"]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 解题思路递归1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] self.dfs(root, str(root.val), res) return res def dfs(self, root, path, res): if not root: return if not root.left and not root.right: res.append(path) return if root.left: self.dfs(root.left, path + '-&gt;' + str(root.left.val), res) if root.right: self.dfs(root.right, path + '-&gt;' + str(root.right.val), res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] stack = [(root, str(root.val))] while stack: node, path = stack.pop(0) if not node.left and not node.right: res.append(path) if node.left: stack.append((node.left, path + '-&gt;' + str(node.left.val))) if node.right: stack.append((node.right, path + '-&gt;' + str(node.right.val))) return res 297. 二叉树的序列化与反序列化题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例:123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 "[1,2,3,null,null,4,5]" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路采用前序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return '#' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ tree = data.split(',') return self.Tree(tree) def Tree(self, tree): if not tree: return None root = None val = tree.pop(0) if val != '#': root = TreeNode(int(val)) root.left = self.Tree(tree) root.right = self.Tree(tree) return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 337. 打家劫舍 III题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1:12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2:12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路对于一个以root为根节点的二叉树而言： 如果偷root节点，那么不能偷其左右子节点 如果不偷该节点，那么可以偷其左右子节点 比较两种方式的大小，取大值 递归完成，每次返回的是(偷，不偷)当前节点的值，如果偷根节点了，那么不能偷其子节点，即加上的是left[1]，和right[1]，1表示的是返回不偷该节点的值。 如果不偷根节点，那么可以偷左右子节点 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rob(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.tryrob(root)) def tryrob(self, root): if not root: return (0, 0) left = self.tryrob(root.left) right = self.tryrob(root.right) # rob now now = root.val + left[1] + right[1] # rob later later = max(left) + max(right) return (now, later) 404. 左叶子之和题目描述计算给定二叉树的所有左叶子之和。 示例：1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回24 解题思路递归，当遇到左叶子节点时加到和里，然后取递归右子树 否则，还没遇到左叶子节点，遍历左子树和右子树123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumOfLeftLeaves(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if root.left and not root.left.left and not root.left.right: return root.left.val + self.sumOfLeftLeaves(root.right) else: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Project - 建筑物能源之星分数预测]]></title>
    <url>%2F2019%2F05%2F14%2FProjectExperience-BuildingEnergyStarScorePrediction%2F</url>
    <content type="text"><![CDATA[Note: 由于Jupyter Notebook运行的一些中间结果在markdown上显示效果不好，因此注释了一些类似于.head() .describe()等内容不在本文中显示，但总体不影响阅读，完整.ipynb文件可以在GitHub查看。 项目来源这是在Github 上找到的一个美国数据科学家在申请工作时的”作业”，英文作业链接。 项目目标 使用提供的建筑能源数据开发一个模型，该模型可以预测建筑物的能源之星分数（building’s Energy Star score）； 解释结果以找到最能预测分数的变量。 这是一个有监督的回归机器学习任务：给定一组包含目标（在本项目中为ENERGY STAR Score能源之星分数）的数据，我们希望训练一个可以学习将特征（也称为解释变量）映射到目标的模型。 监督学习：数据集中同时存在特征和目标变量； 回归任务：目标变量时连续值，在本项目中为0~100。 在训练过程中，我们希望模型学习特征和分数之间的关系；然后，为了测试模型的学习效果，我们在一个没有分数的测试集上进行评估！ 机器学习工作流程虽然每一个机器学习任务的实现细节可能会有所不同，但一般有以下几个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 尽可能地解释模型结果 得出结论并撰写详尽记录的报告 提前设置步骤让我们可以看到一步流入另一步。但是，机器学习过程是一个迭代过程，因此我们并不总是以线性方式遵循这些步骤。我们可能会根据下一步的结果重新审视上一步。例如： 虽然我们可以在构建任何模型之前执行特征选择，但我们可以使用建模结果返回并选择一组不同的特征； 或者，建模可能会出现意想不到的结果，这意味着我们希望从另一个角度探索我们的数据； 一般来说，你必须先完成一步才能继续下一步，但不要觉得一旦你第一次完成一步，你就不能回头做出改进，你可以在任何时候返回前面的步骤做响应的修改。 0 导入库文件使用标准的数据科学和机器学习库:numpy、panda和scikit-learn，同时使用matplotlib和seaborn进行可视化。 123456789101112131415161718192021222324# 用于数值计算的 Pandas和numpyimport pandas as pdimport numpy as np# 不显示在切片副本上的警告pd.options.mode.chained_assignment = None# Matplotlib可视化import matplotlib.pyplot as plt%matplotlib inline# 设置默认字体plt.rcParams['font.size'] = 24# 用于设置图形大小的内部ipython工具from IPython.core.pylabtools import figsize# Seaborn可视化import seaborn as sns# 缩放因子sns.set(font_scale = 2)# 将数据划分为训练集和测试集from sklearn.model_selection import train_test_split 1 数据清理和格式化1.1 导入并检查数据将数据加载到pandas数据帧中，这是数据科学最有用的数据结构之一。 将其视为Python中的电子表格，我们可以轻松地操作，清理和可视化。Pandas官方文档。 123456# 读取数据data = pd.read_csv('dataset/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv')# 显示数据大小print('datashape:',data.shape)# 显示表头data.head() datashape: (11746, 60) 原始数据中有看一下原始数据11746行，60列，我们的目标是预测ENERGY STAR Score列中的数字，其他列作为特征。 根据数据集的文件名为 Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv 这里面有一个Local_Law_84，根据Local_Law_84进行搜索，得到两个比较关键的资料： Local_Law_84网站 基准化公开数据定义 第一个网站告诉我们，当地Local_Law_84是纽约市的一项要求，规定所有超过50,000𝑓𝑡2的建筑物必须每年报告一组与能源相关的数字。pdf文档说明每列代表的含义，虽然我们不需要研究每一列，但至少要理解我们想要预测的目标是个好主意。以下是ENERGY STAR Score能源之星分数的定义： 基于报告年度自我报告的能源使用情况，在投资组合管理器中计算的指定建筑类型的的分数：范围在1到100。 这看起来非常简单：能源之星分数是一种根据能源效率对建筑物进行排名的方法，其中最差的是1，最好是100。它是相对百分位排名，这意味着建筑物相对于彼此进行评分，并且应该在整个值范围内显示均匀分布。 1.2 数据类型和缺失值处理dataframe.info方法是一种通过显示每列的数据类型和非缺失值的数量来评估数据的快速方法。 从查看数据帧开始，可能会出现问题，因为缺失值被编码为“Not Available”而不是np.nan（不是数字）（因为csv文件某些列同时包含数字和字符两种类型）。 这意味着具有数字的列将不会表示为数字，因为pandas会将具有字符串值的列转换为字符串的列。 12# 查看数据列的数据类型和非缺失值数量data.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 11746 entries, 0 to 11745 Data columns (total 60 columns): Order 11746 non-null int64 Property Id 11746 non-null int64 Property Name 11746 non-null object Parent Property Id 11746 non-null object Parent Property Name 11746 non-null object BBL - 10 digits 11735 non-null object NYC Borough, Block and Lot (BBL) self-reported 11746 non-null object NYC Building Identification Number (BIN) 11746 non-null object Address 1 (self-reported) 11746 non-null object Address 2 11746 non-null object Postal Code 11746 non-null object Street Number 11622 non-null object Street Name 11624 non-null object Borough 11628 non-null object DOF Gross Floor Area 11628 non-null float64 Primary Property Type - Self Selected 11746 non-null object List of All Property Use Types at Property 11746 non-null object Largest Property Use Type 11746 non-null object Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object 2nd Largest Property Use Type 11746 non-null object 2nd Largest Property Use - Gross Floor Area (ft²) 11746 non-null object 3rd Largest Property Use Type 11746 non-null object 3rd Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object Year Built 11746 non-null int64 Number of Buildings - Self-reported 11746 non-null int64 Occupancy 11746 non-null int64 Metered Areas (Energy) 11746 non-null object Metered Areas (Water) 11746 non-null object ENERGY STAR Score 11746 non-null object Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site Electricity Intensity (kWh/ft²) 11746 non-null object Weather Normalized Site Natural Gas Intensity (therms/ft²) 11746 non-null object Weather Normalized Source EUI (kBtu/ft²) 11746 non-null object Fuel Oil #1 Use (kBtu) 11746 non-null object Fuel Oil #2 Use (kBtu) 11746 non-null object Fuel Oil #4 Use (kBtu) 11746 non-null object Fuel Oil #5 &amp; 6 Use (kBtu) 11746 non-null object Diesel #2 Use (kBtu) 11746 non-null object District Steam Use (kBtu) 11746 non-null object Natural Gas Use (kBtu) 11746 non-null object Weather Normalized Site Natural Gas Use (therms) 11746 non-null object Electricity Use - Grid Purchase (kBtu) 11746 non-null object Weather Normalized Site Electricity (kWh) 11746 non-null object Total GHG Emissions (Metric Tons CO2e) 11746 non-null object Direct GHG Emissions (Metric Tons CO2e) 11746 non-null object Indirect GHG Emissions (Metric Tons CO2e) 11746 non-null object Property GFA - Self-Reported (ft²) 11746 non-null int64 Water Use (All Water Sources) (kgal) 11746 non-null object Water Intensity (All Water Sources) (gal/ft²) 11746 non-null object Source EUI (kBtu/ft²) 11746 non-null object Release Date 11746 non-null object Water Required? 11628 non-null object DOF Benchmarking Submission Status 11716 non-null object Latitude 9483 non-null float64 Longitude 9483 non-null float64 Community Board 9483 non-null float64 Council District 9483 non-null float64 Census Tract 9483 non-null float64 NTA 9483 non-null object dtypes: float64(6), int64(6), object(48) memory usage: 5.4+ MB 果然，有许多列的数字已被标记为对象数据类型（object）。 在我们进行数值分析之前，必须将它们转换为float数据类型。 1.3 将数据转换为正确的数据类型将带有数字的列转换为数字数据类型，方法是将“Not Available”条目替换为可以解释为浮点数的np.nan。 然后我们将包含数值（例如$ft^2$或$kWh$）的列转换为数值数据类型。 1234567# 用np.nan替换所有的Not Available”data = data.replace(&#123;'Not Available': np.nan&#125;)# 将应该为数值类型的列转换为数值类型for col in list(data.columns): if ('ft²' in col or 'kBtu' in col or 'Metric Tons CO2e' in col or 'kWh' in col or 'therms' in col or 'gal' in col or 'Score' in col): data[col] = data[col].astype(float) 12# 每一列的统计信息data.describe() 1.4 缺失值处理现在我们有了正确的列数据类型，我们可以通过查看每列中缺失值的百分比来开始分析。 当我们进行探索性数据分析时，需要计算缺失值的数量以及每列缺少的总值的百分比。处理方式参考Stack Overflow forum的函数。 1234567891011121314151617181920212223242526272829# 计算每一列中缺失值占比def missing_values_table(df): # 计算总的缺失值 mis_val = df.isnull().sum() # 计算缺失值的百分比 mis_val_percent = 100 * df.isnull().sum() / len(df) # 保存缺失值信息的表格 mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # 列重命名 mis_val_table_ren_columns = mis_val_table.rename( columns = &#123;0 : 'Missing Values', 1 : '% of Total Values'&#125;) # 缺失值比例按列降序 mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) # 打印总结信息 print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n" "There are " + str(mis_val_table_ren_columns.shape[0]) + " columns that have missing values.") # 返回各列缺失值占比信息 return mis_val_table_ren_columns# 调用函数missing_values_table(data) Your selected dataframe has 60 columns. There are 46 columns that have missing values. 根据前面的data.shape可知数据集里一共有11746个实例。我们可以看到我们的目标ENERGY STAR Score能源之星分数有2104个缺失值，占比17.9%，非缺失值有9642个。 虽然我们尽量不能丢失信息，但如果列的丢失值占比很高，那么它可能对结果预测没什么帮助。要保留哪些列在这里有一些讨论，本项目中，我们将删除缺失值超过50％的列。一般来说，要特别小心丢弃任何特征，因为即使有一些缺失值，该特征仍然有可能对于预测目标值有帮助。 1234567# 获得缺失值大于50%的列missing_df = missing_values_table(data)missing_columns = list(missing_df[missing_df['% of Total Values'] &gt; 50].index)print('We will remove %d columns.' % len(missing_columns))# 删除缺失值大于50%的列data = data.drop(columns = list(missing_columns)) Your selected dataframe has 60 columns. There are 46 columns that have missing values. We will remove 11 columns. 其他的具有缺失值的列将用合适的缺失值填充方法补全。 2 探索性数据分析探索性数据分析(EDA)是一个开放式流程，我们绘图并计算统计数据，以便探索我们的数据。 目的是找到异常，模式，趋势或关系。 这些可能是有趣的（例如，找到两个变量之间的相关性），或者它们可用于通知建模决策，例如使用哪些特征。 简而言之，探索性数据分析的目标是确定我们的数据可以告诉我们什么！ 探索性数据分析通常从数据整体开始，然后在我们找到要检查的区域时缩小到数据集的特定部分。 要开始探索性数据分析，我们将关注目标变量，即Energy Star Score能源之星分数，因为这是我们的机器学习模型的目标。 为简单起见，我们可以将列重命名为score分数，然后开始探索此值。 2.1 单变量分析单变量图显示单个变量的分布，例如直方图。 1234567891011figsize(8, 8)# 将Energy Star Score 重命名为scoredata = data.rename(columns= &#123;'ENERGY STAR Score': 'score'&#125;)# score直方图plt.style.use('fivethirtyeight')plt.hist(data['score'].dropna(), bins = 100, edgecolor = 'k')plt.xlabel('Score')plt.ylabel('Number of Buildings')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &#39;Energy Star Score Distribution&#39;) 由于能源之星分数是百分位数，我们预计会看到完全平坦的分布，每个分数占分布的1％（约90个建筑物）。然而，这绝对不是这种情况，因为我们可以看到两个最常见的分数，1和100，构成总分数的不相称的数字。即在两端出现了异常值。 如果我们回到分数的定义，我们会看到它是基于自我报告的能量使用情况。这造成了一个问题，因为建筑物所有者可能想要报告较低的用电量以人为地提高他们的建筑物的分数。这就像给学生一个基于自我报告的考试成绩的成绩。这种行为可以解释高比例的建筑物满分为100，但不能解释为什么这么多建筑物在最底层分数！ 为了对比能源之星分数，我们可以看一下能源使用强度（EUI），它是总能源消耗除以建筑物的平方英尺。在这里，能源使用量不是自我报告的，因此这可以更加客观地衡量建筑物的能源效率。此外，这不是百分位数，因此绝对值很重要，我们希望它们大致正态分布，可能在低端或高端有一些异常值。 123456# Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &#39;Site EUI distribution&#39;) 这表明我们还有另一个问题：异常值！ 由于存在一些分数非常高的建筑物，因此图表非常偏斜。 因此我们需要首先处理异常值。我们来看看EUI这个特征的统计数据。 1data['Site EUI (kBtu/ft²)'].describe() count 11583.000000 mean 280.071484 std 8607.178877 min 0.000000 25% 61.800000 50% 78.500000 75% 97.600000 max 869265.000000 Name: Site EUI (kBtu/ft²), dtype: float64 12# 我们看一下EUI特征最大的10个值data['Site EUI (kBtu/ft²)'].dropna().sort_values().tail(10) 3173 51328.8 3170 51831.2 3383 78360.1 8269 84969.6 3263 95560.2 8268 103562.7 8174 112173.6 3898 126307.4 7 143974.4 8068 869265.0 Name: Site EUI (kBtu/ft²), dtype: float64 其中一栋建筑的EUI远高于其他的，我们看一下这个建筑。 1data.loc[data['Site EUI (kBtu/ft²)'] == 869265.0, :] 异常值可能由于多种原因发生： 拼写错误 测量设备故障 不正确的单位 或者它们可能是合法的但是极端值。 异常值可以删除，因为它们并不表示数据的实际分布。 2.2 删除异常值当我们删除异常值时，我们要小心，我们不能因为异常值就直接删除。 它们可能是我们应该进一步调查的实际现象的结果。 当删除异常值时，可以尝试使用极端异常值的定义来处理，这样可以尽可能保守： 在低端，极端异常值低于 $\text{First Quartile} -3 * \text{Interquartile Range}$ 在高端，极端异常值高于 $\text{Third Quartile} + 3 * \text{Interquartile Range}$ 在这种情况下，我将只删除单个外围点并查看分布情况。 12345678910# 计算第一和第三分位点first_quartile = data['Site EUI (kBtu/ft²)'].describe()['25%']third_quartile = data['Site EUI (kBtu/ft²)'].describe()['75%']# 计算四分位范围：即第一第三分位之间的范围iqr = third_quartile - first_quartile# 去除异常值data = data[(data['Site EUI (kBtu/ft²)'] &gt; (first_quartile - 3 * iqr)) &amp; (data['Site EUI (kBtu/ft²)'] &lt; (third_quartile + 3 * iqr))] 123456# 重画Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &#39;Site EUI distribution&#39;) 删除异常值后，这个直方图分布看起来比较正常，并且接近正态分布，右侧有一条长尾（它有一个正偏斜）。 虽然这可能是一个更客观的衡量标准，但我们的目标仍然是预测能源之星分数，因此我们将回过头来研究该变量。 即使能源之星分数不是一个好的衡量标准，我们仍然需要预测它，这就是我们要做的事情！ 在回到公司的最终报告中，我将指出这可能不是一个客观的衡量标准，并且使用不同的指标来确定建筑物的效率是个好主意。 此外，看看分数为1和100的建筑物可能会很有趣，看看它们是否有任何共同之处。 2.3 寻找关系为了查看分类变量 - categorical variables对分数的影响，我们可以通过分类变量的值来绘制密度图。 密度图还显示单个变量的分布，可以认为是平滑的直方图。 如果我们通过为分类变量密度曲线着色，这将向我们展示分布如何基于类别变化的。 我们将制作的第一个图表显示了Largest Property Use Type建筑类型的分布。 为了不使图形混乱，我们将图形限制为在数据集中具有超过100个观测值的建筑类型。 “具有超过100个观测值的建筑类型” 这句话是什么意思呢？ 有的建筑是住宅楼，有的是酒店，有的是写字楼办公楼，有的是医院等等。 如果用作住宅楼的建筑和用作办公楼的建筑都超过100栋了，那我们就把这两种类型的建筑物的分数分布画出来。例如下图中的红色曲线就代表Office这个类型的建筑物的能源之星分数分布 1234# 统计每个属性值的个数types = data.dropna(subset=['score'])types = types['Largest Property Use Type'].value_counts()types Multifamily Housing 7464 Office 1157 Hotel 202 Non-Refrigerated Warehouse 156 K-12 School 97 Residence Hall/Dormitory 96 Senior Care Community 85 Distribution Center 61 Retail Store 57 Medical Office 23 Hospital (General Medical &amp; Surgical) 15 Financial Office 12 Supermarket/Grocery Store 10 Worship Facility 9 Refrigerated Warehouse 8 Wholesale Club/Supercenter 3 Parking 3 Courthouse 2 Bank Branch 1 Name: Largest Property Use Type, dtype: int64 可以看到，属性值大于100个的有四个： Multifamily Housing Office Hotel Non-Refrigerated Warehouse 12345678910111213141516# 取出属性值个数大于100个的属性types = list(types[types.values &gt; 100].index)# 建筑类型的密度图figsize(12,10)# 绘制每一种建筑类型for b_type in types: # 选出建筑类型 subset = data[data['Largest Property Use Type'] == b_type] # 绘制对应建筑类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = b_type, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Building Type', size = 28) C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &#39;Density Plot of Energy Star Scores by Building Type&#39;) 从该图中，我们可以看到建筑类型确实对分数有影响（图上的负分数是核密度估计过程的人工产物）。 虽然我最初将重点放在用于预测分数的数字列上，但此图表告诉我们应该包含属性类型，因为此信息可用于确定分数。 由于建筑类型是一个分类变量，因此在将其输入机器学习模型之前，必须对其进行独热编码。 为检查另一个分类变量，行政区Borough，我们可以制作类似的图表。 1234# 统计每个属性值的个数boroughs = data.dropna(subset = ['score'])boroughs = boroughs['Borough'].value_counts()boroughs Manhattan 3985 Brooklyn 1947 Queens 1707 Bronx 1655 Staten Island 119 Name: Borough, dtype: int64 12345678910111213141516# 取出属性值个数大于100个的属性boroughs = list(boroughs[boroughs.values &gt; 100].index)# Borough类型的密度图figsize(12,10)# 绘制每一种Borough类型for borough in boroughs: # 选出Borough类型 subset = data[data['Borough'] == borough] # 绘制对应Borough类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = borough, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Borough', size = 28) Text(0.5, 1.0, &#39;Density Plot of Energy Star Scores by Borough&#39;) 建筑的Borough似乎没有像建筑type那样在分数分布上产生显着差异。 尽管如此，将Borough纳入分类变量可能是有意义的。 2.4 特征变量和目标变量的关系为了量化特征（变量）和目标之间的相关性，我们可以计算Pearson相关系数。 这是两个变量之间线性关系的强度和方向的度量：值-1表示两个变量完全负线性相关，值+1表示两个变量完全正线性相关。 尽管特征和目标之间可能存在非线性关系，并且相关系数不考虑特征之间的相互作用，但线性关系是开始探索数据趋势的好方法。 然后，我们可以使用这些值来选择要在我们的模型中使用的特征。 下面的代码计算所有变量和目标变量score之间的相关系数。 12345678910# 计算所有变量和score的相关系数correlations_data = data.corr()['score'].sort_values()# 最负相关的15个特征print(correlations_data.head(15))print('===================================')# 最正相关的15个特征print(correlations_data.tail(15)) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Weather Normalized Site Natural Gas Intensity (therms/ft²) -0.346046 Direct GHG Emissions (Metric Tons CO2e) -0.147792 Weather Normalized Site Natural Gas Use (therms) -0.135211 Natural Gas Use (kBtu) -0.133648 Year Built -0.121249 Total GHG Emissions (Metric Tons CO2e) -0.113136 Electricity Use - Grid Purchase (kBtu) -0.050639 Weather Normalized Site Electricity (kWh) -0.048207 Latitude -0.048196 Property Id -0.046605 Name: score, dtype: float64 =================================== Property Id -0.046605 Indirect GHG Emissions (Metric Tons CO2e) -0.043982 Longitude -0.037455 Occupancy -0.033215 Number of Buildings - Self-reported -0.022407 Water Use (All Water Sources) (kgal) -0.013681 Water Intensity (All Water Sources) (gal/ft²) -0.012148 Census Tract -0.002299 DOF Gross Floor Area 0.013001 Property GFA - Self-Reported (ft²) 0.017360 Largest Property Use Type - Gross Floor Area (ft²) 0.018330 Order 0.036827 Community Board 0.056612 Council District 0.061639 score 1.000000 Name: score, dtype: float64 可以看到，有几个特征与目标变量score存在强负相关关系，与score最负相关的是： Energy Use Intensity (EUI) Site EUI (kBtu/ft²) Weather Normalized Site EUI (kBtu/ft²)（这些只在计算方式上略有不同）。 EUI是建筑使用的能量除以建筑物的平方英尺，并且用于衡量建筑物的效率，其中分数越低越好。 直观地说，这些相关性是有意义的：随着EUI的增加，能源之星分数score趋于下降。 为了考虑可能的非线性关系，我们可以采用特征的平方根和自然对数变换，然后用分数计算相关系数。 为了尝试捕获行政区Borough或建筑type之间的任何可能的关系（这两个特征是类别变量）和分数，我们将对这些特征进行独热编码。 在下面的代码中，我们采用以下策略： 对数值特征：进行平方根和对数变换； 对两个类别变量（Borough和type）进行独热编码； 最后计算所有特征与score之间的相关性，并显示前15个 最积极的和前15个最负相关。 1234567891011121314151617181920212223242526# 选择数值特征numeric_subset = data.select_dtypes('number')# 创建平方根和对数列for col in numeric_subset.columns: # 跳过 Energy Star Score 列 if col == 'score': next else: numeric_subset['sqrt_' + col] = np.sqrt(numeric_subset[col]) numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 独热编码categorical_subset = pd.get_dummies(categorical_subset)# 使用concat对两个数据帧进行拼接，axis=1列绑定features = pd.concat([numeric_subset, categorical_subset], axis = 1)# 去掉没有评分的建筑物features = features.dropna(subset = ['score'])# 计算特征与score之间的相关性correlations = features.corr()['score'].dropna().sort_values() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: divide by zero encountered in log # This is added back by InteractiveShellApp.init_path() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:10: RuntimeWarning: invalid value encountered in sqrt # Remove the CWD from sys.path while we load stuff. C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: invalid value encountered in log # This is added back by InteractiveShellApp.init_path() 12# 显示最负相关的15个特征correlations.head(15) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 sqrt_Site EUI (kBtu/ft²) -0.699817 sqrt_Weather Normalized Site EUI (kBtu/ft²) -0.689019 sqrt_Weather Normalized Source EUI (kBtu/ft²) -0.671044 sqrt_Source EUI (kBtu/ft²) -0.669396 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 log_Source EUI (kBtu/ft²) -0.622892 log_Weather Normalized Source EUI (kBtu/ft²) -0.620329 log_Site EUI (kBtu/ft²) -0.612039 log_Weather Normalized Site EUI (kBtu/ft²) -0.601332 log_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.424246 sqrt_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.406669 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Name: score, dtype: float64 12# # 显示最正相关的15个特征correlations.tail(15) sqrt_Order 0.028662 Borough_Queens 0.029545 Largest Property Use Type_Supermarket/Grocery Store 0.030038 Largest Property Use Type_Residence Hall/Dormitory 0.035407 Order 0.036827 Largest Property Use Type_Hospital (General Medical &amp; Surgical) 0.048410 Borough_Brooklyn 0.050486 log_Community Board 0.055495 Community Board 0.056612 sqrt_Community Board 0.058029 sqrt_Council District 0.060623 log_Council District 0.061101 Council District 0.061639 Largest Property Use Type_Office 0.158484 score 1.000000 Name: score, dtype: float64 在进行非线性转换特征之后： 最强的特征仍然是与能量使用强度（EUI）相关的特征。 对数和平方根变换似乎没有产生任何更强的特征。 尽管我们确实看到建筑类型的办公室（Largest Property Use Type_Office ）与score略微正相关，但没有强烈的正线性关系。此变量是建筑类型的分类变量的独热编码表示。 我们可以使用这些相关性来执行特征选择。 现在，让我们绘制数据集中最重要的相关性（就绝对值而言），即Site EUI (kBtu/ft²)。 我们可以通过建筑类型为图形着色，以显示它如何影响关系。 2.5 双变量分析为了可视化两个变量之间的关系，我们使用散点图。我们还可以使用标记的颜色或大小等方面包含其他变量。在这里，我们将绘制两个数值变量，并使用颜色表示第三个分类变量。 12345678910111213141516figsize(12, 10)# 提取建筑类型特征features['Largest Property Use Type'] = data.dropna(subset=['score'])['Largest Property Use Type']# 限制只取观测值大于100的建筑类型 (从前面的代码)features = features[features['Largest Property Use Type'].isin(types)]# 利用seaborn画score和Site EUI的回归散点图sns.lmplot('Site EUI (kBtu/ft²)', 'score', hue = 'Largest Property Use Type', data = features, scatter_kws = &#123;'alpha': 0.8, 's': 60&#125;, fit_reg = False, size = 12, aspect = 1.2);plt.xlabel('Site EUI', size = 28)plt.ylabel('Energy Star Score', size = 28)plt.title('Energy Star Score vs Site EUI', size = 36) C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\regression.py:546: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(msg, UserWarning) Text(0.5, 1.0, &#39;Energy Star Score vs Site EUI&#39;) Site EUI与score之间存在明显的负相关关系。 这种关系不是完全线性的（相似系数为-0.7，但看起来这个特征对预测建筑物的score很重要。 2.6 多变量分析（pairs plot）我们还可以在几个不同的变量之间建立Pairs Plot。 Pairs Plot是一次检查多个变量的好方法，因为它显示了对角线上的变量对和单个变量直方图之间的散点图。 使用seaborn PairGrid函数，我们可以将不同的图绘制到网格中: 上三角：散点图 对角线：直方图 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计。 123456789101112131415161718192021222324252627282930313233343536373839# 提取需要绘制的变量plot_data = features[['score', 'Site EUI (kBtu/ft²)', 'Weather Normalized Source EUI (kBtu/ft²)', 'log_Total GHG Emissions (Metric Tons CO2e)']]# 使用nan代替infplot_data = plot_data.replace(&#123;np.inf: np.nan, -np.inf:np.nan&#125;)# 重命名列plot_data = plot_data.rename(columns = &#123;'Site EUI (kBtu/ft²)': 'Site EUI', 'Weather Normalized Source EUI (kBtu/ft²)': 'Weather Norm EUI', 'log_Total GHG Emissions (Metric Tons CO2e)': 'log GHG Emissions'&#125;)# 删除缺失值plot_data = plot_data.dropna()# 用于计算两个特征的相关系数的函数def corr_func(x, y, **kwargs): # 计算皮尔逊积矩相关系数 r = np.corrcoef(x, y)[0][1] ax = plt.gca() ax.annotate("r = &#123;:.2f&#125;".format(r), xy=(.2, .8), xycoords=ax.transAxes, size = 20)# 创建绘图网格矩阵grid = sns.PairGrid(data = plot_data, size = 3)# 上三角：散点图grid.map_upper(plt.scatter, color = 'red', alpha = 0.6)# 对角线：直方图grid.map_diag(plt.hist, color = 'red', edgecolor = 'black')# 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计grid.map_lower(corr_func);grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds)# 整张图的标题plt.suptitle('Pairs Plot of Energy Data', size = 36, y = 1.02); C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\axisgrid.py:1241: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(UserWarning(msg)) 为了解释图中的关系，我们可以查找一行中的变量与一列中的变量相交的位置。 例如， 要查找score与log of GHG Emissions之间的关系，我们会查看score列和 log of GHG Emissions行。在交叉点（左下图），我们看到分数与该变量的相关系数为-0.35。如果我们查看对应的右上角图，我们可以看到这种关系的散点图。 同样，要查看Weather EUorm EUI与score的相关性，我们查看Weather EUorm EUI行和score列，可以看到相关系数为-0.67。 3 特征工程和特征选择现在我们已经探索了数据中的趋势和关系，我们可以为我们的模型设计一组功能。 我们可以使用EDA的结果来进行特征工程。 特别是，我们从EDA学到了以下知识，可以帮助我们设计/选择特征： 分数score分布因建筑类型type而异，并且在较小程度上因行政区Borough而异。 因此我们不仅需要关注数值特征，还应该在模型中包含这两个类别特征； 对特征进行对数或平方根变换不会导致特征与分数之间的线性相关性显着增加。 在我们进一步讨论之前，我们应该理解特征工程和特征选择，这些定义是非正式的，并且有相当大的重叠，但我喜欢将它们视为两个独立的过程： 特征工程: 获取原始数据并提取或创建新特征的过程，这些特征允许机器学习模型学习这些特征与目标之间的映射。 这可能意味着对变量进行转换，例如我们对数值特征进行对数和平方根转换，或者对类别变量使用独热编码，以便可以在模型中使用它们。 通常，我认为特征工程是添加从原始数据派生的附加特征。 特征选择: 选择数据中最相关特征的过程。 “最相关”可能取决于许多因素，但它可能与目标的最高相关性或具有最大差异的特征most variance。 在特征选择中，我们会删除对模型学习无用的特征。 这可以帮助模型更好地概括新数据并产生更可解释的模型。 一般来说，我认为特征选择是减去特征，所以我们只留下最重要的特征。 特征工程和选择是迭代过程，通常需要多次尝试才能得到较好的结果。 通常，我们将使用建模结果（例如来自随机森林的特征重要性排序）返回并重做特征选择，或者需要创建新特征的关系。 此外，这些过程通常包含领域知识和数据统计质量的混合。 特征工程和选择 对于获得一个高精度的机器学习模型至关重要。 它可能需要耗费很长时间，但通常比用于模型的算法和超参数选择更重要。 如果我们不为模型提供正确的数据，那么我们将其视为失败，我们不应期望它能够学习！ 在本项目中，我们将采用以下步骤进行特征工程： 仅选择数值变量和两个分类变量（行政区borough和建筑物类型property use type） 对数值变量进行对数变换 对类别变量进行One-hot编码 对于特征选择，我们将执行以下操作： 删除共线性特征 当我们进行特征选择时，我们将讨论共线性（也称为多重共线性）！ 以下代码选择数值特征，并进行对数变换，选择类别特征进行独热编码，并将特征拼接在一起。 1234567891011121314151617181920212223# 复制原始数据features = data.copy# 选择数值特征numeric_subset = data.select_dtypes('number')# 对每一个数值特征进行对数变换for col in numeric_subset.columns: # score为要预测的目标变量，跳过 if col == 'score': next else: numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 进行独热编码categorical_subset = pd.get_dummies(categorical_subset)# 列拼接，axis = 1features = pd.concat([numeric_subset, categorical_subset], axis = 1)features.shape C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: divide by zero encountered in log del sys.path[0] C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: invalid value encountered in log del sys.path[0] (11319, 110) 此时，我们有11319个观测（建筑物），具有109个不同的特征（其中一列是分数score）。 并非所有这些特征对于预测分数有帮助，其中一些特征也许是多余的，因为它们具有高度相关性。 我们将在下面讨论第二个问题。 3.1 删除共线性特征高共线特征在它们之间具有显着的相关系数。 例如，在我们的数据集中，Site EUI和Weather Normalized Site EUI高度相关，因为它们只是略微不同的计算能源使用强度的方法。 12345plot_data = data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna()plt.plot(plot_data['Site EUI (kBtu/ft²)'], plot_data['Weather Normalized Site EUI (kBtu/ft²)'], 'bo')plt.xlabel('Site EUI')plt.ylabel('Weather Norm EUI')plt.title('Weather Norm EUI vs Site EUI, R = %0.4f' % np.corrcoef(data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna(), rowvar=False)[0][1]); 高度共线性的特征可能是多余的，我们只需保留其中一个特征即可为模型提供必要的信息。 删除共线性特征是一种通过减少特征数量来降低模型复杂性的方法，可以提高模型泛化能力。 它还可以帮助我们解释模型，因为我们只需要考虑单一变量，例如EUI，而不是 EUI 和 weather normalized EUI 如何影响分数。 有许多方法可以消除共线特征，例如使用方差膨胀因子。 我们将使用更简单的度量，并删除具有高于某个阈值的相关系数的特征（不是分数，因为我们需要与分数高度相关的特征！）有关删除共线性特征的更全面的讨论， 可以看Kaggle的这个notebook。 以下代码通过删除所比较的两个特征之一，根据我们为相关系数选择的阈值来移除共线性特征。 它还会打印它删除的相关性，以便我们可以看到调整阈值的效果。 我们将使用0.6的阈值，如果特征之间的相关系数超过该值，则删除一对特征中的一个。 代码改编自Stack Overflow的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def remove_collinear_features(x, threshold): ''' Objective: Remove collinear features in a dataframe with a correlation coefficient greater than the threshold. Removing collinear features can help a model to generalize and improves the interpretability of the model. Inputs: threshold: any features with correlations greater than this value are removed Output: dataframe that contains only the non-highly-collinear features ''' # 不要删除与目标变量score之间的相关性 y = x['score'] x = x.drop(columns = ['score']) # 计算相关性矩阵 corr_matrix = x.corr() iters = range(len(corr_matrix.columns) - 1) drop_cols = [] # 遍历相关性矩阵并进行比较 for i in iters: for j in range(i): item = corr_matrix.iloc[j:(j+1), (i+1):(i+2)] col = item.columns row = item.index val = abs(item.values) # 如果有相关性超过阈值 if val &gt;= threshold: # Print the correlated features and the correlation value print(col.values[0], "|", row.values[0], "|", round(val[0][0], 2)) drop_cols.append(col.values[0]) # 删除每对相关特征中的一个 drops = set(drop_cols) x = x.drop(columns = drops) # 删除具有明显相关性的特征，知识计算方式不同 x = x.drop(columns = ['Weather Normalized Site EUI (kBtu/ft²)', 'Water Use (All Water Sources) (kgal)', 'log_Water Use (All Water Sources) (kgal)', 'Largest Property Use Type - Gross Floor Area (ft²)']) # 将目标变量添加回数据帧 x['score'] = y return x 12# 删除相关系数大于指定阈值的特征features = remove_collinear_features(features, 0.6) Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.83 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.81 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.85 Natural Gas Use (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Weather Normalized Site Natural Gas Use (therms) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Electricity Use - Grid Purchase (kBtu) | DOF Gross Floor Area | 0.63 Electricity Use - Grid Purchase (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 Weather Normalized Site Electricity (kWh) | DOF Gross Floor Area | 0.66 Weather Normalized Site Electricity (kWh) | Largest Property Use Type - Gross Floor Area (ft²) | 0.66 Total GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.75 Total GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.79 Total GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.92 Direct GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.97 Direct GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.96 Indirect GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.61 Indirect GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.64 Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.87 Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.86 Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.99 Property GFA - Self-Reported (ft²) | Natural Gas Use (kBtu) | 0.6 Property GFA - Self-Reported (ft²) | Weather Normalized Site Natural Gas Use (therms) | 0.6 Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.7 Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.7 Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.81 Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.81 Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.79 Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 1.0 Council District | Order | 0.86 Council District | Latitude | 0.68 log_Order | Order | 0.88 log_Order | Council District | 0.64 log_Property Id | Property Id | 0.93 log_DOF Gross Floor Area | DOF Gross Floor Area | 0.69 log_DOF Gross Floor Area | Largest Property Use Type - Gross Floor Area (ft²) | 0.63 log_DOF Gross Floor Area | Electricity Use - Grid Purchase (kBtu) | 0.62 log_DOF Gross Floor Area | Weather Normalized Site Electricity (kWh) | 0.62 log_DOF Gross Floor Area | Total GHG Emissions (Metric Tons CO2e) | 0.65 log_DOF Gross Floor Area | Property GFA - Self-Reported (ft²) | 0.65 log_Largest Property Use Type - Gross Floor Area (ft²) | DOF Gross Floor Area | 0.61 log_Largest Property Use Type - Gross Floor Area (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.68 log_Largest Property Use Type - Gross Floor Area (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Largest Property Use Type - Gross Floor Area (ft²) | Property GFA - Self-Reported (ft²) | 0.68 log_Year Built | Year Built | 1.0 log_Number of Buildings - Self-reported | Number of Buildings - Self-reported | 0.73 log_Occupancy | Occupancy | 0.93 log_Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.71 log_Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.68 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.93 log_Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.65 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.91 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.9 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.76 log_Natural Gas Use (kBtu) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Natural Gas Use (kBtu) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Weather Normalized Site Natural Gas Use (therms) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Weather Normalized Site Natural Gas Use (therms) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Electricity Use - Grid Purchase (kBtu) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity (kWh) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | log_DOF Gross Floor Area | 0.74 log_Electricity Use - Grid Purchase (kBtu) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Electricity Use - Grid Purchase (kBtu) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Weather Normalized Site Electricity (kWh) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity (kWh) | 0.62 log_Weather Normalized Site Electricity (kWh) | log_DOF Gross Floor Area | 0.75 log_Weather Normalized Site Electricity (kWh) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.74 log_Weather Normalized Site Electricity (kWh) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Total GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Total GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.73 log_Total GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.76 log_Total GHG Emissions (Metric Tons CO2e) | log_Site EUI (kBtu/ft²) | 0.6 log_Total GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Source EUI (kBtu/ft²) | 0.67 log_Total GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.84 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.68 log_Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.74 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.77 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity (kWh) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Total GHG Emissions (Metric Tons CO2e) | 0.84 log_Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.61 log_Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 log_Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.61 log_Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.61 log_Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.64 log_Property GFA - Self-Reported (ft²) | Property GFA - Self-Reported (ft²) | 0.69 log_Property GFA - Self-Reported (ft²) | log_DOF Gross Floor Area | 0.92 log_Property GFA - Self-Reported (ft²) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.98 log_Property GFA - Self-Reported (ft²) | log_Electricity Use - Grid Purchase (kBtu) | 0.75 log_Property GFA - Self-Reported (ft²) | log_Weather Normalized Site Electricity (kWh) | 0.76 log_Property GFA - Self-Reported (ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.77 log_Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.77 log_Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.66 log_Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.9 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.89 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.78 log_Source EUI (kBtu/ft²) | log_Weather Normalized Source EUI (kBtu/ft²) | 1.0 log_Source EUI (kBtu/ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.67 log_Latitude | Latitude | 1.0 log_Latitude | Council District | 0.68 log_Community Board | Community Board | 0.92 log_Council District C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:33: RuntimeWarning: invalid value encountered in greater_equal | Order | 0.92 log_Council District | Council District | 0.91 log_Council District | log_Order | 0.79 log_Census Tract | Census Tract | 0.78 Borough_Bronx | Latitude | 0.62 Borough_Bronx | Longitude | 0.69 Borough_Bronx | log_Latitude | 0.62 Borough_Brooklyn | Latitude | 0.74 Borough_Brooklyn | Council District | 0.89 Borough_Brooklyn | log_Latitude | 0.74 Borough_Brooklyn | log_Council District | 0.75 Borough_Manhattan | Order | 0.81 Borough_Manhattan | Council District | 0.78 Borough_Manhattan | log_Order | 0.63 Borough_Manhattan | log_Council District | 0.84 Borough_Queens | Order | 0.62 Largest Property Use Type_Office | Largest Property Use Type_Multifamily Housing | 0.63 12features = features.dropna(axis=1, how = 'all')features.shape (11319, 65) 我们的最终数据集有64个特征（其中一列是目标score）。 这仍然不少，但主要是因为我们有一个独热编码的分类变量。 诸如线性回归之类的模型可能存在大量特征， 但诸如随机森林之类的模型执行隐式特征选择并自动确定在训练期间哪些特征是重要的。 还有其他特征选择步骤，但是现在我们将保留我们拥有的所有特征用于训练模型并检验模型的性能。 其他选择选择方法还有很多特征选择的方法，比如主成分分析（PCA），其将特征降低为若干个最大方差的维度，或独立成分分析（ICA），其旨在在一组特征中找到独立源。 然而，虽然这些方法在减少特征数量方面是有效的，但它们创造了没有物理意义的新特征，因此几乎不可能解释模型。 这些方法对于处理高维数据非常有用，更多相关内容。 3.2 训练集和测试集的划分在机器学习中，我们通常需要将我们的数据分为两组： 训练集：有特征和目标值的，用于学习特征和目标之间的映射。 测试集：用于验证模型的效果，该模型从未在测试集上看到过目标值，而是必须使用这些特征进行预测。当我们知道测试集的真实答案时，我们可以将测试预测值与真实值进行比较，以估计我们的模型在现实世界中部署时的表现。 本项目中，我们将首先提取所有没有Energy Star Score能源之星分数的建筑物（我们不知道这些建筑物的真实答案，因此它们对训练或测试没有帮助）。然后，我们将有分数的建筑物分成70&amp;的训练集和30%的测试集。 使用scikit-learn将数据随机拆分为训练和测试集很简单。我们可以设置拆分的random_state以确保一致的结果。 123456# 将数据按照有无score分类no_score = features[features['score'].isna()]score = features[features['score'].notnull()]print(no_score.shape)print(score.shape) (1858, 65) (9461, 65) 1234567891011121314# 将特征和目标变量拆分features = score.drop(columns='score')targets = pd.DataFrame(score['score'])# 为了方便后续的填充，用np.nan替换np.inf和-np.inffeatures = features.replace(&#123;np.inf: np.nan, -np.inf: np.nan&#125;)# 划分70%的训练集和30%的测试集X, X_test, y, y_test = train_test_split(features, targets, test_size = 0.3, random_state = 42)print(X.shape)print(y.shape)print(X_test.shape)print(y_test.shape) (6622, 64) (6622, 1) (2839, 64) (2839, 1) 我们有1858座没有分数的建筑；有分数的建筑中，6622座用作训练集，2839座用作测试集中，接下来建立一个naive 的 baseline以在后续模型中不断优化。 3.3 建立一个baseline在我们开始建立机器学习模型之前建立一个naive的基线是很重要的。 如果我们构建的模型不能胜过naive的猜测，那么我们可能不得不承认机器学习不适合这个问题。 这可能是因为我们没有使用正确的模型，需要更多的数据，或者因为有一个更简单的解决方案，不需要机器学习。 建立基线至关重要，因此我们最终可能不会去建立机器学习模型，只是意识到我们无法真正解决问题。 对于回归任务，良好的基线是使用训练集上目标的中值作为所有所有测试集样本的预测值。这很容易实现，并为我们的模型设置了相对较低的标准：如果它们不能比猜测的中值更好，那么我们需要重新思考我们的方法。 度量标准：平均绝对误差机器学习任务中使用了许多指标，很难知道选择哪一个指标。 大多数情况下，它将取决于特定问题，如果有一个特定的目标来优化。 Andrew Ng建议使用单个实值性能指标来比较模型，因为它简化了评估过程。 我们应该使用一个数字，而不是计算多个指标并尝试确定每个指标的重要程度。 在这种情况下，因为我们进行回归，所以平均绝对误差是适当的度量。 这也是可以解释的，因为它表示我们的估计的平均分数数量，并且与目标值的单位相同 下面的函数计算真实值和预测值之间的平均绝对误差。 123# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred)) 现在我们可以做中值猜测并用于测试集。 1234baseline_guess = np.median(y)print('The baseline guess is a score of %0.2f' % baseline_guess)print("Baseline Performance on the test set: MAE = %0.4f" % mae(y_test, baseline_guess)) The baseline guess is a score of 66.00 Baseline Performance on the test set: MAE = 24.5164 这表明我们对测试集的平均估计偏差约25%。 因为分数在1到100之间，因此这意味着来自baseline的平均误差约25%。猜测训练集中值的naive方法为我们的后续的模型提供了一个低基线！ 3.4 小结到目前为止，我们完成了开头所说机器学习工作流程的前三个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 我们还完成了建立基线指标的关键任务，以便我们确定我们的模型是否比猜测更好！ 以上我们了解了流程中的每个部分是如何流入下一个部分的： 清理数据并将其转换为正确的格式允许我们执行探索性数据分析(EDA)； EDA的结果辅助我们进行特征工程和选择。 这三个步骤通常按此顺序执行，但我们可能会稍后再回来，根据我们的建模结果进行更多的EDA或特征工程。数据科学是一个迭代过程，我们一直在寻找改进以前工作的方法。这意味着我们不必第一次完成任务（尽管我们可以尽力），因为一旦我们对问题有了更多的了解，总有机会重新审视我们的决策。 接下来，我们将重点实现几种机器学习方法，选择最佳模型，并使用交叉验证的超参数调整方法优化我们的问题。 同时，把我们处理过的数据集保存起来，以便在后续步骤中再次使用。 123456# 保存没有分数的数据集，训练集，测试集no_score.to_csv('dataset/no_score.csv', index = False)X.to_csv('dataset/training_features.csv', index = False)X_test.to_csv('dataset/testing_features.csv', index = False)y.to_csv('dataset/training_labels.csv', index = False)y_test.to_csv('dataset/testing_labels.csv', index = False) 4 评估和比较机器学习模型4.1 导入库文件在本项目中，我们使用各种标准的数据科学和机器学习库。 1234567891011# 缺失值填充和最大最小归一化处理from sklearn.preprocessing import Imputer, MinMaxScaler# 机器学习模型from sklearn.linear_model import LinearRegressionfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.svm import SVRfrom sklearn.neighbors import KNeighborsRegressor# 超参数调整from sklearn.model_selection import RandomizedSearchCV, GridSearchCV 4.2 导入数据读取前面部分处理好的数据。 1234567891011# 使用数据帧读取数据train_features = pd.read_csv('dataset/training_features.csv')train_labels = pd.read_csv('dataset/training_labels.csv')test_features = pd.read_csv('dataset/testing_features.csv')test_labels = pd.read_csv('dataset/testing_labels.csv')# 数据维度print('Training Feature Size:', train_features.shape)print('Training Labels Size:', train_labels.shape)print('Testing Feature Size:', test_features.shape)print('Testing Labels Size:', test_labels.shape) Training Feature Size: (6622, 64) Training Labels Size: (6622, 1) Testing Feature Size: (2839, 64) Testing Labels Size: (2839, 1) 这是格式化后的数据。 在前文，我们对数值特征进行了对数变换，对两个类别特征进行独热编码，并通过删除高共线特征来选择特征子集。 1train_features.head(12) training_labels包含能源之星分数，这是我们机器学习问题的目标。 能源之星评分是对建筑物能效的比较测量。 这是能源之星分数的分布。 1234567figsize(8, 8)# score的直方图分布plt.hist(train_labels['score'].dropna(), bins = 100);plt.xlabel('Score')plt.ylabel('Number of Building')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &#39;Energy Star Score Distribution&#39;) 4.3 评估和比较机器学习模型在本节中，我们将为我们的监督回归任务构建、训练及评估几种机器学习方法。 目标是确定哪个模型最有希望进一步开发（例如超参数调整）。 我们使用平均绝对误差作为指标来比较模型。 从3.3节可知随机猜测分数中值的基线模型平均偏离25分。 4.3.1 填充缺失值通常机器学习模型无法处理缺失值，这意味着我们必须找到一种方法来填充或忽略任何缺少值的特征。由于我们在1.4节已经删除了缺失值超过50%的特征，因此我们将重点填充剩下特征的缺失值)。有许多填充方法，但在这里我们将使用相对简单的方法用列的中位数替换缺失值。 （这是关于缺失值填充的更全面的讨论） 在下面的代码中，我们创建一个Scikit-learn Imputer对象，用列的中值填充缺失值。请注意，我们只在训练数据上使用Imputer.fit，但在测试数据集没有使用。然后我们使用Imputer.transform同时处理训练数据集和测试数据集。这意味着测试集中的缺失值用训练集中相应列的中值填充。我们必须现在这么做而不是部署时，我们必须根据训练数据集将测试集的缺失值填充。这是避免数据泄漏问题的一种方法，数据泄露指来自测试集的信息“泄漏”到训练过程中。 123456789# 使用中位数填充策略创建一个imputer对象imputer = Imputer(strategy = 'median')# imputer对象作用于训练集imputer.fit(train_features)# 转换训练数据和测试数据X = imputer.transform(train_features)X_test = imputer.transform(test_features) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\utils\deprecation.py:58: DeprecationWarning: Class Imputer is deprecated; Imputer was deprecated in version 0.20 and will be removed in 0.22. Import impute.SimpleImputer from sklearn instead. warnings.warn(msg, category=DeprecationWarning) 12print('Missing values in training features: ', np.sum(np.isnan(X)))print('Missing values in testing features: ', np.sum(np.isnan(X_test))) Missing values in training features: 0 Missing values in testing features: 0 123# 保证所有数字都是有限值print(np.where(~np.isfinite(X)))print(np.where(~np.isfinite(X_test))) (array([], dtype=int64), array([], dtype=int64)) (array([], dtype=int64), array([], dtype=int64)) 在填充之后，所有特征都是实值的。 对于更复杂的缺失值处理方法（尽管中值通常很有效），请查看本文 4.3.2 特征缩放在我们构建模型之前要采取的最后一步是特征缩放。这是必要的，因为特征之间具有不同的单位度量，我们希望对特征进行标准化，以使单位不影响算法的结果。 线性回归和随机森林不需要特征缩放 但是其他方法（例如支持向量机和kNN）需要进行特征缩放，因为它们考虑了样本之间的欧几里德距离。因此，在比较多个算法时，最佳做法是进行特征缩放。 有两种常用的特征缩放方法： 对于每个值，减去特征的平均值并除以特征的标准偏差。这称为标准化，并且导致每个特征具有0均值和1标准差。 对于每个值，减去特征的最小值并除以最大值减去最小值（范围）。这确保了特征的所有取值都在0和1之间，这称为归一化。 这是一篇关于规范化和标准化的好文章。 与缺失值处理一样，当我们进行特征缩放时，我们只使用训练集计算缩放对象。当我们转换特征时，我们将转换训练集和测试集。 123456789# 创建（0,1）之间的缩放对象scaler = MinMaxScaler(feature_range=(0, 1))# 拟合训练集scaler.fit(X)# 对训练集和测试集进行变换X = scaler.transform(X)X_test = scaler.transform(X_test) 123# 将y转换为一维数组y = np.array(train_labels).reshape((-1, ))y_test = np.array(test_labels).reshape((-1, )) 1y.shape (6622,) 4.4 评估模型我们将使用Scikit-Learn库比较五种不同的机器学习模型： 线性回归 支持向量机回归 随机森林回归 梯度提升回归 K-Nearest Neighbors回归 在本节，我专注于模型实现过程，而不是解释这些模型是如何工作的。除了动手机器学习之外，阅读机器学习模型的另一个重要资源（这是免费的在线）是统计学习简介。 为了比较模型，我们将主要使用模型超参数的Scikit-Learn默认值。通常这些将表现得很好，但应该在实际使用模型之前进行优化。首先，我们只想确定每个模型的基线性能，然后我们可以选择性能最佳的模型，再使用超参数调整进一步优化。请记住，默认的超参数将启动并运行模型，但几乎总是应该使用某种搜索来调整以找到问题的最佳设置！ 以下是Scikit-learn文档中有关默认值的内容： __Sensible defaults__: Whenever an operation requires a user-defined parameter,an appropriate default value is defined by the library. The default value should cause the operation to be performed in a sensible way (giving a baseline solution for the task at hand.) 关于scikit-learn的最大的特点是所有模型都以相同的方式实现：一旦你知道如何构建一个模型，你就可以实现一系列极其多样化的模型。在这里，我们将用几行代码实现多个模型。 123456789101112131415# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred))# 模型训练和预测过程，输入任意模型，输出maedef fit_and_evaluate(model): # 训练模型 model.fit(X, y) # 预测和评估 model_pred = model.predict(X_test) model_mae = mae(y_test, model_pred) # 返回误差指标 return model_mae 12345# 线性回归lr = LinearRegression()lr_mae = fit_and_evaluate(lr)print('Linear Regression Performance on the test set: MAE = %0.4f' % lr_mae) Linear Regression Performance on the test set: MAE = 13.4651 12345# 支持向量回归svm = SVR(C = 1000, gamma = 0.1)svm_mae = fit_and_evaluate(svm)print('Support Vector Machine Regression Performance on the test set: MAE = %0.4f' % svm_mae) Support Vector Machine Regression Performance on the test set: MAE = 10.9337 12345# 随机森林random_forest = RandomForestRegressor(random_state=60)random_forest_mae = fit_and_evaluate(random_forest)print('Random Forest Regression Performance on the test set: MAE = %0.4f' % random_forest_mae) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\ensemble\forest.py:246: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22. &quot;10 in version 0.20 to 100 in 0.22.&quot;, FutureWarning) Random Forest Regression Performance on the test set: MAE = 10.0073 12345# 梯度提升回归gradient_boosted = GradientBoostingRegressor(random_state=60)gradient_boosted_mae = fit_and_evaluate(gradient_boosted)print('Gradient Boosted Regression Performance on the test set: MAE = %0.4f' % gradient_boosted_mae) Gradient Boosted Regression Performance on the test set: MAE = 10.0144 12345# k近邻回归knn = KNeighborsRegressor(n_neighbors=10)knn_mae = fit_and_evaluate(knn)print('K-Nearest Neighbors Regression Performance on the test set: MAE = %0.4f' % knn_mae) K-Nearest Neighbors Regression Performance on the test set: MAE = 13.0131 123456789101112131415161718# 可视化比较不同模型的结果figsize(8, 4)# 保存结果的数据帧model_comparison = pd.DataFrame(&#123;'model': ['Linear Regression', 'Support Vector Machine', 'Random Forest', 'Gradient Boosted', 'K-Nearest Neighbors'], 'mae': [lr_mae, svm_mae, random_forest_mae, gradient_boosted_mae, knn_mae]&#125;)# 直方图model_comparison.sort_values('mae', ascending = False).plot(x = 'model', y = 'mae', kind = 'barh', color = 'red', edgecolor = 'black')plt.ylabel('')plt.yticks(size = 14)plt.xlabel('Mean Absolute Error')plt.xticks(size = 14)plt.title('Model Comparison on Test MAE', size = 20) Text(0.5, 1.0, &#39;Model Comparison on Test MAE&#39;) 根据模型结果比较（每次结果会略有变化），随机森林表现最佳，其次是梯度提升回归。 然而这不是最公平的比较，因为我们主要使用默认的超参数。特别是使用支持向量回归器，超参数对性能有显着影响。 （随机森林和梯度提升方法非常适合开始，因为性能较少依赖于模型设置）。 尽管如此，从这些结果中，我们可以得出结论，机器学习是适用的，因为所有模型都明显优于基线（3.3节25%的mae）！ 接下来，我将专注于使用超参数调整来优化最佳模型。鉴于此处的结果，我将专注于使用Gradient Boosting Regressor。因为Gradient Boosted Trees的Scikit-Learn实现，在过去的几年中赢得了许多Kaggle比赛。 Scikit-Learn版本通常比XGBoost版本慢，但在这里我们将坚持使用Scikit-Learn，因为语法更为熟悉。这是XGBoost包中使用实现的指南。 5 模型优化在机器学习中，优化模型意味着为特定问题找到最佳的超参数集。 5.1 超参数首先，我们需要了解哪些模型超参数与模型参数的对比： 模型超参数被认为是机器学习算法的设置，在训练之前由数据科学家调整。例如，随机森林中的树的数量，或者K Nearest Neighbors Regression中使用的近邻数量。 模型参数是模型在训练期间学习的内容，例如线性回归中的权重。 我们通过选择超参数来控制模型，这些选择会对模型的最终性能产生重大影响（尽管通常不会像获取更多数据或特征工程那么有效）。 调整模型超参数可以控制模型欠拟合与过拟合的平衡。 我们可以尝试通过更复杂的模型来校正欠拟合，例如在随机森林中使用更多树或在深度神经网络中使用更多层。不合适的模型具有高偏差，并且当我们的模型没有足够的容量（自由度）来学习特征和目标之间的关系时发生。 我们可以通过限制模型的复杂性和应用正则化来尝试纠正过拟合。这可能意味着降低多项式回归的阶数，或将dropout 层添加到深度神经网络。过拟合的模型具有高方差并且实际上记忆了训练集。 欠拟合和过拟合都会导致测试集上的泛化性能变差。 选择超参数的问题在于，没有任何超参数可以在所有问题中发挥最佳效果。因此，对于每个新数据集，我们必须找到最佳设置。这可能是一个耗时的过程，但幸运的是，在Scikit-Learn中执行此过程的方法有多种选择。更好的是，新的库，例如epistasis labs的TPOT，旨在自动完成此过程！本项目中，我们将坚持在Scikit-Learn中手动完成，但请继续关注自动模型选择的文章！ 5.2 使用随机搜索和交叉验证进行超参数调整我们可以通过随机搜索和交叉验证为模型选择最佳超参数。 随机搜索是指我们选择超参数来评估模型的方法： 我们定义一系列选项，然后随机选择要尝试的组合。这与网格搜索形成对比，网格搜索评估我们指定的每个组合。 通常，当我们对最佳模型超参数的知识有限时，随机搜索会更好，我们可以使用随机搜索缩小选项范围，然后使用更有限的选项范围进行网格搜索。 交叉验证是用于评估超参数性能的方法： 我们使用K-Fold交叉验证，而不是将数据集拆分为单独训练集的和验证集，以减少我们可以使用的训练数据量。 将训练数据划分为K个部分，然后遍历迭代过程，其中我们首先在K-1个数据集上训练，然后评估在第k个数据集的性能。 重复这个过程K次，所以最终我们将测试训练数据中的每个例子，关键是每次迭代我们都在测试我们没有训练过的数据。 在K折交叉验证结束时，我们将每次K次迭代的平均误差作为最终性能度量，然后在所有训练数据上训练模型。然后，我们记录的性能用于比较超参数的不同组合。 使用k = 5的k折交叉验证图片如下所示： 在这里，我们将使用交叉验证实现随机搜索，以选择梯度梯度回归模型的最佳超参数。 我们首先定义一个网格然后执行迭代过程：从网格中随机抽样一组超参数，使用4折交叉验证评估超参数，然后选择具有最佳性能的超参数。 当然我们实际上并没有自己做这个迭代，我们让Scikit-Learn和RandomizedSearchCV为我们完成这个过程！ 12345678910111213141516171819202122232425# 损失函数 均方差"ls", 绝对损失"lad", Huber损失"huber"loss = ['ls', 'lad', 'huber']# 提升过程使用的树的数量n_estimators = [100, 500, 900, 1100, 1500]# 每棵树的最大深度max_depth = [2, 3, 5, 10, 15]# 每个叶子节点的最少样本min_samples_leaf = [1, 2, 4, 6, 8]# 拆分节点的最小样本数min_samples_split = [2, 4, 6, 10]# 分割时要考虑的最大特征的数量max_features = ['auto', 'sqrt', 'log2', None]# 定义要进行超参数搜索的网络hyperparameter_grid = &#123;'loss': loss, 'n_estimators': n_estimators, 'max_depth': max_depth, 'min_samples_leaf': min_samples_leaf, 'min_samples_split': min_samples_split, 'max_features': max_features&#125; 我们选择了6个不同的超参数来调整GBDT回归。 这些都将以不同的方式影响模型，这些方法很难提前确定，找到特定问题的最佳组合的唯一方法是测试它们！ 要了解超参数，可以查看Scikit-Learn文档。现在，只要知道我们正在努力寻找超参数的最佳组合，并且因为没有理论告诉我们哪种方法效果最好，我们只需要评估它们，就像运行实验一样！ 在下面的代码中，我们创建了随机搜索对象，传递以下参数： estimator: 模型 param_distributions: 我们定义的超参数网络分布 cv ：用于k-fold交叉验证的folds 数量 n_iter: 不同的参数组合的数量 scoring: 评估候选参数时使用的指标 n_jobs: 并行运行时核的数量（-1 时全部使用） verbose: 显示信息的数量（1显示有限信息） return_train_score: 每一个cross-validation fold 返回的分数 random_state: 固定使用的随机数生成器，因此每次运行都会得到相同的结果 随机搜索对象的训练方式与任何scikit-learn模型相同。训练之后，我们可以比较所有不同的超参数组合，找到效果最好的组合。 1234567891011# 建立一个模型用于超参数搜索model = GradientBoostingRegressor(random_state = 42)# 配置具有4折交叉验证的随机搜索random_cv = RandomizedSearchCV(estimator=model, param_distributions=hyperparameter_grid, cv=4, n_iter=25, scoring = 'neg_mean_absolute_error', n_jobs = -1, verbose = 1, return_train_score = True, random_state=42) 12# 拟合训练数据random_cv.fit(X, y) Fitting 4 folds for each of 25 candidates, totalling 100 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 13.5min [Parallel(n_jobs=-1)]: Done 100 out of 100 | elapsed: 21.9min finished RandomizedSearchCV(cv=4, error_score=&#39;raise-deprecating&#39;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;ls&#39;, max_depth=3, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_sampl...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&#39;warn&#39;, n_iter=25, n_jobs=-1, param_distributions={&#39;loss&#39;: [&#39;ls&#39;, &#39;lad&#39;, &#39;huber&#39;], &#39;n_estimators&#39;: [100, 500, 900, 1100, 1500], &#39;max_depth&#39;: [2, 3, 5, 10, 15], &#39;min_samples_leaf&#39;: [1, 2, 4, 6, 8], &#39;min_samples_split&#39;: [2, 4, 6, 10], &#39;max_features&#39;: [&#39;auto&#39;, &#39;sqrt&#39;, &#39;log2&#39;, None]}, pre_dispatch=&#39;2*n_jobs&#39;, random_state=42, refit=True, return_train_score=True, scoring=&#39;neg_mean_absolute_error&#39;, verbose=1) Scikit-learn使用负平均绝对误差进行评估，因为它希望度量最大化。 因此，更好的分数将更接近0.我们可以将随机搜索的结果导入数据帧，并按性能进行排序。 123# 获取cv的结果并按性能排序random_result = pd.DataFrame(random_cv.cv_results_).sort_values('mean_test_score', ascending = False)random_result.head(10) 1random_cv.best_estimator_ GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=500, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 最佳梯度增强模型具有以下超参数: loss = lad n_estimators = 500 max_depth = 5 min_samples_leaf = 6 min_samples_split = 6 max_features = None (这意味着最大特征数量等于数据集中特征的数量) 使用随机搜索是缩小可能的超参数的好方法。最初，我们不知道哪种组合效果最好，但这至少缩小了选项的范围。 我们可以使用随机搜索结果来通过创建具有超参数的网格来通知网格搜索，这些参数接近于在随机搜索期间最有效的参数。接下来将重点放在单个树中的树数量（n_estimators）。通过仅改变一个超参数，我们可以直接观察它如何影响性能。在这种情况情况下，我们预计会看到对过拟合的影响。 在这里，我们将使用网格搜索，网格只有n_estimators超参数。我们将评估树的个数，然后绘制训练和测试性能，以了解增加树数量对模型的影响。我们将其他超参数固定为从随机搜索返回的最佳值，以直接查看树的数量对模型的影响。 12345678910111213# 创建一系列树的数量trees_grid = &#123;'n_estimators': [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]&#125;model = GradientBoostingRegressor(loss = 'lad', max_depth = 5, min_samples_leaf = 6, min_samples_split = 6, max_features = None, random_state = 42)# 对树的数量进行网络搜索grid_search = GridSearchCV(estimator = model, param_grid=trees_grid, cv = 4, scoring = 'neg_mean_absolute_error', verbose = 1, n_jobs = -1, return_train_score = True) 12# 拟合训练数据grid_search.fit(X, y) Fitting 4 folds for each of 15 candidates, totalling 60 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 3.4min [Parallel(n_jobs=-1)]: Done 60 out of 60 | elapsed: 6.2min finished GridSearchCV(cv=4, error_score=&#39;raise-deprecating&#39;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samp...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&#39;warn&#39;, n_jobs=-1, param_grid={&#39;n_estimators&#39;: [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=True, scoring=&#39;neg_mean_absolute_error&#39;, verbose=1) 123456789101112# 获取结果results = pd.DataFrame(grid_search.cv_results_)# 绘制不同树的数量的训练和测试误差figsize(8, 8)plt.style.use('fivethirtyeight')plt.plot(results['param_n_estimators'], -1 * results['mean_test_score'], label = 'Testing Error')plt.plot(results['param_n_estimators'], -1 * results['mean_train_score'], label = 'Training Error')plt.xlabel('Number of Trees')plt.ylabel('Mean Abosolute Error')plt.legend();plt.title('Performance vs Number of Trees') Text(0.5, 1.0, &#39;Performance vs Number of Trees&#39;) 1results.sort_values('mean_test_score', ascending = False).head() 从上图来看，很明显我们的模型过拟合了！训练误差明显低于测试误差，这表明模型正在很好地学习训练数据，但是无法泛化到测试数据。随着树数量的增加，对训练集的拟合效果变好，测试和训练误差都会减少，但训练误差会更快地减少。 训练误差和测试误差之间始终存在显著的差异（训练误差始终较低），我们希望通过获取更多训练数据或降低模型的复杂性来尝试降低过拟合，例如可以进行超参数调整或正则化。对于GDBT回归，可以减少树的数量，减少每棵树的最大深度，以及增加叶节点中的最小样本数。对于任何想要进一步了解GDBT回归的人来说，这是一篇很棒的文章。目前，我们将使用具有最佳性能的模型，并接受它可能对训练集过拟合的事实。 根据交叉验证结果，使用800棵树的最佳模型的交叉验证误差在9以下。这表明Energy Star Score能源之星分数的平均交叉验证估计在真实答案的9分之内，即使模型过拟合了，但仍然是一个不错的结果。 6 使用最佳模型评估测试集我们将使用超参数调整中的最佳模型来对测试集进行预测。 请记住，我们的模型以前从未见过测试集，所以这个性能应该是模型在现实世界中部署时的表现的一个很好的指标。 为了比较，我们还可以查看使用默认参数的模型的性能并和最佳模型进行比较。 下面的代码创建最终模型，训练它（带有时间），并评估测试集。 1234567# 默认模型default_model = GradientBoostingRegressor(random_state = 42)# 选择最优模型final_model = grid_search.best_estimator_final_model GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 12%%timeit -n 1 -r 5default_model.fit(X, y) 1.36 s ± 117 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12%%timeit -n 1 -r 5final_model.fit(X, y) 18.6 s ± 471 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12345default_pred = default_model.predict(X_test)final_pred = final_model.predict(X_test)print('Default model performance on the test set: MAE = %0.4f.' % mae(y_test, default_pred))print('Final model performance on the test set: MAE = %0.4f.' % mae(y_test, final_pred)) Default model performance on the test set: MAE = 10.0130. Final model performance on the test set: MAE = 9.0453. 最终的模型比基线模型的性能提高了大约10％，但代价是显著增加了运行时间。 机器学习通常是一个需要权衡的领域： 偏差与方差 准确性与可解释性 准确性与运行时间 以及使用哪种模型 最终决定取决于具体情况。 这里，运行时间的增加不是障碍，因为虽然相对差异很大，但训练时间的绝对量值并不显着。 在不同的情况下，权衡可能不一样，因此我们需要考虑我们正在优化的内容以及我们必须使用的限制。 为直观地了解预测效果，我们可以绘制下面两个值的分布：测试集上的真实值和最终模型的预测值 123456789figsize(8, 8)# 测试集上的真实值和预测值的密度图sns.kdeplot(final_pred, label = 'Predictions')sns.kdeplot(y_test, label = 'True Values')plt.xlabel('Energy Star Score')plt.ylabel('Density')plt.title('Test Values and Predictions') C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &#39;Test Values and Predictions&#39;) 虽然预测值的密度更接近测试值的中值而不是100的实际峰值，但分布看起来几乎相同。看来模型在预测极值时可能不太准确 而是预测值更接近中位数。 接下来，我们画一下预测值与真实值残差的直方图。 理想情况下，我们希望残差是正态分布的，这意味着模型在两个方向（高和低）上都是预测误差情况是一样的。 1234567891011figsize(6, 6)# 计算残差residuals = final_pred - y_test# 残差的直方图plt.hist(residuals, color = 'red', bins = 20, edgecolor = 'black')plt.xlabel('Error')plt.ylabel('Count')plt.title('Distribution of Residuals') Text(0.5, 1.0, &#39;Distribution of Residuals&#39;) 残差接近正态分布，低端有一些明显的异常值。 这些表明模型估计远低于真实值。 6.1 小结以上我们完成了机器学习的4到6三个步骤： 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 结果表明机器学习适用于我们的问题，最终模型能够将建筑物的能源之星分数预测到9.1分以内（尽管存在过拟合现象）。我们还看到： 超参数调整能够略微改善模型的性能，但同时会消耗大量的时间。这表明，正确的特征工程和收集更多数据（如果可能！）比微调模型有更大的回报。我们还观察了运行时间与精度之间的权衡，这是我们在设计机器学习模型时必须考虑的众多因素之一。 我们知道我们的模型是准确的，但是我们需要知道为什么它能做出正确预测！机器学习过程的下一步至关重要：尝试理解模型如何进行预测，即尽可能地解释模型结果。实现高精度是很好的，但如果我们能够找出模型能够准确预测的原因，那么我们也可以使用这些信息来更好地理解问题。例如，模型依靠什么特征来推断能源之星分数？可以使用此模型进行特征选择，并实现更易于解释的更简单模型吗？ 在接下来的部分，我们将尝试回答这些问题并从项目中得出最终结论！ 7 解释模型本节，我们将查看我们构建的黑盒子模型。我们知道这是准确的，因为它可以预测能源之星分数在真实值的相对误差在9分之内，但它究竟是如何做出预测的呢？ 我们将研究一些尝试理解GBDT回归然后得出结论。 123456# 引入树模型from sklearn import tree# LIME 用于解释预测import lime import lime.lime_tabular 7.1 重新构建最终模型123456# 使用超参数搜索的结果重构模型model = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)model.fit(X, y) GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 1234# 在测试集上做预测model_pred = model.predict(X_test)print('Final Model Performance on the test set: MAE = %0.4f' % mae(y_test, model_pred)) Final Model Performance on the test set: MAE = 9.0453 7.2 解释模型机器学习经常被批评为一个黑盒子： 我们把数据丢进去，它给了我们预测答案。 虽然这些答案通常非常准确，但该模型并未告诉我们它是如何实际做出预测的。 这在某种程度上是正确的，但我们可以通过多种方式尝试并发现模型如何“思考”，例如局部可理解的与模型无关的解释器(Locally Interpretable Model-agnostic Explainer, LIME)。 这种方法试图通过学习围绕预测的线性回归来解释模型预测，这是一个易于解释的模型！ 我们将探索几种解释模型的方法： 特征重要性 局部可理解的与模型无关的解释器（LIME） 检查整体中的单个决策树 7.2 特征重要性我们可以解释决策树集成的基本方法之一是通过特征重要性。 这些可以解释为最能预测目标的特征。 虽然特征重要性的实际细节非常复杂(这里是相关讨论)，我们可以使用相对值来比较特征并确定哪些与我们的问题最相关。 在scikit-learn中，从经过训练的树集成中提取特征重要性非常容易。 我们将特征重要性存储在数据帧中以分析和可视化它们。 12345678# 提取特征重要性，保存到数据帧中feature_results = pd.DataFrame(&#123;'feature': list(train_features.columns), 'importance': model.feature_importances_&#125;)# 显示最重要的10个特征feature_results = feature_results.sort_values('importance', ascending = False).reset_index(drop=True)feature_results.head(10) Site EUI (kBtu/ft²) 和Weather Normalized Site Electricity Intensity (kWh/ft²)是两个相对最重要的两个特征。之后，相对重要性大幅下降，这表明我们可能不需要保留所有特征来创建具有几乎相同性能的模型。 让我们可视化特征重要性。 12345678figsize(12, 10)# 将最重要的10个特征画成直方图feature_results.loc[:9, :].plot(x = 'feature', y = 'importance', edgecolor = 'k', kind = 'barh', color = 'blue')plt.xlabel('Relative Importance', size = 20)plt.ylabel('')plt.title('Feature Importance from Random Forest', size = 30) Text(0.5, 1.0, &#39;Feature Importance from Random Forest&#39;) 利用特征重要性进行特征选择: 鉴于并非每个特征对于影响分数都很重要，如果我们将随机森林中最重要特征的子集用于更简单的模型（如线性回归），会发生什么？ 线性回归确实优于基线，但与模型复杂模型相比表现不佳。 让我们尝试仅在线性回归中的使用10个最重要的特征来查看性能是否得到改善。 我们还可以限制这些功能并重新评估随机森林。 123456789101112# 提取重要的10个特征名称most_important_features = feature_results['feature'][:10]# 寻找对应特征的indexindices = [list(train_features.columns).index(x) for x in most_important_features]# 仅保留最重要的10个特征X_reduced = X[:, indices]X_test_reduced = X_test[:, indices]print('Most important training features shape: ', X_reduced.shape)print('Most important testing features shape: ', X_test_reduced.shape) Most important training features shape: (6622, 10) Most important testing features shape: (2839, 10) 12345678910111213lr = LinearRegression()# 拟合所有特征lr.fit(X, y)lr_full_pred = lr.predict(X_test)# 仅拟合最重要的10个特征lr.fit(X_reduced, y)lr_reduced_pred = lr.predict(X_test_reduced)# 结果对比print('Linear Regression Full Results: MAE = %0.4f.' % mae(y_test, lr_full_pred))print('Linear Regression Reduced Results: MAE = %0.4f.' % mae(y_test, lr_reduced_pred)) Linear Regression Full Results: MAE = 13.4651. Linear Regression Reduced Results: MAE = 14.4016. 可以看到，减少特征并没有改善线性回归结果！ 事实证明，低重要性特征中的额外信息确实可以提高性能。 让我们再看看在梯度提升回归中使用减少的特征集。 性能如何受到影响？ 12345678910# 使用一样的超参数建立梯度提升模型model_reduced = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)# 拟合并预测model_reduced.fit(X_reduced, y)model_reduced_pred = model_reduced.predict(X_test_reduced)print('Gradient Boosted Reduced Results: MAE = %0.4f' % mae(y_test, model_reduced_pred)) Gradient Boosted Reduced Results: MAE = 9.5251 随着特征的减少，模型结果略差，我们将为最终模型保留所有特征。 减少特征数量是因为我们总是希望构建最简约的模型： 即具有足够性能的最简单模型。 使用较少特征的模型将更快地训练并且通常更容易解释。 在这种情况下，保留所有特征并不是主要问题，因为训练时间在本项目中并不重要，我们仍然可以使用许多特征进行解释。 7.3 局部可理解的与模型无关的解释器（LIME）我们将使用LIME来解释模型所做的个别预测。 LIME是一项相对较新的工作，旨在通过用线性模型近似一个预测周围的区域来展示机器学习模型的思考方式。 我们将试图解释模型在两个例子上得到的预测结果：其中一个例子得到的预测结果非常差，另一个例子得到的预测结果非常好。 我们将限制使用的10个最重要的特征来帮助解释。 虽然在10个最重要的特征上训练的模型稍微不准确，但我们通常必须权衡可解释性的准确性！ 123456# 计算残差residuals = abs(model_reduced_pred - y_test)# 提取最差和最好的预测wrong = X_test_reduced[np.argmax(residuals), :]right = X_test_reduced[np.argmin(residuals), :] 12345# 创建lime解释器explainer = lime.lime_tabular.LimeTabularExplainer(training_data = X_reduced, mode = 'regression', training_labels = y, feature_names = list(most_important_features)) 1234567891011# 为错误示例显示预测值和真实值print('Prediction: %0.4f' % model_reduced.predict(wrong.reshape(1, -1)))print('Actual Value: %0.4f' % y_test[np.argmax(residuals)])# 解释错误预测wrong_exp = explainer.explain_instance(data_row = wrong, predict_fn = model_reduced.predict)# 绘制预测解释wrong_exp.as_pyplot_figure()plt.title('Explanation of Prediction', size = 28);plt.xlabel('Effect on Prediction', size = 22); Prediction: 14.1601 Actual Value: 96.0000 C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\linear_model\ridge.py:125: LinAlgWarning: scipy.linalg.solve Ill-conditioned matrix detected. Result is not guaranteed to be accurate. Reciprocal condition number3.113013e-27 overwrite_a=True).T 1wrong_exp.show_in_notebook(show_predicted_value=False) var lime = /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ""; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); exports.PredictedValue = exports.PredictProba = exports.Barchart = exports.Explanation = undefined; var _explanation = __webpack_require__(1); var _explanation2 = _interopRequireDefault(_explanation); var _bar_chart = __webpack_require__(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _predict_proba = __webpack_require__(6); var _predict_proba2 = _interopRequireDefault(_predict_proba); var _predicted_value = __webpack_require__(7); var _predicted_value2 = _interopRequireDefault(_predicted_value); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } if (!global._babelPolyfill) { __webpack_require__(8); } __webpack_require__(339); exports.Explanation = _explanation2.default; exports.Barchart = _bar_chart2.default; exports.PredictProba = _predict_proba2.default; exports.PredictedValue = _predicted_value2.default; //require('style-loader'); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _bar_chart = __webpack_require__(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var Explanation = function () { function Explanation(class_names) { _classCallCheck(this, Explanation); this.names = class_names; if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } } // exp: [(feature-name, weight), ...] // label: int // div: d3 selection Explanation.prototype.show = function show(exp, label, div) { var svg = div.append('svg').style('width', '100%'); var colors = ['#5F9EA0', this.colors_i(label)]; var names = ['NOT ' + this.names[label], this.names[label]]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; names = this.names; } var plot = new _bar_chart2.default(svg, exp, true, names, colors, true, 10); svg.style('height', plot.svg_height + 'px'); }; // exp has all ocurrences of words, with start index and weight: // exp = [('word', 132, -0.13), ('word3', 111, 1.3) Explanation.prototype.show_raw_text = function show_raw_text(exp, label, raw, div) { var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true; //let colors=['#5F9EA0', this.colors(this.exp['class'])]; var colors = ['#5F9EA0', this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var word_lists = [[], []]; var max_weight = -1; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = exp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var _step$value = _slicedToArray(_step.value, 3), word = _step$value[0], start = _step$value[1], weight = _step$value[2]; if (weight > 0) { word_lists[1].push([start, start + word.length, weight]); } else { word_lists[0].push([start, start + word.length, -weight]); } max_weight = Math.max(max_weight, Math.abs(weight)); } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } if (!opacity) { max_weight = 0; } this.display_raw_text(div, raw, word_lists, colors, max_weight, true); }; // exp is list of (feature_name, value, weight) Explanation.prototype.show_raw_tabular = function show_raw_tabular(exp, label, div) { div.classed('lime', true).classed('table_div', true); var colors = ['#5F9EA0', this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var table = div.append('table'); var thead = table.append('tr'); thead.append('td').text('Feature'); thead.append('td').text('Value'); thead.style('color', 'black').style('font-size', '20px'); var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = exp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var _step2$value = _slicedToArray(_step2.value, 3), fname = _step2$value[0], value = _step2$value[1], weight = _step2$value[2]; var tr = table.append('tr'); tr.style('border-style', 'hidden'); tr.append('td').text(fname); tr.append('td').text(value); if (weight > 0) { tr.style('background-color', colors[1]); } else if (weight < 0) { tr.style('background-color', colors[0]); } else { tr.style('color', 'black'); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 && _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } }; Explanation.prototype.hexToRgb = function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }; Explanation.prototype.applyAlpha = function applyAlpha(hex, alpha) { var components = this.hexToRgb(hex); return 'rgba(' + components.r + "," + components.g + "," + components.b + "," + alpha.toFixed(3) + ")"; }; // sord_lists is an array of arrays, of length (colors). if with_positions is true, // word_lists is an array of [start,end] positions instead Explanation.prototype.display_raw_text = function display_raw_text(div, raw_text) { var word_lists = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []; var colors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; var max_weight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1; var positions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; div.classed('lime', true).classed('text_div', true); div.append('h3').text('Text with highlighted words'); var highlight_tag = 'span'; var text_span = div.append('span').style('white-space', 'pre-wrap').text(raw_text); var position_lists = word_lists; if (!positions) { position_lists = this.wordlists_to_positions(word_lists, raw_text); } var objects = []; var _iteratorNormalCompletion3 = true; var _didIteratorError3 = false; var _iteratorError3 = undefined; try { var _loop = function _loop() { var i = _step3.value; position_lists[i].map(function (x) { return objects.push({ 'label': i, 'start': x[0], 'end': x[1], 'alpha': max_weight === 0 ? 1 : x[2] / max_weight }); }); }; for (var _iterator3 = (0, _lodash.range)(position_lists.length)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) { _loop(); } } catch (err) { _didIteratorError3 = true; _iteratorError3 = err; } finally { try { if (!_iteratorNormalCompletion3 && _iterator3.return) { _iterator3.return(); } } finally { if (_didIteratorError3) { throw _iteratorError3; } } } objects = (0, _lodash.sortBy)(objects, function (x) { return x['start']; }); var node = text_span.node().childNodes[0]; var subtract = 0; var _iteratorNormalCompletion4 = true; var _didIteratorError4 = false; var _iteratorError4 = undefined; try { for (var _iterator4 = objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) { var obj = _step4.value; var word = raw_text.slice(obj.start, obj.end); var start = obj.start - subtract; var end = obj.end - subtract; var match = document.createElement(highlight_tag); match.appendChild(document.createTextNode(word)); match.style.backgroundColor = this.applyAlpha(colors[obj.label], obj.alpha); var after = node.splitText(start); after.nodeValue = after.nodeValue.substring(word.length); node.parentNode.insertBefore(match, after); subtract += end; node = after; } } catch (err) { _didIteratorError4 = true; _iteratorError4 = err; } finally { try { if (!_iteratorNormalCompletion4 && _iterator4.return) { _iterator4.return(); } } finally { if (_didIteratorError4) { throw _iteratorError4; } } } }; Explanation.prototype.wordlists_to_positions = function wordlists_to_positions(word_lists, raw_text) { var ret = []; var _iteratorNormalCompletion5 = true; var _didIteratorError5 = false; var _iteratorError5 = undefined; try { for (var _iterator5 = word_lists[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) { var words = _step5.value; if (words.length === 0) { ret.push([]); continue; } var re = new RegExp("\\b(" + words.join('|') + ")\\b", 'gm'); var temp = void 0; var list = []; while ((temp = re.exec(raw_text)) !== null) { list.push([temp.index, temp.index + temp[0].length]); } ret.push(list); } } catch (err) { _didIteratorError5 = true; _iteratorError5 = err; } finally { try { if (!_iteratorNormalCompletion5 && _iterator5.return) { _iterator5.return(); } } finally { if (_didIteratorError5) { throw _iteratorError5; } } } return ret; }; return Explanation; }(); exports.default = Explanation; /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() { var d3 = { version: "3.5.17" }; var d3_arraySlice = [].slice, d3_array = function(list) { return d3_arraySlice.call(list); }; var d3_document = this.document; function d3_documentElement(node) { return node && (node.ownerDocument || node.document || node).documentElement; } function d3_window(node) { return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView); } if (d3_document) { try { d3_array(d3_document.documentElement.childNodes)[0].nodeType; } catch (e) { d3_array = function(list) { var i = list.length, array = new Array(i); while (i--) array[i] = list[i]; return array; }; } } if (!Date.now) Date.now = function() { return +new Date(); }; if (d3_document) { try { d3_document.createElement("DIV").style.setProperty("opacity", 0, ""); } catch (error) { var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty; d3_element_prototype.setAttribute = function(name, value) { d3_element_setAttribute.call(this, name, value + ""); }; d3_element_prototype.setAttributeNS = function(space, local, value) { d3_element_setAttributeNS.call(this, space, local, value + ""); }; d3_style_prototype.setProperty = function(name, value, priority) { d3_style_setProperty.call(this, name, value + "", priority); }; } } d3.ascending = d3_ascending; function d3_ascending(a, b) { return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; } d3.descending = function(a, b) { return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN; }; d3.min = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; } while (++i < n) if ((b = array[i]) != null && a > b) a = b; } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b; } return a; }; d3.max = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; } while (++i < n) if ((b = array[i]) != null && b > a) a = b; } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b; } return a; }; d3.extent = function(array, f) { var i = -1, n = array.length, a, b, c; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; } while (++i < n) if ((b = array[i]) != null) { if (a > b) a = b; if (c < b) c = b; } } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = c = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null) { if (a > b) a = b; if (c < b) c = b; } } return [ a, c ]; }; function d3_number(x) { return x === null ? NaN : +x; } function d3_numeric(x) { return !isNaN(x); } d3.sum = function(array, f) { var s = 0, n = array.length, a, i = -1; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = +array[i])) s += a; } else { while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a; } return s; }; d3.mean = function(array, f) { var s = 0, n = array.length, a, i = -1, j = n; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j; } else { while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j; } if (j) return s / j; }; d3.quantile = function(values, p) { var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h; return e ? v + e * (values[h] - v) : v; }; d3.median = function(array, f) { var numbers = [], n = array.length, a, i = -1; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a); } else { while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a); } if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5); }; d3.variance = function(array, f) { var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0; if (arguments.length === 1) { while (++i < n) { if (d3_numeric(a = d3_number(array[i]))) { d = a - m; m += d / ++j; s += d * (a - m); } } } else { while (++i < n) { if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) { d = a - m; m += d / ++j; s += d * (a - m); } } } if (j > 1) return s / (j - 1); }; d3.deviation = function() { var v = d3.variance.apply(this, arguments); return v ? Math.sqrt(v) : v; }; function d3_bisector(compare) { return { left: function(a, x, lo, hi) { if (arguments.length < 3) lo = 0; if (arguments.length < 4) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid; } return lo; }, right: function(a, x, lo, hi) { if (arguments.length < 3) lo = 0; if (arguments.length < 4) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1; } return lo; } }; } var d3_bisect = d3_bisector(d3_ascending); d3.bisectLeft = d3_bisect.left; d3.bisect = d3.bisectRight = d3_bisect.right; d3.bisector = function(f) { return d3_bisector(f.length === 1 ? function(d, x) { return d3_ascending(f(d), x); } : f); }; d3.shuffle = function(array, i0, i1) { if ((m = arguments.length) < 3) { i1 = array.length; if (m < 2) i0 = 0; } var m = i1 - i0, t, i; while (m) { i = Math.random() * m-- | 0; t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t; } return array; }; d3.permute = function(array, indexes) { var i = indexes.length, permutes = new Array(i); while (i--) permutes[i] = array[indexes[i]]; return permutes; }; d3.pairs = function(array) { var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n); while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ]; return pairs; }; d3.transpose = function(matrix) { if (!(n = matrix.length)) return []; for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) { for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) { row[j] = matrix[j][i]; } } return transpose; }; function d3_transposeLength(d) { return d.length; } d3.zip = function() { return d3.transpose(arguments); }; d3.keys = function(map) { var keys = []; for (var key in map) keys.push(key); return keys; }; d3.values = function(map) { var values = []; for (var key in map) values.push(map[key]); return values; }; d3.entries = function(map) { var entries = []; for (var key in map) entries.push({ key: key, value: map[key] }); return entries; }; d3.merge = function(arrays) { var n = arrays.length, m, i = -1, j = 0, merged, array; while (++i < n) j += arrays[i].length; merged = new Array(j); while (--n >= 0) { array = arrays[n]; m = array.length; while (--m >= 0) { merged[--j] = array[m]; } } return merged; }; var abs = Math.abs; d3.range = function(start, stop, step) { if (arguments.length < 3) { step = 1; if (arguments.length < 2) { stop = start; start = 0; } } if ((stop - start) / step === Infinity) throw new Error("infinite range"); var range = [], k = d3_range_integerScale(abs(step)), i = -1, j; start *= k, stop *= k, step *= k; if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k); return range; }; function d3_range_integerScale(x) { var k = 1; while (x * k % 1) k *= 10; return k; } function d3_class(ctor, properties) { for (var key in properties) { Object.defineProperty(ctor.prototype, key, { value: properties[key], enumerable: false }); } } d3.map = function(object, f) { var map = new d3_Map(); if (object instanceof d3_Map) { object.forEach(function(key, value) { map.set(key, value); }); } else if (Array.isArray(object)) { var i = -1, n = object.length, o; if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o); } else { for (var key in object) map.set(key, object[key]); } return map; }; function d3_Map() { this._ = Object.create(null); } var d3_map_proto = "__proto__", d3_map_zero = "\x00"; d3_class(d3_Map, { has: d3_map_has, get: function(key) { return this._[d3_map_escape(key)]; }, set: function(key, value) { return this._[d3_map_escape(key)] = value; }, remove: d3_map_remove, keys: d3_map_keys, values: function() { var values = []; for (var key in this._) values.push(this._[key]); return values; }, entries: function() { var entries = []; for (var key in this._) entries.push({ key: d3_map_unescape(key), value: this._[key] }); return entries; }, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]); } }); function d3_map_escape(key) { return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key; } function d3_map_unescape(key) { return (key += "")[0] === d3_map_zero ? key.slice(1) : key; } function d3_map_has(key) { return d3_map_escape(key) in this._; } function d3_map_remove(key) { return (key = d3_map_escape(key)) in this._ && delete this._[key]; } function d3_map_keys() { var keys = []; for (var key in this._) keys.push(d3_map_unescape(key)); return keys; } function d3_map_size() { var size = 0; for (var key in this._) ++size; return size; } function d3_map_empty() { for (var key in this._) return false; return true; } d3.nest = function() { var nest = {}, keys = [], sortKeys = [], sortValues, rollup; function map(mapType, array, depth) { if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array; var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values; while (++i < n) { if (values = valuesByKey.get(keyValue = key(object = array[i]))) { values.push(object); } else { valuesByKey.set(keyValue, [ object ]); } } if (mapType) { object = mapType(); setter = function(keyValue, values) { object.set(keyValue, map(mapType, values, depth)); }; } else { object = {}; setter = function(keyValue, values) { object[keyValue] = map(mapType, values, depth); }; } valuesByKey.forEach(setter); return object; } function entries(map, depth) { if (depth >= keys.length) return map; var array = [], sortKey = sortKeys[depth++]; map.forEach(function(key, keyMap) { array.push({ key: key, values: entries(keyMap, depth) }); }); return sortKey ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array; } nest.map = function(array, mapType) { return map(mapType, array, 0); }; nest.entries = function(array) { return entries(map(d3.map, array, 0), 0); }; nest.key = function(d) { keys.push(d); return nest; }; nest.sortKeys = function(order) { sortKeys[keys.length - 1] = order; return nest; }; nest.sortValues = function(order) { sortValues = order; return nest; }; nest.rollup = function(f) { rollup = f; return nest; }; return nest; }; d3.set = function(array) { var set = new d3_Set(); if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]); return set; }; function d3_Set() { this._ = Object.create(null); } d3_class(d3_Set, { has: d3_map_has, add: function(key) { this._[d3_map_escape(key += "")] = true; return key; }, remove: d3_map_remove, values: d3_map_keys, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key)); } }); d3.behavior = {}; function d3_identity(d) { return d; } d3.rebind = function(target, source) { var i = 1, n = arguments.length, method; while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]); return target; }; function d3_rebind(target, source, method) { return function() { var value = method.apply(source, arguments); return value === source ? target : value; }; } function d3_vendorSymbol(object, name) { if (name in object) return name; name = name.charAt(0).toUpperCase() + name.slice(1); for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) { var prefixName = d3_vendorPrefixes[i] + name; if (prefixName in object) return prefixName; } } var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ]; function d3_noop() {} d3.dispatch = function() { var dispatch = new d3_dispatch(), i = -1, n = arguments.length; while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); return dispatch; }; function d3_dispatch() {} d3_dispatch.prototype.on = function(type, listener) { var i = type.indexOf("."), name = ""; if (i >= 0) { name = type.slice(i + 1); type = type.slice(0, i); } if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener); if (arguments.length === 2) { if (listener == null) for (type in this) { if (this.hasOwnProperty(type)) this[type].on(name, null); } return this; } }; function d3_dispatch_event(dispatch) { var listeners = [], listenerByName = new d3_Map(); function event() { var z = listeners, i = -1, n = z.length, l; while (++i < n) if (l = z[i].on) l.apply(this, arguments); return dispatch; } event.on = function(name, listener) { var l = listenerByName.get(name), i; if (arguments.length < 2) return l && l.on; if (l) { l.on = null; listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)); listenerByName.remove(name); } if (listener) listeners.push(listenerByName.set(name, { on: listener })); return dispatch; }; return event; } d3.event = null; function d3_eventPreventDefault() { d3.event.preventDefault(); } function d3_eventSource() { var e = d3.event, s; while (s = e.sourceEvent) e = s; return e; } function d3_eventDispatch(target) { var dispatch = new d3_dispatch(), i = 0, n = arguments.length; while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); dispatch.of = function(thiz, argumentz) { return function(e1) { try { var e0 = e1.sourceEvent = d3.event; e1.target = target; d3.event = e1; dispatch[e1.type].apply(thiz, argumentz); } finally { d3.event = e0; } }; }; return dispatch; } d3.requote = function(s) { return s.replace(d3_requote_re, "\\$&"); }; var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; var d3_subclass = {}.__proto__ ? function(object, prototype) { object.__proto__ = prototype; } : function(object, prototype) { for (var property in prototype) object[property] = prototype[property]; }; function d3_selection(groups) { d3_subclass(groups, d3_selectionPrototype); return groups; } var d3_select = function(s, n) { return n.querySelector(s); }, d3_selectAll = function(s, n) { return n.querySelectorAll(s); }, d3_selectMatches = function(n, s) { var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")]; d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); }; return d3_selectMatches(n, s); }; if (typeof Sizzle === "function") { d3_select = function(s, n) { return Sizzle(s, n)[0] || null; }; d3_selectAll = Sizzle; d3_selectMatches = Sizzle.matchesSelector; } d3.selection = function() { return d3.select(d3_document.documentElement); }; var d3_selectionPrototype = d3.selection.prototype = []; d3_selectionPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, group, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j < m; ) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroup.push(subnode = selector.call(node, node.__data__, i, j)); if (subnode && "__data__" in node) subnode.__data__ = node.__data__; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; function d3_selection_selector(selector) { return typeof selector === "function" ? selector : function() { return d3_select(selector, this); }; } d3_selectionPrototype.selectAll = function(selector) { var subgroups = [], subgroup, node; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j < m; ) { for (var group = this[j], i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j))); subgroup.parentNode = node; } } } return d3_selection(subgroups); }; function d3_selection_selectorAll(selector) { return typeof selector === "function" ? selector : function() { return d3_selectAll(selector, this); }; } var d3_nsXhtml = "http://www.w3.org/1999/xhtml"; var d3_nsPrefix = { svg: "http://www.w3.org/2000/svg", xhtml: d3_nsXhtml, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }; d3.ns = { prefix: d3_nsPrefix, qualify: function(name) { var i = name.indexOf(":"), prefix = name; if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1); return d3_nsPrefix.hasOwnProperty(prefix) ? { space: d3_nsPrefix[prefix], local: name } : name; } }; d3_selectionPrototype.attr = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") { var node = this.node(); name = d3.ns.qualify(name); return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name); } for (value in name) this.each(d3_selection_attr(value, name[value])); return this; } return this.each(d3_selection_attr(name, value)); }; function d3_selection_attr(name, value) { name = d3.ns.qualify(name); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrConstant() { this.setAttribute(name, value); } function attrConstantNS() { this.setAttributeNS(name.space, name.local, value); } function attrFunction() { var x = value.apply(this, arguments); if (x == null) this.removeAttribute(name); else this.setAttribute(name, x); } function attrFunctionNS() { var x = value.apply(this, arguments); if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x); } return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant; } function d3_collapse(s) { return s.trim().replace(/\s+/g, " "); } d3_selectionPrototype.classed = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") { var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1; if (value = node.classList) { while (++i < n) if (!value.contains(name[i])) return false; } else { value = node.getAttribute("class"); while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false; } return true; } for (value in name) this.each(d3_selection_classed(value, name[value])); return this; } return this.each(d3_selection_classed(name, value)); }; function d3_selection_classedRe(name) { return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g"); } function d3_selection_classes(name) { return (name + "").trim().split(/^|\s+/); } function d3_selection_classed(name, value) { name = d3_selection_classes(name).map(d3_selection_classedName); var n = name.length; function classedConstant() { var i = -1; while (++i < n) name[i](this, value); } function classedFunction() { var i = -1, x = value.apply(this, arguments); while (++i < n) name[i](this, x); } return typeof value === "function" ? classedFunction : classedConstant; } function d3_selection_classedName(name) { var re = d3_selection_classedRe(name); return function(node, value) { if (c = node.classList) return value ? c.add(name) : c.remove(name); var c = node.getAttribute("class") || ""; if (value) { re.lastIndex = 0; if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name)); } else { node.setAttribute("class", d3_collapse(c.replace(re, " "))); } }; } d3_selectionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n < 3) { if (typeof name !== "string") { if (n < 2) value = ""; for (priority in name) this.each(d3_selection_style(priority, name[priority], value)); return this; } if (n < 2) { var node = this.node(); return d3_window(node).getComputedStyle(node, null).getPropertyValue(name); } priority = ""; } return this.each(d3_selection_style(name, value, priority)); }; function d3_selection_style(name, value, priority) { function styleNull() { this.style.removeProperty(name); } function styleConstant() { this.style.setProperty(name, value, priority); } function styleFunction() { var x = value.apply(this, arguments); if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority); } return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant; } d3_selectionPrototype.property = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") return this.node()[name]; for (value in name) this.each(d3_selection_property(value, name[value])); return this; } return this.each(d3_selection_property(name, value)); }; function d3_selection_property(name, value) { function propertyNull() { delete this[name]; } function propertyConstant() { this[name] = value; } function propertyFunction() { var x = value.apply(this, arguments); if (x == null) delete this[name]; else this[name] = x; } return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant; } d3_selectionPrototype.text = function(value) { return arguments.length ? this.each(typeof value === "function" ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? "" : v; } : value == null ? function() { this.textContent = ""; } : function() { this.textContent = value; }) : this.node().textContent; }; d3_selectionPrototype.html = function(value) { return arguments.length ? this.each(typeof value === "function" ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? "" : v; } : value == null ? function() { this.innerHTML = ""; } : function() { this.innerHTML = value; }) : this.node().innerHTML; }; d3_selectionPrototype.append = function(name) { name = d3_selection_creator(name); return this.select(function() { return this.appendChild(name.apply(this, arguments)); }); }; function d3_selection_creator(name) { function create() { var document = this.ownerDocument, namespace = this.namespaceURI; return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name); } function createNS() { return this.ownerDocument.createElementNS(name.space, name.local); } return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create; } d3_selectionPrototype.insert = function(name, before) { name = d3_selection_creator(name); before = d3_selection_selector(before); return this.select(function() { return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null); }); }; d3_selectionPrototype.remove = function() { return this.each(d3_selectionRemove); }; function d3_selectionRemove() { var parent = this.parentNode; if (parent) parent.removeChild(this); } d3_selectionPrototype.data = function(value, key) { var i = -1, n = this.length, group, node; if (!arguments.length) { value = new Array(n = (group = this[0]).length); while (++i < n) { if (node = group[i]) { value[i] = node.__data__; } } return value; } function bind(group, groupData) { var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData; if (key) { var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue; for (i = -1; ++i < n; ) { if (node = group[i]) { if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) { exitNodes[i] = node; } else { nodeByKeyValue.set(keyValue, node); } keyValues[i] = keyValue; } } for (i = -1; ++i < m; ) { if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) { enterNodes[i] = d3_selection_dataNode(nodeData); } else if (node !== true) { updateNodes[i] = node; node.__data__ = nodeData; } nodeByKeyValue.set(keyValue, true); } for (i = -1; ++i < n; ) { if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) { exitNodes[i] = group[i]; } } } else { for (i = -1; ++i < n0; ) { node = group[i]; nodeData = groupData[i]; if (node) { node.__data__ = nodeData; updateNodes[i] = node; } else { enterNodes[i] = d3_selection_dataNode(nodeData); } } for (;i < m; ++i) { enterNodes[i] = d3_selection_dataNode(groupData[i]); } for (;i < n; ++i) { exitNodes[i] = group[i]; } } enterNodes.update = updateNodes; enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode; enter.push(enterNodes); update.push(updateNodes); exit.push(exitNodes); } var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]); if (typeof value === "function") { while (++i < n) { bind(group = this[i], value.call(group, group.parentNode.__data__, i)); } } else { while (++i < n) { bind(group = this[i], value); } } update.enter = function() { return enter; }; update.exit = function() { return exit; }; return update; }; function d3_selection_dataNode(data) { return { __data__: data }; } d3_selectionPrototype.datum = function(value) { return arguments.length ? this.property("__data__", value) : this.property("__data__"); }; d3_selectionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== "function") filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j < m; j++) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = 0, n = group.length; i < n; i++) { if ((node = group[i]) && filter.call(node, node.__data__, i, j)) { subgroup.push(node); } } } return d3_selection(subgroups); }; function d3_selection_filter(selector) { return function() { return d3_selectMatches(this, selector); }; } d3_selectionPrototype.order = function() { for (var j = -1, m = this.length; ++j < m; ) { for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) { if (node = group[i]) { if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next); next = node; } } } return this; }; d3_selectionPrototype.sort = function(comparator) { comparator = d3_selection_sortComparator.apply(this, arguments); for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator); return this.order(); }; function d3_selection_sortComparator(comparator) { if (!arguments.length) comparator = d3_ascending; return function(a, b) { return a && b ? comparator(a.__data__, b.__data__) : !a - !b; }; } d3_selectionPrototype.each = function(callback) { return d3_selection_each(this, function(node, i, j) { callback.call(node, node.__data__, i, j); }); }; function d3_selection_each(groups, callback) { for (var j = 0, m = groups.length; j < m; j++) { for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) { if (node = group[i]) callback(node, i, j); } } return groups; } d3_selectionPrototype.call = function(callback) { var args = d3_array(arguments); callback.apply(args[0] = this, args); return this; }; d3_selectionPrototype.empty = function() { return !this.node(); }; d3_selectionPrototype.node = function() { for (var j = 0, m = this.length; j < m; j++) { for (var group = this[j], i = 0, n = group.length; i < n; i++) { var node = group[i]; if (node) return node; } } return null; }; d3_selectionPrototype.size = function() { var n = 0; d3_selection_each(this, function() { ++n; }); return n; }; function d3_selection_enter(selection) { d3_subclass(selection, d3_selection_enterPrototype); return selection; } var d3_selection_enterPrototype = []; d3.selection.enter = d3_selection_enter; d3.selection.enter.prototype = d3_selection_enterPrototype; d3_selection_enterPrototype.append = d3_selectionPrototype.append; d3_selection_enterPrototype.empty = d3_selectionPrototype.empty; d3_selection_enterPrototype.node = d3_selectionPrototype.node; d3_selection_enterPrototype.call = d3_selectionPrototype.call; d3_selection_enterPrototype.size = d3_selectionPrototype.size; d3_selection_enterPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, upgroup, group, node; for (var j = -1, m = this.length; ++j < m; ) { upgroup = (group = this[j]).update; subgroups.push(subgroup = []); subgroup.parentNode = group.parentNode; for (var i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j)); subnode.__data__ = node.__data__; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; d3_selection_enterPrototype.insert = function(name, before) { if (arguments.length < 2) before = d3_selection_enterInsertBefore(this); return d3_selectionPrototype.insert.call(this, name, before); }; function d3_selection_enterInsertBefore(enter) { var i0, j0; return function(d, i, j) { var group = enter[j].update, n = group.length, node; if (j != j0) j0 = j, i0 = 0; if (i >= i0) i0 = i + 1; while (!(node = group[i0]) && ++i0 < n) ; return node; }; } d3.select = function(node) { var group; if (typeof node === "string") { group = [ d3_select(node, d3_document) ]; group.parentNode = d3_document.documentElement; } else { group = [ node ]; group.parentNode = d3_documentElement(node); } return d3_selection([ group ]); }; d3.selectAll = function(nodes) { var group; if (typeof nodes === "string") { group = d3_array(d3_selectAll(nodes, d3_document)); group.parentNode = d3_document.documentElement; } else { group = d3_array(nodes); group.parentNode = null; } return d3_selection([ group ]); }; d3_selectionPrototype.on = function(type, listener, capture) { var n = arguments.length; if (n < 3) { if (typeof type !== "string") { if (n < 2) listener = false; for (capture in type) this.each(d3_selection_on(capture, type[capture], listener)); return this; } if (n < 2) return (n = this.node()["__on" + type]) && n._; capture = false; } return this.each(d3_selection_on(type, listener, capture)); }; function d3_selection_on(type, listener, capture) { var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener; if (i > 0) type = type.slice(0, i); var filter = d3_selection_onFilters.get(type); if (filter) type = filter, wrap = d3_selection_onFilter; function onRemove() { var l = this[name]; if (l) { this.removeEventListener(type, l, l.$); delete this[name]; } } function onAdd() { var l = wrap(listener, d3_array(arguments)); onRemove.call(this); this.addEventListener(type, this[name] = l, l.$ = capture); l._ = listener; } function removeAll() { var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match; for (var name in this) { if (match = name.match(re)) { var l = this[name]; this.removeEventListener(match[1], l, l.$); delete this[name]; } } } return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll; } var d3_selection_onFilters = d3.map({ mouseenter: "mouseover", mouseleave: "mouseout" }); if (d3_document) { d3_selection_onFilters.forEach(function(k) { if ("on" + k in d3_document) d3_selection_onFilters.remove(k); }); } function d3_selection_onListener(listener, argumentz) { return function(e) { var o = d3.event; d3.event = e; argumentz[0] = this.__data__; try { listener.apply(this, argumentz); } finally { d3.event = o; } }; } function d3_selection_onFilter(listener, argumentz) { var l = d3_selection_onListener(listener, argumentz); return function(e) { var target = this, related = e.relatedTarget; if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) { l.call(target, e); } }; } var d3_event_dragSelect, d3_event_dragId = 0; function d3_event_dragSuppress(node) { var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault); if (d3_event_dragSelect == null) { d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect"); } if (d3_event_dragSelect) { var style = d3_documentElement(node).style, select = style[d3_event_dragSelect]; style[d3_event_dragSelect] = "none"; } return function(suppressClick) { w.on(name, null); if (d3_event_dragSelect) style[d3_event_dragSelect] = select; if (suppressClick) { var off = function() { w.on(click, null); }; w.on(click, function() { d3_eventPreventDefault(); off(); }, true); setTimeout(off, 0); } }; } d3.mouse = function(container) { return d3_mousePoint(container, d3_eventSource()); }; var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0; function d3_mousePoint(container, e) { if (e.changedTouches) e = e.changedTouches[0]; var svg = container.ownerSVGElement || container; if (svg.createSVGPoint) { var point = svg.createSVGPoint(); if (d3_mouse_bug44083 < 0) { var window = d3_window(container); if (window.scrollX || window.scrollY) { svg = d3.select("body").append("svg").style({ position: "absolute", top: 0, left: 0, margin: 0, padding: 0, border: "none" }, "important"); var ctm = svg[0][0].getScreenCTM(); d3_mouse_bug44083 = !(ctm.f || ctm.e); svg.remove(); } } if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, point.y = e.clientY; point = point.matrixTransform(container.getScreenCTM().inverse()); return [ point.x, point.y ]; } var rect = container.getBoundingClientRect(); return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ]; } d3.touch = function(container, touches, identifier) { if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches; if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) { if ((touch = touches[i]).identifier === identifier) { return d3_mousePoint(container, touch); } } }; d3.behavior.drag = function() { var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend"); function drag() { this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart); } function dragstart(id, position, subject, move, end) { return function() { var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId); if (origin) { dragOffset = origin.apply(that, arguments); dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ]; } else { dragOffset = [ 0, 0 ]; } dispatch({ type: "dragstart" }); function moved() { var position1 = position(parent, dragId), dx, dy; if (!position1) return; dx = position1[0] - position0[0]; dy = position1[1] - position0[1]; dragged |= dx | dy; position0 = position1; dispatch({ type: "drag", x: position1[0] + dragOffset[0], y: position1[1] + dragOffset[1], dx: dx, dy: dy }); } function ended() { if (!position(parent, dragId)) return; dragSubject.on(move + dragName, null).on(end + dragName, null); dragRestore(dragged); dispatch({ type: "dragend" }); } }; } drag.origin = function(x) { if (!arguments.length) return origin; origin = x; return drag; }; return d3.rebind(drag, event, "on"); }; function d3_behavior_dragTouchId() { return d3.event.changedTouches[0].identifier; } d3.touches = function(container, touches) { if (arguments.length < 2) touches = d3_eventSource().touches; return touches ? d3_array(touches).map(function(touch) { var point = d3_mousePoint(container, touch); point.identifier = touch.identifier; return point; }) : []; }; var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π; function d3_sgn(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; } function d3_cross2d(a, b, c) { return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]); } function d3_acos(x) { return x > 1 ? 0 : x < -1 ? π : Math.acos(x); } function d3_asin(x) { return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x); } function d3_sinh(x) { return ((x = Math.exp(x)) - 1 / x) / 2; } function d3_cosh(x) { return ((x = Math.exp(x)) + 1 / x) / 2; } function d3_tanh(x) { return ((x = Math.exp(2 * x)) - 1) / (x + 1); } function d3_haversin(x) { return (x = Math.sin(x / 2)) * x; } var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4; d3.interpolateZoom = function(p0, p1) { var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S; if (d2 < ε2) { S = Math.log(w1 / w0) / ρ; i = function(t) { return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ]; }; } else { var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1); S = (r1 - r0) / ρ; i = function(t) { var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0)); return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ]; }; } i.duration = S * 1e3; return i; }; d3.behavior.zoom = function() { var view = { x: 0, y: 0, k: 1 }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1; if (!d3_behavior_zoomWheel) { d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1); }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, "mousewheel") : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, "MozMousePixelScroll"); } function zoom(g) { g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted); } zoom.event = function(g) { g.each(function() { var dispatch = event.of(this, arguments), view1 = view; if (d3_transitionInheritId) { d3.select(this).transition().each("start.zoom", function() { view = this.__chart__ || { x: 0, y: 0, k: 1 }; zoomstarted(dispatch); }).tween("zoom:zoom", function() { var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]); return function(t) { var l = i(t), k = dx / l[2]; this.__chart__ = view = { x: cx - l[0] * k, y: cy - l[1] * k, k: k }; zoomed(dispatch); }; }).each("interrupt.zoom", function() { zoomended(dispatch); }).each("end.zoom", function() { zoomended(dispatch); }); } else { this.__chart__ = view; zoomstarted(dispatch); zoomed(dispatch); zoomended(dispatch); } }); }; zoom.translate = function(_) { if (!arguments.length) return [ view.x, view.y ]; view = { x: +_[0], y: +_[1], k: view.k }; rescale(); return zoom; }; zoom.scale = function(_) { if (!arguments.length) return view.k; view = { x: view.x, y: view.y, k: null }; scaleTo(+_); rescale(); return zoom; }; zoom.scaleExtent = function(_) { if (!arguments.length) return scaleExtent; scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ]; return zoom; }; zoom.center = function(_) { if (!arguments.length) return center; center = _ && [ +_[0], +_[1] ]; return zoom; }; zoom.size = function(_) { if (!arguments.length) return size; size = _ && [ +_[0], +_[1] ]; return zoom; }; zoom.duration = function(_) { if (!arguments.length) return duration; duration = +_; return zoom; }; zoom.x = function(z) { if (!arguments.length) return x1; x1 = z; x0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; zoom.y = function(z) { if (!arguments.length) return y1; y1 = z; y0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; function location(p) { return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ]; } function point(l) { return [ l[0] * view.k + view.x, l[1] * view.k + view.y ]; } function scaleTo(s) { view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s)); } function translateTo(p, l) { l = point(l); view.x += p[0] - l[0]; view.y += p[1] - l[1]; } function zoomTo(that, p, l, k) { that.__chart__ = { x: view.x, y: view.y, k: view.k }; scaleTo(Math.pow(2, k)); translateTo(center0 = p, l); that = d3.select(that); if (duration > 0) that = that.transition().duration(duration); that.call(zoom.event); } function rescale() { if (x1) x1.domain(x0.range().map(function(x) { return (x - view.x) / view.k; }).map(x0.invert)); if (y1) y1.domain(y0.range().map(function(y) { return (y - view.y) / view.k; }).map(y0.invert)); } function zoomstarted(dispatch) { if (!zooming++) dispatch({ type: "zoomstart" }); } function zoomed(dispatch) { rescale(); dispatch({ type: "zoom", scale: view.k, translate: [ view.x, view.y ] }); } function zoomended(dispatch) { if (!--zooming) dispatch({ type: "zoomend" }), center0 = null; } function mousedowned() { var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that); d3_selection_interrupt.call(that); zoomstarted(dispatch); function moved() { dragged = 1; translateTo(d3.mouse(that), location0); zoomed(dispatch); } function ended() { subject.on(mousemove, null).on(mouseup, null); dragRestore(dragged); zoomended(dispatch); } } function touchstarted() { var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that); started(); zoomstarted(dispatch); subject.on(mousedown, null).on(touchstart, started); function relocate() { var touches = d3.touches(that); scale0 = view.k; touches.forEach(function(t) { if (t.identifier in locations0) locations0[t.identifier] = location(t); }); return touches; } function started() { var target = d3.event.target; d3.select(target).on(touchmove, moved).on(touchend, ended); targets.push(target); var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i < n; ++i) { locations0[changed[i].identifier] = null; } var touches = relocate(), now = Date.now(); if (touches.length === 1) { if (now - touchtime < 500) { var p = touches[0]; zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1); d3_eventPreventDefault(); } touchtime = now; } else if (touches.length > 1) { var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1]; distance0 = dx * dx + dy * dy; } } function moved() { var touches = d3.touches(that), p0, l0, p1, l1; d3_selection_interrupt.call(that); for (var i = 0, n = touches.length; i < n; ++i, l1 = null) { p1 = touches[i]; if (l1 = locations0[p1.identifier]) { if (l0) break; p0 = p1, l0 = l1; } } if (l1) { var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0); p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ]; l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ]; scaleTo(scale1 * scale0); } touchtime = null; translateTo(p0, l0); zoomed(dispatch); } function ended() { if (d3.event.touches.length) { var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i < n; ++i) { delete locations0[changed[i].identifier]; } for (var identifier in locations0) { return void relocate(); } } d3.selectAll(targets).on(zoomName, null); subject.on(mousedown, mousedowned).on(touchstart, touchstarted); dragRestore(); zoomended(dispatch); } } function mousewheeled() { var dispatch = event.of(this, arguments); if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch); mousewheelTimer = setTimeout(function() { mousewheelTimer = null; zoomended(dispatch); }, 50); d3_eventPreventDefault(); scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k); translateTo(center0, translate0); zoomed(dispatch); } function dblclicked() { var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2; zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1); } return d3.rebind(zoom, event, "on"); }; var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel; d3.color = d3_color; function d3_color() {} d3_color.prototype.toString = function() { return this.rgb() + ""; }; d3.hsl = d3_hsl; function d3_hsl(h, s, l) { return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l); } var d3_hslPrototype = d3_hsl.prototype = new d3_color(); d3_hslPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, this.l / k); }; d3_hslPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, k * this.l); }; d3_hslPrototype.rgb = function() { return d3_hsl_rgb(this.h, this.s, this.l); }; function d3_hsl_rgb(h, s, l) { var m1, m2; h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h; s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s; l = l < 0 ? 0 : l > 1 ? 1 : l; m2 = l 360) h -= 360; else if (h < 0) h += 360; if (h < 60) return m1 + (m2 - m1) * h / 60; if (h < 180) return m2; if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60; return m1; } function vv(h) { return Math.round(v(h) * 255); } return new d3_rgb(vv(h + 120), vv(h), vv(h - 120)); } d3.hcl = d3_hcl; function d3_hcl(h, c, l) { return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l); } var d3_hclPrototype = d3_hcl.prototype = new d3_color(); d3_hclPrototype.brighter = function(k) { return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1))); }; d3_hclPrototype.darker = function(k) { return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1))); }; d3_hclPrototype.rgb = function() { return d3_hcl_lab(this.h, this.c, this.l).rgb(); }; function d3_hcl_lab(h, c, l) { if (isNaN(h)) h = 0; if (isNaN(c)) c = 0; return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c); } d3.lab = d3_lab; function d3_lab(l, a, b) { return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b); } var d3_lab_K = 18; var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883; var d3_labPrototype = d3_lab.prototype = new d3_color(); d3_labPrototype.brighter = function(k) { return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.darker = function(k) { return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.rgb = function() { return d3_lab_rgb(this.l, this.a, this.b); }; function d3_lab_rgb(l, a, b) { var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200; x = d3_lab_xyz(x) * d3_lab_X; y = d3_lab_xyz(y) * d3_lab_Y; z = d3_lab_xyz(z) * d3_lab_Z; return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z)); } function d3_lab_hcl(l, a, b) { return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l); } function d3_lab_xyz(x) { return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037; } function d3_xyz_lab(x) { return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29; } function d3_xyz_rgb(r) { return Math.round(255 * (r 16, value >> 8 & 255, value & 255); } function d3_rgbString(value) { return d3_rgbNumber(value) + ""; } var d3_rgbPrototype = d3_rgb.prototype = new d3_color(); d3_rgbPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); var r = this.r, g = this.g, b = this.b, i = 30; if (!r && !g && !b) return new d3_rgb(i, i, i); if (r && r < i) r = i; if (g && g < i) g = i; if (b && b < i) b = i; return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k)); }; d3_rgbPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_rgb(k * this.r, k * this.g, k * this.b); }; d3_rgbPrototype.hsl = function() { return d3_rgb_hsl(this.r, this.g, this.b); }; d3_rgbPrototype.toString = function() { return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b); }; function d3_rgb_hex(v) { return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16); } function d3_rgb_parse(format, rgb, hsl) { var r = 0, g = 0, b = 0, m1, m2, color; m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase()); if (m1) { m2 = m1[2].split(","); switch (m1[1]) { case "hsl": { return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100); } case "rgb": { return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2])); } } } if (color = d3_rgb_names.get(format)) { return rgb(color.r, color.g, color.b); } if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) { if (format.length === 4) { r = (color & 3840) >> 4; r = r >> 4 | r; g = color & 240; g = g >> 4 | g; b = color & 15; b = b < 4 | b; } else if (format.length === 7) { r = (color & 16711680) >> 16; g = (color & 65280) >> 8; b = color & 255; } } return rgb(r, g, b); } function d3_rgb_hsl(r, g, b) { var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2; if (d) { s = l < .5 ? d / (max + min) : d / (2 - max - min); if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4; h *= 60; } else { h = NaN; s = l > 0 && l < 1 ? 0 : h; } return new d3_hsl(h, s, l); } function d3_rgb_lab(r, g, b) { r = d3_rgb_xyz(r); g = d3_rgb_xyz(g); b = d3_rgb_xyz(b); var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z); return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z)); } function d3_rgb_xyz(r) { return (r /= 255) = 200 && status < 300 || status === 304) { try { result = response.call(xhr, request); } catch (e) { dispatch.error.call(xhr, e); return; } dispatch.load.call(xhr, result); } else { dispatch.error.call(xhr, request); } } request.onprogress = function(event) { var o = d3.event; d3.event = event; try { dispatch.progress.call(xhr, request); } finally { d3.event = o; } }; xhr.header = function(name, value) { name = (name + "").toLowerCase(); if (arguments.length < 2) return headers[name]; if (value == null) delete headers[name]; else headers[name] = value + ""; return xhr; }; xhr.mimeType = function(value) { if (!arguments.length) return mimeType; mimeType = value == null ? null : value + ""; return xhr; }; xhr.responseType = function(value) { if (!arguments.length) return responseType; responseType = value; return xhr; }; xhr.response = function(value) { response = value; return xhr; }; [ "get", "post" ].forEach(function(method) { xhr[method] = function() { return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments))); }; }); xhr.send = function(method, data, callback) { if (arguments.length === 2 && typeof data === "function") callback = data, data = null; request.open(method, url, true); if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*"; if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]); if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType); if (responseType != null) request.responseType = responseType; if (callback != null) xhr.on("error", callback).on("load", function(request) { callback(null, request); }); dispatch.beforesend.call(xhr, request); request.send(data == null ? null : data); return xhr; }; xhr.abort = function() { request.abort(); return xhr; }; d3.rebind(xhr, dispatch, "on"); return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback)); } function d3_xhr_fixCallback(callback) { return callback.length === 1 ? function(error, request) { callback(error == null ? request : null); } : callback; } function d3_xhrHasResponse(request) { var type = request.responseType; return type && type !== "text" ? request.response : request.responseText; } d3.dsv = function(delimiter, mimeType) { var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0); function dsv(url, row, callback) { if (arguments.length < 3) callback = row, row = null; var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback); xhr.row = function(_) { return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row; }; return xhr; } function response(request) { return dsv.parse(request.responseText); } function typedResponse(f) { return function(request) { return dsv.parse(request.responseText, f); }; } dsv.parse = function(text, f) { var o; return dsv.parseRows(text, function(row, i) { if (o) return o(row, i - 1); var a = new Function("d", "return {" + row.map(function(name, i) { return JSON.stringify(name) + ": d[" + i + "]"; }).join(",") + "}"); o = f ? function(row, i) { return f(a(row), i); } : a; }); }; dsv.parseRows = function(text, f) { var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol; function token() { if (I >= N) return EOF; if (eol) return eol = false, EOL; var j = I; if (text.charCodeAt(j) === 34) { var i = j; while (i++ < N) { if (text.charCodeAt(i) === 34) { if (text.charCodeAt(i + 1) !== 34) break; ++i; } } I = i + 2; var c = text.charCodeAt(i + 1); if (c === 13) { eol = true; if (text.charCodeAt(i + 2) === 10) ++I; } else if (c === 10) { eol = true; } return text.slice(j + 1, i).replace(/""/g, '"'); } while (I < N) { var c = text.charCodeAt(I++), k = 1; if (c === 10) eol = true; else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } else if (c !== delimiterCode) continue; return text.slice(j, I - k); } return text.slice(j); } while ((t = token()) !== EOF) { var a = []; while (t !== EOL && t !== EOF) { a.push(t); t = token(); } if (f && (a = f(a, n++)) == null) continue; rows.push(a); } return rows; }; dsv.format = function(rows) { if (Array.isArray(rows[0])) return dsv.formatRows(rows); var fieldSet = new d3_Set(), fields = []; rows.forEach(function(row) { for (var field in row) { if (!fieldSet.has(field)) { fields.push(fieldSet.add(field)); } } }); return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) { return fields.map(function(field) { return formatValue(row[field]); }).join(delimiter); })).join("\n"); }; dsv.formatRows = function(rows) { return rows.map(formatRow).join("\n"); }; function formatRow(row) { return row.map(formatValue).join(delimiter); } function formatValue(text) { return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text; } return dsv; }; d3.csv = d3.dsv(",", "text/csv"); d3.tsv = d3.dsv(" ", "text/tab-separated-values"); var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) { setTimeout(callback, 17); }; d3.timer = function() { d3_timer.apply(this, arguments); }; function d3_timer(callback, delay, then) { var n = arguments.length; if (n < 2) delay = 0; if (n < 3) then = Date.now(); var time = then + delay, timer = { c: callback, t: time, n: null }; if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer; d3_timer_queueTail = timer; if (!d3_timer_interval) { d3_timer_timeout = clearTimeout(d3_timer_timeout); d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } return timer; } function d3_timer_step() { var now = d3_timer_mark(), delay = d3_timer_sweep() - now; if (delay > 24) { if (isFinite(delay)) { clearTimeout(d3_timer_timeout); d3_timer_timeout = setTimeout(d3_timer_step, delay); } d3_timer_interval = 0; } else { d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } } d3.timer.flush = function() { d3_timer_mark(); d3_timer_sweep(); }; function d3_timer_mark() { var now = Date.now(), timer = d3_timer_queueHead; while (timer) { if (now >= timer.t && timer.c(now - timer.t)) timer.c = null; timer = timer.n; } return now; } function d3_timer_sweep() { var t0, t1 = d3_timer_queueHead, time = Infinity; while (t1) { if (t1.c) { if (t1.t < time) time = t1.t; t1 = (t0 = t1).n; } else { t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n; } } d3_timer_queueTail = t0; return time; } function d3_format_precision(x, p) { return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1); } d3.round = function(x, n) { return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x); }; var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix); d3.formatPrefix = function(value, precision) { var i = 0; if (value = +value) { if (value < 0) value *= -1; if (precision) value = d3.round(value, d3_format_precision(value, precision)); i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10); i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3)); } return d3_formatPrefixes[8 + i / 3]; }; function d3_formatPrefix(d, i) { var k = Math.pow(10, abs(8 - i) * 3); return { scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; }, symbol: d }; } function d3_locale_numberFormat(locale) { var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) { var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0; while (i > 0 && g > 0) { if (length + g + 1 > width) g = Math.max(1, width - length); t.push(value.substring(i -= g, i + g)); if ((length += g + 1) > width) break; g = locale_grouping[j = (j + 1) % locale_grouping.length]; } return t.reverse().join(locale_thousands); } : d3_identity; return function(specifier) { var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true; if (precision) precision = +precision.substring(1); if (zfill || fill === "0" && align === "=") { zfill = fill = "0"; align = "="; } switch (type) { case "n": comma = true; type = "g"; break; case "%": scale = 100; suffix = "%"; type = "f"; break; case "p": scale = 100; suffix = "%"; type = "r"; break; case "b": case "o": case "x": case "X": if (symbol === "#") prefix = "0" + type.toLowerCase(); case "c": exponent = false; case "d": integer = true; precision = 0; break; case "s": scale = -1; type = "r"; break; } if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1]; if (type == "r" && !precision) type = "g"; if (precision != null) { if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision)); } type = d3_format_types.get(type) || d3_format_typeDefault; var zcomma = zfill && comma; return function(value) { var fullSuffix = suffix; if (integer && value % 1) return ""; var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign; if (scale < 0) { var unit = d3.formatPrefix(value, precision); value = unit.scale(value); fullSuffix = unit.symbol + suffix; } else { value *= scale; } value = type(value, precision); var i = value.lastIndexOf("."), before, after; if (i < 0) { var j = exponent ? value.lastIndexOf("e") : -1; if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j); } else { before = value.substring(0, i); after = locale_decimal + value.substring(i + 1); } if (!zfill && comma) before = formatGroup(before, Infinity); var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : ""; if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity); negative += prefix; value = before + after; return (align === "" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix; }; }; } var d3_format_re = /(?:([^{])?([=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i; var d3_format_types = d3.map({ b: function(x) { return x.toString(2); }, c: function(x) { return String.fromCharCode(x); }, o: function(x) { return x.toString(8); }, x: function(x) { return x.toString(16); }, X: function(x) { return x.toString(16).toUpperCase(); }, g: function(x, p) { return x.toPrecision(p); }, e: function(x, p) { return x.toExponential(p); }, f: function(x, p) { return x.toFixed(p); }, r: function(x, p) { return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p)))); } }); function d3_format_typeDefault(x) { return x + ""; } var d3_time = d3.time = {}, d3_date = Date; function d3_date_utc() { this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]); } d3_date_utc.prototype = { getDate: function() { return this._.getUTCDate(); }, getDay: function() { return this._.getUTCDay(); }, getFullYear: function() { return this._.getUTCFullYear(); }, getHours: function() { return this._.getUTCHours(); }, getMilliseconds: function() { return this._.getUTCMilliseconds(); }, getMinutes: function() { return this._.getUTCMinutes(); }, getMonth: function() { return this._.getUTCMonth(); }, getSeconds: function() { return this._.getUTCSeconds(); }, getTime: function() { return this._.getTime(); }, getTimezoneOffset: function() { return 0; }, valueOf: function() { return this._.valueOf(); }, setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); }, setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); }, setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); }, setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); }, setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); }, setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); }, setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); }, setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); }, setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); } }; var d3_time_prototype = Date.prototype; function d3_time_interval(local, step, number) { function round(date) { var d0 = local(date), d1 = offset(d0, 1); return date - d0 < d1 - date ? d0 : d1; } function ceil(date) { step(date = local(new d3_date(date - 1)), 1); return date; } function offset(date, k) { step(date = new d3_date(+date), k); return date; } function range(t0, t1, dt) { var time = ceil(t0), times = []; if (dt > 1) { while (time < t1) { if (!(number(time) % dt)) times.push(new Date(+time)); step(time, 1); } } else { while (time < t1) times.push(new Date(+time)), step(time, 1); } return times; } function range_utc(t0, t1, dt) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = t0; return range(utc, t1, dt); } finally { d3_date = Date; } } local.floor = local; local.round = round; local.ceil = ceil; local.offset = offset; local.range = range; var utc = local.utc = d3_time_interval_utc(local); utc.floor = utc; utc.round = d3_time_interval_utc(round); utc.ceil = d3_time_interval_utc(ceil); utc.offset = d3_time_interval_utc(offset); utc.range = range_utc; return local; } function d3_time_interval_utc(method) { return function(date, k) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = date; return method(utc, k)._; } finally { d3_date = Date; } }; } d3_time.year = d3_time_interval(function(date) { date = d3_time.day(date); date.setMonth(0, 1); return date; }, function(date, offset) { date.setFullYear(date.getFullYear() + offset); }, function(date) { return date.getFullYear(); }); d3_time.years = d3_time.year.range; d3_time.years.utc = d3_time.year.utc.range; d3_time.day = d3_time_interval(function(date) { var day = new d3_date(2e3, 0); day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()); return day; }, function(date, offset) { date.setDate(date.getDate() + offset); }, function(date) { return date.getDate() - 1; }); d3_time.days = d3_time.day.range; d3_time.days.utc = d3_time.day.utc.range; d3_time.dayOfYear = function(date) { var year = d3_time.year(date); return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5); }; [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) { i = 7 - i; var interval = d3_time[day] = d3_time_interval(function(date) { (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7); return date; }, function(date, offset) { date.setDate(date.getDate() + Math.floor(offset) * 7); }, function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i); }); d3_time[day + "s"] = interval.range; d3_time[day + "s"].utc = interval.utc.range; d3_time[day + "OfYear"] = function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7); }; }); d3_time.week = d3_time.sunday; d3_time.weeks = d3_time.sunday.range; d3_time.weeks.utc = d3_time.sunday.utc.range; d3_time.weekOfYear = d3_time.sundayOfYear; function d3_locale_timeFormat(locale) { var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths; function d3_time_format(template) { var n = template.length; function format(date) { var string = [], i = -1, j = 0, c, p, f; while (++i < n) { if (template.charCodeAt(i) === 37) { string.push(template.slice(j, i)); if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i); if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p); string.push(c); j = i + 1; } } string.push(template.slice(j, i)); return string.join(""); } format.parse = function(string) { var d = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, i = d3_time_parse(d, template, string, 0); if (i != string.length) return null; if ("p" in d) d.H = d.H % 12 + d.p * 12; var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)(); if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) { if (!("w" in d)) d.w = "W" in d ? 1 : 0; date.setFullYear(d.y, 0, 1); date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7); } else date.setFullYear(d.y, d.m, d.d); date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L); return localZ ? date._ : date; }; format.toString = function() { return template; }; return format; } function d3_time_parse(date, template, string, j) { var c, p, t, i = 0, n = template.length, m = string.length; while (i < n) { if (j >= m) return -1; c = template.charCodeAt(i++); if (c === 37) { t = template.charAt(i++); p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t]; if (!p || (j = p(date, string, j)) < 0) return -1; } else if (c != string.charCodeAt(j++)) { return -1; } } return j; } d3_time_format.utc = function(template) { var local = d3_time_format(template); function format(date) { try { d3_date = d3_date_utc; var utc = new d3_date(); utc._ = date; return local(utc); } finally { d3_date = Date; } } format.parse = function(string) { try { d3_date = d3_date_utc; var date = local.parse(string); return date && date._; } finally { d3_date = Date; } }; format.toString = local.toString; return format; }; d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti; var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths); locale_periods.forEach(function(p, i) { d3_time_periodLookup.set(p.toLowerCase(), i); }); var d3_time_formats = { a: function(d) { return locale_shortDays[d.getDay()]; }, A: function(d) { return locale_days[d.getDay()]; }, b: function(d) { return locale_shortMonths[d.getMonth()]; }, B: function(d) { return locale_months[d.getMonth()]; }, c: d3_time_format(locale_dateTime), d: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, e: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, H: function(d, p) { return d3_time_formatPad(d.getHours(), p, 2); }, I: function(d, p) { return d3_time_formatPad(d.getHours() % 12 || 12, p, 2); }, j: function(d, p) { return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3); }, L: function(d, p) { return d3_time_formatPad(d.getMilliseconds(), p, 3); }, m: function(d, p) { return d3_time_formatPad(d.getMonth() + 1, p, 2); }, M: function(d, p) { return d3_time_formatPad(d.getMinutes(), p, 2); }, p: function(d) { return locale_periods[+(d.getHours() >= 12)]; }, S: function(d, p) { return d3_time_formatPad(d.getSeconds(), p, 2); }, U: function(d, p) { return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2); }, w: function(d) { return d.getDay(); }, W: function(d, p) { return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2); }, x: d3_time_format(locale_date), X: d3_time_format(locale_time), y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 100, p, 2); }, Y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 1e4, p, 4); }, Z: d3_time_zone, "%": function() { return "%"; } }; var d3_time_parsers = { a: d3_time_parseWeekdayAbbrev, A: d3_time_parseWeekday, b: d3_time_parseMonthAbbrev, B: d3_time_parseMonth, c: d3_time_parseLocaleFull, d: d3_time_parseDay, e: d3_time_parseDay, H: d3_time_parseHour24, I: d3_time_parseHour24, j: d3_time_parseDayOfYear, L: d3_time_parseMilliseconds, m: d3_time_parseMonthNumber, M: d3_time_parseMinutes, p: d3_time_parseAmPm, S: d3_time_parseSeconds, U: d3_time_parseWeekNumberSunday, w: d3_time_parseWeekdayNumber, W: d3_time_parseWeekNumberMonday, x: d3_time_parseLocaleDate, X: d3_time_parseLocaleTime, y: d3_time_parseYear, Y: d3_time_parseFullYear, Z: d3_time_parseZone, "%": d3_time_parseLiteralPercent }; function d3_time_parseWeekdayAbbrev(date, string, i) { d3_time_dayAbbrevRe.lastIndex = 0; var n = d3_time_dayAbbrevRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseWeekday(date, string, i) { d3_time_dayRe.lastIndex = 0; var n = d3_time_dayRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonthAbbrev(date, string, i) { d3_time_monthAbbrevRe.lastIndex = 0; var n = d3_time_monthAbbrevRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonth(date, string, i) { d3_time_monthRe.lastIndex = 0; var n = d3_time_monthRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseLocaleFull(date, string, i) { return d3_time_parse(date, d3_time_formats.c.toString(), string, i); } function d3_time_parseLocaleDate(date, string, i) { return d3_time_parse(date, d3_time_formats.x.toString(), string, i); } function d3_time_parseLocaleTime(date, string, i) { return d3_time_parse(date, d3_time_formats.X.toString(), string, i); } function d3_time_parseAmPm(date, string, i) { var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase()); return n == null ? -1 : (date.p = n, i); } return d3_time_format; } var d3_time_formatPads = { "-": "", _: " ", "0": "0" }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/; function d3_time_formatPad(value, fill, width) { var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length; return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string); } function d3_time_formatRe(names) { return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i"); } function d3_time_formatLookup(names) { var map = new d3_Map(), i = -1, n = names.length; while (++i < n) map.set(names[i].toLowerCase(), i); return map; } function d3_time_parseWeekdayNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 1)); return n ? (date.w = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberSunday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.U = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberMonday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.W = +n[0], i + n[0].length) : -1; } function d3_time_parseFullYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 4)); return n ? (date.y = +n[0], i + n[0].length) : -1; } function d3_time_parseYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1; } function d3_time_parseZone(date, string, i) { return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1; } function d3_time_expandYear(d) { return d + (d > 68 ? 1900 : 2e3); } function d3_time_parseMonthNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.m = n[0] - 1, i + n[0].length) : -1; } function d3_time_parseDay(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.d = +n[0], i + n[0].length) : -1; } function d3_time_parseDayOfYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.j = +n[0], i + n[0].length) : -1; } function d3_time_parseHour24(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.H = +n[0], i + n[0].length) : -1; } function d3_time_parseMinutes(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.M = +n[0], i + n[0].length) : -1; } function d3_time_parseSeconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.S = +n[0], i + n[0].length) : -1; } function d3_time_parseMilliseconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.L = +n[0], i + n[0].length) : -1; } function d3_time_zone(d) { var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60; return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2); } function d3_time_parseLiteralPercent(date, string, i) { d3_time_percentRe.lastIndex = 0; var n = d3_time_percentRe.exec(string.slice(i, i + 1)); return n ? i + n[0].length : -1; } function d3_time_formatMulti(formats) { var n = formats.length, i = -1; while (++i < n) formats[i][0] = this(formats[i][0]); return function(date) { var i = 0, f = formats[i]; while (!f[1](date)) f = formats[++i]; return f[0](date); }; } d3.locale = function(locale) { return { numberFormat: d3_locale_numberFormat(locale), timeFormat: d3_locale_timeFormat(locale) }; }; var d3_locale_enUS = d3.locale({ decimal: ".", thousands: ",", grouping: [ 3 ], currency: [ "$", "" ], dateTime: "%a %b %e %X %Y", date: "%m/%d/%Y", time: "%H:%M:%S", periods: [ "AM", "PM" ], days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ] }); d3.format = d3_locale_enUS.numberFormat; d3.geo = {}; function d3_adder() {} d3_adder.prototype = { s: 0, t: 0, add: function(y) { d3_adderSum(y, this.t, d3_adderTemp); d3_adderSum(d3_adderTemp.s, this.s, this); if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t; }, reset: function() { this.s = this.t = 0; }, valueOf: function() { return this.s; } }; var d3_adderTemp = new d3_adder(); function d3_adderSum(a, b, o) { var x = o.s = a + b, bv = x - a, av = x - bv; o.t = a - av + (b - bv); } d3.geo.stream = function(object, listener) { if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) { d3_geo_streamObjectType[object.type](object, listener); } else { d3_geo_streamGeometry(object, listener); } }; function d3_geo_streamGeometry(geometry, listener) { if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) { d3_geo_streamGeometryType[geometry.type](geometry, listener); } } var d3_geo_streamObjectType = { Feature: function(feature, listener) { d3_geo_streamGeometry(feature.geometry, listener); }, FeatureCollection: function(object, listener) { var features = object.features, i = -1, n = features.length; while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener); } }; var d3_geo_streamGeometryType = { Sphere: function(object, listener) { listener.sphere(); }, Point: function(object, listener) { object = object.coordinates; listener.point(object[0], object[1], object[2]); }, MultiPoint: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]); }, LineString: function(object, listener) { d3_geo_streamLine(object.coordinates, listener, 0); }, MultiLineString: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0); }, Polygon: function(object, listener) { d3_geo_streamPolygon(object.coordinates, listener); }, MultiPolygon: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) d3_geo_streamPolygon(coordinates[i], listener); }, GeometryCollection: function(object, listener) { var geometries = object.geometries, i = -1, n = geometries.length; while (++i < n) d3_geo_streamGeometry(geometries[i], listener); } }; function d3_geo_streamLine(coordinates, listener, closed) { var i = -1, n = coordinates.length - closed, coordinate; listener.lineStart(); while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]); listener.lineEnd(); } function d3_geo_streamPolygon(coordinates, listener) { var i = -1, n = coordinates.length; listener.polygonStart(); while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1); listener.polygonEnd(); } d3.geo.area = function(object) { d3_geo_areaSum = 0; d3.geo.stream(object, d3_geo_area); return d3_geo_areaSum; }; var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder(); var d3_geo_area = { sphere: function() { d3_geo_areaSum += 4 * π; }, point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_areaRingSum.reset(); d3_geo_area.lineStart = d3_geo_areaRingStart; }, polygonEnd: function() { var area = 2 * d3_geo_areaRingSum; d3_geo_areaSum += area < 0 ? 4 * π + area : area; d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop; } }; function d3_geo_areaRingStart() { var λ00, φ00, λ0, cosφ0, sinφ0; d3_geo_area.point = function(λ, φ) { d3_geo_area.point = nextPoint; λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ); }; function nextPoint(λ, φ) { λ *= d3_radians; φ = φ * d3_radians / 2 + π / 4; var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ); d3_geo_areaRingSum.add(Math.atan2(v, u)); λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ; } d3_geo_area.lineEnd = function() { nextPoint(λ00, φ00); }; } function d3_geo_cartesian(spherical) { var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ); return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ]; } function d3_geo_cartesianDot(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; } function d3_geo_cartesianCross(a, b) { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; } function d3_geo_cartesianAdd(a, b) { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; } function d3_geo_cartesianScale(vector, k) { return [ vector[0] * k, vector[1] * k, vector[2] * k ]; } function d3_geo_cartesianNormalize(d) { var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]); d[0] /= l; d[1] /= l; d[2] /= l; } function d3_geo_spherical(cartesian) { return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ]; } function d3_geo_sphericalEqual(a, b) { return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε; } d3.geo.bounds = function() { var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range; var bound = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { bound.point = ringPoint; bound.lineStart = ringStart; bound.lineEnd = ringEnd; dλSum = 0; d3_geo_area.polygonStart(); }, polygonEnd: function() { d3_geo_area.polygonEnd(); bound.point = point; bound.lineStart = lineStart; bound.lineEnd = lineEnd; if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90; range[0] = λ0, range[1] = λ1; } }; function point(λ, φ) { ranges.push(range = [ λ0 = λ, λ1 = λ ]); if (φ < φ0) φ0 = φ; if (φ > φ1) φ1 = φ; } function linePoint(λ, φ) { var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]); if (p0) { var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal); d3_geo_cartesianNormalize(inflection); inflection = d3_geo_spherical(inflection); var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180; if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) { var φi = inflection[1] * d3_degrees; if (φi > φ1) φ1 = φi; } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) { var φi = -inflection[1] * d3_degrees; if (φi < φ0) φ0 = φi; } else { if (φ < φ0) φ0 = φ; if (φ > φ1) φ1 = φ; } if (antimeridian) { if (λ < λ_) { if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ; } } else { if (λ1 >= λ0) { if (λ < λ0) λ0 = λ; if (λ > λ1) λ1 = λ; } else { if (λ > λ_) { if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ; } } } } else { point(λ, φ); } p0 = p, λ_ = λ; } function lineStart() { bound.point = linePoint; } function lineEnd() { range[0] = λ0, range[1] = λ1; bound.point = point; p0 = null; } function ringPoint(λ, φ) { if (p0) { var dλ = λ - λ_; dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ; } else λ__ = λ, φ__ = φ; d3_geo_area.point(λ, φ); linePoint(λ, φ); } function ringStart() { d3_geo_area.lineStart(); } function ringEnd() { ringPoint(λ__, φ__); d3_geo_area.lineEnd(); if (abs(dλSum) > ε) λ0 = -(λ1 = 180); range[0] = λ0, range[1] = λ1; p0 = null; } function angle(λ0, λ1) { return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1; } function compareRanges(a, b) { return a[0] - b[0]; } function withinRange(x, range) { return range[0] true * * _.inRange(4, 2); * // => false * * _.inRange(2, 2); * // => false * * _.inRange(1.2, 2); * // => true * * _.inRange(5.2, 4); * // => false * * _.inRange(-3, -2, -6); * // => true */ function inRange(number, start, end) { start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } number = toNumber(number); return baseInRange(number, start, end); } /** * Produces a random number between the inclusive `lower` and `upper` bounds. * If only one argument is provided a number between `0` and the given number * is returned. If `floating` is `true`, or either `lower` or `upper` are * floats, a floating-point number is returned instead of an integer. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @memberOf _ * @since 0.7.0 * @category Number * @param {number} [lower=0] The lower bound. * @param {number} [upper=1] The upper bound. * @param {boolean} [floating] Specify returning a floating-point number. * @returns {number} Returns the random number. * @example * * _.random(0, 5); * // => an integer between 0 and 5 * * _.random(5); * // => also an integer between 0 and 5 * * _.random(5, true); * // => a floating-point number between 0 and 5 * * _.random(1.2, 5.2); * // => a floating-point number between 1.2 and 5.2 */ function random(lower, upper, floating) { if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) { upper = floating = undefined; } if (floating === undefined) { if (typeof upper == 'boolean') { floating = upper; upper = undefined; } else if (typeof lower == 'boolean') { floating = lower; lower = undefined; } } if (lower === undefined && upper === undefined) { lower = 0; upper = 1; } else { lower = toFinite(lower); if (upper === undefined) { upper = lower; lower = 0; } else { upper = toFinite(upper); } } if (lower > upper) { var temp = lower; lower = upper; upper = temp; } if (floating || lower % 1 || upper % 1) { var rand = nativeRandom(); return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper); } return baseRandom(lower, upper); } /*------------------------------------------------------------------------*/ /** * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the camel cased string. * @example * * _.camelCase('Foo Bar'); * // => 'fooBar' * * _.camelCase('--foo-bar--'); * // => 'fooBar' * * _.camelCase('__FOO_BAR__'); * // => 'fooBar' */ var camelCase = createCompounder(function(result, word, index) { word = word.toLowerCase(); return result + (index ? capitalize(word) : word); }); /** * Converts the first character of `string` to upper case and the remaining * to lower case. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to capitalize. * @returns {string} Returns the capitalized string. * @example * * _.capitalize('FRED'); * // => 'Fred' */ function capitalize(string) { return upperFirst(toString(string).toLowerCase()); } /** * Deburrs `string` by converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to deburr. * @returns {string} Returns the deburred string. * @example * * _.deburr('déjà vu'); * // => 'deja vu' */ function deburr(string) { string = toString(string); return string && string.replace(reLatin, deburrLetter).replace(reComboMark, ''); } /** * Checks if `string` ends with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=string.length] The position to search up to. * @returns {boolean} Returns `true` if `string` ends with `target`, * else `false`. * @example * * _.endsWith('abc', 'c'); * // => true * * _.endsWith('abc', 'b'); * // => false * * _.endsWith('abc', 'b', 2); * // => true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position >= 0 && string.slice(position, end) == target; } /** * Converts the characters "&", "", '"', and "'" in `string` to their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the ">" character is escaped for symmetry, characters like * ">" and "/" don't need escaping in HTML and have no special meaning * unless they're part of a tag or unquoted attribute value. See * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under "semi-related fun fact") for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape('fred, barney, & pebbles'); * // => 'fred, barney, &amp; pebbles' */ function escape(string) { string = toString(string); return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+", * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp('[lodash](https://lodash.com/)'); * // => '\[lodash\]\(https://lodash\.com/\)' */ function escapeRegExp(string) { string = toString(string); return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string; } /** * Converts `string` to * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase('Foo Bar'); * // => 'foo-bar' * * _.kebabCase('fooBar'); * // => 'foo-bar' * * _.kebabCase('__FOO_BAR__'); * // => 'foo-bar' */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? '-' : '') + word.toLowerCase(); }); /** * Converts `string`, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase('--Foo-Bar--'); * // => 'foo bar' * * _.lowerCase('fooBar'); * // => 'foo bar' * * _.lowerCase('__FOO_BAR__'); * // => 'foo bar' */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toLowerCase(); }); /** * Converts the first character of `string` to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst('Fred'); * // => 'fred' * * _.lowerFirst('FRED'); * // => 'fRED' */ var lowerFirst = createCaseFirst('toLowerCase'); /** * Pads `string` on the left and right sides if it's shorter than `length`. * Padding characters are truncated if they can't be evenly divided by `length`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad('abc', 8); * // => ' abc ' * * _.pad('abc', 8, '_-'); * // => '_-abc_-_' * * _.pad('abc', 3); * // => 'abc' */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength >= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Pads `string` on the right side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd('abc', 6); * // => 'abc ' * * _.padEnd('abc', 6, '_-'); * // => 'abc_-_' * * _.padEnd('abc', 3); * // => 'abc' */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Pads `string` on the left side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart('abc', 6); * // => ' abc' * * _.padStart('abc', 6, '_-'); * // => '_-_abc' * * _.padStart('abc', 3); * // => 'abc' */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Converts `string` to an integer of the specified radix. If `radix` is * `undefined` or `0`, a `radix` of `10` is used unless `value` is a * hexadecimal, in which case a `radix` of `16` is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpret `value` by. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {number} Returns the converted integer. * @example * * _.parseInt('08'); * // => 8 * * _.map(['6', '08', '10'], _.parseInt); * // => [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0); } /** * Repeats the given string `n` times. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the repeated string. * @example * * _.repeat('*', 3); * // => '***' * * _.repeat('abc', 2); * // => 'abcabc' * * _.repeat('abc', 0); * // => '' */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches for `pattern` in `string` with `replacement`. * * **Note:** This method is based on * [`String#replace`](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace('Hi Fred', 'Fred', 'Barney'); * // => 'Hi Barney' */ function replace() { var args = arguments, string = toString(args[0]); return args.length < 3 ? string : string.replace(args[1], args[2]); } /** * Converts `string` to * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase('Foo Bar'); * // => 'foo_bar' * * _.snakeCase('fooBar'); * // => 'foo_bar' * * _.snakeCase('--FOO-BAR--'); * // => 'foo_bar' */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? '_' : '') + word.toLowerCase(); }); /** * Splits `string` by `separator`. * * **Note:** This method is based on * [`String#split`](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split('a-b-c', '-', 2); * // => ['a', 'b'] */ function split(string, separator, limit) { if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0; if (!limit) { return []; } string = toString(string); if (string && ( typeof separator == 'string' || (separator != null && !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator && hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Converts `string` to * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase('--foo-bar--'); * // => 'Foo Bar' * * _.startCase('fooBar'); * // => 'Foo Bar' * * _.startCase('__FOO_BAR__'); * // => 'FOO BAR' */ var startCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + upperFirst(word); }); /** * Checks if `string` starts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returns `true` if `string` starts with `target`, * else `false`. * @example * * _.startsWith('abc', 'a'); * // => true * * _.startsWith('abc', 'b'); * // => false * * _.startsWith('abc', 'b', 1); * // => true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in "interpolate" delimiters, HTML-escape interpolated data properties in * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over `_.templateSettings` values. * * **Note:** In the development build `_.template` utilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash's custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML "escape" delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The "evaluate" delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The "interpolate" delimiter. * @param {string} [options.sourceURL='lodash.templateSources[n]'] * The sourceURL of the compiled template. * @param {string} [options.variable='obj'] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Function} Returns the compiled template function. * @example * * // Use the "interpolate" delimiter to create a compiled template. * var compiled = _.template('hello !'); * compiled({ 'user': 'fred' }); * // => 'hello fred!' * * // Use the HTML "escape" delimiter to escape data property values. * var compiled = _.template(''); * compiled({ 'value': '' }); * // => '&lt;script&gt;' * * // Use the "evaluate" delimiter to execute JavaScript and generate HTML. * var compiled = _.template(''); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the internal `print` function in "evaluate" delimiters. * var compiled = _.template('!'); * compiled({ 'user': 'barney' }); * // => 'hello barney!' * * // Use the ES template literal delimiter as an "interpolate" delimiter. * // Disable support by replacing the "interpolate" delimiter. * var compiled = _.template('hello ${ user }!'); * compiled({ 'user': 'pebbles' }); * // => 'hello pebbles!' * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(''); * compiled({ 'value': 'ignored' }); * // => '' * * // Use the `imports` option to import `jQuery` as `jq`. * var text = ''; * var compiled = _.template(text, { 'imports': { 'jq': jQuery } }); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the `sourceURL` option to specify a custom sourceURL for the template. * var compiled = _.template('hello !', { 'sourceURL': '/basic/greeting.jst' }); * compiled(data); * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector. * * // Use the `variable` option to ensure a with-statement isn't used in the compiled template. * var compiled = _.template('hi !', { 'variable': 'data' }); * compiled.source; * // => function(data) { * // var __t, __p = ''; * // __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!'; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template('hello !'); * compiled({ 'user': 'mustache' }); * // => 'hello mustache!' * * // Use the `source` property to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\ * var JST = {\ * "main": ' + _.template(mainText).source + '\ * };\ * '); */ function template(string, options, guard) { // Based on John Resig's `tmpl` implementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova's doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard && isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '"; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$' , 'g'); // Use a sourceURL for easier debugging. var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']') ) + '\n'; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += "' +\n__e(" + escapeValue + ") +\n'"; } if (evaluateValue) { isEvaluating = true; source += "';\n" + evaluateValue + ";\n__p += '"; } if (interpolateValue) { source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"; } index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in // order to produce the correct `offset` value. return match; }); source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = 'with (obj) {\n' + source + '\n}\n'; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source) .replace(reEmptyStringMiddle, '$1') .replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body. source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n' ) + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '' ) + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n' ) + source + 'return __p\n}'; var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); // Provide the compiled function's source by its `toString` method or // the `source` property as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Converts `string`, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower('--Foo-Bar--'); * // => '--foo-bar--' * * _.toLower('fooBar'); * // => 'foobar' * * _.toLower('__FOO_BAR__'); * // => '__foo_bar__' */ function toLower(value) { return toString(value).toLowerCase(); } /** * Converts `string`, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper('--foo-bar--'); * // => '--FOO-BAR--' * * _.toUpper('fooBar'); * // => 'FOOBAR' * * _.toUpper('__foo_bar__'); * // => '__FOO_BAR__' */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trim(' abc '); * // => 'abc' * * _.trim('-_-abc-_-', '_-'); * // => 'abc' * * _.map([' foo ', ' bar '], _.trim); * // => ['foo', 'bar'] */ function trim(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrim, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(''); } /** * Removes trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(' abc '); * // => ' abc' * * _.trimEnd('-_-abc-_-', '_-'); * // => '-_-abc' */ function trimEnd(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimEnd, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(''); } /** * Removes leading whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(' abc '); * // => 'abc ' * * _.trimStart('-_-abc-_-', '_-'); * // => 'abc-_-' */ function trimStart(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimStart, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(''); } /** * Truncates `string` if it's longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to "...". * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission='...'] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate('hi-diddly-ho there, neighborino'); * // => 'hi-diddly-ho there, neighbo...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': ' ' * }); * // => 'hi-diddly-ho there,...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': /,? +/ * }); * // => 'hi-diddly-ho there...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'omission': ' [...]' * }); * // => 'hi-diddly-ho there, neig [...]' */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = 'separator' in options ? options.separator : separator; length = 'length' in options ? toInteger(options.length) : length; omission = 'omission' in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length >= strLength) { return string; } var end = length - stringSize(omission); if (end < 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g'); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index > -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of `_.escape`; this method converts the HTML entities * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=''] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape('fred, barney, &amp; pebbles'); * // => 'fred, barney, & pebbles' */ function unescape(string) { string = toString(string); return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Converts `string`, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase('--foo-bar'); * // => 'FOO BAR' * * _.upperCase('fooBar'); * // => 'FOO BAR' * * _.upperCase('__foo_bar__'); * // => 'FOO BAR' */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toUpperCase(); }); /** * Converts the first character of `string` to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst('fred'); * // => 'Fred' * * _.upperFirst('FRED'); * // => 'FRED' */ var upperFirst = createCaseFirst('toUpperCase'); /** * Splits `string` into an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Array} Returns the words of `string`. * @example * * _.words('fred, barney, & pebbles'); * // => ['fred', 'barney', 'pebbles'] * * _.words('fred, barney, & pebbles', /[^, ]+/g); * // => ['fred', 'barney', '&', 'pebbles'] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invoke `func` with. * @returns {*} Returns the `func` result or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, '>_>'); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn't set the "length" property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returns `object`. * @example * * var view = { * 'label': 'docs', * 'click': function() { * console.log('clicked ' + this.label); * } * }; * * _.bindAll(view, ['click']); * jQuery(element).on('click', view.click); * // => Logs 'clicked docs' when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ 'a': 1 }), _.constant('matches A')], * [_.conforms({ 'b': _.isNumber }), _.constant('matches B')], * [_.stubTrue, _.constant('no match')] * ]); * * func({ 'a': 1, 'b': 2 }); * // => 'matches A' * * func({ 'a': 0, 'b': 1 }); * // => 'matches B' * * func({ 'a': '1', 'b': '2' }); * // => 'no match' */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != 'function') { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index < length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `_.conformsTo` with * `source` partially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 2, 'b': 1 }, * { 'a': 1, 'b': 2 } * ]; * * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } })); * // => [{ 'a': 1, 'b': 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returns `value`. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ 'a': 1 })); * * console.log(objects); * // => [{ 'a': 1 }, { 'a': 1 }] * * console.log(objects[0] === objects[1]); * // => true */ function constant(value) { return function() { return value; }; } /** * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // => 1 * * _.defaultTo(undefined, 10); * // => 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with the `this` binding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // => 9 */ var flow = createFlow(); /** * This method is like `_.flow` except that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // => 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returns `value`. * @example * * var object = { 'a': 1 }; * * console.log(_.identity(object) === object); * // => true */ function identity(value) { return value; } /** * Creates a function that invokes `func` with the arguments of the created * function. If `func` is a property name, the created function returns the * property value for a given element. If `func` is an array or object, the * created function returns `true` for elements that contain the equivalent * source properties, otherwise it returns `false`. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { 'user': 'barney', 'age': 36, 'active': true }, * { 'user': 'fred', 'age': 40, 'active': false } * ]; * * // The `_.matches` iteratee shorthand. * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true })); * // => [{ 'user': 'barney', 'age': 36, 'active': true }] * * // The `_.matchesProperty` iteratee shorthand. * _.filter(users, _.iteratee(['user', 'fred'])); * // => [{ 'user': 'fred', 'age': 40 }] * * // The `_.property` iteratee shorthand. * _.map(users, _.iteratee('user')); * // => ['barney', 'fred'] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter(['abc', 'def'], /ef/); * // => ['def'] */ function iteratee(func) { return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object and `source`, returning `true` if the given object has equivalent * property values, else `false`. * * **Note:** The created function is equivalent to `_.isMatch` with `source` * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `_.isEqual` * for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.filter(objects, _.matches({ 'a': 4, 'c': 6 })); * // => [{ 'a': 4, 'b': 5, 'c': 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value at `path` of a given object to `srcValue`, returning `true` if the * object value is equivalent, else `false`. * * **Note:** Partial comparisons will match empty array and empty object * `srcValue` values against any array or object value, respectively. See * `_.isEqual` for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.find(objects, _.matchesProperty('a', 4)); * // => { 'a': 4, 'b': 5, 'c': 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method at `path` of a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { 'a': { 'b': _.constant(2) } }, * { 'a': { 'b': _.constant(1) } } * ]; * * _.map(objects, _.method('a.b')); * // => [2, 1] * * _.map(objects, _.method(['a', 'b'])); * // => [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of `_.method`; this method creates a function that invokes * the method at a given path of `object`. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.methodOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.methodOf(object)); * // => [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. If `object` is a function, then methods * are added to its prototype as well. * * **Note:** Use `_.runInContext` to create a pristine `lodash` function to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returns `object`. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ 'vowels': vowels }); * _.vowels('fred'); * // => ['e'] * * _('fred').vowels().value(); * // => ['e'] * * _.mixin({ 'vowels': vowels }, { 'chain': false }); * _('fred').vowels(); * // => ['e'] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null && !(isObject(source) && (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ 'func': func, 'args': arguments, 'thisArg': object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the `_` variable to its previous value and returns a reference to * the `lodash` function. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns the `lodash` function. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returns `undefined`. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // => [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at index `n`. If `n` is negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func('a', 'b', 'c', 'd'); * // => 'b' * * var func = _.nthArg(-2); * func('a', 'b', 'c', 'd'); * // => 'c' */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokes `iteratees` with the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // => [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => false * * func(NaN); * // => false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => true * * func(NaN); * // => false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value at `path` of a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { 'a': { 'b': 2 } }, * { 'a': { 'b': 1 } } * ]; * * _.map(objects, _.property('a.b')); * // => [2, 1] * * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b'); * // => [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of `_.property`; this method creates a function that returns * the value at a given path of `object`. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.propertyOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.propertyOf(object)); * // => [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from * `start` up to, but not including, `end`. A step of `-1` is used if a negative * `start` is specified without an `end` or `step`. If `end` is not specified, * it's set to `start` with `start` then set to `0`. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // => [0, 1, 2, 3] * * _.range(-4); * // => [0, -1, -2, -3] * * _.range(1, 5); * // => [1, 2, 3, 4] * * _.range(0, 20, 5); * // => [0, 5, 10, 15] * * _.range(0, -4, -1); * // => [0, -1, -2, -3] * * _.range(1, 4, 0); * // => [1, 1, 1] * * _.range(0); * // => [] */ var range = createRange(); /** * This method is like `_.range` except that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // => [3, 2, 1, 0] * * _.rangeRight(-4); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // => [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // => [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // => [1, 1, 1] * * _.rangeRight(0); * // => [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // => [[], []] * * console.log(arrays[0] === arrays[1]); * // => false */ function stubArray() { return []; } /** * This method returns `false`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `false`. * @example * * _.times(2, _.stubFalse); * // => [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // => [{}, {}] * * console.log(objects[0] === objects[1]); * // => false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // => ['', ''] */ function stubString() { return ''; } /** * This method returns `true`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `true`. * @example * * _.times(2, _.stubTrue); * // => [true, true] */ function stubTrue() { return true; } /** * Invokes the iteratee `n` times, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invoke `iteratee`. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // => ['0', '1', '2'] * * _.times(4, _.constant(0)); * // => [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n < 1 || n > MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index < n) { iteratee(index); } return result; } /** * Converts `value` to a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath('a.b.c'); * // => ['a', 'b', 'c'] * * _.toPath('a[0].b.c'); * // => ['a', '0', 'b', 'c'] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. If `prefix` is given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=''] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId('contact_'); * // => 'contact_104' * * _.uniqueId(); * // => '105' */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // => 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computes `number` rounded up to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // => 5 * * _.ceil(6.004, 2); * // => 6.01 * * _.ceil(6040, -2); * // => 6100 */ var ceil = createRound('ceil'); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // => 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computes `number` rounded down to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // => 4 * * _.floor(0.046, 2); * // => 0.04 * * _.floor(4060, -2); * // => 4000 */ var floor = createRound('floor'); /** * Computes the maximum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // => 8 * * _.max([]); * // => undefined */ function max(array) { return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like `_.max` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // => { 'n': 2 } * * // The `_.property` iteratee shorthand. * _.maxBy(objects, 'n'); * // => { 'n': 2 } */ function maxBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values in `array`. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // => 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like `_.mean` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // => 5 * * // The `_.property` iteratee shorthand. * _.meanBy(objects, 'n'); * // => 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // => 2 * * _.min([]); * // => undefined */ function min(array) { return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like `_.min` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // => { 'n': 1 } * * // The `_.property` iteratee shorthand. * _.minBy(objects, 'n'); * // => { 'n': 1 } */ function minBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // => 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computes `number` rounded to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // => 4 * * _.round(4.006, 2); * // => 4.01 * * _.round(4060, -2); * // => 4100 */ var round = createRound('round'); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // => 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values in `array`. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // => 20 */ function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; } /** * This method is like `_.sum` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // => 20 * * // The `_.property` iteratee shorthand. * _.sumBy(objects, 'n'); * // => 20 */ function sumBy(array, iteratee) { return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { 'chain': false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) { lodash[methodName].placeholder = lodash; }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants. arrayEach(['drop', 'take'], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ && !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') }); } return result; }; LazyWrapper.prototype[methodName + 'Right'] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // Add `LazyWrapper` methods that accept an `iteratee` value. arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // Add `LazyWrapper` methods for `_.head` and `_.last`. arrayEach(['head', 'last'], function(methodName, index) { var takeName = 'take' + (index ? 'Right' : ''); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`. arrayEach(['initial', 'tail'], function(methodName, index) { var dropName = 'drop' + (index ? '' : 'Right'); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == 'function') { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ && (start > 0 || end < 0)) { return new LazyWrapper(result); } if (start < 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end < 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // Add `LazyWrapper` methods to `lodash.prototype`. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker && chainAll) ? result[0] : result; }; if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) { // Avoid lazy use if the iteratee has a "length" value other than `1`. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid; if (!retUnwrapped && useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped && onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // Add `Array` methods to `lodash.prototype`. arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped && !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + ''), names = realNames[key] || (realNames[key] = []); names.push({ 'name': methodName, 'func': lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }]; // Add methods to `LazyWrapper`. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use `_.noConflict` to remove Lodash from the global object. root._ = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the "underscore" module. !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return _; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } // Check for `exports` after `define` in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = _; // Export for CommonJS support. freeExports._ = _; } else { // Export to the global object. root._ = _; } }.call(this)); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module))) /***/ }), /* 5 */ /***/ (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Prediction probabilities'; _classCallCheck(this, PredictProba); var width = parseInt(svg.style('width')); this.names = class_names; this.names.push('Other'); if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === '' ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars * (bar_height + space_between_bars) + bar_yshift; svg.style('height', this.svg_height + 'px'); var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) * i + bar_yshift; }; var bar = svg.append("g"); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == 'Other' && this.names.length > 20) { color = '#5F9EA0'; } var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", x_scale(data[i])).style("fill", color); bar.append("rect").attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", bar_width - 1).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); text = bar.append("text"); text.attr("x", bar_x + x_scale(data[i]) + 5).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif").text(data[i].toFixed(2)); text = bar.append("text"); text.attr("x", bar_x - 10).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(names[i]); while (text.node().getBBox()['width'] + 1 > class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + '...'); if (cur_text === '') { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length 4 && arguments[4] !== undefined ? arguments[4] : 'Predicted value'; var log_coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style('width')); this.color = _d2.default.scale.category10(); this.color('predicted_value'); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 * num_digits; var corner_padding = 5.5 * num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width * 2 - corner_padding * 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === '' ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = bar_yshift; var bar = svg.append("g"); //filled in bar representing predicted value in range var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(width_proportion)).style("fill", this.color); //empty box representing range bar.append("rect").attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(1)).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); //text for min value text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text("(min)"); //text for predicted value // console.log('bar height: ' + bar_height) text = bar.append("text"); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr("x", bar_x + x_scale(width_proportion)).attr("y", bar_y + bar_height + v_adjust_predicted_value_text).attr("fill", "black").attr("text-anchor", "middle").style("font", "14px tahoma, sans-serif"); //text for max value text = bar.append("text"); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif"); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif").text("(max)"); //readjust svg size // let svg_width = width + 1 * h_adjust; // svg.style('width', svg_width + 'px'); this.svg_height = n_bars * bar_height + bar_yshift + 2 * text.node().getBBox().height + 10; svg.style('height', this.svg_height + 'px'); if (log_coords) { console.log("svg width: " + svg_width); console.log("svg height: " + this.svg_height); console.log("bar_y: " + bar_y); console.log("bar_x: " + bar_x); console.log("Min value: " + min_value); console.log("Max value: " + max_value); console.log("Pred value: " + predicted_value); } }; exports.default = PredictedValue; /***/ }), /* 8 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {"use strict"; __webpack_require__(9); __webpack_require__(335); __webpack_require__(336); if (global._babelPolyfill) { throw new Error("only one instance of babel-polyfill is allowed"); } global._babelPolyfill = true; var DEFINE_PROPERTY = "defineProperty"; function define(O, key, value) { O[key] || Object[DEFINE_PROPERTY](O, key, { writable: true, configurable: true, value: value }); } define(String.prototype, "padLeft", "".padStart); define(String.prototype, "padRight", "".padEnd); "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) { [][key] && define(Array, key, Function.call.bind([][key])); }); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(10); __webpack_require__(59); __webpack_require__(60); __webpack_require__(61); __webpack_require__(62); __webpack_require__(64); __webpack_require__(67); __webpack_require__(68); __webpack_require__(69); __webpack_require__(70); __webpack_require__(71); __webpack_require__(72); __webpack_require__(73); __webpack_require__(74); __webpack_require__(75); __webpack_require__(77); __webpack_require__(79); __webpack_require__(81); __webpack_require__(83); __webpack_require__(86); __webpack_require__(87); __webpack_require__(88); __webpack_require__(92); __webpack_require__(94); __webpack_require__(96); __webpack_require__(99); __webpack_require__(100); __webpack_require__(101); __webpack_require__(102); __webpack_require__(104); __webpack_require__(105); __webpack_require__(106); __webpack_require__(107); __webpack_require__(108); __webpack_require__(109); __webpack_require__(110); __webpack_require__(112); __webpack_require__(113); __webpack_require__(114); __webpack_require__(116); __webpack_require__(117); __webpack_require__(118); __webpack_require__(120); __webpack_require__(122); __webpack_require__(123); __webpack_require__(124); __webpack_require__(125); __webpack_require__(126); __webpack_require__(127); __webpack_require__(128); __webpack_require__(129); __webpack_require__(130); __webpack_require__(131); __webpack_require__(132); __webpack_require__(133); __webpack_require__(134); __webpack_require__(139); __webpack_require__(140); __webpack_require__(144); __webpack_require__(145); __webpack_require__(146); __webpack_require__(147); __webpack_require__(149); __webpack_require__(150); __webpack_require__(151); __webpack_require__(152); __webpack_require__(153); __webpack_require__(154); __webpack_require__(155); __webpack_require__(156); __webpack_require__(157); __webpack_require__(158); __webpack_require__(159); __webpack_require__(160); __webpack_require__(161); __webpack_require__(162); __webpack_require__(163); __webpack_require__(165); __webpack_require__(166); __webpack_require__(168); __webpack_require__(169); __webpack_require__(175); __webpack_require__(176); __webpack_require__(178); __webpack_require__(179); __webpack_require__(180); __webpack_require__(184); __webpack_require__(185); __webpack_require__(186); __webpack_require__(187); __webpack_require__(188); __webpack_require__(190); __webpack_require__(191); __webpack_require__(192); __webpack_require__(193); __webpack_require__(196); __webpack_require__(198); __webpack_require__(199); __webpack_require__(200); __webpack_require__(202); __webpack_require__(204); __webpack_require__(206); __webpack_require__(208); __webpack_require__(209); __webpack_require__(210); __webpack_require__(214); __webpack_require__(215); __webpack_require__(216); __webpack_require__(218); __webpack_require__(228); __webpack_require__(232); __webpack_require__(233); __webpack_require__(235); __webpack_require__(236); __webpack_require__(240); __webpack_require__(241); __webpack_require__(243); __webpack_require__(244); __webpack_require__(245); __webpack_require__(246); __webpack_require__(247); __webpack_require__(248); __webpack_require__(249); __webpack_require__(250); __webpack_require__(251); __webpack_require__(252); __webpack_require__(253); __webpack_require__(254); __webpack_require__(255); __webpack_require__(256); __webpack_require__(257); __webpack_require__(258); __webpack_require__(259); __webpack_require__(260); __webpack_require__(261); __webpack_require__(263); __webpack_require__(264); __webpack_require__(265); __webpack_require__(266); __webpack_require__(267); __webpack_require__(269); __webpack_require__(270); __webpack_require__(271); __webpack_require__(273); __webpack_require__(274); __webpack_require__(275); __webpack_require__(276); __webpack_require__(277); __webpack_require__(278); __webpack_require__(279); __webpack_require__(280); __webpack_require__(282); __webpack_require__(283); __webpack_require__(285); __webpack_require__(286); __webpack_require__(287); __webpack_require__(288); __webpack_require__(291); __webpack_require__(292); __webpack_require__(294); __webpack_require__(295); __webpack_require__(296); __webpack_require__(297); __webpack_require__(299); __webpack_require__(300); __webpack_require__(301); __webpack_require__(302); __webpack_require__(303); __webpack_require__(304); __webpack_require__(305); __webpack_require__(306); __webpack_require__(307); __webpack_require__(308); __webpack_require__(310); __webpack_require__(311); __webpack_require__(312); __webpack_require__(313); __webpack_require__(314); __webpack_require__(315); __webpack_require__(316); __webpack_require__(317); __webpack_require__(318); __webpack_require__(319); __webpack_require__(320); __webpack_require__(322); __webpack_require__(323); __webpack_require__(324); __webpack_require__(325); __webpack_require__(326); __webpack_require__(327); __webpack_require__(328); __webpack_require__(329); __webpack_require__(330); __webpack_require__(331); __webpack_require__(332); __webpack_require__(333); __webpack_require__(334); module.exports = __webpack_require__(16); /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // ECMAScript 6 symbols shim var global = __webpack_require__(11); var has = __webpack_require__(12); var DESCRIPTORS = __webpack_require__(13); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var META = __webpack_require__(32).KEY; var $fails = __webpack_require__(14); var shared = __webpack_require__(28); var setToStringTag = __webpack_require__(33); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var wksExt = __webpack_require__(35); var wksDefine = __webpack_require__(36); var enumKeys = __webpack_require__(37); var isArray = __webpack_require__(52); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var createDesc = __webpack_require__(24); var _create = __webpack_require__(53); var gOPNExt = __webpack_require__(56); var $GOPD = __webpack_require__(58); var $DP = __webpack_require__(18); var $keys = __webpack_require__(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON && $JSON.stringify; var PROTOTYPE = 'prototype'; var HIDDEN = wks('_hidden'); var TO_PRIMITIVE = wks('toPrimitive'); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared('symbol-registry'); var AllSymbols = shared('symbols'); var OPSymbols = shared('op-symbols'); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == 'function'; var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS && $fails(function () { return _create(dP({}, 'a', { get: function () { return dP(this, 'a', { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) { return typeof it == 'symbol'; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l > i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!'); var tag = uid(arguments.length > 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], 'toString', function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames; __webpack_require__(51).f = $propertyIsEnumerable; __webpack_require__(50).f = $getOwnPropertySymbols; if (DESCRIPTORS && !__webpack_require__(29)) { redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables' ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F * !USE_NATIVE, 'Symbol', { // 19.4.2.1 Symbol.for(key) 'for': function (key) { return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!'); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F * !USE_NATIVE, 'Object', { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}'; })), 'JSON', { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length > i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == 'function') value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint) $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, 'JSON', true); /***/ }), /* 11 */ /***/ (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 12 */ /***/ (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(14)(function () { return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 14 */ /***/ (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var hide = __webpack_require__(17); var redefine = __webpack_require__(25); var ctx = __webpack_require__(30); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 16 */ /***/ (function(module, exports) { var core = module.exports = { version: '2.6.5' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var createDesc = __webpack_require__(24); module.exports = __webpack_require__(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { var anObject = __webpack_require__(19); var IE8_DOM_DEFINE = __webpack_require__(21); var toPrimitive = __webpack_require__(23); var dP = Object.defineProperty; exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { /* empty */ } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 20 */ /***/ (function(module, exports) { module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () { return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 22 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var document = __webpack_require__(11).document; // typeof document.createElement is 'object' in old IE var is = isObject(document) && isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; }; /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = __webpack_require__(20); // instead of the ES6 spec version, we didn't implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val; if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; throw TypeError("Can't convert object to primitive value"); }; /***/ }), /* 24 */ /***/ (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 25 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var hide = __webpack_require__(17); var has = __webpack_require__(12); var SRC = __webpack_require__(26)('src'); var $toString = __webpack_require__(27); var TO_STRING = 'toString'; var TPL = ('' + $toString).split(TO_STRING); __webpack_require__(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == 'function'; if (isFunction) has(val, 'name') || hide(val, 'name', key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == 'function' && this[SRC] || $toString.call(this); }); /***/ }), /* 26 */ /***/ (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 27 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(28)('native-function-to-string', Function.toString); /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { var core = __webpack_require__(16); var global = __webpack_require__(11); var SHARED = '__core-js_shared__'; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: core.version, mode: __webpack_require__(29) ? 'pure' : 'global', copyright: '© 2019 Denis Pushkarev (zloirock.ru)' }); /***/ }), /* 29 */ /***/ (function(module, exports) { module.exports = false; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { // optional / simple context binding var aFunction = __webpack_require__(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/* ...args */) { return fn.apply(that, arguments); }; }; /***/ }), /* 31 */ /***/ (function(module, exports) { module.exports = function (it) { if (typeof it != 'function') throw TypeError(it + ' is not a function!'); return it; }; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { var META = __webpack_require__(26)('meta'); var isObject = __webpack_require__(20); var has = __webpack_require__(12); var setDesc = __webpack_require__(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !__webpack_require__(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: 'O' + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return 'F'; // not necessary to add metadata if (!create) return 'E'; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze }; /***/ }), /* 33 */ /***/ (function(module, exports, __webpack_require__) { var def = __webpack_require__(18).f; var has = __webpack_require__(12); var TAG = __webpack_require__(34)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { var store = __webpack_require__(28)('wks'); var uid = __webpack_require__(26); var Symbol = __webpack_require__(11).Symbol; var USE_SYMBOL = typeof Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { exports.f = __webpack_require__(34); /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var LIBRARY = __webpack_require__(29); var wksExt = __webpack_require__(35); var defineProperty = __webpack_require__(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); }; /***/ }), /* 37 */ /***/ (function(module, exports, __webpack_require__) { // all enumerable object keys, includes symbols var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(39); var enumBugKeys = __webpack_require__(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { var has = __webpack_require__(12); var toIObject = __webpack_require__(40); var arrayIndexOf = __webpack_require__(44)(false); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys while (names.length > i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(41); var defined = __webpack_require__(43); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = __webpack_require__(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == 'String' ? it.split('') : Object(it); }; /***/ }), /* 42 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); }; /***/ }), /* 43 */ /***/ (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError("Can't call method on " + it); return it; }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { // false -> Array#indexOf // true -> Array#includes var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); var toAbsoluteIndex = __webpack_require__(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length > index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.15 ToLength var toInteger = __webpack_require__(46); var min = Math.min; module.exports = function (it) { return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 }; /***/ }), /* 46 */ /***/ (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it); }; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index < 0 ? max(index + length, 0) : min(index, length); }; /***/ }), /* 48 */ /***/ (function(module, exports, __webpack_require__) { var shared = __webpack_require__(28)('keys'); var uid = __webpack_require__(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); }; /***/ }), /* 49 */ /***/ (function(module, exports) { // IE 8- don't enum bug keys module.exports = ( 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf' ).split(','); /***/ }), /* 50 */ /***/ (function(module, exports) { exports.f = Object.getOwnPropertySymbols; /***/ }), /* 51 */ /***/ (function(module, exports) { exports.f = {}.propertyIsEnumerable; /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.2 IsArray(argument) var cof = __webpack_require__(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == 'Array'; }; /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(19); var dPs = __webpack_require__(54); var enumBugKeys = __webpack_require__(49); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var Empty = function () { /* empty */ }; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(22)('iframe'); var i = enumBugKeys.length; var lt = ''; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(55).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 54 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var anObject = __webpack_require__(19); var getKeys = __webpack_require__(38); module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length > i) dP.f(O, P = keys[i++], Properties[P]); return O; }; /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { var document = __webpack_require__(11).document; module.exports = document && document.documentElement; /***/ }), /* 56 */ /***/ (function(module, exports, __webpack_require__) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = __webpack_require__(40); var gOPN = __webpack_require__(57).f; var toString = {}.toString; var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it)); }; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = __webpack_require__(39); var hiddenKeys = __webpack_require__(49).concat('length', 'prototype'); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); }; /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { var pIE = __webpack_require__(51); var createDesc = __webpack_require__(24); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var IE8_DOM_DEFINE = __webpack_require__(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { /* empty */ } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); }; /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, 'Object', { create: __webpack_require__(53) }); /***/ }), /* 60 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(18).f }); /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(54) }); /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = __webpack_require__(40); var $getOwnPropertyDescriptor = __webpack_require__(58).f; __webpack_require__(63)('getOwnPropertyDescriptor', function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; }); /***/ }), /* 63 */ /***/ (function(module, exports, __webpack_require__) { // most Object methods by ES6 should accept primitives var $export = __webpack_require__(15); var core = __webpack_require__(16); var fails = __webpack_require__(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp); }; /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = __webpack_require__(65); var $getPrototypeOf = __webpack_require__(66); __webpack_require__(63)('getPrototypeOf', function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; }); /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.13 ToObject(argument) var defined = __webpack_require__(43); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = __webpack_require__(12); var toObject = __webpack_require__(65); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; }; /***/ }), /* 67 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 Object.keys(O) var toObject = __webpack_require__(65); var $keys = __webpack_require__(38); __webpack_require__(63)('keys', function () { return function keys(it) { return $keys(toObject(it)); }; }); /***/ }), /* 68 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 Object.getOwnPropertyNames(O) __webpack_require__(63)('getOwnPropertyNames', function () { return __webpack_require__(56).f; }); /***/ }), /* 69 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.5 Object.freeze(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('freeze', function ($freeze) { return function freeze(it) { return $freeze && isObject(it) ? $freeze(meta(it)) : it; }; }); /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.17 Object.seal(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('seal', function ($seal) { return function seal(it) { return $seal && isObject(it) ? $seal(meta(it)) : it; }; }); /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.15 Object.preventExtensions(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('preventExtensions', function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it; }; }); /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.12 Object.isFrozen(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isFrozen', function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; }); /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.13 Object.isSealed(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isSealed', function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; }); /***/ }), /* 74 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.11 Object.isExtensible(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isExtensible', function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; }); /***/ }), /* 75 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.1 Object.assign(target, source) var $export = __webpack_require__(15); $export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) }); /***/ }), /* 76 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.1 Object.assign(target, source, ...) var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || __webpack_require__(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = 'abcdefghijklmnopqrst'; A[S] = 7; K.split('').forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen > index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.10 Object.is(value1, value2) var $export = __webpack_require__(15); $export($export.S, 'Object', { is: __webpack_require__(78) }); /***/ }), /* 78 */ /***/ (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y; }; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = __webpack_require__(15); $export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set }); /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { // Works with __proto__ only. Old v8 can't work with null proto objects. /* eslint-disable no-proto */ var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!"); }; module.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line function (test, buggy, set) { try { set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.__proto__ = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check }; /***/ }), /* 81 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.3.6 Object.prototype.toString() var classof = __webpack_require__(82); var test = {}; test[__webpack_require__(34)('toStringTag')] = 'z'; if (test + '' != '[object z]') { __webpack_require__(25)(Object.prototype, 'toString', function toString() { return '[object ' + classof(this) + ']'; }, true); } /***/ }), /* 82 */ /***/ (function(module, exports, __webpack_require__) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = __webpack_require__(42); var TAG = __webpack_require__(34)('toStringTag'); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == 'Arguments'; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { /* empty */ } }; module.exports = function (it) { var O, T, B; return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B; }; /***/ }), /* 83 */ /***/ (function(module, exports, __webpack_require__) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...) var $export = __webpack_require__(15); $export($export.P, 'Function', { bind: __webpack_require__(84) }); /***/ }), /* 84 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var aFunction = __webpack_require__(31); var isObject = __webpack_require__(20); var invoke = __webpack_require__(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')'); } return factories[len](F, args); }; module.exports = Function.bind || function bind(that /* , ...args */) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/* args... */) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; }; /***/ }), /* 85 */ /***/ (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); }; /***/ }), /* 86 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18).f; var FProto = Function.prototype; var nameRE = /^\s*function ([^ (]*)/; var NAME = 'name'; // 19.2.4.2 name NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, { configurable: true, get: function () { try { return ('' + this).match(nameRE)[1]; } catch (e) { return ''; } } }); /***/ }), /* 87 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(20); var getPrototypeOf = __webpack_require__(66); var HAS_INSTANCE = __webpack_require__(34)('hasInstance'); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V) if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != 'function' || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } }); /***/ }), /* 88 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseInt = __webpack_require__(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt }); /***/ }), /* 89 */ /***/ (function(module, exports, __webpack_require__) { var $parseInt = __webpack_require__(11).parseInt; var $trim = __webpack_require__(90).trim; var ws = __webpack_require__(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10)); } : $parseInt; /***/ }), /* 90 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var defined = __webpack_require__(43); var fails = __webpack_require__(14); var spaces = __webpack_require__(91); var space = '[' + spaces + ']'; var non = '\u200b\u0085'; var ltrim = RegExp('^' + space + space + '*'); var rtrim = RegExp(space + space + '*$'); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spaces[KEY]() || non[KEY]() != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F * FORCE, 'String', exp); }; // 1 -> String#trimLeft // 2 -> String#trimRight // 3 -> String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE & 1) string = string.replace(ltrim, ''); if (TYPE & 2) string = string.replace(rtrim, ''); return string; }; module.exports = exporter; /***/ }), /* 91 */ /***/ (function(module, exports) { module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'; /***/ }), /* 92 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseFloat = __webpack_require__(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat }); /***/ }), /* 93 */ /***/ (function(module, exports, __webpack_require__) { var $parseFloat = __webpack_require__(11).parseFloat; var $trim = __webpack_require__(90).trim; module.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 && string.charAt(0) == '-' ? -0 : result; } : $parseFloat; /***/ }), /* 94 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var has = __webpack_require__(12); var cof = __webpack_require__(42); var inheritIfRequired = __webpack_require__(95); var toPrimitive = __webpack_require__(23); var fails = __webpack_require__(14); var gOPN = __webpack_require__(57).f; var gOPD = __webpack_require__(58).f; var dP = __webpack_require__(18).f; var $trim = __webpack_require__(90).trim; var NUMBER = 'Number'; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER; var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == 'string' && it.length > 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code < 48 || code > maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) { $Number = function Number(value) { var it = arguments.length < 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = __webpack_require__(13) ? gOPN(Base) : ( // ES3: 'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before): 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger' ).split(','), j = 0, key; keys.length > j; j++) { if (has(Base, key = keys[j]) && !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; __webpack_require__(25)(global, NUMBER, $Number); } /***/ }), /* 95 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var setPrototypeOf = __webpack_require__(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) { setPrototypeOf(that, P); } return that; }; /***/ }), /* 96 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toInteger = __webpack_require__(46); var aNumberValue = __webpack_require__(97); var repeat = __webpack_require__(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = 'Number.toFixed: incorrect invocation!'; var ZERO = '0'; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i < 6) { c2 += n * data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (--i >= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) * 1e7; } }; var numToString = function () { var i = 6; var s = ''; while (--i >= 0) { if (s !== '' || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 >= 4096) { n += 12; x2 /= 4096; } while (x2 >= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F * (!!$toFixed && ( 0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128' ) || !__webpack_require__(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), 'Number', { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ''; var m = ZERO; var e, z, j, k; if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return 'NaN'; if (x = 1e21) return String(x); if (x < 0) { s = '-'; x = -x; } if (x > 1e-21) { e = log(x * pow(2, 69, 1)) - 69; z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1); z *= 0x10000000000000; e = 52 - e; if (e > 0) { multiply(0, z); j = f; while (j >= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j >= 23) { divide(1 < 23); j -= 23; } divide(1 < j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 < -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f > 0) { k = m.length; m = s + (k -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x); }; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.5 Math.asinh(x) var $export = __webpack_require__(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1)); } // Tor Browser bug: Math.asinh(0) -> -0 $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh }); /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.7 Math.atanh(x) var $export = __webpack_require__(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0 $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } }); /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.9 Math.cbrt(x) var $export = __webpack_require__(15); var sign = __webpack_require__(115); $export($export.S, 'Math', { cbrt: function cbrt(x) { return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3); } }); /***/ }), /* 115 */ /***/ (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1; }; /***/ }), /* 116 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.11 Math.clz32(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { clz32: function clz32(x) { return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32; } }); /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.12 Math.cosh(x) var $export = __webpack_require__(15); var exp = Math.exp; $export($export.S, 'Math', { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } }); /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.14 Math.expm1(x) var $export = __webpack_require__(15); var $expm1 = __webpack_require__(119); $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 }); /***/ }), /* 119 */ /***/ (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1; } : $expm1; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { fround: __webpack_require__(121) }); /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var sign = __webpack_require__(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) * (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32; a = (1 + EPSILON32 / EPSILON) * $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result > MAX32 || result != result) return $sign * Infinity; return $sign * result; }; /***/ }), /* 122 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = __webpack_require__(15); var abs = Math.abs; $export($export.S, 'Math', { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i < aLen) { arg = abs(arguments[i++]); if (larg < arg) { div = larg / arg; sum = sum * div * div + 1; larg = arg; } else if (arg > 0) { div = arg / larg; sum += div * div; } else sum += arg; } return larg === Infinity ? Infinity : larg * Math.sqrt(sum); } }); /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.18 Math.imul(x, y) var $export = __webpack_require__(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F * __webpack_require__(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), 'Math', { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 & xn; var yl = UINT16 & yn; return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) < 16 >>> 0); } }); /***/ }), /* 124 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.21 Math.log10(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log10: function log10(x) { return Math.log(x) * Math.LOG10E; } }); /***/ }), /* 125 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.20 Math.log1p(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log1p: __webpack_require__(111) }); /***/ }), /* 126 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.22 Math.log2(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log2: function log2(x) { return Math.log(x) / Math.LN2; } }); /***/ }), /* 127 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.28 Math.sign(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { sign: __webpack_require__(115) }); /***/ }), /* 128 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.30 Math.sinh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F * __webpack_require__(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), 'Math', { sinh: function sinh(x) { return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2); } }); /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.33 Math.tanh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; $export($export.S, 'Math', { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } }); /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.34 Math.trunc(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { trunc: function trunc(it) { return (it > 0 ? Math.floor : Math.ceil)(it); } }); /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toAbsoluteIndex = __webpack_require__(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', { // 21.1.2.2 String.fromCodePoint(...codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen > i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point'); res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(''); } }); /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); $export($export.S, 'String', { // 21.1.2.4 String.raw(callSite, ...substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len > i) { res.push(String(tpl[i++])); if (i < aLen) res.push(String(arguments[i])); } return res.join(''); } }); /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.1.3.25 String.prototype.trim() __webpack_require__(90)('trim', function ($trim) { return function trim() { return $trim(this, 3); }; }); /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $at = __webpack_require__(135)(true); // 21.1.3.27 String.prototype[@@iterator]() __webpack_require__(136)(String, 'String', function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index >= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; }); /***/ }), /* 135 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var defined = __webpack_require__(43); // true -> String#at // false -> String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i < 0 || i >= l) return TO_STRING ? '' : undefined; a = s.charCodeAt(i); return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 < 10) + (b - 0xdc00) + 0x10000; }; }; /***/ }), /* 136 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var LIBRARY = __webpack_require__(29); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var $iterCreate = __webpack_require__(138); var setToStringTag = __webpack_require__(33); var getPrototypeOf = __webpack_require__(66); var ITERATOR = __webpack_require__(34)('iterator'); var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next` var FF_ITERATOR = '@@iterator'; var KEYS = 'keys'; var VALUES = 'values'; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY && kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ' Iterator'; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined; var $anyNative = NAME == 'Array' ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES && $native && $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods); } return methods; }; /***/ }), /* 137 */ /***/ (function(module, exports) { module.exports = {}; /***/ }), /* 138 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var create = __webpack_require__(53); var descriptor = __webpack_require__(24); var setToStringTag = __webpack_require__(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]() __webpack_require__(17)(IteratorPrototype, __webpack_require__(34)('iterator'), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ' Iterator'); }; /***/ }), /* 139 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $at = __webpack_require__(135)(false); $export($export.P, 'String', { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } }); /***/ }), /* 140 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var ENDS_WITH = 'endsWith'; var $endsWith = ''[ENDS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', { endsWith: function endsWith(searchString /* , endPosition = @length */) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length > 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } }); /***/ }), /* 141 */ /***/ (function(module, exports, __webpack_require__) { // helper for String#{startsWith, endsWith, includes} var isRegExp = __webpack_require__(142); var defined = __webpack_require__(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!"); return String(defined(that)); }; /***/ }), /* 142 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.8 IsRegExp(argument) var isObject = __webpack_require__(20); var cof = __webpack_require__(42); var MATCH = __webpack_require__(34)('match'); module.exports = function (it) { var isRegExp; return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp'); }; /***/ }), /* 143 */ /***/ (function(module, exports, __webpack_require__) { var MATCH = __webpack_require__(34)('match'); module.exports = function (KEY) { var re = /./; try { '/./'[KEY](re); } catch (e) { try { re[MATCH] = false; return !'/./'[KEY](re); } catch (f) { /* empty */ } } return true; }; /***/ }), /* 144 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) 'use strict'; var $export = __webpack_require__(15); var context = __webpack_require__(141); var INCLUDES = 'includes'; $export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', { includes: function includes(searchString /* , position = 0 */) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined); } }); /***/ }), /* 145 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.P, 'String', { // 21.1.3.13 String.prototype.repeat(count) repeat: __webpack_require__(98) }); /***/ }), /* 146 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var STARTS_WITH = 'startsWith'; var $startsWith = ''[STARTS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', { startsWith: function startsWith(searchString /* , position = 0 */) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } }); /***/ }), /* 147 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // B.2.3.2 String.prototype.anchor(name) __webpack_require__(148)('anchor', function (createHTML) { return function anchor(name) { return createHTML(this, 'a', 'name', name); }; }); /***/ }), /* 148 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ' Array#map // 2 -> Array#filter // 3 -> Array#some // 4 -> Array#every // 5 -> Array#find // 6 -> Array#findIndex var ctx = __webpack_require__(30); var IObject = __webpack_require__(41); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var asc = __webpack_require__(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length > index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; }; /***/ }), /* 182 */ /***/ (function(module, exports, __webpack_require__) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = __webpack_require__(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); }; /***/ }), /* 183 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var isArray = __webpack_require__(52); var SPECIES = __webpack_require__(34)('species'); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; }; /***/ }), /* 184 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $map = __webpack_require__(181)(1); $export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn /* , thisArg */) { return $map(this, callbackfn, arguments[1]); } }); /***/ }), /* 185 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $filter = __webpack_require__(181)(2); $export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn /* , thisArg */) { return $filter(this, callbackfn, arguments[1]); } }); /***/ }), /* 186 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $some = __webpack_require__(181)(3); $export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn /* , thisArg */) { return $some(this, callbackfn, arguments[1]); } }); /***/ }), /* 187 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $every = __webpack_require__(181)(4); $export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn /* , thisArg */) { return $every(this, callbackfn, arguments[1]); } }); /***/ }), /* 188 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } }); /***/ }), /* 189 */ /***/ (function(module, exports, __webpack_require__) { var aFunction = __webpack_require__(31); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var toLength = __webpack_require__(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen < 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index < 0 : length = 0 : length > index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; }; /***/ }), /* 190 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } }); /***/ }), /* 191 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $indexOf = __webpack_require__(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement /* , fromIndex = 0 */) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } }); /***/ }), /* 192 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1])); if (index < 0) index = length + index; for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } }); /***/ }), /* 193 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { copyWithin: __webpack_require__(194) }); __webpack_require__(195)('copyWithin'); /***/ }), /* 194 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length > 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from < to && to < from + count) { inc = -1; from += count - 1; to += count - 1; } while (count-- > 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; }; /***/ }), /* 195 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = __webpack_require__(34)('unscopables'); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; }; /***/ }), /* 196 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { fill: __webpack_require__(197) }); __webpack_require__(195)('fill'); /***/ }), /* 197 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = function fill(value /* , start = 0, end = @length */) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length); var end = aLen > 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos > index) O[index++] = value; return O; }; /***/ }), /* 198 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(5); var KEY = 'find'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { find: function find(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 199 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(6); var KEY = 'findIndex'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { findIndex: function findIndex(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 200 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(201)('Array'); /***/ }), /* 201 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var dP = __webpack_require__(18); var DESCRIPTORS = __webpack_require__(13); var SPECIES = __webpack_require__(34)('species'); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); }; /***/ }), /* 202 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var addToUnscopables = __webpack_require__(195); var step = __webpack_require__(203); var Iterators = __webpack_require__(137); var toIObject = __webpack_require__(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype[@@iterator]() module.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index >= O.length) { this._t = undefined; return step(1); } if (kind == 'keys') return step(0, index); if (kind == 'values') return step(0, O[index]); return step(0, [index, O[index]]); }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries'); /***/ }), /* 203 */ /***/ (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; }; /***/ }), /* 204 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var inheritIfRequired = __webpack_require__(95); var dP = __webpack_require__(18).f; var gOPN = __webpack_require__(57).f; var isRegExp = __webpack_require__(142); var $flags = __webpack_require__(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // "new" creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(14)(function () { re2[__webpack_require__(34)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i'; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; __webpack_require__(25)(global, 'RegExp', $RegExp); } __webpack_require__(201)('RegExp'); /***/ }), /* 205 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.2.5.3 get RegExp.prototype.flags var anObject = __webpack_require__(19); module.exports = function () { var that = anObject(this); var result = ''; if (that.global) result += 'g'; if (that.ignoreCase) result += 'i'; if (that.multiline) result += 'm'; if (that.unicode) result += 'u'; if (that.sticky) result += 'y'; return result; }; /***/ }), /* 206 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpExec = __webpack_require__(207); __webpack_require__(15)({ target: 'RegExp', proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec }); /***/ }), /* 207 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpFlags = __webpack_require__(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = 'lastIndex'; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b*/g; nativeExec.call(re1, 'a'); nativeExec.call(re2, 'a'); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim's String#split patch. var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG && match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED && match && match.length > 1) { // Fix browsers whose `exec` methods don't consistently return `undefined` // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i < arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec; /***/ }), /* 208 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(209); var anObject = __webpack_require__(19); var $flags = __webpack_require__(205); var DESCRIPTORS = __webpack_require__(13); var TO_STRING = 'toString'; var $toString = /./[TO_STRING]; var define = function (fn) { __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (__webpack_require__(14)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) { define(function toString() { var R = anObject(this); return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); } /***/ }), /* 209 */ /***/ (function(module, exports, __webpack_require__) { // 21.2.5.3 get RegExp.prototype.flags() if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(18).f(RegExp.prototype, 'flags', { configurable: true, get: __webpack_require__(205) }); /***/ }), /* 210 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toLength = __webpack_require__(45); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); // @@match logic __webpack_require__(213)('match', 1, function (defined, MATCH, $match, maybeCallNative) { return [ // `String.prototype.match` method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O)); }, // `RegExp.prototype[@@match]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; }); /***/ }), /* 211 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var at = __webpack_require__(135)(true); // `AdvanceStringIndex` abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); }; /***/ }), /* 212 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var classof = __webpack_require__(82); var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === 'function') { var result = exec.call(R, S); if (typeof result !== 'object') { throw new TypeError('RegExp exec method returned something other than an Object or null'); } return result; } if (classof(R) !== 'RegExp') { throw new TypeError('RegExp#exec called on incompatible receiver'); } return builtinExec.call(R, S); }; /***/ }), /* 213 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(206); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var wks = __webpack_require__(34); var regexpExec = __webpack_require__(207); var SPECIES = wks('species'); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a "grops" property. var re = /./; re.exec = function () { var result = []; result.groups = { a: '7' }; return result; }; return ''.replace(re, '$') !== '7'; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = 'ab'.split(re); return result.length === 2 && result[0] === 'a' && result[1] === 'b'; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ''[KEY](O) != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === 'split') { // RegExp[@@split] doesn't call the regex's exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } re[SYMBOL](''); return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL && !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue) // 21.2.5.11 RegExp.prototype[@@split](string, limit) ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype[@@match](string) // 21.2.5.9 RegExp.prototype[@@search](string) : function (string) { return rxfn.call(string, this); } ); } }; /***/ }), /* 214 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|]*>)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ // `String.prototype.replace` method // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, // `RegExp.prototype[@@replace]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === 'function'; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = ''; var nextSourcePosition = 0; for (var i = 0; i < results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reason `nativeSlice.call(result, 1, result.length)` (called in // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position >= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case '$': return '$'; case '&': return matched; case '`': return str.slice(0, position); case "'": return str.slice(tailPos); case '>> 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q < S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i 0; m = m * 256 + buffer[i], i--, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) * m * pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] < 24 | bytes[2] < 16 | bytes[1] < 8 | bytes[0]; } function packI8(it) { return [it & 0xff]; } function packI16(it) { return [it & 0xff, it >> 8 & 0xff]; } function packI32(it) { return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!'); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, '_l'); addGetter($DataView, BUFFER, '_b'); addGetter($DataView, BYTE_LENGTH, '_l'); addGetter($DataView, BYTE_OFFSET, '_o'); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] < 24 >> 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] < 8 | bytes[0]) < 16 >> 16; }, getUint16: function getUint16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] < 8 | bytes[0]; }, getInt32: function getInt32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0; }, getFloat32: function getFloat32(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView; /***/ }), /* 239 */ /***/ (function(module, exports, __webpack_require__) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError('Wrong length!'); return length; }; /***/ }), /* 240 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.G + $export.W + $export.F * !__webpack_require__(237).ABV, { DataView: __webpack_require__(238).DataView }); /***/ }), /* 241 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int8', 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 242 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; if (__webpack_require__(13)) { var LIBRARY = __webpack_require__(29); var global = __webpack_require__(11); var fails = __webpack_require__(14); var $export = __webpack_require__(15); var $typed = __webpack_require__(237); var $buffer = __webpack_require__(238); var ctx = __webpack_require__(30); var anInstance = __webpack_require__(219); var propertyDesc = __webpack_require__(24); var hide = __webpack_require__(17); var redefineAll = __webpack_require__(227); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var toIndex = __webpack_require__(239); var toAbsoluteIndex = __webpack_require__(47); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var classof = __webpack_require__(82); var isObject = __webpack_require__(20); var toObject = __webpack_require__(65); var isArrayIter = __webpack_require__(171); var create = __webpack_require__(53); var getPrototypeOf = __webpack_require__(66); var gOPN = __webpack_require__(57).f; var getIterFn = __webpack_require__(173); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var createArrayMethod = __webpack_require__(181); var createArrayIncludes = __webpack_require__(44); var speciesConstructor = __webpack_require__(217); var ArrayIterators = __webpack_require__(202); var Iterators = __webpack_require__(137); var $iterDetect = __webpack_require__(174); var setSpecies = __webpack_require__(201); var arrayFill = __webpack_require__(197); var arrayCopyWithin = __webpack_require__(194); var $DP = __webpack_require__(18); var $GOPD = __webpack_require__(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = 'ArrayBuffer'; var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER; var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'; var PROTOTYPE = 'prototype'; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks('iterator'); var TAG = wks('toStringTag'); var TYPED_CONSTRUCTOR = uid('typed_constructor'); var DEF_CONSTRUCTOR = uid('def_constructor'); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = 'Wrong length!'; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!'); return offset; }; var validate = function (it) { if (isObject(it) && TYPED_ARRAY in it) return it; throw TypeError(it + ' is not a typed array!'); }; var allocate = function (C, length) { if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) { throw TypeError('It is not a typed array constructor!'); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length > index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source /* , mapfn, thisArg */) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen > 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined && !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/* ...items */) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length > index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start /* , end */) { return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined); }, every: function every(callbackfn /* , thisArg */) { return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn /* , thisArg */) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)); }, find: function find(predicate /* , thisArg */) { return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate /* , thisArg */) { return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn /* , thisArg */) { arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement /* , fromIndex */) { return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, includes: function includes(searchElement /* , fromIndex */) { return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn /* , thisArg */) { return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index < middle) { value = that[index]; that[index++] = that[--length]; that[length] = value; } return that; }, some: function some(callbackfn /* , thisArg */) { return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike /* , offset */) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset > length) throw RangeError(WRONG_LENGTH); while (index < len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { /* noop */ }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, 'buffer', 'b'); addGetter($TypedArrayPrototype$, 'byteOffset', 'o'); addGetter($TypedArrayPrototype$, 'byteLength', 'l'); addGetter($TypedArrayPrototype$, 'length', 'e'); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'; var GETTER = 'get' + KEY; var SETTER = 'set' + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray && getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff; data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN); }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, '_d'); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length * BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength < 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) * BYTES; if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, '_d', { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index < length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, 'constructor', TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // `ws` module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F * (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F * FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F * fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F * (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { /* empty */ }; /***/ }), /* 243 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 244 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true); /***/ }), /* 245 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int16', 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 246 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint16', 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 247 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int32', 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 248 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint32', 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 249 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float32', 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 250 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float64', 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 251 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = __webpack_require__(15); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var rApply = (__webpack_require__(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F * !__webpack_require__(14)(function () { rApply(function () { /* empty */ }); }), 'Reflect', { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } }); /***/ }), /* 252 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = __webpack_require__(15); var create = __webpack_require__(53); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var fails = __webpack_require__(14); var bind = __webpack_require__(84); var rConstruct = (__webpack_require__(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as `new.target`, but does not create `this` from it var NEW_TARGET_BUG = fails(function () { function F() { /* empty */ } return !(rConstruct(function () { /* empty */ }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { /* empty */ }); }); $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', { construct: function construct(Target, args /* , newTarget */) { aFunction(Target); anObject(args); var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } }); /***/ }), /* 253 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = __webpack_require__(18); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var toPrimitive = __webpack_require__(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F * __webpack_require__(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), 'Reflect', { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } }); /***/ }), /* 254 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = __webpack_require__(15); var gOPD = __webpack_require__(58).f; var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc && !desc.configurable ? false : delete target[propertyKey]; } }); /***/ }), /* 255 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 26.1.5 Reflect.enumerate(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; __webpack_require__(138)(Enumerate, 'Object', function () { var that = this; var keys = that._k; var key; do { if (that._i >= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, 'Reflect', { enumerate: function enumerate(target) { return new Enumerate(target); } }); /***/ }), /* 256 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); function get(target, propertyKey /* , receiver */) { var receiver = arguments.length < 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, 'Reflect', { get: get }); /***/ }), /* 257 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = __webpack_require__(58); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } }); /***/ }), /* 258 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = __webpack_require__(15); var getProto = __webpack_require__(66); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } }); /***/ }), /* 259 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.9 Reflect.has(target, propertyKey) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { has: function has(target, propertyKey) { return propertyKey in target; } }); /***/ }), /* 260 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.10 Reflect.isExtensible(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $isExtensible = Object.isExtensible; $export($export.S, 'Reflect', { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } }); /***/ }), /* 261 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.11 Reflect.ownKeys(target) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { ownKeys: __webpack_require__(262) }); /***/ }), /* 262 */ /***/ (function(module, exports, __webpack_require__) { // all object keys, includes non-enumerable and symbols var gOPN = __webpack_require__(57); var gOPS = __webpack_require__(50); var anObject = __webpack_require__(19); var Reflect = __webpack_require__(11).Reflect; module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; }; /***/ }), /* 263 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.12 Reflect.preventExtensions(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $preventExtensions = Object.preventExtensions; $export($export.S, 'Reflect', { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } }); /***/ }), /* 264 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = __webpack_require__(18); var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var createDesc = __webpack_require__(24); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); function set(target, propertyKey, V /* , receiver */) { var receiver = arguments.length < 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, 'value')) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, 'Reflect', { set: set }); /***/ }), /* 265 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = __webpack_require__(15); var setProto = __webpack_require__(80); if (setProto) $export($export.S, 'Reflect', { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } }); /***/ }), /* 266 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/Array.prototype.includes var $export = __webpack_require__(15); var $includes = __webpack_require__(44)(true); $export($export.P, 'Array', { includes: function includes(el /* , fromIndex = 0 */) { return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)('includes'); /***/ }), /* 267 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var aFunction = __webpack_require__(31); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatMap: function flatMap(callbackfn /* , thisArg */) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); __webpack_require__(195)('flatMap'); /***/ }), /* 268 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = __webpack_require__(52); var isObject = __webpack_require__(20); var toLength = __webpack_require__(45); var ctx = __webpack_require__(30); var IS_CONCAT_SPREADABLE = __webpack_require__(34)('isConcatSpreadable'); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex < sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable && depth > 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex >= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray; /***/ }), /* 269 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatten: function flatten(/* depthArg = 1 */) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); __webpack_require__(195)('flatten'); /***/ }), /* 270 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/mathiasbynens/String.prototype.at var $export = __webpack_require__(15); var $at = __webpack_require__(135)(true); $export($export.P, 'String', { at: function at(pos) { return $at(this, pos); } }); /***/ }), /* 271 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-string-pad-start-end var $export = __webpack_require__(15); var $pad = __webpack_require__(272); var userAgent = __webpack_require__(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F * WEBKIT_BUG, 'String', { padStart: function padStart(maxLength /* , fillString = ' ' */) { return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true); } }); /***/ }), /* 272 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = __webpack_require__(45); var repeat = __webpack_require__(98); var defined = __webpack_require__(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ' ' : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength 0; var $y0 = y0 >>> 0; return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0; } }); /***/ }), /* 311 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 >>> 0; var $x1 = x1 >>> 0; var $y0 = y0 >>> 0; return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0; } }); /***/ }), /* 312 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >> 16; var v1 = $v >> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16); } }); /***/ }), /* 313 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI }); /***/ }), /* 314 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, 'Math', { radians: function radians(degrees) { return degrees * DEG_PER_RAD; } }); /***/ }), /* 315 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { scale: __webpack_require__(309) }); /***/ }), /* 316 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >>> 16; var v1 = $v >>> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16); } }); /***/ }), /* 317 */ /***/ (function(module, exports, __webpack_require__) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = __webpack_require__(15); $export($export.S, 'Math', { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0; } }); /***/ }), /* 318 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-promise-finally 'use strict'; var $export = __webpack_require__(15); var core = __webpack_require__(16); var global = __webpack_require__(11); var speciesConstructor = __webpack_require__(217); var promiseResolve = __webpack_require__(226); $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == 'function'; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } }); /***/ }), /* 319 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-promise-try var $export = __webpack_require__(15); var newPromiseCapability = __webpack_require__(223); var perform = __webpack_require__(224); $export($export.S, 'Promise', { 'try': function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } }); /***/ }), /* 320 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } }); /***/ }), /* 321 */ /***/ (function(module, exports, __webpack_require__) { var Map = __webpack_require__(228); var $export = __webpack_require__(15); var shared = __webpack_require__(28)('metadata'); var store = shared.store || (shared.store = new (__webpack_require__(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == 'symbol' ? it : String(it); }; var exp = function (O) { $export($export.S, 'Reflect', O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp }; /***/ }), /* 322 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) { var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata['delete'](targetKey); return !!targetMetadata.size || store['delete'](target); } }); /***/ }), /* 323 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 324 */ /***/ (function(module, exports, __webpack_require__) { var Set = __webpack_require__(232); var from = __webpack_require__(290); var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) { return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 325 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 326 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 327 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 328 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 329 */ /***/ (function(module, exports, __webpack_require__) { var $metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var aFunction = __webpack_require__(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } }); /***/ }), /* 330 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = __webpack_require__(15); var microtask = __webpack_require__(222)(); var process = __webpack_require__(11).process; var isNode = __webpack_require__(42)(process) == 'process'; $export($export.G, { asap: function asap(fn) { var domain = isNode && process.domain; microtask(domain ? domain.bind(fn) : fn); } }); /***/ }), /* 331 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/zenparsing/es-observable var $export = __webpack_require__(15); var global = __webpack_require__(11); var core = __webpack_require__(16); var microtask = __webpack_require__(222)(); var OBSERVABLE = __webpack_require__(34)('observable'); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var anInstance = __webpack_require__(219); var redefineAll = __webpack_require__(227); var hide = __webpack_require__(17); var forOf = __webpack_require__(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === 'function' ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++]; return new (typeof this === 'function' ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j < items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); __webpack_require__(201)('Observable'); /***/ }), /* 332 */ /***/ (function(module, exports, __webpack_require__) { // ie9- setTimeout & setInterval additional parameters fix var global = __webpack_require__(11); var $export = __webpack_require__(15); var userAgent = __webpack_require__(225); var slice = [].slice; var MSIE = /MSIE .\./.test(userAgent); // 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == 'function' ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F * MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) }); /***/ }), /* 333 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $task = __webpack_require__(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear }); /***/ }), /* 334 */ /***/ (function(module, exports, __webpack_require__) { var $iterators = __webpack_require__(202); var getKeys = __webpack_require__(38); var redefine = __webpack_require__(25); var global = __webpack_require__(11); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var wks = __webpack_require__(34); var ITERATOR = wks('iterator'); var TO_STRING_TAG = wks('toStringTag'); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } } /***/ }), /* 335 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) {/** * Copyright (c) 2014, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * https://raw.github.com/facebook/regenerator/master/LICENSE file. An * additional grant of patent rights can be found in the PATENTS file in * the same directory. */ !(function(global) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; var inModule = typeof module === "object"; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we're in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don't bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we're in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there's no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don't have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don't natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = "GeneratorFunction"; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, "__await")` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { __await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && typeof value === "object" && hasOwn.call(value, "__await")) { return Promise.resolve(value.__await).then(function(value) { invoke("next", value, resolve, reject); }, function(err) { invoke("throw", err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === "object" && global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { // Setting context._sent for legacy support of Babel's // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = "throw"; context.arg = record.arg; } } }; } // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === "throw") { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { // If maybeInvokeDelegate(context) changed context.method from // "return" to "throw", let that override the TypeError below. return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError( "The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was "next", forget context.arg since it has been // "consumed" by the delegate iterator. If context.method was // "return", allow the original .return call to continue in the // outer generator. if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers' implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn't happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel's // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = "next"; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle("end"); } if (entry.tryLoc true * * _.endsWith('abc', 'b'); * // => false * * _.endsWith('abc', 'b', 2); * // => true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position >= 0 && string.slice(position, end) == target; } /** * Converts the characters "&", "", '"', and "'" in `string` to their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the ">" character is escaped for symmetry, characters like * ">" and "/" don't need escaping in HTML and have no special meaning * unless they're part of a tag or unquoted attribute value. See * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under "semi-related fun fact") for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape('fred, barney, & pebbles'); * // => 'fred, barney, &amp; pebbles' */ function escape(string) { string = toString(string); return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+", * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp('[lodash](https://lodash.com/)'); * // => '\[lodash\]\(https://lodash\.com/\)' */ function escapeRegExp(string) { string = toString(string); return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string; } /** * Converts `string` to * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase('Foo Bar'); * // => 'foo-bar' * * _.kebabCase('fooBar'); * // => 'foo-bar' * * _.kebabCase('__FOO_BAR__'); * // => 'foo-bar' */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? '-' : '') + word.toLowerCase(); }); /** * Converts `string`, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase('--Foo-Bar--'); * // => 'foo bar' * * _.lowerCase('fooBar'); * // => 'foo bar' * * _.lowerCase('__FOO_BAR__'); * // => 'foo bar' */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toLowerCase(); }); /** * Converts the first character of `string` to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst('Fred'); * // => 'fred' * * _.lowerFirst('FRED'); * // => 'fRED' */ var lowerFirst = createCaseFirst('toLowerCase'); /** * Pads `string` on the left and right sides if it's shorter than `length`. * Padding characters are truncated if they can't be evenly divided by `length`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad('abc', 8); * // => ' abc ' * * _.pad('abc', 8, '_-'); * // => '_-abc_-_' * * _.pad('abc', 3); * // => 'abc' */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength >= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Pads `string` on the right side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd('abc', 6); * // => 'abc ' * * _.padEnd('abc', 6, '_-'); * // => 'abc_-_' * * _.padEnd('abc', 3); * // => 'abc' */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Pads `string` on the left side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart('abc', 6); * // => ' abc' * * _.padStart('abc', 6, '_-'); * // => '_-_abc' * * _.padStart('abc', 3); * // => 'abc' */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Converts `string` to an integer of the specified radix. If `radix` is * `undefined` or `0`, a `radix` of `10` is used unless `value` is a * hexadecimal, in which case a `radix` of `16` is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpret `value` by. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {number} Returns the converted integer. * @example * * _.parseInt('08'); * // => 8 * * _.map(['6', '08', '10'], _.parseInt); * // => [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0); } /** * Repeats the given string `n` times. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the repeated string. * @example * * _.repeat('*', 3); * // => '***' * * _.repeat('abc', 2); * // => 'abcabc' * * _.repeat('abc', 0); * // => '' */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches for `pattern` in `string` with `replacement`. * * **Note:** This method is based on * [`String#replace`](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace('Hi Fred', 'Fred', 'Barney'); * // => 'Hi Barney' */ function replace() { var args = arguments, string = toString(args[0]); return args.length < 3 ? string : string.replace(args[1], args[2]); } /** * Converts `string` to * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase('Foo Bar'); * // => 'foo_bar' * * _.snakeCase('fooBar'); * // => 'foo_bar' * * _.snakeCase('--FOO-BAR--'); * // => 'foo_bar' */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? '_' : '') + word.toLowerCase(); }); /** * Splits `string` by `separator`. * * **Note:** This method is based on * [`String#split`](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split('a-b-c', '-', 2); * // => ['a', 'b'] */ function split(string, separator, limit) { if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0; if (!limit) { return []; } string = toString(string); if (string && ( typeof separator == 'string' || (separator != null && !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator && hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Converts `string` to * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase('--foo-bar--'); * // => 'Foo Bar' * * _.startCase('fooBar'); * // => 'Foo Bar' * * _.startCase('__FOO_BAR__'); * // => 'FOO BAR' */ var startCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + upperFirst(word); }); /** * Checks if `string` starts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returns `true` if `string` starts with `target`, * else `false`. * @example * * _.startsWith('abc', 'a'); * // => true * * _.startsWith('abc', 'b'); * // => false * * _.startsWith('abc', 'b', 1); * // => true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in "interpolate" delimiters, HTML-escape interpolated data properties in * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over `_.templateSettings` values. * * **Note:** In the development build `_.template` utilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash's custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML "escape" delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The "evaluate" delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The "interpolate" delimiter. * @param {string} [options.sourceURL='lodash.templateSources[n]'] * The sourceURL of the compiled template. * @param {string} [options.variable='obj'] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Function} Returns the compiled template function. * @example * * // Use the "interpolate" delimiter to create a compiled template. * var compiled = _.template('hello !'); * compiled({ 'user': 'fred' }); * // => 'hello fred!' * * // Use the HTML "escape" delimiter to escape data property values. * var compiled = _.template(''); * compiled({ 'value': '' }); * // => '&lt;script&gt;' * * // Use the "evaluate" delimiter to execute JavaScript and generate HTML. * var compiled = _.template(''); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the internal `print` function in "evaluate" delimiters. * var compiled = _.template('!'); * compiled({ 'user': 'barney' }); * // => 'hello barney!' * * // Use the ES template literal delimiter as an "interpolate" delimiter. * // Disable support by replacing the "interpolate" delimiter. * var compiled = _.template('hello ${ user }!'); * compiled({ 'user': 'pebbles' }); * // => 'hello pebbles!' * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(''); * compiled({ 'value': 'ignored' }); * // => '' * * // Use the `imports` option to import `jQuery` as `jq`. * var text = ''; * var compiled = _.template(text, { 'imports': { 'jq': jQuery } }); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the `sourceURL` option to specify a custom sourceURL for the template. * var compiled = _.template('hello !', { 'sourceURL': '/basic/greeting.jst' }); * compiled(data); * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector. * * // Use the `variable` option to ensure a with-statement isn't used in the compiled template. * var compiled = _.template('hi !', { 'variable': 'data' }); * compiled.source; * // => function(data) { * // var __t, __p = ''; * // __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!'; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template('hello !'); * compiled({ 'user': 'mustache' }); * // => 'hello mustache!' * * // Use the `source` property to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\ * var JST = {\ * "main": ' + _.template(mainText).source + '\ * };\ * '); */ function template(string, options, guard) { // Based on John Resig's `tmpl` implementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova's doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard && isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '"; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$' , 'g'); // Use a sourceURL for easier debugging. var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']') ) + '\n'; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += "' +\n__e(" + escapeValue + ") +\n'"; } if (evaluateValue) { isEvaluating = true; source += "';\n" + evaluateValue + ";\n__p += '"; } if (interpolateValue) { source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"; } index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in // order to produce the correct `offset` value. return match; }); source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = 'with (obj) {\n' + source + '\n}\n'; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source) .replace(reEmptyStringMiddle, '$1') .replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body. source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n' ) + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '' ) + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n' ) + source + 'return __p\n}'; var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); // Provide the compiled function's source by its `toString` method or // the `source` property as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Converts `string`, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower('--Foo-Bar--'); * // => '--foo-bar--' * * _.toLower('fooBar'); * // => 'foobar' * * _.toLower('__FOO_BAR__'); * // => '__foo_bar__' */ function toLower(value) { return toString(value).toLowerCase(); } /** * Converts `string`, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper('--foo-bar--'); * // => '--FOO-BAR--' * * _.toUpper('fooBar'); * // => 'FOOBAR' * * _.toUpper('__foo_bar__'); * // => '__FOO_BAR__' */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trim(' abc '); * // => 'abc' * * _.trim('-_-abc-_-', '_-'); * // => 'abc' * * _.map([' foo ', ' bar '], _.trim); * // => ['foo', 'bar'] */ function trim(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrim, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(''); } /** * Removes trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(' abc '); * // => ' abc' * * _.trimEnd('-_-abc-_-', '_-'); * // => '-_-abc' */ function trimEnd(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimEnd, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(''); } /** * Removes leading whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(' abc '); * // => 'abc ' * * _.trimStart('-_-abc-_-', '_-'); * // => 'abc-_-' */ function trimStart(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimStart, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(''); } /** * Truncates `string` if it's longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to "...". * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission='...'] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate('hi-diddly-ho there, neighborino'); * // => 'hi-diddly-ho there, neighbo...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': ' ' * }); * // => 'hi-diddly-ho there,...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': /,? +/ * }); * // => 'hi-diddly-ho there...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'omission': ' [...]' * }); * // => 'hi-diddly-ho there, neig [...]' */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = 'separator' in options ? options.separator : separator; length = 'length' in options ? toInteger(options.length) : length; omission = 'omission' in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length >= strLength) { return string; } var end = length - stringSize(omission); if (end < 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g'); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index > -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of `_.escape`; this method converts the HTML entities * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=''] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape('fred, barney, &amp; pebbles'); * // => 'fred, barney, & pebbles' */ function unescape(string) { string = toString(string); return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Converts `string`, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase('--foo-bar'); * // => 'FOO BAR' * * _.upperCase('fooBar'); * // => 'FOO BAR' * * _.upperCase('__foo_bar__'); * // => 'FOO BAR' */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toUpperCase(); }); /** * Converts the first character of `string` to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst('fred'); * // => 'Fred' * * _.upperFirst('FRED'); * // => 'FRED' */ var upperFirst = createCaseFirst('toUpperCase'); /** * Splits `string` into an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Array} Returns the words of `string`. * @example * * _.words('fred, barney, & pebbles'); * // => ['fred', 'barney', 'pebbles'] * * _.words('fred, barney, & pebbles', /[^, ]+/g); * // => ['fred', 'barney', '&', 'pebbles'] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invoke `func` with. * @returns {*} Returns the `func` result or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, '>_>'); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn't set the "length" property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returns `object`. * @example * * var view = { * 'label': 'docs', * 'click': function() { * console.log('clicked ' + this.label); * } * }; * * _.bindAll(view, ['click']); * jQuery(element).on('click', view.click); * // => Logs 'clicked docs' when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ 'a': 1 }), _.constant('matches A')], * [_.conforms({ 'b': _.isNumber }), _.constant('matches B')], * [_.stubTrue, _.constant('no match')] * ]); * * func({ 'a': 1, 'b': 2 }); * // => 'matches A' * * func({ 'a': 0, 'b': 1 }); * // => 'matches B' * * func({ 'a': '1', 'b': '2' }); * // => 'no match' */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != 'function') { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index < length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `_.conformsTo` with * `source` partially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 2, 'b': 1 }, * { 'a': 1, 'b': 2 } * ]; * * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } })); * // => [{ 'a': 1, 'b': 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returns `value`. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ 'a': 1 })); * * console.log(objects); * // => [{ 'a': 1 }, { 'a': 1 }] * * console.log(objects[0] === objects[1]); * // => true */ function constant(value) { return function() { return value; }; } /** * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // => 1 * * _.defaultTo(undefined, 10); * // => 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with the `this` binding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // => 9 */ var flow = createFlow(); /** * This method is like `_.flow` except that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // => 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returns `value`. * @example * * var object = { 'a': 1 }; * * console.log(_.identity(object) === object); * // => true */ function identity(value) { return value; } /** * Creates a function that invokes `func` with the arguments of the created * function. If `func` is a property name, the created function returns the * property value for a given element. If `func` is an array or object, the * created function returns `true` for elements that contain the equivalent * source properties, otherwise it returns `false`. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { 'user': 'barney', 'age': 36, 'active': true }, * { 'user': 'fred', 'age': 40, 'active': false } * ]; * * // The `_.matches` iteratee shorthand. * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true })); * // => [{ 'user': 'barney', 'age': 36, 'active': true }] * * // The `_.matchesProperty` iteratee shorthand. * _.filter(users, _.iteratee(['user', 'fred'])); * // => [{ 'user': 'fred', 'age': 40 }] * * // The `_.property` iteratee shorthand. * _.map(users, _.iteratee('user')); * // => ['barney', 'fred'] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter(['abc', 'def'], /ef/); * // => ['def'] */ function iteratee(func) { return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object and `source`, returning `true` if the given object has equivalent * property values, else `false`. * * **Note:** The created function is equivalent to `_.isMatch` with `source` * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `_.isEqual` * for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.filter(objects, _.matches({ 'a': 4, 'c': 6 })); * // => [{ 'a': 4, 'b': 5, 'c': 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value at `path` of a given object to `srcValue`, returning `true` if the * object value is equivalent, else `false`. * * **Note:** Partial comparisons will match empty array and empty object * `srcValue` values against any array or object value, respectively. See * `_.isEqual` for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.find(objects, _.matchesProperty('a', 4)); * // => { 'a': 4, 'b': 5, 'c': 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method at `path` of a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { 'a': { 'b': _.constant(2) } }, * { 'a': { 'b': _.constant(1) } } * ]; * * _.map(objects, _.method('a.b')); * // => [2, 1] * * _.map(objects, _.method(['a', 'b'])); * // => [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of `_.method`; this method creates a function that invokes * the method at a given path of `object`. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.methodOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.methodOf(object)); * // => [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. If `object` is a function, then methods * are added to its prototype as well. * * **Note:** Use `_.runInContext` to create a pristine `lodash` function to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returns `object`. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ 'vowels': vowels }); * _.vowels('fred'); * // => ['e'] * * _('fred').vowels().value(); * // => ['e'] * * _.mixin({ 'vowels': vowels }, { 'chain': false }); * _('fred').vowels(); * // => ['e'] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null && !(isObject(source) && (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ 'func': func, 'args': arguments, 'thisArg': object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the `_` variable to its previous value and returns a reference to * the `lodash` function. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns the `lodash` function. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returns `undefined`. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // => [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at index `n`. If `n` is negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func('a', 'b', 'c', 'd'); * // => 'b' * * var func = _.nthArg(-2); * func('a', 'b', 'c', 'd'); * // => 'c' */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokes `iteratees` with the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // => [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => false * * func(NaN); * // => false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => true * * func(NaN); * // => false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value at `path` of a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { 'a': { 'b': 2 } }, * { 'a': { 'b': 1 } } * ]; * * _.map(objects, _.property('a.b')); * // => [2, 1] * * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b'); * // => [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of `_.property`; this method creates a function that returns * the value at a given path of `object`. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.propertyOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.propertyOf(object)); * // => [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from * `start` up to, but not including, `end`. A step of `-1` is used if a negative * `start` is specified without an `end` or `step`. If `end` is not specified, * it's set to `start` with `start` then set to `0`. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // => [0, 1, 2, 3] * * _.range(-4); * // => [0, -1, -2, -3] * * _.range(1, 5); * // => [1, 2, 3, 4] * * _.range(0, 20, 5); * // => [0, 5, 10, 15] * * _.range(0, -4, -1); * // => [0, -1, -2, -3] * * _.range(1, 4, 0); * // => [1, 1, 1] * * _.range(0); * // => [] */ var range = createRange(); /** * This method is like `_.range` except that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // => [3, 2, 1, 0] * * _.rangeRight(-4); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // => [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // => [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // => [1, 1, 1] * * _.rangeRight(0); * // => [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // => [[], []] * * console.log(arrays[0] === arrays[1]); * // => false */ function stubArray() { return []; } /** * This method returns `false`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `false`. * @example * * _.times(2, _.stubFalse); * // => [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // => [{}, {}] * * console.log(objects[0] === objects[1]); * // => false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // => ['', ''] */ function stubString() { return ''; } /** * This method returns `true`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `true`. * @example * * _.times(2, _.stubTrue); * // => [true, true] */ function stubTrue() { return true; } /** * Invokes the iteratee `n` times, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invoke `iteratee`. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // => ['0', '1', '2'] * * _.times(4, _.constant(0)); * // => [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n < 1 || n > MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index < n) { iteratee(index); } return result; } /** * Converts `value` to a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath('a.b.c'); * // => ['a', 'b', 'c'] * * _.toPath('a[0].b.c'); * // => ['a', '0', 'b', 'c'] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. If `prefix` is given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=''] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId('contact_'); * // => 'contact_104' * * _.uniqueId(); * // => '105' */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // => 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computes `number` rounded up to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // => 5 * * _.ceil(6.004, 2); * // => 6.01 * * _.ceil(6040, -2); * // => 6100 */ var ceil = createRound('ceil'); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // => 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computes `number` rounded down to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // => 4 * * _.floor(0.046, 2); * // => 0.04 * * _.floor(4060, -2); * // => 4000 */ var floor = createRound('floor'); /** * Computes the maximum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // => 8 * * _.max([]); * // => undefined */ function max(array) { return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like `_.max` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // => { 'n': 2 } * * // The `_.property` iteratee shorthand. * _.maxBy(objects, 'n'); * // => { 'n': 2 } */ function maxBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values in `array`. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // => 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like `_.mean` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // => 5 * * // The `_.property` iteratee shorthand. * _.meanBy(objects, 'n'); * // => 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // => 2 * * _.min([]); * // => undefined */ function min(array) { return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like `_.min` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // => { 'n': 1 } * * // The `_.property` iteratee shorthand. * _.minBy(objects, 'n'); * // => { 'n': 1 } */ function minBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // => 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computes `number` rounded to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // => 4 * * _.round(4.006, 2); * // => 4.01 * * _.round(4060, -2); * // => 4100 */ var round = createRound('round'); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // => 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values in `array`. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // => 20 */ function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; } /** * This method is like `_.sum` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // => 20 * * // The `_.property` iteratee shorthand. * _.sumBy(objects, 'n'); * // => 20 */ function sumBy(array, iteratee) { return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { 'chain': false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) { lodash[methodName].placeholder = lodash; }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants. arrayEach(['drop', 'take'], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ && !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') }); } return result; }; LazyWrapper.prototype[methodName + 'Right'] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // Add `LazyWrapper` methods that accept an `iteratee` value. arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // Add `LazyWrapper` methods for `_.head` and `_.last`. arrayEach(['head', 'last'], function(methodName, index) { var takeName = 'take' + (index ? 'Right' : ''); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`. arrayEach(['initial', 'tail'], function(methodName, index) { var dropName = 'drop' + (index ? '' : 'Right'); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == 'function') { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ && (start > 0 || end < 0)) { return new LazyWrapper(result); } if (start < 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end < 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // Add `LazyWrapper` methods to `lodash.prototype`. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker && chainAll) ? result[0] : result; }; if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) { // Avoid lazy use if the iteratee has a "length" value other than `1`. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid; if (!retUnwrapped && useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped && onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // Add `Array` methods to `lodash.prototype`. arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped && !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + ''), names = realNames[key] || (realNames[key] = []); names.push({ 'name': methodName, 'func': lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }]; // Add methods to `LazyWrapper`. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use `_.noConflict` to remove Lodash from the global object. root._ = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the "underscore" module. !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return _; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } // Check for `exports` after `define` in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = _; // Export for CommonJS support. freeExports._ = _; } else { // Export to the global object. root._ = _; } }.call(this)); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module))) /***/ }), /* 5 */ /***/ (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Prediction probabilities'; _classCallCheck(this, PredictProba); var width = parseInt(svg.style('width')); this.names = class_names; this.names.push('Other'); if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === '' ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars * (bar_height + space_between_bars) + bar_yshift; svg.style('height', this.svg_height + 'px'); var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) * i + bar_yshift; }; var bar = svg.append("g"); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == 'Other' && this.names.length > 20) { color = '#5F9EA0'; } var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", x_scale(data[i])).style("fill", color); bar.append("rect").attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", bar_width - 1).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); text = bar.append("text"); text.attr("x", bar_x + x_scale(data[i]) + 5).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif").text(data[i].toFixed(2)); text = bar.append("text"); text.attr("x", bar_x - 10).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(names[i]); while (text.node().getBBox()['width'] + 1 > class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + '...'); if (cur_text === '') { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length 4 && arguments[4] !== undefined ? arguments[4] : 'Predicted value'; var log_coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style('width')); this.color = _d2.default.scale.category10(); this.color('predicted_value'); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 * num_digits; var corner_padding = 5.5 * num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width * 2 - corner_padding * 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === '' ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = bar_yshift; var bar = svg.append("g"); //filled in bar representing predicted value in range var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(width_proportion)).style("fill", this.color); //empty box representing range bar.append("rect").attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(1)).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); //text for min value text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text("(min)"); //text for predicted value // console.log('bar height: ' + bar_height) text = bar.append("text"); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr("x", bar_x + x_scale(width_proportion)).attr("y", bar_y + bar_height + v_adjust_predicted_value_text).attr("fill", "black").attr("text-anchor", "middle").style("font", "14px tahoma, sans-serif"); //text for max value text = bar.append("text"); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif"); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif").text("(max)"); //readjust svg size // let svg_width = width + 1 * h_adjust; // svg.style('width', svg_width + 'px'); this.svg_height = n_bars * bar_height + bar_yshift + 2 * text.node().getBBox().height + 10; svg.style('height', this.svg_height + 'px'); if (log_coords) { console.log("svg width: " + svg_width); console.log("svg height: " + this.svg_height); console.log("bar_y: " + bar_y); console.log("bar_x: " + bar_x); console.log("Min value: " + min_value); console.log("Max value: " + max_value); console.log("Pred value: " + predicted_value); } }; exports.default = PredictedValue; /***/ }), /* 8 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {"use strict"; __webpack_require__(9); __webpack_require__(335); __webpack_require__(336); if (global._babelPolyfill) { throw new Error("only one instance of babel-polyfill is allowed"); } global._babelPolyfill = true; var DEFINE_PROPERTY = "defineProperty"; function define(O, key, value) { O[key] || Object[DEFINE_PROPERTY](O, key, { writable: true, configurable: true, value: value }); } define(String.prototype, "padLeft", "".padStart); define(String.prototype, "padRight", "".padEnd); "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) { [][key] && define(Array, key, Function.call.bind([][key])); }); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(10); __webpack_require__(59); __webpack_require__(60); __webpack_require__(61); __webpack_require__(62); __webpack_require__(64); __webpack_require__(67); __webpack_require__(68); __webpack_require__(69); __webpack_require__(70); __webpack_require__(71); __webpack_require__(72); __webpack_require__(73); __webpack_require__(74); __webpack_require__(75); __webpack_require__(77); __webpack_require__(79); __webpack_require__(81); __webpack_require__(83); __webpack_require__(86); __webpack_require__(87); __webpack_require__(88); __webpack_require__(92); __webpack_require__(94); __webpack_require__(96); __webpack_require__(99); __webpack_require__(100); __webpack_require__(101); __webpack_require__(102); __webpack_require__(104); __webpack_require__(105); __webpack_require__(106); __webpack_require__(107); __webpack_require__(108); __webpack_require__(109); __webpack_require__(110); __webpack_require__(112); __webpack_require__(113); __webpack_require__(114); __webpack_require__(116); __webpack_require__(117); __webpack_require__(118); __webpack_require__(120); __webpack_require__(122); __webpack_require__(123); __webpack_require__(124); __webpack_require__(125); __webpack_require__(126); __webpack_require__(127); __webpack_require__(128); __webpack_require__(129); __webpack_require__(130); __webpack_require__(131); __webpack_require__(132); __webpack_require__(133); __webpack_require__(134); __webpack_require__(139); __webpack_require__(140); __webpack_require__(144); __webpack_require__(145); __webpack_require__(146); __webpack_require__(147); __webpack_require__(149); __webpack_require__(150); __webpack_require__(151); __webpack_require__(152); __webpack_require__(153); __webpack_require__(154); __webpack_require__(155); __webpack_require__(156); __webpack_require__(157); __webpack_require__(158); __webpack_require__(159); __webpack_require__(160); __webpack_require__(161); __webpack_require__(162); __webpack_require__(163); __webpack_require__(165); __webpack_require__(166); __webpack_require__(168); __webpack_require__(169); __webpack_require__(175); __webpack_require__(176); __webpack_require__(178); __webpack_require__(179); __webpack_require__(180); __webpack_require__(184); __webpack_require__(185); __webpack_require__(186); __webpack_require__(187); __webpack_require__(188); __webpack_require__(190); __webpack_require__(191); __webpack_require__(192); __webpack_require__(193); __webpack_require__(196); __webpack_require__(198); __webpack_require__(199); __webpack_require__(200); __webpack_require__(202); __webpack_require__(204); __webpack_require__(206); __webpack_require__(208); __webpack_require__(209); __webpack_require__(210); __webpack_require__(214); __webpack_require__(215); __webpack_require__(216); __webpack_require__(218); __webpack_require__(228); __webpack_require__(232); __webpack_require__(233); __webpack_require__(235); __webpack_require__(236); __webpack_require__(240); __webpack_require__(241); __webpack_require__(243); __webpack_require__(244); __webpack_require__(245); __webpack_require__(246); __webpack_require__(247); __webpack_require__(248); __webpack_require__(249); __webpack_require__(250); __webpack_require__(251); __webpack_require__(252); __webpack_require__(253); __webpack_require__(254); __webpack_require__(255); __webpack_require__(256); __webpack_require__(257); __webpack_require__(258); __webpack_require__(259); __webpack_require__(260); __webpack_require__(261); __webpack_require__(263); __webpack_require__(264); __webpack_require__(265); __webpack_require__(266); __webpack_require__(267); __webpack_require__(269); __webpack_require__(270); __webpack_require__(271); __webpack_require__(273); __webpack_require__(274); __webpack_require__(275); __webpack_require__(276); __webpack_require__(277); __webpack_require__(278); __webpack_require__(279); __webpack_require__(280); __webpack_require__(282); __webpack_require__(283); __webpack_require__(285); __webpack_require__(286); __webpack_require__(287); __webpack_require__(288); __webpack_require__(291); __webpack_require__(292); __webpack_require__(294); __webpack_require__(295); __webpack_require__(296); __webpack_require__(297); __webpack_require__(299); __webpack_require__(300); __webpack_require__(301); __webpack_require__(302); __webpack_require__(303); __webpack_require__(304); __webpack_require__(305); __webpack_require__(306); __webpack_require__(307); __webpack_require__(308); __webpack_require__(310); __webpack_require__(311); __webpack_require__(312); __webpack_require__(313); __webpack_require__(314); __webpack_require__(315); __webpack_require__(316); __webpack_require__(317); __webpack_require__(318); __webpack_require__(319); __webpack_require__(320); __webpack_require__(322); __webpack_require__(323); __webpack_require__(324); __webpack_require__(325); __webpack_require__(326); __webpack_require__(327); __webpack_require__(328); __webpack_require__(329); __webpack_require__(330); __webpack_require__(331); __webpack_require__(332); __webpack_require__(333); __webpack_require__(334); module.exports = __webpack_require__(16); /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // ECMAScript 6 symbols shim var global = __webpack_require__(11); var has = __webpack_require__(12); var DESCRIPTORS = __webpack_require__(13); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var META = __webpack_require__(32).KEY; var $fails = __webpack_require__(14); var shared = __webpack_require__(28); var setToStringTag = __webpack_require__(33); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var wksExt = __webpack_require__(35); var wksDefine = __webpack_require__(36); var enumKeys = __webpack_require__(37); var isArray = __webpack_require__(52); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var createDesc = __webpack_require__(24); var _create = __webpack_require__(53); var gOPNExt = __webpack_require__(56); var $GOPD = __webpack_require__(58); var $DP = __webpack_require__(18); var $keys = __webpack_require__(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON && $JSON.stringify; var PROTOTYPE = 'prototype'; var HIDDEN = wks('_hidden'); var TO_PRIMITIVE = wks('toPrimitive'); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared('symbol-registry'); var AllSymbols = shared('symbols'); var OPSymbols = shared('op-symbols'); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == 'function'; var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS && $fails(function () { return _create(dP({}, 'a', { get: function () { return dP(this, 'a', { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) { return typeof it == 'symbol'; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l > i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!'); var tag = uid(arguments.length > 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], 'toString', function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames; __webpack_require__(51).f = $propertyIsEnumerable; __webpack_require__(50).f = $getOwnPropertySymbols; if (DESCRIPTORS && !__webpack_require__(29)) { redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables' ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F * !USE_NATIVE, 'Symbol', { // 19.4.2.1 Symbol.for(key) 'for': function (key) { return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!'); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F * !USE_NATIVE, 'Object', { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}'; })), 'JSON', { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length > i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == 'function') value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint) $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, 'JSON', true); /***/ }), /* 11 */ /***/ (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 12 */ /***/ (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(14)(function () { return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 14 */ /***/ (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var hide = __webpack_require__(17); var redefine = __webpack_require__(25); var ctx = __webpack_require__(30); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 16 */ /***/ (function(module, exports) { var core = module.exports = { version: '2.6.5' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var createDesc = __webpack_require__(24); module.exports = __webpack_require__(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { var anObject = __webpack_require__(19); var IE8_DOM_DEFINE = __webpack_require__(21); var toPrimitive = __webpack_require__(23); var dP = Object.defineProperty; exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { /* empty */ } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 20 */ /***/ (function(module, exports) { module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () { return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 22 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var document = __webpack_require__(11).document; // typeof document.createElement is 'object' in old IE var is = isObject(document) && isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; }; /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = __webpack_require__(20); // instead of the ES6 spec version, we didn't implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val; if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; throw TypeError("Can't convert object to primitive value"); }; /***/ }), /* 24 */ /***/ (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 25 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var hide = __webpack_require__(17); var has = __webpack_require__(12); var SRC = __webpack_require__(26)('src'); var $toString = __webpack_require__(27); var TO_STRING = 'toString'; var TPL = ('' + $toString).split(TO_STRING); __webpack_require__(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == 'function'; if (isFunction) has(val, 'name') || hide(val, 'name', key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == 'function' && this[SRC] || $toString.call(this); }); /***/ }), /* 26 */ /***/ (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 27 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(28)('native-function-to-string', Function.toString); /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { var core = __webpack_require__(16); var global = __webpack_require__(11); var SHARED = '__core-js_shared__'; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: core.version, mode: __webpack_require__(29) ? 'pure' : 'global', copyright: '© 2019 Denis Pushkarev (zloirock.ru)' }); /***/ }), /* 29 */ /***/ (function(module, exports) { module.exports = false; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { // optional / simple context binding var aFunction = __webpack_require__(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/* ...args */) { return fn.apply(that, arguments); }; }; /***/ }), /* 31 */ /***/ (function(module, exports) { module.exports = function (it) { if (typeof it != 'function') throw TypeError(it + ' is not a function!'); return it; }; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { var META = __webpack_require__(26)('meta'); var isObject = __webpack_require__(20); var has = __webpack_require__(12); var setDesc = __webpack_require__(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !__webpack_require__(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: 'O' + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return 'F'; // not necessary to add metadata if (!create) return 'E'; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze }; /***/ }), /* 33 */ /***/ (function(module, exports, __webpack_require__) { var def = __webpack_require__(18).f; var has = __webpack_require__(12); var TAG = __webpack_require__(34)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { var store = __webpack_require__(28)('wks'); var uid = __webpack_require__(26); var Symbol = __webpack_require__(11).Symbol; var USE_SYMBOL = typeof Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { exports.f = __webpack_require__(34); /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var LIBRARY = __webpack_require__(29); var wksExt = __webpack_require__(35); var defineProperty = __webpack_require__(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); }; /***/ }), /* 37 */ /***/ (function(module, exports, __webpack_require__) { // all enumerable object keys, includes symbols var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(39); var enumBugKeys = __webpack_require__(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { var has = __webpack_require__(12); var toIObject = __webpack_require__(40); var arrayIndexOf = __webpack_require__(44)(false); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys while (names.length > i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(41); var defined = __webpack_require__(43); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = __webpack_require__(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == 'String' ? it.split('') : Object(it); }; /***/ }), /* 42 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); }; /***/ }), /* 43 */ /***/ (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError("Can't call method on " + it); return it; }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { // false -> Array#indexOf // true -> Array#includes var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); var toAbsoluteIndex = __webpack_require__(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length > index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.15 ToLength var toInteger = __webpack_require__(46); var min = Math.min; module.exports = function (it) { return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 }; /***/ }), /* 46 */ /***/ (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it); }; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index < 0 ? max(index + length, 0) : min(index, length); }; /***/ }), /* 48 */ /***/ (function(module, exports, __webpack_require__) { var shared = __webpack_require__(28)('keys'); var uid = __webpack_require__(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); }; /***/ }), /* 49 */ /***/ (function(module, exports) { // IE 8- don't enum bug keys module.exports = ( 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf' ).split(','); /***/ }), /* 50 */ /***/ (function(module, exports) { exports.f = Object.getOwnPropertySymbols; /***/ }), /* 51 */ /***/ (function(module, exports) { exports.f = {}.propertyIsEnumerable; /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.2 IsArray(argument) var cof = __webpack_require__(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == 'Array'; }; /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(19); var dPs = __webpack_require__(54); var enumBugKeys = __webpack_require__(49); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var Empty = function () { /* empty */ }; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(22)('iframe'); var i = enumBugKeys.length; var lt = ''; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(55).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 54 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var anObject = __webpack_require__(19); var getKeys = __webpack_require__(38); module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length > i) dP.f(O, P = keys[i++], Properties[P]); return O; }; /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { var document = __webpack_require__(11).document; module.exports = document && document.documentElement; /***/ }), /* 56 */ /***/ (function(module, exports, __webpack_require__) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = __webpack_require__(40); var gOPN = __webpack_require__(57).f; var toString = {}.toString; var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it)); }; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = __webpack_require__(39); var hiddenKeys = __webpack_require__(49).concat('length', 'prototype'); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); }; /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { var pIE = __webpack_require__(51); var createDesc = __webpack_require__(24); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var IE8_DOM_DEFINE = __webpack_require__(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { /* empty */ } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); }; /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, 'Object', { create: __webpack_require__(53) }); /***/ }), /* 60 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(18).f }); /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(54) }); /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = __webpack_require__(40); var $getOwnPropertyDescriptor = __webpack_require__(58).f; __webpack_require__(63)('getOwnPropertyDescriptor', function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; }); /***/ }), /* 63 */ /***/ (function(module, exports, __webpack_require__) { // most Object methods by ES6 should accept primitives var $export = __webpack_require__(15); var core = __webpack_require__(16); var fails = __webpack_require__(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp); }; /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = __webpack_require__(65); var $getPrototypeOf = __webpack_require__(66); __webpack_require__(63)('getPrototypeOf', function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; }); /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.13 ToObject(argument) var defined = __webpack_require__(43); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = __webpack_require__(12); var toObject = __webpack_require__(65); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; }; /***/ }), /* 67 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 Object.keys(O) var toObject = __webpack_require__(65); var $keys = __webpack_require__(38); __webpack_require__(63)('keys', function () { return function keys(it) { return $keys(toObject(it)); }; }); /***/ }), /* 68 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 Object.getOwnPropertyNames(O) __webpack_require__(63)('getOwnPropertyNames', function () { return __webpack_require__(56).f; }); /***/ }), /* 69 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.5 Object.freeze(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('freeze', function ($freeze) { return function freeze(it) { return $freeze && isObject(it) ? $freeze(meta(it)) : it; }; }); /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.17 Object.seal(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('seal', function ($seal) { return function seal(it) { return $seal && isObject(it) ? $seal(meta(it)) : it; }; }); /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.15 Object.preventExtensions(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('preventExtensions', function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it; }; }); /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.12 Object.isFrozen(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isFrozen', function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; }); /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.13 Object.isSealed(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isSealed', function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; }); /***/ }), /* 74 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.11 Object.isExtensible(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isExtensible', function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; }); /***/ }), /* 75 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.1 Object.assign(target, source) var $export = __webpack_require__(15); $export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) }); /***/ }), /* 76 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.1 Object.assign(target, source, ...) var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || __webpack_require__(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = 'abcdefghijklmnopqrst'; A[S] = 7; K.split('').forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen > index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.10 Object.is(value1, value2) var $export = __webpack_require__(15); $export($export.S, 'Object', { is: __webpack_require__(78) }); /***/ }), /* 78 */ /***/ (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y; }; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = __webpack_require__(15); $export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set }); /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { // Works with __proto__ only. Old v8 can't work with null proto objects. /* eslint-disable no-proto */ var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!"); }; module.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line function (test, buggy, set) { try { set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.__proto__ = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check }; /***/ }), /* 81 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.3.6 Object.prototype.toString() var classof = __webpack_require__(82); var test = {}; test[__webpack_require__(34)('toStringTag')] = 'z'; if (test + '' != '[object z]') { __webpack_require__(25)(Object.prototype, 'toString', function toString() { return '[object ' + classof(this) + ']'; }, true); } /***/ }), /* 82 */ /***/ (function(module, exports, __webpack_require__) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = __webpack_require__(42); var TAG = __webpack_require__(34)('toStringTag'); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == 'Arguments'; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { /* empty */ } }; module.exports = function (it) { var O, T, B; return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B; }; /***/ }), /* 83 */ /***/ (function(module, exports, __webpack_require__) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...) var $export = __webpack_require__(15); $export($export.P, 'Function', { bind: __webpack_require__(84) }); /***/ }), /* 84 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var aFunction = __webpack_require__(31); var isObject = __webpack_require__(20); var invoke = __webpack_require__(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')'); } return factories[len](F, args); }; module.exports = Function.bind || function bind(that /* , ...args */) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/* args... */) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; }; /***/ }), /* 85 */ /***/ (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); }; /***/ }), /* 86 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18).f; var FProto = Function.prototype; var nameRE = /^\s*function ([^ (]*)/; var NAME = 'name'; // 19.2.4.2 name NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, { configurable: true, get: function () { try { return ('' + this).match(nameRE)[1]; } catch (e) { return ''; } } }); /***/ }), /* 87 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(20); var getPrototypeOf = __webpack_require__(66); var HAS_INSTANCE = __webpack_require__(34)('hasInstance'); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V) if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != 'function' || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } }); /***/ }), /* 88 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseInt = __webpack_require__(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt }); /***/ }), /* 89 */ /***/ (function(module, exports, __webpack_require__) { var $parseInt = __webpack_require__(11).parseInt; var $trim = __webpack_require__(90).trim; var ws = __webpack_require__(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10)); } : $parseInt; /***/ }), /* 90 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var defined = __webpack_require__(43); var fails = __webpack_require__(14); var spaces = __webpack_require__(91); var space = '[' + spaces + ']'; var non = '\u200b\u0085'; var ltrim = RegExp('^' + space + space + '*'); var rtrim = RegExp(space + space + '*$'); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spaces[KEY]() || non[KEY]() != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F * FORCE, 'String', exp); }; // 1 -> String#trimLeft // 2 -> String#trimRight // 3 -> String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE & 1) string = string.replace(ltrim, ''); if (TYPE & 2) string = string.replace(rtrim, ''); return string; }; module.exports = exporter; /***/ }), /* 91 */ /***/ (function(module, exports) { module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'; /***/ }), /* 92 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseFloat = __webpack_require__(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat }); /***/ }), /* 93 */ /***/ (function(module, exports, __webpack_require__) { var $parseFloat = __webpack_require__(11).parseFloat; var $trim = __webpack_require__(90).trim; module.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 && string.charAt(0) == '-' ? -0 : result; } : $parseFloat; /***/ }), /* 94 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var has = __webpack_require__(12); var cof = __webpack_require__(42); var inheritIfRequired = __webpack_require__(95); var toPrimitive = __webpack_require__(23); var fails = __webpack_require__(14); var gOPN = __webpack_require__(57).f; var gOPD = __webpack_require__(58).f; var dP = __webpack_require__(18).f; var $trim = __webpack_require__(90).trim; var NUMBER = 'Number'; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER; var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == 'string' && it.length > 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code < 48 || code > maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) { $Number = function Number(value) { var it = arguments.length < 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = __webpack_require__(13) ? gOPN(Base) : ( // ES3: 'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before): 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger' ).split(','), j = 0, key; keys.length > j; j++) { if (has(Base, key = keys[j]) && !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; __webpack_require__(25)(global, NUMBER, $Number); } /***/ }), /* 95 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var setPrototypeOf = __webpack_require__(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) { setPrototypeOf(that, P); } return that; }; /***/ }), /* 96 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toInteger = __webpack_require__(46); var aNumberValue = __webpack_require__(97); var repeat = __webpack_require__(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = 'Number.toFixed: incorrect invocation!'; var ZERO = '0'; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i < 6) { c2 += n * data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (--i >= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) * 1e7; } }; var numToString = function () { var i = 6; var s = ''; while (--i >= 0) { if (s !== '' || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 >= 4096) { n += 12; x2 /= 4096; } while (x2 >= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F * (!!$toFixed && ( 0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128' ) || !__webpack_require__(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), 'Number', { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ''; var m = ZERO; var e, z, j, k; if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return 'NaN'; if (x = 1e21) return String(x); if (x < 0) { s = '-'; x = -x; } if (x > 1e-21) { e = log(x * pow(2, 69, 1)) - 69; z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1); z *= 0x10000000000000; e = 52 - e; if (e > 0) { multiply(0, z); j = f; while (j >= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j >= 23) { divide(1 < 23); j -= 23; } divide(1 < j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 < -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f > 0) { k = m.length; m = s + (k -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x); }; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.5 Math.asinh(x) var $export = __webpack_require__(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1)); } // Tor Browser bug: Math.asinh(0) -> -0 $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh }); /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.7 Math.atanh(x) var $export = __webpack_require__(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0 $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } }); /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.9 Math.cbrt(x) var $export = __webpack_require__(15); var sign = __webpack_require__(115); $export($export.S, 'Math', { cbrt: function cbrt(x) { return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3); } }); /***/ }), /* 115 */ /***/ (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1; }; /***/ }), /* 116 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.11 Math.clz32(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { clz32: function clz32(x) { return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32; } }); /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.12 Math.cosh(x) var $export = __webpack_require__(15); var exp = Math.exp; $export($export.S, 'Math', { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } }); /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.14 Math.expm1(x) var $export = __webpack_require__(15); var $expm1 = __webpack_require__(119); $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 }); /***/ }), /* 119 */ /***/ (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1; } : $expm1; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { fround: __webpack_require__(121) }); /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var sign = __webpack_require__(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) * (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32; a = (1 + EPSILON32 / EPSILON) * $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result > MAX32 || result != result) return $sign * Infinity; return $sign * result; }; /***/ }), /* 122 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = __webpack_require__(15); var abs = Math.abs; $export($export.S, 'Math', { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i < aLen) { arg = abs(arguments[i++]); if (larg < arg) { div = larg / arg; sum = sum * div * div + 1; larg = arg; } else if (arg > 0) { div = arg / larg; sum += div * div; } else sum += arg; } return larg === Infinity ? Infinity : larg * Math.sqrt(sum); } }); /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.18 Math.imul(x, y) var $export = __webpack_require__(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F * __webpack_require__(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), 'Math', { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 & xn; var yl = UINT16 & yn; return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) < 16 >>> 0); } }); /***/ }), /* 124 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.21 Math.log10(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log10: function log10(x) { return Math.log(x) * Math.LOG10E; } }); /***/ }), /* 125 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.20 Math.log1p(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log1p: __webpack_require__(111) }); /***/ }), /* 126 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.22 Math.log2(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log2: function log2(x) { return Math.log(x) / Math.LN2; } }); /***/ }), /* 127 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.28 Math.sign(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { sign: __webpack_require__(115) }); /***/ }), /* 128 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.30 Math.sinh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F * __webpack_require__(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), 'Math', { sinh: function sinh(x) { return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2); } }); /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.33 Math.tanh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; $export($export.S, 'Math', { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } }); /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.34 Math.trunc(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { trunc: function trunc(it) { return (it > 0 ? Math.floor : Math.ceil)(it); } }); /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toAbsoluteIndex = __webpack_require__(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', { // 21.1.2.2 String.fromCodePoint(...codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen > i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point'); res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(''); } }); /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); $export($export.S, 'String', { // 21.1.2.4 String.raw(callSite, ...substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len > i) { res.push(String(tpl[i++])); if (i < aLen) res.push(String(arguments[i])); } return res.join(''); } }); /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.1.3.25 String.prototype.trim() __webpack_require__(90)('trim', function ($trim) { return function trim() { return $trim(this, 3); }; }); /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $at = __webpack_require__(135)(true); // 21.1.3.27 String.prototype[@@iterator]() __webpack_require__(136)(String, 'String', function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index >= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; }); /***/ }), /* 135 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var defined = __webpack_require__(43); // true -> String#at // false -> String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i < 0 || i >= l) return TO_STRING ? '' : undefined; a = s.charCodeAt(i); return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 < 10) + (b - 0xdc00) + 0x10000; }; }; /***/ }), /* 136 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var LIBRARY = __webpack_require__(29); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var $iterCreate = __webpack_require__(138); var setToStringTag = __webpack_require__(33); var getPrototypeOf = __webpack_require__(66); var ITERATOR = __webpack_require__(34)('iterator'); var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next` var FF_ITERATOR = '@@iterator'; var KEYS = 'keys'; var VALUES = 'values'; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY && kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ' Iterator'; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined; var $anyNative = NAME == 'Array' ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES && $native && $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods); } return methods; }; /***/ }), /* 137 */ /***/ (function(module, exports) { module.exports = {}; /***/ }), /* 138 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var create = __webpack_require__(53); var descriptor = __webpack_require__(24); var setToStringTag = __webpack_require__(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]() __webpack_require__(17)(IteratorPrototype, __webpack_require__(34)('iterator'), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ' Iterator'); }; /***/ }), /* 139 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $at = __webpack_require__(135)(false); $export($export.P, 'String', { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } }); /***/ }), /* 140 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var ENDS_WITH = 'endsWith'; var $endsWith = ''[ENDS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', { endsWith: function endsWith(searchString /* , endPosition = @length */) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length > 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } }); /***/ }), /* 141 */ /***/ (function(module, exports, __webpack_require__) { // helper for String#{startsWith, endsWith, includes} var isRegExp = __webpack_require__(142); var defined = __webpack_require__(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!"); return String(defined(that)); }; /***/ }), /* 142 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.8 IsRegExp(argument) var isObject = __webpack_require__(20); var cof = __webpack_require__(42); var MATCH = __webpack_require__(34)('match'); module.exports = function (it) { var isRegExp; return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp'); }; /***/ }), /* 143 */ /***/ (function(module, exports, __webpack_require__) { var MATCH = __webpack_require__(34)('match'); module.exports = function (KEY) { var re = /./; try { '/./'[KEY](re); } catch (e) { try { re[MATCH] = false; return !'/./'[KEY](re); } catch (f) { /* empty */ } } return true; }; /***/ }), /* 144 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) 'use strict'; var $export = __webpack_require__(15); var context = __webpack_require__(141); var INCLUDES = 'includes'; $export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', { includes: function includes(searchString /* , position = 0 */) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined); } }); /***/ }), /* 145 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.P, 'String', { // 21.1.3.13 String.prototype.repeat(count) repeat: __webpack_require__(98) }); /***/ }), /* 146 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var STARTS_WITH = 'startsWith'; var $startsWith = ''[STARTS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', { startsWith: function startsWith(searchString /* , position = 0 */) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } }); /***/ }), /* 147 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // B.2.3.2 String.prototype.anchor(name) __webpack_require__(148)('anchor', function (createHTML) { return function anchor(name) { return createHTML(this, 'a', 'name', name); }; }); /***/ }), /* 148 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ' Array#map // 2 -> Array#filter // 3 -> Array#some // 4 -> Array#every // 5 -> Array#find // 6 -> Array#findIndex var ctx = __webpack_require__(30); var IObject = __webpack_require__(41); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var asc = __webpack_require__(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length > index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; }; /***/ }), /* 182 */ /***/ (function(module, exports, __webpack_require__) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = __webpack_require__(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); }; /***/ }), /* 183 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var isArray = __webpack_require__(52); var SPECIES = __webpack_require__(34)('species'); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; }; /***/ }), /* 184 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $map = __webpack_require__(181)(1); $export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn /* , thisArg */) { return $map(this, callbackfn, arguments[1]); } }); /***/ }), /* 185 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $filter = __webpack_require__(181)(2); $export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn /* , thisArg */) { return $filter(this, callbackfn, arguments[1]); } }); /***/ }), /* 186 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $some = __webpack_require__(181)(3); $export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn /* , thisArg */) { return $some(this, callbackfn, arguments[1]); } }); /***/ }), /* 187 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $every = __webpack_require__(181)(4); $export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn /* , thisArg */) { return $every(this, callbackfn, arguments[1]); } }); /***/ }), /* 188 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } }); /***/ }), /* 189 */ /***/ (function(module, exports, __webpack_require__) { var aFunction = __webpack_require__(31); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var toLength = __webpack_require__(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen < 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index < 0 : length = 0 : length > index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; }; /***/ }), /* 190 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } }); /***/ }), /* 191 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $indexOf = __webpack_require__(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement /* , fromIndex = 0 */) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } }); /***/ }), /* 192 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1])); if (index < 0) index = length + index; for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } }); /***/ }), /* 193 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { copyWithin: __webpack_require__(194) }); __webpack_require__(195)('copyWithin'); /***/ }), /* 194 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length > 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from < to && to < from + count) { inc = -1; from += count - 1; to += count - 1; } while (count-- > 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; }; /***/ }), /* 195 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = __webpack_require__(34)('unscopables'); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; }; /***/ }), /* 196 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { fill: __webpack_require__(197) }); __webpack_require__(195)('fill'); /***/ }), /* 197 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = function fill(value /* , start = 0, end = @length */) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length); var end = aLen > 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos > index) O[index++] = value; return O; }; /***/ }), /* 198 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(5); var KEY = 'find'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { find: function find(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 199 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(6); var KEY = 'findIndex'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { findIndex: function findIndex(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 200 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(201)('Array'); /***/ }), /* 201 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var dP = __webpack_require__(18); var DESCRIPTORS = __webpack_require__(13); var SPECIES = __webpack_require__(34)('species'); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); }; /***/ }), /* 202 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var addToUnscopables = __webpack_require__(195); var step = __webpack_require__(203); var Iterators = __webpack_require__(137); var toIObject = __webpack_require__(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype[@@iterator]() module.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index >= O.length) { this._t = undefined; return step(1); } if (kind == 'keys') return step(0, index); if (kind == 'values') return step(0, O[index]); return step(0, [index, O[index]]); }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries'); /***/ }), /* 203 */ /***/ (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; }; /***/ }), /* 204 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var inheritIfRequired = __webpack_require__(95); var dP = __webpack_require__(18).f; var gOPN = __webpack_require__(57).f; var isRegExp = __webpack_require__(142); var $flags = __webpack_require__(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // "new" creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(14)(function () { re2[__webpack_require__(34)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i'; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; __webpack_require__(25)(global, 'RegExp', $RegExp); } __webpack_require__(201)('RegExp'); /***/ }), /* 205 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.2.5.3 get RegExp.prototype.flags var anObject = __webpack_require__(19); module.exports = function () { var that = anObject(this); var result = ''; if (that.global) result += 'g'; if (that.ignoreCase) result += 'i'; if (that.multiline) result += 'm'; if (that.unicode) result += 'u'; if (that.sticky) result += 'y'; return result; }; /***/ }), /* 206 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpExec = __webpack_require__(207); __webpack_require__(15)({ target: 'RegExp', proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec }); /***/ }), /* 207 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpFlags = __webpack_require__(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = 'lastIndex'; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b*/g; nativeExec.call(re1, 'a'); nativeExec.call(re2, 'a'); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim's String#split patch. var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG && match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED && match && match.length > 1) { // Fix browsers whose `exec` methods don't consistently return `undefined` // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i < arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec; /***/ }), /* 208 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(209); var anObject = __webpack_require__(19); var $flags = __webpack_require__(205); var DESCRIPTORS = __webpack_require__(13); var TO_STRING = 'toString'; var $toString = /./[TO_STRING]; var define = function (fn) { __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (__webpack_require__(14)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) { define(function toString() { var R = anObject(this); return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); } /***/ }), /* 209 */ /***/ (function(module, exports, __webpack_require__) { // 21.2.5.3 get RegExp.prototype.flags() if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(18).f(RegExp.prototype, 'flags', { configurable: true, get: __webpack_require__(205) }); /***/ }), /* 210 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toLength = __webpack_require__(45); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); // @@match logic __webpack_require__(213)('match', 1, function (defined, MATCH, $match, maybeCallNative) { return [ // `String.prototype.match` method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O)); }, // `RegExp.prototype[@@match]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; }); /***/ }), /* 211 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var at = __webpack_require__(135)(true); // `AdvanceStringIndex` abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); }; /***/ }), /* 212 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var classof = __webpack_require__(82); var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === 'function') { var result = exec.call(R, S); if (typeof result !== 'object') { throw new TypeError('RegExp exec method returned something other than an Object or null'); } return result; } if (classof(R) !== 'RegExp') { throw new TypeError('RegExp#exec called on incompatible receiver'); } return builtinExec.call(R, S); }; /***/ }), /* 213 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(206); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var wks = __webpack_require__(34); var regexpExec = __webpack_require__(207); var SPECIES = wks('species'); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a "grops" property. var re = /./; re.exec = function () { var result = []; result.groups = { a: '7' }; return result; }; return ''.replace(re, '$') !== '7'; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = 'ab'.split(re); return result.length === 2 && result[0] === 'a' && result[1] === 'b'; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ''[KEY](O) != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === 'split') { // RegExp[@@split] doesn't call the regex's exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } re[SYMBOL](''); return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL && !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue) // 21.2.5.11 RegExp.prototype[@@split](string, limit) ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype[@@match](string) // 21.2.5.9 RegExp.prototype[@@search](string) : function (string) { return rxfn.call(string, this); } ); } }; /***/ }), /* 214 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|]*>)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ // `String.prototype.replace` method // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, // `RegExp.prototype[@@replace]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === 'function'; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = ''; var nextSourcePosition = 0; for (var i = 0; i < results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reason `nativeSlice.call(result, 1, result.length)` (called in // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position >= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case '$': return '$'; case '&': return matched; case '`': return str.slice(0, position); case "'": return str.slice(tailPos); case '>> 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q < S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i 0; m = m * 256 + buffer[i], i--, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) * m * pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] < 24 | bytes[2] < 16 | bytes[1] < 8 | bytes[0]; } function packI8(it) { return [it & 0xff]; } function packI16(it) { return [it & 0xff, it >> 8 & 0xff]; } function packI32(it) { return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!'); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, '_l'); addGetter($DataView, BUFFER, '_b'); addGetter($DataView, BYTE_LENGTH, '_l'); addGetter($DataView, BYTE_OFFSET, '_o'); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] < 24 >> 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] < 8 | bytes[0]) < 16 >> 16; }, getUint16: function getUint16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] < 8 | bytes[0]; }, getInt32: function getInt32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0; }, getFloat32: function getFloat32(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView; /***/ }), /* 239 */ /***/ (function(module, exports, __webpack_require__) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError('Wrong length!'); return length; }; /***/ }), /* 240 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.G + $export.W + $export.F * !__webpack_require__(237).ABV, { DataView: __webpack_require__(238).DataView }); /***/ }), /* 241 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int8', 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 242 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; if (__webpack_require__(13)) { var LIBRARY = __webpack_require__(29); var global = __webpack_require__(11); var fails = __webpack_require__(14); var $export = __webpack_require__(15); var $typed = __webpack_require__(237); var $buffer = __webpack_require__(238); var ctx = __webpack_require__(30); var anInstance = __webpack_require__(219); var propertyDesc = __webpack_require__(24); var hide = __webpack_require__(17); var redefineAll = __webpack_require__(227); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var toIndex = __webpack_require__(239); var toAbsoluteIndex = __webpack_require__(47); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var classof = __webpack_require__(82); var isObject = __webpack_require__(20); var toObject = __webpack_require__(65); var isArrayIter = __webpack_require__(171); var create = __webpack_require__(53); var getPrototypeOf = __webpack_require__(66); var gOPN = __webpack_require__(57).f; var getIterFn = __webpack_require__(173); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var createArrayMethod = __webpack_require__(181); var createArrayIncludes = __webpack_require__(44); var speciesConstructor = __webpack_require__(217); var ArrayIterators = __webpack_require__(202); var Iterators = __webpack_require__(137); var $iterDetect = __webpack_require__(174); var setSpecies = __webpack_require__(201); var arrayFill = __webpack_require__(197); var arrayCopyWithin = __webpack_require__(194); var $DP = __webpack_require__(18); var $GOPD = __webpack_require__(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = 'ArrayBuffer'; var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER; var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'; var PROTOTYPE = 'prototype'; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks('iterator'); var TAG = wks('toStringTag'); var TYPED_CONSTRUCTOR = uid('typed_constructor'); var DEF_CONSTRUCTOR = uid('def_constructor'); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = 'Wrong length!'; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!'); return offset; }; var validate = function (it) { if (isObject(it) && TYPED_ARRAY in it) return it; throw TypeError(it + ' is not a typed array!'); }; var allocate = function (C, length) { if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) { throw TypeError('It is not a typed array constructor!'); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length > index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source /* , mapfn, thisArg */) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen > 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined && !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/* ...items */) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length > index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start /* , end */) { return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined); }, every: function every(callbackfn /* , thisArg */) { return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn /* , thisArg */) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)); }, find: function find(predicate /* , thisArg */) { return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate /* , thisArg */) { return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn /* , thisArg */) { arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement /* , fromIndex */) { return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, includes: function includes(searchElement /* , fromIndex */) { return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn /* , thisArg */) { return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index < middle) { value = that[index]; that[index++] = that[--length]; that[length] = value; } return that; }, some: function some(callbackfn /* , thisArg */) { return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike /* , offset */) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset > length) throw RangeError(WRONG_LENGTH); while (index < len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { /* noop */ }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, 'buffer', 'b'); addGetter($TypedArrayPrototype$, 'byteOffset', 'o'); addGetter($TypedArrayPrototype$, 'byteLength', 'l'); addGetter($TypedArrayPrototype$, 'length', 'e'); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'; var GETTER = 'get' + KEY; var SETTER = 'set' + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray && getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff; data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN); }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, '_d'); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length * BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength < 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) * BYTES; if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, '_d', { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index < length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, 'constructor', TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // `ws` module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F * (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F * FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F * fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F * (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { /* empty */ }; /***/ }), /* 243 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 244 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true); /***/ }), /* 245 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int16', 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 246 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint16', 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 247 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int32', 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 248 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint32', 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 249 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float32', 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 250 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float64', 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 251 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = __webpack_require__(15); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var rApply = (__webpack_require__(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F * !__webpack_require__(14)(function () { rApply(function () { /* empty */ }); }), 'Reflect', { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } }); /***/ }), /* 252 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = __webpack_require__(15); var create = __webpack_require__(53); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var fails = __webpack_require__(14); var bind = __webpack_require__(84); var rConstruct = (__webpack_require__(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as `new.target`, but does not create `this` from it var NEW_TARGET_BUG = fails(function () { function F() { /* empty */ } return !(rConstruct(function () { /* empty */ }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { /* empty */ }); }); $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', { construct: function construct(Target, args /* , newTarget */) { aFunction(Target); anObject(args); var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } }); /***/ }), /* 253 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = __webpack_require__(18); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var toPrimitive = __webpack_require__(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F * __webpack_require__(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), 'Reflect', { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } }); /***/ }), /* 254 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = __webpack_require__(15); var gOPD = __webpack_require__(58).f; var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc && !desc.configurable ? false : delete target[propertyKey]; } }); /***/ }), /* 255 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 26.1.5 Reflect.enumerate(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; __webpack_require__(138)(Enumerate, 'Object', function () { var that = this; var keys = that._k; var key; do { if (that._i >= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, 'Reflect', { enumerate: function enumerate(target) { return new Enumerate(target); } }); /***/ }), /* 256 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); function get(target, propertyKey /* , receiver */) { var receiver = arguments.length < 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, 'Reflect', { get: get }); /***/ }), /* 257 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = __webpack_require__(58); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } }); /***/ }), /* 258 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = __webpack_require__(15); var getProto = __webpack_require__(66); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } }); /***/ }), /* 259 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.9 Reflect.has(target, propertyKey) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { has: function has(target, propertyKey) { return propertyKey in target; } }); /***/ }), /* 260 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.10 Reflect.isExtensible(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $isExtensible = Object.isExtensible; $export($export.S, 'Reflect', { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } }); /***/ }), /* 261 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.11 Reflect.ownKeys(target) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { ownKeys: __webpack_require__(262) }); /***/ }), /* 262 */ /***/ (function(module, exports, __webpack_require__) { // all object keys, includes non-enumerable and symbols var gOPN = __webpack_require__(57); var gOPS = __webpack_require__(50); var anObject = __webpack_require__(19); var Reflect = __webpack_require__(11).Reflect; module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; }; /***/ }), /* 263 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.12 Reflect.preventExtensions(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $preventExtensions = Object.preventExtensions; $export($export.S, 'Reflect', { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } }); /***/ }), /* 264 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = __webpack_require__(18); var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var createDesc = __webpack_require__(24); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); function set(target, propertyKey, V /* , receiver */) { var receiver = arguments.length < 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, 'value')) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, 'Reflect', { set: set }); /***/ }), /* 265 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = __webpack_require__(15); var setProto = __webpack_require__(80); if (setProto) $export($export.S, 'Reflect', { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } }); /***/ }), /* 266 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/Array.prototype.includes var $export = __webpack_require__(15); var $includes = __webpack_require__(44)(true); $export($export.P, 'Array', { includes: function includes(el /* , fromIndex = 0 */) { return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)('includes'); /***/ }), /* 267 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var aFunction = __webpack_require__(31); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatMap: function flatMap(callbackfn /* , thisArg */) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); __webpack_require__(195)('flatMap'); /***/ }), /* 268 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = __webpack_require__(52); var isObject = __webpack_require__(20); var toLength = __webpack_require__(45); var ctx = __webpack_require__(30); var IS_CONCAT_SPREADABLE = __webpack_require__(34)('isConcatSpreadable'); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex < sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable && depth > 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex >= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray; /***/ }), /* 269 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatten: function flatten(/* depthArg = 1 */) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); __webpack_require__(195)('flatten'); /***/ }), /* 270 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/mathiasbynens/String.prototype.at var $export = __webpack_require__(15); var $at = __webpack_require__(135)(true); $export($export.P, 'String', { at: function at(pos) { return $at(this, pos); } }); /***/ }), /* 271 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-string-pad-start-end var $export = __webpack_require__(15); var $pad = __webpack_require__(272); var userAgent = __webpack_require__(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F * WEBKIT_BUG, 'String', { padStart: function padStart(maxLength /* , fillString = ' ' */) { return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true); } }); /***/ }), /* 272 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = __webpack_require__(45); var repeat = __webpack_require__(98); var defined = __webpack_require__(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ' ' : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength 0; var $y0 = y0 >>> 0; return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0; } }); /***/ }), /* 311 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 >>> 0; var $x1 = x1 >>> 0; var $y0 = y0 >>> 0; return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0; } }); /***/ }), /* 312 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >> 16; var v1 = $v >> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16); } }); /***/ }), /* 313 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI }); /***/ }), /* 314 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, 'Math', { radians: function radians(degrees) { return degrees * DEG_PER_RAD; } }); /***/ }), /* 315 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { scale: __webpack_require__(309) }); /***/ }), /* 316 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >>> 16; var v1 = $v >>> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16); } }); /***/ }), /* 317 */ /***/ (function(module, exports, __webpack_require__) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = __webpack_require__(15); $export($export.S, 'Math', { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0; } }); /***/ }), /* 318 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-promise-finally 'use strict'; var $export = __webpack_require__(15); var core = __webpack_require__(16); var global = __webpack_require__(11); var speciesConstructor = __webpack_require__(217); var promiseResolve = __webpack_require__(226); $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == 'function'; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } }); /***/ }), /* 319 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-promise-try var $export = __webpack_require__(15); var newPromiseCapability = __webpack_require__(223); var perform = __webpack_require__(224); $export($export.S, 'Promise', { 'try': function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } }); /***/ }), /* 320 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } }); /***/ }), /* 321 */ /***/ (function(module, exports, __webpack_require__) { var Map = __webpack_require__(228); var $export = __webpack_require__(15); var shared = __webpack_require__(28)('metadata'); var store = shared.store || (shared.store = new (__webpack_require__(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == 'symbol' ? it : String(it); }; var exp = function (O) { $export($export.S, 'Reflect', O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp }; /***/ }), /* 322 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) { var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata['delete'](targetKey); return !!targetMetadata.size || store['delete'](target); } }); /***/ }), /* 323 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 324 */ /***/ (function(module, exports, __webpack_require__) { var Set = __webpack_require__(232); var from = __webpack_require__(290); var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) { return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 325 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 326 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 327 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 328 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 329 */ /***/ (function(module, exports, __webpack_require__) { var $metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var aFunction = __webpack_require__(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } }); /***/ }), /* 330 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = __webpack_require__(15); var microtask = __webpack_require__(222)(); var process = __webpack_require__(11).process; var isNode = __webpack_require__(42)(process) == 'process'; $export($export.G, { asap: function asap(fn) { var domain = isNode && process.domain; microtask(domain ? domain.bind(fn) : fn); } }); /***/ }), /* 331 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/zenparsing/es-observable var $export = __webpack_require__(15); var global = __webpack_require__(11); var core = __webpack_require__(16); var microtask = __webpack_require__(222)(); var OBSERVABLE = __webpack_require__(34)('observable'); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var anInstance = __webpack_require__(219); var redefineAll = __webpack_require__(227); var hide = __webpack_require__(17); var forOf = __webpack_require__(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === 'function' ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++]; return new (typeof this === 'function' ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j < items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); __webpack_require__(201)('Observable'); /***/ }), /* 332 */ /***/ (function(module, exports, __webpack_require__) { // ie9- setTimeout & setInterval additional parameters fix var global = __webpack_require__(11); var $export = __webpack_require__(15); var userAgent = __webpack_require__(225); var slice = [].slice; var MSIE = /MSIE .\./.test(userAgent); // 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == 'function' ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F * MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) }); /***/ }), /* 333 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $task = __webpack_require__(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear }); /***/ }), /* 334 */ /***/ (function(module, exports, __webpack_require__) { var $iterators = __webpack_require__(202); var getKeys = __webpack_require__(38); var redefine = __webpack_require__(25); var global = __webpack_require__(11); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var wks = __webpack_require__(34); var ITERATOR = wks('iterator'); var TO_STRING_TAG = wks('toStringTag'); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } } /***/ }), /* 335 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) {/** * Copyright (c) 2014, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * https://raw.github.com/facebook/regenerator/master/LICENSE file. An * additional grant of patent rights can be found in the PATENTS file in * the same directory. */ !(function(global) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; var inModule = typeof module === "object"; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we're in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don't bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we're in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there's no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don't have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don't natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = "GeneratorFunction"; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, "__await")` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { __await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && typeof value === "object" && hasOwn.call(value, "__await")) { return Promise.resolve(value.__await).then(function(value) { invoke("next", value, resolve, reject); }, function(err) { invoke("throw", err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === "object" && global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { // Setting context._sent for legacy support of Babel's // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = "throw"; context.arg = record.arg; } } }; } // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === "throw") { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { // If maybeInvokeDelegate(context) changed context.method from // "return" to "throw", let that override the TypeError below. return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError( "The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was "next", forget context.arg since it has been // "consumed" by the delegate iterator. If context.method was // "return", allow the original .return call to continue in the // outer generator. if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers' implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn't happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel's // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = "next"; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle("end"); } if (entry.tryLoc]]></content>
      <categories>
        <category>Project Experience</category>
      </categories>
      <tags>
        <tag>Project Experience</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是字符串相关题目题解总结。 test 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑’*’： 如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符’‘考虑进去，它可以匹配任意次的字符，当然出现0次也可以： 而当模式中的第二个字符是时： 如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 1. 模式后移2字符，相当于x*被忽略； 2. 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 3. 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符&#39;.&#39;的情况。 1. 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为&#39;.&#39;的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 2. 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1.1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = left+(right-left)//2 if data[mid] == k: temp = 0 for i in range(left, right+1): if data[i] == k: temp += 1 return temp elif data[mid] &lt; k: left += 1 else: right -= 1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 0: return False Dict = &#123;&#125; for i in range(len(numbers)): if numbers[i] not in Dict: Dict[numbers[i]] = 1 else: Dict[numbers[i]] += 1 if Dict[numbers[i]] == 2: duplication[0] = numbers[i] return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1—&gt;0k+2—&gt;1n-1 —&gt; n-k-20 — &gt; n-k-1 k-1 —&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # 思路1 # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res # 思路2 res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) —&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
