<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习-模型评估]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-模型评估相关内容。 1 模型评估定义模型评估主要分为离线评估和在线评估两个阶段。针对分类、排序、回归、序列预测等不同类型的机器学习问题，评估指标的选择也有所不同。 2 准确率的局限性准确率是指分类正确的样本占总样本个数的比例，即 $accuracy=n_{correct} / n_{total}$ ，其中 $n_{correct}$ 为被正确分类的样本个数，$n_{total}$ 为总样本的个数。 准确率是分类问题中最简单也是最直观的评价指标，但存在明显的缺陷。比如，当负样本占99%时，分类器把所有样本都预测为负样本也可以获得99%的准确率。所以，当不同类别的样本比例非常不均衡时，占比大的类别往往成为影响准确率的最主要因素。为了解决这个问题，可以使用更为有效的平均准确率（每个类别下的样本准确率的算术平均）作为模型评估的指标。 3 精确率与召回率的权衡。精确率是指分类正确的正样本个数占分类器判定为正样本的样本个数的比例。召回率是指分类正确的正样本个数占真正的正样本个数的比例。 Precision值和Recall值是既矛盾又统一的两个指标，为了提高Precision值，分类器需要尽量在“更有把握”时才把样本预测为正样本，但此时往往会因为过于保守而漏掉很多“没有把握”的正样本，导致Recall值降低。 为了综合评估一个排序模型的好坏，不仅要看模型在不同TopN下的Precision@N和Recall@N，而且最好绘制出模型的P-R（PrecisionRecall）曲线。P-R曲线的横轴是召回率，纵轴是精确率。对于一个排序模型来说，其P-R曲线上的一个点代表着，在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本，此时返回结果对应的召回率和精确率。整条P-R曲线是通过将阈值从高到低移动而生成的。 F1score和ROC曲线也能综合地反映一个排序模型的性能。F1score是精准率和召回率的调和平均值，定义为 \mathrm{Fl}=\frac{2 \times \text { precision } \times \text { recall}}{\text {precision}+\text {recall}}4 什么是ROC曲线ROC曲线是Receiver Operating Characteristic Curve的简称，中文名为“受试者工作特征曲线”。ROC曲线源于军事领域，而后在医学领域应用甚广，“受试者工作特征曲线”这一名称也正是来自于医学领域。ROC曲线的横坐标为假阳性率（False Positive Rate，FPR）；纵坐标为真阳性率（True Positive Rate，TPR）。FPR和TPR的计算方法分别为FPR=FP/N,TPR=TP/P，上式中，P是真实的正样本的数量，N是真实的负样本的数量，TP是P个正样本中被分类器预测为正样本的个数，FP是N个负样本中被分类器预测为正样本的个数。 只看定义确实有点绕，为了更直观地说明这个问题，我们举一个医院诊断病人的例子。假设有10位疑似癌症患者，其中有3位很不幸确实患了癌症（P=3），另外7位不是癌症患者（N=7）。医院对这10位疑似患者做了诊断，诊断出3位癌症患者，其中有2位确实是真正的患者（TP=2）。那么真阳性率TPR=TP/P=2/3。对于7位非癌症患者来说，有一位很不幸被误诊为癌症患者（FP=1），那么假阳性率FPR=FP/N=1/7。对于“该医院”这个分类器来说，这组分类结果就对应ROC曲线上的一个点（1/7，2/3）。 5 如何绘制ROC曲线首先，根据样本标签统计出正负样本的数量，假设正样本数量为P，负样本数量为N；接下来，把横轴的刻度间隔设置为1/N，纵轴的刻度间隔设置为1/P；再根据模型输出的预测概率对样本进行排序（从高到低）；依次遍历样本，同时从零点开始绘制ROC曲线，每遇到一个正样本就沿纵轴方向绘制一个刻度间隔的曲线，每遇到一个负样本就沿横轴方向绘制一个刻度间隔的曲线，直到遍历完所有样本，曲线最终停在（1,1）这个点，整个ROC曲线绘制完成。 6 如何计算AUCAUC指的是ROC曲线下的面积大小，该值能够量化地反映基于ROC曲线衡量出的模型性能。计算AUC值只需要沿着ROC横轴做积分就可以了。由于ROC曲线一般都处于y=x这条直线的上方（如果不是的话，只要把模型预测的概率反转成1−p就可以得到一个更好的分类器），所以AUC的取值一般在0.5～1之间。AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好。 更优雅的解释，auc是指随机给定一个正样本和一个负样本，分类器输出该正样本为正的概率值比分类器输出该负样本为正的概率值要大的可能性。 7 ROC曲线相比P-R曲线有什么特点相比P-R曲线，ROC曲线有一个特点，当正负样本的分布发生变化时，ROC曲线的形状能够基本保持不变，而P-R曲线的形状一般会发生较剧烈的变化。这个特点让ROC曲线能够尽量降低不同测试集带来的干扰，更加客观地衡量模型本身的性能。这有什么实际意义呢？在很多实际问题中，正负样本数量往往很不均衡。比如，计算广告领域经常涉及转化率模型，正样本的数量往往是负样本数量的1/1000甚至1/10000。若选择不同的测试集，P-R曲线的变化就会非常大，而ROC曲线则能够更加稳定地反映模型本身的好坏。所以，ROC曲线的适用场景更多，被广泛用于排序、推荐、广告等领域。但需要注意的是，选择P-R曲线还是ROC曲线是因实际问题而异的，如果研究者希望更多地看到模型在特定数据集上的表现，P-R曲线则能够更直观地反映其性能。 8 平方根误差的“意外”。我们希望构建一个回归模型来预测某部美剧的流量趋势，但无论采用哪种回归模型，得到的RMSE指标都非常高。然而事实是，模型在95%的时间区间内的预测误差都小于1%，取得了相当不错的预测结果。那么，造成RMSE指标居高不下的最可能的原因是什么？ RMSE的计算公式为 R M S E=\sqrt{\frac{\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}}{n}}其中，$y_i$是第$i$个样本点的真实值，$\hat{y}_{i}$是第$i$个样本点的预测值，$n$是样本点的个数。一般情况下，RMSE能够很好地反映回归模型预测值与真实值的偏离程度。但在实际问题中，如果存在个别偏离程度非常大的离群点（Outlier）时，即使离群点数量非常少，也会让RMSE指标变得很差。回到问题中来，模型在95%的时间区间内的预测误差都小于1%，这说明，在大部分时间区间内，模型的预测效果都是非常优秀的。然而，RMSE却一直很差，这很可能是由于在其他的5%时间区间内存在非常严重的离群点。 解决方案：第一，如果我们认定这些离群点是“噪声点”的话，就需要在数据预处理的阶段把这些噪声点过滤掉。第二，如果不认为这些离群点是“噪声点”的话，就需要进一步提高模型的预测能力，将离群点产生的机制建模进去。第三，可以找一个更合适的指标来评估该模型。关于评估指标，其实是存在比RMSE的鲁棒性更好的指标，比如平均绝对百分比误差（Mean Absolute Percent Error，MAPE），它定义为 M A P E=\sum_{i=1}^{n}\left|\frac{y_{i}-\hat{y}_{i}}{y_{i}}\right| \times \frac{100}{n}相比RMSE，MAPE相当于把每个点的误差进行了归一化，降低了个别离群点带来的绝对误差的影响。 9 余弦距离的定义在机器学习问题中，通常将特征表示为向量的形式，所以在分析两个特征向量之间的相似性时，常使用余弦相似度来表示。余弦相似度的取值范围是$[−1,1]$，相同的两个向量之间的相似度为1。如果希望得到类似于距离的表示，将1减去余弦相似度即为余弦距离。因此，余弦距离的取值范围为$[0,2]$，相同的两个向量余弦距离为0。 10 为什么在一些场景中要使用余弦相似度而不是欧氏距离？对于两个向量A和B，其余弦相似度定义为 \cos (\theta)=\frac{A \cdot B}{\|A\|\|B\|}=\frac{\sum_{i=1}^{n} A_{i} \times B_{i}}{\sqrt{\sum_{i=1}^{n}\left(A_{i}\right)^{2}} \times \sqrt{\sum_{i=1}^{n}\left(B_{i}\right)^{2}}}即两个向量夹角的余弦，关注的是向量之间的角度关系，并不关心它们的绝对大小，其取值范围是[−1,1]。当一对文本相似度的长度差距很大、但内容相近时，如果使用词频或词向量作为特征，它们在特征空间中的的欧氏距离通常很大；而如果使用余弦相似度的话，它们之间的夹角可能很小，因而相似度高。此外，在文本、图像、视频等领域，研究的对象的特征维度往往很高，余弦相似度在高维情况下依然保持“相同时为1，正交时为0，相反时为−1”的性质，而欧氏距离的数值则受维度的影响，范围不固定，并且含义也比较模糊。 总体来说，欧氏距离体现数值上的绝对差异，而余弦距离体现方向上的相对差异。例如，统计两部剧的用户观看行为，用户A的观看向量为(0,1)，用户B为(1,0)；此时二者的余弦距离很大，而欧氏距离很小；我们分析两个用户对于不同视频的偏好，更关注相对差异，显然应当使用余弦距离。而当我们分析用户活跃度，以登陆次数(单位：次)和平均观看时长(单位：分钟)作为特征时，余弦距离会认为(1,10)、(10,100)两个用户距离很近；但显然这两个用户活跃度是有着极大差异的，此时我们更关注数值绝对差异，应当使用欧氏距离。 11 余弦距离是否是一个严格定义的距离?距离的定义：在一个集合中，如果每一对元素均可唯一确定一个实数，使得三条距离公理（正定性，对称性，三角不等式）成立，则该实数可称为这对元素之间的距离。 余弦距离满足正定性和对称性，但是不满足三角不等式，因此它并不是严格定义的距离。具体来说，对于向量A和B，三条距离公理的证明过程如下: 正定性根据余弦距离的定义，有 \operatorname{dist}(A, B)=1-\cos \theta=\frac{\|A\|_{2}\|B\|_{2}-A B}{\|A\|_{2}\|B\|_{2}}考虑到 $|A|_{2}|B|_{2}-A B \geqslant 0$ ，因此有 $\operatorname{dist}(A, B) \geqslant 0$ 恒成立。特别地，$\operatorname{dist}(A, B)=0 \Leftrightarrow|A|_{2}|B|_{2}=A B \Leftrightarrow A=B$因此余弦距离满足正定性。 对称性根据余弦距离的定义，有 \operatorname{dist}(A, B)=\frac{\|A\|_{2}\|B\|_{2}-A B}{\|A\|_{2}\|B\|_{2}}=\frac{\|B\|_{2}\|A\|_{2}-A B}{\|B\|_{2}\|A\|_{2}}=\operatorname{dist}(B, A)因此余弦距离满足对称性。 三角不等式该性质并不成立，下面给出一个反例。给定A=(1,0)，B=(1,1)，C=(0,1)，则有 \operatorname{dist}(A, B)=1-\frac{\sqrt{2}}{2} \operatorname{dist}(B, C)=1-\frac{\sqrt{2}}{2} \quad \operatorname{dist}(A, C)=1因此 \operatorname{dist}(A, B)+\operatorname{dist}(B, C)=2-\sqrt{2}]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-基本概念]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-基本概念相关内容。 1 完整机器学习项目的流程 明确要解决的问题，并将问题抽象成数学问题。主要是明确我们可以获得什么样的数据，目标是一个分类还是回归或者是聚类的问题。 获取数据。我们知道数据决定了机器学习结果的上限，而算法模型只是尽可能地逼近这个上限。数据要有代表性，否则可能会出现过拟合。 特征预处理与特征选择。比如对于分类问题，数据偏斜不能太严重，不同类型的数据数量最好不能有数个数量级的差距，不平衡数据后面要进行处理，主要包括欠采样，过采样和调整权值。还有可能需要对数据进行归一化，标准化，离散化，缺失值处理等，对特征筛选，选出显著特征，运用相关系数，卡方检验，平均互信息等方法。 训练模型与调优。 模型诊断。比如使用交叉验证，绘制学习曲线判断模型是否过拟合，欠拟合了。 过拟合的基本调优思路是增加数据量，降低模型复杂度；欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。以及通过观察误差样本，分析误差产生的原因，是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题。 上线运行与维护。这时不仅需要考虑准确程度，误差等情况，还需要考虑模型的时间和空间复杂度以及稳定性是否可以接受。 Note： 相关系数，卡方检验，平均互信息都是用于检验两个变量独立性的方法，用于去除相关变量。 2 有监督学习和无监督学习 有监督学习：对具有标记的训练样本进行学习，以尽可能对训练样本集外的数据进行分类或预测。如逻辑斯蒂回归，SVM，随机森林等。 无监督学习：对未标记的样本进行学习，以发现这些样本中的内在性质及结构知识。如聚类，密度估计等 Note： 半监督学习：训练数据同时包含有标记样本和未标记样本数据，让学习器不依赖外界交互，自动地利用未标记样本来提升学习性能。 强化学习：给定数据，学习如何选择一系列行动，以最大化长期受益。例如马尔科夫决策过程，动态规划。 3 判别式模型和生成式模型 判别模型：由数据直接学习决策函数 $Y=f(X)$ 或条件概率分布 $P(Y|X)$ 作为预测模型。 生成模型：由数据学习联合概率分布 $P(X,Y)$，然后求出条件概率分布 $P(Y|X)$ 作为预测模型：P(Y | X)=\frac{P(X, Y)}{P(X)} 由生成模型可以得到判别模型，但是由判别模型得不到生成模型。 判别模型：K近邻，SVM，决策树，逻辑斯蒂回归，最大熵模型，提升方法和条件随机场等。 生成模型：朴素贝叶斯，隐马尔可夫模型，高斯混合模型，文档主题生成模型，限制玻尔兹曼机。 4 通俗易懂解释机器学习机器学习就像婴儿学走路。每次他们摔倒，他们就会学到（无知觉地）并且明白，他们的腿要伸直，而不能弯着。他们下一次在摔倒，摔疼了，摔哭了，但是它们学会了“不要用那种姿势站着”，为了避免摔疼，他们更加努力尝试，为了站稳，他们还扶着门或者墙壁或者任何靠近他们的东西。这同样也是一起机器如何在环境中学习和发展它的直觉的。 5 给定一个数据集，如何选择算法 机器学习算法的选择取决于学习任务和数据的类型，是分类问题还是回归问题（分类就先从常用的分类模型里选择），如果给定的一个数据集是线性的，线性回归是最好的选择，如果是图像或者音频，那么神经网络可以构建一个稳健的模型。如果该数据是非线性互相作用的的，可以用boosting或bagging算法。如果业务需求是要构建一个可以部署的模型，我们可以用回归或决策树模型（容易解释和说明），而不是黑盒算法如SVM，GBM等。 总之，没有一个一劳永逸的算法。我们必须有足够的细心，去了解到底要用哪个算法。 6 线性分类器与非分类器的区别以及优劣 线性和非线性是针对模型参数和输入特征来讲的，比如输入x，模型y=ax+b为线性模型，模型y=ax+bx^2则是非线性模型。 线性分类器可解释性好，计算复杂度较低，不足之处是模型的拟合效果相对弱些。 非线性分类器拟合效果较强，不足之处是数据量小时容易过拟合，计算复杂度高，可解释性不好。 Note 常见的线性分类器有：贝叶斯分类，单层感知机，线性回归，逻辑斯蒂回归。 常见的非线性分类器有：决策树，随机森林，GBDT，多层感知机。 SVM两种都有，看使用和核函数是线性核还是高斯核。 7 有隐含关联的事件举例美国的太太们常叮嘱她们的丈夫下班后为小孩买尿布，而丈夫们在买尿布后又随手带回了两瓶啤酒。这一消费行为导致了这两件商品经常被同时购买，所以，沃尔玛索性就将它们放在了一块，既方便了顾客，更提高了产品销量。这说明数据能告诉我们消费者的潜在需求，这可能是人很难直接发现的。 8 TensorFlow简介TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。Tensor（张量）意味着N维数组，Flow（流）意味着基于数据流图的计算，TensorFlow为张量从流图的一端流动到另一端计算过程。TensorFlow是将复杂的数据结构传输至人工智能神经网中进行分析和处理过程的系统。 9 数据流图（Data Flow Graph）数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。 10 TensorFlow的优缺点 优点：高度的灵活性，真正的可移植性（Portability），自动求微分，多语言支持，其核心代码是c++编写的，执行效率比较高，同时有其他语言的接口。 缺点：使用Python时效率比较低，每一个mini-batch要从Python中feed到网络中，这个过程在mini-batch的数据量很小或者运算时间很短时，可能会带来影响比较大的延迟。 11 病态问题 训练完的模型，测试样本稍作修改就会得到差别较大的结果，就是病态问题。 模型对未知数据的预测能力很差，即泛化误差大。 12 VC维 VC维是模型的复杂程度，模型假设空间越大，VC维越高。某种程度上，VC维给机器学习科学性提供了理论支撑。 测试集合的loss是否和训练集合的loss接近？VC维越小，理论越接近，越不容易过拟合。 训练数据的loss是否可以足够小？VC维越大，loss理论越小，越不容易欠拟合。 我们对模型添加的正则化可以对模型的复杂度（VC维）进行控制，平衡这两部分。 13 机器学习的各种模型与各自的损失函数一一对应 可以把机器学习视作表达和优化，其中表达的部分，各种模型会有各种不同的形态（线性回归，逻辑回归，SVM，树模型） 当确定了用某个模型（比如逻辑斯蒂回归）去解决问题，你需要知道当前模型要达到更好的效果需要怎么优化，这个时候就要借助损失函数了。 14 超参数和参数的区别 超参数是为了定义模型，需要提前敲定的东西（比如多项式拟合的最高次数，SVM选择的核函数）。 参数是你确定了超参数之后（比如用最高3次的多项式回归），学习到的参数（比如多项式回归的系数）。 15 最小二乘法最小二乘法的主要思想：计算未知参数，使得理论值和观测值之差的平方和达到最小。 \min _{\vec{x}}\left\|\vec{y}_{m}(\vec{x})-\vec{y}\right\|_{2}16 协方差和相关性的区别 协方差可以理解为两个变量在变化过程中是同方向变化还是反方向变化，以及同向或反向变化的程度如何。 相关性是剔除了量纲影响、标准化后的协方差。它也可以反映两个变量变化是同向还是反向的，它消除了两个变量变化幅度的影响，可以单纯反映两个变量每单位变化时的相似程度。\Sigma_{i j}=\operatorname{cov}\left(X_{i}, X_{j}\right)=\mathrm{E}\left[\left(X_{i}-\mu_{i}\right)\left(X_{j}-\mu_{j}\right)\right]=\mathrm{E}\left[X_{i} X_{j}\right]-\mu_{i} \mu_{j}\rho_{X, Y}=\frac{\operatorname{cov}(X, Y)}{\sigma_{X} \sigma_{Y}} 17 特征比数据量还大时，选择什么样的分类器线性分类器，因为维度高的时候，数据一般在维度空间里面会比较稀疏，很有可能线性可分。 18 对于维度极低的特征，选择线性还是非线性分类器？非线性分类器，低维空间可能很多特征都跑到一起了，导致线性不可分。 19 你正在一个时间序列数据集上工作，经理要求你建立一个高精度的模型，你开始用决策树算法，因为你知道它在所有类型的数据集上的表现都不错，后来，你尝试了时间序列回归模型，并得到了比决策树模型更高的精度，这种情况会发生吗，为什么？会发生，因为时间序列数据有线性关系，而决策树算法室已知的检测非线性交互最好的算法，为什么决策树没能提供好的预测是因为它不能像回归模型那样做到对线性关系那么好的映射。因此，我们知道了如果有一个满足线性假设的数据集，一个线性回归模型能提供强大的预测。 20分类（Classification）和回归（Prediction）的主要步骤及区别联系 分类：输入样本数据，输出对应的类别，将样本中每个数据对应一个已知属性。 回归：两种或者两种以上的变量之间相互依赖的函数模型，预测给定自变量对应的因变量的值。 分类算法分为两步： 学习步：通过训练样本数据集，建立分类规则 分类步：用已知的测试样本集评估分类规则的准确率，若准确率可接受，则是使用该规则对除样本以外的数据(待测样本集)进行预测。 回归算法分两步： 我们先要基于一定数量的样本来训练出一个训练模型； 为了判断这个模型训练的如何，我们还要对其进行检测一下； 如果测试的样本数据与我们想象中的差别太大，那么我们就要重新进行训练这个预测模型，但是如果我们的预测模型符合我们的预先的期望，那么我们就可以用这个模型进行预测的操作。 区别 特征：分类vs. 回归预测 输出类型：离散数据vs. 连续数据 目的：寻找决策边界 vs. 找到最优拟合线 评价方法：精度、混淆矩阵 vs. SEE(sum of square errors)或MSE 联系 分类算法可以预测连续值，但是连续值是以类标签的概率的形式。 回归算法可以预测离散值，但离散值以整数形式表示。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-无监督学习]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-无监督学习相关内容。 1 无监督学习的定义在”无监督学习”(unsupervised learning)中，训练样本的标记信息是未知的，目标是通过对无标记训练样本的学习来挖掘数据的内在性质及规律。无监督学习主要包含两大类学习方法：数据聚类和特征变量关联。其中，聚类算法往往是通过多次迭代来找到数据的最优分割，而特征变量关联则是利用各种相关性分析方法来找到变量之间的关系。 2 K均值聚类的步骤 随机选择K个点作为点的聚类中心，这表示我们要将数据分为K类。 遍历所有的点P，算出P到每个聚类中心的距离，将P放到最近的聚类中心的点集中。遍历结束后我们将得到K个点集。 遍历每一个点集，算出每一个点集的中心位置，将其作为新的聚类中心。 重复步骤2和步骤3，直到聚类中心位置不再移动。 3 K均值算法的优缺点K均值算法有一些缺点，例如受初值和离群点的影响每次的结果不稳定、结果通常不是全局最优而是局部最优解、需要提前确定k值、无法很好地解决数据簇分布差别比较大的情况（比如一类是另一类样本数量的100倍）、不太适用于离散分类等。总结：对异常值敏感，需要提前确定k值，结果依赖于分类中心的初始化，结果不稳定。 K均值聚类的优点也是很明显和突出的，主要体现在：对于大数据集，K均值聚类算法相对是可伸缩和高效的，它的计算复杂度是 $O(NKt)$ 接近于线性，其中N是数据对象的数目，K是聚类的簇数，t是迭代的轮数。尽管算法经常以局部最优结束，但一般情况下达到的局部最优已经可以满足聚类的需求。总结：计算时间短，速度快，容易解释，聚类效果还不错 4 K均值调优思路K均值算法的调优一般可以从以下几个角度出发。 数据归一化和离群点处理。K均值聚类本质上是一种基于欧式距离度量的数据划分方法，均值和方差大的维度将对数据的聚类结果产生决定性的影响，所以未做归一化处理和统一单位的数据是无法直接参与运算和比较的。同时，离群点或者少量的噪声数据就会对均值产生较大的影响，导致中心偏移，因此使用K均值聚类算法之前通常需要对数据做预处理。 合理选择K值。K值的选择是K均值聚类最大的问题之一，这也是K均值聚类算法的主要缺点。k-均值聚类算法首先会随机确定k个中心位置，然后将各个数据项分配给最邻近的中心点，待分配完成后，聚类中心就会移到分配给该聚类的所有节点的平均位置处，然后整个分配过程重新开始，这一过程会一直重复下去，知道分配过程不再产生变化为止。k值的选择，通常有4种：按需选择，观察法，手肘法，gap statistic法。 按需选择：简单地说即使按照建模的需求和目的来选择聚类的个数。比如一个游戏公司想把所有玩家做聚类分析，分成顶级，高级，中级和菜鸟四类，那么k取4。按需选择虽然合理，但是未必能保证在做k-means时 观察法：就是用肉眼观察数据，看这些点大概能聚成几类，这个方法虽然简单，但也模棱两可。观察法要求原始维度低，三维以下，否则人眼无法观察，对于高维数据，可以用PCA降维然后观察。 手肘法（elbow method）：手肘法本质上也是一种间接的观察法。当k-means算法完成后，我们将得到k个聚类的中心点Mi，i=1,2,3…,k，以及每个原始点所对应的聚类Ci，i=1,2,…k。我们通常计算所有样本点到它所在的聚类的中心点的距离的和作为模型的度量，记为 $D_K$ D_{K}=\sum_{i=1}^{K} \sum_{X \in C_{i}}\left\|X-M_{i}\right\|这里距离可以采用欧氏距离。对于不同的k，我们会得到不同的中心点和聚类，所以会有不同的度量，把k作为横坐标，$D_K$作为纵坐标，可以下面的的曲线。很显然k越大，距离和越小，我们注意到k=3是一个拐点，就像是我们的肘部一样，k=1到3下降很快，k=3之后趋于平稳，手肘法认为这个点就是最佳的k。 gapstatistic法：这个方法是源自斯坦福几个machine learning大牛的paper Estimating the number of clusters in a dataset via the gap statistic。这里我们继续使用上面的DK，GAPSTATISTIC的定义为： \operatorname{Gap}(K)=\mathrm{E}\left(\log D_{k}\right)-\log D_{k}这里 $\mathrm{E}\left(\log D_{k}\right)$ 指的是 $\log D_{k}$ 的期望，这个数值通常通过蒙特卡洛模拟产生，我们在样本里所在的矩形区域中（高维的话就是立方体区域）按照均匀分布随机地产生和原始样本数一样多的随机样本，并对这个随机样本做一个k-means，从而得到一个 $D_K$，如此往复多次，通常20次，我们可以得到20个 $\log D_{k}$。对这20个数值求平均值，就得到了 $\mathrm{E}\left(\log D_{k}\right)$ 的近似值，最终可以得到 gap statistic，而gap static取得最大值所对应的k就是最佳的k。Gap statistic的优点是，我们不再需要肉眼了，我们只需要找到最大的gap statistic所对应的k即可。 5 Kmeans初始类簇中心点的选取 选择彼此距离尽可能远的k个点。首先随机选择一个点作为第一个初始类簇中心点，然后选择距离该点最远的那个点作为第二个初始类簇中心点，然后在选择距离前两个点的最近距离最大的点作为第三个初始类簇的中心点，以此类推，直至k个初始类簇中心点。 先对数据用层次聚类算法或者canopy算法进行聚类，得到k个簇之后，从每个类簇中选择一个点作为簇中心点，可以直接选择该簇的中心点或者是距离类簇中心点最近的那个点。 5 优化KmeansK均值算法的主要缺点如下。 需要人工预先确定初始K值，且该值和真实的数据分布未必吻合。 K均值只能收敛到局部最优，效果受到初始值很大。 易受到噪点的影响。 样本点只能被划分到单一的类中。 Kmeans++算法：K均值的改进算法中，对初始值选择的改进是很重要的一部分。而这类算法中，最具影响力的当属K-means++算法。原始K均值算法最开始随机选取数据集中K个点作为聚类中心，而K-means++按照如下的思想选取K个聚类中心。假设已经选取了n个初始聚类中心（0&lt;n&lt;K），则在选取第n+1个聚类中心时，距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。在选取第一个聚类中心（n=1）时同样通过随机的方法。可以说这也符合我们的直觉，聚类中心当然是互相离得越远越好。当选择完初始点后，K-means++后续的执行和经典K均值算法相同，这也是对初始值选择进行改进的方法等共同点。 ElkanK-means算法对距离计算进行了优化，在传统的kmeans算法中，我们在每轮迭代中，要计算所有的样本点到所有的质心的距离，而elkan kmeans算法就是减少不必要的距离计算，主要思想是利用两边之和大于第三边，以及两边之差小于第三边的三角形性质，来减少距离的计算。 ISODATA算法：当K值的大小不确定时，可以使用ISODATA算法。ISODATA的全称是迭代自组织数据分析法。在K均值算法中，聚类个数K的值需要预先人为地确定，并且在整个算法过程中无法更改。而当遇到高维度、海量的数据集时，人们往往很难准确地估计出K的大小。ISODATA算法就是针对这个问题进行了改进，它的思想也很直观。当属于某个类别的样本数过少时，把该类别去除；当属于某个类别的样本数过多、分散程度较大时，把该类别分为两个子类别。ISODATA算法在K均值算法的基础之上增加了两个操作，一是分裂操作，对应着增加聚类中心数；二是合并操作，对应着减少聚类中心数。ISODATA算法是一个比较常见的算法，其缺点是需要指定的参数比较多，不仅仅需要一个参考的聚类数量Ko，还需要制定3个阈值。下面介绍ISODATA算法的各个输入参数。 预期的聚类中心数目Ko。在ISODATA运行过程中聚类中心数可以变化，Ko是一个用户指定的参考值，该算法的聚类中心数目变动范围也由其决定。具体地，最终输出的聚类中心数目常见范围是从Ko的一半，到两倍Ko。 每个类所要求的最少样本数目Nmin。如果分裂后会导致某个子类别所包含样本数目小于该阈值，就不会对该类别进行分裂操作。 最大方差Sigma。用于控制某个类别中样本的分散程度。当样本的分散程度超过这个阈值时，且分裂后满足（1），进行分裂操作。 两个聚类中心之间所允许最小距离Dmin。如果两个类靠得非常近（即这两个类别对应聚类中心之间的距离非常小），小于该阈值时，则对这两个类进行合并操作。 如果希望样本不划分到单一的类中，可以使用模糊C均值或者高斯混合模型。 8 KNN和Kmeans有什么不同Kmeans属于无监督学习，knn属于有监督学习，kmeans是聚类算法，knn是分类或回归算法。Kmeans算法用数据集分成簇，使得形成的簇是同构的，最小化簇内距离，最大化簇间距离，由于无监督的性质，这些簇没有任何标签。KNN算法时基于其K个周围邻居来对未标记的样本进行分类，将k个邻居中出现最多的类作为未标记样本的类别。（也可做回归，取均值）。 9 EM算法EM算法是一种迭代算法，用于含有隐变量的概率模型参数的极大似然估计或极大后验概率估计。EM算法的每次迭代由两步组成：E步，求期望，也就是利用隐藏变量的现有估计值，计算其最大似然估计值；M步，求极大值，即最大化在E步求得的最大似然值来计算参数的值。所以EM算法称作期望极大算法。 EM算法的基本思想是： 首先给参数θ自主规定个初值； 然后根据给定观测数据和当前的参数θ，求未观测数据z的条件概率分布的期望； 然后根据估计出的未观测数据的期望加上之前的已观测数据，通过极大似然估计求更优的θ’ 因为第二步和第三步的结果可能不是最优的，所以重复第二步和第三步，直到收敛。 Note EM算法的前提是假设数据总体的分布。 似然性：指某种事物发生的可能性。 最大似然估计：已经知道了结果，然后寻求使该结果出现的可能性最大的条件。 概率是根据条件推测结果，似然是根据结果反推条件，即已知样本X，求参数。 10 使用EM算法求解的模型有哪些，为什么不用牛顿法或者梯度牛顿法?用EM算法求解的模型一般有GMM或者协同过滤，k-means其实也属于EM，EM算法一定会收敛，但是可能会收敛到局部最优。由于求和的项数将随着隐变量的数目指数上升，会给梯度计算带来麻烦。 11 高斯混合模型高斯混合模型（Gaussian Mixed Model，GMM）也是一种常见的聚类算法，与K均值算法类似，同样使用了EM算法进行迭代计算。高斯混合模型假设每个簇的数据都是符合高斯分布（又叫正态分布）的，当前数据呈现的分布就是各个簇的高斯分布叠加在一起的结果。 12 高斯混合模型的核心思想高斯混合模型的核心思想是，假设数据可以看作从多个高斯分布中生成出来的。在该假设下，每个单独的分模型都是标准高斯模型，其均值 μi 和方差 Σi 是待估计的参数。此外，每个分模型都还有一个参数 πi ，可以理解为权重或生成数据的概率。 高斯混合模型是一个生成式模型。可以这样理解数据的生成过程，假设一个最简单的情况，即只有两个一维标准高斯分布的分模型N(0,1)和N(5,1)，其权重分别为0.7和0.3。那么，在生成第一个数据点时，先按照权重的比例，随机选择一个分布，比如选择第一个高斯分布，接着从N(0,1)中生成一个点，如−0.5，便是第一个数据点。在生成第二个数据点时，随机选择到第二个高斯分布N(5,1)，生成了第二个点4.7。如此循环执行，便生成出了所有的数据点。 13 高斯混合模型和Kmeans高斯混合模型与K均值算法的相同点是，它们都是可用于聚类的算法；都需要指定K值；都是使用EM算法来求解；都往往只能收敛于局部最优。而它相比于K均值算法的优点是，可以给出一个样本属于某类的概率是多少；不仅仅可以用于聚类，还可以用于概率密度的估计；并且可以用于生成新的样本点。 14 以聚类问题为例，假设没有外部标签数据，如何评估两个聚类算法的优劣数据的聚类依赖于实际需求，同时也依赖于数据的特征度量以及评估数据相似性的方法。相比于监督学习，非监督学习通常没有标注数据，模型、算法的设计直接影响最终的输出和模型的性能。为了评估不同聚类算法的性能优劣，我们需要了解常见的数据簇的特点。 以中心定义的数据簇：这类数据集合倾向于球形分布，通常中心被定义为质心，即此数据簇中所有点的平均值。集合中的数据到中心的距离相比到其他簇中心的距离更近。 以密度定义的数据簇：这类数据集合呈现和周围数据簇明显不同的密度，或稠密或稀疏。当数据簇不规则或互相盘绕，并且有噪声和离群点时，常常使用基于密度的簇定义。 以连通定义的数据簇：这类数据集合中的数据点和数据点之间有连接关系，整个数据簇表现为图结构。该定义对不规则形状或者缠绕的数据簇有效。 以概念定义的数据簇：这类数据集合中的所有数据点具有某种共同性质。 聚类评估的任务是估计在数据集上进行聚类的可行性，以及聚类方法产生结果的质量。这一过程又分为三个子任务。 估计聚类趋势。这一步骤是检测数据分布中是否存在非随机的簇结构。如果数据是基本随机的，那么聚类的结果也是毫无意义的。可以观察聚类误差是否随聚类类别数量的增加而单调变化，如果数据是基本随机的，即不存在非随机簇结构，那么聚类误差随聚类类别数量增加而变化的幅度应该较不显著，并且也找不到一个合适的K对应数据的真实簇数。 判定数据簇数。确定聚类趋势之后，我们需要找到与真实数据分布最为吻合的簇数，据此判定聚类结果的质量。数据簇数的判定方法有很多，例如手肘法和Gap Statistic方法。需要说明的是，用于评估的最佳数据簇数可能与程序输出的簇数是不同的。例如，有些聚类算法可以自动地确定数据的簇数，但可能与其他方法确定的最优数据簇数有所差别。 测定聚类质量。给定预设的簇数，不同的聚类算法将输出不同的结果，如何判定哪个聚类结果的质量更高呢？在无监督的情况下，我们可以通过考察簇的分离情况和簇的紧凑情况来评估聚类的效果。包括轮廓系数（反应簇中数据的紧凑程度，簇与其他临近簇的分离程度），均方根标准偏差（Root-mean-square standard deviation，RMSSTD）：用来衡量聚结果的同质性，即紧凑程度。R方（R-Square）：可以用来衡量聚类的差异度。 15 密度聚类 DBSCAN密度聚类亦称”基于密度的聚类” (density-based clustering)，此类算法假 设聚类结构能通过样本分布的紧密程度确定.通常情形下，密度聚类算法从样 本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇 以获得最终的聚类结果。 最具代表性的密度聚类算法是DBSCAN， DBSCAN能够将足够高密度的区域划分成簇，并能在具有噪声的空间数据库中发现任意形状的簇。DBSCAN的核心思想是从某个核心点出发，不断向密度可达的区域扩张，从而得到一个包含核心点和边界点的最大化区域，区域中任意两点密度相连。 DBSCAN基本步骤输入：包含n个对象的集合D，指定半径epislon和最少样本量MinPts。输出：所有生成的簇，达到密度要求。 repeat 从集合D中抽取一个未处理的点； 如果抽出的点是核心点，则找出所有从该点出发的密度可达对象，形成簇； 如果抽出点的为非核心点，则跳出循环，寻找下一个点； until所有点都被处理。 核心点：某点半径为epislon的圆内样本点个数大于等于MinPts的点 优点 可以对任意形状的稠密数据集进行聚类，相对的，K-Means之类的聚类算法一般只适用于凸数据集。 可以在聚类的同时发现异常点，对数据集中的异常点不敏感。 聚类结果没有偏倚，相对的，K-Means之类的聚类算法初始值对聚类结果有很大影响。 缺点 需要为算法指定eps和MinPts参数，这对分析人员是一个很大的挑战； DBSCAN聚类算法对参数eps和MinPts的设置是非常敏感的，如果指定不当，该算法将造成聚类质量的下降。 16 层次聚类 AGNES层次聚类(hierarchical clustering)试图在不同层次对数据集进行划分，从而 形成树形的聚类结构. 数据集的划分可采用”自底向上”的聚合策略，也可采 用 “自顶向下” 的分拆策略. AGNES是一种采用自底向上聚合策略的层次聚类算法.它先将数据集中 的每个样本看作一个初始聚类簇，然后在算法运行的每一步中找出距离最近的两个粟类簇进行合并，该过程不断重复，直至达到预设的聚类簇个数.这里的关 键是如何计算聚类簇之间的距离.实际上每个簇是一个样本集合，因此，只需 采用关于集合的某种距离即可.最小距离，最大距离，平均距离。 最小距离由两个簇的最近样本决定，最大距离由两个簇的最远样本决定7 而平均距离则由两个簇的所有样本共同决定。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-贝叶斯]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-贝叶斯相关内容。 1 贝叶斯原理贝叶斯公式直接可以根据条件概率的定义直接推出。考虑一个问题： $P(A|B)$ 是在B发生的情况下A发生的可能性。首先，事件B发生之前，我们对事件A的发生有一个基本的概率判断，称A的先验概率，用 $P(A)$ 表示。其次，事件B发生之后，我们对事件A的发生概率重新评估，称为A的后验概率，用 $P(A|B)$ 表示。同样地定义 $P(B)$ 和 $P(B|A)$ 。所以根据贝叶斯公式为： P(A | B)=\frac{P(B | A) P(A)}{P(B)}根据条件概率公式，在事件B发生的情况下事件A发生的概率是 {P}({A} | {B})={P}({A} \cap {B}) / {P}({B})同样地，在事件A发生的条件下事件B发生的概率是 {P}({B} | {A})={P}({A} \cap {B}) / {P}({A})整合上述两个公式：$P(A|B)P(B)=P(B|A)P(A)$ ，上式两边同除 $P(B)$ ，若P(B)是非零的，我们可以直接得到贝叶斯定理的公式表达式。 Note： 条件概率：在同一个样本空间 $\Omega$ 中包含事件A和事件B，如果随机从$\Omega$中选出的一个元素属于B，那么这个随机选择的元素还属于A的概率就定义为在B的前提下A的条件概率，所以 ${P}({B} | {A})={P}({A} \cap {B}) / {P}({A})$。 联合概率表示两个时间共同发生的概率。A和B的联合概率表示为 ${P}({A} \cap {B})$ 或者 $P(A,B)$。 边缘概率又称先验概率：是某个事件发生的概率。在联合概率中，把最终结果中那些不需要的事件通过合并成它们的全概率，而消去它们（对离散随机变量用求和得全概率，对连续随机变量用积分得全概率），这称为边缘化（marginalization），比如A的边缘概率表示为 $P(A)$，B的边缘概率表示为 $P(B)$。 2 朴素贝叶斯算法里的先验概率，似然估计和边际似然估计先验概率就是因变量（二分法）在数据集中的比例，这是在没有任何进一步信息的时候，对分类能做出的最接近的猜测。例如，在一个数据集中，，因变量是二进制的1和0,1（垃圾邮件）的比例为70%和0（非垃圾邮件）的为30%，因此，我们可以估算任何新的电子邮件有70%的概率为垃圾邮件。似然估计就是在其他一些变量给定的情况下，一个观测值被分类为1的概率，例如，“free”这个词在以前的垃圾邮件中使用的概率就是似然估计，边际似然估计就是，“free”这个词在任何消息中使用的概率。 3 为什么朴素贝叶斯如此朴素因为它假设所有特征在数据集中的作用是同样重要和独立的，即特征条件独立性。但是在实际问题中，这种假设很少成立，但特征相关性很小的实际情况还是很多的，所以这个模型依然有一定的适用性。 Note 朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，首先基于特征条件独立假设学习输入和输出的联合概率密度，然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出 y。 朴素贝叶斯属于生成模型。 4 当你在Google中输入“Julw”时，系统会猜测你的意图：是不是要搜索“July”，这叫拼写检查，根据谷歌一员工写的文章显示，Google的拼写检查是基于贝叶斯方法，具体Google是怎么利用贝叶斯方法，实现拼写检查的？用户输入一个单词，可能拼写正确，也可能拼写错误。如果把拼写正确记为c（代表correct），拼写错误记为w（代表wrong），那么拼写检查要做的事情是：在发生w的情况下，试图推断出c。换言之，已知w，然后 在若干个备选方案中，找出可能性最大的那个c，也就是求P(c|w)的最大值。 根据贝叶斯定理 $P(c | w)=\frac{P(w | c) P(c)}{P(w)} $，对于所有的备选 c来说，对应的都是同一个 w，所以它们的 $P(w)$ 相同，因此我们只要最大化 $P(w|c)P(c)$ 即可。 P(c)表示某个正确的词出现的概率，它可以用频率代替，如果我们有一个足够大的文本库，那么这个文本库中每个单词的出现概率，就相当于它的发生频率。某个词出现概率越大，P(c)就越大。比如在你输入一个错误的次‘julw’时，系统更倾向于去猜测你可能想输入的词是‘july’，而不是‘jult’，因为‘july’更常见。 $P(w|c)$ 表示在试图拼写c的情况下，出现拼写错误w的概率，我们可以使用编辑距离度量两个词的接近程度，两个词越接近，越有可能拼错，$P(w|c)$ 越大。所以我们比较所有拼写相近的词在文本库中的出现频率，再从中挑出出现频率最高的一个，即是用户想输入的那个词。 Note 两个词的编辑距离：一个词转变到另一个词所需的步骤。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-集成学习]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-集成学习相关内容。 1 集成学习的原理步骤集成学习(ensemble learning)通过构建并结合多个学习器来完成学习任务，有时也被称为多分类器系统(multi-classifier system)、基于委员会的学习(committee-based learning)等。集成学习一般可分为以下3个步骤。 找到误差互相独立的基分类器。 训练基分类器。 合并基分类器的结果。 2 集成学习的合并策略合并基分类器的主要有三种：平均法（averaging），投票法（voting），学习法（stacking）三种。 平均法有简单平均法和加权平均法。在个体学习器性能相差较大时宜使用加权平均法，而在个体学习器性能相近时宜使用简单平均法。 投票法有绝对多数投票法，相对多数投票法和加权投票法。标准的绝对多数投票法提供了”拒绝预测”选项，也就是在没有类别超过一半时不给出预测，这在可靠性要求较高的学习任务中是一个很好的机制.但若学习任务要求必须提供预测结果，则绝对多数投票法将退化为相对多数投票法。因此，在不允许拒绝预测的任务中，绝对多数、相对多数投票法统称为”多数投票法”。 学习法通过另一个学习器，用串行的方式，Stacking先从初始数据集训练出初级学习器，然后”生成”一个新数据集用于训练次级学习器.在这个新数据集中，初级学习器的输出被当作样例输入到次级分类器，最后将所有基分类器的输出结果相加或者用更复杂的算法融合。比如把各基分类器的输出作为特征，使用逻辑回归作为融合模型进行最后的结果预测）作为最终的输出。在训练阶段，次级训练集是利用初级学习器产生的，若直接用初级学习器的训练集来产生次级训练集，则过拟合风险会比较大;因此一般是通过使用交叉验证或留一法这样的方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本。 此外还有一种方法为Blending，Blending步骤如下：原始训练数据集划分为训练数据集和验证数据集，针对训练数据集训练多个模型，每个模型针对验证数据集的结果构成新的训练数据集，每个模型针对预测数据集的结果构成新的预测数据集。然后针对新的训练数据集训练模型，训练完成后，得到的模型对新的预测数据集的结果作为最终的结果。Blending与Stacking大致相同，只是Blending的主要区别在于训练集不是通过K-Fold的CV策略来获得预测值从而生成第二阶段模型的特征，而是建立一个Holdout集。简单来说，Blending直接用不相交的数据集用于不同层的训练。 3 集成学习的分类boosting和baggingBoosting方法训练基分类器时采用串行的方式，各个基分类器之间有依赖。它的基本思路是将基分类器层层叠加，每一层在训练的时候，对前一层基分类器分错的样本，给予更高的权重。测试时，根据各层分类器的结果的加权得到最终结果。Boosting的过程很类似于人类学习的过程，我们学习新知识的过程往往是迭代式的，第一遍学习的时候，我们会记住一部分知识，但往往也会犯一些错误，对于这些错误，我们的印象会很深。第二遍学习的时候，就会针对犯过错误的知识加强学习，以减少类似的错误发生。不断循环往复，直到犯错误的次数减少到很低的程度。 Bagging：Bagging与Boosting的串行训练方式不同，Bagging方法在训练过程中，各基分类器之间无强依赖，可以并行训练。它直接基于自助来样法(bootstrap sampling)。给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。初始训练集中约有63.2%的样本出现在来样集中。自助采样过程还给Bagging带来了另一个优点，由于每个基学习器只使用了初始训练集中约63.2%的样本，剩下约36.8%的样本可用作验证集来对泛化性能进行”包外估计”（oob）。Bagging方法更像是一个集体决策的过程，每个个体都进行单独学习，学习的内容可以相同，也可以不同，也可以部分重叠。但由于个体之间存在差异性，最终做出的判断不会完全一致。在最终做决策时，每个个体单独作出判断，再通过投票的方式做出最后的集体决策。 4 建了5个GBM，没有一个模型比基准模型表现得更好。组合的学习模型是基于合并弱的学习模型来创造一个强大的学习模型。但是，只有当各模型之间没有相关性的时候组合起来才比较强大，由于我们已经试了5个GBM，但没有提高精度，表明这些模型是相关的。具有相关性的模型的问题是，所有的模型提供相同的信息。 5 偏差、方差、噪声的含义 偏差度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力; 方差度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响; 噪声则表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度. 偏差一方差分解说明，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的.给定学习任务，为了取得好的泛化性能，则需使偏差较小，即能够充分拟合数据，并且使方差较小，即使得数据扰动产生的影响小. 6 从偏差-方差分解的角度理解Boosting和Bagging基分类器，有时又被称为弱分类器，因为基分类器的错误率要大于集成分类器。基分类器的错误，是偏差和方差两种错误之和。偏差主要是由于分类器的表达能力有限导致的系统性错误，表现在训练误差不收敛。方差是由于分类器对于样本分布过于敏感，导致在训练样本数较少时，产生过拟合。 Boosting方法是通过逐步聚焦于基分类器分错的样本，减小集成分类器的偏差。Bagging方法则是采取分而治之的策略，通过对训练样本多次采样，并分别训练出多个不同模型，然后做综合，来减小集成分类器的方差 也就是Bagging能够提高弱分类器性能的原因是降低了方差，而Boosting能够提升弱分类器性能的原因是降低了偏差。 7 Bagging为什么会减小方差角度1：Bagging是Bootstrap Aggregating的简称，意思就是再抽样，然后在每个样本上训练出来的模型取平均，对n个独立不相关的模型的预测结果取平均，方差是原来单个模型的1/n。当然，模型之间不可能完全独立。为了追求模型的独立性，诸多Bagging的方法做了不同的改进。比如在随机森林算法中，每次选取节点分裂属性时，会随机抽取一个属性子集，而不是从所有属性中选取最优属性，这就是为了避免弱分类器之间过强的相关性。通过训练集的重采样也能够带来弱分类器之间的一定独立性，从而降低Bagging后模型的方差。 角度2：Bagging每次减少了outlier的采样（原始数据集如果outlier很多的话，会 让Model记住太多噪声导致过拟合；bagging随机选取data的subset，outlier 因为比例比较低，参与model training的几率也比较低，所以bagging降低 了outliers和noise对model的影响，所以降低了variance（这个从outlier的 角度回答，所以很新颖）。 再看Boosting，在Boosting的训练过程。在训练好一个弱分类器后，我们需要计算弱分类器的错误或者残差，作为下一个分类器的输入。这个过程本身就是在不断减小损失函数，来使模型不断逼近真实值，使得模型偏差不断降低。但Boosting的过程并不会显著降低方差。这是因为Boosting的训练过程使得各弱分类器之间是强相关的，缺乏独立性，所以并不会对降低方差有作用。 8 AdaBoostBoosting族算法最著名的代表是AdaBoost，它的思想是，对分类正确的样本降低了权重，对分类错误的样本升高或者保持权重不变。在最后进行模型融合的过程中，也根据错误率对基分类器进行加权融合。错误率低的分类器拥有更大的“话语权”。 Boosting算法要求基学习器能对特定的数据分布进行学习，这可通过”重赋权法”(re-weighting)实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重.对无法接受带权样本的基学习算法，则可通过”重采样法”(re-sampling)来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得的样本集对基学习器进行训练. Boosting算法在训练的每一轮都要检查当前生成的基学习器是否满足基本条件(检查当前基分类器是否是比随机猜测好)，一旦条件不满足，则当前基学习器即被抛弃，且学习过程停止.在此种情形下，初始设置的学习轮数T也许遥远未达到，可能导致最终集成中只包含很少的基学习器而性能不佳.若采用”重采样法”，则可获得”重启动”机会以避免训练过程过早停止，即在抛弃不满足条件的当前基学习器之后，可根据当前分布重新对训练样本进行采样，再基于新的采样结果重新训练出基学习器，从而使得学习过程可以持续到预设的T轮完成. 9 随机森林 RF随机森林(Random Forest，简称RF)是Bagging的一个扩展变体.在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择. 具体来说，传统决策树在选择划分属性时是在当前结点的属性集合(假定有d个属性)中选择一个最优属性;而在RF中，对基决策树的每个结点，先从该结点的属性集合中随机选择一个包含k个属性的子集，然后再从这个子集中选择一个最优属性用于划分.这里的参数k控制了随机性的引入程度;若令k=d，则基决策树的构建与传统决策树相同;若令k=1，则是随机选择一个属性用于划分;一般情况下，推荐值k=log2d。 随机森林的训练效率常优于Bagging，因为在个体决策树的构建过程中，Bagging使用的是”确定型”决策树，在选择划分属性时要对结点的所有属性进行考察，而随机森林使用的”随机型”决策树，即只需考察一个属性子集。这种属性扰动导致生成的决策树基分类器随机性较大，这样的不稳定的学习器更适合作为基分类器。因为样本随机性以及特征随机性保证了每棵树用的都是样本数据的一部分，使得每棵决策树之间的相关性减少，所以过拟合的可能性小。 10 随机森林如何处理缺失值 缺失值较多的时候可以抛弃缺失值。 缺失值较少时补充缺失值，对于训练集，同一个类别下的数据，如果是描述性数据缺少，用出现最多的值替换，如果是连续性数值，则用中位数替换。 概率化缺失值，对缺失值的样本赋予该属性所有属性值的概率分布，即将缺失值按照其所在属性已知值的相对概率分布区创建决策树。 11 怎么理解决策树，Xgboost能处理缺失值？而有的模型（SVM）对缺失值比较敏感？涉及到距离度量时，比如需要计算两个点的距离，缺失数据就变得比较重要。因为涉及到“距离”这个概念，那么缺失值处理不当就会导致效果很差，比如SVM，KNN等。 树模型对于缺失值的敏感度降低，大部分时候可以在数据缺失的时候使用，决策树的缺失值可以用其所对应的类别中的中位数或者出现最多的数值替换，Xgboost可以为缺失值提供默认的分裂方向，使用能够最小化训练误差的方向作为默认的分裂方向。 Note 线性模型的代价函数往往涉及到距离的计算，计算预测值和真实值之间的差别，这容易导致对缺失值敏感。 神经网络的鲁棒性强，对于缺失数据不是太敏感。 贝叶斯模型对于缺失数据也比较稳定，数据量很小的时候首选贝叶斯。 总结来看：数据量很小，用朴素贝叶斯；数据量适中或较大，用树模型，优先Xgboost；数据量大，使用神经网络；避免使用距离度量相关的模型，如KNN和SVM。 12 随机森林如何评估特征重要性衡量变量重要性的方法有两种：mean decrease accuracy（平均降低精度）和mean decrease Gini（平均降低基尼系数）. Mean decrease accuracy：将一个变量的取值变为随机数，计算随机森林预测准确性的降低程度。该值越大表示该变量越重要。 Mean decrease Gini：将一个变量的取值变为随机数，计算基尼系数变化的程度，从而比较变量的重要性。该值越大表示该变量越重要。 13 GBDTGBDT中文名是梯度提升决策树，它的核心思想是，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得到真实值的累加量。具体来说就是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器，然后将训练好的弱分类器以累加的形式结合到现有模型中。例如用户A的真实年龄是25岁，但第一棵决策树的预测年龄是22岁，差了3岁，即残差为3。那么在第二棵树里我们把A的年龄设为3岁去学习，如果第二棵树能把A分到3岁的叶子节点，那两棵树的结果相加就可以得到A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在-2岁的残差，第三棵树里A的年龄就变成-2岁。这里使用残差继续学习，就是GBDT中Gradient Boosted所表达的意思。GBDT中使用的决策树通常为CART。 14 随机森林和GBDT之间的区别和联系相同点：都是由多棵树组成，最终的结果都是由多棵树一起决定。 不同点：最根本的区别是，随机森林算法使用bagging技术做出预测，GBDT采用boosting技术做预测，在bagging技术中，模型的训练是并行的，数据集用随机采样的方法被划分成n个样本集，然后，使用单一的学习算法，在所有样本上建模，接着利用投票或者求平均来组合所得到的预测。而boosting是串行运行的，在每一轮的预测之后，算法将分类出错的样本点加高权重，分对的降低权重，是分错的样本可以在后续一轮中得到校正，这种给予分类出错的样本高权重的顺序过程持续进行，直到达到停止标准为止。随机森林通过减少方差来提高模型的精度，生成树之间是不相关的，以把最大程度低减小方差。而GBDT提高了精度，减少了模型的偏差。 15 梯度提升和梯度下降的区别和联系是什么在最小化损失函数时，可以通过梯度下降思想来求得最小化的损失函数和对应的参数值，反过来，如果要求最大化的损失函数，可以通过梯度上升思想来求取。两者都是在每一轮迭代中，利用损失函数相对于模型的负梯度方向的信息来对当前模型进行更新，只不过在梯度下降中，模型是以参数化形式表示，从而模型的更新等价于参数的更新。而在梯度提升中，模型并不需要进行参数化表示，而是直接定义在函数空间中，从而大大扩展了可以使用的模型种类。 16 GBDT的优点和局限性有哪些优点 在分布稠密的数据集上，泛化能力和表达能力都很好，这使得GBDT在Kaggle的众多竞赛中，经常名列榜首。 采用决策树作为弱分类器使得GBDT模型具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系，并且也不需要对数据进行特殊的预处理如归一化等。 局限性 GBDT在高维稀疏的数据集上，表现不如支持向量机或者神经网络。 GBDT在处理文本分类特征问题上，相对其他模型的优势不如它在处理数值特征时明显。 训练过程需要串行训练。 17 XGBoost和GBDT的联系和区别原理：XGBoost类似于GBDT的优化版，在GBDT的基础上，目标函数增加了正则化项，并且在求解时做了二阶泰勒展开，不论是精度还是效率都有了提升。与GBDT相比，XGBoost具有以下的优点： 损失函数是用泰勒展式二项逼近，同时用到了一阶和二阶导数，而GBDT只用到了一阶导数信息；另外，xgboost工具还支持自定义代价函数，只要函数可以求一阶和二阶求导。 XGboost在损失函数中加入了正则化约束，降低了模型的方差，防止模型过拟合，降低了过拟合的可能性； 节点分裂的方式不同，GBDT用的是基尼系数，XGBoost是经过优化推导后的，大致思想是根据百分位法列举几个可能成为分割点的候选特征，然后从候选特征中根据公式计算找出最佳的分割点。 xgboost考虑了训练数据为稀疏值的情况，可以为缺失值指定默认的分裂方向，这能大大提升算法的效率。 xgboost借鉴了随机森林中的特征采样技术，xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。 缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。 xgboost在一定程度上并行。xgboost的并行不是树维度上的并行，xgboost也是一次迭代完才能进行下一次迭代的。xgboost的并行是在特征维度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。 传统的GBDT以CART作为基分类器，XGBoost还支持线性分类器，这个时候XGBoost相当于带L1和L2正则化向的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。 xgboost还考虑了当数据量比较大，内存不够时怎么有效使用磁盘，主要是结合多线程，数据压缩，分片的方法，尽可能的提高算法的效率。 可并行的近似直方图算法，树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点，当数据无法一次载入内存或在分布式情况下，贪心算法的效率就会变得很低，所以XGBoost提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。 18 为什么XGBoost要用泰勒展开 Xgboost，当目标函数是MSE时，展开是一阶项（残差）+二阶项的形式，而其他目标函数，如logloss的展开式就没有这样的形式。为了能有个统一的形式，所以采用泰勒展开来得到二阶项，这样就能把MSE推导的那套直接复用到其他自定义损失函数上。简短来说，就是为了统一损失函数求导的形式以支持自定义损失函数。这是从为什么会想到引入泰勒二阶的角度来说的。 二阶信息本身就能让梯度收敛更快更准确。这一点在优化算法里的牛顿法里已经证实了。可以简单认为一阶导指引梯度方向，二阶导指引梯度方向如何变化。这是从二阶导本身的性质，也就是为什么要用泰勒二阶展开的角度来说的。 19 XGBoost如何寻找最优特征？是有放回还是无放回的？xgboost在训练的过程中给出各个特征的增益评分，最大增益的特征会被选出来作为分裂依据,从而记忆了每个特征对在模型训练时的重要性—从根到叶子中间节点涉及某特征的次数作为该特征重要性排序.XGBoost属于Boosting集成学习方法，样本是不放回的，因而每轮计算样本不重复，另一方面，XGBoost支持子采样，也就是每轮计算可以不适用全部样本，以减少过拟合，xgboost还支持列采样，每轮按照百分比随机采样一部分特征，既提高计算速度又减少过拟合。 20 AdaBoost V.S. GBDT它们都属于boosting提升方法，只是损失函数不同。AdaBoost用错分数据点来识别问题，通过调整错分数据点的权重来改进模型。GBDT通过负梯度来识别问题，通过计算负梯度来改进模型。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-采样]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%87%87%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-采样相关内容。 1 采样的本质及在机器学习中的应用采样本质上是对随机现象的模拟，根据给定的概率分布，来模拟产生一个对应的随机事件。采样可以让人们对随机事件及其产生过程有更直观的认识。例如，通过对二项分布的采样，可以模拟“抛硬币出现正面还是反面”这个随机事件，进而模拟产生一个多次抛硬币出现的结果序列，或者计算多次抛硬币后出现正面的频率。 另一方面，采样得到的样本集也可以看作是一种非参数模型，即用较少量的样本点（经验分布）来近似总体分布，并刻画总体分布中的不确定性。从这个角度来说，采样其实也是一种信息降维，可以起到简化问题的作用。例如，在训练机器学习模型时，一般想要优化的是模型在总体分布上的期望损失（期望风险），但总体分布可能包含无穷多个样本点，要在训练时全部用上几乎是不可能的，采集和存储样本的代价也非常大。因此，一般采用总体分布的一个样本集来作为总体分布的近似，称之为训练集，训练模型的时候是最小化模型在训练集上损失函数（经验风险）。同理，在评估模型时，也是看模型在另外一个样本集（测试集）上的效果。这种信息降维的特性，使得采样在数据可视化方面也有很多应用，它可以帮助人们快速、直观地了解总体分布中数据的结构和特性。 2 自助采样(bootstrap sampling)自助采样法是一种有放回的采样策略，给定包含m个样本的数据集，我们先随机取出一个样本放入采样集中，再把该样本放回初始数据集，使得下次采样时该样本仍有可能被选中，这样，经过m次随机采样操作，我们得到含m个样本的采样集，初始训练集中有的样本在采样集里多次出现，有的则从未出现。样本在m次采样中始终不被采到的概率是(1-1/m)m，取极限得到 $\lim _{m \rightarrow \infty}\left(1-\frac{1}{m}\right)^{m} \mapsto \frac{1}{e} \approx 0.368$ ，初始训练集中约有63.2%的样本出现在来样集中。自助采样过程还给Bagging带来了另一个优点，由于每个基学习器只使用了初始训练集中约63.2%的样本，剩下约36.8%的样本可用作验证集来对泛化性能进行”包外估计”（oob）。事实上，包外样本还有许多其他用途.例如当基学习器是决策树时，可使用包外样本来辅助剪枝，或用于估计决策树中各结点的后验概率以辅助对零训练样本结点的处理;当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险. 3 不均衡样本集的采样策略 基于数据的方法首先可以直接对训练集里的反类样例进行”欠采样”(under sampling)，即去除一些反例使得正、反例数目接近，然后再进行学习;还可以对训练集里的正类样例进行”过采样”(oversampling)，即增加一些正例使得正、反例数目接近，然后再进行学习;（有放回）。另外还可以对少数类样本进行一些噪声扰动或变换（如图像数据集中对图片进行裁剪、翻转、旋转、加光照等）以构造出新的样本； 基于算法的方法直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，改变判断阈值；也可以通过改变模型训练时的目标函数（如代价敏感学习中不同类别有不同的权重）来矫正这种不平衡性；当样本数目极其不均衡时，也可以将问题转化为单类学习（one-class learning）、或异常检测（anomaly detection）问题。 4 癌症检测的数据集，取得了96%的分离精度，还能做什么优化癌症检测的数据集是一个不平衡数据集，在不平衡数据集中，精度不应该被用来作为衡量模型的标准，因为96%可能只有正确预测多数多类但我们感兴趣的是那些少数分类（4%），是那些被诊断出癌症的病人。 为了评价模型的性能，应该用灵敏度（真阳性率），特异性（真阴性率），F值用来确定这个分类器的性能。如果在那4%的数据上表现不好，我们可以采取以下步骤： 我们可以使用欠采样，过采样让数据平衡 我们可以通过概率验证和利用AUC-ROC曲线找到最佳阈值来调整预测阈值 我们可以给分类分配权重，那些较少的分类获得较大的权重 我们还可以使用异常检测 5 将训练集随机抽样地分成训练集验证集，验证精度很差在做分类问题时，我们应该使用分层抽样而不是随机抽样，随机抽样不考虑目标类别的比例，而分层抽样有助于保持目标变量在所得分布样本中的分布。 分层抽样：也叫类型抽样法，就是将总体单位按其属性特征分成若干类型或层，然后在类型或层中随机抽取样本。特点：由于通过划类分层，增大了各类型中单位间的共同性，容易抽出具有代表性的调查样本，适用于总体情况复杂，各单位之间差异较大，单位较多的情况。 6 实现均匀分布随机数生成器首先需要明确的是，计算机程序都是确定性的，因此并不能产生真正意义上的完全均匀分布随机数，只能产生伪随机数（伪随机数是指这些数字虽然是通过确定性的程序产生的，但是它们能通过近似的随机性测试）。另外，由于计算机的存储和计算单元只能处理离散状态值，因此也不能产生连续均匀分布随机数，只能通过离散分布来逼近连续分布（用很大的离散空间来提供足够的精度）。 一般可采用线性同余法（Linear Congruential Generator）来生成离散均匀分布伪随机数，计算公式为 x_{t+1} \equiv a \cdot x_{t}+c(\bmod m)也就是根据当前生成的随机数 $x_t$ 来进行适当变换，进而产生下一次的随机数 $x_{t+1}$ 。初始值 $x_0$ 称为随机种子。上式得到的是区间$[0,m−1]$上的随机整数，如果想要得到区间$[0,1]$上的连续均匀分布随机数，用 $x_t$ 除以 $m$ 即可。 可以看出，线性同余法得到的随机数并不是相互独立的（即下一次的随机数根据当前随机数来产生）。此外，根据上式，该算法最多只能产生m个不同的随机数，实际上对于特定的种子，很多数无法取到，循环周期基本达不到m。如果进行多次操作，得到的随机数序列会进入循环周期。因此，一个好的线性同余随机数生成器，要让其循环周期尽可能接近m，这就需要精心选择合适的乘法因子a和模数m（需要利用代数和群理论）。具体实现中有多种不同的版本，例如gcc中采用的glibc版本： \left\{\begin{array}{l}{m=2^{31}-1} \\ {a=1103515245} \\ {c=12345}\end{array}\right.由计算机程序实现的随机数生成器产生的都是伪随机数，真正的随机数只会存在于自然界的物理现象中，比如放射性物质的衰变，温度、气流的随机扰动等。 7 常见的采样方法对于一个随机变量，通常用概率密度函数来刻画该变量的概率分布特性。具体来说，给定随机变量的一个取值，可以根据概率密度函数来计算该值对应的概率（密度）。反过来，也可以根据概率密度函数提供的概率分布信息来生成随机变量的一个取值，这就是采样。因此，从某种意义上来说，采样是概率密度函数的逆向应用。 通用的采样方法主要有三种逆变换采样，拒绝采样，重要性采样。几乎所有的采样方法都是以均匀分布随机数作为基本操作。均匀分布随机数一般用线性同余法来产生。如果随机变量x和u存在变换关系，则它们的概率密度函数有如下关系： p(u)\left|\varphi^{\prime}(x)\right|=p(x)因此，如果从目标分布 $p(x)$ 中不好采样x，可以构造一个变换 $\mu=\varphi(\mathrm{x})$ ，使得从变换后的分布 $p(u)$ 中采样 $u$ 比较容易，这样可以通过先对 $u$ 进行采样然后通过反函数 $\mathrm{x}=\varphi^{-1}(\mu)$ 得到 x。如果是高维空间的随机变量，则 $\varphi^{\prime}(\mathrm{x})$ 对应的是雅克比行列式。注：在向量微积分中，雅可比矩阵是一阶偏导数以一定方式排列成的矩阵，其行列式称为雅可比行列式。雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。因此，雅可比矩阵类似于多元函数的导数。 特别地，在函数变换法中，如果变换关系 $\varphi(\cdot)$ 是 x 的累积分布函数的话，则得到所谓的逆变换采样（Inverse Transform Sampling）。假设待采样的目标分布的概率密度函数为p(x)，它的累积分布函数为 u=\Phi(x)=\int_{-\infty}^{x} p(t) \mathrm{d} t则逆变换采样法按如下过程进行采样： 从均匀分布 $U(0,1)$ 产生一个随机数 $u_i$； 计算 $\mathrm{x}=\varphi^{-1}(\mu)$ ，其中 $\varphi^{-1}(\cdot)$ 是累积分布函数的逆函数。 如果待采样的目标分布的累积分布函数的逆函数无法求解或者不容易计算，则不适用于逆变换采样法。此时可以构造一个容易采样的参考分布，先对参考分布进行采样，然后对得到的样本进行一定的后处理操作，使得最终的样本服从目标分布。常见的拒绝采样（Rejection Sampling）、重要性采样（Importance Sampling），就属于这类采样算法，下面分别简单介绍它们的采样过程。 拒绝采样，又叫接受/拒绝采样（Accept-Reject Sampling）。对于目标分布$p(x)$，选取一个容易采样的参考分布$q(x)$，使得对于任意x都有 $p(x) \leqslant M \cdot q(x)$，则可以按如下过程进行采样：（1）从参考分布$q(x)$中随机抽取一个样本$x_i$。（2）从均匀分布$U(0,1)$产生一个随机数$u_i$。（3）如果 $u_{i}&lt;\frac{p\left(x_{i}\right)}{M q\left(x_{i}\right)}$，则接受样本$x_i$；否则拒绝，重新进行步骤（1）～（3），直到新产生的样本xi被接受。 拒绝采样的关键是为目标分布$p(x)$选取一个合适的包络函数$M·q(x)$：包络函数越紧，每次采样时样本被接受的概率越大，采样效率越高。在实际应用中，为了维持采样效率，有时很难寻找一个解析形式的$q(x)$，因此延伸出了自适应拒绝采样（Adaptive Rejection Sampling），在目标分布是对数凹函数时，用分段线性函数来覆盖目标分布的对数$lnp(x)$. 如果只想从目标分布$p(x)$中采样出若干样本，则可以用重要性重采样（Sampling-Importance Re-sampling，SIR），先在从参考分布$q(x)$中抽取N个样本$\{x_i\}$，然后按照它们对应的重要性权重$\{\mathrm{w}(\mathrm{x_i})]$对这些样本进行重新采样（这是一个简单的针对有限离散分布的采样），最终得到的样本服从目标分布 $p(x)$。 在实际应用中，如果是高维空间的随机向量，拒绝采样和重要性重采样经常难以寻找合适的参考分布，采样效率低下（样本的接受概率小或重要性权重低），此时可以考虑马尔可夫蒙特卡洛采样法，常见的有Metropolis-Hastings采样法和吉布斯采样法。 8 高斯分布的采样实验中直接调用函数就可以生成高斯分布随机数标准高斯分布randn，可指定mean和sigma：normrnd。理论上有逆变换法、拒绝采样、重要性采样、马尔可夫蒙特卡洛采样法。如果直接用逆变换法，基本操作步骤为：（1）产生$[0,1]$上的均匀分布随机数$u$。（2）令 $z=\sqrt{2} \operatorname{erf}^{-1}(2 u-1)$，则z服从标准正态分布。其中$\operatorname{erf}(\cdot)$是高斯误差函数，它是标准正态分布的累积分布函数经过简单平移和拉伸变换后的形式，定义如下 \operatorname{crf}(x)=\frac{2}{\sqrt{\pi}} \int_{0}^{x} \mathrm{e}^{-x^{2}} \mathrm{d} t除了逆变换法，我们还可以利用拒绝采样法，选择一个比较好计算累积分布逆函数的参考分布来覆盖当前正态分布（可以乘以一个常数倍），进而转化为对参考分布的采样以及对样本点的拒绝/接收操作。考虑到高斯分布的特性，这里可以用指数分布来作为参考分布。指数分布的累积分布及其逆函数都比较容易求解。由于指数分布的样本空间为$x \geqslant 0$，而标准正态分布的样本空间为 $(-\infty,+\infty)$ ，因此还需要利用正态分布的对称性来在半坐标轴和全坐标轴之间转化。具体来说，取 $\lambda=1$ 的指数分布作为参考分布，其密度函数为$q(x)=\mathrm{e}^{-x}$对应的累积分布函数及其逆函数分别为$F(x)=1-e^{-x}$ 和 $F^{-1}(u)=-\log (1-u)$。 利用逆变换法很容易得到指数分布的样本，然后再根据拒绝采样法来决定是否接受该样本，接受的概率为$A(x)=\frac{p(x)}{M \cdot q(x)}$。 实际应用时，$M$需要尽可能小，这样每次的接受概率大，采样效率更高。因此，具体的采样过程如下：（1）产生$[0,1]$上的均匀分布随机数 $u_0$，计算 $x=F^{-1}\left(u_{0}\right)$ 得到指数分布的样本x。（2）再产生$[0,1]$上的均匀分布随机数 $u_1$，若$u_{1}&lt;A(x)$ ，则接受 x，进入下一步；否则拒绝，跳回到步骤1重新采样。（3）最后再产生$[0,1]$上的均匀分布随机数$u_2$，若$u_2&lt;0.5$，则将$x$转化为$−x$，否则保持不变；由此最终得到标准正态分布的一个样本。 9 马尔可夫蒙特卡洛采样法 MCMCMCMC主要解决在高维空间中，拒绝采样和重要性重采样经常难以寻找合适的参考分布，采样效率低下的问题。从名字看，MCMC采样法主要包括两个MC，即蒙特卡洛法（Monte Carlo）和马尔可夫链（Markov Chain）。蒙特卡洛法是指基于采样的数值型近似求解方法，而马尔可夫链则用于进行采样。MCMC采样法基本思想是：针对待采样的目标分布，构造一个马尔可夫链，使得该马尔可夫链的平稳分布就是目标分布；然后，从任何一个初始状态出发，沿着马尔可夫链进行状态转移，最终得到的状态转移序列会收敛到目标分布，由此可以得到目标分布的一系列样本。在实际操作中，核心点是如何构造合适的马尔可夫链，即确定马尔可夫链的状态转移概率 简单介绍几种常见的MCMC采样法。 Metropolis-Hastings采样法：对于目标分布$p(x)$，首先选择一个容易采样的参考条件分布$q(x^{*}|x)$，并令 A(x, \dot{x})=\min \left\{1, \frac{p\left(x^{*}\right) q\left(x | x^{*}\right)}{p(x) q\left(x^{*} | x\right)}\right\}然后根据如下过程进行采样： 随机选一个初始样本$x^{(0)}$。 Fort=1,2,3,…:根据参考条件分布 $q\left(X^{*} X^{(t-1)}\right)$ 抽取一个样本 $x^{*}$；根据均匀分布$U(0,1)$产生随机数$u$；若$u&lt;A\left(x^{(t-1)}, x^{*}\right)$，则令$x^{(t)}=x^{*}$，否则令$x^{(t)}=x^{(t-1)}$。 上述过程得到的样本序列最终会收敛到目标分布$p(x)$。 吉布斯采样法:吉布斯采样法是Metropolis-Hastings算法的一个特例，其核心思想是每次只对样本的一个维度进行采样和更新。在拒绝采样中，如果在某一步中采样被拒绝，则该步不会产生新样本，需要重新进行采样。与此不同，MCMC采样法每一步都会产生一个样本，只是有时候这个样本与之前的样本一样而已。另外，MCMC采样法是在不断迭代过程中逐渐收敛到平稳分布的，因此实际应用中一般会对得到的样本序列进行“burn-in”处理，即截除掉序列中最开始的一部分样本，只保留后面的样本。 10 MCMC采样法如何得到相互独立的样本与一般的蒙特卡洛算法不同，MCMC采样法得到的样本序列中相邻的样本不是独立的，因为后一个样本是由前一个样本根据特定的转移概率得到的，或者有一定概率就是前一个样本。如果仅仅是采样，并不需要样本之间相互独立。如果确实需要产生独立同分布的样本，可以同时运行多条马尔可夫链，这样不同链上的样本是独立的；或者在同一条马尔可夫链上每隔若干个样本才选取一个，这样选取出来的样本也是近似独立的。 11 马尔科夫采样收敛到目标分布本身的数学推导很复杂，是由于马尔科夫本身的性质决定的，比如时齐性、细致平衡条件、可遍历性等。可以举个例子说明PageRank：Google的民主表决式网页排名技术 。“PageRank”的核心思想就是如果一个网页被很多其他网页所链接，说明它受到普遍的承认和信赖，那么它的排名就高。当然实际并不是这么简单，还需考虑各个网页的权重。但是权重该如何度量呢？但是如果单纯用网页排名，那这岂不是成了”先有鸡还是先有蛋“的问题了吗？Google创始人之一谢盖尔 布林破解了怪圈，他将这个问题变成二维矩阵相乘问题，先假定初始排名相同，然后进行迭代直到收敛。他俩从理论证明了无论初始值如何选，这种算法都能保证网页排名的估计值收敛到真实值。这其实就是马尔科夫的收敛性。当然如今决定搜索质量不仅依靠网页与网页之间的关系，还有用户的点击信息。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-特征工程]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-特征工程相关内容。 1 什么是特征工程对于一个机器学习问题，数据和特征往往决定了结果的上限，而模型、算法的选择及优化则是在逐步接近这个上限。 特征工程是指对原始数据进行一系列工程处理，将其提炼为特征，作为输入供算法和模型使用。从本质上来讲，特征工程是一个表示和展现数据的过程。在实际工作中，特征工程旨在去除原始数据中的杂质和冗余，设计更高效的特征以刻画求解的问题与预测模型之间的关系。特征工程主要包括数据与特征处理，特征选择和降维三部分内容。 对数据进行预处理，可提高数据质量，提高挖掘质量。对数据进行清洗可填充缺失值，光滑噪声数据，识别和删除离群点数据，保证数据的一致性。使用正确的采样方法可解决因数据不平衡带来的预测偏差。 对不同的数据类型进行不同的特征处理有助于提高特征的可用性。例如： 对数值型数据进行归一化可将数据转化到同一量纲下； 对类别性数据，可以使用one-hot编码方法将类别数据数字化，数字化特征之后可用来计算距离，相似性等； 可从时间型数据中提取更多的时间特征，如年月日等，这些特征对于业务场景以及模型的预测往往有很大的帮助，统计性特征处理有助于从业务场景中挖掘更丰富的信息。 2 数据预处理数据预处理：无量纲化（标准化，区间缩放法，标准化与归一化的区别），对定量标准二值化，对定性特征哑编码，缺失值计算，数据变换。步骤如下: 将数据导入 看数据。重点看元数据，即对字段解释，数据来源等信息，导入数据后，提取部分数据进行查看 缺失值清洗。根据需要对缺失值进行处理，可以删除数据或填充数据。重新取数：如果某些非常重要的字段缺失，需要和负责采集数据的人沟通，是否可以再次获得。 数据格式清洗：统一数据的时间，日期，全半角等显示格式 逻辑错误的数据：重复的数据，不合理的值 不一致错误的处理：指对矛盾内容的修正，最常见的如身份证号和出生年月日不对应。 3 处理类别型特征 序号编码，序号编码通常用于处理类别间具有大小关系的数据，例如成绩，可以分为低、中、高三档，并且存在“高&gt;中&gt;低”的排序关系。序号编码会按照大小关系对类别型特征赋予一个数值ID，例如高表示为3、中表示为2、低表示为1，转换后依然保留了大小关系。 独热编码，独热编码通常用于处理类别间不具有大小关系的特征。例如血型，一共有4个取值（A型血、B型血、AB型血、O型血），独热编码会把血型变成一个4维稀疏向量，A型血表示为（1,0,0,0），B型血表示为（0,1,0,0），AB型表示为（0,0,1,0），O型血表示为（0,0,0,1）。 二进制编码，二进制编码主要分为两步，先用序号编码给每个类别赋予一个类别ID，然后将类别ID对应的二进制编码作为结果。以A、B、AB、O血型为例。A型血的ID为1，二进制表示为001；B型血的ID为2，二进制表示为010；以此类推可以得到AB型血和O型血的二进制表示。可以看出，二进制编码本质上是利用二进制对ID进行哈希映射，最终得到0/1特征向量，且维数少于独热编码，节省了存储空间。 4 特征选择的方法filter（过滤式）：过滤式方法先对数据集进行特征选择，然后再训练学习器，特征选择过程与后续学习器无关。这相当于先用特征选择过程对初始特征进行”过滤”，再用过滤后的特征来训练模型。 Relief(Relevant Features)是一种著名的过滤式特征选择方法，该方法设计了一个”相关统计量”来度量特征的重要性。该统计量是一个向量，其每个分量分别对应于一个初始特征，而特征子集的重要性则是由子集中每个特征所对应的相关统计量分量之和来决定。于是，最终只需指定一个阈值T，然后选择比T大的相关统计量分量所对应的特征即可；也可指定欲选取的特征个数k，然后选择相关统计量分量最大的k个特征。 wrapper（包裹式）：与过滤式特征选择不考虑后续学习器不同，包裹式特征选择直接把最终将要使用的学习器的性能作为特征子集的评价准则。换言之，包裹式特征选择的目的就是为给定学习器选择最有利于其性能、”量身定做”的特征子集。 一般而言，由于包裹式特征选择方法直接针对给定学习器进行优化，因此从最终学习器性能来看，包裹式特征选择比过滤式特征选择更好，但另一方面，由于在特征选择过程中需多次训练学习器，因此包裹式特征选择的计算开销通常比过滤式特征边择大得多。 embedded（嵌入法）：基于惩罚项的特征选择法。 在过滤式和包裹式特征选择方法中，特征选择过程与学习器训练过程有明显的分别；与此不同，嵌入式特征选择是将特征选择过程与学习器训练过程融为一体，两者在同一个优化过程中完成，即在学习器训练过程中自动地进行了特征选择。常见的有LASSO回归。 5 如何进行特征选择特征选择是一个重要的数据预处理过程，主要有两个目的：一是减少特征数量，降维，使模型泛化能力更强，减少过拟合；二是增强对特征和特征值之前的理解。常见的特征选择方法： 去除方差较小的特征； 单变量特征选择，对每一个特征进行测试，衡量该特征和输出响应之间的关系，根据得分去掉不好的特征； 使用正则化。L1正则化能够使模型变得稀疏。L2正则化的表现更加稳定，由于有用的特征对应系数非零。 随机森林 平均不纯度减少mean decrease impurity：利用不纯度确定节点分裂特征，对于分类问题，通常采用基尼系数或者信息增益，对于回归问题，通常采用方差或者最小二乘拟合，当训练决策树的时候，可以计算出每个特征减少了多少不纯度，并把它减少的不纯度作为特征选择的值。 平均精确率减少Mean decrease accuracy：直接度量每个特征对模型精确率的影响，主要思路是分别打乱每个特征的特征值排序，并且度量顺序变动对模型的精确率的影响。很明显，对于不重要的变量来说，打乱顺序对模型的精确率影响不会太大，但是对于重要的顺序，打乱顺序就会降低模型的精确率 稳定性选择Stability selection。稳定性选择是一种二次抽样和特征选择算法相结合的较新的方法，选择算法可以是回归，SVM或其他类似的方法。它的主要思想是在不同的数据子集和特征子集上运行特征选择算法，不断的重复，最终汇总特征选择结果，比如可以统计某个特征被认为是重要特征的频率（被选为重要特征的次数除以它所在的子集被测试的次数）。理想情况下，重要特征的得分会接近100%。稍微弱一点的特征得分会是非0的数，而最无用的特征得分将会接近于0。 递归特征消除Recursive feature elimination(RFE)。递归特征消除的主要思想是反复地构建模型，然后选出最好的特征（可以根据系数来选），把选出来的特征放在一边，然后在剩余的特征上重复这个过程，直到所有特征都遍历了。这个过程中特征被消除的次序就是特征的排序。因此这是一种寻找最优特征子集的贪心算法。 6 组合特征为了提高复杂关系的拟合能力，在特征工程中经常会把一阶离散特征两两组合，构成高阶组合特征。两个特征的取值数量分别为m和n，那么组合之后的规模为m×n。 7 有效地寻找组合特征如果简单地两两组合，依然容易存在参数过多、过拟合等问题，而且并不是所有的特征组合都是有意义的，可以使用基于决策树的特征组合寻找方法，每一条从根节点到叶节点的路径都可以看成一种特征组合的方式。 8 标准化和归一化的区别标准化：将数据按比例缩放，使每个特征的均值变为0，标准差变为1.目的是使得不同度量之间的特征具有可比性的同时不改变原始分布，对目标函数的影响体现在几何分布上。$X^{\prime}=(x-u) / \sigma$。 归一化：将有量纲的表达式变成无量纲的表达式，便于不同单位或量级的指标能够进行比较和加权，一般是将数据变成(0,1)或者(1,1)之间的小数，归一化会改变原始数据的分布，使各个特征维度对目标函数的影响权重是一致的，也就是使那些扁平分布的数据伸缩变换成类圆形分布，对目标函数的影响体现在数值上。$X^{\prime}=(x-x_{min} ) /(x_{max} -x_{min} )$。 一个椭圆形分布的数据，如果采用标准化，不会改变两个维度上的分布，还是会保持椭圆形。而采用归一化则会在不同维度上对数据进行不同的伸缩变换，会改变数据的原始距离及分布信息，使其呈类圆形。 虽然归一化会丢掉数据的原始信息，但这防止了直接对原始数据进行梯度下降的优化算法时最终被数值大的特征所主导，归一化之后，各个特征对目标函数的影响权重是一致的，可以提升模型的收敛速度和提高模型的精度。 9 归一化的作用归一化加快了梯度下降求最优解的速度，归一化有可能提高精度。 提升收敛速度：在特征量纲不一样时，可能一个特征的数值远大于另一个特征，在用原始数据进行优化时，会得到一个窄长的椭圆形，导致在梯度下降时，梯度的方向为垂直等高线的方向而走之字形路线，这样会使迭代很慢，相比之下，归一化的迭代就会很快，即步长走多走少方向总是对的，不会走偏。 提升模型的精度：比如算法要计算欧氏距离，当各特征之间的水平相差很大时，如果直接使用原始数据进行分析，就会突出数值较大的特征在计算时的作用，相对削弱数值较小的特征的作用，而实际上我们可能认为两个维度对结果同样重要，所以不进行归一化会造成精度的损失，这在距离计算的算法中影响较大。 10 不需要做归一化的机器学习算法在实际应用中，通过梯度下降法求解的模型一般都是需要归一化的，如线性回归，逻辑斯蒂回归，KNN，SVM，神经网络等模型。但树模型不需要归一化，因为树模型不关心特征的值，而是只关心特征的分布和特征之间的条件概率，如决策树，随机森林等。 11 文本表示模型 词袋模型和N-gram模型 最基础的文本表示模型是词袋模型。顾名思义，就是将每篇文章看成一袋子词，并忽略每个词出现的顺序。具体地说，就是将整段文本以词为单位切分开，然后每篇文章可以表示成一个长向量，向量中的每一维代表一个单词，而该维对应的权重则反映了这个词在原文章中的重要程度。常用TF-IDF来计算权重，公式为 \mathrm{TF}-\mathrm{IDF}(t, d)=\mathrm{TF}(t, d) \times \operatorname{IDF}(t)其中 $\mathrm{TF}(t, d)$ 为单词 t 在文档 d 中出现的频率，$\operatorname{IDF}(t)$ 是逆文档频率，用来衡量单词 t 对表达语义所起的重要性，表示为 \operatorname{IDF}(t)=\log \frac{文章总数}{包含单词t的文章总数+1}直观的解释是，如果一个单词在非常多的文章里面都出现，那么它可能是一个比较通用的词汇，对于区分某篇文章特殊语义的贡献较小，因此对权重做一定惩罚。 将文章进行单词级别的划分有时候并不是一种好的做法，比如英文中的natural language processing（自然语言处理）一词，如果将natural，language，processing这3个词拆分开来，所表达的含义与三个词连续出现时大相径庭。通常，可以将连续出现的n个词（n≤N）组成的词组（N-gram）也作为一个单独的特征放到向量表示中去，构成N-gram模型。另外，同一个词可能有多种词性变化，却具有相似的含义。在实际应用中，一般会对单词进行词干抽取（Word Stemming）处理，即将不同词性的单词统一成为同一词干的形式。 主题模型 基于词袋模型或N-gram模型的文本表示模型有一个明显的缺陷，就是无法识别出两个不同的词或词组具有相同的主题。因此，需要一种技术能够将具有相同主题的词或词组映射到同一维度上去，于是产生了主题模型。主题模型是一种特殊的概率图模型。想象一下我们如何判定两个不同的词具有相同的主题呢？这两个词可能有更高的概率同时出现在同一篇文档中；换句话说，给定某一主题，这两个词的产生概率都是比较高的，而另一些不太相关的词汇产生的概率则是较低的。假设有K个主题，我们就把任意文章表示成一个K维的主题向量，其中向量的每一维代表一个主题，权重代表这篇文章属于这个特定主题的概率。主题模型所解决的事情，就是从文本库中发现有代表性的主题（得到每个主题上面词的分布），并且计算出每篇文章对应着哪些主题。 常见的主题模型：pLSA（Probabilistic Latent Semantic Analysis），LDA（Latent Dirichlet Allocation） 词嵌入与深度学习模型 词嵌入是一类将词向量化的模型的统称，核心思想是将每个词都映射成低维空间（通常K=50～300维）上的一个稠密向量（Dense Vector）。K维空间的每一维也可以看作一个隐含的主题，只不过不像主题模型中的主题那样直观。 由于词嵌入将每个词映射成一个K维的向量，如果一篇文档有N个词，就可以用一个N×K维的矩阵来表示这篇文档，但是这样的表示过于底层。在实际应用中，如果仅仅把这个矩阵作为原文本的表示特征输入到机器学习模型中，通常很难得到令人满意的结果。因此，还需要在此基础之上加工出更高层的特征。在传统的浅层机器学习模型中，一个好的特征工程往往可以带来算法效果的显著提升。而深度学习模型正好为我们提供了一种自动地进行特征工程的方式，模型中的每个隐层都可以认为对应着不同抽象层次的特征。从这个角度来讲，深度学习模型能够打败浅层模型也就顺理成章了。卷积神经网络和循环神经网络的结构在文本表示中取得了很好的效果，主要是由于它们能够更好地对文本进行建模，抽取出一些高层的语义特征。与全连接的网络结构相比，卷积神经网络和循环神经网络一方面很好地抓住了文本的特性，另一方面又减少了网络中待学习的参数，提高了训练速度，并且降低了过拟合的风险。 12 Word2Vec原理，与LDA的区别与联系Word2Vec是目前最常用的词嵌入模型之一。Word2Vec实际是一种浅层的神经网络模型，它有两种网络结构，分别是CBOW（Continues Bag of Words）和Skip-gram。CBOW的目标是根据上下文出现的词语来预测当前词的生成概率；而Skip-gram是根据当前词来预测上下文中各词的生成概率。 CBOW和Skip-gram都可以表示成由输入层（Input）、映射层（Projection）和输出层（Output）组成的神经网络。输入层中的每个词由独热编码方式表示，即所有词均表示成一个N维向量，其中N为词汇表中单词的总数。在向量中，每个词都将与之对应的维度置为1，其余维度的值均设为0。在映射层（又称隐含层）中，K个隐含单元（Hidden Units）的取值可以由N维输入向量以及连接输入和隐含单元之间的N×K维权重矩阵计算得到。在CBOW中，还需要将各个输入词所计算出的隐含单元求和。 同理，输出层向量的值可以通过隐含层向量（K维），以及连接隐含层和输出层之间的K×N维权重矩阵计算得到。输出层也是一个N维向量，每维与词汇表中的一个单词相对应。最后，对输出层向量应用Softmax激活函数，可以计算出每个单词的生成概率。Softmax激活函数的定义为 P\left(y=w_{n} | x\right)=\frac{\mathrm{e}^{x_{n}}}{\sum_{k=1}^{N} \mathrm{e}^{x_{k}}}Word2Vec与LDA的区别和联系： 首先，LDA是利用文档中单词的共现关系来对单词按主题聚类，也可以理解为对“文档-单词”矩阵进行分解，得到“文档主题”和“主题-单词”两个概率分布。而Word2Vec其实是对“上下文-单词”矩阵进行学习，其中上下文由周围的几个单词组成，由此得到的词向量表示更多地融入了上下文共现的特征。也就是说，如果两个单词所对应的Word2Vec向量相似度较高，那么它们很可能经常在同样的上下文中出现。 需要说明的是，上述分析的是LDA与Word2Vec的不同，不应该作为主题模型和词嵌入两类方法的主要差异。主题模型通过一定的结构调整可以基于“上下文-单词”矩阵进行主题推理。同样地，词嵌入方法也可以根据“文档-单词”矩阵学习出词的隐含向量表示。 主题模型和词嵌入两类方法最大的不同其实在于模型本身，主题模型是一种基于概率图模型的生成式模型，其似然函数可以写成若干条件概率连乘的形式，其中包括需要推测的隐含变量（即主题）；而词嵌入模型一般表达为神经网络的形式，似然函数定义在网络的输出之上，需要通过学习网络的权重以得到单词的稠密向量表示。 13 图像数据不足时的处理方法一个模型所能提供的信息一般来源于两个方面，一是训练数据中蕴含的信息；二是在模型的形成过程中（包括构造、学习、推理等），人们提供的先验信息。当训练数据不足时，说明模型从原始数据中获取的信息比较少，这种情况下要想保证模型的效果，就需要更多先验信息。先验信息可以作用在模型上，例如让模型采用特定的内在结构、条件假设或添加其他一些约束条件；先验信息也可以直接施加在数据集上，即根据特定的先验假设去调整、变换或扩展训练数据，让其展现出更多的、更有用的信息，以利于后续模型的训练和学习。 具体到图像分类任务上，训练数据不足带来的问题主要表现在过拟合方面，即模型在训练样本上的效果可能不错，但在测试集上的泛化效果不佳。根据上述讨论，对应的处理方法大致也可以分两类： 一是基于模型的方法，主要是采用降低过拟合风险的措施，包括简化模型（如将非线性模型简化为线性模型）、添加约束项以缩小假设空间（如L1/L2正则项）、集成学习、Dropout超参数等； 二是基于数据的方法，主要通过数据扩充（Data Augmentation），即根据一些先验知识，在保持特定信息的前提下，对原始数据进行适当变换以达到扩充数据集的效果。具体到图像分类任务中，在保持图像类别不变的前提下，可以对训练集中的每幅图像进行以下变换。-（1）一定程度内的随机旋转、平移、缩放、裁剪、填充、左右翻转等，这些变换对应着同一个目标在不同角度的观察结果。 （2）对图像中的像素添加噪声扰动，比如椒盐噪声、高斯白噪声等。 （3）颜色变换。例如，在图像的RGB颜色空间上进行主成分分析，得到3个主成分的特征向量及其对应的特征值，然后在每个像素的RGB值上添加方差较小的高斯分布随机数。 （4）改变图像的亮度、清晰度、对比度、锐度等。 除了直接在图像空间进行变换，还可以先对图像进行特征提取，然后在图像的特征空间内进行变换，利用一些通用的数据扩充或上采样技术，例如SMOTE（Synthetic Minority Over-sampling Technique）算法。抛开上述这些启发式的变换方法，使用生成模型也可以合成一些新样本，例如当今非常流行的生成式对抗网络模型。 此外，借助已有的其他模型或数据来进行迁移学习在深度学习中也十分常见。例如，对于大部分图像分类任务，并不需要从头开始训练模型，而是借用一个在大规模数据集上预训练好的通用模型，并在针对目标任务的小数据集上进行微调（fine-tune），这种微调操作就可以看成是一种简单的迁移学习。 14 降维用一个低维度的向量表示原始高维度的特征显得尤为重要。常见的降维方法有主成分分析、线性判别分析、等距映射、局部线性嵌入、拉普拉斯特征映射、局部保留投影等。 15 主成分分析（PCA）PCA是一种线性、非监督、全局的降维算法，旨在找到数据中的主成分，并利用这些主成分表征原始数据，从而达到降维的目的。 工作原理可由两个角度解释，第一个是最大化投影方差（让数据在主轴上投影的方差尽可能大）；第二个是最小化平方误差（样本点到超平面的垂直距离足够近）。 优点 计算简单，易于实现 各主成分之间正交，可消除原始数据成分间的相互影响的因素 仅仅需要以方差衡量信息量，不受数据集以外的因素影响 降维维数没有限制，可根据需要制定。 缺点 无法利用类别的先验信息 降维后，只与数据有关，主成分各个维度的含义模糊，不易于解释 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响 线性模型，对于复杂数据集难以处理（可用核映射方式改进）。 步骤 对样本数据进行中心化处理（意义：投影之后均值为0）。 求样本协方差矩阵。 对协方差矩阵进行特征值分解，将特征值从大到小排列。 取特征值前d大对应的特征向量ω1,ω2,…,ωd，将n维样本映射到d维。 Note PCA最大方差理论：PCA的目标是最大化投影方差，也就是让数据在主轴上投影的方差最大。PCA旨在找到数据中的主成分，并利用这些主成分表征原始数据，从而达到降维的目的。举一个简单的例子，在三维空间中有一系列数据点，这些点分布在一个过原点的平面上。如果我们用自然坐标系x,y,z三个轴来表示数据，就需要使用三个维度。而实际上，这些点只出现在一个二维平面上，如果我们通过坐标系旋转变换使得数据所在平面与x,y平面重合，那么我们就可以通过x′,y′两个维度表达原始数据，并且没有任何损失，这样就完成了数据的降维。而x′,y′两个轴所包含的信息就是我们要找到的主成分。 16 在PCA中有必要做旋转变换是的，旋转（正交）是必要的，因为它把由主成分捕获的方差之间的差异最大化，这使得主成分更容易解释。但是我们不要忘记我们做PCA的目的是选择更少的主成分，那些选择的主成分能够解释数据集中最大方差。 通过做旋转，各主成分的相对位置不发生变化，它只能改变点的实际坐标。如果我们没有旋转主成分，PCA的效果会减弱，那样我们不得不选择更多个主成分来解释数据集里的方差。 17 数据集中部分特征高度相关的，用PCA时需要先去掉相关的变量吗需要，因为有相关变量的存在，由特征成分解释的方差被放大。如一个数据集有3个变量，其中有两个是相关的，如果在该数据集上用PCA，第一主成分的方差会是其不相关变量的差异的两倍。此外，加入相关的变量使PCA错误地提高那些变量的重要性，这是有误导的。 18 线性判别分析（LDA）LDA是为了让映射后的样本有最好的分类性能。是一种有监督的降维方法，它的中心思想是最大化类间距离和最小化类内距离。目标函数定义为类间距离和类内距离的比值。 步骤： 计算数据集中每个类别样本的均值向量 $μ_j$，及总体均值向量 $μ$。 计算类内散度矩阵 $S_w$ ，全局散度矩阵 $S_t$，并得到类间散度矩阵 $S_b = S_t-S_w$。 对矩阵 $S_{w}^{-1} S_{B}$ 进行特征值分解，将特征值从大到小排列。 取特征值前 $d$ 大的对应的特征向量，通过映射将 $n$ 维样本映射到 $d$ 维。 19 PCA和LDA的区别首先从目标出发，PCA选择的是投影后数据方差最大的方向。由于它是无监督的，因此PCA假设方差越大，信息量越多，用主成分来表示原始数据可以去除冗余的维度，达到降维。而LDA选择的是投影后类内方差小、类间方差大的方向。其用到了类别标签信息，是有监督降维算法，为了找到数据中具有判别性的维度，使得原始数据在这些方向上投影后，不同类别尽可能区分开。 20 连续特征，既可以做离散化，也可以做幅度缩放，那这两种处理方式分别适用于什么场景呢？幅度缩放一般在计算性模型里会用到，离散化一般在线性模型会用到，如LR。 21 离散化的目的： 非线性。逻辑回归属于广义线性模型，表达能力受限，单变量离散化为N个后，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型的表达能力，加大拟合；离散特征的增加和减少都很容易，易于模型的快速迭代。 速度快。稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展； 鲁棒性。离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰； 方便交叉与特征组合：离散化后可以进行特征交叉，由 $M+N$ 个变量变为$M*N$个变量，进一步引入非线性，提升表达能力； 稳定性：特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问； 简化模型：特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。 22 什么时候分类变量当成连续型变量会更得到一个更好的预测模型为了得到更好的预测，只有在分类变量在本质上是有序的情况下才可以被当做连续型变量来处理。 23 缺失值分布在离中值有1个标准偏差的范围内，百分之多少的数据不会受到影响。约有32%的数据不会受到缺失值的影响。 24 是可以捕获连续变量和分类变量之间的相关性可以的，我们可以用ANCOVA（协方差分析）技术来捕获连续变量和分类变量之间的相关性。 25 缺失值处理 把缺失值分成单独的一类，这些缺失值说不定会包含一些趋势信息 可以删除他们 我们可以用目标变量来检查他们的分布，如果发现任何模式，我们将保留那些缺失值并给他们一个新的分类，同时删除其他缺失值。 26 异常值处理 视为无效信息（噪声点）：结合异常值检测算法，检测出后直接丢弃； 视为有效信息（信号点）：作为缺失值，用缺失值的方式处理； 不处理，直接在具有异常值的数据上进行数据挖掘。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-优化算法]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-优化算法相关内容。 1 有监督学习涉及的损失函数有哪些0-1损失函数。该损失函数能够直观地刻画分类的错误率，但是由于其非凸、非光滑的特点，使得算法很难直接对该函数进行优化。 L(Y, f(X))=\left\{\begin{array}{ll}{1,} & {Y \neq f(X)} \\ {0,} & {Y=f(X)}\end{array}\right.平方损失函数：平方损失函数是光滑函数，能够用梯度下降法进行优化。然而，当预测值距离真实值越远时，平方损失函数的惩罚力度越大，因此它对异常点比较敏感。 L(Y, f(X))=(Y-f(X))^{2}绝对损失函数：对损失函数相当于是在做中值回归，相比做均值回归的平方损失函数，绝对损失函数对异常点更鲁棒一些。但是，绝对损失函数在f=y处无法求导数。综合考虑可导性和对异常点的鲁棒性， L(Y, f(X))=|Y-f(X)|对数损失函数。 L(Y, P(Y | X))=-\log P(Y | X)hinge损失函数：是0-1损失函数相对紧的凸上界，且当z≥1时，该函数不对其做任何惩罚。Hinge损失在z=1处不可导，因此不能用梯度下降法进行优化，而是用次梯度下降法（Sub gradient Descent Method） \ell_{\text {hinge}}(z)=\max (0,1-z)O-1损失函数：Hinge损失： 交叉熵损失函数 L(w)=\sum_{i=1}^{N}\left[y_{i} \log \pi\left(x_{i}\right)+\left(1-y_{i}\right) \log \left(1-\pi\left(x_{i}\right)\right)\right]Note 经验风险最小化：也就是损失函数最小，容易发生过拟合。 结构风险最小化：经验风险最小化+正则化项，防止过拟合。 2 机器学习中的优化问题，哪些是凸优化问题，哪些是非凸优化问题？凸函数曲面上任意两点连接而成的线段，其上的任意一点都不会处于该函数曲面的下方，逻辑回归，对应的优化问题就是凸优化问题，通过计算目标函数的二阶Hessian矩阵来验证凸性。Hessian矩阵为半正定，则为凸优化问题，对于凸优化问题，所有的局部极小值都是全局极小值，因此这类问题一般认为是比较容易求解的问题。 主成分分析对应的优化问题是非凸优化问题。一般来说，非凸优化问题被认为是比较难求解的问题，但主成分分析是一个特例，我们可以借助SVD直接得到主成分分析的全局极小值。其他凸优化问题的例子包括支持向量机、线性回归等线性模型，非凸优化问题的例子包括低秩模型（如矩阵分解）、深度神经网络模型等。 3 无约束优化问题的优化方法经典的优化算法可以分为直接法和迭代法两大类。 直接法，顾名思义，就是能够直接给出优化问题最优解的方法。这个方法听起来非常厉害的样子，但它不是万能的。直接法要求目标函数需要满足两个条件。第一个条件是，L(·)是凸函数。若L(·)是凸函数，那么θ是最优解的充分必要条件是L(·)在θ处的梯度为0。即▽L(θ)=0，因此，为了能够直接求解出θ，第二个条件是，上式有闭式解。同时满足这两个条件的经典例子是岭回归（Ridge Regression），其目标函数为$L(\theta)=|X \theta-y|_{2}^{2}+\lambda|\theta|_{2}^{2}$ 稍加推导就能得到最优解为$\theta^{*}=\left(X^{T} X+\lambda I\right)^{-1} X^{T} y$ 迭代法又可以分为一阶法和二阶法两类。一阶法也称梯度下降法，梯度就是目标函数的一阶信息。二阶法也称为牛顿法，Hessian矩阵就是目标函数的二阶信息。二阶法的收敛速度一般要远快于一阶法，但是在高维情况下，Hessian矩阵求逆的计算复杂度很大，而且当目标函数非凸时，二阶法有可能会收敛到鞍点（Saddle Point）。 4 梯度下降法。梯度下降法是求解无约束最优化问题的一种常用方法，它是一种迭代算法，每一步需要求解目标函数的梯度向量，选取适当的初始值进行迭代，由于负梯度方向是使函数值下降最快的方向，在迭代的每一步中，以负梯度方向按规定步长更新x的值，从而达到函数的局部极小值。相反如果向正梯度方向进行搜索，则会达到函数的局部极大值点，这个过程被称为梯度上升法。 Note 梯度：一阶导数信息 Hessian矩阵：二阶导数信息 梯度下降的缺点：当变量没有归一化，变量值处于不同的量级，它的梯度图是一个狭长的椭圆时，梯度下降算法的迭代方向会呈现一种锯齿现象，其并不能朝着极小值点径直优化，所以它的迭代次数很多，收敛速度很慢。这是由于非线性函数局部的梯度方向并不一定就是朝着最优点。 训练大规模神经网络时，因为有上万的参数，所以梯度下降法是比较有效的，因为梯度下降法的梯度算符向量规模为n，而Hessian矩阵存储的规模就为n^2，同时梯度的计算量也比Hessian矩阵小得多。 5 梯度下降法存在的问题经典的梯度下降法采用所有训练数据的平均损失来近似目标函数，在每次对模型参数进行更新时，需要遍历所有的训练数据。当M很大时，这需要很大的计算量，耗费很长的计算时间，在实际应用中基本不可行。 为了解决该问题，随机梯度下降法（Stochastic Gradient Descent，SGD）用单个训练样本的损失来近似平均损失，用单个训练数据即可对模型参数进行一次更新，大大加快了收敛速率。该方法也非常适用于数据源源不断到来的在线更新场景。 6 梯度下降法找到的一定是下降最快的方向吗梯度下降法并不是全局下降最快的方向，它只是目标函数在当前的点的切平面上下降最快的方向，即在局部是下降最快，但在全局不是，所以梯度下降不一定能找到全局的最优解。当然，如果我们的损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。 7 随机梯度下降法的问题和挑战随机梯度下降法每一次更新只使用一个样本，需要更新很多次，它的最大的缺点在于每次更新可能并不会按照正确的方向进行，可能带来波动，使得最后的结果不是全局最优解。但是优点是训练速度很快，并且可以进行在线更新。 不过从另一个方面来看，随机梯度下降所带来的波动有个好处就是，对于类似盆地区域（即有很多局部极小值点），那么这个波动的特点可能会使优化的方向从当前的局部极小值点调到另一个局部极小值点，这样便可能对于非凸函数最终收敛到一个比较好的局部极值点，甚至是全局极值点。由于波动，会使迭代次数增多，即收敛速度变慢。 梯度下降法分类： 批梯度下降法：原始的梯度下降法，使用全部数据计算梯度，速度比较慢，需要较大内存，不允许在线更新模型。 随机梯度下降法：每次梯度计算只使用一个样本。避免在类似样本上计算梯度造成的冗余计算，增加了跳出当前的局部最小值的潜力，在逐渐缩小学习率的情况下，有与批梯度下降法类似的收敛速度。 小批量随机梯度下降法：每次梯度计算使用一个小批量样本。梯度计算比单样本更加稳定，可以很好的利用现成的高度优化的矩阵运算工具。主要遇到的困难： 如何选取参数m？在不同的应用中，最优的m通常会不一样，需要通过调参选取。一般m取2的幂次时能充分利用矩阵运算操作，所以可以在2的幂次中挑选最优的取值，例如32、64、128、256等。 如何挑选m个训练数据？为了避免数据的特定顺序给算法收敛带来的影响，一般会在每次遍历训练数据之前，先对所有的数据进行随机排序，然后在每次迭代时按顺序挑选m个训练数据直至遍历完所有的数据。 选择适当的学习率比较困难，太小的学习率会导致收敛缓慢，而学习速度太快会造成较大波动，可能会跳过全局最优点，通常会采用衰减学习速率的方案：一开始算法采用较大的学习速率，当误差曲线进入平台期后，减小学习速率做更精细的调整。最优的学习速率方案也通常需要调参才能得到。 8 随机梯度下降法失效的原因—摸着石头下山。为了回答这个问题，我们先做一个形象的比喻。想象一下，你正在下山，视力很好，能看清自己所处位置的坡度，那么沿着坡向下走，最终你会走到山底。如果你被蒙上双眼，只能凭脚底踩石头的感觉判断当前位置的坡度，精确性就大大下降，有时候你认为的坡，实际上可能并不是坡，走上一段时间发现没有下山，或者曲曲折折走了好多弯路才下山。类似地，批量（原始）梯度下降法（Batch Gradient Descent，BGD）就好比正常下山，而随机梯度下降法就好比蒙着眼睛下山。 为了获取准确的梯度，批量梯度下降法的每一步都把整个训练集载入进来进行计算，时间花费和内存开销都非常大，无法应用于大数据集、大模型的场景。相反，随机梯度下降法则放弃了对梯度准确性的追求，每步仅仅随机采样一个（或少量）样本来估计当前梯度，计算速度快，内存开销小。但由于每步接受的信息量有限，随机梯度下降法对梯度的估计常常出现偏差，造成目标函数曲线收敛得很不稳定，伴有剧烈波动，有时甚至出现不收敛的情况。 9 山谷和鞍点对随机梯度下降法来说，可怕的不是局部最优点，而是山谷和鞍点两类地形。 山谷顾名思义就是狭长的山间小道，左右两边是峭壁；鞍点的形状像是一个马鞍，一个方向上两头翘，另一个方向上两头垂，而中心区域是一片近乎水平的平地。为什么随机梯度下降法最害怕遇上这两类地形呢？在山谷中，准确的梯度方向是沿山道向下，稍有偏离就会撞向山壁，而粗糙的梯度估计使得它在两山壁间来回反弹震荡，不能沿山道方向迅速下降，导致收敛不稳定和收敛速度慢。 在鞍点处，随机梯度下降法会走入一片平坦之地（此时离最低点还很远，故也称plateau）。想象一下蒙着双眼只凭借脚底感觉坡度，如果坡度很明显，那么基本能估计出下山的大致方向；如果坡度不明显，则很可能走错方向。同样，在梯度近乎为零的区域，随机梯度下降法无法准确察觉出梯度的微小变化，结果就停滞下来。 10 改进随机梯度下降法-惯性保持和环境感知 动量法Momentum SGD的一个缺点是其更新方向完全依赖于当前batch计算出的梯度，因而十分不稳定。Momentum借用了物理中的动量概念，模拟物体运动时的惯性，在更新的时候在一定程度上保留之前更新的方向，同时利用当前批次的梯度微调最终的更新方向。可以增加稳定性，加快收敛速度，具有一定摆脱局部最优（山谷震荡和鞍点停滞）的能力。 为了解决随机梯度下降法山谷震荡和鞍点停滞的问题，我们做一个简单的思维实验。想象一下纸团在山谷和鞍点处的运动轨迹，在山谷中纸团受重力作用沿山道滚下，两边是不规则的山壁，纸团不可避免地撞在山壁，由于质量小受山壁弹力的干扰大，从一侧山壁反弹回来撞向另一侧山壁，结果来回震荡地滚下；如果当纸团来到鞍点的一片平坦之地时，还是由于质量小，速度很快减为零。纸团的情况和随机梯度下降法遇到的问题简直如出一辙。直观地，如果换成一个铁球，当沿山谷滚下时，不容易受到途中旁力的干扰，轨迹会更稳更直；当来到鞍点中心处，在惯性作用下继续前行，从而有机会冲出这片平坦的陷阱。 自适应学习率的方法： AdaGrad算法 对出现频率较低的参数采用较大的学习率更新，相反，对出现频率较高的参数采用较小的学习率更新。非常适合处理稀疏数据。随机梯度下降法对环境的感知是指在参数空间中，根据不同参数的一些经验性判断，自适应地确定参数的学习速率，不同参数的更新步幅是不同的。例如，在文本处理中训练词嵌入模型的参数时，有的词或词组频繁出现，有的词或词组则极少出现。数据的稀疏性导致相应参数的梯度的稀疏性，不频繁出现的词或词组的参数的梯度在大多数情况下为零，从而这些参数被更新的频率很低。在应用中，我们希望更新频率低的参数可以拥有较大的更新步幅，而更新频率高的参数的步幅可以减小。AdaGrad方法采用“历史梯度平方和”来衡量不同参数的梯度的稀疏性，取值越小表明越稀疏。意味着随着时间推移，学习速率越来越小，从而保证了算法的最终收敛。 Adam算法 Adaptive Moment Estimation，Adam方法将惯性保持和环境感知这两个优点集于一身。一方面，Adam记录梯度的一阶矩（first moment），即过往梯度与当前梯度的平均，这体现了惯性保持；另一方面，Adam还记录梯度的二阶矩（second moment），即过往梯度平方与当前梯度平方的平均，这类似AdaGrad方法，体现了环境感知能力，为不同参数产生自适应的学习速率。一阶矩和二阶矩采用类似于滑动窗口内求平均的思想进行融合，即当前梯度和近一段时间内梯度的平均值，时间久远的梯度对当前平均值的贡献呈指数衰减。具体来说，一阶矩和二阶矩采用指数衰退平均。 除了上述三种随机梯度下降法变种，研究者还提出了以下几种方法。 Nesterov Accelerated Gradient。该方法扩展了动量方法，顺着惯性方向，计算未来可能位置处的梯度而非当前位置的梯度，这个“提前量”的设计让算法有了对前方环境预判的能力。 AdaDelta和RMSProp。这两个方法非常类似，是对AdaGrad方法的改进。AdaGrad方法采用所有历史梯度平方和的平方根做分母，分母随时间单调递增，产生的自适应学习速率随时间衰减的速度过于激进。针对这个问题，AdaDelta和RMSProp采用指数衰退平均的计算方法，用过往梯度的均值代替它们的求和。 AdaMax。该方法是基于Adam方法的一个变种方法，对梯度平方的处理由指数衰退平均改为指数衰退求最大值。 11 牛顿法和梯度下降法的区别牛顿法是一个使用了Hessian矩阵求权重的二阶算法，它的目标就是采用损失函数的二阶偏导数寻找更好的训练方向，它比一阶收敛的梯度下降法只要更少的迭代次数就能下降到损失函数的极小值，因此函数收敛速度大幅加快。但是每一步需要求解目标函数的Hessian矩阵的逆矩阵，计算比较复杂，可以使用拟牛顿法通过正定矩阵近似Hessian矩阵的逆矩阵，简化了计算过程。 牛顿法对初始值有一定的要求，因为牛顿法步长会越来越小，非凸问题容易陷入鞍点，而梯度下降法对初始点没有太强的要求，容易逃离鞍点。 从应用场景来看，牛顿法适用于维度较小的场景，梯度下降法可以用于维度较大的场景。 12 拟牛顿法拟牛顿法的本质思想是改善牛顿法在每次迭代中需要求解复杂的Hessian矩阵的逆矩阵的缺陷，使用了正定矩阵来近似Hessian矩阵的逆，从而简化了运算复杂度（从O(N^3)下降到O(N^2)），拟牛顿法和梯度下降法一样只要求在每一步迭代时知道目标函数的梯度，通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性的收敛。另外因为拟牛顿法不需要二阶导数信息，所以比牛顿法更为高效。 13 共轭梯度法共轭梯度法是介于梯度下降法和牛顿法之间的一个方法，它仅需一阶导数信息，但克服了梯度下降法收敛慢的缺点，又避免了牛顿法需要存储和计算Hessian矩阵并求逆的缺点，共轭梯度法所需存储量小，沿着共轭方向进行搜索的，通常比沿着梯度方向更快收敛。 14 对所有优化问题来说，有没有可能找到比现在已知算法更好的算法对于训练样本，不同的算法在不同的测试样本会有不同的表现，这表示对于一个学习算法A，若它在某些问题上比学习算法B更好，则必然存在一些问题，在那里B比A好，也就是说对于所有问题，无论A算法多好，B算法多差，它们的期望性能是相同的，但是这个结论的前提是假设所有问题出现的几率相同，但是在实际应用中，不同的场景，会有不同的问题分布，在优化算法时，需要针对具体问题进行分析。 Note 没有免费的午餐定理：没有一种机器学习算法时适用于所有情况的，对于所有机器学习问题，任何算法（包括瞎猜）的期望效果都是一样的。前提：所有机器学习问题都是同等重要的。 奥卡姆剃刀定理：若有多个假设与观察一致，则选择最简单的那个，也就是说简单的就是最好的。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-K近邻]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-K%E8%BF%91%E9%82%BB%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-K近邻相关内容。 1 K近邻原理算法原理：如果一个样本在特征空间的k个最相近的样本中的大多数属于某类别，则该样本也属于该类别。 算法过程：对未知类别的样本点进行如下操作： 计算已知类别数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点最相似的k个点； 确定前k个点所在类别的出现次数或频率； 选择前k个点出现次数或频率最高的类别作为当前点的预测分类。 KNN用于回归：输出结果是对象的属性值，这个值是其k个最近邻居的值共同决定的平均值或者加权平均值。 优点：简单，易理解和实现；无需估计参数，无需训练；精度高，对异常值不敏感；适合于多分类问题；无数据输入假定。缺点：当样本不平衡时，效果较差；计算复杂度高；空间复杂度高；可解释性差，无法给出像决策树那样的规则。 KNN是”懒惰学习”的著名代表，此类学习技术在训练阶段仅仅是把样本保存起来，训练时间开销为零，待收到测试样本后再进行处理；相应的，那些在训练阶段就对样本进行学习处理的方法，称为”急切学习” (eager learning)。 2 KNN中的k是如何选取的？K值可以通过先验知识选取一个近似值，然后可以采用交叉验证法来选取最优的k值。 较小的k值：用较少训练样本预测，非常相似的样本才起作用，学习的近似误差会减小；预测结果与少量样本有关，对近邻数据非常敏感，学习的估计误差会增大，对噪声敏感；k值的减小意味着模型变复杂，容易过拟合。 较大的k值：用较多的训练样本进行预测，学习的估计误差会减小；与输入数据距离较远的实例也会起作用，学习的近似误差会增大；k值的增大意味着模型变简单，容易欠拟合。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-支持向量机]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-支持向量机相关内容。 1 支持向量机原理SVM，全称是Support vector machine，中文名叫支持向量机。SVM是一个面向数据的分类算法，它的基本模型是定义在特征空间上的间隔最大的线性分类器，它的目标是确定一个分类超平面，从而将不同的数据分隔开。支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的损失函数自带正则项，这就是为什么SVM是结构风险最小化算法。 SVM主要包括线性可分支持向量机、线性支持向量机以及非线性支持向量机三种模型。当训练数据线性可分时，通过硬间隔最大化，学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；当数训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。 硬间隔最大化：当训练数据线性可分时，有许多超平面可以将数据正确分类，我们应该寻找位于两类训练样本正中间的超平面，也就是样本点与直线的距离最大的那条直线。 支持向量：距离超平面最近的几个训练样本称为支持向量。 学习的对偶算法：一个优化问题可以从两个角度进行考察，一个是原始问题，一个是对偶问题，通过给每一个约束条件加上一个拉格朗日乘子，定义拉格朗日函数，也就是通过拉格朗日函数将约束条件融合到目标函数里，从而只用一个函数表达式便能清楚地表达我们的问题。一般情况下对偶问题给出原始问题最优解的下界，对偶问题是凸优化问题，可以进行较好的求解，SVM就是将原始问题转换为对偶问题进行求解，从而进一步引入核函数的思想，进而推广到非线性分类问题。 软间隔最大化：通常情况下训练数据不是线性可分的，训练数据中有一些特异点，将这些特异点去除后，剩下大部分的样本点组成的集合是线性可分的，通过对每个样本点引入一个松弛变量，使函数间隔加上松弛变量可以被正确分类，求解的是凸二次规划问题，显然线性支持向量机包含线性可分支持向量机，由于现实中训练数据集往往是线性不可分的，线性支持向量机有更广的适用性。 核技巧：通过一个非线性变换，将非线性问题变换为线性问题。即在核函数给定的条件下，可以利用解线性分类问题的方法求解非线性问题的支持向量机。在线性不可以的分类问题中，可以使用核函数将原始空间映射到一个更高维度的特征空间，使得样本在这个特征空间内线性可分，然后在新空间里用线性分类学习方法从训练数据中学习分类模型。 常用核函数：线性核，多项式核，高斯核，拉普拉斯核，sigmoid核。 2 带核的SVM为什么能分类非线性问题？核函数的本质是两个函数的内积，通过核函数将其映射到高维空间，在高维空间将非线性问题转化为线性问题，SVM得到超平面是高维空间的线性分类平面，其分类结果也可以看做为低维空间的非线性分类结果，因而带核的SVM能解决非线性分类问题。 3 线性可分的两类点向SVM分类的超平面上做投影，这些点在超平面上的投影仍然是线性可分的吗不是线性可分的，我们可以通过凸优化理论中的超平面分离定理（Separating Hyperplane Theorem，SHT）解决。该定理描述的是，对于不相交的两个凸集，存在一个超平面，将两个凸集分离。 对于二维的情况，两个凸集间距离最短两点连线的中垂线就是一个将它们分离的超平面。先对线性可分的这两组点求各自的凸包，凸包就表示两个类别数据点的外边界。不难发现，SVM求得的超平面就是两个凸包上距离最短的两点连线的中垂线，也就是超平面分离定理二维情况中所阐释的分类超平面。根据凸包的性质容易知道，凸包上的点要么是样本点，要么处于两个样本点的连线上。因此，两个凸包间距离最短的两个点可以分为三种情况： 两边的点均为样本点； 两边的点均在样本点的连线上; 一边的点为样本点，另一边的点在样本点的连线上从几何上分析即可知道，无论哪种情况两类点的投影均是线性不可分的。 4 加大训练数据量一定能提高SVM准确率吗当然不一定，如果加入的数据包含很多噪音，或者数据的多样性不够，对效果提升其实没啥帮助。SVM本质上是凸优化问题，如果增加的样本点只是无效约束，并不会影响其最后的结果。这也就是为什么SVM适合于小样本量数据集的原因。随样本量而使模型自身发生改变的，是统计推断。最大似然，再到贝叶斯，每个都涉及到样本数连乘的一项，这些方法建立的模型才真正和样本数量有最直接的联系。 5 SVM解决多分类问题的方法SVM算法最初是为二值分类问题设计的，当处理多类问题时，就需要构造合适的多类分类器。目前，构造SVM多类分类器的方法主要有两类：一类是直接法，直接在目标函数上进行修改，将多个分类面的参数求解合并到一个最优化问题中，通过求解该最优化问题“一次性”实现多类分类。这种方法看似简单，但其计算复杂度比较高，实现起来比较困难，只适合用于小型问题中；另一类是间接法，主要是通过组合多个二分类器来实现多分类器的构造，常见的方法有一对一，一对多以及层次支持向量机三种。 一对一法（one-versus-one,简称1-v-1 SVMs）。其做法是在任意两类样本之间设计一个SVM，因此k个类别的样本就需要设计 $k(k-1)/2$ 个SVM。当对一个未知样本进行分类时，最后得票最多的类别即为该未知样本的类别。Libsvm中的多类分类就是根据这个方法实现的。 一对多法（one-versus-rest,简称1-v-r SVMs）。训练时依次把某个类别的样本归为一类,其他剩余的样本归为另一类，这样k个类别的样本就构造出了k个SVM。分类时将未知样本分类为具有最大分类函数值的那类。 层次支持向量机（H-SVMs）。层次分类法首先将所有类别分成两个子类，再将子类进一步划分成两个次级子类，如此循环，直到得到一个单独的类别为止。 6 SVM解决回归问题的方法SVR是SVM的一种运用，基本的思路是一致，除了一些细微的区别。使用SVR作回归分析，与SVM一样，我们需要找到一个超平面，不同的是：在SVM中我们要找出一个间隔（gap）最大的超平面，而在SVR，我们定义一个阈值a，定义虚线内区域的数据点的残差为0，即SVR认为只要 $f(x)$ 与 $y$ 偏离程度不是太大，就可以认为预测正确，而虚线区域外的数据点到虚线的边界的距离为残差（$\zeta$）。与线性模型类似，我们希望这些残差（$\zeta$）最小。所以大致上来说，在虚线区域部分的数据点我们都认为该模型预测准确了，只计算虚线区域外的数据点的损失，SVR就是要找出一个最佳的条状区域（ $2a$ 宽度），再对区域外的点进行回归。 对于非线性的模型，与SVM一样使用核函数（kernel function）映射到特征空间，然后再进行回归。 7 SVM的优缺点优点 使用核函数可以向高维空间进行映射 使用核函数可以解决非线性的分类 分类思想很简单，就是将样本与决策面的间隔最大化 缺点 SVM算法对大规模训练样本难以实施，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。 SVM无法直接支持多分类问题。 8 支持向量机(SVM)是否适合大规模数据这个问题其实有两个层面，一个层面是，svm在分类效果上是否适合大规模数据；另外一个层面是，svm对于大规模数据训练的运算量是否太大而无法使用。 第一个层面的理解。我理解SVM并不是不适合大规模数据，而应该说，SVM在小样本训练集上能够得到比其它算法好很多的结果。支持向量机之所以成为目前最常用，效果最好的分类器之一，在于其优秀的泛化能力，这是是因为其本身的优化目标是结构化风险最小，而不是经验风险最小，因此，通过margin的概念，得到对数据分布的结构化描述，因此减低了对数据规模和数据分布的要求。而大规模数据上，并没有实验和理论证明表明SVM会差于其它分类器，也许只是相对其它分类器而言，领先的幅度没有那么高而已。 第二个层面，大规模数据，在很大程度上取决于你所面对的应用以及可用的计算资源，算法能不能处理大规模数据主要有两点要素，1）算法是否依赖于对训练集的随机访问。依赖于训练集随机访问的算法需要将训练集全部加载进内存，所能处理的数据量受内存大小的限制。2）算法是否能有效地利用分布式（或并行的）计算资源。单台计算机（或单处理器）的处理能力毕竟是有限的。如果可用的计算资源增长100倍，算法能处理的数据量的增长远小于100倍，则算法的适用范围也会有很大的限制。但对于大规模学习来说，障碍往往在于算法的计算能力不足，不是数据不够，所以我觉得传统的统计学习方法都不适合大规模数据处理(包括SVM)。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-决策树]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-决策树相关内容。 1 决策树的基本原理决策树是一种自上而下，递归地将样本数据进行树形分类的过程，由结点和有向边组成。结点分为内部结点和叶结点，其中每个内部结点表示一个特征或属性，叶结点表示类别。从顶部根结点开始，所有样本聚在一起。经过根结点的划分，样本被分到不同的子结点中。再根据子结点的特征进一步划分，直至所有样本都被归到某一个类别（即叶结点）中。 决策树的目标是从一组样本数据中，根据不同的特征和属性，建立一棵树形的分类结构。我们既希望它能拟合训练数据，达到良好的分类效果，同时又希望控制其复杂度，使得模型具有一定的泛化能力。对于一个特定的问题，决策树的选择可能有很多种。 2 ID3，C4.5，CART原理决策树的关键是如何选择最优划分树形，一般来说，随着划分过程不断进行，我们希望决策树的分支结点所包含的样本尽可能属于同一类别，也就是希望结点的”纯度”(purity)越来越高。 ID3—最大信息增益准则。信息增益=信息熵-条件熵。 \operatorname{Gain}(D, a)=\operatorname{Ent}(D)-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Ent}\left(D^{v}\right)信息熵：信息熵的度量等于不确定性的多少。越不确定的事物，信息熵越高。 \operatorname{Ent}(D)=-\sum_{k=1}^{|\mathcal{Y}|} p_{k} \log _{2} p_{k}条件熵 H(D | A)=\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} H\left(D_{i}\right)=\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|}\left(-\sum_{k=1}^{k} \frac{\left|D_{i k}\right|}{\left|D_{i}\right|} \log _{2} \frac{\left|D_{i k}\right|}{\left|D_{i}\right|}\right)对于各类别样本数量不一致数据，信息增益准则对可取值数目较多的属性有所偏好。例如N个样本有N个取值，每一个取值都是1/N，信息熵最大，因此信息增益最大。 C4.5—最大信息增益比。 D, a )=\frac{\operatorname{Gain}(D, a)}{\operatorname{IV}(a)} \mathrm{IV}(a)=-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \log _{2} \frac{\left|D^{v}\right|}{|D|}$\mathrm{IV}(a)$ 是属性$a$的”固有值”(intrinsicvalue),属性$a$的可能取值数目越多(即 $V$ 越大)，则 $\mathrm{IV}(a)$ 的值通常会越大，导致信息增益比小，因此信息增益比对可取值数目较少的属性有所偏好。 CART—最小基尼指数。 (D, a)=\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} \operatorname{Gini}\left(D^{v}\right) \operatorname{Gini}(D)=1-\sum_{k=1}^{|y|} p_{k}^{2}$\operatorname{Gini}(D)$ 越小，则数据集D的纯度越高，我们在候选属性集合A中，选择那个使得划分后基尼指数最小的属性作为最优划分属性。 3 ID3，C4.5，CART的对比首先，ID3是采用信息增益作为评价标准，会倾向于取值较多的特征。因为，信息增益反映的是给定条件以后不确定性减少的程度，特征取值越多就意味着确定性更高，也就是条件熵越小，信息增益越大。这在实际应用中是一个缺陷。比如，我们引入特征“DNA”，每个人的DNA都不同，如果ID3按照“DNA”特征进行划分一定是最优的（条件熵接近于0），但这种分类的泛化能力是非常弱的。因此，C4.5实际上是对ID3进行优化，通过引入信息增益比，一定程度上对取值比较多的特征进行惩罚，避免ID3出现过拟合的特性，提升决策树的泛化能力。 其次，从样本类型的角度，ID3只能处理离散型变量，而C4.5和CART都可以处理连续型变量。C4.5处理连续型变量时，通过对数据排序之后找到类别不同的分割线作为切分点，根据切分点把连续属性转换为布尔型，从而将连续型变量转换多个取值区间的离散型变量。而对于CART，由于其构建时每次都会对特征进行二值划分，即CART是一棵二叉树，采样二元切割法，每一步将数据按照特征的取值分成两份，分别进入左右子树，因此可以很好地适用于连续性变量。 从应用角度，ID3和C4.5只能用于分类任务，而CART（Classification and Regression Tree，分类回归树）从名字就可以看出其不仅可以用于分类，也可以应用于回归任务（回归树使用最小平方误差准则）。 4 剪枝处理剪枝(pruning)是决策树学习算法对付”过拟合”的主要手段.在决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得”太好”了，以致于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。因此可通过主动去掉一些分支来降低过拟合的风险。 决策树的剪枝通常有两种方法，预剪枝（Pre-Pruning）和后剪枝（Post-Pruning）。 预剪枝：预剪枝是指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点，此时可能存在不同类别的样本同时存于该叶结点中，按照多数投票的原则判断该叶结点所属类别。预剪枝对于何时停止决策树的生长有以下几种方法： ①当树到达一定深度的时候，停止树的生长。 ②当到达当前结点的样本数量小于某个阈值的时候，停止树的生长。 ③计算每次分裂对测试集的准确度提升，当小于某个阈值的时候，不再继续扩展。预剪枝具有思想直接、算法简单、效率高等特点，适合解决大规模问题。但如何准确地估计何时停止树的生长（即上述方法中的深度或阈值），针对不同问题会有很大差别，需要一定经验判断。且预剪枝存在一定局限性，有欠拟合的风险，虽然当前的划分会导致测试集准确率降低，但在之后的划分中，准确率可能会有显著上升。 后剪枝：后剪枝则是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点.该结点的类别同样按照多数投票的原则进行判断。同样地，后剪枝也可以通过在测试集上的准确率进行判断，如果剪枝过后准确率有所提升，则进行剪枝。相比于预剪枝，后剪枝方法通常可以得到泛化能力更强的决策树，但时间开销会更大。 5 树形结构为什么不需要归一化树形结构算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程，数值缩放不影响特征值的排序顺序，因此所属的分支以及分裂点的位置就不会改变，所以归一化对树模型的结构不造成影响。而且树模型数不能进行梯度下降的，因为构建树模型是通过递归地寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没有意义，也就不需要归一化。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-线性回归&逻辑回归&最大熵]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%26%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%26%E6%9C%80%E5%A4%A7%E7%86%B5%2F</url>
    <content type="text"><![CDATA[本系列为机器学习相关知识总结。 机器学习-基本概念 机器学习-特征工程 机器学习-模型评估 机器学习-支持向量机 机器学习-线性回归&amp;逻辑回归&amp;最大熵 机器学习-K近邻 机器学习-贝叶斯 机器学习-无监督学习 机器学习-决策树 机器学习-集成学习 机器学习-优化算法 机器学习-采样 本文主要是机器学习-线性回归&amp;逻辑回归&amp;最大熵相关内容。 1 线性回归原理给定数据集，线性回归试图学得一个线性模型以尽可能准确地预测实值。求解线性回归模型参数的策略是使均方误差最小化，基于均方误差最小化来进行模型求解的方法称为”最小二乘法”。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧氏距离之和最小。 2 逻辑斯蒂回归原理逻辑斯蒂回归的基础是线性回归，但是线性回归做的是回归任务，而逻辑斯蒂回归利用一个单调可微的函数将分类任务的真实标记与线性回归模型的预测值联系起来，学习的是分类任务。它的优点是直接对分类的可能性进行建模，所以它不仅可以预测出类别，还可以得到属于该类别的概率，这对于许多需要利用概率辅助决策的任务很有用；此外，Sigmoid函数是任意阶可导函数，具有很好的数学性质。逻辑斯蒂回归模型的参数估计中，使用梯度下降法进行学习，一般使用小批量的数据进行迭代优化。 3 LR为什么用的是sigmoid函数而不用阶跃函数阶跃函数虽然能够直观刻画分类的错误率，但是由于其非凸、非光滑的特点，使得算法很难直接对该函数进行优化。而sigmoid函数本身的特征（光滑无限阶可导），以及完美的映射到概率空间，就用于逻辑回归了。同时对于二分类问题来说，因为伯努利分布属于指数族分布，具有最大熵的性质。 4 线性回归和逻辑斯蒂的区别首先，逻辑回归处理的是分类问题，线性回归处理的是回归问题，这是两者的最本质的区别，另外，线性回归的损失函数是最小平方误差，而逻辑斯蒂回归的损失函数为交叉熵损失函数，也就是最小对数似然损失。 逻辑回归和线性回归的相同在于，首先我们可以认为二者都使用了极大似然估计来对训练样本进行建模。线性回归使用最小二乘法，实际上就是在自变量x与超参数θ确定，因变量y服从正态分布的假设下，使用极大似然估计的一个化简；而逻辑回归中通过对似然函数的学习，得到最佳参数θ。另外，二者在求解超参数的过程中，都可以使用梯度下降的方法，这也是监督学习中一个常见的相似之处。 5 当使用逻辑回归处理多标签的分类问题时，有哪些常见做法，分别应用于哪些场景，它们之间又有怎样的关系 首先，如果一个样本只对应于一个标签，我们可以假设每个样本属于不同标签的概率服从于几何分布，使用多项逻辑回归（Softmax Regression）来进行分类 当存在样本可能属于多个标签的情况时，我们可以训练k个二分类的逻辑回归分类器。第i个分类器用以区分每个样本是否可以归为第i类，训练该分类器时，需要把标签重新整理为“第i类标签”与“非第i类标签”两类。通过这样的办法，我们就解决了每个样本可能拥有多个标签的情况。 6 逻辑斯蒂回归为什么要对特征进行离散化 非线性。逻辑斯蒂回归属于广义线性模型，表达能力受限，离散化后增加了非线性成分，可以增强模型表达能力和拟合能力，离散特征的增加和减少都很容易，易于模型的快速迭代。 速度快。稀疏向量内积乘法运算速度快，计算结果方便存储，容易扩展； 鲁棒性。离散化后的特征对异常数据有很强的鲁棒性：比如一个特征是年龄&gt;30是1，否则0。如果特征没有离散化，一个异常数据“年龄300岁”会给模型造成很大的干扰； 方便交叉与特征组合：离散化后可以进行特征交叉，由 $M+N$ 个变量变为$M*N$个变量，进一步引入非线性，提升表达能力； 稳定性：特征离散化后，模型会更稳定，比如如果对用户年龄离散化，20-30作为一个区间，不会因为一个用户年龄长了一岁就变成一个完全不同的人。当然处于区间相邻处的样本会刚好相反，所以怎么划分区间是门学问； 简化模型：特征离散化以后，起到了简化了逻辑回归模型的作用，降低了模型过拟合的风险。 7 LR和SVM各自的优缺点和适用场景 最本质是他们的损失函数不同，LR是对数损失而SVM是合页损失函 数； LR可以给出每个点属于每一类的概率，而SVM是非概率的，一个 是基于统计的方法，一个基于几何的方法； 支持向量机只考虑局部的 边界线附近的点（支持向量），而逻辑回归考虑所有的样本点，所以线性SVM不直接依赖于数据分布，分类平面不受一类点影响，LR则受所有数据点的影响对不平衡数据先做balance； 同样是线性分类，如果异常点较多无法剔除，首先LR中每个样本都有贡献，最大似然后会自动压制异常的贡献，SVM + 软间隔对异常却比较敏感，因为其训练只需要支持向量，有效样本本来就不高，一旦被干扰，预测结果会难以预料； SVM的损失函数本省自带正则项，这就是为什么SVM是结构风险最小化算法，而LR必须另外在损失函数上添加正则项。 8 LR使用核函数解决线性不可分问题逻辑回归本质上是一个线性模型，但是，这不意味着只有线性可分的数据能通过LR求解，实际上，我们可以通过2种方式帮助LR实现： 利用特殊核函数，对特征进行变换：把低维空间转换到高维空间，而在低维空间不可分的数据，到高维空间中线性可分的几率会高一些。但在LR算法里，每个样本点都必须参与决策面的计算过程，也就是说，假设我们在LR里也运用核函数的原理，那么每个样本点都必须参与核计算，这带来的计算复杂度是相当高的。所以，在具体应用时，LR很少运用核函数机制。 扩展LR算法，提出FM算法。 9 最大熵模型原理熵是随机变量不确定性的度量，不确定性越大，熵越大；为了准确估计随机变量的状态，我们一般最大化熵，认为在所有可能的概率模型（分布）中，熵最大的模型是最好的模型。也就是说，在已知部分知识的前提下，关于未知分布最合理的推理就是符合已知知识最不确定或者最随机的推断，其原则是承认已知知识，并且对未知事物不做任何假设，没有任何偏见。最大熵在解决二分类问题时就是逻辑回归，在解决多分类问题时就是多项逻辑回归（softmax）。 Note 最大熵原理认为要选择的概率模型首先必须满足已有的事实，即约束条件。在没有更多信息的情况下，那些不确定的部分都是“等可能的”，最大熵原理通过熵的最大化来表示等可能性。 例如，投掷一个骰子，如果问“每个面朝上的概率分别是多少”，你会说是等概率，即各点出现的概率均为1/6，因为对这个“一无所知”的骰子，什么都不确定，而假定它每一个面朝上概率均等则是最合理的做法。从投资的角度来看，这是风险最小的作法，从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达到最大。 10 SVM和logistic回归分别在什么情况下使用 如果特征的数量很大，跟样本数量差不多或者比样本多，选用逻辑斯蒂回归或者线性核的SVM。理由：特征数相对于训练样本数已经够大了，使用线性模型就能取得不错的效果，不需要过于复杂的模型； 如果特征的数量比较小，样本数量一般，选用高斯核的SVM。理由：在训练样本数量足够大而特征数较小的情况下，可以通过使用复杂核函数的SVM来获得更好的预测性能，而且因为训练样本数量并没有达到百万级，使用复杂核函数的SVM也不会导致运算过慢； 如果特征数量很小，而样本数量很多，需要手工添加一些特征变成第一种情况。理由：因为训练样本数量特别大，使用复杂核函数的SVM会导致运算很慢，因此应该考虑通过引入更多特征，然后使用线性核函数的SVM或者lr来构建预测性更好的模型。 11 SVM和逻辑斯特回归对同一样本A进行训练，如果某类中增加一些数据点，那么原来的决策边界分别会怎么变化？不妨设只添加一个数据点，且它属于“+”的那一类。 SVM：如果这个数据点本身在margin之外“+”的那一侧，那么判决边界不受影响。如果这个数据点在margin之内，或者在margin之外“-”的那一侧，那么这个点一定会成为新的支持向量。但是，判决边界并不一定发生变化，因为这个数据点可能能够被目标函数中的容错项处理掉。 LR：当新数据点在“+”类这一边，但离判决边界比较近。新的模型为了能够正确判别这个数据点，会把判决边界向“-”类方向移动。当数据点在“+”类这一边，但离判决边界很远，旧模型已经可以毫无压力地把它判别正确。这时，新模型反倒会把判决边界向“+”类方向移动，这样虽然新的数据点的似然值减小了一点儿，但换来的是原来的“-”类数据似然值增加。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[置顶-站点导航]]></title>
    <url>%2F2019%2F06%2F17%2F%E7%BD%AE%E9%A1%B6-%E7%AB%99%E7%82%B9%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[Sitemap 机器学习 项目经历 学习笔记 Leetcode题解 剑指offer题解 数据结构 数据库 Keep updating… BiographyCurrently I am a second year graduate student of School of Microelectronics in Southeast University and a member of National ASIC System Engineering Research Center, led by professor Longxing Shi. I was admitted to study in School of Information Science and Engineering in September 2013 and received my B.Sc. degree in Electronic Engineering in June 2017 from Shandong University. In the same year, I was admitted to pursue for a M.Sc. degree in Southeast University without entrance examination. Research InterestsMy research interests include topics in high dimensional yield analysis and machine learning. CorrespondenceEmail: huangqiancun#foxmail.com (change # to @)Address: No.2 Sipailou, Nanjing, Jiangsu Province, 210096, P. R. China]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库SQL实战题解]]></title>
    <url>%2F2019%2F06%2F17%2F%E6%95%B0%E6%8D%AE%E5%BA%93SQL%E5%AE%9E%E6%88%98%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文为数据库SQL实战刷题笔记，刷题平台为牛客网。题量为61道。网站OJ编译器为sqlite3.7.9。 相关笔记：StudyNotes-MySQL必知必会 1 查找最晚入职员工的所有信息题目描述1234567891011121314查找最晚入职员工的所有信息CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT * FROM employeesWHERE hire_date = (SELECT MAX(hire_date) FROM employees); 123SELECT * FROM employeesORDER BY hire_date DESC LIMIT 0, 1; 2 查找入职员工时间排名倒数第三的员工所有信息题目描述1234567891011121314查找入职员工时间排名倒数第三的员工所有信息CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1; 123SELECT * FROM employees WHERE hire_date = (SELECT hire_date FROM employees ORDER BY hire_date DESC LIMIT 2,1); 3 查找当前薪水详情以及部门编号dept_no题目描述123456789101112131415161718查找各个部门当前(to_date='9999-01-01')领导当前薪水详情以及其对应部门编号dept_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary from_date to_date dept_no 解题思路123456SELECT s.*, d.dept_noFROM salaries as s INNER JOIN dept_manager as d ON s.emp_no = d.emp_noWHERE s.to_date='9999-01-01' AND d.to_date='9999-01-01'; 4 查找所有已经分配部门的员工的last_name和first_name题目描述12345678910111213141516171819查找所有已经分配部门的员工的last_name和first_nameCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_no 解题思路1234SELECT e.last_name, e.first_name, d.dept_noFROM employees AS e INNER JOIN dept_emp AS d ON e.emp_no = d.emp_no 5 查找所有员工的last_name和first_name以及对应部门编号dept_no题目描述12345678910111213141516171819查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_no 解题思路 INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。 LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。 RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。 1234SELECT e.last_name, e.first_name, d.dept_noFROM employees AS e LEFT JOIN dept_emp AS d ON e.emp_no = d.emp_no 6 查找所有员工入职时候的薪水情况题目描述12345678910111213141516171819查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary 解题思路 在测试数据中，salaries中的emp_no不唯一（因为号码为emp_no的员工会有多次涨薪的可能，所有在salaries中对应的记录不止一条）。 employees.emp_no唯一，即salaries的数据会多于employees。 123456# 利用INNER JOIN连接两张表SELECT e.emp_no, s.salaryFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC; 123456# 直接用逗号并列查询两张表SELECT e.emp_no, s.salaryFROM employees AS e, salaries AS sWHERE e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC; 7 查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t题目描述1234567891011查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数tCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no t 解题思路 用COUNT函数和GROUP BY语句可以统计同一emp_no值的记录条数。 用AS语句将COUNT(emp_no) 的值转换为t。 COUNT函数不可用WHERE语句，因此使用HAVING语句。 涨幅超过15次，salaries中相应的记录数应该超过16（从第2条记录开始算作第1次涨幅），不过题目为了简单起见，将第1条记录当作第1次涨幅，所以令t&gt;15即可。 注意： 严格来说，下一条salary高于本条才算涨幅，但本题只要出现了一条记录就算一次涨幅，salary相同可以理解为涨幅为0，salary变少理解为涨幅为负。 1234SELECT emp_no, COUNT(*) AS tFROM salariesGROUP BY emp_noHAVING t &gt; 15; 8 找出所有员工当前薪水salary情况题目描述1234567891011找出所有员工当前(to_date='9999-01-01')具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:salary 解题思路1234SELECT DISTINCT salaryFROM salariesWHERE to_date = '9999-01-01'ORDER BY salary DESC; 9 获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’题目描述1234567891011121314151617获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date='9999-01-01'CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路1234567# 使用联结。SELECT d.dept_no, d.emp_no, s.salaryFROM dept_manager AS d INNER JOIN salaries AS s ON d.emp_no = s.emp_no AND d.to_date = '9999-01-01' AND s.to_date = '9999-01-01'; 123456# 使用逗号并列查询SELECT d.dept_no, d.emp_no, s.salaryFROM dept_manager AS d, salaries AS sWHERE d.emp_no = s.emp_no AND d.to_date = '9999-01-01' AND s.to_date = '9999-01-01'; 10 获取所有非manager的员工emp_no题目描述12345678910111213141516171819获取所有非manager的员工emp_noCREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no 解题思路123SELECT emp_noFROM employeesWHERE emp_no NOT IN (SELECT emp_no FROM dept_manager); 12345SELECT e.emp_noFROM employees AS e LEFT OUTER JOIN dept_manager AS d ON e.emp_no = d.emp_noWHERE dept_no IS NULL; 11 获取所有员工当前的manager题目描述123456789101112131415161718获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date='9999-01-01'。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输入描述:无输出描述:emp_no manager_no 解题思路 要输出自己的经历，部门要相同 de.dept_no = dm.dept_no。 123456SELECT de.emp_no, dm.emp_noFROM dept_emp AS de, dept_manager AS dmWHERE de.dept_no = dm.dept_no AND de.to_date = '9999-01-01' AND dm.to_date = '9999-01-01' AND de.emp_no &lt;&gt; dm.emp_no; 1234567SELECT de.emp_no, dm.emp_noFROM dept_emp AS de INNER JOIN dept_manager AS dm ON de.dept_no = dm.dept_noWHERE de.to_date = '9999-01-01' AND dm.to_date = '9999-01-01' AND de.emp_no &lt;&gt; dm.emp_no; 12 获取所有部门中当前员工薪水最高的相关信息题目描述1234567891011121314151617获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salaryCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路 使用GROUP BY d.dept_no 将每个部门分为一组，用MAX函数选取每组中工资最高者 12345678SELECT d.dept_no, d.emp_no, MAX(s.salary) AS salaryFROM dept_emp AS d INNER JOIN salaries AS s ON d.emp_no = s.emp_noWHERE d.to_date = '9999-01-01' AND s.to_date = '9999-01-01'GROUP BY d.dept_noORDER by d.dept_no; 1234567SELECT d.dept_no, d.emp_no, MAX(s.salary) AS salaryFROM dept_emp AS d, salaries AS sWHERE d.emp_no = s.emp_no AND d.to_date = '9999-01-01' AND s.to_date = '9999-01-01'GROUP BY d.dept_noORDER by d.dept_no; 13 从titles表获取按照title进行分组题目描述12345678910从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title t 解题思路1234SELECT title, COUNT(*) AS tFROM titlesGROUP BY titleHAVING t &gt;= 2; 14 从titles表获取按照title进行分组，注意对于重复的emp_no进行忽略题目描述1234567891011从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略。CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title t 解题思路1234SELECT title, COUNT(DISTINCT emp_no) AS tFROM titles GROUP BY titleHAVING t &gt;= 2; 15 查找employees表题目描述12345678910111213查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:emp_no birth_date first_name last_name gender hire_date 解题思路12345SELECT *FROM employeesWHERE emp_no % 2 = 1 AND last_name != 'Mary'ORDER BY hire_date DESC; 16 统计出当前各个title类型对应的员工当前薪水对应的平均工资题目描述12345678910111213141516统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg。CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));CREATE TABLE IF NOT EXISTS "titles" (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:title avg 解题思路1234567SELECT t.title, Avg(s.salary)FROM titles AS t INNER JOIN salaries AS s ON t.emp_no = s.emp_noWHERE t.to_date = '9999-01-01' AND s.to_date = '9999-01-01'GROUP BY t.title; 123456SELECT t.title, Avg(s.salary)FROM titles AS t, salaries AS sWHERE t.emp_no = s.emp_no AND t.to_date = '9999-01-01' AND s.to_date = '9999-01-01'GROUP BY t.title; 17 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary题目描述1234567891011获取当前（to_date='9999-01-01'）薪水第二多的员工的emp_no以及其对应的薪水salaryCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary 解题思路1234SELECT emp_no, salaryFROM salariesWHERE to_date='9999-01-01'ORDER BY salary DESC LIMIT 1, 1; 18 获取当前薪水第二多的员工的emp_no以及其对应的薪水salary，不准使用order题目描述12345678910111213141516171819查找当前薪水(to_date='9999-01-01')排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order byCREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary last_name first_name 解题思路12345678SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_noWHERE s.to_date = '9999-01-01' AND s.salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date='9999-01-01'); 123456SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_noWHERE s.to_date = '9999-01-01' AND s.salary &lt; (SELECT MAX(salary) FROM salaries); 19 查找所有员工的last_name和first_name以及对应的dept_name题目描述1234567891011121314151617181920212223查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:last_name first_name dept_name 解题思路 第一次LEFT JOIN连接employees表与dept_emp表，得到所有员工的last_name和first_name以及对应的dept_no，也包括暂时没有分配部门的员工 第二次LEFT JOIN连接上表与departments表，即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工 123SELECT e.last_name, e.first_name, d.dept_nameFROM (employees AS e LEFT JOIN dept_emp AS de ON e.emp_no = de.emp_no) LEFT JOIN departments AS d ON de.dept_no = d.dept_no; 20 查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth题目描述1234567891011查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growthCREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:growth 解题思路 最大to_date的salary 减去最小值to_date的salary 1234SELECT ( (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date DESC LIMIT 1)- (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date LIMIT 1) )AS growth; 最大salary-最小salary，不严禁，有可能最后最大salary不在当前日期取得，最小salary不在最早的日期取得。 123SELECT (MAX(salary)- MIN(salary)) AS growth FROM salariesWHERE emp_no = 10001; 21 查找所有员工自入职以来的薪水涨幅情况题目描述12345678910111213141516171819查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no growth 解题思路 建立两张表，一张存放员工当前工资，另一张存放员工入职时的工资。 1234567SELECT present.emp_no, (present.salary - pass.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.to_date='9999-01-01') AS present, (SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.from_date=e.hire_date) AS passWHERE present.emp_no = pass.emp_noORDER BY growth; 123456789# 内层用LEFT JOIN，内层用INNER JOINSELECT present.emp_no, (present.salary - pass.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees AS e LEFT JOIN salaries AS s ON e.emp_no = s.emp_no WHERE s.to_date='9999-01-01') AS present INNER JOIN (SELECT s.emp_no, s.salary FROM employees AS e LEFT JOIN salaries AS s ON e.emp_no = s.emp_no WHERE s.from_date=e.hire_date) AS passON present.emp_no = pass.emp_noORDER BY growth; 22 统计各个部门对应员工涨幅的次数总和题目描述123456789101112131415161718192021统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sumCREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no dept_name sum 解题思路 用INNER JOIN联结dept_emp和salaries表，得到所有部门所有员工的记录总数，在联结departmens表，找到dept_no和dept_name的对应关系。 1234SELECT dp.dept_no, dp.dept_name, COUNT(s.salary) AS sumFROM (dept_emp AS de INNER JOIN salaries AS s ON de.emp_no = s.emp_no) INNER JOIN departments AS dp ON de.dept_no = dp.dept_no GROUP BY dp.dept_no; 1234SELECT dp.dept_no, dp.dept_name, COUNT(s.salary) AS sumFROM dept_emp AS de, salaries AS s, departments AS dpWHERE de.emp_no = s.emp_no AND de.dept_no = dp.dept_no GROUP BY dp.dept_no; 23 对所有员工的薪水按照salary进行按照1-N的排名题目描述1234567891011对所有员工的当前(to_date='9999-01-01')薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no salary rank 解题思路 复用salaries表进行比较排名，从两张相同的salaries表（分别为s1与s2）进行对比分析。 先将两表限定条件设为to_date = ‘9999-01-01’，挑选出当前所有员工的薪水情况。 s1.salary &lt;= s2.salary，意思是在输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary。 1234567SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rankFROM salaries AS s1, salaries AS s2WHERE s1.to_date = '9999-01-01' AND s2.to_date = '9999-01-01' AND s1.salary &lt;= s2.salaryGROUP BY s1.emp_noORDER BY rank, s1.emp_no; 24 获取所有非manager员工当前的薪水情况题目描述12345678910111213141516171819202122232425262728293031获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date='9999-01-01'CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:dept_no emp_no salary 解题思路123456SELECT de.dept_no, s.emp_no, s.salaryFROM (employees AS e INNER JOIN salaries AS s ON e.emp_no = s.emp_no AND s.to_date = '9999-01-01') INNER JOIN dept_emp AS de ON e.emp_no = de.emp_noWHERE de.emp_no NOT IN (SELECT emp_no FROM dept_manager WHERE to_date='9999-01-01'); 25 获取员工其当前的薪水比其manager当前薪水还高的相关信息题目描述123456789101112131415161718192021222324252627获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date='9999-01-01',结果第一列给出员工的emp_no，第二列给出其manager的manager_no，第三列给出该员工当前的薪水emp_salary,第四列给该员工对应的manager当前的薪水manager_salaryCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no manager_no emp_salary manager_salary 解题思路 创建两张表，一张保存员工的工资，另一张保存经理的工资。 找出同一部门，员工比经理工资高的输出。 12345678SELECT s1.emp_no AS emp_no, s2.emp_no AS manager_no, s1.salary AS emp_salary, s2.salary AS manager_salaryFROM (SELECT s.salary, s.emp_no, de.dept_no FROM salaries AS s INNER JOIN dept_emp AS de ON s.emp_no = de.emp_no AND s.to_date='9999-01-01') AS s1, (SELECT s.salary, s.emp_no, dm.dept_no FROM salaries AS s INNER JOIN dept_manager AS dm ON s.emp_no = dm.emp_no AND s.to_date='9999-01-01') AS s2WHERE s1.dept_no = s2.dept_no AND s1.salary &gt; s2.salary; 26 汇总各个部门当前员工的title类型的分配数目题目描述1234567891011121314151617181920汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目countCREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE IF NOT EXISTS `titles` (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);输入描述:无输出描述:dept_no dept_name title count 解题思路 用 GROUP BY 同时对 de.dept_no 和 t.title 进行分组。 12345SELECT de.dept_no, dp.dept_name, t.title, COUNT(t.title) AS countFROM (dept_emp de INNER JOIN titles t ON de.emp_no = t.emp_no AND de.to_date = '9999-01-01' AND t.to_date = '9999-01-01') INNER JOIN departments dp ON de.dept_no = dp.dept_no GROUP BY de.dept_no, t.title; 27 给出每个员工每年薪水涨幅超过5000的员工编号emp_no题目描述1234567891011121314给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。提示：在sqlite中获取datetime时间对应的年份函数为strftime('%Y', to_date)CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输入描述:无输出描述:emp_no from_date salary_growth 解题思路 每年的薪资涨幅，转化为strftime(‘%Y’, s2.to_date) - strftime(‘%Y’, s1.to_date) = 1 这种需要“穷举”每两行的关系的题目，需要用那张表的两个副本（s2.emp_no = s1.emp_no是“穷举”操作，因为要考虑差值，就需要所有的两两组合。 1234567SELECT s1.emp_no, s2.from_date, (s2.salary-s1.salary) AS salary_growthFROM salaries s1, salaries s2WHERE s1.emp_no = s2.emp_no AND (strftime('%Y', s2.to_date) - strftime('%Y', s1.to_date) = 1 OR strftime('%Y', s2.from_date) - strftime('%Y', s1.from_date) = 1 ) AND salary_growth &gt; 5000ORDER BY salary_growth DESC; 28 查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部题目描述12345678910111213141516171819202122232425262728293031323334353637film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT '0',title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);查找描述信息中包括robot的电影对应的分类名称以及电影数目，而且还需要该分类对应电影数量&gt;=5部输入描述:无输出描述:无 解题思路123456789SELECT c.name AS name, COUNT(f.film_id) AS amountFROM film f, film_category fc, category c, (SELECT category_id FROM film_category GROUP BY category_id HAVING COUNT(film_id)&gt;=5) AS ccWHERE f.description LIKE '%robot%' AND f.film_id = fc.film_id AND fc.category_id = c.category_id AND c.category_id = cc.category_id; 29 使用join查询方式找出没有分类的电影id以及名称[题目描述]12345678910111213141516171819202122232425262728293031323334353637film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT '0',title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);使用join查询方式找出没有分类的电影id以及名称输入描述:无输出描述:无 解题思路 用 LEFT JOIN 连接 film 和 film_category，限定条件为 f.film_id = fc.film_id，即连接电影 id 和电影分类 id，如果电影没有分类，则电影分类 id 显示 null 再用 WHERE 来限定条件 fc.category_id IS NULL 选出没分类的电影 1234SELECT f.film_id, f.titleFROM film f LEFT JOIN film_category fcON f.film_id = fc.film_idWHERE fc.category_id IS NULL; 30 使用子查询的方式找出属于Action分类的所有电影对应的title,description题目描述123456789101112131415161718192021222324252627282930313233343536film表字段 说明film_id 电影idtitle 电影名称description 电影描述信息CREATE TABLE IF NOT EXISTS film (film_id smallint(5) NOT NULL DEFAULT '0',title varchar(255) NOT NULL,description text,PRIMARY KEY (film_id));category表字段 说明category_id 电影分类idname 电影分类名称last_update 电影分类最后更新时间CREATE TABLE category (category_id tinyint(3) NOT NULL ,name varchar(25) NOT NULL, `last_update` timestamp,PRIMARY KEY ( category_id ));film_category表字段 说明film_id 电影idcategory_id 电影分类idlast_update 电影id和分类id对应关系的最后更新时间CREATE TABLE film_category (film_id smallint(5) NOT NULL,category_id tinyint(3) NOT NULL, `last_update` timestamp);使用子查询的方式找出属于Action分类的所有电影对应的title,description输入描述:无输出描述:无 解题思路12345SELECT f.title, f.descriptionFROM (film f INNER JOIN film_category fc ON f.film_id = fc.film_id) INNER JOIN category c ON fc.category_id = c.category_idWHERE c.name = 'Action'; 31 获取select * from employees对应的执行计划题目描述12345获取select * from employees对应的执行计划输入描述:无输出描述:无 解题思路 可以用 “EXPLAIN” 关键字短语，用于描述表的细节。 1EXPLAIN SELECT * FROM employees; 32 将employees表的所有员工的last_name和first_name拼接起来作为Name题目描述123456789101112将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输入描述:无输出描述:Name 解题思路 MySQL用的 SELECT Concat(last_name, ‘ ‘, first_name) AS Name 本题SQLite数据库只支持用连接符号”||”来连接字符串 12SELECT (last_name||" "||first_name) AS NameFROM employees; 33 创建一个actor表，包含如下列信息[创建一个actor表，包含如下列信息]1234567列表 类型 是否为NULL 含义actor_id smallint(5) not null 主键idfirst_name varchar(45) not null 名字last_name varchar(45) not null 姓氏last_update timestamp not null 最后更新时间，默认是系统的当前时间输入描述:无 解题思路1234567CREATE TABLE actor(actor_id smallint(5) not null,first_name varchar(45) not null,last_name varchar(45) not null,last_update timestamp not null DEFAULT (datetime('now','localtime')),PRIMARY KEY (actor_id)); 34 批量插入数据题目描述1234567891011对于表actor批量插入如下数据CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))actor_id first_name last_name last_update1 PENELOPE GUINESS 2006-02-15 12:34:332 NICK WAHLBERG 2006-02-15 12:34:33输入描述:无 解题思路 insert into 表名 (列名可选) values(数据1),(数据2) 12INSERT INTO actor(actor_id, first_name, last_name, last_update)values (1,'PENELOPE','GUINESS','2006-02-15 12:34:33'), (2,'NICK','WAHLBERG','2006-02-15 12:34:33'); 使用UNION SELECT插入 123INSERT INTO actor(actor_id, first_name, last_name, last_update)SELECT 1, 'PENELOPE', 'GUINESS', '2006-02-15 12:34:33'UNION SELECT 2, 'NICK', 'WAHLBERG', '2006-02-15 12:34:33'; 35 批量插入数据，不使用replace操作题目描述12345678对于表actor批量插入如下数据,如果数据已经存在，请忽略，不使用replace操作CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))actor_id first_name last_name last_update'3' 'ED' 'CHASE' '2006-02-15 12:34:33' 解题思路12INSERT OR IGNORE INTO actorVALUES('3', 'ED', 'CHASE', '2006-02-15 12:34:33'); 若使用MySQL，则把OR去掉，即INSERT IGNORE INTO。 36 创建一个actor_name表题目描述123456789对于如下表actor，其对应的数据为:actor_id first_name last_name last_update1 PENELOPE GUINESS 2006-02-15 12:34:332 NICK WAHLBERG 2006-02-15 12:34:33创建一个actor_name表，将actor表中的所有first_name以及last_name导入改表。 actor_name表结构如下：列表 类型 是否为NULL 含义first_name varchar(45) not null 名字last_name varchar(45) not null 姓氏 解题思路123456CREATE TABLE actor_name(first_name varchar(45) not null,last_name varchar(45) not null);INSERT INTO actor_nameSELECT first_name, last_name FROM actor; 37 对first_name创建唯一索引uniq_idx_firstname题目描述1234567针对如下表actor结构创建索引：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')))对first_name创建唯一索引uniq_idx_firstname，对last_name创建普通索引idx_lastname 解题思路 创建唯一索引 CREATE UNIQUE INDEX。 创建普通索引 CREATE INDEX。 12CREATE UNIQUE INDEX uniq_idx_firstname ON actor(first_name);CREATE INDEX idx_lastname ON actor(last_name); 38 针对actor表创建视图actor_name_view题目描述123456针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime'))) 解题思路123CREATE VIEW actor_name_view ASSELECT first_name AS first_name_v, last_name AS last_name_vFROM actor; 也可以直接在视图名后面跟字段名。 1234CREATE VIEW actor_name_view (first_name_v,last_name_v)ASSELECT first_name , last_name FROM actor; 39 针对上面的salaries表emp_no字段创建索引idx_emp_no题目描述12345678针对salaries表emp_no字段创建索引idx_emp_no，查询emp_no为10005, 使用强制索引。CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));create index idx_emp_no on salaries(emp_no); 解题思路 MYSQL中强制索引查询使用：FORCE INDEX(indexname); SQLite中强制索引查询使用：INDEXED BY indexname; 1SELECT * FROM salaries INDEXED BY idx_emp_no WHERE emp_no = 10005; 40 在last_update后面新增加一列名字为create_date题目描述1234567存在actor表，包含如下列信息：CREATE TABLE IF NOT EXISTS actor (actor_id smallint(5) NOT NULL PRIMARY KEY,first_name varchar(45) NOT NULL,last_name varchar(45) NOT NULL,last_update timestamp NOT NULL DEFAULT (datetime('now','localtime')));现在在last_update后面新增加一列名字为create_date, 类型为datetime, NOT NULL，默认值为'0000 00:00:00' 解题思路 题目给的日期格式是错的。 使用ALTER TABLE更新表。 12ALTER TABLE actorADD create_date datetime NOT NULL DEFAULT '0000-00-00 00:00:00'; 41 构造一个触发器audit_log题目描述123456789101112构造一个触发器audit_log，在向employees_test表中插入一条数据的时候，触发插入相关的数据到audit中。CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,NAME TEXT NOT NULL); 解题思路 用 CREATE TRIGGER 语句构造触发器，用 BEFORE或AFTER 来指定在执行后面的SQL语句之前或之后来触发TRIGGER 触发器执行的内容写出 BEGIN与END 之间 可以使用 NEW与OLD 关键字访问触发后或触发前的employees_test表单记录 1234CREATE TRIGGER audit_log AFTER INSERT ON employees_testBEGIN INSERT INTO audit VALUES(NEW.ID, NEW.NAME);END; 42 删除emp_no重复的记录，只保留最小的id对应的记录题目描述123456789101112131415删除emp_no重复的记录，只保留最小的id对应的记录。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'); 解题思路 先用 GROUP BY 和 MIN() 选出每个 emp_no 分组中最小的 id. 然后用 DELETE FROM … WHERE … NOT IN … 语句删除 “非每个分组最小id对应的所有记录” 123DELETE FROM titles_test WHERE id NOT IN (SELECT MIN(id) FROM titles_test GROUP BY emp_no); 43 将所有to_date为9999-01-01的全部更新为NULL题目描述123456789101112131415将所有to_date为9999-01-01的全部更新为NULL,且 from_date更新为2001-01-01。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'); 解题思路1234UPDATE titles_test SET to_date = NULL, from_date = '2001-01-01'WHERE to_date = '9999-01-01'; 44 将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005题目描述123456789101112131415将id=5以及emp_no=10001的行数据替换成id=5以及emp_no=10005,其他数据保持不变，使用replace实现。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'); 解题思路123UPDATE titles_test SET emp_no=10005WHERE id=5 AND emp_no=10001; 45 将titles_test表名修改为titles_2017题目描述123456789101112131415将titles_test表名修改为titles_2017。CREATE TABLE IF NOT EXISTS titles_test (id int(11) not null primary key,emp_no int(11) NOT NULL,title varchar(50) NOT NULL,from_date date NOT NULL,to_date date DEFAULT NULL);insert into titles_test values ('1', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('2', '10002', 'Staff', '1996-08-03', '9999-01-01'),('3', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'),('4', '10004', 'Senior Engineer', '1995-12-03', '9999-01-01'),('5', '10001', 'Senior Engineer', '1986-06-26', '9999-01-01'),('6', '10002', 'Staff', '1996-08-03', '9999-01-01'),('7', '10003', 'Senior Engineer', '1995-12-03', '9999-01-01'); 解题思路1ALTER TABLE titles_test RENAME TO titles_2017; 46 在audit表上创建外键约束，其emp_no对应employees_test表的主键id题目描述12345678910111213在audit表上创建外键约束，其emp_no对应employees_test表的主键id。CREATE TABLE employees_test(ID INT PRIMARY KEY NOT NULL,NAME TEXT NOT NULL,AGE INT NOT NULL,ADDRESS CHAR(50),SALARY REAL);CREATE TABLE audit(EMP_no INT NOT NULL,create_date datetime NOT NULL); 解题思路 MySQL使用ALTER TABLE tablename ADD FOREIGN KEY … REFERENCES。 sqlite只能先删除表，在建立表。 12345DROP TABLE audit;CREATE TABLE audit( EMP_no INT NOT NULL, create_date datetime NOT NULL, FOREIGN KEY(EMP_no) REFERENCES employees_test(ID)); 47 如何获取emp_v和employees有相同的数据no题目描述12345678910111213存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;如何获取emp_v和employees有相同的数据？CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT e.* FROM employees e, emp_v evWHERE e.emp_no = ev.emp_no; 123SELECT e.* FROM employees e INNER JOIN emp_v evON e.emp_no = ev.emp_no; 48 将所有获取奖金的员工当前的薪水增加10%题目描述12345678910将所有获取奖金的员工当前的薪水增加10%。create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`)); 解题思路1234UPDATE salariesSET salary = salary + salary * 0.1WHERE emp_no IN (SELECT emp_no FROM emp_bonus) AND to_date='9999-01-01'; 49 针对库中的所有表生成select count(*)对应的SQL语句题目描述12345678910111213141516171819202122232425262728293031323334353637383940针对库中的所有表生成select count(*)对应的SQL语句CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:cntsselect count(*) from employees;select count(*) from departments;select count(*) from dept_emp;select count(*) from dept_manager;select count(*) from salaries;select count(*) from titles;select count(*) from emp_bonus; 解题思路 列出数据库中所有表名：SELECT name FROM sqlite_master WHERE type=’table’ 12SELECT "select count(*) from " || name || ";" AS cntsFROM sqlite_master WHERE type = 'table'; 50 将employees表中的所有员工的last_name和first_name通过(‘)连接起来题目描述123456789101112将employees表中的所有员工的last_name和first_name通过(')连接起来。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:nameFacello'Georgi 解题思路12SELECT last_name || "'" || first_name AS nameFROM employees; 51 查找字符串’10,A,B’ 中逗号’,’出现的次数cnt题目描述1查找字符串'10,A,B' 中逗号','出现的次数cnt。 解题思路 用replace函数将原串中出现的子串用空串替换 再用原串长度减去替换后字符串的长度（使用length）函数获得串长度 最后除以子串的长度 1SELECT (length('10,A,B')-length(replace('10,A,B', ',', ''))) / length(',') AS cnt; 52 获取Employees中的first_name题目描述123456789101112131415获取Employees中的first_name，查询按照first_name最后两个字母，按照升序进行排列CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式：first_nameChirstianTzvetanBezalelDuangkaew 解题思路 substr(X,Y,Z) 或 substr(X,Y) 函数。其中X是要截取的字符串。Y是字符串的起始位置（注意第一个字符的位置为1，而不为0），取值范围是±(1~length(X))，当Y等于length(X)时，则截取最后一个字符；当Y等于负整数-n时，则从倒数第n个字符处截取。Z是要截取字符串的长度，取值范围是正整数，若Z省略，则从Y处一直截取到字符串末尾；若Z大于剩下的字符串长度，也是截取到字符串末尾为止。 123SELECT first_name FROM employeesORDER BY substr(first_name, -2); 123SELECT first_name FROM employeesORDER BY substr(first_name, length(first_name)-1); 53 按照dept_no进行汇总题目描述123456789101112131415按照dept_no进行汇总，属于同一个部门的emp_no按照逗号进行连接，结果给出dept_no以及连接出的结果employeesCREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输出格式:dept_no employeesd001 10001,10002d002 10006d003 10005d004 10003,10004d005 10007,10008,10010d006 10009,10010 解题思路 SQLite的聚合函数group_concat(X, Y)，其中X是要连接的字段，Y是连接时用的符号，可省略，默认为逗号。 1234SELECT dept_no, group_concat(emp_no, ',') AS employeesFROM dept_empGROUP BY dept_noORDER BY dept_no; 54 查找排除当前最大、最小salary之后的员工的平均工资avg_salary题目描述123456789查找排除当前最大、最小salary之后的员工的平均工资avg_salary。CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:avg_salary69462.5555555556 解题思路12345SELECT Avg(salary) AS avg_salaryFROM salariesWHERE to_date = '9999-01-01' AND salary NOT IN (SELECT MIN(salary) FROM salaries) AND salary NOT IN (SELECT MAX(salary) FROM salaries); 55 分页查询employees表，每5行一页，返回第2页的数据题目描述123456789分页查询employees表，每5行一页，返回第2页的数据CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`)); 解题思路 LIMIT 关键字。注意：在 LIMIT X,Y 中，Y代表返回几条记录，X代表从第几条记录开始返回（第一条记录序号为0） LIMIT 和 OFFSET 关键字。LIMIT 后的数字代表返回几条记录，OFFSET 后的数字代表从第几条记录开始返回 123SELECT * FROM employeesLIMIT 5, 5; 123SELECT * FROM employeesLIMIT 5 OFFSET 5; 56 获取所有员工的emp_no题目描述12345678910111213141516171819202122232425262728获取所有员工的emp_no、部门编号dept_no以及对应的bonus类型btype和recevied，没有分配具体的员工不显示CREATE TABLE `dept_emp` ( `emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:e.emp_no dept_no btype recevied 解题思路 题目缺了一个emp_bonus表，如下。 1234create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null); 123SELECT e.emp_no, de.dept_no, eb.btype, eb.receviedFROM (employees e INNER JOIN dept_emp de ON e.emp_no = de.emp_no)LEFT JOIN emp_bonus eb ON e.emp_no = eb.emp_no; 57 使用含有关键字exists查找未分配具体部门的员工的所有信息题目描述123456789101112131415161718使用含有关键字exists查找未分配具体部门的员工的所有信息。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));输出格式:emp_no birth_date first_name last_name gender hire_date10011 1953-11-07 Mary Sluis F 1990-01-22 解题思路123SELECT *FROM employeesWHERE NOT EXISTS (SELECT emp_no FROM dept_emp WHERE emp_no = employees.emp_no); 1234SELECT e.*FROM employees e LEFT JOIN dept_emp deON e.emp_no = de.emp_noWHERE de.emp_no IS NULL; 58 获取employees中的行数据，且这些行也存在于emp_v中题目描述12345678910111213存在如下的视图：create view emp_v as select * from employees where emp_no &gt;10005;CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));获取employees中的行数据，且这些行也存在于emp_v中。注意不能使用intersect关键字。输出格式:emp_no birth_date first_name last_name gender hire_date 解题思路123SELECT e.*FROM employees e INNER JOIN emp_v evON e.emp_no = ev.emp_no; 123SELECT e.*FROM employees e, emp_v evWHERE e.emp_no = ev.emp_no; 1SELECT * FROM emp_v 59 获取有奖金的员工相关信息。题目描述123456789101112131415161718192021222324252627获取有奖金的员工相关信息。CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));create table emp_bonus(emp_no int not null,recevied datetime not null,btype smallint not null);CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL, PRIMARY KEY (`emp_no`,`from_date`));给出emp_no、first_name、last_name、奖金类型btype、对应的当前薪水情况salary以及奖金金额bonus。 bonus类型btype为1其奖金为薪水salary的10%，btype为2其奖金为薪水的20%，其他类型均为薪水的30%。 当前薪水表示to_date='9999-01-01'输出格式:emp_no first_name last_name btype salary bonus 解题思路 使用CASE语句。 1234567SELECT e.emp_no, e.first_name, e.last_name, eb.btype, s.salary, (CASE eb.btype WHEN 1 THEN s.salary * 0.1 WHEN 2 THEN s.salary * 0.2 ELSE s.salary * 0.3 END) AS bonusFROM (employees e INNER JOIN salaries s ON e.emp_no = s.emp_no AND s.to_date='9999-01-01')INNER JOIN emp_bonus eb ON e.emp_no = eb.emp_no; 60 统计salary的累计和running_total题目描述12345678910111213141516171819题目描述按照salary的累计和running_total，其中running_total为前两个员工的salary累计和，其他以此类推。 具体结果如下Demo展示。。CREATE TABLE `salaries` ( `emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));输出格式:emp_no salary running_total10001 88958 8895810002 72527 16148510003 43311 20479610004 74057 27885310005 94692 37354510006 43311 41685610007 88070 50492610009 95409 60033510010 94409 69474410011 25828 720572 解题思路 running_total由一个 SELECT 子查询构成。将子查询内复用的 salaries 表记为 s2，主查询的 salaries 表记为 s1，当主查询的 s1.emp_no 确定时，对子查询中不大于 s1.emp_no 的 s2.emp_no 所对应的薪水求和。 1234SELECT s1.emp_no, s1.salary, (SELECT SUM(s2.salary) FROM salaries s2WHERE s2.emp_no &lt;= s1.emp_no AND s2.to_date = '9999-01-01') AS running_totalFROM salaries s1 WHERE s1.to_date = '9999-01-01' ORDER BY s1.emp_no; 61 对于employees表中，给出奇数行的first_name题目描述1234567891011121314151617对于employees表中，给出奇数行的first_nameCREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));输出格式:first_nameGeorgiChirstianAnnekeTzvetanSaniyaMary 解题思路 题目隐含了first_name是排序的。 1234SELECT e1.first_nameFROM employees e1WHERE (SELECT COUNT(*) FROM employees e2 WHERE e2.first_name &lt;= e1.first_name) % 2 = 1;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StudyNotes-MySQL必知必会]]></title>
    <url>%2F2019%2F06%2F14%2FStudyNotes-MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[本系列为StudyNotes整理，所有笔记汇总如下： StudyNotes-MySQL必知必会….. 本文为MySQL必知必会StudyNotes。 相关题解：数据库SQL实战题解 第1章 了解SQL1.1 数据库基础1.1.1 什么是数据库 数据库 以某种有组织的方式存储的数据集合 保存有组织的数据的容器（通常是一个文件或一组文件） 数据库软件 DBMS-数据库管理系统 使用DBMS访问数据库 1.1.2 表 表 是一种结构化的文件，用来存储某种特定类型的数据 某种特定类型数据的结构化清单 存储在表中的数据是一种类型或一个清单，不应该在同一个表中有两种类型或两个清单 表名用来标识自己，名字是唯一的 相同数据库中不能使用相同的表名，但在不同的数据库中可以使用相同的表名 模式 定义了数据在表中如何存储 用来描述数据库中特定的表以及整个数据库和其中表的关系 关于数据库和表的布局及特性的信息 1.1.3 列和数据类型 列 表由列组成，列中存储着表中某部分的信息 表中的一个字段，所有表都是有一个或者多个列组成的 正确地将数据分解分为多个列很重要 数据类型 所容许的数据的类型，每个表列都有响应的数据类型，限制（或容许）该列中存储的数据 1.1.4 行 行 表中的一个记录 行 = 数据库记录 1.1.5 主键 主键 一列（或一组列），其值能够唯一区分表中的每个行 应该总是定义主键，便于数据操纵和管理 任意两行都不具有相同的主键值 表中任何列都可以作为主键，主要它满足一下条件 每个行都必须具有一个主键值（主键列不允许NULL值） 通常定义在表的一列上，但也可以使用多个列作为主键 好习惯 不更新主键列中的值 不重用主键列的值 不在主键列中使用可能会更改的值 1.2 什么是SQL SQL 结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言 优点 不是某个特定数据库供应商专有的语言，通用性 简单易学 强有力，灵活，可以进行非常复杂和高级的数据库操作 任意两个DBMS实现的SQL都不完全相同，不是完全可移植的，本书针对MySQL 1.3 动手实践 附录B B.1 样例表 - 随身物品推销商使用的订单录入系统 管理供应商 管理产品目录 管理顾客列表 录入顾客订单 表的描述 6个表，表的列出顺序是因为它们之间的依赖关系 vendors表 存储销售产品的供应商，每个供应商为一个记录。供应商列用来匹配产品和供应商 所有表都应该有主键，这个表使用vend_id作为主键，vend_id为一个自动增量字段 表B-1 vendors表的列 列 说明 vend_id 唯一的供应商ID vend_name 供应商名 vend_address 供应商的地址 vend_city 供应商的城市 vend_state 供应商的州 vend_zip 供应商的邮政编码 vend_country 供应商的国家 products表 products表包含产品目录，每行一个产品，每个产品有唯一的ID（prod_id列），通过vend_id（供应商的唯一ID）关联到它的供应商 所有表都应该有主键，这个表使用prod_id列作为主键 为实施引用完整性，应该在vend_id上定义一个外键，关联到vendors的vend_id 表B-2 products表的列 列 说明 prod_id 唯一的产品ID vend_id 产品供应商ID（关联到vendors表中的vend_id） prod_name 产品名 prod_price 产品价格 prod_desc 产品描述 customers表 customers表存储所有顾客的信息，每个顾客有唯一的ID（cust_id列） 所有表都应该有主键，这个表使用cust_id列作为主键，cust_id是一个自动增量的字段 表B-3 customers表的列 列 说明 cust_id 唯一的顾客ID cust_name 顾客名 cust_address 顾客的地址 cust_city 顾客的城市 cust_state 顾客的州 cust_zip 顾客的邮政编码 cust_country 顾客的国家 cust_contact 顾客的联系名 cust_email 顾客的联系email地址 orders表 orders表存储顾客订单（但不是订单细节），每个订单唯一的编号（order_num列），订单用cust_id列（它关联到customer表的顾客唯一ID）与响应的顾客关联 所有表都应该有主键，这个表使用order_num列作为主键，order_num是一个自动增量的字段 为实施引用完整性，应该在cust_id上定义一个外键，关联到customers的cust_id 表B-4 orders表的列 列 说明 order_num 唯一订单号 order_data 订单日期 cust_id 订单顾客ID（关联到customers表的cust_id） orderitems表 orderitems表存储每个订单中的实际物品，每个订单的每个物品占一行，对orders表中的一行，orderitems中有一行或多行，每个订单物品有订单号加订单物品（第一个物品、第二个物品等）唯一标识。订单物品通过order_num列（关联到orders中订单的唯一ID）与它们响应的订单相关联，每个订单项包含订单物品的产品ID（它关联物品到products表） 所有表都应该有主键，这个表使用order_num和order_item作为其主键 为实施引用完整性，应该在order_num上定义一个外键，关联到orders的order_num，在prod_id定义外键，关联到products的prod_id 表B-5 orderitems表的列 列 说明 order_num 订单号（关联到orders表的order_num） order_item 订单物品号（在某个订单中的顺序） prod_id 产品ID（关联到products表的prod_id） quantity 物品数量 item_price 物品价格 productnotes表 productnotes表存储于特定产品有关的注释信息，并非所有产品都有相关的注释，而有的产品可能有许多相关的注释 所有表都应该有主键，这个表使用note_id作为其主键 列note_text必须为FULLTEXT搜索进行索引 由于这个表使用全文本搜索，因此必须指定ENGINE=MyISAM 表B-6 productnotes表的列 列 说明 note_id 唯一注释ID prod_id 产品ID（对应于products表中的prod_id） note_date 增加注释的日期 note_text 注释文本 B.2 创建样例表下载数据：https://www/forta.com/books/0672327120/ 创建一个新数据源 保证选择新数据源 执行create.sql脚本 重复前面的步骤，用populate.sql文件填充各个新表 第2章 MySQL简介2.1 什么是MySQL MySQL 是一种DBMS，数据库软件 广泛使用，原因： 成本 - MySQL是开源的，可以免费使用（甚至可以免费修改） 性能 - MySQL执行很快 可信赖 - 很多公司，站点都用MySQL来处理自己的重要数据 简单 - MySQL很容易安装和使用 2.1.1 客户机-服务器软件 DBMS 分两类，一类为基于共享文件系统的DBMS，另一类为基于客户机-服务器的DBMS MySQL是基于客户机-服务器的数据库 服务器部分是负责所有数据访问和处理的一个软件，运行在数据库服务器上，与数据文件打交道的只有服务器软件，数据添加、删除和更新都由服务器软件完成 客户机是与用户打交道的软件 2.1.2 MySQL版本 DBMS版本 当前版本为5 版本4：InnoDB引擎，增加事物处理（第26章），并（第17章），改进全文本搜索（第18章）的支持 版本4.1：对函数库、子查询（第14章）、集成帮助等的重要增加 版本5：存储过程（第23章）、触发器（第25章）、游标（第24章）、视图（第22章）等 2.2 MySQL工具2.2.1 mysql命令行使用程序 指定登录名：mysql -u ben 指定用户名、主机名、端口和口令：mysql -u ben -p -h myserver -P 9999 完整的参数列表：mysql —help 命令输入在mysql&gt;之后 命令用 ; 或 \g 结束，仅按enter不执行命令 输入help或 -h 获得帮助 获得特定命令的帮助 如help select 输入quit或exit退出命令行实用程序 2.2.2 MySQL Administrator MySQL Administrator（MySQL管理器）是一个图形交互客户机，简化MySQL服务器的管理 key points： Server Information（服务器信息）显示客户机和被连接的服务器的状态和版本信息 Server Control（服务控制）允许停止和启动MySQL以及指定服务器特性 User Administration（用户管理）用来定义MySQL用户、登录和权限 Catalogs（目录）列出可用的数据库并允许创建数据库和表 2.2.3 MySQL Query Browser MySQL Query Browser是一个图形交互客户机，编写和执行MySQL命令 第3章 使用MySQL3.1 连接 MySQL有自己的用户列表，用户间的权限可能不同 MySQL Administrator 的Users视图可直接定义新用户，包括赋予口令和访问权限 主机名+端口+用户名+口令 3.2 选择数据库 使用USE关键字 （关键字：作为MySQL的保留字，不要用关键字命名一个表和列。） USE crashcourse （选择crashcourse数据库，不返回任何结果） 3.3 了解数据库和表 SHOW DATABASES（返回可用数据库的一个列表） SHOW TABLES（返回当前选择的数据库内可用表的列表） SHOW COLUMNS FROM customers； （显示表列） 对每个字段返回一行，行中包括字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（如字段cust_id的auto_increment） 自动增量：某些表列需要唯一值，在每个行添加到表中时，MySQL自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值。在CREATE语句创建表时定义（第21章） DESCRIBE是SHOW COLUMNS FROM的快捷方式，DESCRIBE customers 与 SHOW COLUMNS FROM customers 等价 SHOW STATUS （显示服务器状态信息） SHOW CREATE DATABASE和SHOW CREATE TABLE （分别用来显示创建特定数据库或表的MySQL语句） SHOW GRANTS （显示授予用户（所有用户或特定用户）的安全权限） SHOW ERRORS和SHOW WARNINGS （显示服务器错误或警告消息） HELP SHOW （显示所有允许的SHOW语句） MySQL新增内容：INFORMATION_SCHEMA，获得和过滤模式信息 第4章 检索数据4.1 SELECT语句 从一个表或多个表中检索信息 使用SELECT时，至少给出两条信息：想选择什么，以及从什么地方选择 4.2 检索单个列123# 从products表中检索一个名为prod_name的列，返回的数据是无序的SELECT prod_nameFROM products; 多条语句用分号分隔，在每一条语句后加分号没有坏处 SQL语句不区分大小写，SELECT=Select，一般对关键字使用大写，对列和表明使用小写，易于阅读和调试 在处理SQL语句时，所有空格被忽略，SQL语句可以在一行给出，也可以分成许多行，多行更容易阅读和调试 4.3 检索多个列 使用相同的SELECT语句，在SELECT后给出多个列名，列名之间必须以逗号分隔，但最后一个列名后不加逗号，否则报错 12SELECT prod_id, prod_name, prod_priceFROM products; SQL语句一般返回原始的、无格式的数据 数据的格式化是一个表示问题，而不是检索问题，表示（对齐和数值）一般在显示该数据的应用程序中规定，一般很少使用实际检索出的原始数据 4.4 检索所有列123# 使用通配符 * SELECT *FROM products; 如果给定一个通配符 * ，则返回表中所有列，列的顺序一般是列在表定义中出现的顺序，但表的模式的变化（如添加和删除列）可能会导致顺序的变化 使用通配符省事，但会降低检索和应用程序的性能 使用通配符优点，可以检索出名字未知的列 4.5 检索不同的行123# 只返回不同的vend_id行SELECT DISTINCT vend_idFROM products; 使用DISTINCT关键字只返回不同的值，放在列名的前面 不能部分使用DISTINCT，DISTINCT应用于所有列而不仅是前置它的列 4.6 限制结果 使用LIMIT语句返回前几行 1234# 返回不多于5行SELECT prod_nameFROM productsLIMIT 5; 指定要检索的开始行和行数 1234# 返回从行5开始的5行SELECT prod_nameFROM productsLIMIT 5, 5; LIMIT 5, 5返回从行5开始的5行，第一个数为开始位置，第二个数为要检索的行数 带一个值的LIMIT总是从第一行开始，给出的数为返回的行数 第一行时行0，LIMIT 1, 1将检索出第二行而不是第一行 LIMIT中指定要检索的行数为检索的最大行数 MySQL5支持LIMIT 4 OFFSET 3 与 LIMIT 3, 4等价，从行3开始取4行 4.7 使用完全限定的表名 完全限定的名字：同时使用表名和列字 12SELECT products.prod_name # 完全限定的列名FROM products； 12SELECT products.prod_name # 完全限定的列名FROM crashcourse.products； # 完全限定的表名 第5章 排序检索数据 SELECT语句的ORDER BY 子句 5.1 排序数据12SELECT prod_nameFROM products; 以上输出数据没有特定的顺序，如果不排序，一般会以它在底层表中出现的顺序显示，这可以是数据最初添加到表中的顺序，但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。 子句，SQL语句由子句构成，有些子句是必需的，而有的是可选的，一个子句通常由一个关键字和所提供的的数据组成，如SELECT语句的FROM子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序。 123SELECT prod_nameFROM productsORDER BY prod_name; 通常ORDER BY子句中使用的列为显示所选择的列，但用非检索列的列排序数据也是完全合法的。 5.2 按多个列排序 按多个列排序，只要指定列名，列名之间用逗号分开即可。 1234# 首先按价格，再按名称排序SELECT prod_id, prod_price, prod_nameFROM productsORDER BY prod_price, prod_name; 5.3 指定排序方向 默认是生序排序，无须指定关键字，也可以指定升序关键字ASC 降序排序需要指定DESC关键字。 1234# 降序排序SELECT prod_id, Prod_price, prod_nameFROM productsORDER BY prod_price DESC; 1234# prod_price降序排序, prod_name 升序排序SELECT prod_id, Prod_price, prod_nameFROM productsORDER BY prod_price DESC, prod_name; 在多个列上降序排序，必须对每个列指定DESC关键字。 大小写问题，MySQL认为A和a相同。 ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值。 12345# 找出价格最高物品的值SELECT prod_priceFROM productsORDER BY prod_price DESCLIMIT 1; ORDER BY在FROM子句之后，LIMIT位于ORDER BY之后，次序不对将报错。 第6章 过滤数据 使用SELECT的WHERE子句指定搜索条件。 6.1 使用WHERE子句 只检索所需数据需要指定搜索条件，搜索条件也称为过滤条件。 在SELECT中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出。 1234# 从products中检索两个列，只返回prod_price值为2.50的行SELECT prod_name, prod_priceFROM productsWHERE prod_price = 2.50; 6.2 WHERE子句操作符 WHERE支持的条件操作符。 WHERE子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 6.2.1 检查单个值1234# 返回prod_name的值为Fuses的行，不区分大小写，Fuces和fuces匹配SELECT prod_name, prod_priceFROM productsWHERE prod_name = 'fuses'; 1234# 列出价格小于10美元的所有产品SELECT prod_name, prod_priceFROM productsWHERE prod_price &lt; 10; 6.2.2 不匹配检查1234# 列出不是由供应商制造的所有产品SELECT vend_id, prod_nameFROM productsWHERE vend_id &lt;&gt; 1003; 何时使用引号：单引号用来限定字符串，如果将值与串类型的列进行比较，则需要限定引号，用来与数值列进行比较的值不用引号。 &lt;&gt; 和 != 等价。 6.2.3 范围值检查 使用BETWEEN操作符，需要两个值，即范围的开始值和结束值，匹配范围内所有的值，包括开始值和结束值。 1234# 检索价格在5美元到10美元的所有产品SELECT prod_name, prod_priceFROM productsWHERE prod_price BETWEEN 5 AND 10; 6.2.4 空值检查 在创建表时，可以指定其中的列可以不包含空值，空值为NULL。 空值NULL与字段包含0，空字符串或仅仅包含空格不同。 IS NULL子句用来检索NULL的列。 1234# 返回没有价格（空prod_price字段，不是价格为0）的所有产品的行SELECT prod_nameFROM productsWHERE prod_price IS NULL; NULL与不匹配：匹配过滤和不匹配过滤时不返回具有NULL值的行。 第7章 数据过滤 组合WHERE子句，NOT和IN操作符。 7.1 组合WHERE子句 以ANF子句或OR子句的方式使用多个WHERE子句。 操作符：用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符。 7.1.1 AND操作符1234# 检索由供应商1003制造且价格小于等于10美元的所有产品的名称和价格SELECT prod_id, prod_price, prod_nameFROM productsWHERE vend_id = 1003 AND prod_price &lt;= 10; AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。 7.1.2 OR操作符 OR操作符与AND不同，它指示检索匹配任一条件的行。 1234# 检索由供应商1002或1003制造的任何产品SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003; OR 用在WHERE子句中的关键字，用来指示检索匹配任一给定条件的行。 7.1.3 计算次序 WHERE可包含任意数目的AND和OR操作符，允许两者结合以进行复杂和高级的过滤。 AND的计算优先级比OR高，使用圆括号明确地分组相应的操作符。 1234# 检索由供应商1002或1003制造的任何产品，并且价格大于等于10美元的行SELECT prod_name, prod_priceFROM productsWHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price &gt;= 10; 在WHERE子句中，任何时候使用AND和OR操作时，都要使用圆括号明确地分组操作符，使用圆括号没有坏处，可以消除歧义。 7.2 IN操作符 圆括号在WHERE子句中还有另外一种用法，IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，IN取合法值的由逗号分隔的清单，全都在圆括号中。 123456# 检索供应商1002和1003制造的所有产品SELECT prod_name, prod_priceFROM productsWHERE vend_id IN (1002, 1003)ORDER BY prod_name;​` IN操作符完成与OR相同的功能。 ​12345# 检索供应商1002和1003制造的所有产品SELECT prod_name, prod_priceFROM productsWHERE vend_id = 1002 OR vend_id = 1003ORDER BY prod_name; IN操作符的优点： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观 计算次数更容易管理 比OR操作符执行更快 最大的优点是可以包含其他SELECT语句，能够更加动态地建立WHERE子句 7.3 NOT操作符 NOT操作符有且只有一个功能，否定它之后所跟的任何条件。 12345# 匹配1002和1003之外的供应商SELECT prod_name, prod_priceFROM productsWHERE vend_id NOT IN (1002, 1003)ORDER BY prod_name; 与IN操作符联合使用时，NOT使找出与条件列表不匹配的行。 第8章 用通配符进行过滤8.1 LIKE操作符 通配符：用来匹配值的一部分的特殊字符。 搜索模式：由字面值、通配符或两者组合构成的搜索条件。 在搜索子句中使用通配符，必须使用LIKE操作符，LIKE指示后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 8.1.1 百分号（%）通配符 % 表示任何字符出现的任意次数。 1234# 检索任意jet起头的词，%告诉MySQL接受jet之后的任意字符，不管它有多少字符SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 'jet%'; 区分大小写：搜索是可以区分大小写的。 通配符可以在搜索模式中任意位置使用，并且可以使用多个通配符。 1234# 匹配任何位置包含文本anvil的值SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '%anvil%'; 1234# 匹配以s起头以e结尾的所有产品SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE 's%e'; % 还可以匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。 注意尾空格，尾空格可能会干扰通配符匹配，例如anvil后有一个或多个空格时，则子句WHERE prod_name LIKE &#39;%anvil&#39;将不会匹配它们，因为在最后有空格，一个简单的方法是在搜索模式最后附加一个%，一个更好的方法是使用函数（第11章）去掉首尾空格。 注意NULL，%通配符不能匹配值为NULL的行。 8.1.2 下划线（_）通配符 下划线只匹配单个字符而不是多个字符。 1234# （_）只匹配一个字符SELECT prod_id, prod_nameFROM productsWHERE prod_name LIKE '_ ton anvil' 8.2 使用通配符的技巧 通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。 技巧： 不要过度使用通配符。 除非有必要，否则不要把它们用在搜索模式的开始处，因为置于开始处是最慢的。 仔细注意通配符的位置。 第9章 用正则表达式进行搜索9.1 正则表达式介绍 正则表达式：用来匹配文本的特殊的串（字符集合）。 更多参考《正则表达式必知必会》。 9.2 使用MySQL正则表达式 MySQL仅支持正则表达式实现的一个很小的子集。 9.2.1 基本字符匹配12345# 检索列prod_name包含1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; 12345# .是表示匹配任意一个字符，因此可以匹配1000和2000SELECT prod_nameFROM productsWHERE prod_name REGEXP '.000'ORDER BY prod_name; LIKE和REGEXP比较。 12345# 不返回数据SELECT prod_nameFROM productsWHERE prod_name LIKE '1000'ORDER BY prod_name; 12345# 检索列prod_name包含1000的所有行SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; LIKE匹配整个列，如果被匹配的文本在列值中出现，LIKE将不会找到它，除非使用通配符。 而REGEXP在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到它，响应的行将被返回。 匹配不区分大小写，为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY &#39;JetPack .000&#39;。 9.2.2 进行OR匹配 为检索两个串之一，使用|。 12345# | 表示OR操作，表示匹配其中之一，因此1000和2000都匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 可以给出两个以上的OR条件，例如&#39;1000|2000|3000&#39;将匹配1000或2000或3000。 9.2.3 匹配几个字符之一 使用一组用[]括起来的字符即可。 12345# [123]表示匹配1或2或3，因此，1 ton和2 ton都匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP '[123] Ton'ORDER BY prod_name; [] 是另一种形式的OR语句，[123] Ton是[1|2|3] Ton的缩写。 需要用[]来定义OR语句。 12345# 表示'1'或'2'或'3 ton'SELECT prod_nameFROM productsWHERE prod_name REGEXP '1|2|3 Ton'ORDER BY prod_name; 需要把字符|括在一个集合里，否则它将应用于整个串。 字符集合也可以被否定，即它将匹配除指定字符外的任何东西，在集合的开始处放置一个^即可，例如123匹配除1、2或3外的任何东西。 9.2.4 匹配范围 集合可用来定义要匹配的一个或多个字符。例如[0123456789]将匹配数字0到9，可使用-来定义一个范围，简化为[0-9]。[a-z]匹配任意字母字符。 12345# [1-5]表示匹配1到5, 5 ton是一个匹配SELECT prod_nameFROM productsWHERE prod_name REGEXP '[1-5] ton'ORDER BY prod_name; 9.2.5 匹配特殊字符 加前导\\匹配特殊字符.、[]、|、_。\\_表示查找_，\\. 表示查找.。这种处理称为转义。 12345# 使用 \\. 匹配 . SELECT vend_nameFROM vendorsWHERE vend_name REGEXP '\\.'ORDER BY vend_name; \\也用来引用元字符（具有特殊含义的字符）。 表9-1 空白元字符 元字符 说明 \\f 换页 \\n 换行 \\r 回车 \\t 制表 \\v 纵向制表 为了匹配反斜杠（\）字符本身，需要使用 \\\ 多数正则表达式实现使用单个反斜杠转义特殊字符，以便能使用这些字符本身，但MySQL要求两个反斜杠实现转义（MySQL解释一个，正则表达式库解释另一个）。 9.2.6 匹配字符类 存在找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。使用预定义的字符集，称为字符类。表9-2 字符类 类 说明 [:alnum:] 任意字母和数字（同[a-aA-Z0-9]） [:alpha:] 任意字母（同[a-zA-Z]）] [:blank:] 空格和制表（同[\\t]） [:cntrl:] ASCII控制字符（ASCII 0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，但不包含空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 9.2.7 匹配多个实例表9-3 重复元字符 元字符 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1, }） ? 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n, } 不少于指定数目的匹配 {n, m} 匹配数目的范围{m不超过255} 12345# \\(匹配)，[0-9]匹配任意数字，sticks？匹配stick和sticks(s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现)，没有？，匹配stick和sticks会非常困难SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\([0-9]) sticks?\\'ORDER BY prod_name; 以下匹配连在一起的4位数字 12345# [:digit:] 匹配任意数字，&#123;4&#125;要求它前面的字符（任意数字）出现4次SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]]&#123;4&#125;'ORDER BY prod_name; 12345# 与上例等价SELECT prod_nameFROM productsWHERE prod_name REGEXP '[0-9][0-9][0-9][0-9]'ORDER BY prod_name; 9.2.8 定位符 匹配特定位置的文本。 表9-4 定位元字符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 12345# 使用^定位符找出以一个数（包括小数点开始的数）开始的所有产品SELECT prod_nameFROM productsWHERE prod_name REGEXP '^[0-9\\.]'ORDER BY prod_name; ^还可以在集合中[]用来否定该集合。 使REGEXP起类似LIKE的作用，通过用^开始每个表达式，用$结束每个表达式，可以使REGEXP的作用与LIKE一样。 可以在不使用数据库表的情况下用SELECT来测试正则表达式，REGEXP总是返回0（不匹配）或者1（匹配）。如 SELECT &#39;hello&#39; REGEXP &#39;[0-9]&#39;;，返回0。 第10章 创建计算字段10.1 计算字段 存储在数据库表中的数据一般不是应用程序所需要的格式，直接从数据库中检索出转换、计算或格式化过的数据，称为计算字段。 计算字段是运行SELECT语句是创建的。 字段，基本上与列的意思相同，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。 客户机与服务器的格式，可在客户机和服务器上完成转换和格式化工作，但在服务器上比客户机中要快得多。 10.2 拼接字段 拼接，将值联结到一起构成单个值。 在SELECT语句中，用Concat()函数来拼接两个列。 MySQL的不同之处，多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。 1234# 返回vend_name(vend_country)字段SELECT Concat(vend_name, '(', vend_country, ')')FROM vendorsORDER BY vend_name; 删除数据右侧多于的空格整理数据，使用RTrim。 1234# 拼接前使RTrim()函数删除vend_name和vend_country右侧的空格SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')')FROM vendorsORDER BY vend_name; LTrim()，去掉串左边的空格，Trim()，去掉左右两边的空格。 使用别名，SELECT语句拼接地址字段没有名字，需要使用别名（alias）表示一个字段或值，用AS关键字赋予。 1234# 使用AS vend_title指定计算字段的列名SELECT Concat(vend_name, '(', vend_country, ')') AS vend_titleFROM vendorsORDER BY vend_name; 别名的其他用途，在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或容易误解时扩充它。 别名，有称为导出列（derived column）。 10.3 执行算术计算 对检索出的数据进行算术运算。 1234567# 汇总物品的价格（单价乘以订购数量），expanded_price为一个计算字段SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_priceFROM orderitemsWHERE order_num = 2005; MySQL支持的基本算术运算符，圆括号可用来区分优先顺序。 表10-1 MySQL算术操作符 操作符 说明 + 加 - 减 * 乘 / 除 测试计算，可以省略FROM子句以便简单地访问和处理表达式，例如 SELECT 3*2 将返回 6，SELECT Trim(&#39; abc &#39;)将返回abc，SELECT Now()返回当前日期和时间。 第11章 使用数据处理函数11.1 函数 能运行在多个系统上的代码称为可移植的。 函数的可移植性不强。 11.2 使用函数 大多数SQL实现支持以下类型的函数。 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。 用于在数值数据上进行算术操作（如返回绝对值，进行代数计算）的数值函数。 用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等的日期和时间函数。 返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。 11.2.1 文本处理函数 Upper()函数 1234# 返回vend_name和vend_name大写的一个计算字段SELECT vend_name, Upper(vend_name) AS vend_name_upcaseFROM vendorsORDER BY vend_name; 常用文本处理函数。 表11-1 常用的文本处理函数 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 SOUNDEX，将任何文本串转换为描述其语音表示的字母数字模式的算法，其考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。 例如customers表中有一个顾客Coyote Inc.，其联系名为Y. LEE。但如果这是输入错误，实际应为Y. Lie，按正确的联系名搜索将搜索不到。 1234# 返回空，因为没有叫Y. Lie的SELECT cust_name, cust_contactFROM customersWHERE cust_concact = 'Y.Lie'; 1234# 返回Y.LEE，因为Y.LEE和Y.Lie发音相似SELECT cust_name, cust_contactFROM customersWHERE Soundex(cust_concact) = Soundex('Y.Lie'); 11.2.2 日期和时间处理函数 常用的日期和时间处理函数 表11-2 常用日期和时间处理函数 函数 说明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DatOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期的时间部分 Year() 返回一个日期的年份部分 日期格式必须为yyyy-mm-dd。其他格式也可，但这是首选的，因为它排除了多义性。 使用4位数字的年份更可靠。 1234# 返回order_date为'2005-09-01'的订单SELECT cust_id, order_numFROM ordersWHERE order_date = '2005-09-01'; 存储order_date值为 2005-09-01 11:30:05时，则 WHERE order_date = &#39;2005-09-01&#39;匹配失败。 解决方法是仅将给出的日期和列中的日期部分进行比较，而不是将给出的日期和整个列值进行比较。使用Date(order_date)指示仅提取列的日期部分。 1234# 更可靠的SELECT语句SELECT cust_id, order_numFROM ordersWHERE Date(order_date) = '2005-09-01'; 如果要的是日期，使用Date()。想要的是时间，使用Time()。 检索2005年9月下的所有订单。 123456SELECT cust_id, order_numFROM ordersWHERE Date(order_date) BETWEEN '2005-09-01' AND '2005-09-30';# 更好的方法WHERE Year(order_date) = 2005 AND Month(order_date) = 9; 11.2.3 数值处理函数 常用数值处理函数 表11-3 常用数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 第12章 汇总数据12.1 聚集函数 聚集函数，运行在行组上，计算和返回单个值的函数。 表12-1 SQL聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 12.1.1 AVG()函数 可以返回所有列的平均值，也可以返回特定列或行的平均值 123# 返回products表中所有产品的平均价格SELECT AVG(prod_price) AS avg_priceFROM products; 1234# 返回特定供应商的产品平均价格SELECT AVG(prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; AVG只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出，为了获得多个列的平均值，必须使用多个AVG()函数。 AVG函数忽略列值为NULL的行。 12.1.2 COUNT()函数 确定表中行的数目或符合特定条件的行的数目。 两种使用方式： COUNT(*)，对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。 COUNT(column)，对特定列中具有值的行进行计数，忽略NULL值。 123# 对所有行计数SELECT COUNT(*) AS num_custFROM customers; 123# 对只具有电子邮件地址的客户计数SELECT COUNT(cust_email) AS num_custFROM customers; 如果指定列名，则指定列的空值（NULL）被忽略，但如果用的是星号（不指定列名），则不忽略。 12.1.3 MAX()函数 返回列中的最大值 123# 返回products中的最大的价格SELECT MAX(prod_price) AS max_priceFROM products; 对非数值数据使用MAX()函数，允许返回任意列中的最大值，包括文本列。 MAX()函数忽略值为NULL的行。 12.1.4 MIN()函数 返回列中的最小值。 123# 返回products中的最小的价格SELECT MIN(prod_price) AS min_priceFROM products; 对非数值数据使用MIN()函数，允许返回任意列中的最小值，包括文本列。 MIN()函数忽略值为NULL的行。 12.1.5 SUM()函数 返回指定列值的和。 1234# 返回orderitems表包含订单中实际的物品SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num = 20005; SUM()函数也可以合并计算值。 1234# 返回orderitems表中所有物品价格之和SELECT SUM(item_price*quantity) AS total_priceFROM orderitemsWHERE order_num = 20005; 可以执行多个列上的计算。 SUM()函数忽略列值为NULL的行。 12.2 聚焦不同值 以下内容仅在MySQL 5及后期版本可用。 以上5个聚集函数都可以如下使用： 对所有行执行计算，指定ALL参数或不给参数（因为ALL是默认的）。 只包含不同的值，指定DISTINCT参数。 1234# 返回特定供应商的 不同价格 的平均值SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id = 1003; DISTINCT必须指定列名，COUNT(DISTINCT)会报错，还不能用于计算或表达式。 DISTINCT用于MIN()和MAX()，可行但没有价值。用不用结果一样。 12.3 组合函数123456# 执行了4个聚集计算SELECT COUNT(*) AS num_items, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max, AVG(prod_price) AS price_avgFROM products; 第13章 分组数据13.1 数据分组 分组，把数据分为多个逻辑组，以便对每个组进行聚集计算。 13.2 创建分组 分组时在SELECT语句的 GROUP BY子句中建立的。 1234# 使用GROUP BY 对每个供应商计算产品数量SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; GROUP BY 可以包含任意数目的列，这使得能对分组进行嵌套。 如果使用了嵌套，数据将在最后规定的分组上进行汇总， 即所有列都一起计算。 GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式，如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式，不能使用别名。 除聚集语句外，SELECT语句中的每个列都必须在GROUP BY 子句中给出。 若分组列中药NULL值，NULL值作为一个分组。 GROUP BY在WHERE子句之后，在ORDER BY 子句之前。 使用WITH ROOLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。 123SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id WITH ROOLUP; 13.3 过滤分组 WHERE过滤的是行而不是分组。 使用HAVING过滤分组，WHERE子句可以用HAVING子句替代。 12345# 找出两个以上的订单的分组，使用WHERE不起作用SELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤，WHERE排除的行不包括在分组中。 123456# 列出具有2个及以上、价格为10及以上的产品的供应商SELECT vend_id, COUNT(*) AS num_prodsFROM productsWHERE prod_price &gt;= 10GROUP BY vend_idHAVING COUNT(*) &gt;= 2; 13.4 分组和排序 ORDER BY 与GROUP BY的差别 表13-1 ORDER BY 与GROUP BY ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 一般在使用GROUP BY子句时，应该也给出ORDER BY 子句，这是保证数据正确排序的唯一方法。 123456# 列出总计订单价格大于等于50的订单号和总订单价格SELECT order_num, SUM(quantity*item_price) AS ordertotalFROM orderitemsGROUP BY order_numHAVING SUM(quantity*item_price) &gt;= 50ORDER BY ordertotal; 13.5 SELECT子句顺序表13-2 SELECT子句及其顺序 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 第14章 使用子查询14.1 子查询 版本要求，MySQL4.1及以上版本。 查询，任何SQL语句都是查询，但此术语一般指SELECT语句。 子查询，嵌套在其他查询中的查询。 14.2 利用子查询进行过滤 把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。 1234567891011SELECT cust_name, cust_contactFROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2')); # 以上语句首先执行了SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'; 在orderitems表里查询prod_id为TNT2的订单号，然后这些订单号以IN操作符传递给外部的WHERE子句。# 然后在orders表里查询具有这些订单号的客户ID，并将客户ID以IN操作符传递给最外层的WHERE子句。# 最后在customers表中查询这些客户ID的信息。 在SELECT语句中，子查询总是从内向外处理。 对于能嵌套的子查询的数目没有限制，但太多嵌套会影响性能。 列必须匹配，SELECT语句应该具有与WHERE子句中相同数目的列。 子查询可以与IN，=，&lt;&gt;等操作符结合使用。 14.3 作为计算字段使用子查询 使用子查询的另一方法是创建计算字段。 123456789# 从customers表中检索客户列表# 对于检索出的每个客户，统计其在orders表中的订单数目SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders)FROM customersORDER BY cust_name; 子查询中的WHERE语句需要使用完全限定列名。orders.cust_id = customers.cust_id。这种类型的子查询称为相关子查询，即涉及外部查询的子查询，必须使用这种语法。否则可能出错。 第15章 联结表15.1 联结 SQL最强大的功能之一，在数据检索查询的执行中联结表。 15.1.1 关系表 关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（关系）互相关联。 外键，某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系。 好处： 信息不重复，不浪费时间和空间。 信息变动，只更新对应表的单个记录，相关表中的数据不用改动。 数据无重复，处理更简单。 有效地存储和方便地处理。 关系数据库的可伸缩性远比非关系数据库要好。 可伸缩性，能够适应不断增加的工作量而不失败。 15.1.2 为什么要使用联结 联结，用来在一条SELECT语句中关联表。 维护引用完整性，仅在关系列中插入合法的数据。 15.2 创建联结123456# prod_name, prod_price在products中，而vend_name在vendors中# 使用WHERE正确联结，需完全限定列名SELECT vend_name, prod_name, prod_priceFROM vendor, productsWHERE vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; 在引用的列可能出现二义性时，必须使用完全限定列名。 15.2.1 WHERE子句的重要性 WHERE作为过滤条件，只包含那些匹配给定条件（联结条件）的行。 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 笛卡尔积，由没有联结条件的表关系返回的结果为笛卡尔积，检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。又称叉联结。 应该保证所有联结都有WHERE子句，否则将返回比想要的数据多得多的数据 15.2.2 内部联结 基于两个表之间的相等测试，称为等值联结，也称为内部联结。 使用不同语法来明确联结的类型。 12345# 与前面例子完全相同SELECT vend_name, prod_name, prod_priceFROM vendor INNER JOIN productsON vendors.vend_id = products.vend_idORDER BY vend_name, prod_name; ANSI SQL规范首选INNER JOIN 语法。 15.2.3 联结多个表 SQL对一条SELECT语句中可以联结的表的数目没有限制。首先列出所有表，然后定义表之间的关系。 123456# 显示订单编号为20005的订单中的物品SELECT vend_name, prod_name, prod_price, quantityFROM orderitems, products, vendorWHERE products.vend_id = vendors.vend_id AND orderitems.prod_id = products.prod_id AND order_num = 20005; 性能考虑，联结的表越多，性能下降越厉害。 联结表可以替代子查询。 12345678910111213SELECT cust_name, cust_contactFROM customersWHERE cust_id IN(SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'));# 等价于SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num AND prod_id = 'TNT2'; 第16章 创建高级联结16.1 创建高级联结 给列起别名的语法如下。 123SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS vend_titleFROM vendorsORDER BY vend_name; 给表名起别名，可以缩短SQL语句，并允许在单条SELECT语句中多次使用相同的表。 12345SELECT cust_name, cust_contactFROM customers AS c, orders AS o, orderitems AS oiwhere c.cust_id = o.cust_id AND io.order_num = o.order_nu AND prod_id = 'TNT2'; 表别名只在查询执行中使用，与列别名不一样，表别名不返回到客户机。 16.2 使用不同类型的联结 前文都是内部联结，下面介绍自联结、自然联结和外部联结。 16.2.1 自联结123456789101112131415# 查询生产ID为DTNTR的供应商的其他物品# 使用子查询SELECT prod_id, prod_nameFROM productsWHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = 'DTNTR');# 使用自联结# 使用两次products表，但用不同的别名SELECT p1.prod_id, p1.prod_nameFROM products AS p1, products AS p2WHERE p1.vend_id = p2.vend_id AND p2.prod_id = 'DTNTR'; 用自联结而不用子查询，虽然结果相同，但自联结速度更快。 16.2.2 自然联结 自然联结排除列多次出现，使每个列只返回一次。 1234567# 通配符只对第一个表使用，所有其他列明确列出，所有没有重复的列被检索出来SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_priceFROM customers AS c, orders AS o, orderitems AS oiWHERE c.cust_id = o.cust_id AND oi.order_num = o.order_num AND prod_id = 'FB'; 到目前为止 每个内部联结都是自然联结，一般不会用到不是自然联结的内部联结。 16.2.3 外部联结 外部联结，联结包含了在相关表中没有关联行的行。 1234# 内部联结 检索所有客户及其订单SELECT customers.cust_id, orders.order_numFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_id; 1234# 外部联结 检索所有客户，包括没有订单的客户SELECT customers.cust_id, orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; 在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表，RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表。上例使用LEFT OUTER JOIN从FROM 子句的左边表(customers表)中选择所有行。 不支持*=和=*的使用。 16.3 使用带聚集函数的联结1234567# 检索所有客户及每个客户所下的订单数SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers INNER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 1234567# 使用左外部联结来包含所有客户，包括没有任何下订单的客户SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 16.4 使用联结和联结条件 注意所使用的联结条件，一般使用内部联结。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡尔积。 使用多个联结时，分别测试每个联结，这将使故障排除更为简单。 第17章 组合查询17.1 组合查询 组合查询，执行多条SELECT语句，并将结果作为单个查询结果集返回，这些组合查询又称并或复合查询。 两种情况需要组合查询： 在单个查询中从不同的表返回类似结构的数据。 对单个表执行多个查询，按单个查询返回数据。 组合查询与具有多个WHERE子句条件的单条查询相同。 17.2 创建组合查询 用UNION操作符来组合数条SQL查询。 17.2.1 使用UNION 给出每条SELECT语句，在各条语句之前放上关键字UNION。 1234567891011121314# 使用UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_in IN (1001, 1002);# 使用多条WHERESELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5 OR vend_in IN (1001, 1002); 17.2.2 UNION规则 UNION必须由两条或两条以上的SELECT语句组成，语句之间用UNION分隔。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（列出次序可以不同） 列数据类型必须兼容，类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 17.2.3 包含或取消重复的行 UNION从查询结果集中自动去除了重复的行。可以使用UNION ALL不去除重复的行。 17.2.4 对组合结果排序 在使用UNION组合查询时，只能使用一条ORDER BY子句，必须出现在最后一条SELECT语句之后。 123456789# 使用UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id, prod_id, prod_priceFROM productsWHERE vend_in IN (1001, 1002)ORDER BY vend_id, prod_price; 第18章 全文本搜索18.1 理解全文本搜索 两个最常用的引擎MyISAM和InnoDB，前者支持全文本搜索，而后者不支持。 如果需要全文本搜索功能，在创建表时选择MyISAM引擎。 通配符和正则表达式存在几个重要的限制： 性能，通配符和正则表达式通常要求尝试匹配表中所有行，行增加时非常耗时。 明确控制，很难明确控制匹配什么和不匹配什么。 智能化的结果。 18.2 使用全文本搜索 为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。 在索引之后，SELECT可与Match()和Against()一起使用以执行搜索。 18.2.1 启用全文本搜索支持 在创建表时启用全文本搜索，CRTATE TABLE语句（第21章介绍）接收FULLTEXT子句。 123456789CRTATE TABLE productnotes( note_id int NOT NULL AUTO_INCREMENT, prod_id char(10) NOT NULL, note_date datetime NOT NULL, note_text text NULL, PROMARY KEY(note_id), FULLTEXT(note_text)) ENGINE = MyISAM; MySQL根据子句FULLTEXT(note_text)的指示对note_text进行索引。FULLTEXT可以索引单个或者多个列。MySQL自动维护该索引，在增加、更新或删除行时，索引随之自动更新。 可以在创建表时指定FULLTEXT，或者在稍后指定（在这种情况下所有已有数据必须立刻索引）。 不要在导入数据时使用FULLTEXT，更新索引比较耗时。 18.2.2 进行全文本搜索 使用函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。 1234# 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit'); 传递给Match()的值必须与FULLTEXT()定义中的相同，如果指定多个列，则必须列出它们（而且次序正确）。 搜索默认不区分大小写，除非使用BINARY关键字。 1234# 也使用LIKE 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE note_text LIKE '%rabbit%'; LIKE以不那么有用的顺序返回数据，使用全文本搜索以文本匹配的良好程度排序返回数据。全文本搜索的一个重要部分就是对结果排序，具有较高等级的行先返回。 1234# 全文本搜索排序过程，不包含rabbit的行等级为0，包含rabbit的行中词靠前的行等级高SELECT note_text Match(note_text) Against('rabbit') AS rankFROM products; 18.2.3 使用查询扩展 查询扩展用来设法放宽所返回的全文本搜索结果的范围。 使用查询扩展时，MySQL对数据和索引进行两遍扫描来完成搜索： 首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行。 其次，MySQL检查这些匹配行并选择所有有用的词（如何判定什么有用，什么无用）。 再其次，MySQL再次进行全文本搜索，这次不仅使用原来的条件，而且还使用所有有用的词。 利用扩展查询，能找出可能相关的结果，即使它们并不精确包含所查找的词。 查询扩展功能只用于版本4.1.1或更高版本。 1234# 搜索note_text中含rabbit的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION); 表中的行越多，使用查询扩展返回的结果越好。 18.2.4 布尔文本搜索 MySQL支持全文本搜索的另一种形式，称为布尔方式。 以布尔方式，可以提供如下内容的细节： 要匹配的词； 要排斥的词； 排列提示； 表达式分组； 另外一些内容。 即使没有FULLTEXT索引也可以使用，但性能比较差。 1234# 匹配词heavy，但排除包含任何以rope开始的词的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE); 表18-1 全文本布尔操作符 布尔操作符 说明 + 包含，词必须存在 - 排除，词必须不出现 &gt; 包含，而且增加等级值 &lt; 包含，而且减少等级值 () 把词组成表达式（允许这些子表达式作为一个组被包含、排除、排列等） ~ 取消一个词的排序词 * 词尾的通配符 “ ” 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） 1234# 匹配包含词rabbit和bait的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('+rabbit +bait' IN BOOLEAN MODE); 1234# 没有指定操作符，匹配包含rabbit和bait中的至少一个词的行SELECT note_textFROM productnotesWHERE Match(note_text) Against('rabbit bait' IN BOOLEAN MODE); 1234# 匹配rabbit和carrot，增加前者的等级，降低后者的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('&gt;rabbit &lt;carrot' IN BOOLEAN MODE); 1234# 匹配safe和combination，降低后者的等级SELECT note_textFROM productnotesWHERE Match(note_text) Against('+safe +(&lt;combination)' IN BOOLEAN MODE); 18.2.5 全文本搜索的使用说明 在索引全文本数据时，短语被忽略且从索引中排除，短语定义为具有3个及3个以下字符的词（如果需要，这个数目可以更改）。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略，如果需要，可以覆盖这个列表。 许多词出现的频率很高，搜索它们没有用处（返回太多结果），因此，如果一个词出现在50%的行中，则将它作为一个非用词忽略。%50规则不用于 IN BOOLEAN MODE。 如果表中的行数少于3，则全文本搜索不返回结果。 忽略词中的单引号。例如don’t索引为dont 不具有词分隔符的语言不能恰当地返回全文本搜索结果。 仅在MyISAM引擎中支持全文本搜索。 没有邻近操作符。 第19章 插入数据19.1 数据插入 INSERT语句。 插入完整的行。 插入行的一部分。 插入多行。 插入某些查询的结果。 19.2 插入完整的行 指定表名和被插入到新行中的值。 存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。 各个列必须以它们在表定义中出现的次序填充。 1234567891011# 插入一个新客户到customers表INSERT INTO CustomersVALUES(NULL, 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL); 简单但不安全，尽量避免使用，高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息，结构变动后各个列可能不能保持相同的次序。 更安全的方法（不过更繁琐），在表名后的括号里明确给出列名。 1234567891011121314151617# 插入一个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL); 提供了列名，VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序，即使表的结构改变，仍能正确工作。 总是使用列的列表。 仔细地给出正确数目的VALUES值。 使用给出列名的这种语法，还可以省略列，可以只给某些列提供值。 该列定义为允许NULL值 在表定义中给出默认值，这表示如果不给出值，将使用默认值 如果对表中不允许NULL值且没有默认值的列不给出值，将会报错 提高整体性能，INSERT操作比较耗时，可以在INSERT和INTO之间添加关键字LOW_PRIORITY，指示降低INSERT的优先级。 19.3 插入多个行 使用多条INSERT语句，一次提交它们，每条语句用一个分号结束。 123456789101112131415161718192021222324252627282930313233# 插入多个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL);INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL); 或者，只要每条INSERT语句中的列名和次序相同，可以如下组合各语句。 12345678910111213141516171819202122232425# 插入多个新客户到customers表INSERT INTO Customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES( 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL)，VALUES( 'Pep E. LaPew', '100 Main Street', 'Los Angeles', 'CA', '90046', 'USA', NULL, NULL); 其中单条INSERT语句有多个值，每组值用一对圆括号括起来，用逗号分隔。此技术可以提高数据库处理的性能，因为用单条INSERT语句处理多个插入比使用多条INSERT语句块。 19.4 插入检索出的数据 利用INSERT语句将一条SELEECT语句的结果插入表中，这就是所谓的INSERT SELECT，即由一条INSERT语句和一条SELECT语句组成。 123456789101112131415161718192021# 从custnew表将所有数据导入到customers表中# 为避免重复，可以将INSERT和SELECT中的cust_id列忽略INSERT INTO customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM custnew; INSERT SELECT中的列名，不一定要求列名匹配，使用的是列的位置，SELECT中的第一列（不管其列名）将会用来填充INSERT表列中指定的第一个列。这对于使用不同列名的表中导入数据非常有用。 INSERT SELECT语句可包含WHERE子句过滤插入的数据。 第20章 更新和删除数据20.1 更新数据 UPDATE语句更新（修改）表中的数据。 更新表中特定行，使用WHERE子句 更新表中所有行 UPDATE语句的组成。 要更新的表 列名和它们的新值 确定要更新行的过滤条件 1234# 更新单个列UPDATE customersSET cust_email = 'elmer@fudd.com'WHERE cust_id = 10005; UPDATE后更要更新的表名。SET用来指定新值被赋予的列。WHERE指定特定的行，没有WHERE子句，将会更新所有行。 在更新多个列时，只需要使用单个SET命令，每个 “列=值”对之间用逗号分隔。 12345# 更新两个列UPDATE customersSET cust_email = 'elmer@fudd.com', cust_name = 'The Fudds'WHERE cust_id = 10005; UPDATE语句可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。 IGNORE关键字，即使发生错误，也继续进行更新，UPDATE IGNORE customers..。 为删除某个列的值，可设置它为NULL值（假如表定义允许NULL值）。 123UPDATE customersSET cust_email = NULLWHERE cust_id = 10005; 20.2 删除数据 DELETE语句删除（去掉）数据。 从表中删除特定的行，使用WHERE子句 从表中删除所有行 123# 删除一行DELETE FROM customersWHERE cust_id = 10006; DELETE不需要列名和通配符。 DELET 删除整行而不是删除列，为了删除指定的列，使用UPDATE语句。 DELETE从表中删除行，不删除表本身。 如果想要删除表中所有的行，不要使用DELETE，可使用TRUNCATE TABLE语句，它完成同样的工作，但速度更快。 20.3 更新和删除的指导原则 除非打算更新和删除所有行，否则不要使用不带WHERE子句的UPDATE或DELETE语句。 保证每个表都有主键，尽可能像WHERE子句那样使用它。 在对UPDATE或DELETE语句使用WHERE子句前，应先使用SELECT进行测试，保证正确过滤。 使用强制引用完整性的数据库。 没有撤销功能。 第21章 创建和操纵表21.1 创建表 创建表的方法。 使用具有交互式管理和创建表的工具 使用MySQL语句操纵，使用CREATE TABLE语句 21.1.1 表创建基础 创建表，必须给出以下信息。 新表的名字，在关键字CREATE TABLE之后给出 表列的名字和定义，用逗号分隔 1234567891011121314# 创建customers表CREATE TABLE customers(cust_id int NOT NULL AUTO_INCREMENT,cust_name char(50) NOT NULL,cust_address char(50) NULL,cust_city char(50) NULL,cust_state char(5) NULL,cust_zip char(10) NULL,cust_conutry char(50) NULL,cust_contact char(50) NULL,cust_email char(255) NULL,PRIMARY KEY (cust_id)) ENGINE = InnoDB; SQL对缩进空格等格式化没有规定，推荐采用某种缩进格式。 创建表时，指定的表名必须不存在，否则出错。如果表存在，一般首先手工删除表，然后在重建它。如果想仅在表不存在时创建，表名后使用IF NOT EXISTS。 21.1.2 使用NULL值 允许NULL值的列允许在插入行时不给出该列的值，不允许NULL值的列在插入或更新行时，该列必须有值。 创建表时，NULL为默认设置，如果不指定NOT NULL，则认为指定的是NULL。 NULL值是没有值，而不是空串&#39;&#39;，空串是一个有效的值。 21.1.3 主键再介绍 主键值必须唯一，如果使用单个列，则它的值必须唯一，如果使用多个列，则这些列的组合值必须唯一。 多个列组成的主键，以逗号分隔的列表给出各列名。 12345678910# 多个列组成的主键CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULL,prod_id char(10) NOT NULL,quantity int NOT NULL,item_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num, order_item)) ENGINE = InnoDB 主键可以在创建表时定义，也可以在创建表之后定义。 主键中不允许NULL值的列，允许NULL值的列不能作为唯一标识。 21.1.4 使用AUTO_INCREMENT 设置AUTO_INCREMENT 的列，每当增加一行时自动增量。 每个表只允许一个AUTO_INCREMENT 列，而且它必须被索引，可以通过使它成为主键值。 AUTO_INCREMENT 的列可以在插入时指定一个值，只要它是唯一（至今尚未使用过）即可，该值将被用来替代自动生成的值，后续的增量将开始使用该手工插入的值。 确定AUTO_INCREMENT的值，使用SELECT last_insert_id()返回最后一个AUTO_INCREMENT值，然后可以将该值用于其他MySQL语句。 21.1.5 指定默认值 默认值用CREATE TABLE语句的列定义中的DEFALUT关键字指定。 12345678910# 指定quantity的默认值为1CREATE TABLE orderitems(order_num int NOT NULL,order_item int NOT NULL,prod_id char(10) NOT NULL,quantity int NOT NULL DEFAULT 1,item_price decimal(8,2) NOT NULL,PRIMARY KEY (order_num, order_item)) ENGINE = InnoDB; 不允许使用函数作为默认值，它只支持常量。 使用默认值而不是NULL值。 21.1.6 引擎类型 如果省略ENGINE=语句，则使用默认引擎（很可能是MyISAM）。 InnoDB是一个可靠的事物处理引擎，不支持全文本搜索。 MEMORY在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（适合于临时表）。 MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事物管理。 引擎类型可以混用。 外键不跨引擎。 MyISAM最受欢迎。 21.2 更新表 使用ALTER TABLE更新表定义，但是，理想状态下，当表中存储数据以后，该表就不应该别更新。 使用ALTER TABLE更改表结构，需给出以下信息。 在ALTER TABLE之后给出要更改的表名（该表必须存在）。 所做更改的列表。 123# 给表添加一个名为vend_phone的列，必须明确数据类型ALTER TABLE vendorsADD vend_phone CHAR(20); 123# 删除列ALTER TABLE vendorsDROP COLUMN vend_phone; 使用ALTER TABLE 定义外键。 1234567ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_ordersFOREIGN KEY (order_num) REFERENCES orders (order_num);ALTER TABLE orderitemsADD CONSTRAINT fk_orderitems_productsFOREIGN KEY (prod_id) REFERENCES products (prod_id); 复杂的表结构更改需要手动删除过程，步骤： 用新的列布局创建一个新表； 使用INSERT SELECT语句从旧表复制数据到新表，如果有必要，可使用转换函数和计算字段； 检验包含所需数据的新表； 重命名旧表（如果确定，可以删除它）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。 使用ALTER TABLE前应该做一个完整的备份，因为数据表的更改不能撤销。 21.3 删除表 使用DROP TABLE 语句。DROP TABLE customers2，删除表没有确认，也不能撤销。 21.4 重命名表 使用RENAME TABLE语句。 1234567# 重命名一个表RENAME TABLE customers2 TO customers;# 重命名多个表，使用逗号分隔RENAME TABLE backup_customers TO customers, backup_vendors TO vendors, backup_produts TO products; 第22章 使用视图22.1 视图 版本要求，MySQL5及之后版本添加了对视图的支持。 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 1234567891011SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num AND prod_id = 'TNT2'; # 假如可以把以上整个查询包装成一个productcustomers的虚拟表，则可以从虚拟表中检索数据# productcustomers是一个视图SELECT cust_name, cust_contactFROM productcustomersWHERE prod_id = 'TNT2'; 22.1.1 为什么使用视图 重用SQL语句。 简化复杂的SQL操作。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用于表基本相同的方式利用他们，可以执行SELECT，过滤和排序，联结，甚至是添加和更新数据的操作。 性能问题。视图不包含数据，每次使用视图时，都必须处理查询执行时所需的任一个查询，如果使用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。 22.1.2 视图的规则和限制 与表一样，视图必须唯一命名。 对于可创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常有数据库管理人员授予。 视图可以嵌套。 ORDER BY 可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY 将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。 22.2 使用视图 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname，来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname。 更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图，如果要更新的视图存在，则第2条语句会替换原有视图。 22.2.1 利用视图简化复杂的联结 视图最常用的应用之一是隐藏复杂的SQL。 12345678910111213# 创建名为productcustomers的视图，联结三个表，以返回以订购了任意产品的所有客户的列表CREATE VIEW productcustomers ASSELECT cust_name, cust_contact, prod_idFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num; # 如果执行 SELECT * FROM productcustomers，将列出订购了任意产品的客户# 检索订购了产品TNT2的客户SELECT cust_name, cust_contactFROM productcustomersWHERE prod_id = 'TNT2'; 创建可重用的视图是一种好方法。 22.2.2 用视图重新格式化检索出的数据 视图的另一常见用途是重新格式化检索出的数据。 12345# 返回供应商名和位置（来自第10章）SELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS vend_titleFROM vendorsORDER BY vend_name; 假如要经常使用这个格式的结果，不必在每次需要时执行联结，创建一个视图，每次需要时使用它即可。 12345678910# 创建视图 返回供应商名和位置CREATE VIEW vendorlocations ASSELECT Concat(RTrim(vend_name), '(', RTrim(vend_country), ')') AS vend_titleFROM vendorsORDER BY vend_name;# 检索所有供应商和位置的数据SELECT * FROM vendorlocations; 22.2.3 用视图过滤不想要的数据 视图也可以使用WHERE子句过滤数据。 123456789# 创建视图，排除没有电子邮件地址的用户CREATE VIEW customeremaillist ASSELECT cust_id, cust_name, cust_emailFROM customersWHERE cust_email is NOT NULL;# 检索SELECT * FROM customeremaillist 如果从视图检索数据时使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。 22.2.4 使用视图与计算字段 视图对于简化计算字段的使用特别有用。 1234567891011121314151617181920# 检索某个特定订单中的物品，计算每种物品的总价格（来自第10章）SELECT prod_id, quantity, item_price, quantity*item_price AS expand_priceFROM orderitemsWHERE order_num = 20005;# 将其转化为一个视图CREATE VIEW orderitemsexpanded AS SELECT prod_id, quantity, item_price, quantity*item_price AS expand_priceFROM orderitems;# 检索订单20005的详细内容SELECT *FROM orderitemsexpandedWHERE order_num = 20005; 22.2.5 更新视图 视图的数据是否可以更新是视情况而定。 通常，视图是可以更新的，更新一个视图将更新其基表（视图本身没有数据）。 但是，并非所有视图都是可更新的，如果不能正确地确定被更新的基数据，则不允许更新。 如果视图定义中有以下操作，将不能更新： 分组（GROUP BY 和HAVING） 联结 子查询 并 聚集函数（MIN()、COUNT()、SUM() 等） DISTINCT 导出（计算）列 视图主要用于数据检索（SELECT），很少用于更新（INSERT、UPDATE和DELETE）。 第23章 使用存储过程23.1 存储过程 MySQL添加了对存储过程的支持，支持MySQL5及以后的版本。 存储过程，就是为以后的使用而保存的一条或多条MySQL语句的集合，可将其视为批文件。 23.2 为什么要使用存储过程 存储过程的好处： 通过把处理封装在容易使用的单元中，简化复杂的操作。 由于不要求反复建立一系列处理步骤，保证了数据的完整性，所有开发人员和应用程序都使用同一的存储过程，则所使用的代码都是相同的。 防止错误，需要执行的步骤越多，出错的可能性就越大。 简化对变动的管理，如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码。通过对存储过程限制对基础数据的访问保证了安全性。 提高性能，使用存储过程比适用单独的SQL语句要快。 总结：简单，安全，高性能。 存储过程的缺陷： 编写比基本的SQL语句复杂。 MySQL将编写和执行存储过程的安全和访问区分开来，你可能没有创建存储过程的安全访问权限。 不能编写存储过程，但仍然可以使用。 23.3 使用存储过程23.3.1 执行存储过程 调用，CALL，接受存储过程的名字以及需要传递给它的任意参数。 1234# 执行名为productpricing的存储过程，返回产品的最低、最高和平均价格CALL productpricing(@pricelow, @pricehigh, @priceaverage); 存储过程可以显示结果，也可以不显示结果。 23.3.2 创建存储过程123456# 返回平均价格的存储过程，名为productpricing，没有参数CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END; 因为存储过程的语句结束分隔符也为;，需要临时更改语句结束分隔符。除 \ 符号外，任何字符都可以作为语句分隔符。 1234567891011# 告诉命令行使用 // 作为新的语句结束分隔符DELIMITER //# 返回平均价格的存储过程，名为productpricing，没有参数CREATE PROCEDURE productpricing()BEGIN SELECT Avg(prod_price) AS priceaverage FROM products;END//# 恢复为原来的语句结束分隔符DELIMITER ; 12# 调用存储过程CALL productpricing(); 23.3.3 删除存储过程 存储过程创建后，被保存在服务器上以供使用，直至被删除。 删除存储过程，DROP PROCEDURE productpricing;。存储过程名后不带()，只给出存储过程名。 仅当存在时删除，DROP PROCEDURE IF EXISTS productpricing。 23.3.4 使用参数 一般地，存储过程并不显示结果，而是把结果返回给你指定的变量。 变量，内存中一个特定的位置，用来临时存储数据。 123456789101112131415161718# 以下是productpricing的修改版本，如果不事先删除此存储过程，则不能再次创建它# 此存储过程接受三个参数，pl存储最低价格，ph存储最高价格，pa存储最高价格CREATE PROCEDURE productpricing(OUT pl DECIMAL(8,2),OUT ph DECIMAL(8,2),OUT pa DECIMAL(8,2))BEGIN SELECT Min(prod_price) INTO pl FROM products; SELECT Max(prod_price) INTO ph FROM products; SELECT Avg(prod_price) INTO pa FROM products;END; 每个参数必须具有指定的类型，关键字OUT指出相应的参数用来从存储过程传出一个值，返回给调用者。 IN（传递给存储过程），OUT（从存储过程传出），INTO（对存储过程传入和传出）。 记录集是不允许的类型，不能通过一个参数返回多个行和列。 12345678# 调用此修改过的存储过程，需指定三个变量名CALL productpricing(@pricelow, @pricehigh, @priceavgerage);# 调用时不现实任何数据，返回可以显示的变量，显示产品的平均价格SELECT @priceaverage;# 显示三个值SELECT @pricehigh, @pricelow, @priceaverage; MySQL的所有变量都必须以@开始。 使用IN和OUT参数 1234567891011121314151617181920# 使用IN和OUT参数，ordertotal接受订单号并返回该订单的合计# onumber定义为IN，订单号被传入存储过程# ototal定义为OUT，从存储过程返回合计CREATE PROCEDURE ordertotal( IN onumber INT OUT ototal DECIMAL(8,2))BEGIN SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO ototal;END;# 调用这个存储过程# 第一个参数为输入订单号，第二个参数为返回计算出来的合计的变量名CALL ordertotal(20005, @total);# 显示此合计SELECT @total 23.3.5 建立智能存储过程 包含业务规则和智能处理的存储过程。 12345678910111213141516171819202122232425262728293031323334353637# name: ordertotal# parameters: onumber = order number# taxable = 0 if not taxable, 1 if taxable# ototal = order total variableCREATE PROCEDURE ordertotal( IN onumber INT, IN taxable BOOLEAN, OUT ototal DECIMAL(8,2))COMMENT 'Obtain order total, optionally adding tax' # COMMENT不是必须的，如果给出，将在SHOW PROCEDURE STATUS的结果中显示BEGIN # Declare variable for total DECLARE total DECIMAL(8,2); # Declare tax percentage DECLARE taxrate INT DEFAULT 6; # Get the order total SELECT Sum(item_price*quantity) FROM orderitems WHERE order_num = onumber INTO total; # Is this taxable IF taxable THEN # Yes, so add taxrate to the total SELECT total+(total/100*rate) INTO total END IF; # And finaly, save to out variable SELECT total INTO ototal;END;# 调用，通过给中间的参数指定0或1，可以有条件地将营业税加到合计上CALL ordertotal(2005, 0, @total);SELECT @total;CALL ordertotal(2005, 1, @total);SELECT @total; 23.3.6 检查存储过程 显示用来创建一个存储过程，的CREATE语句。SHOW CREATE PROCEDURE ordertotal。 获得包括何时、由谁创建等详细信息的所有存储过程列表，使用SHOW PROCEDURE STATUS。 使用LIKE指定一个过滤模式，列出指定的存储过程，使用SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;。 第24章 使用游标24.1 存储过程 版本MySQL5及之后的版本支持。 使用游标的原因，需要在检索出来的行中前进或后退一行或多行。 游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或作出更改。 MySQL的游标只能用于存储过程（和函数）。 24.2 使用游标 使用前需要声明（定义）游标。 声明后，需要打开游标以供使用。 对于填有数据的游标，根据需要取出（检索）各行。 在结束游标使用时，必须关闭游标。 24.2.1 创建游标 游标用DECLARE语句创建，并定义响应的SELECT语句，根据需要带WHERE和其他子句。 1234567# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders;END; 存储过程处理完成后，游标就消息（因为它局限于存储过程），在定义游标之后，可以打开它。 24.2.2 打开和关闭游标 使用OPEN CURSOR语句打开游标。如OPEN ordernumbers。在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。 关闭游标，CLOSE ordernumbers。CLOSE释放游标使用的所有内部内存和资源，游标不需要时应该关闭。 隐含关闭，如果不明确关闭游标，将会在到达END语句时自动关闭。 1234567891011121314# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 关闭游标 CLOSE ordernumbers;END; 24.2.3 使用游标数据 使用FETCH语句分别访问它的每一行，FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行。 从游标中检索单个行。 1234567891011121314151617# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 检索当前行的order_num列（自动从第一行开始）到一个名为o的局部声明的变量中。 FETCH ordernumbers INTO o # 关闭游标 CLOSE ordernumbers;END; 循环检索数据，从第一行到最后一行。 12345678910111213141516171819# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 打开游标 OPEN ordernumbers; # 循环检索 REPEAT FETCH ordernumbers INTO o; UNTIL done END REPEAT; # 关闭游标 CLOSE ordernumbers;END; 需设置变量done为真的停止条件。 123# 定义了CONTINUE HANDLER，指出当SQLSTATE '02000'出现时，SET done 1,# SQLSTATE '02000'是一个未找到条件DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。 更详细的游标存储过程样例。 123456789101112131415161718192021222324252627282930313233343536373839# 创建名为ordernumbers的游标，使用了可以检索所有订单的SELECT语句CREATE PROCEDURE processorders()BEGIN # 定义局部变量 DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE t DECIMAL(8,2); # 声明游标 DECLARE ordernumbers CURSOR FOR SELECT order_num FROM orders; # 定义句柄 DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1; # 创建一个表保存结果 CREATE TABLE IF NOT EXISTS ordertotals( order_num INT, total DECIMAL(8,2)); # 打开游标 OPEN ordernumbers; # 循环检索 REPEAT # 获取订单号 FETCH ordernumbers INTO o; # 获取该订单号的带税的合计，该存储过程在前一章创建 CALL ordertotal(o, 1, @t); # 将订单号和订单合计插入ordertotals结果表中 INSERT INTO ordertotals(order_num, total) VALUES(o, t); UNTIL done END REPEAT; # 关闭游标 CLOSE ordernumbers;END; 此存储过程不返回数据，但它能够创建和填充另一个表。查看该表，SELECT * FROM ordertotals。 第25章 使用触发器25.1 触发器 MySQL5或之后的版本支持触发器。 希望某条语句（或某些语句）在事件发生时自动执行。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE INSERT UPDATE 其他MySQL语句不支持触发器。 25.2 创建触发器 在创建触发器时，需要给出四条信息： 唯一的触发器名 触发器关联的表 触发器应该响应的活动（DELETE、INSERT或UPDATE） 触发器何时执行（处理之前或之后） 触发器在每个表中唯一，在数据库中的两个表可以具有相同名字的触发器。但最好在数据库范围内使用唯一的触发器名。 触发器用CREATE TRIGGER语句创建。 12345# 创建名为newproduct的触发器，将在INSERT语句执行后执行# 指定FOR EACH ROW SELECT，对每个插入行执行# 本文Product added对每个插入行显示一次CREATE TRIGGER newproduct AFTER INSERT ON productsFOR EACH ROW SELECT 'Product added'; 只有表才支持触发器，视图不支持（临时表也不支持）。 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器，每个表最多支持6个触发器（每天INSERT、UPDATE和DELETE的之前和之后）。 单个触发器不能与多个事件或多个表关联，如果你需要对一个INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。 25.3 删除触发器 使用DROP TRIGGER 语句。如DROP TRIGGER newproduct。 触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。 25.4 使用触发器25.4.1 INSERT触发器 INSERT 触发器在INSERT语句执行之前或之后执行。 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行。 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）。 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。 12345678910# 创建一个名为neworder的触发器# 插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中# 触发器从NEW.order_num取得这个值并返回它CREATE TRIGGER neworder AFTER INSERT ON ordersFOR EACH ROW SELECT NEW.order_num;# 插入一个新行# orders包含3行，order_date和 cust_id必须给出，order_num由MySQL自动生成INSERT INTO order(order_date, cust_id)VALURES(now(), 10001) 25.4.2 DELETE触发器 DELETE触发器在DELETE语句执行之前或之后执行。 在DELETE触发器代码内，可引用一个名为OLD的虚拟表，访问被删除的行。 OLD中的值全都是只读的，不能更新。 1234567# 在任意订单被删除前将执行此触发器，它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到archive_orders存档表中CREATE TRIGGER deleteorder BEFORE DELETE ON ordersFOR EACH ROWBEGIN INSERT INTO archive_orders(order_num, order_date, cust_id) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; 使用BEGIN 和 END语句的好处是触发器能容纳多条SQL语句。 25.4.3 UPDATE触发器 UPDATE 触发器在UPDATE语句执行之前或之后执行。 在UPDATE触发器代码内，可引用一个名为OLD的虚拟表访问以前的值，引用一个名为NEW的虚拟表访问被新更新的值。 在BEFORE UPDATE触发器中，NEW中的值也可以被更新（允许更改被插入的值）。 OLD中的值全都是只读的，不能更新。 123# 保证输入的州名是大写，不管输入是大写还是小写CREATE TRIGGER updatevendor BEFORE UPDATE ON vendorsFOR EACH ROW SET NEW.vend_state = Upper(NEW.vend_state) 25.4.4 关于触发器的进一步介绍 创建触发器可能需要特殊的安全访问权限。但是触发器的执行时自动的。 用触发器保证数据的一致性（大小写、格式等）。 触发器可以创建审计跟踪，把更改记录到另一个表非常容易。 触发器不支持CALL语句。 第26章 管理事务处理26.1 事务处理 MyISAM和InnoDB是两种最常使用的引擎，前者不支持明确的事务处理管理，后者支持。 事务处理用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 利用事务管理，可以保证一组操作不会中途停止，它们作为整体执行，或者完全不执行。 如果没有发生错误，整组语句提交给数据库表，如果发生错误，则进行回退（撤销）以恢复数据库到某个已知且安全的状态。 事务（transaction）：一组SQL语句。 回退（rollback）：撤销指定SQL语句的过程。 提交（commit）：将未存储的SQL语句结果写入数据库表。 保留点（savepoint）：事务处理中设置的临时占位符（placeholder），你可以对它发布回退。 26.2 控制事务处理 关键在于将SQL语句分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。 使用START TRANSACTION来标识事务的开始。 26.2.1 使用ROLLBACK 使用ROLLBACK来回退（撤销）MySQL语句。 123456SELECT * FROM ordertotals; # 显示表ordertotals不为空START TRANSACTION; # 开始一个事务处理DELETE FROM ordertotals; # 删除ordertotals中的所有行，注意不是删除表SELECT * FROM ordertotals; # 验证ordertotals确实为空ROLLBACK; # 回退START TRANSACTION之后的所有语句SELECT * FROM ordertotals; # 显示表ordertotals不为空，回退成功 ROLLBACK 只能在一个事务处理内使用（执行一条START TRANSACTION 命令之后）。 事务管理用来管理INSERT、UPDATE和DELETE语句。 不能回退SELECT语句、CREATE和DROP操作。 26.2.2 使用COMMIT 一般的MySQL语句都是隐含提交的，即提交（写或保存）操作都是自动的。 但事务处理块中，提交不会隐含地进行，使用COMMIT语句进行明确的提交。 12345# 使用COMMIT语句仅在不出错时写出更改START TRANSACTION;DELETE FROM orderitems WHERE order_num = 20010;DELETE FROM orders WHERE order_num = 20010;COMMIT; 当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 26.2.3 使用保留点 复杂的事务处理可能需要部分提交或回退。 为了支持回退部分事务处理，必须能在事务处理块中合适位置放置占位符，如果需要回退，可以回退到某个占位符。 创建占位符，使用SAVEPOINT，例如SAVEPOINT delete1;。 每个保留点都标识它的唯一名字。 回退到保留点，ROLLBACK TO delete1;。 保留点越多越好，越灵活。 保留点在事务处理完成后自动释放，也可以用RELEASE SAVEPOINT明确地释放保留点。 26.2.4 更改默认的提交行为 MySQL默认自动提交所有更改。 为只是MySQL不自动提交更改，使用SET autocommit=0;。 第27章 全球化和本地化27.1 字符集和校对顺序 MySQL需要适应不同的字符集，适应不同的排序和检索数据的方法。 字符集：字母和符号的结合。 编码：某个字符集成员的内部表示。 校对：规定字符如何比较的指令。 使用何种字符集合校对的决定在服务器、数据库和表级进行。 27.2 使用字符集和校对顺序 查看所支持的字符集完整列表，SHOW CHARACTER SET;。 查看所支持校对的完整列表，SHOW COLLATION。 可以在安装时定义一个默认的字符集和校对，也可以在创建数据库时，指定默认的字符集和校对。为了确定所用的字符集和校对，使用语句，SHOW VARIABLES LIKE &#39;character%&#39;和SHOW VARIABLES LIKE &#39;collation%&#39;。 给表指定字符集和校对，使用带子句的CREATE TABLE。 123456CREATE TABLE mytable(column1 INT,column2 VARCHAR(10)) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 除了可以给表指定字符集和校对，还可以对每个列设置它们。 12345678CREATE TABLE mytable(column1 INT,column2 VARCHAR(10),column3 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci;) DEFAULT CHARACTER SET hebrewCOLLATE hebrew_general_ci; 校对在用ORDER BY子句检索出来的数据排序时起重要的作用。 123# 使用与创建表时不同的校对顺序排序特定的SELECT语句SELECT * FROM customersORDER BY lastname, firstname COLLATE latin1_general_cs; 第28章 安全管理28.1访问控制 安全基础：用户应该对他们需要的数据具有恰当的访问权，既不能多也不能少。用户不能对过多的数据具有过多的访问权。 访问控制：给用户提供他们所需的访问权，且仅提供他们所需的访问权。 不要在日常操作中使用root。 28.2 管理用户 获取所有用户账户列表。 123# mysql数据库有一个名为user的表，它包含所有用户账号USE mysql;SELECT user FROM user; 28.2.1 创建用户账户 创建新用户。 12# 创建一个新用户，用户名ben，口令p@$$wordCREATE USER ben IDENTIFIED BY 'p@$$word'; IDENTIFIED BY为纯文本口令，为了作为散列指定加密口令，使用IDENTIFIED BY PASSWORD。 重命名用户名。使用RENAME USER ben TO bforta;。 28.2.2 删除用户账户 使用DROP USER语句，如DROP USER bforta;。 28.2.3 设置访问权限 新创建的用户没有访问权限。 查看赋予用户的权限，SHOW GRANTS FOR bforta;。 用户定义为user@host。默认主机名为%。 为设置权限，使用GRANT语句，需给出以下信息： 要授予的权限。 被授予访问权限的数据库或表。 用户名。 12345# 允许用户在crashcourse.*（crashcourse数据库的所有表）上使用SELECTGRANT SELECT ON crashcourse.* TO bforta;# 查看添加的权限SHOW GRANTS FOR bforta; 撤销特定的全效，使用REVOKE语句。REVOKE SELECT ON crashcourse.* FROM bforta;，撤销了bforta的SELECT访问权限。 GRANT 和REVOKE可在几个层次上控制访问权限。 整个服务器，使用GRANT ALL 和 REVOKE ALL。 整个数据库，使用ON database.*。 特定的表，使用ON database.table。 特定的列。 特定的存储过程。 28.2.4 更改口令 使用SET PASSWORD，新口令必须使用Password加密：SET PASSWORD FOR bforta = Password(&#39;n3w p@$$word&#39;)。 设置自己的口令：SET PASSWORD = Password(&#39;n3w p@$$word&#39;)。 第29章 数据库维护29.1 备份数据 使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。 可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据。 可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。 29.2 进行数据库维护 ANALYZE TABLE，用来检查表键是否正确。 CHECK TABLE，用来针对许多问题对表进行检查。 29.3 诊断启动问题 服务器启动问题通常在对MySQL匹配或服务器本身进行更改时出现。 排除系统启动问题时，首先应该尽量用手动启动服务器。 mysql命令行选项。 —help显示帮助。 —safe -mode装载减去某些最佳配置的服务器。 —verbose显示全文本信息。 —version显示版本信息。 29.4 查看日志文件 错误日志。—log-error 查询日志。—log 二进制日志。—log- bin 缓慢查询日志。—log-slow-queries 第30章 改善性能30.1 改善性能 运行在专用服务器上。 调整内存分配、缓冲区大小。 显示所有活动进程，KILL命令终结某个特定的进程。 使用联结、并、子查询等方法编写SELECT语句。 使用存储过程。 使用正确的数据类型。 不要检索比需求还要多的数据，尽量不要用SELECT *。 使用DELAYED关键字。 导入数据时，应该关闭自动提交。 索引数据库表以改善数据检索的性能。 使用多条SELECT语句和联结它们的UNION语句来替代一系列复杂的OR语句。 LIKE很慢，最好使用FULLTEXT。 每条规则在某些条件下都会被打破。]]></content>
      <categories>
        <category>StudyNotes</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>StudyNotes</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Project Experience - 2019未来杯高校AI挑战赛：城市房产租金预测]]></title>
    <url>%2F2019%2F06%2F10%2FProjectExperience-futureAI-contest-19-house-rent-prediction%2F</url>
    <content type="text"><![CDATA[本文为2019未来杯高校AI挑战赛: 城市-房产租金预测的 单模90.952分 解题思路，不包含模型调参及模型融合。 赛题链接：2019未来杯高校AI挑战赛：城市房产租金预测 完整数据及代码：Github 赛题说明根据给定的数据集，建立模型，预测房屋租金。数据集中的数据类别包括租赁房源、小区、二手房、配套、新房、土地、人口、客户、真实租金等。 数据预处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117# -*- coding: utf-8 -*-"""Created on Thu May 30 20:19:58 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import timetrain_raw = pd.read_csv('dataset/train_data.csv')test_raw = pd.read_csv('dataset/test_a.csv')combine_raw = pd.concat([train_raw, test_raw],axis=0,ignore_index=True)# =============================================================================# 将所有中文转化为英文# =============================================================================def ZHtoEN(df): df['rentType'][df['rentType']=='--'] = '未知方式' df['rentType'].replace(&#123;'未知方式':'unknown', '合租': 'hezu', '整租':'zhengzu'&#125;, inplace = True) df['houseFloor'].replace(&#123;'低':'low', '中': 'middle', '高':'high'&#125;, inplace = True) df['houseFloor'].replace(&#123;'低':'low', '中': 'middle', '高':'high'&#125;, inplace = True) df['houseToward'].replace(['暂无数据', '西南', '西北', '西', '南北', '南', '东西', '东南', '东', '北'], ['unknown', 'WS', 'WN', 'W', 'SN', 'S','EW','ES','E','N'] , inplace = True) df['houseDecoration'].replace([u'其他','毛坯',u'简装',u'精装'], ['unknown', 'maopei', 'jianzhuang', 'jingzhuang'],inplace=True) df['buildYear'][df['buildYear'] == '暂无信息'] = 'unknown' return dfcombine_1 = ZHtoEN(combine_raw)# =============================================================================# 将houseType转化为室厅卫# =============================================================================def houseType_trans(df): houseType_ = pd.DataFrame(columns = ['ID', 'room', 'lobby', 'bath']) houseType_['ID'] = df['ID'].copy() houseType_['room'] = df['houseType'].apply(lambda x: int(x[0])) houseType_['lobby'] = df['houseType'].apply(lambda x: int(x[2])) houseType_['bath'] = df['houseType'].apply(lambda x: int(x[4])) df = df.merge(houseType_,on='ID',how='left') return dfcombine_2 = houseType_trans(combine_1)# =============================================================================# 将tradeTime转化为年月日 和 时间戳# =============================================================================def datetime_timestamp(dt): s = time.mktime(time.strptime(dt,'%Y/%m/%d')) return sdef tradeTime_trans(df): df['tradeYear'] = df['tradeTime'].apply(lambda x: int(x.split('/')[0])) df['tradeMonth'] = df['tradeTime'].apply(lambda x: int(x.split('/')[1])) df['tradeDay'] = df['tradeTime'].apply(lambda x: int(x.split('/')[2])) df['tradeTime']=df['tradeTime'].apply(lambda x:datetime_timestamp(x),1) return df combine_3 = tradeTime_trans(combine_2)# =============================================================================# 处理缺失值# =============================================================================def fillna_(df): # 处理pv和uv的空值 df['pv'] = df['pv'].fillna(df['pv'].mean()) df['uv'] = df['uv'].fillna(df['uv'].mean()) df['pv'] = df['pv'].astype('int') df['uv'] = df['uv'].astype('int') # 处理buildYear的暂无信息 df['buildYear'].replace('unknown', np.nan, inplace = True) df['buildYear'].fillna(df['buildYear'].mode()[0], inplace = True) df['buildYear'] = df['buildYear'].astype('int') # 将未知 houseToward 转为为 S temp = df['houseToward'].mode()[0] df['houseToward'] = df['houseToward'].apply(lambda x:x.replace("unknown",temp),1) return df combine_4 = fillna_(combine_3)# =============================================================================# 去除test中不存在的小区，区域和板块# =============================================================================def remove_(df, train, test): samecommunity = set(train.communityName) &amp; set(test.communityName) df = df[df.communityName.isin(samecommunity)] sameregion = set(train.region) &amp; set(test.region) df = df[df.region.isin(sameregion)] sameplate = set(train.plate) &amp; set(test.plate) df = df[df.plate.isin(sameplate)] return dfcombine_5 = remove_(combine_4, train_raw, test_raw)# =============================================================================# 去除训练集中的异常值# =============================================================================train_pre = combine_5[combine_5.tradeMoney.notnull()]test_pre= combine_5[combine_5.tradeMoney.isnull()]train_pre1 = train_pre[(train_pre.area&lt;=160)&amp;(train_pre.area&gt;=10)]train_pre2 = train_pre1[(train_pre1.tradeMoney&lt;=20000)&amp;(train_pre1.tradeMoney&gt;=600)]train_pre3 = train_pre2[(train_pre2.totalFloor &gt; 1)]combine_6 = pd.concat([train_pre3, test_pre],axis=0,ignore_index=True)combine_6.to_csv('output/test-a/data_preprocessing.csv',index=None) 简单特征工程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding: utf-8 -*-"""Created on Thu May 30 21:13:37 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')combine = pd.read_csv('output/test-a/data_preprocessing.csv')# =============================================================================# 添加简单特征# =============================================================================def simple_feature(df): # 房子年龄 df['buildingAge'] = df['tradeYear'] - df['buildYear'] # 实际交易时间 df['tradeDay_real'] = (df['tradeMonth'] -1) * 30 + df['tradeDay'] # 房间总数 df['totalRoom'] = df['room'] + df['lobby'] + df['bath'] # 平均面积 df['per_room'] = df['area'] / df['totalRoom'] df['room_add_lobby'] = df['room'] + df['lobby'] df['room_sub_lobby'] = df['room'] - df['lobby'] df['room_add_bath'] = df['room'] + df['bath'] df['room_sub_bath'] = df['room'] - df['bath'] df['lobby_add_bath'] = df['lobby'] + df['bath'] df['lobby_sub_bath'] = df['lobby'] - df['bath'] # pv/uv # pv/uv df['pv/uv'] = df['pv'] / (df['uv']+1) df['client'] = df['pv/uv'] + df['lookNum'] df['Floor_'] = np.ceil(df['houseFloor'].map(&#123;'low':0.2, 'middle':0.5, 'high':0.8 &#125;) * df['totalFloor']) # 配套设施 df['transportation'] = df['subwayStationNum'] + df['busStationNum'] df['education'] = df['interSchoolNum'] + df['schoolNum'] + df['privateSchoolNum'] df['health'] = df['hospitalNum'] + df['drugStoreNum'] + df['drugStoreNum'] + df['gymNum'] df['convenience'] = df['bankNum'] + df['shopNum'] + df['parkNum'] + df['mallNum'] + df['superMarketNum'] df['supportingFacilities'] = df['transportation'] + df['education'] + df['health'] + df['convenience'] # 成交比例# 新房成交比例 df['tradeNewRatio'] = df['tradeNewNum'] / (df['tradeNewNum'] + df['remainNewNum'] + 1)# 新增人口平均每人成交套数 df['tradeRatio_avg'] = df['newWorkers'] / (df['tradeSecNum'] + df['tradeNewNum']+1)# 工人占比 df['workerRatio'] = df['totalWorkers'] / (df['residentPopulation'] + df['totalWorkers'] + 1)# 本月新增工人占比 df['NewWorkerRatio'] = df['newWorkers'] / (df['totalWorkers']+1) return dfcombine_feature_1 = simple_feature(combine)combine_feature_1.to_csv('output/test-a/data_featureEngineering_1.csv',index=None) 复杂特征工程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# -*- coding: utf-8 -*-"""Created on Thu May 30 23:11:08 2019@author: huangqiancun"""from sklearn.preprocessing import LabelEncoder, OneHotEncoderimport pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import MeanEncodercombine = pd.read_csv('output/test-a/data_featureEngineering_1.csv')# =============================================================================# 获取位置 区域+板块+小区# =============================================================================def get_location(df): df['location'] = df['region']+"_"+df['plate']+"_"+df['communityName'] return dfcombine2 = get_location(combine)# =============================================================================# rank编码# =============================================================================def rank_feature(df): df['communityName_freq'] = df['communityName'].map(df['communityName'].value_counts().rank()/len(df['communityName'].unique())) df['region'] = df['region'].map(df['region'].value_counts().rank()/len(df['region'].unique())) df['plate'] = df['plate'].map(df['plate'].value_counts().rank()/len(df['plate'].unique())) df['location'] = df['location'].map(df['location'].value_counts().rank()/len(df['location'].unique())) return dfcombine3 = rank_feature(combine2)# =============================================================================# LabelEncoder 编码# =============================================================================def label_feature(df): for col in ['houseType',"houseToward","communityName"]: lbl =LabelEncoder() df[col]=lbl.fit_transform(df[col]) return dfcombine4 = label_feature(combine3)train = combine4[combine4.tradeMoney.notnull()]test = combine4[combine4.tradeMoney.isnull()]# =============================================================================# MeanEncoder 需要自定义依赖文件 MeanEncoder.py# =============================================================================flag="mean"print("mean...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("std...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="std", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("max...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="max", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("min...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="min", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("skew...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="skew", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("kurt...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="kurt", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("unique...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="unique", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)print("freq...")mean_encoder = MeanEncoder.MeanEncoder( categorical_features=['communityName',"plate","buildYear","totalFloor","tradeDay"], stats="freq", target_type='regression',flag=flag )train = mean_encoder.fit_transform(train, pd.Series(train['tradeMoney']))test = mean_encoder.transform(test)# =============================================================================# 组合变量# =============================================================================combine5 = pd.concat([train,test])groupby_feat=combine5.groupby("communityName",as_index=False)['area'].agg(&#123;"area_mean":"mean","area_std":"std","area_skew":"skew", "area_min":"min","area_max":"max",&#125;)groupby_feat1=combine5.groupby("communityName",as_index=False)['tradeDay'].agg(&#123;"day_mean":"mean","day_std":"std","day_skew":"skew", "day_min":"min","day_max":"max",&#125;)groupby_feat2=combine5.groupby("communityName",as_index=False)['tradeMonth'].agg(&#123;"month_mean":"mean","month_std":"std","month_skew":"skew", "month_min":"min","month_max":"max"&#125;)train = pd.merge(train,groupby_feat,on="communityName",how="left")test = pd.merge(test,groupby_feat,on="communityName",how="left")train = pd.merge(train,groupby_feat1,on="communityName",how="left")test = pd.merge(test,groupby_feat1,on="communityName",how="left")train = pd.merge(train,groupby_feat2,on="communityName",how="left")test = pd.merge(test,groupby_feat2,on="communityName",how="left")# =============================================================================# 输出# =============================================================================combine6 = pd.concat([train,test])combine6.drop(['ID', 'city','tradeYear'], axis = 1, inplace = True)combine6.to_csv('output/test-a/data_featureEngineering_2.csv',index=None) 训练模型best：0.90952123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# -*- coding: utf-8 -*-"""Created on Thu May 30 22:23:47 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import lightgbm as lgbfrom sklearn.model_selection import KFoldfrom sklearn.metrics import r2_scoreimport self_define_function #自定义函数combine = pd.read_csv('output/test-a/data_featureEngineering_2.csv')train = combine[combine.tradeMoney.notnull()]test = combine[combine.tradeMoney.isnull()]params = &#123; 'num_leaves': 31, 'min_data_in_leaf': 20, 'min_child_samples':20, 'objective': 'regression', 'learning_rate': 0.01, "boosting": "gbdt", "feature_fraction": 0.8, "bagging_freq": 1, "bagging_fraction": 0.85, "bagging_seed": 23, "metric": 'rmse', "lambda_l1": 0.2, "nthread": 4,&#125;# baseline 0.90952target = train.pop('tradeMoney')test.drop(['tradeMoney'], axis = 1, inplace = True)object_feats = [x for x in train.select_dtypes(include = ['object']).columns]for col in object_feats: train[col] = train[col].astype('category') test[col] = test[col].astype('category') score, feature_importance_df,predictions_lgb, oog_lgb = self_define_function.lgb_eval(params, train, target, test)feature_importance = (feature_importance_df[["feature", "importance"]] .groupby("feature") .mean() .sort_values(by="importance", ascending=False).index)#feature_importance = self_define_function.feature_importance(feature_importance_df)pd.DataFrame(predictions_lgb).apply(round).to_csv('submit/submit-baseline.csv',na_rep='\\n',index=False,encoding='utf8',header=False)# =============================================================================# 15个重要特征进行特征交叉# =============================================================================def add(x, y): return x + ydef substract(x, y): return x - ydef times(x, y): return x * ydef divide(x, y): return (x + 0.001)/(y + 0.001)CrossMethod = &#123;# '+':add,# '-':substract, '*': times, '/': divide, &#125;def get_Cross_feat(Cross_col, df): df_after = pd.DataFrame() for i in range(len(Cross_col)): for j in range(i+1, len(Cross_col)): for k in CrossMethod: df_after[Cross_col[i]+k+Cross_col[j]] = CrossMethod[k](df[Cross_col[i]], df[Cross_col[j]]) print(Cross_col[i]+k+Cross_col[j],"done") return df_afterimp_feature = feature_importance[:15]#imp_feature = ['area', 'per_room', 'communityName_pred_mean', 'area_mean',# 'communityName_pred_max', 'communityName_pred_min', 'tradeTime',# 'tradeDay_pred_std', 'communityName_pred_std', 'tradeDay_pred_freq',# 'tradeDay_pred_mean', 'area_skew', 'area_min', 'houseType', 'day_skew',# 'tradeDay_pred_kurt', 'tradeMeanPrice', 'client', 'tradeDay_pred_skew',# 'plate_pred_mean', 'area_std', 'month_std', 'Floor_',# 'communityName_pred_skew', 'month_skew', 'tradeDay_pred_unique',# 'tradeNewMeanPrice', 'day_std', 'communityName_pred_kurt',# 'plate_pred_std'][:15]Cross_train = get_Cross_feat(imp_feature,train)Cross_test = get_Cross_feat(imp_feature,test)train_after_cross = train.join(Cross_train)test_after_cross = test.join(Cross_test)# =============================================================================# 特征交叉后 重新训练 0.90921 降分# =============================================================================score, feature_importance_df,predictions_lgb, oog_lgb = self_define_function.lgb_eval(params, train_after_cross, target, test_after_cross)feature_importance = (feature_importance_df[["feature", "importance"]] .groupby("feature") .mean() .sort_values(by="importance", ascending=False).index)#feature_importance = self_define_function.feature_importance(feature_importance_df)pd.DataFrame(predictions_lgb).apply(round).to_csv('submit/submit.csv',na_rep='\\n',index=False,encoding='utf8',header=False)# =============================================================================# 保存所有特征 给下一步做特征选择# =============================================================================train_after_cross['tradeMoney'] = targetcombine7 = pd.concat([train_after_cross,Cross_test],axis=0, ignore_index=True)combine7.to_csv('output/test-a/data_featureCross.csv',index=None) 暴力前向特征选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121# -*- coding: utf-8 -*-"""Created on Mon Jun 3 04:24:08 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')from sklearn.model_selection import cross_val_score, ShuffleSplitfrom sklearn.model_selection import KFoldfrom sklearn.ensemble import RandomForestRegressor combine = pd.read_csv('output/test-a/data_featureCross.csv')train= combine[combine.tradeMoney.notnull()]test= combine[combine.tradeMoney.isnull()]def lgb_feature(train, target): folds = KFold(n_splits=3, shuffle=True, random_state=2333) oof_lgb = np.zeros(len(train)) for fold_, (trn_idx, val_idx) in enumerate(folds.split(train.values, target.values)): print("fold &#123;&#125;".format(fold_)) trn_data = lgb.Dataset(train.iloc[trn_idx], label=target.iloc[trn_idx]) val_data = lgb.Dataset(train.iloc[val_idx], label=target.iloc[val_idx]) num_round = 10000 clf = lgb.train(params, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=3000, early_stopping_rounds = 200) oof_lgb[val_idx] = clf.predict(train.iloc[val_idx], num_iteration=clf.best_iteration) print("CV Score: &#123;:&lt;8.5f&#125;".format(r2_score(target, oof_lgb))) score = 1- np.sum(np.square(target - oof_lgb)) / np.sum(np.square(target - np.mean(target))) print("Score: &#123;:&lt;8.5f&#125;".format(score)) return score# 参考 https://stackoverflow.com/questions/43258188/cant-reproduce-xgb-cv-cross-validation-resultsdef Forward_Feature_Selection(train, target): best = 0 selected_features = [] previous_best_score = 0 res_score = [] threshold = 0 gain = threshold + 1 features = train.columns.values selected = np.zeros(len(features)) scores = np.zeros(len(features)) while (gain &gt; threshold): # we start a add-a-feature loop# while len(selected_features) &lt; 3: for i in range(0,len(features)): print("last added feature: " + features[best] + "**number:" + str(len(selected_features)) + "**Launching XGBoost for feature:= "+ features[i]) if (selected[i] == 0): # take only features not yet selected selected_features.append(features[i]) new_train = train.iloc[:][selected_features] selected_features.remove(features[i]) categorical_subset = new_train.select_dtypes('category') categorical_feats = [c for c in categorical_subset.columns] scores[i] = lgb_feature(new_train, target) else: scores[i] = -1 # discard already selected variables from candidates # 一次只取最好的一个# best = np.argmax(scores)# gain = scores[best] - previous_best_score# # if (gain &gt; 0):# previous_best_score = scores[best]# res_score.append(scores[best])# selected_features.append(features[best])# selected[best] = 1 # 一次选择多个特征，加速 candidates = scores[sorted(scores, reverse = True)[:5]] best = candidates[0] gain = scores[best] - previous_best_score if (gain &gt; 0): previous_best_score = scores[best] res_score.append(scores[candidates]) selected_features.append(features[candidates]) selected[candidates] = 1 print("Adding feature: " + features[best] + " increases score by " + str(gain) + ". Final score is now: " + str(previous_best_score)) return selected_features, previous_best_score, res_scoretarget = train.pop('tradeMoney')test.drop(['tradeMoney'], axis = 1, inplace = True)object_feats = [x for x in train.select_dtypes(include = ['object']).columns]for col in object_feats: train[col] = train[col].astype('category') test[col] = test[col].astype('category') selected_features, previous_best_score, res_score = Forward_Feature_Selection(train, target)train = train[selected_features]test = test[selected_features]train['tradeMoney'] = targetcombine = pd.concat([train,test],axis=0, ignore_index=True)combine.to_csv('output/test-a/data_featureSelection.csv',index=None) 选择特征后训练模型降分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-"""Created on Thu May 30 22:23:47 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import lightgbm as lgbfrom sklearn.model_selection import KFoldfrom sklearn.metrics import r2_scoreimport self_define_function#combine = pd.read_csv('output/test-a/data_featureSelection.csv')#train = combine[combine.tradeMoney.notnull()]#test = combine[combine.tradeMoney.isnull()]# 特征选择太耗时，没跑完，直接使用前100个重要的特征训练模型combine = pd.read_csv('output/test-a/data_featureCross.csv')selected_features = feature_importance[:100]train = combine[combine.tradeMoney.notnull()]test = combine[combine.tradeMoney.isnull()]train = train[selected_features]test = test[selected_features]params = &#123; 'num_leaves': 31, 'min_data_in_leaf': 20, 'min_child_samples':20, 'objective': 'regression', 'learning_rate': 0.01, "boosting": "gbdt", "feature_fraction": 0.8, "bagging_freq": 1, "bagging_fraction": 0.85, "bagging_seed": 23, "metric": 'rmse', "lambda_l1": 0.2, "nthread": 4,&#125;# 特征选择后训练 0.90848 target = train.pop('tradeMoney')test.drop(['tradeMoney'], axis = 1, inplace = True)object_feats = [x for x in train.select_dtypes(include = ['object']).columns]for col in object_feats: train[col] = train[col].astype('category') test[col] = test[col].astype('category') score, feature_importance_df,predictions_lgb, oog_lgb = self_define_function.lgb_eval(params, train, target, test)#feature_importance = self_define_function.feature_importance(feature_importance_df)pd.DataFrame(predictions_lgb).apply(round).to_csv('submit/submit-after_feature_selection.csv',na_rep='\\n',index=False,encoding='utf8',header=False) 一些自定义的函数 self_define_function.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-"""Created on Thu May 30 22:39:33 2019@author: huangqiancun"""import pandas as pdimport numpy as npimport warningswarnings.filterwarnings('ignore')import lightgbm as lgbfrom sklearn.model_selection import KFoldfrom sklearn.metrics import r2_scoreimport matplotlib.pyplot as pltimport seaborn as snsdef feature_importance(feature_importance_df): cols = (feature_importance_df[["feature", "importance"]] .groupby("feature") .mean() .sort_values(by="importance", ascending=False)[:1000].index) best_features = feature_importance_df.loc[feature_importance_df.feature.isin(cols)] feature_rank = best_features.sort_values(by="importance",ascending=False) plt.figure(figsize=(14,40)) sns.barplot(x="importance", y="feature", data=feature_rank) plt.title('LightGBM Features (avg over folds)') plt.tight_layout() return colsdef lgb_eval(params, train, target, test): features = train.columns folds = KFold(n_splits=5, shuffle=True, random_state=2333) oof_lgb = np.zeros(len(train)) predictions_lgb = np.zeros(len(test)) feature_importance_df = pd.DataFrame() for fold_, (trn_idx, val_idx) in enumerate(folds.split(train.values, target.values)): print("fold &#123;&#125;".format(fold_)) trn_data = lgb.Dataset(train.iloc[trn_idx], label=target.iloc[trn_idx]) val_data = lgb.Dataset(train.iloc[val_idx], label=target.iloc[val_idx]) num_round = 10000 clf = lgb.train(params, trn_data, num_round, valid_sets = [trn_data, val_data], verbose_eval=2000, early_stopping_rounds = 200) oof_lgb[val_idx] = clf.predict(train.iloc[val_idx], num_iteration=clf.best_iteration) fold_importance_df = pd.DataFrame() fold_importance_df["feature"] = features fold_importance_df["importance"] = clf.feature_importance() fold_importance_df["fold"] = fold_ + 1 feature_importance_df = pd.concat([feature_importance_df, fold_importance_df], axis=0) predictions_lgb += clf.predict(test, num_iteration=clf.best_iteration) / folds.n_splits print("CV Score: &#123;:&lt;8.5f&#125;".format(r2_score(target, oof_lgb))) score = 1- np.sum(np.square(target - oof_lgb)) / np.sum(np.square(target - np.mean(target))) print("Score: &#123;:&lt;8.5f&#125;".format(score)) return score, feature_importance_df, predictions_lgb, oof_lgb MeanEncoder.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193# -*- coding: utf-8 -*-"""Created on Sun Jun 9 13:38:42 2019@author: huangqiancun"""import numpy as npimport pandas as pdfrom sklearn.model_selection import StratifiedKFold, KFoldfrom itertools import productfrom scipy import statsfrom scipy.stats import skew, kurtosisdef get_mode(row): return stats.mode(row)[0][0] def get_unique_num(row): if len(row) == 0: return 0 return len(np.unique(row))def get_len(row): return len(row)def get_unique_freq(row): if len(row) == 0: return 0 return float(len(np.unique(row))) / len(row)def get_max(row): return np.max(row)def get_min(row): return np.min(row)def get_mean(row): return np.mean(row)def get_std(row): return np.std(row)def get_skew(row): return skew(row)class MeanEncoder: def __init__(self, categorical_features,stats="mean", flag="mean",n_splits=5, target_type='classification', prior_weight_func=None): """ :param categorical_features: list of str, the name of the categorical columns to encode :param n_splits: the number of splits used in mean encoding :param target_type: str, 'regression' or 'classification' :param prior_weight_func: a function that takes in the number of observations, and outputs prior weight when a dict is passed, the default exponential decay function will be used: k: the number of observations needed for the posterior to be weighted equally as the prior f: larger f --&gt; smaller slope ''' &gt;&gt;&gt;example: mean_encoder = MeanEncoder( categorical_features=['regionidcity', 'regionidneighborhood', 'regionidzip'], target_type='regression' ) X = mean_encoder.fit_transform(X, pd.Series(y)) X_test = mean_encoder.transform(X_test) """ self.categorical_features = categorical_features self.n_splits = n_splits self.learned_stats = &#123;&#125; self.stats=stats self.flag=flag if target_type == 'classification': self.target_type = target_type self.target_values = [] else: self.target_type = 'regression' self.target_values = None if isinstance(prior_weight_func, dict): self.prior_weight_func = eval('lambda x: 1 / (1 + np.exp((x - k) / f))', dict(prior_weight_func, np=np)) elif callable(prior_weight_func): self.prior_weight_func = prior_weight_func else: self.prior_weight_func = lambda x: 1 / (1 + np.exp((x - 2) / 1)) @staticmethod def mean_encode_subroutine(X_train, y_train, X_test, variable, target, prior_weight_func,stats,flag): X_train = X_train[[variable]].copy() X_test = X_test[[variable]].copy() if target is not None: nf_name = '&#123;&#125;_pred_&#123;&#125;_&#123;&#125;'.format(variable, target,stats) X_train['pred_temp'] = (y_train == target).astype(int) # classification else: nf_name = '&#123;&#125;_pred_&#123;&#125;'.format(variable,stats) X_train['pred_temp'] = y_train # regression# prior = X_train['pred_temp'].mean() stats_dict=&#123;"mean":get_mean, "min":get_min, "max":get_max, "std":get_std, "skew":get_skew, "mode":get_mode, "kurt":kurtosis, "unique":get_unique_num, "freq":get_unique_freq &#125; if stats=="mode": col_avg_y = X_train.groupby(by=variable, axis=0)['pred_temp'].agg(&#123;stats: get_mode, 'beta': 'size'&#125;) if stats=="kurt": col_avg_y = X_train.groupby(by=variable, axis=0)['pred_temp'].agg(&#123;stats: kurtosis, 'beta': 'size'&#125;) if stats=="unique": prior = get_unique_num(X_train['pred_temp']) col_avg_y = X_train.groupby(by=variable, axis=0)['pred_temp'].agg(&#123;stats: get_unique_num, 'beta': 'size'&#125;) if stats=="freq": prior = get_unique_freq(X_train['pred_temp']) col_avg_y = X_train.groupby(by=variable, axis=0)['pred_temp'].agg(&#123;stats: get_unique_freq, 'beta': 'size'&#125;) if stats in ["mean","max","min","sum","std","var","median","skew"]: col_avg_y = X_train.groupby(by=variable, axis=0)['pred_temp'].agg(&#123;stats: stats, 'beta': 'size'&#125;) if flag=="mean": prior = stats_dict['mean'](X_train['pred_temp']) elif flag=="median": prior = X_train['pred_temp'].median() else: prior = stats_dict[stats](X_train['pred_temp']) col_avg_y['beta'] = prior_weight_func(col_avg_y['beta']) col_avg_y[nf_name] = col_avg_y['beta'] * prior + (1 - col_avg_y['beta']) * col_avg_y[stats] col_avg_y.drop(['beta', stats], axis=1, inplace=True) nf_train = X_train.join(col_avg_y, on=variable)[nf_name].values nf_test = X_test.join(col_avg_y, on=variable).fillna(prior, inplace=False)[nf_name].values return nf_train, nf_test, prior, col_avg_y def fit_transform(self, X, y): """ :param X: pandas DataFrame, n_samples * n_features :param y: pandas Series or numpy array, n_samples :return X_new: the transformed pandas DataFrame containing mean-encoded categorical features """ X_new = X.copy() stats=self.stats if self.target_type == 'classification': skf = StratifiedKFold(self.n_splits) else: skf = KFold(self.n_splits) if self.target_type == 'classification': self.target_values = sorted(set(y)) self.learned_stats = &#123;'&#123;&#125;_pred_&#123;&#125;_&#123;&#125;'.format(variable, target,stats): [] for variable, target in product(self.categorical_features, self.target_values)&#125; for variable, target in product(self.categorical_features, self.target_values): nf_name = '&#123;&#125;_pred_&#123;&#125;_&#123;&#125;'.format(variable, target,stats) X_new.loc[:, nf_name] = np.nan for large_ind, small_ind in skf.split(y, y): nf_large, nf_small, prior, col_avg_y = MeanEncoder.mean_encode_subroutine( X_new.iloc[large_ind], y.iloc[large_ind], X_new.iloc[small_ind], variable, target, self.prior_weight_func,self.stats,self.flag) X_new.iloc[small_ind, -1] = nf_small self.learned_stats[nf_name].append((prior, col_avg_y)) else: self.learned_stats = &#123;'&#123;&#125;_pred_&#123;&#125;'.format(variable,stats): [] for variable in self.categorical_features&#125; for variable in self.categorical_features: nf_name = '&#123;&#125;_pred_&#123;&#125;'.format(variable,stats) X_new.loc[:, nf_name] = np.nan for large_ind, small_ind in skf.split(y, y): nf_large, nf_small, prior, col_avg_y = MeanEncoder.mean_encode_subroutine( X_new.iloc[large_ind], y.iloc[large_ind], X_new.iloc[small_ind], variable, None, self.prior_weight_func,self.stats,self.flag) X_new.iloc[small_ind, -1] = nf_small self.learned_stats[nf_name].append((prior, col_avg_y)) return X_new def transform(self, X): """ :param X: pandas DataFrame, n_samples * n_features :return X_new: the transformed pandas DataFrame containing mean-encoded categorical features """ X_new = X.copy() stats=self.stats if self.target_type == 'classification': for variable, target in product(self.categorical_features, self.target_values): nf_name = '&#123;&#125;_pred_&#123;&#125;_&#123;&#125;'.format(variable, target,stats) X_new[nf_name] = 0 for prior, col_avg_y in self.learned_stats[nf_name]: X_new[nf_name] += X_new[[variable]].join(col_avg_y, on=variable).fillna(prior, inplace=False)[ nf_name] X_new[nf_name] /= self.n_splits else: for variable in self.categorical_features: nf_name = '&#123;&#125;_pred_&#123;&#125;'.format(variable,stats) X_new[nf_name] = 0 for prior, col_avg_y in self.learned_stats[nf_name]: X_new[nf_name] += X_new[[variable]].join(col_avg_y, on=variable).fillna(prior, inplace=False)[ nf_name] X_new[nf_name] /= self.n_splits return X_new]]></content>
      <categories>
        <category>Project Experience</category>
      </categories>
      <tags>
        <tag>Project Experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-红黑树]]></title>
    <url>%2F2019%2F05%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 红黑树定义红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在$O(logn)$时间内做查找，插入和删除，这里的$n$是树中元素的数目。 红黑树性质红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。除二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1：节点是红色或黑色 性质2：根节点是黑色 性质3：所有叶子节点都是黑色（叶子是NIL节点） 性质4：每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 性质5.：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 注意： 性质3中的叶子节点，是只为空(NIL或null)的节点。 性质5确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，因而，红黑树是相对是接近平衡的二叉树。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。 红黑树示例： 红黑树的应用红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。 例如，Java集合中的TreeSet和TreeMap，C++的STL中的Set、Map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 红黑树基本操作左旋]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Research Project - 基于低秩张量近似的高维良率分析]]></title>
    <url>%2F2019%2F05%2F19%2FResearchExperience-LowRankTensorApproximation%2F</url>
    <content type="text"><![CDATA[Note：本项目为国家重点研发计划《超低电压高精度时序分析技术（共性关键技术类）》的子课题《快速蒙特卡洛分析技术》的相关研究成果之一。 0 《超低电压高精度时序分析技术》项目概要0.1 研究内容针对超低电压电路时序波动大、传统静态时序分 析方法难以适用的问题，研发超低电压高精度时序分析 EDA 工具；研究超低电压条件下电路时序分布模型，关键时序路径的快速选取方法，关键路径的高精度仿真方法，关键路径时序良率分析方法，关键路径时序统计分析方法和电压灵敏度分析方法，以及大规模电路的时序并行化分析方法。 0.2 考核指标 实现超低电压高精度时序分析 EDA 工具； 支持40nm 及以下先进工艺，电路规模≥1000 万门，支持宽幅、变工作电压的时序分析（0.6×VDD~1.1×VDD，10 个电压节点以上， 其中 VDD 是指集成电路工艺对应的标准电源电压）； 单条关键路径的延时统计分析相比 6 sigma 蒙特卡洛仿真误差≤5%，速度提升≥1000 倍； 基于该工具实现应用示范，支持 2 款以上超低电压芯片的设计流片。 1 基于低秩张量近似的高维良率分析1.1 研究背景及价值1.1.1 研究背景随着工艺的发展，晶体管特征尺寸的不断减小给集成电路性能和功耗带来了巨大改善，但同时电路稳定性受工艺、电压和温度(PVT)等影响下的随机工艺偏差的影响日益严重，良率成为继性能、功耗和面积(PPA)后电路设计中的又一个性能参数。如何快速准确预估电路的良率，已经成为电子设计自动化面临的主要问题。纳米制造工艺的变化及其对产品良率的影响的问题是现有28nm/20nm以下平面CMOS和16nm 以下FinFET技术的集成电路设计的主要挑战之一。 一方面，当接近器件几何的原子极限时，如随机掺杂剂波动和线边缘粗糙度的局部随机变化变得越来越显著，有很多电路单元都会很容易受这些变化的影响，比如数据转换器，PLL，I/O和存储器电路等；另一方面，先进工艺下晶体管模型更精确，电路系统更复杂，受工艺影响的参数更多，具有明显的高维特性，该特性也极大地增加了电路良率分析的难度。 电路维度定义为电路可变参数的数量，如图1所示，一个6T SRAM bitcell中有6个管子，对每个管子的阈值电压Vth，关断电压Voff和迁移率μ 三个参数建模为独立高斯变量，则一个bitcell 的可变维度为6*3=18维 更贴合实际的，如图2所示，将SRAM bitcell组合成SRAM 阵列，随着电路的规模增大，电路可变参数的数量变多，例如含有N=32个SRAM bitcell的阵列的维度为 $ 32 \times 6 \times 3 = 576 $ 维，这在电路良率分析中为高维场景。 本课题针对由随机工艺偏差导致的高维电路失效问题，对受工艺偏差影响的电路参数进行建模，结合低秩张量近似理论和机器学习领域的相关算法，准确分析工艺偏差影响下的电路良率，实现在流片之前准确预估芯片的良率，并以此优化电路设计以满足良率要求，可以节约不必要的流片成本和缩短设计周期 1.1.2 研究价值工艺偏差会直接造成电路性能的波动及可怕的良率损失，如果电路的良率无法提前获得快速准确的预测，更先进的工艺开发技术将要花费极大的时间代价，甚至无法实现。实现快速准确地预估电路的良率，可以加快电路设计，降低成本及推动工艺继续向前发展。 目前芯片设计一般通过使用多种工艺和有较大安全余量的工艺角以达到电路功能上的实现，但这个余量是以降低芯片性能和增加功耗为代价的，同时也是不可靠的，因为它无法给出电路的真实良率。同时这种设计方式可能导致过度设计，进而转化为对芯片性能和面积的浪费。而如果追求更小的尺寸，更高的性能和最低的功耗，这种仅提供了一个可行的工程解决方法的设计方法将不再适用。 先进工艺复杂系统的背景下，由于集成电路设计受工艺偏差影响巨大，当前集成电路设计方法学已经过渡到以良率驱动的设计方法学。考虑性能、功耗、面积和良率四维目标的联合优化问题，而在设计阶段准确预测电路良率是良率驱动设计方法学的核心，具有指导和优化电路设计的重要作用。 1.2 国内外研究现状、发展动态针对电路良率分析的问题，蒙特卡洛(Monte Carlo, MC)采样分析方法是值得信赖的黄金标准。因为它具有一些非常重要的属性，包括准确性，一致性和变量数量的可扩展性。在MC分析中，从模型库中的分布中抽取模型参数的随机样本，并对每个样本运行SPICE仿真，从而得到性能指标的输出分布。 给定一个电路性能的指标，如延迟或功率，根据指标定义一个电路的失效阈值，这就是电路良率的界限。根据失效阈值通过概率论的知识去确定失效概率，从而确定良率。而MC应用到电路良率中，通俗来说，就是仿真模拟电路里的每一个样本，将每一个样本都和失效阈值比较，将样本分为pass/fail，最后的失效率就是fail的样本除于总样本。 MC分析的误差随着样本数量的增加以 $1/ \sqrt{N}$ 的速率下降，最终可以得到非常可靠的结果。MC具有其他统计方法所没有的非常关键的性质： 无偏估计：无偏估计是统计方法的一个非常重要的原则，即可靠地收敛到预期结果。 一致估计：随着样本数量的增加，估计值平稳地收敛到预期值。 误差控制：可以估计误差并进行监视，从而可以可靠地检测到收敛。 如果的估计的是一个非常小的概率，我们将需要一个更大的样本数。 以上1~3是为什么MC是唯一真正可靠的良率分析的黄金标准，而4则是限制MC应用到3-sigma以上（即high sigma）的原因。例如如果估计$1e^{-5}$数量级的失效概率，那么至少需要$1e^7 - 1e^8$数量级的蒙特卡洛仿真次数，才能得到较为准确的良率结果，这显然无法适应快速分析的需求。 国内外有许多研究团队致力于研究快速电路良率分析，并有百余篇相关论文发表。以算法机理归类，主要有以下几种方法： 基于重要采样[MIS,MNIS,Gibbs,HDIS,HSCS, 最高解决维度：70] 优点：在失效区域进行采样，可以极大减少样本数缺点：严重依赖于偏移分布的构建，同时失效样本可能分布在多个失效区域，难以覆盖所有失效区域 基于分类[SB,RSB,Rescope, 最高解决维度： 108] 优点：通过少数的样本建立分类器去刻画失效边界，利用分类器判断未知样本失效情况缺点：失效边界的形状可能不规则，使得建立分类器难度大，在高维时通常需使用降维算法进行维度修剪，不能反映真实维度的影响 基于替代模型[adaptive online surrogate modeling, 最高解决维度：102] 优点：通过少数的样本建立输入工艺参数和输出电路性能的回归关系，利用模型去预测未知样本的电路性能值缺点：现有基于替代模型方法仅应用简单的算法获得回归模型，在高维空间下表现不佳 1.3 研究内容本课题在深入分析和研究国内外相关工作的基础上，针对MC方法所需仿真次数庞大、仿真时间长，以及现有大部分快速良率分析在高维下表现不佳的问题： 基于重要性采样方法在高维空间下，求解空间距离难度大，偏移分布不易获得；基于分类器的方法严重依赖分类器的性能，在高维下难以描绘失效边界等问题。 本项目基于低秩张量近似(Low-Rank Tensor Approximation, LRTA)，提出一种适用于高维电路的的快速良率分析算法，并和现有的方法在速度和精度上作比较。 1.4 技术路线本课题针对高维电路的良率分析问题，提出使用低秩张量近似算法去建立输入工艺参数与输出性能响应之间的关系。基于低秩张量近似的高维电路良率分析，从数学领域首次将张量计算引入到电路良率分析，有效且准确地估计高维及极小概率下电路的良率。首先使用少量样本建立替代模型；然后用替代模型去判断大量样本的预测值，并根据预测值估计良率。使用张量近似算法，可以极大减小所需的SPICE仿真次数。 由于电路失效概率一般比较小且在参数空间尾部，采用随机采样可能无法包含任何失效样本，因此首先使用方差缩放采样策略采集训练样本，以保证采样样本尽可能覆盖整个参数空间。 然后使用交叉验证选择模型的参数，之后利用低秩张量理论及多项式基函数对输入工艺参数展开，利用带有稀疏正则化的交替最小二乘法求解该近似模型的系数, 另外设计了自适应采样框架以进一步减少所需样本量。 最后得到输入参数和输出响应的回归模型。 在建立低秩张量近似模型 $y=\mathrm{M}(X)$ 去映射输入工艺参数和输出电路性能之后，通过该模型替代实际的SPICE电路仿真，可以获得每个输入样本的近似电路性能 $\hat{y}$ ，于是可进行快速良率估计。例如当研究的电路性能是SRAM的读失效时，当放电时间大于给定阈值 $T_{threshold}$ 时，SRAM发生读失效。给定未经SPICE的样本集，使用所建立的替代模型，则输出电路性能 $\{y^{(1)},…,y^{(N)}\}$ 被近似电路性能 $\{\hat{y}^{(1)},…,\hat{y}^{(N)}\}$ 代替，同样使用 $T_{threshold}$ 作为失效阈值。当近似电路性能大于阈值时，发生读失效，根据失效个数可以计算失效概率。 1.5 关键难点及解决方案1.5.1 训练样本的来源在电路良率问题中，失效样本一般为小概率事件，如果采用传统的MC随机采样策略，采集的训练样本可能过于集中无法有效地包含失效样本，这导致最终训练得到的模型对失效区域样本预测能力弱。本课题拟采用方差缩放采样策略，核心思想是从一个方差不断增大的分布中采取样本，这可以保证训练样本能尽可能地覆盖整个参数空间。 1.5.2 LRTA模型的建立本课题旨在建立高维空间下输入工艺参数与输出响应之间的映射关系，由于电路参数众多，采用传统多项式拟合方法难以保证拟合效果。本文引入低秩张量及多项式基函数展开的方法建立输入输出之间的模型，设 $X=[x_1,x_2,…,x_d]$ 为d维独立随机变量表示d个工艺参数，使用低秩张量近似可以将输出电路性能 $Y$ 和输入工艺参数X的关系表示为 $R$ 个一阶张量积的和：\begin{equation}Y=M(X)=\sum_{i=1}^{R} b_{l} w_{l}(X)\end{equation}其中\begin{equation}w_{l}(X)=\prod_{i=1}^{d} v_{l}^{(i)}\left(x_{i}\right)\end{equation} $b_l$为归一化系数，$w_l$为输入参数X的一阶张量积，$ v_{l}^{(i)}$为参数$x_i$的概率密度函数。 为了获得$Y=M(X)$的具体解析式，将每个输入参数的概率密度函数使用正交基函数展开，即\begin{equation}v_{l}^{(i)}\left(x_{i}\right)=\sum_{k=0}^{p i} z_{k, l}^{(i)} p_{k}^{(i)}\left(x_{i}\right)\end{equation} 其中$p_{k}^{(i)}$为参数$x_i$的第$k$阶展开式， $z_{k, l}^{(i)}$为展开式 $p_{k}^{(i)}$的系数，$p_i$为最大展开阶数。 联合以上几式，则模型$Y=M(X)$可以表示为：\begin{equation}Y=M(X)=\sum_{i=1}^{R} b_{l}\left(\prod_{i=1}^{d} v_{l}^{(i)}\left(x_{i}\right)\right)=\sum_{i=1}^{R} b_{l}\left(\prod_{i=1}^{d}\left(\sum_{k=0}^{pi} z_{k, l}^{(i)} p_{k}^{(i)}\left(x_{i}\right)\right)\right)\end{equation} 根据输入参数的特性选取适合的多项式基函数对输入变量的概率密度函数进行展开，以得到最好的近似效果。常用的多项式基函数如表2所示，由于每个工艺参数都服从独立的高斯分布，所以本文使用Hermite多项式对输入工艺参数进行展开。 表2 常用的多项式基函数 1.5.3 LRTA模型的求解将输出电路性能$Y$表示为输入参数$X$的$R$个一阶张量积近似后，对应的模型为： \begin{equation}Y=M(X)=\sum_{i=1}^{R} b_{l} w_{l}(X)\end{equation}\begin{equation}w_{l}(X)=\prod_{i=1}^{d}\left(\sum_{k=0}^{p i} z_{k, l}^{(i)} p_{k}^{(i)}\left(x_{i}\right)\right)\end{equation} 给定一组工艺参数样本$X=\{x^{(1)},…,x^{(N)}\}$及对应输出$Y=\{y^{(1)},…,y^{(N)}\}$，通过先后建立一阶张量积$w_l$和计算$b_l$对以上模型求解。求解过程主要分为一系列校正和更新步骤。 例如，第$I_r$阶段，建立一阶张量$w_r$，更新归一化系数$\{b_1,b_2,…,b_r\}$。 校正阶段：在第$I_r$阶段，一阶张量$w_r$通过求解一下最小化问题建立：\begin{equation}w_{r}(X)=\min _{\omega \in W}\left|M-M_{r-1}-\omega\right|_{\varepsilon}^{2}\end{equation} 其中$M_{r-1}$为第$I_{r-1}$阶段的近似模型，$w$为第$I_{r-1}$阶段后的近似残差，第$r$阶段的目的是求解建立与$w$的近似误差最小的$w_r (X)$。 使用交替最小二乘(ALS)求解$w_r (X)$中的多项式系数$z_r$ ，ALS求解维度$i \in \{1,2,…,d\}$的系数$z_{r}^{(i)}$时，将剩余维度的系数$\left\{z_{r}^{(j)}\right\}_{i \neq j}$ 固定在当前值，这使得每一次需要求解的未知数个数很小。具体如下式：\begin{equation}z_{r}^{(i)}=\min _{\xi \in \mathbb{R}^{p_i+1}}\left|M-M_{r-1}-c^{(i)}\left(\sum_{k=0}^{p i} \xi_{k} p_{k}^{(i)}\left(x_{i}\right)\right)\right|^{2}_{\varepsilon}\end{equation} 其中$c^{(i)}$为固定在当前值的维度：\begin{equation}c^{(i)}\left(x_{1}, \ldots x_{i-1}, x_{i+1}, \ldots, x_{d}\right)=\prod_{j \neq i} v_{r}^{(j)}\left(x_{j}\right)=\prod_{j \neq i}\left(\sum_{k=0}^{pj} z_{k, r}^{(j)} p_{k}^{(j)}\left(x_{j}\right)\right)\end{equation} 上式中仅含有$(p_j+1)$个未知数，而由于输入器件参数服从高斯分布且相互独立，因此使用Hertime对其展开时，Hertime多项式的阶数一般不超过10。因此多项式系数$z_{r}^{(i)}$使用最小二乘算法很容易求解。 校正阶段会循环迭代地求解维度 $i \in \{1,2,…,d\}$的系数 ，将第$I_r$次迭代过程的残差定义为：\begin{equation}E r r_{r}=\left|M-M_{r-1}-\omega\right|^{2}\end{equation} 通过给定两次迭代的误差阈值$\Delta \mathrm{Err}_{\mathrm{min}}$及最大迭代次数$I_{max}$，校正阶段的停止条件是第$I_r$次与第$I_{r-1}$次迭代的误差$\Delta \mathrm{Err}$小于给定误差或者超出最大迭代次数。 更新阶段：当完成校正阶段$I_r$，建立一阶张量$w_r$后，需要求解第$1,2,…,I_r$阶段的归一化系数$b=\{b_1,b_2,…,b_r\}$，归一化系数通过最小化模型的误差求得，即：\begin{equation}b=\min _{\beta \in \mathbb{R}}\left|M-\sum_{l=1}^{r} \beta_{l} \omega_{l}\right|_{\varepsilon}^{2}\end{equation} 在每次更新阶段，归一化系数长度增加1，这是由于在第$I_r$阶段，$b_r$才第一次确定，而第$1,2,..,I_{r-1}$阶段的归一化系数 $\left\{\beta_{1}, \ldots, \beta_{r-1}\right\}$被更新。训练低秩张量近似模型需要迭代地进行多次校正和更新阶段，在第$r$次校正迭代，需要求解$d$个复杂度为$(p_i+1)$的最小化问题；在第$r$次更新阶段，需求解$1$个复杂度为$r$的最小化问题。因此每个迭代阶段的总体复杂度仅为$(pi+1)d$，与维度$d$呈线性关系，可以有效地解决高维问题。 1.5.4 张量阶数R和多项式展开阶数p的选择在实际的应用中，我们一般不会事先知道一阶张量积的个数$R$，及各维度的展开阶次$p_i$的最佳取值，因此我们给定最大$R_{max}$和$p_{max}$，通过3-折交叉验证的方法选择最优的$R$及$p$，选取使验证误差最小的$R$和$p$作为最优参数。 1.5.5 防止模型过拟合和其他回归的方法类似，低秩张量近似算法也可能发生过拟合，特别是当所给训练样本集太小时。在进行求解系数时，通过引入正则化方法，可以有效防止过拟合，增强模型泛化能力，提升鲁棒性，本文选用的正则项为L1范数，L1范数可以使一些回归系数置0，可以消除了噪声等干扰因素的影响，加入正则化后的优化目标函数为：\begin{equation}z_{r}^{(i)}=\min _{\xi \in \mathbb{R}^{p_i + 1}}\left|M-M_{r-1}-c^{(i)}\left(\sum_{k=0}^{p i} \xi_{k} p_{k}^{(i)}\left(x_{i}\right)\right)\right|_{\varepsilon}^{2}+\lambda P(\xi)\end{equation} \begin{equation}b=\min _{\beta \in \mathbb{R}^{r}}\left|M-\sum_{l=1}^{r} \beta_{l} \omega_{l}\right|_{\varepsilon}^{2}+\lambda P(\beta)\end{equation} 其中$\lambda$为正则化系数，$P(u)$是$u$的L1范数。 1.5.6 自适应采样策略自适应采样将训练过程分为若干个迭代，接下来根据设定的加点策略在每个周期增加样本，以动态地调节模型拟合能力，我们采样的加点策略是将参数空间划分成若干个子区域，计算每一个区域的误差，并根据这些误差计算出权重，然后根据权重在不同的区域生成样本，用来增强该区域的拟合能力。这样可以使每一个样本对模型精度的提升效果最大化。同时可以清楚地看到每一次迭代模型的精度，有利于了解模型的收敛情况。 1.6 结果 低维下比同类方法快 6~9 倍，高维下比标准蒙卡快 2150 倍， 相对误差仅为 2.4%。该算法复杂度仅随维度线性增长， 有效解决了高维良率分析中遇到的 “维度诅咒” 问题。 论文 Meta-Model based High-Dimensional Yield Analysis using Low-Rank Tensor Approximation (Full paper PDF) 投稿到 ACM/IEEE Design Automation Conference (DAC) 2019 (CCF-B 类会议, 设计自动化领域顶级会议), 已录用. 目前在此基础上进行改进, 计划投稿到 IEEETCAD(CCF-A 类期刊). like to the codes.]]></content>
      <categories>
        <category>Project Experience</category>
      </categories>
      <tags>
        <tag>Project Experience</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-字典树]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 字典树字典树，即Trie树，又称单词查找树或键树，是一种树形结构，常用于统计和排序大量字符串等场景（但不限于字符串），且经常被搜索引擎用于文本词频统计。它的优点是最大限度减少无谓的字符串比较，查询效率比较高。Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，已达到提高效率的目的。它有以下三个基本性质： 根结点不包含字符，除根结点外每一个结点都只包含一个字符； 从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。 树的构建举例：题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。现在回到例子中，如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是$O(n^2)$。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的： 如上图所示，从根结点遍历到每个结点的路径就是一个单词，如果这个结点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，只要顺着它从根走到对应的结点，再看这个结点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成我们可以看到，trie树每一层的节点数是$26^i$级别的。为了节省空间，还可以动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数乘以单词长度。声明：本文为博主原创文章，转载请附上博文链接！ 查询Trie树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的AJAX搜索框时，就是Trie开始。本质上，Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie： 可以看出： 每条边对应一个字母。 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。 单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。 查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。 搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步：考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。 问题实例 Q. 10个频繁出现的词： 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。A. 用Trie树统计每个词出现的次数，时间复杂度是$O(nl)$（$l$表示单词的平均长度，最终用最小堆找到出现次数最频繁的10个词，时间复杂度为$O(nlog10)$ 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有1000万个记录，这些查询串的重复度比较高，虽然总数是1000万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。A. 可以使用Trie树，观察关键字在该查询串出现的次数，若没有出现则为0，最后用10个元素的最小堆来对出现频率进行排序。 参考文献：从Trie树（字典树）谈到后缀树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-赫夫曼树及赫夫曼编码]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 赫夫曼树先看如下两棵树： 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。 二叉树 a 中， 根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。 树的路径长度就是从树根到每一结点的路径长度之和 。 二 叉树 a 的树路径长度就为 1+1+2+2+3+3+4+4=20。二叉树 b 的树路径长度就为1+2+3+3+2+1+2+2=16。 考虑到带权的结点，结点的带权的路径长度为该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值$\{w_1,w_2,…,w_n\}$，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 $W_k$，每个叶子的路径长度为 $l_k$，则其中带权路径长度(WPL)最小的二叉树称做赫夫曼树，也称为最优二叉树。 二叉树 a 的 $WPL=5 x 1+15 x 2+40 x 3+30 x 4+10 x 4 = 315 $ 二叉树 b 的 $WPL=5 x 3+ 15 x 3+40 x 2+30 x 2+ 10 x 2 = 220 $ 2 赫夫曼树构造方法 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即 :A5，E10 , B15 , D30, C40。 取头两个最小权值的结点作为一个新节点 N1的两个子结点， 注意相对较小的 是左孩子，这里就是 A 为 N1 的左孩子， E 为 N1的右孩子，如图 6-12-5 所 示。新结点的权值为两个叶子权值的和 5+10=15。 将 N1替换 A 与 E，插入有序序列中， 保持从小到大排列。 即: N1-15, B-15 , D-30, C-40。 重复步骤 2. 将 N1 与 B 作为一个新节点 N2的两个子结点。 如图 6-12-6 所 示。 N2 的权值=15+15=30。 将 N2 替换 N1 与 B ，插入有序序列中， 保持从小到大排列。 即: N2-30 , D-30, C-40。 重复步骤 2. 将 N2 与 D 作为一个新节点 N3 的两个子结点。 如图 6-12-7 所示。 N3 的权值=30+30=60。 将 N3替换 N2与 D，插入有序序列中，保持从小到大排列。即 : C-40 , N3-60。 重复步骤 2。将 C 与 N3 作为一个新节点 T 的两个子结点，如图 6-12-8 所示。 由于 T 即是根结点，完成赫夫曼树的构造。 构造赫夫曼树的赫夫曼算法描述： 根据给定的 n 个权值$\{w_1,w_2,…,w_n\}$构成 n 棵二叉树的集合 $F = \{T_1,T_2,…,T_n\}$， 其中每棵二叉树 $T_i $中只有一个带权为 $W_i$根结点，其左右子树均为空。2 . 在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且 置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。3 . 在 F 中删除这两棵树，同时将新得到的二叉树加入 F 中。 重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。 3 赫夫曼编码用于压缩和解压缩文件，把要压缩的文本进行重新编码，以减少不必要的空间。比如我们有一段文字内容为 “BADCADFEED” 要网络传输给别人，显然用二进制 的数字 (0 和 1) 来表示是很自然的想法。我们现在这段文字只有六个字母 ABCDEF，那么我们可以用相应的二进制数据表示： 这样真正传输的数据就是编码后的 “001000011010000011101100100011“， 对 方接收时可以按照 3 位划分来译码。效率低下。 根据不同词频使用赫夫曼树重新编码。 假设六个字母的频率为 A 27 , B 8, C 15 , D 15 , E 30, F 5 ，合起来正好是 100%。 那就意味着，我们完全可以重新按照赫夫曼树来规划它们。 以下左图为按照第2节的赫夫曼树构造方法得到的赫夫曼树，右图为将所有左分支改为0，右分支改为1后的赫夫曼树。 对着六个字母重新编码如下： 我们将文字内容为 “BADCADFEED” 再次编码，对比可以看到结果串变小了 。 原编码二进制串 :001000011010000011101100100011(共30个字符) 新编码二进制率: 1001010010101001000111100(共 25 个字符) 数据被压缩了。 4 赫夫曼解码前缀编码：编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。 在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。 当我们接收到 1001010010101001000111100 时，按约定好的赫夫曼树可知， 1001 得到第一个字母是 B，接下来的01意味着第二个字符是 A，如图 6-12-10 所示， 其余的也相应的可以得到，从而成功解码。 5 赫夫曼编码定义一般地，设需要编码的字符集为$\{d_1,d_2,…,d_n\}$，各个字符在电文中出现的次数或频率集合为$\{w_1,w_2,…,w_n\}$ ，以 $d_1,d_2,…,d_n$作为叶子结点，以 $w_1,w_2,…,w_n$ 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1， 则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-串的模式匹配]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 朴素的模式匹配算法对主串的每一个字符作为子串开头，与要匹配的字符串进行匹 配。对主串做大循环，每个字符开头做 子串 的长度的小循环，直到匹配成功或全部遍历完成为止。 Python实现：123456789101112131415161718def index(S,T): if len(T)&gt;len(S): return False i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if S[i] == T[j]: i += 1 j += 1 else: i = i-j+1 j = 0 if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': result = index('goodgoogle','google') print(result) 时间复杂度： 最坏情况：一开始就匹配成功，时间复杂度为$O(1)$； 稍差一些：如果每次都是首字母就不匹配，那么对子串的循环就不必进行了，时间复杂度为$O(n+m)$，其中 n 为主串长度， m 为要匹配的子串长度； 平均情况：根据等概率原则，平均是 $(n+m) /2$ 次查找，时间复杂度为 $O(n+m)$； 最差情况： 每次不成功的匹配都发生在子串 的最后一个字符，时间复杂度为 $O((n- m+ 1)*m)$。 2 KMP模式匹配算法通过对模式串(子串)的一个预处理，将时间复杂度减少到了一个线性的水平。 举例：首先我们有主串：acabaabaabcacaabc，有模式串：abaabcac，现在假设我们匹配到了如下的图的步骤： 现在模式串的第六个字符和主串匹配不上了，那么现在我们就需要把模式串往右移动，并且重新选择主串和模式串的比较位置重新开始比较。 朴素模式匹配的做法是直接把子串向右移动一位，然后，主串的第四个字符和我们模式串的第一个字符重新开始做比较。 但是其实主串的第三个字符到第六个字符我们都是已经和模式串做过比较的，而且我们知道他们的各个位置上的内容是什么，那么为什么不把这些已经知道的信息充分利用起来了？比如：我们知道模式串中红色的两个字符和绿色的两个字符是相等的，而且红色的两个字符正好是模式串开始的两个字符，所以我们可以直接把模式串向右移动四位，然后，我们主串从刚才发现不匹配那个字符位置开始和模式串的第三个位置比较，这样我们就可以减少五次比较。 这个时候，我们就需要对我们的模式串做一个预处理，通过预处理我们可得到一个next数组，它保存的就是当我们在模式串某个位置匹配失败后，应该从模式串的哪个位置重新开始比较。 12345678910111213141516171819202122232425262728293031323334def get_next(T): #KMP next = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 next.append(j) else: j = next[j-1] return nextdef index(S,T): if len(T)&gt;len(S): return False next = get_next(T) i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if j == 0 or S[i] == T[j]: i += 1 j += 1 else: j = next[j-1] if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': next = get_next('ababaaaba') print(next) result = index('ababaabc','abc') print(result) 改进的KMP模式匹配算法如果模式串中的当前位置的字符与前缀字符相等，则将该前缀字符的next值赋给当前next值。 123456789101112131415def get_nextval(T):#改进的KMP nextval = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 if T[j-1] != T[i-1]: nextval.append(j) else: nextval.append(nextval[j-1]) else: j = nextval[j-1] return nextval 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 排序算法]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 排序假设含有n个记录的序列为${r_1,r_2,…,r_n}$，其相应的关键字分别为$(k_1,k_2,…,k_n)$，需确定$1,2,…,n$的一种排列$p_1,p_2,…,p_n$,使其相应的关键字满足$K_{p1} \leq k_{p2} \leq … \leq k_{pn}$关系，即使得序列成为一个按关键字有序的序列${r_{p1},r_{p2},…,r_{pn}$，这样的操作就称为排序。 1.1 排序的稳定性假设$k_i = k_j (1 \leq i \leq n，1 \leq j \leq n，i \neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i＜j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。 1.2 内排序与外排序内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要内外存之间多次交换数据才能进行。 对于内排序来说，排序算法的性能主要受3个方面影响： 时间性能：内排序中主要进行两种操作，比较和移动。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间：辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性：算法本身的复杂度，而不是指算法的时间复杂度。 内排序按主要操作分类：插入排序交换排序选择排序归并排序 排序按复杂度分类简单算法：冒泡排序，简单选择排序，直接插入排序改进算法：希尔排序，堆排序，归并排序，快速排序 2 常见排序算法2.1 冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 2.1.1 冒泡排序初级版让每一个关键字，都和他后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。123456789def BubbleSort0(L): for i in range(len(L)): for j in range(i+1,len(L)): if L[i]&gt;L[j]: L[i],L[j] = L[j],L[i] return Lif __name__ == '__main__': result = BubbleSort0([9,1,5,8,3,7,4,6,2]) print(result) 2.1.2 冒泡排序正宗版123456789def BubbleSort(L): for i in range(len(L)): for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.3 冒泡排序优化当i=2时，我们已经对9与8,8与7，。。。，3与2作了比较，没有任何数据交换，说明此序列已经有序，不需要再继续后面的循环判断工作了。增加标记变量flag来实现这一算法的改进。12345678910111213def BubbleSort(L): flag = True for i in range(len(L)): if flag: flag = False for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] flag = True return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.4 冒泡排序的算法复杂度：最好情况：要排序的表本身就是有序的，需要$n-1$次比较，没有数据交换，时间复杂度为$O(n)$。最坏情况：待排序表示逆序的情况，需要比较$1+2+3+…+(n-1) = n(n-1)/2$次，并做等数量级的记录移动，总时间复杂度为$O(n^2)$. 2.2 简单选择排序通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i,(1≤i≤n)$个记录交换之。123456789101112def SelectSort(L): for i in range(len(L)): min = i for j in range(i+1,len(L)): if L[j] &lt; L[min]: min = j if min != i: L[i],L[min] = L[min],L[i] return Lif __name__ == '__main__': result = SelectSort([9,1,5,8,3,7,4,6,2]) print(result) 2.2.1 简单选择排序复杂度分析简单选择排序最大的特点是交换移动数据次数相当少。无论最好最差的情况，其比较次数都是一样多，第$i$躺排序需要进行$n-i$次关键字的比较，需要比较$(n-1)+(n-2)+…+1 = n(n-1)/2$次;而对于交换次数而言，最好的时候交换0次，最坏时候交换n-1次。总的时间复杂度仍为$O(n^2)$。性能略优于冒泡排序 2.3 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。12345678910111213def InsertSort(L): for i in range(1,len(L)): if L[i] &lt; L[i-1]: temp = L[i]#设置哨兵 k = i while temp &lt; L[k-1] and k &gt;= 1: L[k] = L[k-1]#记录后移 k -= 1 L[k] = temp#插入到正确位置 return Lif __name__ == '__main__': result = InsertSort([9,1,5,8,3,7,4,6,2]) print(result) 2.3.1 直接插入排序复杂度分析 空间复杂度：只需要一个记录的辅助空间，$O(1)$ 最好时间复杂度：待排序表是有序时，n-1次比较，0次移动，复杂度为$O(n)$ 最坏时间复杂度：待排序表示逆序时，需要比较$2+3+…+n=(n+2)(n-1)/2$次，移动$(n+4)(n-1)/2$次。 平均比较和移动次数$n^2/4$次。总的时间复杂度为$O(n^2)$，直接插入排序法比冒泡和简单选择排序的性能要好一些。 2.4 希尔排序希尔排序算法是突破O(n^2)这个时间复杂度的第一批算法。采用跳跃分割的策略：将相距某个“增量”的记录组成一个字序列，这样才能保证在子序列内分别进行插入排序后得到的结果就是基本有序而不是局部有序。 123456789101112131415def ShellSort(L): increment = len(L) // 2 while increment &gt; 0: for i in range(increment,len(L)): temp = L[i] k = i - increment while temp &lt; L[k] and k &gt;= 0: L[k+increment] = L[k] k -= increment L[k+increment] = temp increment = increment // 2 return Lif __name__ == '__main__': result = ShellSort([9,1,5,8,3,7,4,6,2]) print(result) 2.4.1 希尔排序复杂度分析增量的选取很关键，迄今为止还没有人找到一种最好的增量序列。增量序列的最后一个增量值必须等于1才行，由于记录是跳跃式的移动，希尔排序并不是一种稳定的算法。时间复杂度为$O(n^{3/2})%。优于直接排序的$O(n^2)$。 2.5 堆排序堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如果按照层序遍历的方式给结点从1进行编号，则结点之间满足以下关系： 2.5.1 堆排序算法堆排序就是利用堆（假设利用大顶堆求升序）进行排序的方法，他的基本思想是：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。1234567891011121314151617181920212223def HeapSort(L): for i in range(len(L)//2,-1,-1): HeapAdjust(L,i,len(L)) for j in range(1,len(L))[::-1]: L[j],L[0] = L[0],L[j] HeapAdjust(L,i,j) return Ldef HeapAdjust(L,parent,length): temp = L[parent] child = 2*parent+1 while child &lt; length: if child+1&lt;length and L[child]&lt;L[child+1]: child += 1 if temp &gt;= L[child]: break L[parent] = L[child] parent = child child = 2*parent+1 L[parent] = tempif __name__ == '__main__': result = HeapSort([9,1,5,8,3,7,4,6,2]) print(result) 2.5.2 堆排序复杂度分析运行时间主要消耗在初始构建堆和重建堆的反复筛选。 构建堆的时间复杂度为$O(n)$ 重建堆的时间复杂度为$O(nlogn)$ 总的时间复杂度为$O(nlogn)$ 空间复杂度，只需要一个用来交换的暂存单元，$O(1)$。 2.6 归并排序归并排序的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到[n//2]个长度为2或1的有序子序列；再两两合并，…，如此重复，直至得到一个长度为n的有序序列为止，这种方法称为2路归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940def MergeSort(L): temp = [0]*len(L) MSort(L,temp,0,len(L)-1) return Ldef MSort(L,temp,left,right): if left &gt;= right: return mid = (left+right)//2 MSort(L,temp,left,mid) MSort(L,temp,mid+1,right) Merge(L,temp,left,mid,right)def Merge(L,temp,left,mid,right): l,r = left,mid+1 k = 0 while l &lt;= mid and r &lt;= right: if L[l]&lt;L[r]: temp[k] = L[l] l += 1 else: temp[k] = L[r] r += 1 k += 1 while l &lt;= mid: temp[k] = L[l] l+=1 k+=1 while r &lt;= right: temp[k] = L[r] r += 1 k += 1 k = 0 while left &lt;= right: L[left] = temp[k] left += 1 k += 1 if __name__ == '__main__': result = MergeSort([9,1,5,8,3,7,4,6,2]) print(result) 2.6.1 归并排序复杂度分析一趟归并需要将待排序序列中的所有记录扫描一遍，耗费$O(n)$时间，而由完全二叉树的深度可知，整个归并排序需要进行$[log2^n]$次，因此总的时间复杂度为$O(nlogn)$，而且这是归并排序算法中最好、最坏、平均的时间性能。由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$log2^n$的栈空间，因此空间复杂度为$O(n+logn)$。由于Merge函数中有$if L[l]&lt;L[r]$语句，说明需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。归并排序是一种比较占用内存，但效率高且稳定的算法。 2.7 快速排序快速排序的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 1234567891011121314151617181920212223def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) Partition 函数要做的，就是先选取当中的一个关键字，比如选择第一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴( pivot) 。 2.7.1 快速排序复杂度分析快速排序的时间性能取决于快速排序递归的深度。 在最优情况下,Partition每次划分都很均匀，如果排序n个关键字，其递归树的深度就为$[log2^n]+1$，仅需递归$log2^n$次，需要时间为$T(n)$的话，第一次Partition应该是对整个数组扫描一遍，做n次比较。然后获得的枢轴将数组一份为二，那么各自还需要$T(n/2)$的时间。 在最优的情况下，快速排序算法的时间复杂度为$O(nlogn) $。 最坏时间复杂度为$O(n^2)$。 空间复杂度主要是递归造成的栈空间的使用: 最好情况，递归树的深度为$log2^n$ ，其空间复杂度也就为$O(logn)$ 最坏情况，需要进行$n - 1$ 递归调用，其空间复杂度为$O(n)$ 平均情况， 空间复杂度也为$O (logn) $。 由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 2.7.2 快速排序优化2.7.2.1 优化选取枢轴三数取中：即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数。三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey ，123456789101112131415161718192021222324252627282930def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.2 优化不必要的交换1234567891011121314151617181920212223242526272829303132def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] temp = pivotkey while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low] = L[high] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[high] = L[low] L[low] = temp return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.3 优化小数组时的排序方案2.7.2.4 优化递归操作2.8 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 2.8.1 桶排序复杂度分析假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果 对每个桶中的数字采用快速排序，那么整个算法的复杂度是$O(n + m n/mlog(n/m)) = O(n + nlogn - nlogm) $ 当m接近n的时候，桶排序复杂度接近$O(n)$。前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是： 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 其次待排序的元素都要在一定的范围内。 桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 参考 2.8.2 桶排序实现桶排序求前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路 使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路 桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result) 3 总结 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 哈希表]]></title>
    <url>%2F2019%2F05%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 散列表散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。即:存储位置=f(关键字)采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表，关键字对应的记录存储位置称为散列地址。散列技术既是一种存储方法，也是一种查找方法。它也线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字关联。因此，散列主要是面向查找的存储结构，适合求解的问题是查找与给定值相等的记录。 1.1 散列冲突每个关键字 $key1 \not= key2$，但却有$f(key1) = f(key2)$，这种现象称为冲突，并把key1和key2称为这个散列函数的同义词。出现了冲突当然非常糟糕，那将造成数 据查找错误。 2 散列函数的构造方法2.1 构造原则 计算简单。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。 散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，并减少为处理冲突而耗费的时间。 2.2 构造方法2.2.1 直接定址法取关键字的某个线性函数值为散列函数，即：$f(key) = a * key + b$，（a、b为常数） 优点是简单、均匀、不会产生冲突 缺点是需要首先知道关键字的分布情况，适合查找表较小且连续的情况 2.2.2 数字分析法基于抽取的方法，即使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布 且关键字的若干位分布较均匀，就可以考虑用这个方法。 2.2.3 平均取中法先对关键字求平方，在抽取中间的k位作为散列地址。比如关键字是 1234， 那么它的平方就是 1522756，再抽取中间的 3 位就是 227 ，用做散列地址。适合于不知道关键字的分布，且位数不是很大的情况。 2.2.4 折叠法将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够 时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如我们的关键字是 9876543210 ，散列表表长为三位，我们将它分为四组， 9871654132110， 然后将它们叠加求和987+654+321+0=1962，再求后 3 位得到散列 地址为 962。有时可能这还不能够保证分布均匀 ， 不妨从一端向另一端来回折叠后对齐相加。 比如我们将 987 和 321 反转，再与 654 和 0 相加， 变成 789+654+123+0=1566，此时散列地址为 566.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。 2.2.5 除留余数法对于散列表长为m的散列函数公式为：$f(key) = key mod p, (p \leq m)$不仅可以对关键字直接取模，还可在折叠、平方取中后再取模。 2.2.6 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址。即：$f (key) =random (key)$这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 3 散列冲突的处理方法3.1 开放定址法 (线性探测法)一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1,2,3,…,m-1)$ 堆积：两个关键字同时争夺同一个地址。此时需要不断处理冲突，降低存入和查找的效率。 解决方法1：二次探测法，增加平方运算使关键字尽可能分散。即：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1^2, -1^2, 2^2, -2^2 ,…,q^2, -q^2, q \leq m/2)$ 解决方法2：随机探测法，在冲突时，对于位移量 $d_i$，采用随机函数计算得到。即：$f_i (key) = (f(key) + d_i) mod m, d_i )$是一个随机数列 3.2 再散列函数法换一个不同的函数重新计算散列地址。$f_i (key) = RH_i(key), i=1,2,…,ki )$$RH_i$为不同的散列函数，如除留余数、折叠、平方取中等。 3.3 链地址法不存在冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。但带来了查找时需要遍历单链装的性能损耗。 3.4 公共溢出区法为所有冲突的关键字建立一个公共的溢出区来存放。查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对， 如果相等，则查找成功； 如果不相等，则到溢出表去进顺序查找； 如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。 4 散列表查找性能时间复杂度为O(1)。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 贪心算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是贪心算法相关题目题解总结。 [TOC] 贪心思想概念 最优子结构：最优子结构反映了分解问题的方式，我们在解决问题的时候，都会尝试将问题分解进行解决，产生的子问题，进而会产生局部解（总体解的子结构）。通常而言局部解也不仅只有一个，当局部解是局部最优解，并且该局部最优解是全局最优解的一部分时，我们称子问题的最优解为最优子结构。 最优子结构的性质：问题的最优解由相关自问题的最优解组合而成，而这些子问题可以独立求解。（需要注意这里独立求解的含义：当前最优，不考虑后面的步骤）；最优子结构的形式（或者是否有最优子结构）取决于你分解问题的方式。合理的分解达到的效果是：与最终问题的目标存在紧密的关系。如果分解问题之后却无法导出最终问题的解，那么这种问题分解的方式就是无意义的。 基本思想 贪心算法的基本思想是找出整体当中每个小的局部的最优解，并且将所有的这些局部最优解合起来形成整体上的一个最优解。因此能够使用贪心算法的问题必须满足下面的两个性质： 整体的最优解可以通过局部的最优解来求出； 一个整体能够被分为多个局部，并且这些局部都能够求出最优解。使用贪心算法当中的两个典型问题是活动安排问题和背包问题。 主要步骤 建立对问题精确描述的数学模型，包括定义最优解的模型； 将问题分解为一系列子问题，同时定义子问题的最优解结构； 应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路设置最大和maxsub = nums[0]，中间和temp = 0；遍历数组加到temp中，若temp &gt; maxsub，则更新最大和maxsun；若temp &lt; 0，则置为0从新开始。 1234567891011121314151617class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 maxsub = nums[0] temp = 0 for i in range(len(nums)): temp += nums[i] if temp &gt; maxsub: maxsub = temp if temp &lt; 0: temp = 0 return maxsub 55. 跳跃游戏题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2:123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路贪心。使用一个变量保存当前能到达的最后位置的索引，向后遍历每个位置，如果该位置大于前面能到达的最大位置，则返回False，如果这个位置可以达到，则更新能达到的最后位置索引，更新策略是当前位置索引+这个数字能走多少步和原来能到的最大值。12345678910111213141516class Solution(object): def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 0: return True reach = 0 for i in range(len(nums)): if i &gt; reach: return False reach = max(reach, i+nums[i]) return True 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对数组进行遍历，定义到目前为止最大利润maxsum和加上当前利润的中间利润temp； 如果temp&gt;maxsum，则到目前最大利润maxsum = temp； 如果temp小于0，舍弃，temp = 0。 1234567891011121314151617class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxsum = 0 temp = 0 for i in range(1,len(prices)): temp += prices[i] - prices[i-1] if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ； 因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，从而在局部最优的情况下也保证全局最优。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxp = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: maxp += prices[i] - prices[i-1] return maxp 134. 加油站题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2:12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 解题思路12345678910111213141516171819202122class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ if len(gas) != len(cost) or len(gas) == 0: return -1 start = 0 rest = 0 overall = 0 for i in range(len(gas)): rest += gas[i]-cost[i] overall += gas[i]-cost[i] if rest &lt; 0: rest = 0 start = i+1 return start if overall &gt;= 0 else -1 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = “abc”, t = “ahbgdc”返回 true. 示例 2: s = “axc”, t = “ahbgdc”返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路双指针，遍历两个序列。 1234567891011121314151617181920class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if not s: return True if not t or len(s) &gt; len(t): return False i = j = 0 while i &lt; len(s) and j &lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s)if __name__ == '__main__': result = Solution().isSubsequence("ace","abcde") print(result) 406. 根据身高重建队列题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路 对people进行排序，h越大k越小的在前； 然后按顺序给个高的先排序，因为个高的排好后，再怎么对矮个排序，都不会影响个高人的相对位置。 12345678910111213class Solution(object): def reconstructQueue(self, people): """ :type people: List[List[int]] :rtype: List[List[int]] """ if len(people) &lt;= 1: return people people.sort(key = lambda x:[-x[0],x[1]]) res = [] for i in range(len(people)): res.insert(people[i][1],people[i]) return res 435. 无重叠区间题目描述给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 解题思路区间题目一般按照排序+贪心去求解： 先将区间按照起点升序； 令第一个区间为起始老区间，然后从第二个起进行遍历，如果遍历到的区间的起点比老区间的终点小，说明有重叠； 此时计数并移除区间，移除的为终点大的区间，即将老区间设置为终点小的区间； 如果没有重叠，则更新老区间为当前遍历到的区间。 12345678910111213141516171819202122232425# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def eraseOverlapIntervals(self, intervals): """ :type intervals: List[Interval] :rtype: int """ if len(intervals) &lt;= 1: return 0 intervals = sorted(intervals, key = lambda interval:interval.start) last = 0 count = 0 for i in range(1,len(intervals)): if intervals[i].start &lt; intervals[last].end: count += 1 if intervals[i].end &lt;intervals[last].end: last = i else: last = i return count 452. 用最少数量的箭引爆气球题目描述在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 Example: 输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 解题思路 使用排序+贪心。把所有坐标按照右边界进行排序，因为每个气球都要被打破，初始当前最远的位置curr_pos为第一个坐标的右边界，对坐标进行遍历； 如果当前遍历到的坐标左边界小于curr_pos，则说明有重叠，继续； 否则说明没有重叠，修改curr_pos为当前坐标的右边界，计数加1。 1234567891011121314151617181920class Solution(object): def findMinArrowShots(self, points): """ :type points: List[List[int]] :rtype: int """ if not points: return 0 points.sort(key=lambda x: x[1]) curr_pos = points[0][1] ans = 1 for i in range(len(points)): if curr_pos &gt;= points[i][0]: continue curr_pos = points[i][1] ans += 1 return ansif __name__ == '__main__': result = Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) print(result) 455. 分发饼干题目描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路对孩子胃口值g和饼干尺寸s排序，先用最小的饼干满足最小胃口值的孩子，如果最小饼干满足不了最小胃口值的孩子，则加大饼干值去满足该孩子。 1234567891011121314151617181920class Solution(object): def findContentChildren(self, g, s): """ :type g: List[int] :type s: List[int] :rtype: int """ if len(g)==0 or len(s)==0: return 0 g.sort() s.sort() child = i = 0 while child &lt; len(g) and i &lt; len(s): if s[i] &gt;= g[child]: child += 1 i += 1 return childif __name__ == '__main__': result = Solution().findContentChildren([10,9,8,7],[5,6,7,8]) print(result) 763. 划分字母区间题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1: 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意: S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。 解题思路 用字典记录每个字母在字符串中出现的最右位置； 然后对每个字母和位置进行遍历，找到最靠右位置end； 如果遍历到的当前位置和最靠右位置重合，说明已经找到了一个划分； 更新开始位置start，继续。 1234567891011121314151617181920class Solution(object): def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ if not S: return [] charIndex = &#123;c: i for i, c in enumerate(S)&#125; end = start = 0 ans = [] for i, c in enumerate(S): end = max(end,charIndex[c]) if i == end: ans.append(end-start+1) start = end + 1 return ansif __name__ == '__main__': result = Solution().partitionLabels("ababcbacadefegdehijhklij") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 动态规划]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是动态规划相关题目题解总结。 [TOC] 动态规划递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是动态规划保存了子问题的解，避免重复计算。 动态规划与分治算法类似，都是通过组合子问题的解来求解原问题的： 分治算法将问题划分为互不相关的子问题，再递归地求解子问题，最后将它们的解组合起来，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，需要反复求解那些公共子问题，而动态规划对于每个子子问题只求解一次，将其保存在一个表格里面，从而无需每次求解一个子子问题时都需要重新计算，避免了不必要的计算工作。 动态规划的应用场景 动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。 动态规划的一般步骤 定义一个状态，这是一个最优解的结构特征； 进行状态递推，得到递推公式； 进行初始化； 返回结果。 动态规划的实质就是分治思想和解决冗余。将原来具有指数级复杂性的算法改进成具有多项式时间的算法，这是动态规划算法的目的。由于在实现的过程中，需要存储各种状态，所以它的空间复杂性要大于其他算法，这是一种以空间换时间的技术。 动态规划三要素最优子结构性质、子问题重叠性、自底向上的求解方法。 最优子结构性质 最优子结构性质，就是问题的最优解包含其子问题的最优解。如果不具备该性质，就不能使用动态规划来解决。常用反证法分析论证问题是否具备最优子结构的性质； 有时对某个子问题的解不一定达到最优，但是当把它延伸成整个问题的解时反而成了最优解，这种问题不满足最优子结构性质，无法使用动态规划。 子问题重叠性质 动态规划对每个子问题只求解一次，并把其答案保存在表格里，因此可以避免重复计算； 子问题重叠性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。 自底向上的求解方法由于动态规划解决的问题具有子问题重叠的问题，求解时需要自底向上的方法： 首先选择合适的表格（一维或二维），将递归的停止条件填入表格的相应位置； 然后将问题的规模一级一级放大，求出每一级子问题的最优解，并将其填入表格的相应位置 ； 直到问题所要求的规模，此时求出的便是原问题的最优解。 除了自底向上的方法，还可以使用 “带备忘录的自顶向下方法”。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（用数组或列表保存）。当需要子问题的解时，过程首先检查是否已经保存过此解。如果是，直接返回保存的值，从而节省时间；否则，按通常方式计算这个子问题。这个递归过程是带备忘的，因为它记住了之前已经计算出的结果。 贪婪算法的局限性动态规划的一个关键特点是每次做选择之前，对所有选择的效果进行计算。在计算的结果上选择能够达到最优的选项，从而保证每次选择都是最优的。 但是这种策略在当选项的数量非常巨大的时候将不堪重负。例如下围棋的时候，如果采用动态规划策略，则需要先对每步可能的行棋的影响进行计算，然后比较选择最优的走法。但每一步可行进的走法实在太多，如果再考虑到一盘棋有几乎不计其数的步骤，所以计算任务非常大几乎不可能完成。这种情况就是上面介绍的动态规划的缺点。这个时候应该采用贪婪策略。 贪婪策略运行我们不对所有可能选择的影响计算一遍后作出决策。我们可以在进行选择的时候不进行任何计算，而根据当时的情况作出我们认为最好的选择，这样就避免了大量计算，从而大大提高了算法的效率。 【算法】详解动态规划算法导论——-动态规划是什么 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为： &amp; (i-j&lt;=2 | dp[j + 1][i - 1])) 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路动态规划：当我们想要获得0~n中最大的子串和时，如果0~n-1的连续和小于0，则连续和等于它自己nums[n]，如果为正，则连续和等于它自己加上0~n-1的连续和。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dp = [0]*len(nums) dp[0] = nums[0] for i in range(1,len(nums)): if dp[i-1] &lt; 0: dp[i] = nums[i] else: dp[i] = nums[i] + dp[i-1] return max(dp) temp比0小，那就从开始重新记录 12345678910111213141516171819class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] res = nums[0] temp = 0 for x in nums: temp += x if temp &gt; res: res = temp if temp &lt; 0: temp = 0 return res 讨论区里很精巧的解法。将每一个nums[i]的值，看成是存放前面连续的和大于0的序列；通过遍历，纠正错误存放的值；nums[i]中的每一个数存放的都是序号i前面连续数据的最大和。 123456789101112class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 for i in range(1,len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1] return max(nums) 62. 不同路径题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 解题思路动态规划。 当只有一行或者一列的时候，只有一种方式； 遍历其余位置，每一个位置只能由其左边或上边的元素达到，即迭代公式为: 遍历完成后，dp矩阵存放了每一个位置的走法数，因此返回最后一个数即为所求。 1234567891011121314151617181920class Solution(object): def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m &lt; 1 or n &lt; 1: return 0 if m == 1 or n == 1: return 1 dp = [[1]*n for i in range(m)] for i in range(m): dp[i][0] = 1 for i in range(n): dp[0][i] == 1 for i in range(1,m): for j in range(1,n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] 63. 不同路径 II题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解题思路有障碍物的地方走法为0。 12345678910111213141516171819202122232425262728293031class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ if len(obstacleGrid) == 0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for i in range(m)] for i in range(m): if obstacleGrid[i][0] == 0: dp[i][0] = 1 else: break for i in range(n): if obstacleGrid[0][i] == 0: dp[0][i] = 1 else: break for i in range(1,m): for j in range(1,n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1] 64. 最小路径和题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路每个位置的最小数字总和为当前位置数值加上 上方及左方数字总和 较小的数。 1234567891011121314151617181920212223class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for i in range(m)] dp[0][0] = grid[0][0] for i in range(1,m): dp[i][0] = grid[i][0] + dp[i-1][0] for i in range(1,n): dp[0][i] = grid[0][i] + dp[0][i-1] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1] 70. 爬楼梯题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1：12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2：123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归 (超时)1234567891011class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 动态规划1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n dp = [0]*n dp[0] = 1 dp[1] = 2 for i in range(2,n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n a, b = 1, 2 res = 0 for i in range(3, n+1): res = a + b a, b = b, res return res 91. 解码方法题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码：1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:123输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2:123输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 解题思路dp[i]代表解析是s[:i]字符串的所有可能的方式数目。则：12dp[i] = dp[i-1] if s[i] != '0' + dp[i-2] if '9' &lt; s[i-2:i] &lt; '27' 举例子：对于’226’： 令dp=[0,0,0,0]，初始化为[1,0,0,0]； 从第一个位置开始，输入’2’，不为0，dp=[1,1,0,0]； 第二个位置为’2’，不为0，所以dp=[1,1,1,0]，此时前两位为’22’，满足区间，所以变为[1,1,2,0]; 第三个位置为’6’，不为0，所以dp=[1,1,2,2]，此时前两位为’26’，满足区间，所以变为[1,1,2,3]。 12345678910111213141516class Solution(object): def numDecodings(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 dp = [0] * (len(s)+1) dp[0] = 1 for i in range(1, len(s)+1): if s[i-1] != '0': dp[i] = dp[i-1] if i != 1 and '09' &lt; s[i-2:i] &lt; '27': dp[i] += dp[i-2] return dp[len(s)] 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 解题思路12345678910111213141516171819202122232425262728给定一个数n，求1到n这些数可以构成多少棵二叉树。给定一个序列1.....n，为了构造所有二叉树，我们可以使用1......n中的每一个数i作为根节点，自然1......(i-1)必然位于树的左子树中，(i+1).....n位于树的右子树中。然后可以递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。使用两个状态来记录：dp(n)：长度为n的序列的所有唯一的二叉树。dp(i,n)，1&lt;=i&lt;=n：以i作为根节点的二叉树的数量。dp(n)就是我们要求解的答案，dp(n)可以由F(i,n)计算而来。dp(n)=F(1,n)+F(2,n)+...+F(n,n) (1)dp(0)=1,dp(1)=1对于给定的一个序列1.....n，我们取i作为它的根节点，那么以i作为根节点的二叉树的数量F(i)可以由下面的公式计算而来：F(i,n)=dp(i-1)*dp(n-i-1) 1&lt;=i&lt;=n (2)比i小的数1...i-1作为左子树，比i大的数i+1...n作为右子树，左子树的排列和右子树的排列的乘积是此时的数目。例如 i=3，n=3时， dp[3] = dp[0]*dp[2]+dp[1]*dp[1]+dp[2]dp[0]。即左右子树节点数量分别为(0,2),(1,1),(2,0)。综合公式（1）和公式（2），可以看出：dp(n) = dp(0) * dp(n-1) + dp(1) * dp(n-2) + … + dp(n-1) * dp(0)[参考](https://blog.csdn.net/u012501459/article/details/46622501) 1234567891011121314class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt;= 2: return dp[n] dp += [0] * (n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[n] 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:1234567891011输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 解题思路 遍历1~n选择一个数当作根节点，所以其左边的数字构成左子树，右边的数字构成右子树。 当左子树固定的时候，把所有可能的右子树都构成，然后再变换左子树。（两层for循环遍历leftnodes和rightnodes）。 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 120. 三角形最小路径和题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形：123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路新建dp和三角形一样大小，dp[i][j]为第i层第j个位置的最短路径，dp初始化为最下面一层，从倒数第二层自底向上遍历，则：1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j] 123456789101112131415161718class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = [] for i in range(len(triangle)): dp.append([0]*len(triangle[i])) dp[-1] = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j] return dp[0][0] 由于 dp[i][j] 只被用了一次，所以可以变为一维dp：1dp[i] = min(dp[i],dp[i+1]) + triangle[i][j] 1234567891011121314class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0] 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路维护两个变量，到目前为止的最小值和最大收益。 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 minprice = prices[0] for i in range(1, len(prices)): minprice = min(minprice, prices[i]) maxprofit = max(maxprofit, prices[i]-minprice) return maxprofit 动态规划dp[i]为前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1种的最小价格) dp[i] = max(dp[i-1]-min(prices[:i]) 123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0]*len(prices) for i in range(1,len(prices)): dp[i] = max(dp[i-1], prices[i]-min(prices[:i])) return dp[-1] 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路当今天价格比昨天价格高时，就做一次交易。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 for i in range(1,len(prices)): if prices[i]&gt;prices[i-1]: maxprofit += prices[i]-prices[i-1] return maxprofit 动态规划，dp[i]为到第i天的最大收益，当今天价格比昨天价格高时，就做一次交易，dp[i] = dp[i-1]+prices[i]-prices[i-1] if prices[i]&gt;prices[i-1] else 0. 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0] * len(prices) for i in range(1,len(prices)): dp[i] = dp[i-1] if prices[i] &gt; prices[i-1]: dp[i] += prices[i]-prices[i-1] return dp[-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。 示例 2：1234输入: s = "applepenapple", wordDict = ["apple", "pen"]输出: true解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 152. 乘积最大子序列题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1:123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路暴力，超时。12345678910111213141516171819class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = nums[0] for i in range(len(nums)): res = max(res, nums[i]) cur = nums[i] for j in range(i+1,len(nums)): cur *= nums[j] res = max(res, cur) return res 动态规划 考虑某个位置出现负数或0的情况。当遇到0时，整个乘积变为0；当遇到负数时，当前的最大乘积变为最小乘积，最小乘积变为最大乘积。 使用两个数组分别记录以某个位置i结尾时的最大乘积和最小乘积，另最大乘积为dpmax，最小乘积为dpmin： 当前最大值为已知最大值乘当前值，当前值，已知最小值乘当前值，三者中的最大值； 当前最小值为已知最小值乘当前值，当前值，已知最大值乘当前值，三者中的最小值； 结果为最大值数组中的最大值。 1234567891011121314151617181920class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = [0]*len(nums) dpmax = [0]*len(nums) dpmin[0] = dpmax[0] = nums[0] res = nums[0] for i in range(1,len(nums)): dpmin[i] = min(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) dpmax[i] = max(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) res = max(res, dpmax[i]) # return max(dpmax) return res 空间优化。123456789101112131415161718class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = dpmax = nums[0] res = nums[0] for i in range(1,len(nums)): lastmin = dpmin lastmax = dpmax dpmin = min(lastmax*nums[i], nums[i], lastmin*nums[i]) dpmax = max(lastmax*nums[i], nums[i], *nums[i]) res = max(res, dpmax) return res 198. 打家劫舍题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路动态规划，维护一个长为len(nums)的数组dp，dp[i]代表在i处能取得的最大金额，这个房子该不该偷，这么决定的因素是这个房子偷了的话的收益和不偷留着偷下一个房子的收益那个比较高： 房子i的金额+dp[i-2]的金额 大于 dp[i-1]时，偷； 房子i的金额+dp[i-2]的金额 小于 dp[i-1]时，不偷。 即递推式为：123dp[0] = nums[0] dp[1] = nums[1] dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 12345678910111213141516171819class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(2,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 213. 打家劫舍 II题目描述你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路本题相比第198题就多了不同时偷第一个和最后一个的约束条件。所以，两种偷的情况：第一种不偷最后一个房间，第二种不偷第一个房间，求这两种偷法能获得的最大值。 12345678910111213141516171819202122class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) return max(self.helper(nums[:len(nums)-1]), self.helper(nums[1:])) def helper(self, nums): if len(nums) == 2: return max(nums) dp = [0]*len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(1,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 221. 最大正方形题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例:12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路使用DP，设DP[i][j]为以i,j位置为右下角顶点的能构成的最大正方形的边长，DP数组的第一行和第一列和matrix相等，其他位置当matrix[i][j]==1时，能构成的正方形边长等于左边，上边，左上角能构成正方形边长的最小值+1.递推公式：12341 when i==0 or j == 0, dp[i][j] = matrix[i][j]2 when i &gt; 0 and j &gt; 0, if matrix[i][j] == 0 dp[i][j] = 0 if matrix[i][j] == 1 dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 参考 12345678910111213141516171819202122class Solution(object): def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0]) for i in range(len(matrix))] res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if i == 0 or j == 0: dp[i][j] = 1 if matrix[i][j] == '1' else 0 elif matrix[i][j] == '1': dp[i][j] = 1+ min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) res = max(res, dp[i][j]) return res*res 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:121 是丑数。n 不超过1690。 解题思路123456789101112131415161718192021222324class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n &lt;= 6: return n dp = [1] t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp.append(min(dp[t2]*2, dp[t3]*3, dp[t5]*5)) if dp[t2]*2 == dp[-1]: t2 += 1 if dp[t3]*3 == dp[-1]: t3 += 1 if dp[t5]*5 == dp[-1]: t5 += 1 return dp[-1] 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路dp[i] = 1+min(dp[i-1^2],dp[i-2^2],…,dp[i-k^2]) 12345678910111213141516171819class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0]*(n+1) for i in range(1, n+1): minval = float('inf') for j in range(1, int(i**0.5)+1): minval = min(minval, dp[i-j*j]) dp[i] = minval + 1 return dp[-1] 300. 最长上升子序列题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路使用dp保存包目前为止的最大递增子序列长度，最后求所有为止的最大值，而不是dp的最后元素1初始化dp[i]=12对每一个位置，如果当前位置比之前位置的大，则此时为递增子序列，更新之 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) res = 1 dp = [1]*len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(res, dp[i]) return res 303. 区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例：12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路先把到当前位置的和求出来，然后再调用的时候直接右边的和减去左边的和。 12345678910111213141516171819202122232425262728class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.data = [] total = 0 for num in nums: total += num self.data.append(total) def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i == 0: return self.data[j] else: return self.data[j]-self.data[i-1]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 304. 二维区域和检索 - 矩阵不可变题目描述给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例:1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 解题思路使用dp保存当前位置到左上角元素构成的矩形的所有元素和，添加了第一列和第一行全是0，这样能保证在求和的时候，每个位置的和是是左边的和+上边的和-左上元素的和+当前位置的值1Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA) 参考 123456789101112131415161718192021222324252627class NumMatrix(object): def __init__(self, matrix): """ :type matrix: List[List[int]] """ if not matrix or not matrix[0]: m, n = 0, 0 else: m, n = len(matrix), len(matrix[0]) self.dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m): for j in range(n): self.dp[i+1][j+1] = self.dp[i+1][j]+self.dp[i][j+1]-self.dp[i][j] + matrix[i][j] def sumRegion(self, row1, col1, row2, col2): """ :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int """ return self.dp[row2+1][col2+1]-self.dp[row2+1][col1]-self.dp[row1][col2+1]+self.dp[row1][col1] 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路使用两个数组1 sell[i]表示该天结束之后手里没有股票的情况下的最大收益，可能情况为该天手里有股票卖了，或者该天没进行交易，即 max(hold[i-1]+prices[i]， sell[i-1]);2 hold[i]表示该天结束之后手里有股票的情况下的最大收益，可能情况为手里有股票但是没进行交易，或者手里没有股票买进股票，今天买进的条件是昨天必须休息，即max(hold[i-1], sell[i-2]-prices[i])。 注意：第一天不可能有卖股票的操作，hold[0] = -prices[0]。 该算法的时间复杂度是O(n)，空间复杂度是O(n)。123456789101112131415161718class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 sell = [0 for _ in range(len(prices))] hold = [0 for _ in range(len(prices))] hold[0] = -prices[0] for i in range(1, len(prices)): sell[i] = max(sell[i-1], hold[i-1]+prices[i]) hold[i] = max(hold[i-1], (sell[i-2] if i&gt;=2 else 0)-prices[i]) return sell[-1] 优化空间复杂度到O(1)123456789101112131415161718192021class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 cursell = 0 precell = 0 hold = -prices[0] for i in range(1, len(prices)): temp = cursell cursell = max(cursell, hold+prices[i]) hold = max(hold, (presell if i&gt;= 2 else 0)-prices[i]) presell = temp return cursell 322. 零钱兑换题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 解题思路DP。构建一个amount+1的数组，保存面额从0到amount+1需要使用的最少硬币数量。对于每一个位置i，如果j-c &gt;= 0, dp[i] = min(dp[i],dp[i-c]+1) 1234567891011121314151617181920212223class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [float('inf')]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for c in coins: if i-c &gt;= 0: dp[i] = min(dp[i], dp[i-c]+1) return dp[-1] if dp[-1] != float('inf') else -1 f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1123456789101112131415161718192021222324class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [0 for _ in range(amount+1)] for i in range(1, amount+1): cost = float('inf') for c in coins: if i-c &gt;= 0: cost = min(cost, dp[i-c]+1) dp[i] = cost return dp[-1] if dp[-1] != float('inf') else -1 338. 比特位计数题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1:12输入: 2输出: [0,1,1] 示例 2:12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 builtin_popcount）来执行此操作。 解题思路找规律使用dp，如果i是偶数，它的二进制1的位数等于i//2中1的位数；如果i是奇数，那么它的二进制位数等于i-1的二进制位数+1.即 if i%2==0: dp[i] = dp[i//2]else: dp[i] = dp[i-1]+1 又因为i为奇数时，i-1为偶数，即dp[i-1]=dp[i//2]，此时dp[i] = dp[i//2]+1，综合起来可以写成dp[i] = dp[i//2] + (i&amp;1) 123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] dp = [0] * (num+1) for i in range(1, num+1): # if i % 2 == 0: # dp[i] = dp[i//2] # else: # dp[i] = dp[i-1] + 1 dp[i] = dp[i//2] + (i&amp;1) return dp 暴力，时间复杂度为O(n*sizeof(integer))123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] res = [] for i in range(num+1): count = 0 while i: if i&amp;1: count += 1 i &gt;&gt;= 1 res.append(count) return res 343. 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 解题思路使用dp，dp[i]表示i拆分后的最大乘积，将i分为两部分j和i-j，将这两部分相乘取最大的。 123456789101112131415161718192021class Solution(object): def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 dp = [0]*(n+1) dp[2] = 1 dp[3] = 2 for i in range(4, n+1): for j in range(1, i//2 + 1): dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j])) return dp[-1] 357. 计算各个位数不同的数字个数题目描述给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。 示例:123输入: 2输出: 91 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。 解题思路//dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1)); //加上dp[i-1]没什么可说的，加上之前的数字 //dp[i-1]-dp[i-2]的意思是我们之前判断各位不重复的数字 //我们要在这些数字后面填新的数字。当i=2时，说明之前选取的数字只有 //1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。 //当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的 //有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9） 123456789101112131415161718class Solution(object): def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0] * (n+1) dp[0] = 1 dp[1] = 10 for i in range(2, n+1): dp[i] = dp[i-1] + (dp[i-1]-dp[i-2]) * (10-(i-1)) return dp[-1] 368. 最大整除子集题目描述给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。 如果有多个目标子集，返回其中任何一个均可。 示例 1:12输入: [1,2,3]输出: [1,2] (当然, [1,3] 也正确) 示例 2:12输入: [1,2,4,8]输出: [1,2,4,8] 解题思路首先对数组进行排序，使用dp，dp[i]的含义是从0~i位置满足题目的数组最长长度，先用i遍历每个数字，然后用j从后向前（从前到后也可以）寻找能被nums[i]整除的数字，这样如果判断能整除的时候，在判断dp[i]&lt;d[j]+1，即判断对于以i为结尾的最长数组是否变长了。在变长的情况下，需要更新dp[i]，同时使用parent[i]更新i的前面能整除的数字。另外还要统计对于整个数组最长的子数组长度。 知道了对于每个位置最长的子数组之后，我们也就知道了对于0~n区间内最长的满足题目条件的数组，最后需要再次遍历，使用parent就能把正儿个数组统计输出出来。因为这个最大的索引mx_index是对n而言的，所以输出是逆序的。 参考 1234567891011121314151617181920212223242526272829303132class Solution(object): def largestDivisibleSubset(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] nums.sort() dp = [0] * len(nums) parent = [0] * len(nums) maxlen = 0 maxlenIndex = -1 for i in range(len(nums)): for j in range(i-1, -1, -1): # for j in range(i): if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j]+1: dp[i] = dp[j] + 1 parent[i] = j if dp[i] &gt; maxlen: maxlen = dp[i] maxlenIndex = i res = [] for i in range(maxlen+1): res.append(nums[maxlenIndex]) maxlenIndex = parent[maxlenIndex] return res[::-1] 375. 猜数字大小 II题目描述我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例:123456789n = 10, 我选择了8.第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。游戏结束。8 就是我选的数字。你最终要支付 5 + 7 + 9 = 21 块钱。 给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。 解题思路这题要求我们在猜测数字y未知的情况下（1~n任意一个数），要我们在最坏情况下我们支付最少的钱。也就是说要考虑所有y的情况。 我们假定选择了一个错误的数x，（1&lt;=x&lt;=n &amp;&amp; x!=y ）那么就知道接下来应该从[1,x-1 ] 或者[x+1,n]中进行查找。 假如我们已经解决了[1,x-1] 和 [x+1,n]计算问题，我们将其表示为solve(L,x-1) 和solve(x+1,n)，那么我们应该选择max(solve(L,x-1),solve(x+1,n)) 这样就是求最坏情况下的损失。总的损失就是 f(x) = x + max(solve(L,x-1),solve(x+1,n)) 那么将x从1~n进行遍历，取使得 f(x) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。 上面的说法其实是一个自顶向下的过程（Top-down），可以用递归来解决。很容易得到如下的代码（这里用了记忆化搜索）： 参考 123456789101112131415161718class Solution(object): def getMoneyAmount(self, n): """ :type n: int :rtype: int """ dp = [[0]*(n+1) for _ in range(n+1)] return self.solve(dp, 1, n) def solve(self, dp, left, right): if left &gt;= right: return 0 if dp[left][right]: return dp[left][right] dp[left][right] = min(i + max(self.solve(dp, left, i-1), self.solve(dp, i+1, right)) for i in range(left, right+1)) return dp[left][right] 376. 摆动序列题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 解题思路摆动为一升一降，一个up就要配一个down构成一组。注意去重 123456789101112131415161718192021class Solution(object): def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) up = 1 down = 1 for i in range(1, len(nums)): if nums[i] &gt; nums[i-1]: up = down + 1 elif nums[i] &lt; nums[i-1]: down = up + 1 return max(up, down) 377. 组合总和 Ⅳ题目描述给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶： 如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？ 解题思路使用dp[i]表示组合数为i时使用nums中的数组能组成组合数的个数，因为都是正数，所以长度最多是target,target个1组成。 从1遍历到target，对于每一个数i，遍历nums数组，如果i&gt;=x, dp[i] += dp[i - x]。比如说对于[1,2,3] 4，在计算dp[3]的时候，3可以拆分为1+x，而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了。 1234567891011121314151617181920class Solution(object): def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 dp = [0] * (target+1) dp[0] = 1 for i in range(1, target+1): for x in nums: if i &gt;= x: dp[i] += dp[i-x] return dp[-1] 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1:123s = "abc", t = "ahbgdc"返回 true. 示例 2:123s = "axc", t = "ahbgdc"返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路dp的tag不用dp。使用一个指针index记录最后s[:index]在t中存在的最后位置。 123456789101112131415161718192021class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(t) &lt; len(s): return False if len(s) == 0: return True index = 0 for i in range(len(t)): if t[i] == s[index]: index += 1 if index == len(s): return True return index == len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 回溯算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是回溯算法相关题目题解总结。 [TOC] 回溯算法回溯算法属于DFS。在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。 普通DFS主要用于可达性问题，这种问题只需要执行到特定的位置然后返回即可； 而Backtracking主要用于求解排列组合问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。 Backtracking的基本思想是： 从一条路往前走，能进则进，不能进则退回来，换一条路再试。 八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。 回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。 回溯算法说白了就是穷举法。 因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素； 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。 17. 电话号码的字母组合题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路回溯。要求所有位置都要有字母，即组合的长度为数字的长度。 123456789101112131415161718192021class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] dic = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; res = [] self.dfs(digits, 0, '', dic, res) return res def dfs(self, digits, index, path, dic, res): if len(path) == len(digits): if path: res.append(path) return if digits[index] not in dic: return [] for j in dic[digits[index]]: self.dfs(digits, index+1, path+j, dic, res) 123456789101112131415161718192021222324252627class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] Dict = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; strs = [] for x in digits: strs.append(Dict[x]) res = [] self.dfs(strs, 0, '', res) return res def dfs(self, strs, index, path, res): if len(path) == len(strs): res.append(path) return for j in strs[index]: self.dfs(strs, index+1, path+j, res) 22. 括号生成题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 解题思路回溯。如果左括号还有剩余，则放置左括号，如果有括号剩余数大于左括号，则可以放置有括号，停止条件为所有括号全部放置完。 12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n &lt;= 0: return [] res = [] self.dfs(n, n, '', res) return res def dfs(self, left, right, path, res): if left == 0 and right == 0: res.append(path) return if left &gt; 0: self.dfs(left-1, right, path+'(', res) if left &lt; right: self.dfs(left, right-1, path+')', res) 39. 组合总和题目描述给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题思路先进行排序在dfs。123456789101112131415161718192021class Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, start, templist, res): if residue == 0: res.append(templist) return for i in range(start, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i, templist+[candidates[i]], res) 40. 组合总和 II题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解题思路和39差不多，加判断条件防止res中出现重复项，调用时为i+1，防止重复的数字。12345678910111213141516171819202122class Solution(object): def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, index, templist, res): if residue == 0 and templist not in res: res.append(templist) return for i in range(index, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i+1, templist+[candidates[i]], res) 46. 全排列题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例:12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路12345678910111213141516171819202122class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(temp) == len(nums): res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res) 47. 全排列 II题目描述给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路123456789101112131415161718192021class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(nums) == len(temp) and temp not in res: res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, temp, res): if not nums and temp not in res: res.append(temp) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], temp+[nums[i]], res) 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 解题思路所有元素共有 n! 种排列。根据下图对’1234’的全排列，按照第一个字符可以分为4组，按照第二个字符可以分为3组，按照第三个字符可以分为2组，所以一共有4x3x2种排列方式。 要得到第九个排列’2314’，转换为数组下标也就是8，在level 1 中下标为1，level 2 中下标为1，level 3 中下标为0。具体过程为： 最高位可以取{1,2,3,4}，并且每个数在最高位出现3!=6次，第9个排序的最高位下标为：8//3!=1，也就是2； 次位可以取{1,3,4}，并且每个数在次位出现2!=2次，第9个排序的最高位下标为：(8%6)//2!=1，也就是3; 第三位可以取{1,4},并且每个数在第三位出现1次，第9个排列的第三位取值下标为：(8%6%2)//1=0，也就是1； 最后一位只有一个数字4。 用ki表示在数组中的取值下标，n表示集合中数字个数： k = k-1，此步是关键 k1 = k//(n-1)! k = k%(n-1)! k2 = k//(n-2)! k = k%(n-2)! … kn-1 = k//1 参考文章1234567891011121314151617181920212223class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' fact = [1]*n for i in range(1,n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' k = k-1 res = '' num = [str(i) for i in range(1,n+1)] for i in range(n, 0, -1): index = k // fact[i-1] res += num[index] k = k % fact[i-1] num.pop(index) return res 77. 组合题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路回溯法，我们抽取第一个字符，然后从后面n-1个字符中抽取k-1个；抽取第二个字符，再从后面的n-2个字符抽出k-1. 12345678910111213141516171819202122class Solution(object): def combine(self, n, k): """ :type n: int :type k: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0: return [] res = [] self.dfs(range(1, n+1), k, [], res) return res def dfs(self, nums, k, path, res): if k &gt; len(nums): return if k == 0: res.append(path) return for i in range(len(nums)): self.dfs(nums[i+1:], k-1, path+[nums[i]], res) 78. 子集题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路12345678910111213141516class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [[]] res = [] self.dfs(nums, 0, res, []) return res def dfs(self, nums, index, res, path): res.append(path) for i in range(index, len(nums)): self.dfs(nums, i+1, res, path+[nums[i]]) 79. 单词搜索题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例:12345678910board =[ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']]给定 word = "ABCCED", 返回 true.给定 word = "SEE", 返回 true.给定 word = "ABCB", 返回 false. 解题思路Leetcode65题12345678910111213141516171819202122232425262728293031323334class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ if len(board) == 0: return False if len(word) == 0: return True visited = [[False]*len(board[0]) for i in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, word, i, j, 0, visited): return True return False def helper(self, board, word, i, j, pathlength, visited): if pathlength == len(word): return True curHaspath = False if 0&lt;=i&lt;len(board) and 0&lt;=j&lt;len(board[0]) and board[i][j] == word[pathlength] and not visited[i][j]: visited[i][j] = True pathlength += 1 curHaspath = self.helper(board,word,i+1,j,pathlength,visited) or self.helper(board,word,i-1,j,pathlength,visited) or self.helper(board,word,i,j+1,pathlength,visited) or self.helper(board,word,i,j-1,pathlength,visited) if not curHaspath: visited[i][j] = False pathlength -= 1 return curHaspath 89. 格雷编码题目描述格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路格雷码的生成过程：res[i] = i ^ (i//2)。如n = 3： res[0] = 0 = 000 res[1] = 1^(1//2) = 001^000 = 001 res[2] = 2^(2//2) = 010^001 = 011 res[3] = 3^(3//2) = 011^001 = 010 res[4] = 4^(4//2) = 100^010 = 110 res[5] = 5^(5//2) = 101^010 = 111 res[6] = 6^(6//2) = 110^011 = 101 res[7] = 7^(7//2) = 111^011 = 100 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] num = 1 for i in range(n): num *= 2 res = [0]*num while i &lt; num: res[i] = i ^ (i//2) i += 1 return res 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] res = [0]*(2**n) for i in range(len(res)): res[i] = i^(i//2) return res 90. 子集 II题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路123456789101112131415161718192021class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] nums.sort() res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, index, path, res): if path not in res: res.append(path) for i in range(index, len(nums)): if i &gt; index and nums[i] == nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) 93. 复原IP地址题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: “25525511135”输出: [“255.255.11.135”, “255.255.111.35”] 解题思路IP地址由四部分组成，每一部分的数字为0~255，使用回溯算法验证每一部分的数字大小,一部分数字做多为3位（range(1,4))，在使用完字符串中所有字符且当前IP地址为四部分时添加到结果中。每次dfs的时候都去检查一下所有的字符串的长度是不是能满足在最多4个3位数字组成。 123456789101112131415161718192021222324class Solution(object): def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ if not s or len(s) &lt; 4 or len(s) &gt; 12: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and len(temp) == 4: res.append('.'.join(temp)) return if len(temp) &gt;= 4 or len(s) &gt; (4-len(temp))*3: return for i in range(1, 4): if i &gt; len(s): continue number = int(s[:i]) if str(number) == s[:i] and number &lt;= 255: self.dfs(s[i:], temp + [s[:i]], res) 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: "aab"输出:[ ["aa","b"], ["a","a","b"]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 二分查找]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是二分查找相关题目题解总结。 [TOC] 二分查找二分查找也称折半查找，它是一种效率较高的查找方法。但是折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排序。 查找过程二分查找适用于有序的顺序表。首先将表中间位置记录的关键字和查找关键字比较；如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表；如果中间位置记录的关键字大于查找关键字，则进入前一子表，否则进入后一子表；重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止。 算法要求 必须采用顺序存储结构； 必须按关键字大小有序排序。 复杂度时间复杂度O(log2n)，空间复杂度为O(1)。 中值mid的计算有两种计算中值mid的方式： mid = (left+right) // 2; mid = left + (right-left)//2left+right 可能出现加法溢出，最好使用第二种方式。 返回值 如果成功查找到key： 返回key所在的位置。 如果循环退出时仍然没有找到key，表示查找失败，有两种可能返回值： -1:以一个错误码表示没有查找到key；pos：将key插入到原列表中合适的位置。 正常实现1234567891011121314class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == key: return mid elif nums[mid] &gt; key: right = mid - 1 else: left = mid + 1 return -1 二分查找的变种二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：123456789101112131415class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt; right: # 小于 而不是小于等于 mid = left + (right-left)//2 if nums[mid] &gt;= key: right = mid # mid 不是mid-1 else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().binarySearch([1,1,1,2,3,3,4,5,6,7],1) print(result) 与正常实现不同： right 的赋值表达式为 right = mid； 循环条件为left&lt;right; 最后返回left而不是-1。 解释： 在nums[mid] &gt;= key的情况下，可以推导出最左key位于[left,mid]区间中，right 的赋值表达式为 right = mid，因为mid位置也可能为解； 在right 的赋值表达式为 right = mid的情况下，如果循环条件为left&lt;=right，将会导致陷入死循环的情况； 当循环退出时，不表示没有查找成功，为了验证有没有查找到，应该在调用函数时判断一下返回值上的值和key是否相等。 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 123456789101112131415161718192021222324252627282930class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return -1 34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解题思路二分查找。 当nums[mid] == target时，说明target在数组中的[left,right]中，其中开始位置在[left,mid]，结束位置在[mid,right]中； 从头遍历[left,mid]，找到第一个等于target的位置作为开始位置； 从后遍历[mid,right]，从后找到第一个等于target的位置作为结束位置； 当nums[mid] &gt; target时，right = mid-1 当nums[mid] &lt; target时，left = mid+1 12345678910111213141516171819202122232425262728293031class Solution(object): def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1,-1] left, right = 0 ,len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: temp = [] for i in range(left,mid+1): if nums[i] == target: temp.append(i) break for i in range(right, mid-1,-1): if nums[i] == target: temp.append(i) break return temp elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return [-1,-1]if __name__ == '__main__': result = Solution().searchRange([5,7,7,8,8,10],8) print(result) 35. 搜索插入位置题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 2输出: 1 示例 3:12输入: [1,3,5,6], 7输出: 4 示例 4:12输入: [1,3,5,6], 0输出: 0 解题思路1234567891011121314151617181920212223class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return left 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: # return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2 示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 解题思路 二分查找。一个数x的开根号一定在[1,x//2+1]之间，因为在(x//2+1)^2 &gt; x，所以我们将二分查找的终点设为x//2+1; 对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 left &lt;= right 并且循环退出时，right 总是比 left 小 1，也就是说 right = 2，left = 3，因此最后的返回值应该为 right 而不是 left。 1234567891011121314151617181920class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x == 0: return 0 if x == 1: return 1 left, right = 1, x//2+1 while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在正式比较之前，先移动左指针，使它指向和右指针不同的数字上。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: while left &lt; right and nums[left] == nums[right]: left += 1 mid = left + (right-left)//2 if nums[mid] == target: return True if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 153. 寻找旋转排序数组中的最小值题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 示例 2: 输入: [4,5,6,7,0,1,2]输出: 0 解题思路数组分为两个升序的数组，使用二分查找。 当nums[mid]&gt;nums[mid+1]时，最小值为nums[mid+1]; 当nums[mid]&gt;nums[right]时,left = mid+1; 当nums[mid]&gt;nums[right]时,right = mid，因为mid位置可能就是最小值了； 由于right = mid，则循环条件为left&lt;right。 1234567891011121314151617181920212223class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] left, right = 0, len(nums)-1 while left &lt; right: mid = left + (right-left)//2 if mid+1 &lt;= len(nums)-1 and nums[mid] &gt; nums[mid+1]: return nums[mid+1] if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]if __name__ == '__main__': result = Solution().findMin([4,5,6,7,0,1,2]) print(result) 二刷12345678910111213141516171819202122class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if mid-1&gt;=0 and nums[mid-1] &gt; nums[mid]: return nums[mid] if nums[mid] &lt;= nums[right]: right = mid-1 else: left = mid + 1 return nums[left] 162. 寻找峰值题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 解题思路用两个mid，判断上坡还是下坡，上坡将left移到坡顶，下坡将right移到坡顶123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 left, right = 0, len(nums)-1 while left &lt; right: mid1 = left+(right-left)//2 mid2 = mid1 + 1 if nums[mid1] &lt; nums[mid2]: left = mid2 else: right = mid1 return left 278. 第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -false调用 isBadVersion(5) -true调用 isBadVersion(4) -true所以，4 是第一个错误的版本。 解题思路给定 n = 5，并且 version = 4 是第一个错误的版本时，输入分布为[1,2,3,4,5]，对应版本正误情况为[0,0,0,1,1]，题目要求出最靠左的1的位置。使用二分查找： 如果第mid个版本出错，则第一个出错版本在[left,mid]，有可能出现在mid位置，因此right = mid； 如果第mid个版本没错，则第一个出错版本在[mid+1,right]，因此left = mid+1; 当循环条件为left&lt;=right时，会陷入死循环。 总结：当right的赋值表达式为 right = mid 时，循环条件为 left &lt; right。 123456789101112131415161718192021222324252627# The isBadVersion API is already defined for you.# @param version, an integer# @return a booldef isBadVersion(version): if version in (1,2,3): return False elif version in (4,5): return Trueclass Solution(object): def firstBadVersion(self, n): """ :type n: int :rtype: int """ left, right = 1, n while left &lt; right: mid = left + (right-left)//2 if isBadVersion(mid): right = mid else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().firstBadVersion(5) print(result) 540. 有序数组中的单一元素题目描述给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例 2: 输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 解题思路如果题目不限制在 O(log n)时间复杂度运行，可使用异或运算。1234567891011def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for i in nums: res ^= i return res 使用二分查找法实现O(log n)时间复杂度和 O(1)空间复杂度。初始令左右指针分别为 0，len(nums)-1;当left&lt;= right时循环：mid = left+(right-left)//2 当nums[mid] == nums[mid-1]时，数组可以分为[left, mid-2], [mid+1, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-2]长度为偶数，则目标位于[mid+1, right]，令left = mid +1;当mid为偶数时，说明[left, mid-2]长度为奇数，则目标位于该数组内，令right = mid -1; 同理当nums[mid] == nums[mid+1]时，数组可以分为[left, mid-1], [mid+2, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-1]长度为奇数，则目标位于该数组内，令right = mid -1;当mid为偶数时，说明[left, mid-1]长度为偶数，则目标位于[mid+2, right]，令left = mid +1; 当nums[mid]与nums[mid - 1], nums[mid + 1]均不相等，则返回nums[mid]。 1234567891011121314151617181920212223242526class Solution(object): def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left) //2 if mid-1 &gt;= 0 and nums[mid] == nums[mid-1]: if mid %2 == 1: left = mid + 1 else: right = mid - 2 elif mid+1 &lt;= len(nums)-1 and nums[mid] == nums[mid+1]: if mid %2 == 1: right = mid - 1 else: left = mid + 2 else: return nums[mid]if __name__ == '__main__': result = Solution().singleNonDuplicate([3,3,7,7,10,11,11]) print(result) 744. 寻找比目标字母大的最小字母题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 示例: 输入:letters = [“c”, “f”, “j”]target = “a”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f” 输入:letters = [“c”, “f”, “j”]target = “g”输出: “j” 输入:letters = [“c”, “f”, “j”]target = “j”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “k”输出: “c” 注: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路二分搜索。注意当有重复字母时，如[“e”,”e”,”e”,”e”,”e”,”e”,”n”,”n”,”n”,”n”],”e”，当letters[mid] 小于及 等于 target时，left都要向前走一步;如果left大于右边界时，说明target比数组里的所有字母都大，返回letters[0];否则返回letters[left]。 1234567891011121314151617181920class Solution(object): def nextGreatestLetter(self, letters, target): """ :type letters: List[str] :type target: str :rtype: str """ if len(letters) == 0: return '' left, right = 0, len(letters)-1 while left &lt;= right: mid = left + (right-left)//2 if letters[mid] &lt;= target: left = mid + 1 else: right = mid - 1 return letters[0] if left == len(letters) else letters[left]if __name__ == '__main__': result = Solution().nextGreatestLetter(["e","e","e","e","e","e","n","n","n","n"],"e") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 搜索]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是搜索相关题目题解总结。 [TOC] 搜索本文内容主要包括广度优先搜索(breadth first search)，深度优先搜索(depth first search)。 广度优先搜索(BFS)主要思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点依次访问它们的邻接点，并使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起点，重复上述过程，直至图中所有顶点都被访问到。 注意：遍历过的节点不能再次被遍历。 每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。 实现 BFS 时需要考虑以下问题：队列：用来存储每一轮遍历得到的节点；标记：对于遍历过的节点，应该将它标记，防止重复遍历。 无向图的广度优先搜索 第1步：访问A。并将C，D，F加入到访问队列，[C,D,F] 第2步：访问C。并将 B加入到访问队列，[D,F,B] 第3步：访问D。由于D的邻接点C已经访问过，则不加入访问队列，[F,B]; 第4步：访问F。并将G加入访问队列，[B,G]; 第5步：访问B。 第6步：访问G。并将E加入到访问队列，[E]; 第7步：访问E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索 访问顺序：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 深度优先搜索(DFS)主要思想：假设初始状态所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历，直到所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问到。 深度优先搜索是一个递归的过程。 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种可达性问题。 实现 DFS 时需要考虑以下问题：栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。 无向图的深度优先搜索访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 参考 127. 单词接龙题目描述给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -“hot” -“dot” -“dog” -“cog”, 返回它的长度 5。 示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 解题思路使用BFS，最短路的思路。将beginWord放进队列，如果队列不为空，那么取出第一个数，将其周围的在字典的字符放进队列，直到周围的存在endword。1234567891011121314151617181920212223242526import collectionsclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) queue = collections.deque() queue.append([beginWord, 1]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i + 1:] if nextWord in wordList: wordList.remove(nextWord) queue.append([nextWord, length + 1]) return 0if __name__ == '__main__': result = Solution().ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]) print(result) 123456789101112131415161718192021222324class Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) stack = [(beginWord, 1)] while stack: word, length = stack.pop(0) if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i+1:] if nextWord in wordList: wordList.remove(nextWord) stack.append((nextWord, length+1)) return 0 130. 被围绕的区域题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例:1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为：1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路从边上开始搜索，如果是’O’,那么搜索’O’周围的元素，并将’O’置换为’D’。如果该’O’周围都是’X’，则会跳出，这样内部的’O’将不受影响。最后没有被’X’围住的’O’都置换成了’D’,被围住的’O’还是’O’，没有改变。然后遍历一遍，将’O’置换为’X’，将’D’置换为’O’。 在leetcode中文网站无法提交，英文网站正常。 迭代 BFS。123456789101112131415161718192021222324252627class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ import collections queue = collections.deque([]) for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board) - 1] or c in [0, len(board[0]) - 1]) and board[r][c] == "O": queue.append((r, c)) while queue: r, c = queue.popleft() if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == "O": board[r][c] = "D" queue.append((r - 1, c)) queue.append((r + 1, c)) queue.append((r, c - 1)) queue.append((r, c + 1)) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == "O": board[r][c] = "X" elif board[r][c] == "D": board[r][c] = "O" 递归 DFS1234567891011121314151617181920212223class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O': self.dfs(board, r, c) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == 'O': board[r][c] = 'X' elif board[r][c] == 'D': board[r][c] = 'O' def dfs(self, board, r, c): if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == 'O': board[r][c] = 'D' self.dfs(board, r-1, c) self.dfs(board, r+1, c) self.dfs(board, r, c-1) self.dfs(board, r, c+1) 133. 克隆图题目描述克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。 OJ的无向图序列化： 节点被唯一标记。 我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。 例如，序列化无向图 {0,1,2#1,2#2,2}。 该图总共有三个节点, 被两个分隔符 # 分为三部分。 第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。 第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。 第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。 我们将图形可视化如下： 解题思路由于遍历一个图有两种方式：bfs和dfs。所以深拷贝一个图也可以采用这两种方法。不管使用dfs还是bfs都需要一个哈希表map来存储原图中的节点和新图中的节点的一一映射。map的作用在于替代bfs和dfs中的visit数组，一旦map中出现了映射关系，就说明已经复制完成，也就是已经访问过了。 BFS12345678910111213141516171819202122232425262728# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None queue = [] dic = &#123;&#125; newhead = UndirectedGraphNode(node.label) dic[node] = newhead queue.append(node) while queue: curr = queue.pop() for neighbor in curr.neighbors: if neighbor not in dic: copy = UndirectedGraphNode(neighbor.label) dic[curr].neighbors.append(copy) dic[neighbor] = copy queue.append(neighbor) else: dic[curr].neighbors.append(dic[neighbor]) return newhead DFS12345678910111213141516171819202122# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None return self.dfs(node, &#123;&#125;) def dfs(self, input, dic): if input in dic: return dic[input] output = UndirectedGraphNode(input.label) dic[input] = output for neighbor in input.neighbors: output.neighbors.append(self.dfs(neighbor, dic)) return output 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 解题思路按层次遍历，没层取最右边元素。 BFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res DFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, 0, res) return [level[-1] for level in res] def dfs(self, root, level, res): if not root: return [] if level == len(res): res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 200. 岛屿的个数题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路给定由0和1组成的二维数组，求1的连通块。 BFS 超时12345678910111213141516171819202122232425262728class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.bfs(grid, i, j) count += 1 return count def bfs(self, grid, i, j): queue = collections.deque() queue.append((i,j)) grid[i][j] = '#' direction = [(0,1), (0,-1), (1,0), (-1,0)] while queue: i, j = queue.popleft() for d in direction: r, c = i + d[0], i + d[1] if 0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0]) and grid[r][c] == '1': grid[r][c] == '#' queue.append((r, c)) DFS12345678910111213141516171819202122class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0]) and grid[i][j] == '1': grid[i][j] = '#' self.dfs(grid, i-1, j) self.dfs(grid, i+1, j) self.dfs(grid, i, j-1) self.dfs(grid, i, j+1) 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路使用DFS，如n=12，首先计算出可能存在的平方数candidate = [1,4,9]，然后对当前残差及candidate进行遍历，直到残差等于candidate，则返回。 123456789101112131415161718192021222324252627282930313233class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ if n &lt; 0: return 0 if n &lt;= 1: return 1 candidate = [] i = 1 while i*i &lt;= n: candidate.append(i*i) i += 1 count = 0 toCheck = &#123;n&#125; while toCheck: count += 1 temp = set() for residue in toCheck: for cand in candidate: if residue == cand: return count if residue &lt; cand: break temp.add(residue-cand) toCheck = temp return countif __name__ == '__main__': result = Solution().numSquares(12) print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数学]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是数学相关题目题解总结。 [TOC] 2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路使用哨兵节点，设置进位carry，直接相加，当进位为1时加到下一位。 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next 第一次写的思路：先求和，在构建链表。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 num1, num2 = 0, 0 base = 1 while l1: num1 += l1.val * base base *= 10 l1 = l1.next base = 1 while l2: num2 += l2.val*base base *= 10 l2 = l2.next num = num1 + num2 if num == 0: root = ListNode(0) return root return self.helper(num) def helper(self, num): if num == 0: return None root = ListNode(num % 10) root.next = self.helper(num // 10) return root 7. 整数反转题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:1假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路123456789101112131415class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &lt; 0: x = -x flag = -1 res = 0 while x: res = res * 10 + x % 10 x = x // 10 return res * flag if -2**31 &lt;= res &lt;= 2**31-1 else 0 8. 字符串转换整数 (atoi)题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:12输入: "42"输出: 42 示例 2:1234输入: " -42"输出: -42解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: "4193 with words"输出: 4193解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4:1234输入: "words and 987"输出: 0解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: "-91283472332"输出: -2147483648解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路一个一个条件判断。。。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def myAtoi(self, str): """ :type str: str :rtype: int """ if not str: return 0 i = 0 while i &lt; len(str) and str[i] == ' ': i += 1 if i == len(str) or str[i] not in '1234567890+-': return 0 flag = 1 if str[i] in '+-': if i == len(str)-1 or str[i+1] not in '1234567890': return 0 elif str[i] == '-': flag = -1 i = i+1 start = i end = start while end &lt; len(str) and str[end] in '1234567890': end += 1 res = flag*int(str[start:end]) if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 9. 回文数题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:1234输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶: 你能不将整数转为字符串来解决这个问题吗？ 解题思路1234567891011121314151617class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False xhat = 0 temp = x while temp: xhat = xhat*10 + temp % 10 temp //= 10 return x == xhat 12345678910111213141516171819class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) left, right = 0, len(x)-1 while left &lt; right: if x[left] != x[right]: return False left += 1 right -= 1 return True 12. 整数转罗马数字题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:12输入: 3输出: "III" 示例 2:12输入: 4输出: "IV" 示例 3:12输入: 9输出: "IX" 示例 4:123输入: 58输出: "LVIII"解释: L = 50, V = 5, III = 3. 示例 5:123输入: 1994输出: "MCMXCIV"解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ if not num: return '' val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = '' for i in range(len(val)): while num &gt;= val[i]: res += st[i] num -= val[i] return res 13. 罗马数字转整数题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: "III"输出: 3 示例 2:12输入: "IV"输出: 4 示例 3:12输入: "IX"输出: 9 示例 4:123输入: "LVIII"输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: "MCMXCIV"输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920212223class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if not s: return 0 val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] Dict = &#123;'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 'IV':4,'I':1&#125; res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in Dict: res += Dict[s[i:i+2]] i += 2 else: res += Dict[s[i]] i += 1 return res 1234567891011121314151617181920212223242526class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] strs = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in strs: index = strs.index(s[i:i+2]) res += vals[index] i += 2 else: index = strs.index(s[i]) res += vals[index] i += 1 return res 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 43. 字符串相乘题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1:12输入: num1 = "2", num2 = "3"输出: "6" 示例 2:12输入: num1 = "123", num2 = "456"输出: "56088" 说明：1234num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路按照乘法竖式计算，将num1和num2翻转，用num1中的每一个数和num2进行相乘，乘法过程中考虑进位和位数。 1234567891011121314151617181920212223class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ if num1 == '0' or num2 == '0': return '0' res = 0 for i, n1 in enumerate(num1[::-1]): carry = 0 temp = 0 for j, n2 in enumerate(num2[::-1]): multi = (ord(n1)-ord('0')) * (ord(n2)-ord('0')) carrytemp, val = multi//10, multi%10 temp += (val+carry) * (10**j) carry = carrytemp temp += carry * (10**len(num2)) res += temp * (10**i) return str(res) 二刷。 123456789101112131415161718192021222324252627282930class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ num1, num2 = num1[::-1], num2[::-1] temp = [0]*(len(num1)+len(num2)) for i in range(len(num1)): for j in range(len(num2)): temp[i+j] += (ord(num1[i])-ord('0')) * (ord(num2[j])-ord('0')) res = [] for i in range(len(temp)): digit = temp[i] % 10 carry = temp[i] // 10 if i &lt; len(temp)-1: temp[i+1] += carry res.insert(0, str(digit)) i = 0 while i&lt;len(res)-1 and res[i] == '0': i += 1 res = res[i:] return ''.join(res) 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：123456"123""132""213""231""312""321" 给定 n 和 k，返回第 k 个排列。 说明：12给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:12输入: n = 3, k = 3输出: "213" 示例 2:12输入: n = 4, k = 9输出: "2314" 解题思路以n=4, k=9为例，初始化k=k-1=8。 最高位可取数字为[1,2,3,4]，每一个取值都有3!=6种取法，那么第9个下标为k//(n-1)!=8//6=1，即2，可取数字删去2更新为[1,3,4]，k=k%(n-1)!=2； 次高位可取数字为[1,3,4]，每一个取值都有2!=2种取法，那么第九个下标为k//(n-1-1)!=2//2=1,即3，可取数字删去3更新为[1,4]，k=k%(n-1-1)!=0； 第三位可取数字为[1,4]，每一个取值都有1!=1中取法，那么第九个下标为k//(n-1-1-1)!=0//1=0，即1，可取数字删去1更新为[4]，k=k%(n-1-1-1)=0; 第四位为[4]。 123456789101112131415161718192021222324252627class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' num = [str(i) for i in range(1, n+1)] fact = [1] * n for i in range(1, n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' res = '' k = k-1 for i in range(n): index = k // fact[n-1-i] res += num[index] num.pop(index) k = k % fact[n-1-i] return res 66. 加一题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路数九。从最后一位开始遍历，若当前遍历的值为9，则置为0；如果不是9，则当前位加1跳出循环；最后判断最高位是否为0，若为0，则需要在增加数组长度，即在最高位之前插入1。 123456789101112131415161718192021class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] for i in range(len(digits))[::-1]: if digits[i] == 9: digits[i] = 0 continue else: digits[i] += 1 break if digits[0] == 0: digits.insert(0, 1) return digits 采用进位。初始化进位为0，首先对最后一位加1操作，从后向前遍历，当当前位加上进位等于10时，将改为置0，进位置1，如小于10，则将进位置0，跳出循环。 1234567891011121314151617181920212223242526class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] pos = len(digits)-1 carry = 0 digits[-1] += 1 while pos &gt;= 0: digits[pos] += carry if digits[pos] &gt;= 10: digits[pos] -= 10 carry = 1 else: carry = 0 break pos -= 1 if carry: digits.insert(0, 1) return digits 一刷。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] temp = 0 for x in digits: temp = temp*10 + x temp += 1 res = [] while temp: res.insert(0, temp%10) temp //= 10 return res 67. 二进制求和题目描述给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1:12输入: a = "11", b = "1"输出: "100" 示例 2:12输入: a = "1010", b = "1011"输出: "10101" 解题思路设置当前位和plus，从后向前遍历，将每一位(plus%2)加入到结果中，将进位(plus//2)赋给下一次迭代位和plus。 1234567891011121314151617181920212223242526class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ res = '' carry = 0 m, n, plus = len(a)-1, len(b)-1, 0 i, j = m, n res = '' while i &gt;= 0 or j &gt;= 0 or plus: if i &gt;= 0: plus += int(a[i]) i -= 1 if j &gt;= 0: plus += int(b[j]) j -= 1 res = str(plus%2) + res plus //= 2 return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:12输入: 4输出: 2 示例 2:1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路二分查找。 12345678910111213141516171819202122class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x &lt;= 1: return x left, right = 1, x while left &lt;= right: mid = left + (right-left)//2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: "0.5" 示例 2:12输入: numerator = 2, denominator = 1输出: "2" 示例 3:12输入: numerator = 2, denominator = 3输出: "0.(6)" 解题思路先处理分子，分母为零，负数的情况。然后使用字典将余数保存起来，当余数不为零时，在结果后加小数位数，当余数重复出现时，找到最开始重复的位置，加括号返回。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ if denominator == 0: return '' if numerator == 0: return '0' res = '' if numerator*denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) remainder = numerator % denominator if remainder == 0: return res res += '.' Dict = &#123;&#125; Dict[remainder] = len(res) while remainder: remainder *= 10 res += str(remainder // denominator) remainder %= denominator if remainder in Dict: start = Dict[remainder] res = res[:start] + '(' + res[start:] + ')' break else: Dict[remainder] = len(res) return res 168. Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如，123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1:12输入: 1输出: "A" 示例 2:12输入: 28输出: "AB" 示例 3:12输入: 701输出: "ZY" 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def convertToTitle(self, n): """ :type n: int :rtype: str """ res = '' while n: if n % 26 == 0: res = 'Z' + res n -= 26 else: res = chr(n % 26 -1 + ord('A')) + res n -= n % 26 n //= 26 return res 171. Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如，12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1:12输入: "A"输出: 1 示例 2:12输入: "AB"输出: 28 示例 3:12输入: "ZY"输出: 701 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 base = 1 for x in s[::-1]: res += (ord(x) - ord('A') + 1) * base base *= 26 return res 123456789101112class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 for x in s: res = res*26 + (ord(x) - ord('A') + 1) return res 172. 阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1:123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2:123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 6!=[123456]，其中25才有0，所以可以抛开其他数据，只看2,5出现的次数； 10!=[12345678910]，有2,5组成的有2,4(22),5,6(23),8(222),10(25)，一个2和一个5配对产生一个0，所以有两个配对有两个0。由于2一定比5多，只对5计数就可以了。 123456789101112class Solution(object): def trailingZeroes(self, n): """ :type n: int :rtype: int """ res = 0 while n: n //= 5 res += n return res 202. 快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例:1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路12345678910111213141516171819202122232425262728class Solution(object): def isHappy(self, n): """ :type n: int :rtype: bool """ if n == 0: return False if n == 1: return True seen = [n] while n != 1: lastN = n nextN = 0 while lastN: nextN += (lastN % 10) ** 2 lastN //= 10 n = nextN if n in seen: return False seen.append(n) return True 204. 计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路超时12345678910111213141516171819202122class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = 0 for i in range(2, n): flag = 1 for j in range(2, i): if i % j == 0: flag = 0 break if flag: res += 1 return res 厄拉多塞筛法.比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推. 首先生成了一个全部为1的列表 res= [1] * n 因为0和1不是质数,所以列表的前两个位置赋值为0 res[0],res[1] = 0,0 此时从index = 2开始遍历,res[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引,全部赋值为0.此时res[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推. 123456789101112131415161718class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = [1] * n res[0], res[1] = 0, 0 for i in range(2, int(n**0.5)+1): if res[i] == 1: res[i*i:n:i] = [0] * len(res[i*i:n:i]) return sum(res) 223. 矩形面积题目描述在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例:12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 解题思路分两种情况，第一种是不重叠，第二种重叠123456789101112131415161718class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): """ :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int """ if E &gt;= C or A &gt;= G or F &gt;= D or B &gt;= H: return (C-A)*(D-B) + (G-E)*(H-F) else: return (C-A)*(D-B) + (G-E)*(H-F) - (min(G,C)-max(A,E)) * (min(D,H)-max(B,F)) 231. 2的幂题目描述12345678910111213141516给定一个整数，编写一个函数来判断它是否是 2 的幂次方。示例 1:输入: 1输出: true解释: 20 = 1示例 2:输入: 16输出: true解释: 24 = 16示例 3:输入: 218输出: false 解题思路2的幂的二进制中只有一位是1.12345678910111213141516171819class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False res = 0 while n: if n &amp; 1: res += 1 if res &gt;= 2: return False n &gt;&gt;= 1 return True 2的幂的数 n和(n-1)相与一定是0，不为0则不是2的幂 如8(0000 1000) &amp; 7 (0000 0111) ==024(0001 1000) &amp; 23 (0001 0111) != 0 1234567891011class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False return n&amp;(n-1) == 0 258. 各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例:123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路暴力12345678910111213141516171819class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num while num &gt;= 10: lastn = num nextn = 0 while lastn: nextn += lastn % 10 lastn //= 10 num = nextn return num 余9法。1234567891011假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。 参考1234567891011121314class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num if num % 9 == 0: return 9 else: return num % 9 263. 丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:123输入: 6输出: true解释: 6 = 2 × 3 示例 2:123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3:123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明：121 是丑数。2 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路不断的除5,3,2，最后为1则为丑数 12345678910111213141516class Solution(object): def isUgly(self, num): """ :type num: int :rtype: bool """ if num == 0: return False for x in [5,3,2]: while num and num % x == 0: num //= x if num == 1: return True return False 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路1234567891011121314151617181920212223242526class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 dp = [0] * (n) dp[0] = 1 t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp[i] = min(dp[t2]*2, dp[t3]*3, dp[t5]*5) if dp[t2]*2 == dp[i]: t2 += 1 if dp[t3]*3 == dp[i]: t3 += 1 if dp[t5]*5 == dp[i]: t5 += 1 return dp[-1] 313. 超级丑数题目描述编写一段程序来查找第 n 个超级丑数。 超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。 示例:123输入: n = 12, primes = [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 说明:12341 是任何给定 primes 的超级丑数。 给定 primes 中的数字以升序排列。0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。第 n 个超级丑数确保在 32 位有符整数范围内。 解题思路123456789101112131415161718192021222324252627class Solution(object): def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ if n &lt;= 1: return n dp = [0] * n dp[0] = 1 t = [0] * len(primes) for i in range(1, n): temp = float('inf') for j in range(len(t)): temp = min(temp, dp[t[j]]*primes[j]) dp[i] = temp for j in range(len(t)): if temp == dp[t[j]]*primes[j]: t[j] += 1 return dp[-1] 319. 灯泡开关题目描述初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例:123456789输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 解题思路暴力超时。1234567891011121314151617181920class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 if n &lt;= 3: return 1 dp = [1] * n for i in range(1, n): for i in range(i, n, i+1): dp[i] *= -1 return dp.count(1) 数学法。开平方？12345678class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ return int(n**0.5) 326. 3的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27输出: true示例 2: 输入: 0输出: false示例 3: 输入: 9输出: true示例 4: 输入: 45输出: false进阶：你能不使用循环或者递归来完成本题吗？ 解题思路1234567891011121314class Solution(object): def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 0: return False while n % 3 == 0: n //= 3 return n == 1 365. 水壶问题题目描述有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空示例 1: (From the famous “Die Hard” example)12输入: x = 3, y = 5, z = 4输出: True 示例 2:12输入: x = 2, y = 6, z = 5输出: False 解题思路1234567891011121314151617这是一道脑筋急转弯题，我想很多人以前应该听过这道题目，有一个容量为3升和一个容量为5升的水罐，问我们如何准确的称出4升的水。我想很多人都知道怎么做，先把5升水罐装满水，倒到3升水罐里，这时5升水罐里还有2升水，然后把3升水罐里的水都倒掉，把5升水罐中的2升水倒入3升水罐中，这时候把5升水罐解满，然后往此时有2升水的3升水罐里倒水，这样5升水罐倒出1升后还剩4升即为所求。这个很多人都知道，但是这道题随意给我们了三个参数，问有没有解法，这就比较难了。这里我就照搬网上大神的讲解吧：这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为x和y，问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么我们可以用一个公式来表达：z = m * x + n * y其中m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即3升的水罐往外倒了两次水，5升水罐往里舀了两次水。那么问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立。根据裴蜀定理，ax + by = d的解为 d = gcd(x, y)，那么我们只要只要z % d == 0，上面的等式就有解，所以问题就迎刃而解了，我们只要看z是不是x和y的最大公约数的倍数就行了，别忘了还有个限制条件x + y &gt;= z，因为x和y不可能称出比它们之和还多的水，参见代码如下；时间复杂度很小，但是不会算，空间复杂度是O(1). 参考 123456789101112131415161718class Solution(object): def canMeasureWater(self, x, y, z): """ :type x: int :type y: int :type z: int :rtype: bool """ return z == 0 or (x+y &gt;= z and z % self.gcd(x, y) == 0) def gcd(self, x, y): res = x % y while res != 0: x, y = y, res res = x % y return y 367. 有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：12输入：16输出：True 示例 2：12输入：14输出：False 解题思路二分搜索12345678910111213141516171819202122class Solution(object): def isPerfectSquare(self, num): """ :type num: int :rtype: bool """ if num == 0: return False left, right = 1, int(num**0.5)+1 while left &lt;= right: mid = left + (right-left)//2 if mid*mid == num: return True elif mid*mid &gt; num: right = mid-1 else: left = mid+1 return False 372. 超级次方题目描述你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1:12输入: a = 2, b = [3]输出: 8 示例 2:12输入: a = 2, b = [1,0]输出: 1024 解题思路二分求幂123456789101112131415161718192021class Solution(object): def superPow(self, a, b): """ :type a: int :type b: List[int] :rtype: int """ res = 1 for n in b: res = self.pow(res, 10) * self.pow(a, n) % 1337 return res def pow(self, x, n): if x == 1 or n == 0: return 1 if n % 2: return self.pow(x, n-1) * x % 1337 else: return self.pow(x*x%1337, n//2) % 1337 396. 旋转函数题目描述给定一个长度为 n 的整数数组 A 。 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：1F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。 计算F(0), F(1), …, F(n-1)中的最大值。 注意:可以认为 n 的值小于 105。 示例:12345678A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。 解题思路看了数据规模是10^5，可以知道时间复杂度是O(N)量级，这就难办了。我们为了找规律，先把具体的数字抽象为A,B,C,D，那么我们可以得到：123456789101112F(0) = 0A + 1B + 2C +3DF(1) = 0D + 1A + 2B +3CF(2) = 0C + 1D + 2A +3BF(3) = 0B + 1C + 2D +3A 那么，我们通过仔细观察，我们可以得出下面的规律：123456789F(1) = F(0) + sum - 4DF(2) = F(1) + sum - 4CF(3) = F(2) + sum - 4B 那么我们就找到规律了,1F(i) = F(i-1) + sum - n * A[n-i]， 是个递推公式。我们最后求的是这个所有F(i)中的最大值。 时间复杂度是O(N)，空间复杂度是O(1). 参考12345678910111213141516class Solution(object): def maxRotateFunction(self, A): """ :type A: List[int] :rtype: int """ sumA = sum(A) f = sum(i*A[i] for i in range(len(A))) res = f for i in range(1, len(A)): f = f + sumA - len(A)*A[-i] res = max(res, f) return res 397. 整数替换题目描述给定一个正整数 n，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。n 变为 1 所需的最小替换次数是多少？ 示例 1:12345678输入:8输出:3解释:8 -&gt; 4 -&gt; 2 -&gt; 1 示例 2:12345678910输入:7输出:4解释:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1或7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 解题思路思路1：递归，速度很慢1234567891011121314151617class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n &lt;= 1: return 0 if n == 2: return 1 if n % 2 == 0: return 1 + self.integerReplacement(n//2) else: return 1 + min(self.integerReplacement(n-1), self.integerReplacement(n+1)) 思路2：位运算，速度很快当n是偶数时，直接除2；当n是奇数时，-1还是+1？奇数二进制数一定是01或者11结尾，如果把一个奇数化为4的倍数，变成1的步骤会更少（3除外）：15-&gt;16-&gt;8-&gt;4-&gt;2-&gt;115-&gt;14-&gt;7-&gt;6-&gt;3-&gt;2-&gt;1 因此：如果结尾是01，减1，如果结尾时11，加1，3的时候直接减1。 1234567891011121314151617181920212223class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 res = 0 while n &gt; 1: res += 1 if n % 2 == 0: n &gt;&gt;= 1 else: if n &amp; 2 and n != 3: n += 1 else: n -= 1 return res 400. 第N个数字题目描述在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1:12345输入:3输出:3 示例 2:12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 解题思路一位数字有9个，有9位；2位数字有910=90个，有290=180位；3位数字有9100=900个，有3900=2700位； 首先找到n是几位数字，然后找到n是所在位数的第几个数字，最后求在这个数字的第几位上。 1234567891011121314151617181920212223class Solution(object): def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt;= 9: return n bitlen = 1 count = 9 start = 1 while n &gt; bitlen*count: n -= bitlen*count bitlen += 1 count *= 10 start *= 10 res = start + (n-1) // bitlen return str(res)[(n-1) % bitlen]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 哈希表]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是哈希表相关题目题解总结。 [TOC] 哈希表哈希表使用O(N)的空间复杂度存储数据，并且以O(1)的时间复杂度求解问题。 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i 3. 无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2:123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3:1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 解题思路使用字典保存字符最后一次出现的位置，如果这个字符在前面出现过，即这个区间已经有重复的字符了，需要更新左边界，移动到当前遍历字符在字典中保存的位置的下一个位置，同时更新当前字符的位置（右边界）。 123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 left = 0 Dict = &#123;&#125; for right in range(len(s)): if s[right] in Dict: left = max(left, Dict[s[right]]+1) Dict[s[right]] = right res = max(res, right-left+1) return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 36. 有效的数独题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ ["5","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]]输出: true 示例 2:123456789101112131415输入:[ ["8","3",".",".","7",".",".",".","."], ["6",".",".","1","9","5",".",".","."], [".","9","8",".",".",".",".","6","."], ["8",".",".",".","6",".",".",".","3"], ["4",".",".","8",".","3",".",".","1"], ["7",".",".",".","2",".",".",".","6"], [".","6",".",".",".",".","2","8","."], [".",".",".","4","1","9",".",".","5"], [".",".",".",".","8",".",".","7","9"]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 解题思路遍历每一个不为’.’的位置，将其值保存下来，并将其所在位置暂时替换为无关字符，然后判断其所在行、列和9宫格内是否重复，如果重复则直接返回，否则将其位置重新赋原来的值。1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False for x in range(len(board)): for y in range(len(board[0])): if board[x][y] == '.': continue val = board[x][y] board[x][y] = 'D' if not self.isValid(x, y, board, val): return False else: board[x][y] = val return True def isValid(self, x, y, board, val): for i in range(len(board)): if board[i][y] == val: return False for i in range(len(board[0])): if board[x][i] == val: return False for i in range(3): for j in range(3): if board[(x//3)*3+i][(y//3)*3+j] == val: return False return True 依次判断行、列和九宫格是否有重复的，使用set去重然后与没去重的比较长度。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False return self.isValidRow(board) and self.isValidCol(board) and self.isValidSpace(board) def isValidRow(self, board): for row in range(len(board)): temp = [board[row][col] for col in range(len(board[0])) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidCol(self, board): for col in range(len(board[0])): temp = [board[row][col] for row in range(len(board)) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidSpace(self, board): for i in range(0, len(board), 3): for j in range(0, len(board[0]), 3): temp = [] for row in range(3): for col in range(3): if board[row+i][col+j] != '.': temp.append(board[row+i][col+j]) if len(set(temp)) != len(temp): return False return True 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ for i in range(9): if not self.judge(board[i]): return False for i in range(9): temp = [] for j in range(9): temp.append(board[j][i]) if not self.judge(temp): return False for i in range(0,9,3): for j in range(0,9,3): temp = [] for row in range(3): for col in range(3): temp.append(board[row+i][col+j]) if not self.judge(temp): return False return True def judge(self, nums): Dict = &#123;&#125; for x in nums: if x == '.': continue if x in Dict: return False Dict[x] = 1 return True 49. 字母异位词分组题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: ["eat", "tea", "tan", "ate", "nat", "bat"],输出:[ ["ate","eat","tea"], ["nat","tan"], ["bat"]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路遍历字符串，对字符串进行排序，使用字典将同样的字符串放在一起。 123456789101112131415161718192021222324class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ if len(strs) == 0: return [] Dict = &#123;&#125; for x in strs: temp = ''.join(sorted(x)) if temp not in Dict: Dict[temp] = [x] else: Dict[temp].append(x) # res = []# for val in Dict.values():# res.append(val) # return res return list(Dict.values()) 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: "0.5" 示例 2:12输入: numerator = 2, denominator = 1输出: "2" 示例 3:12输入: numerator = 2, denominator = 3输出: "0.(6)" 解题思路用字典保存余数及余数对应的结果的长度，当余数存在于字典中时，说明为循环小数，循环起始位字典中保存的位置。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ res = '' if numerator * denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) residue = numerator % denominator if residue == 0: return res res += '.' Dict = &#123;&#125; Dict[residue] = len(res) while residue: numerator = residue * 10 res += str(numerator // denominator) residue = numerator % denominator if residue not in Dict: Dict[residue] = len(res) else: start = Dict[residue] res = res[:start] + '(' + res[start:] + ')' break return res 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"输出: ["AAAAACCCCC", "CCCCCAAAAA"] 解题思路12345678910111213141516class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 242. 有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1:12输入: s = "anagram", t = "nagaram"输出: true 示例 2:12输入: s = "rat", t = "car"输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路水123456789class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ return sorted(s) == sorted(t) 词频统计1234567891011121314151617181920212223class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(s) != len(t): return False scnt = [0] * 26 tcnt = [0] * 26 for i in range(len(s)): scnt[ord(s[i]) - 97] += 1 tcnt[ord(t[i]) - 97] += 1 for i in range(26): if scnt[i] != tcnt[i]: return False return True 274. H指数题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）” 示例:1234输入: citations = [3,0,6,1,5]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 解题思路好难理解。。。1234567891011121314151617class Solution(object): def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ if len(citations) == 0: return 0 maxi = len(citations) for x in sorted(citations):#假设h为N 那么所有的论文引用次数都大于等于N，如果存在引用次数小于N,h- if x &gt;= maxi: break else: maxi -= 1 return maxi 290. 单词模式题目描述给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。 这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。 示例1:12输入: pattern = "abba", str = "dog cat cat dog"输出: true 示例 2:12输入:pattern = "abba", str = "dog cat cat fish"输出: false 示例 3:12输入: pattern = "aaaa", str = "dog cat cat dog"输出: false 示例 4:12输入: pattern = "abba", str = "dog dog dog dog"输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路分别将pattern和str分割，如果长度不一致则返回False 使用hash表，遍历pattern，依次保存pattern和str的映射关系 如果某个pattern[i]不存在hash表中，需要首先判断对应的str[i]是否已经在hash表中，如果在说明该str[i]已经被其他pattern占用，返回False; 如果某个pattern[i]已经在hash中，那么只需要判断当前对应的str[i]是否和保存起来的str是否一致即可。 12345678910111213141516171819202122232425class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ pattern = list(pattern) str = str.split() if len(pattern) != len(str): return False Dict = &#123;&#125; for i in range(len(pattern)): if pattern[i] not in Dict: if str[i] in Dict.values(): return False Dict[pattern[i]] = str[i] else: if str[i] != Dict[pattern[i]]: return False return True 299. 猜数字游戏题目描述你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1:12345输入: secret = "1807", guess = "7810"输出: "1A3B"解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2:12345输入: secret = "1123", guess = "0111"输出: "1A1B"解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 解题思路用hash表保存secret中数字重现的次数；定义两个变量，allmatch统计secret和guess中都出现的次数，另一个统计Bulls；然后遍历guess，如果当前字符在hash中出现过，说明这个字符在secret和guess都出现过，allmatch+=1，同时判断位置在这secret和guess的位置是否相同，相同Bulls+=1;最后Cows = allmatch - bulls。 12345678910111213141516171819202122232425262728293031class Solution(object): def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ if len(secret) != len(guess) or len(secret) == 0: return "" Dict = &#123;&#125; for c in secret: if c not in Dict: Dict[c] = 1 else: Dict[c] += 1 allmatch = 0 Bulls = 0 for i in range(len(guess)): if guess[i] in Dict and Dict[guess[i]] != 0: Dict[guess[i]] -= 1 allmatch += 1 if secret[i] == guess[i]: Bulls += 1 Cows = allmatch - Bulls return str(Bulls) + 'A' + str(Cows) + 'B' 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路hash统计，values降序，取前k个 123456789101112131415161718192021class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums) &lt; k or k &lt;= 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 Dict = sorted(Dict.items(), key = lambda item:-item[1]) return [Dict[i][0] for i in range(k)] 349. 两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。解题思路 123456789101112131415161718class Solution(object): def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] res = [] for x in nums2: if x in nums1 and x not in res: res.append(x) return res 350. 两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路先用hash表将nums1的数字和对应次数保存起来，遍历nums2，查看当前遍历元素是否在Dict中存在，且次数大于0,如果存在需要将Dict[x] -= 11234567891011121314151617181920212223242526class Solution(object): def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] Dict = &#123;&#125; for x in nums1: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in nums2: if x in Dict and Dict[x] != 0: res.append(x) Dict[x] -= 1 return res 389. 找不同题目描述给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例:123456789输入：s = "abcd"t = "abcde"输出：e解释：'e' 是那个被添加的字母。 解题思路123456789101112131415161718192021class Solution(object): def findTheDifference(self, s, t): """ :type s: str :type t: str :rtype: str """ if not t or len(s) &gt;= len(t): return '' s = list(s) for c in t: if c not in s: return c else: s.remove(c) return '']]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 位运算]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是位运算相关题目题解总结。 [TOC] 位运算基本原理0s表示一串0，1s表示一串1。123x^0s = x x&amp;0s = 0 x|0s = xx^1s = ~x x&amp;1s = x x|1s = 1sx^x = 0 x&amp;x = x x|x = x 利用x^1s=~x的特点，可以将位级表示翻转； 利用x^x=0的特点，可以将三个数中重复的两个数去除，只留下另一个数； 利用x&amp;0s=0和x&amp;1s=x的特点，可以实现掩码操作，一个数num与mask进行位与操作，只保留num中与mask的1部分相对应的位；例如num:10101010和mask:00111100，进行位与操作得00101000。 利用x|0s=x和x|1s=1s的特点，可以实现设值操作，一个数num与mask进行位或操作，将num中与mask中的1部分相对应的位都设置为1；例如num:10101010和mask:00111100，进行位或操作得10111110。 位与运算技巧： n&amp;(n-1) 表示去掉n的位级表示中最低位的1。例如n:10110100，减去1得到10110011，将这两个数相与得到10110000。 n&amp;(-n)表示n的位级表示中的最低位的1，-n得到n的反码加1，对于二进制表示10110100，-n得到01001100，相与得到00000100。 n-n&amp;(~n+1)表示去掉n的位级表示中的最高位的1。例如n:10110100，则n-n&amp;(~n+1): ??? 移位运算： &gt;&gt;n为算术右移，相当于除以2^n； &gt;&gt;n为无符号右移，左边会补上0； &lt;&lt;n为算术左移，相当于乘以2^n。 mask计算： 要获取11111111，将0取反即可，~0； 要得到只有第i位为1的mask，将1向左移动i-1位即可，1&lt;&lt;(i-1)。例如1&lt;&lt;4得到只有第5位为1的mask：00010000； 要得到1到i位为1的mask，(1&lt;&lt;(i+1))-1即可，例如将1&lt;&lt;(4+1)-1=00010000-1=00001111； 要得到1到i位为0的mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。 参考 136. 只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 解题思路方法1：使用异或操作，一个数自己异或自己等于0, 一个数异或0等于数本身，即把所有数字进行异或操作，如果一个数出现两次，则变为0消失，最后剩下只出现一次的数字。 123456789101112class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for x in nums: res ^= x return res 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。1234567891011121314151617class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key in Dict: if Dict[key] == 1: return key 137. 只出现一次的数字 II题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,3,2]输出: 3 示例 2:12输入: [0,1,0,1,0,1,99]输出: 99 解题思路方法1：位运算，把32位的二进制数进行遍历，统计所有数字的每一位出现0或1的次数。因为每个数字出现3次或者1次，当某一位出现次数不为3时，则一定是出现1次，使用或操作将每个位置叠加起来。python的整形没有最大值，当输入是负数时，会认为是很大的正数，如果大于2^31-1时，则需要减去2^32。1234567891011121314151617181920class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count % 3 == 1: res |= mask mask &lt;&lt;= 1 return res if res &gt;&gt; 31 == 0 else res-(1&lt;&lt;32) 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。123456789101112131415161718class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val == 1: return key 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1:12输入: [3,2,3]输出: 3 示例 2:12输入: [2,2,1,1,1,2,2]输出: 2 解题思路方法1：将原数组排序nums.sort()， 返回nums[len(nums)//2]; 方法2：使用字典记录每个数出现的次数，返回出现次数大于len(nums)//2的数；优化：在计数时同时判断数字出现的次数，只用一个for循环； 方法3：位运算，遍历二进制的每一位，每一位上的1或0（代码使用1）出现次数大于一半，即为所求的值在该位上的值，统计每一位的1或0组合即可，减去2^32对负数进行处理。以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去2 ^ 32。 1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count &gt; len(nums)//2: res |= mask break mask &lt;&lt;= 1 return res if res&gt;&gt;31 == 0 else res - (1&lt;&lt;32) 方法4：摩尔投票法，待续。 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"输出: ["AAAAACCCCC", "CCCCCAAAAA"] 解题思路方法1：遍历+set，从头到尾把字符串遍历，然后判断这10个字母是否已经出现过，如果出现过，则加入结果中，否则，加入辅助集合中。用set是因为一个字符串可能出现多次，为了防止重复添加到结果中，使用set去重。时间空间复杂度均为O(N)。1234567891011121314151617class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ if len(s) &lt; 10: return [] res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 方法2：位运算，待续 190. 颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1：1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 解题思路使用python二进制转换。12345678class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = '&#123;0:032b&#125;'.format(n) # 032b的0用于填充，0:32b为' 10100101000001111010011100'，0:032b为'00000010100101000001111010011100' res = res[::-1] res = int(res,2) return res 位运算。从n的最后一位向前遍历，放到res的后面，并且res向左移动。 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 for i in range(32): res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return res 12345678910111213class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 count = 0 while n: res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 count += 1 res = res&lt;&lt;(32-count) return res 191. 位1的个数题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题思路123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 while n: if n&amp;1: res += 1 n &gt;&gt;= 1 return res 123456789101112131415class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 mask = 1 for i in range(32): if mask &amp; n: res += 1 mask &lt;&lt;= 1 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 双指针]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是双指针相关题目题解总结。 [TOC] 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 28. 实现strStr()题目描述实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1:12输入: haystack = "hello", needle = "ll"输出: 2 示例 2:12输入: haystack = "aaaaa", needle = "bba"输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路123456789101112131415161718class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if len(needle) == 0: return 0 if len(haystack) == 0 or len(haystack) &lt; len(needle): return -1 for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 80. 删除排序数组中的重复项 II题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) left = 0 for n in nums: if left &lt; 2 or n &gt; nums[left-2]: nums[left] = n left += 1 return left 88. 合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出:[1,2,2,3,5,6] 解题思路 从尾向前遍历，设置两个指针p1和p2遍历数组，p1，p2分别从m-1和n-1开始向前遍历； 每一次遍历将大的元素放到nums1后面（最后一位为m-n+1），并向前移动一步，直到一个数组先遍历完成； 若nums1首先遍历完成，则需要将nums2剩下的元素放到nums1的前面。 123456789101112131415161718192021222324252627class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ if len(nums1)&lt; m+n: return False p1,p2 = m-1,n-1 point = m+n-1 while p1&gt;= 0 and p2 &gt;= 0: if nums1[p1]&lt;nums2[p2]: nums1[point] = nums2[p2] p2 -= 1 else: nums1[point] = nums1[p1] p1 -= 1 point -= 1 if p2 &gt;= 0: nums1[:p2+1] = nums2[:p2+1]if __name__ == '__main__': result = Solution().merge([1,2,3,0,0,0],3,[2,5,6],3) print(result) 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 141. 环形链表题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用双指针，一个一次走两步，另一个一次走一步，若有环，则必然相遇。 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始， 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2。 解题思路使用两个指针left和right，left指向数组第一个元素并从头向后遍历，right指向数组最后一个元素并从尾向前遍历： 如果两个指针指向元素之和numbers[left]+numbers[right] == target, 则返回 [left+1,right+1]，结束； 如果两个指针指向元素之和numbers[left]+numbers[right] &gt; target，则right -= 1； 如果两个指针指向元素之和numbers[left]+numbers[right] &lt; target，则left += 1。 12345678910111213141516171819202122class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt; 2: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().twoSum([2,7,11,15], 9) print(result) 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路123456789101112131415161718192021class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt;= 1: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return [] 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路12345678910111213141516171819class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ left, right = 0, 0 res = float('inf') while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res != float('inf') else 0 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “leetcode”输出: “leotcede” 说明: 元音字母不包含字母”y”。 解题思路元音字母有五个：aAeEIioOuU。使用双指针，left从头向后遍历，right从后向前遍历，分别找到元音字母时时进行一次交换。 1234567891011121314151617181920212223class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ vowels = 'aAeEiIoOuU' s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in vowels: left += 1 while right &gt; left and s[right] not in vowels: right -= 1 if left &lt; right: s[left],s[right] = s[right], s[left] left += 1 right -= 1 return ''.join(s)if __name__ == '__main__': result = Solution().reverseVowels("leetcode") print(result) 524. 通过删除字母匹配到字典里最长单词题目描述给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例 1: 输入:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出:“apple” 示例 2: 输入:s = “abpcplea”, d = [“a”,”b”,”c”]输出:“a” 说明: 所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 解题思路先把d中元素排序，以长度为主，字典序为辅；然后遍历d中字符串，依此判断是否满足条件，满足条件则返回；因为经过了排序，第一个满足条件的可以保证返回长度最长且字典顺序最小的字符串。 123456789101112131415161718192021222324252627282930313233class Solution(object): def findLongestWord(self, s, d): """ :type s: str :type d: List[str] :rtype: str """ if len(d) == 0 or len(s) == 0: return '' d = sorted(d, key=lambda x: (-len(x), x)) res = '' for x in d: if self.judge(s,x): return x return '' def judge(self,s,x): if len(s) &lt; len(x): return False p1,p2 = 0, 0 while p1 &lt; len(s) and p2 &lt; len(x): if s[p1] == x[p2]: p1 += 1 p2 += 1 else: p1 += 1 if p2 == len(x): return True return Falseif __name__ == '__main__': result = Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) print(result) 633. 平方数之和题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1： 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 解题思路假设\(a=0\)，则 \(b=\sqrt{c}\)，则最大整数为 \(\sqrt{c}\)，设置两个指针，left指向0并向前遍历，right指向\(\sqrt{c}\)并向后遍历： 如果 left*left+right*right = c， 返回True,结束； 如果 left*left+right*right &gt; c， right -= 1； 如果 left*left+right*right &lt; c， left += 1； 123456789101112131415161718192021class Solution(object): def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ if c &lt; 0: return False left, right = 0, int(pow(c,1.0/2)) while left &lt;= right: if left*left+right*right == c: return True elif left*left+right*right &gt; c: right -= 1 else: left += 1 return Falseif __name__ == '__main__': result = Solution().judgeSquareSum(6) print(result) 680. 验证回文字符串 Ⅱ题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意： 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路使用双指针，找到第一个不相等的位置后，去除left或着right后判断是否成为回文。 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): """ :type s: str :rtype: bool """ left, right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return self.isPalindrome(s[:left]+s[left+1:]) or self.isPalindrome(s[:right]+s[right+1:]) left += 1 right -= 1 return True def isPalindrome(self,s): left ,right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == '__main__': result = Solution().validPalindrome("aba") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 排序]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是排序相关题目题解总结。 [TOC] 排序快速排序用于求解 Kth 问题，使用快速排序的partition()进行实现，需要首先打乱数组，否则最坏情况下时间复杂度为O(N^2)。 堆排序用于求解 TopK 问题，通过维护一个大小为K的堆，堆中的元素就是TopK elements； 堆排序也可以用于求解 Kth 问题，堆顶元素就是 Kth elements； 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements； 因此快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 56. 合并区间题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 将区间按起始元素排序，新建返回res数组，遍历所有区间； 若res为空或res中最后一个区间的结束元素小于当前区间的起始元素，则无需合并，直接将该区间添加到res中；若res中最后一个区间的结束元素大于当前区间的起始元素，则需要合并，将res最后区间的结束元素置为原来的值与当前区间结束值的最大值。 1234567891011121314151617181920# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ intervals = sorted(intervals, key=lambda x:x.start) res = [] for t in intervals: if not res or res[-1].end &lt; t.start: res.append(t) else: res[-1].end = max(res[-1].end,t.end) return res 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 147. 对链表进行插入排序题目描述对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。 示例 1： 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路插入排序：插入排序的实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），用指针 head 逐一向后遍历 申请一个 dummyHead 节点，其下一个节点指向头结点。如果要在头结点出插入，dummyHead 会给我们带来便利； 当 head 的值不大于下一节点值，就进行遍历下一节点； 当 head 的值大于下一节点，那么就将 head 的下一节点取出，从前向后扫描，在第一个比它的值大的节点之前插入该节点。 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: temp = head.next q = dummy head.next = head.next.next while q.next and q.next.val &lt; temp.val: q = q.next temp.next = q.next q.next = temp return dummy.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head and head.next: if head.val &lt;= head.next.val: head = head.next else: pre = dummy while pre.next and pre.next.val &lt;= head.next.val: pre = pre.next temp = head.next head.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路使用归并排序，使用快慢指针找到中间结点后进行递归。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Nonehead = ListNode(4)head.next = ListNode(2)head.next.next = ListNode(1)head.next.next.next = ListNode(3)class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None # left = self.sortList(leftHead) # right = self.sortList(rightHead) # sortMerge = self.merge(left,right) # return sortMerge return self.merge(self.sortList(leftHead),self.sortList(rightHead)) def getmiddle(self,head): if not head: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self,leftHead,rightHead): dummyNode = ListNode(0) dummyHead = dummyNode i,j = leftHead, rightHead while i and j: if i.val &lt; j.val: dummyNode.next = i i = i.next else: dummyNode.next = j j = j.next dummyNode = dummyNode.next if i: dummyNode.next = i if j: dummyNode.next = j return dummyHead.nextif __name__ == '__main__': result = Solution().sortList(head) while result: print(result.val,end = ' ') result = result.next 179. 最大数题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2]输出: 210 示例 2: 输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路两层循环遍历，每一个数和之后的每一个数进行比较，交换大的数放在前面；两个数谁应该放在前面：拼接两个字符串进行比较 a+b&gt;b+a，则a在前面。 1234567891011121314151617class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ if len(nums) == 0: return '0' if len(nums) == 1: return str(nums[0]) for i in range(len(nums)-1): for j in range(i+1, len(nums)): if str(nums[i])+str(nums[j]) &lt; str(nums[j])+str(nums[i]): nums[i], nums[j] = nums[j], nums[i] return '0' if nums[0] == 0 else ''.join([str(x) for x in nums]) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路思路1：利用堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质；即子结点的键值或索引总是小于（或者大于）它的父节点。 通常堆是通过一维数组来实现的。在起始数组为 0 的情形中 父节点i的左子节点在位置 (2i+1)；父节点i的右子节点在位置 (2i+2)；子节点i的父节点在位置 floor((i-1)/2)。 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作 最大堆调整（Min_Heapify）：将堆的末端子结点作调整，使得子结点永远小于父结点；创建最大堆（Build_Min_Heap）：将堆所有数据重新排序;注：堆排序不是一种稳定排序。 用小根堆得办法寻找最大的K个数 用容量为K的最小堆来存储最大的K个数。最小堆的堆顶元素就是最大K个数中的最小的一个；每次扫描一个数据X，如果X比堆顶元素Y小，则不需要改变原来的堆。如果X比堆顶元素大；那么用X替换堆顶元素Y，在替换之后，X可能破坏了最小堆的结构，需要调整堆来维持堆的性质；调整过程时间复杂度为O(logK)。 全部的时间复杂度为O(N*logK)；这种方法当数据量比较大的时候，比较方便。因为对所有的数据只会遍历一次。 堆排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k,len(nums)+1): if change: for j in range(k//2,-1,-1): self.adjust(res,j,k) for j in range(k-1,0,-1): res[j],res[0] = res[0],res[j] self.adjust(res,0,j) change = False if i != len(nums) and nums[i] &gt; res[k-1]: res[k-1] = nums[i] change = True return res[k-1] def adjust(self,res,parent,length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1]&lt;res[child]: child = child+1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = tempif __name__ == '__main__': result = Solution().findKthLargest([3,2,3,1,2,4,5,5,6],4) print(result) 思路2：利用快速排序 快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：分割左边都是比它小的数，右边都是比它大的数。 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，因此达到整个数据变成有序序列。 举例：nums = [3,2,1,5,6,4] 首先以nums[0]=3为基准点，设置指针left指向第一个元素(0)，right指向最后一个元素(len(nums)-1)； 从右至左偏移right指针，寻找到第一个比基准点3小的元素，将该元素(这里为1)赋给left指针所指的位置，此时数组为[1,2,1,5,6,4]; 从左至右偏移left指针，寻找到第一个比基准点3大的元素，将该元素赋给right指针所指的位置，此时数组 不断循环步骤一二，知道left和right重合，将基准点3赋给重合位置，一轮排序结束数组为[1,2,3,5,6,4]; 经过递归过程，最后排序结束。 **快速排序1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left 思路3：归并排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = self.dfs(nums) return res[-k] def dfs(self, nums): if len(nums) &lt;= 1: return nums mid = len(nums)//2 left = self.dfs(nums[:mid]) right = self.dfs(nums[mid:]) return self.merge(left, right) def merge(self, left, right): res = [] i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 if i &lt; len(left): res += left[i:] else: res += right[j:] return res 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 451. 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 栈和队列]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是栈和队列相关题目题解总结。 [TOC] 栈和队列栈的顺序为后进先出，队列 的顺序为先进先出。 20. 有效的括号题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: "()"输出: true 示例 2:12输入: "()[]&#123;&#125;"输出: true 示例 3:12输入: "(]"输出: false 示例 4:12输入: "([)]"输出: false 示例 5:12输入: "&#123;[]&#125;"输出: true 解题思路使用栈，遍历字符串，当栈为空或者当前字符为左括号’(‘,’[‘,’{‘时或者为右括号但是栈顶字符与其不匹配，则将字符加入栈，否则栈顶字符出栈。最后判断栈是否为空。12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ if not s: return True Dict = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for c in s: if not stack or c not in Dict or stack[-1] != Dict[c]: stack.append(c) else: stack.pop() return True if not stack else False 71. 简化路径题目描述以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：123输入："/home/"输出："/home"解释：注意，最后一个目录名后面没有斜杠。 示例 2：123输入："/../"输出："/"解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：123输入："/home//foo/"输出："/home/foo"解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：12输入："/a/./b/../../c/"输出："/c" 示例 5：12输入："/a/../../b/../c//.//"输出："/c" 示例 6：12输入："/a//b////c/d//././/.."输出："/a/b/c" 解题思路将字符串按照‘/‘分隔得到了每个文件的目录，然后遍历每个目录进行入栈或者出栈。如果目录为空或者为当前目录’.’，则不进行任何操作；如果为’..’，表示返回上一级目录，如果栈中有上级目录，则将其弹出。 12345678910111213141516171819class Solution(object): def simplifyPath(self, path): """ :type path: str :rtype: str """ if not path: return '/' stack = [] path = path.split('/') for c in path: if not c or c == '.': continue if c == '..': if stack: stack.pop() else: stack.append(c) return '/'+'/'.join(stack) 150. 逆波兰表达式求值题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：123输入: ["2", "1", "+", "3", "*"]输出: 9解释: ((2 + 1) * 3) = 9 示例 2：123输入: ["4", "13", "5", "/", "+"]输出: 6解释: (4 + (13 / 5)) = 6 示例 3：12345678910输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 12345678910111213141516171819202122232425class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for c in tokens: if c not in ('+','-','*','/'): stack.append(c) else: a = int(stack.pop()) b = int(stack.pop()) if c == '+': stack.append(str(b+a)) if c == '-': stack.append(str(b-a)) if c == '*': stack.append(str(b*a)) if c == '/': if b*a &lt; 0 and b%a != 0: stack.append(str(b/a+1)) else: stack.append(str(b/a)) return int(stack[0]) 155. 最小栈题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.data = [] self.min = [] def push(self, x): """ :type x: int :rtype: void """ self.data.append(x) if not self.min or x &lt;= self.min[-1]: self.min.append(x) def pop(self): """ :rtype: void """ val = self.data.pop() if val == self.min[-1]: self.min.pop() def top(self): """ :rtype: int """ return self.data[-1] def getMin(self): """ :rtype: int """ return self.min[-1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin()]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是字符串相关题目题解总结。 [TOC] 6. Z 字形变换题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数：1string convert(string s, int numRows); 示例 1:12输入: s = "LEETCODEISHIRING", numRows = 3输出: "LCIRETOESIIGEDHN" 示例 2:12345678输入: s = "LEETCODEISHIRING", numRows = 4输出: "LDREOEIIECIHNTSG"解释:L D RE O E I IE C I H NT S G 解题思路将字符分为numRows保存，遍历字符串，从上到下和从下到上反复将字符加到对应的行里，当遍历到第一行时，index递增，当遍历到最后一行时，index递减。 12345678910111213141516171819202122232425class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): return s res = ['' for i in range(numRows)] index = 0 step = 1 for x in s: res[index] += x if index == 0: step = 1 elif index == numRows-1: step = -1 index += step return ''.join(res) 14. 最长公共前缀题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: ["flower","flow","flight"]输出: "fl" 示例 2:123输入: ["dog","racecar","car"]输出: ""解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路首先把第一个字符串作为答案，然后遍历后面的字符串，当后面的字符串长度小于第一个字符串时，需要对第一个字符串进行裁剪，然后依次判断每一个字符是否相等，不相等时将第一个字符串裁剪。 12345678910111213141516171819202122class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' res = strs[0] for i in range(1, len(strs)): if len(res) &gt; len(strs[i]): res = res[:len(strs[i])] for j in range(len(res)): if res[j] != strs[i][j]: res = res[:j] break if res == '': return '' return res 38. 报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。 11 被读作 “two 1s” (“两个一”）, 即 21。 21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:12输入: 1输出: "1" 示例 2:12输入: 4输出: "1211" 解题思路1234567891011121314151617181920212223class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return '1' pre = '1' for i in range(1, n): count = 1 res = '' for j in range(1, len(pre)): if pre[j] == pre[j-1]: count += 1 else: res += str(count) + pre[j-1] count = 1 res += str(count) + pre[-1] pre = res return res 58. 最后一个单词的长度题目描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: "Hello World"输出: 5 解题思路库函数。123456789101112class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 s = s.split() return len(s[-1]) if s else 0 双指针，一个指向最后一个单词的末尾，一个指向最后一个单词的开头。1234567891011121314151617181920class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 left, right = 0, len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 left = right while left &gt;= 0 and s[left] != ' ': left -= 1 return right - left 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: "aab"输出:[ ["aa","b"], ["a","a","b"]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = "leetcode", wordDict = ["leet", "code"]输出: true解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。 示例 2：1234输入: s = "applepenapple", wordDict = ["apple", "pen"]输出: true解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 151. 翻转字符串里的单词题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例:12输入: "the sky is blue",输出: "blue is sky the". 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 解题思路库函数1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return ' '.join(s.split()[::-1]) 自己写的。先将头尾的空格去掉，新建一个字符串，将单词字符加入，去掉多余的空格。 然后先将整个字符串翻转，在将每个单词翻转。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ if not s: return "" left = 0 while left &lt; len(s) and s[left] == ' ': left += 1 right = len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 s = s[left:right+1] newstring = '' i = 0 while i &lt; len(s): if s[i] != ' ': newstring += s[i] i += 1 else: newstring += ' ' while i &lt; len(s) and s[i] == ' ': i += 1 newstring = list(newstring) self.reverse(newstring, 0, len(newstring)) start, end = 0, 0 while end &lt; len(newstring): while end &lt; len(newstring) and newstring[end] != ' ': end += 1 self.reverse(newstring, start, end) start = end + 1 end = start return ''.join(newstring) def reverse(self, s, start, end): left, right = start, end-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 165. 比较版本号题目描述比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1:12输入: version1 = "0.1", version2 = "1.1"输出: -1 示例 2:12输入: version1 = "1.0.1", version2 = "1"输出: 1 示例 3:12输入: version1 = "7.5.2.4", version2 = "7.5.3"输出: -1 示例 4：123输入：version1 = "1.01", version2 = "1.001"输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5：123输入：version1 = "1.0", version2 = "1.0.0"输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示： 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。 版本字符串不以点开始或结束，并且其中不会有两个连续的点。 解题思路先将两个版本号以’.’分隔为两个列表，然后按位比较，短的补零。1234567891011121314151617181920212223242526class Solution(object): def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ if not version1 or not version2: return 0 version1 = version1.split('.') version2 = version2.split('.') i = 0 while i &lt; len(version1) or i &lt; len(version2): v1 = version1[i] if i &lt; len(version1) else 0 v2 = version2[i] if i &lt; len(version2) else 0 if int(v1) &gt; int(v2): return 1 if int(v1) &lt; int(v2): return -1 i += 1 return 0 227. 基本计算器 II题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:12输入: "3+2*2"输出: 7 示例 2:12输入: " 3/2 "输出: 1 示例 3:12输入: " 3+5 / 2 "输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路用num保存上一个数字，用pre_op保存上一个操作符。当遇到新的操作符的时候，需要根据pre_op进行操作。乘除的优先级高于加减。所以有以下规则： 之前的运算符是+，那么需要把之前的数字num进栈，然后等待下一个操作数的到来。 之前的运算符是-，那么需要把之前的数字求反-num进栈，然后等待下一个操作数的到来。 之前的运算符是×，那么需要立刻出栈和之前的数字相乘，重新进栈，然后等待下一个操作数的到来。 之前的运算符是/，那么需要立刻出栈和之前的数字相除，重新进栈，然后等待下一个操作数的到来。 注意比较的都是之前的操作符和操作数，现在遇到的操作符是没有什么用的。 另外，坑爹的Python地板除。 参考 12345678910111213141516171819202122232425262728293031323334class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 stack = [] num = 0 pre_op = '+' for i in range(len(s)): if s[i] in '0123456789': num = num*10+int(s[i]) if i == len(s)-1 or s[i] in '+-*/': if pre_op == '+': stack.append(num) elif pre_op == '-': stack.append(-num) elif pre_op == '*': stack.append(stack.pop()*num) elif pre_op == '/': top = stack.pop() if top*num &lt; 0 and top % num != 0: stack.append(top // num + 1) else: stack.append(top // num) pre_op = s[i] num = 0 return sum(stack) 344. 反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：12输入：["h","e","l","l","o"]输出：["o","l","l","e","h"] 示例 2：12输入：["H","a","n","n","a","h"]输出：["h","a","n","n","a","H"] 解题思路12345678class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ s[:] = s[::-1] 1234567891011121314class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left, right = left + 1, right - 1 return 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:12输入: "hello"输出: "holle" 示例 2:12输入: "leetcode"输出: "leotcede" 说明:元音字母不包含字母”y”。 解题思路12345678910111213141516171819class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in 'aAeEiIoOuU': left += 1 while right &gt; left and s[right] not in 'aAeEiIoOuU': right -= 1 s[left], s[right] = s[right], s[left] left, right = left+1, right-1 return ''.join(s) 383. 赎金信题目描述给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。123canConstruct("a", "b") -&gt; falsecanConstruct("aa", "ab") -&gt; falsecanConstruct("aa", "aab") -&gt; true 解题思路遍历ransomNote，如果不在magazine，返回False，如果在，删除magazine中对应的字符。 需要转成list才可以用remove。 12345678910111213141516171819202122class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if len(ransomNote ) == 0: return True if len(magazine) == 0: return False magazine = list(magazine) for x in ransomNote: if x not in magazine: return False else: magazine.remove(x) return True 385. 迷你语法分析器题目描述给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。 列表中的每个元素只可能是整数或整数嵌套列表 提示：你可以假定这些字符串都是格式良好的： 字符串非空字符串不包含空格字符串只包含数字0-9, [, - ,, ] 示例 1：123456给定 s = "324",你应该返回一个 NestedInteger 对象，其中只包含整数值 324。``` 示例 2： 给定 s = “[123,[456,[789]]]”, 返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表： 一个 integer 包含值 123 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273###解题思路###不太理解。[参考](https://leetcode.com/problems/mini-parser/discuss/86221/Easy-Python-recursive-solution-and-stack-solution-please-be-careful-about-time-complexity)```python# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def __init__(self, value=None):# """# If value is not specified, initializes an empty list.# Otherwise initializes a single integer equal to value.# """## def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def add(self, elem):# """# Set this NestedInteger to hold a nested list and adds a nested integer elem to it.# :rtype void# """## def setInteger(self, value):# """# Set this NestedInteger to hold a single integer equal to value.# :rtype void# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class Solution(object): def deserialize(self, s): """ :type s: str :rtype: NestedInteger """ if len(s) == 0: return NestedInteger() if s[0] != '[': return NestedInteger(int(s)) res = NestedInteger() numP, start = 0, 1 for i in range(1, len(s)): if (numP == 0 and s[i] == ',') or i == len(s)-1: if start &lt; i: res.add(self.deserialize(s[start:i])) start = i + 1 elif s[i] == '[': numP += 1 elif s[i] == ']': numP -= 1 return res 387. 字符串中的第一个唯一字符题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = "leetcode"返回 0.s = "loveleetcode",返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路两次遍历 12345678910111213141516171819202122class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return -1 Dict = &#123;&#125; for x in s: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for i in range(len(s)): if Dict[s[i]] == 1: return i return -1 415. 字符串相加题目描述给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路123456789101112131415161718192021222324252627282930313233343536class Solution(object): def addStrings(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ midsum = [] num1, num2 = num1[::-1], num2[::-1] index = 0 while index &lt; len(num1) and index &lt; len(num2): midsum.append(ord(num1[index])-48 + ord(num2[index]) - 48) index += 1 if index == len(num1): for i in range(index, len(num2)): midsum.append(ord(num2[i]) - 48) else: for i in range(index, len(num1)): midsum.append(ord(num1[i]) - 48) res = '' plus = 0 for x in midsum: num = plus + x res = str(num % 10) + res plus = num // 10 if plus: res = str(plus) + res return res 434. 字符串中的单词数题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:12输入: "Hello, my name is John"输出: 5 解题思路12345678910class Solution(object): def countSegments(self, s): """ :type s: str :rtype: int """ s = s.split() return len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数组]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是数组相关题目题解总结。 [TOC] 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415161718class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt;= 1: return False Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i return False 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 31. 下一个排列题目描述解题思路先找到从后面开始数第一个降序的位置，在将这个位置之后的数字翻转，然后遍历翻转的部分数字，最后交换这个降序数字和后面第一个比他大的数。12345678910111213141516171819202122class Solution(object): def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums) &lt; 2: return index = len(nums) - 2 while index &gt;= 0: if nums[index] &lt; nums[index+1]: #从后找到第一个降序数字 break index -= 1 nums[index+1:] = nums[index+1:][::-1] #将降序数字后面的数字翻转 for i in range(index+1, len(nums)): if nums[i] &gt; nums[index]: #在翻转的数字中找到第一个大于降序数字的 nums[i], nums[index] = nums[index], nums[i] #交换 break 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 48. 旋转图像题目描述给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路1234567891011121314class Solution(object): def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ # 先沿着左上右下的对角线翻转 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] #在翻转每一行 for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 54. 螺旋矩阵题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2:1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路从左到右，从上到下，从右到左，从下到上，循环。123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if len(matrix) == 0: return [] top, buttom = 0, len(matrix)-1 left, right = 0, len(matrix[0])-1 res = [] while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1, buttom+1): res.append(matrix[i][right]) if top &lt; buttom: # 当top==buttom时，最后为一行，前面已经从左到右遍历过，不需重复遍历 for i in range(right-1, left-1, -1): res.append(matrix[buttom][i]) if left &lt; right: # 当left == right时， 最后为一列，前面已经从上到下遍历过了，不需重复遍历 for i in range(buttom-1, top, -1): res.append(matrix[i][left]) top, buttom = top+1, buttom-1 left, right = left+1, right-1 return res 59. 螺旋矩阵 II题目描述给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ if n == 0: return [] if n == 1: return [[1]] matrix = [[0]*n for i in range(n)] top, buttom = 0, n-1 left, right = 0, n-1 val = 1 while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): matrix[top][i] = val val += 1 for i in range(top+1, buttom+1): matrix[i][right] = val val += 1 if top &lt; buttom: for i in range(right-1, left-1, -1): matrix[buttom][i] = val val += 1 if left &lt; right: for i in range(buttom-1, top, -1): matrix[i][left] = val val += 1 top, buttom = top+1, buttom-1 left, right = left+1, right-1 return matrix 73. 矩阵置零题目描述给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1:123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2:123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路O(m+n)12345678910111213141516171819202122class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = [False] * len(matrix) col = [False] * len(matrix[0]) # 找出0的位置 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: row[i] = True col[j] = True # 将0所在的行和列置0 for i in range(len(matrix)): for j in range(len(matrix[0])): if row[i] or col[j]: matrix[i][j] = 0 将0所在的行或列的其他位置置为’#’，然后替换成0123456789101112131415161718192021222324class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ if len(matrix) == 0: return for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): if matrix[i][k] != 0: matrix[i][k] = '#' for k in range(len(matrix)): if matrix[k][j] != 0: matrix[k][j] = '#' for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == '#': matrix[i][j] = 0 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 118. 杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路12345678910111213141516171819202122class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(2, numRows+1): pre = res[-1] temp = [] i = 0 while i &lt; len(pre)-1: temp.append(pre[i]+pre[i+1]) i += 1 res.append([1]+temp+[1]) return res 119. 杨辉三角 II题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路123456789101112131415161718class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ if rowIndex == 0: return [1] res = [1] for i in range(2, rowIndex+2): temp = [] for i in range(len(res)-1): temp.append(res[i]+res[i+1]) res = [1]+temp+[1] return res 189. 旋转数组题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1:123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解题思路切片，拼接1234567891011121314class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return nums k = k%len(nums) nums[:] = nums[-k:]+nums[:-k] 先把所有的翻转，然后在对0~k和k~n分别进行翻转。12345678910111213141516171819202122class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return k = k%len(nums) self.reverse(nums, 0, len(nums)-1) self.reverse(nums, 0, k-1) self.reverse(nums, k, len(nums)-1) def reverse(self, nums, left, right): while left &lt; right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路双指针 123456789101112131415161718192021222324class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = float('inf') left, right = 0, 0 while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res!=float('inf') else 0 216. 组合总和 III题目描述找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2:12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0 or n &gt; 45: return [] nums = [x for x in range(1, 10)] res = [] self.dfs(nums, [], 0, k, n, res) return res def dfs(self, nums, path, index, k, target, res): if k == 0 and target == 0 and path: res.append(path) return for i in range(index, len(nums)): if nums[i] &gt; target: return self.dfs(nums, path+[nums[i]], i+1, k-1, target-nums[i], res) 217. 存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题思路12345678910111213class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 1: return False set1 = set(nums) return len(set1) != len(nums) 219. 存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1:12输入: nums = [1,2,3,1], k = 3输出: true 示例 2:12输入: nums = [1,0,1,1], k = 1输出: true 示例 3:12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路123456789101112131415161718192021class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ if len(nums) &lt;= 0 or k &lt;= 0: return False Dict = &#123;&#125; for i in range(len(nums)): if nums[i] not in Dict: Dict[nums[i]] = i else: if i - Dict[nums[i]] &lt;= k: return True Dict[nums[i]] = i return False 228. 汇总区间题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:123输入: [0,1,2,4,5,7]输出: ["0-&gt;2","4-&gt;5","7"]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:123输入: [0,2,3,4,6,8,9]输出: ["0","2-&gt;4","6","8-&gt;9"]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 解题思路1234567891011121314151617181920212223class Solution(object): def summaryRanges(self, nums): """ :type nums: List[int] :rtype: List[str] """ if len(nums) == 0: return [] res = [] i = 0 while i &lt; len(nums): j = i while j &lt; len(nums)-1 and nums[j+1] == nums[j]+1: j += 1 if i == j: res.append(str(nums[i])) else: res.append(str(nums[i])+'-&gt;'+str(nums[j])) i = j+1 return res 229. 求众数 II题目描述给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1:12输入: [3,2,3]输出: [3] 示例 2:12输入: [1,1,1,3,3,2,2,2]输出: [1,2] 解题思路1234567891011121314151617181920212223class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in set(nums): if Dict[x] &gt; len(nums)//3: res.append(x) return res 238. 除自身以外数组的乘积题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 解题思路123456789101112131415161718192021class Solution(object): def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] res = [1]*len(nums) for i in range(1, len(nums)): res[i] = res[i-1]*nums[i-1] temp = 1 for i in range(len(nums)-2, -1, -1): temp *= nums[i+1] res[i] *= temp return res 268. 缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:12输入: [3,0,1]输出: 2 示例 2:12输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路123456789101112131415class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = len(nums) for i in range(len(nums)): res ^= nums[i]^i return res 283. 移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路12345678910111213141516class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. """ if len(nums) &lt;= 1: return index = 0 for i in range(len(nums)): if nums[i] != 0: nums[index] = nums[i] index += 1 nums[index:] = [0] * (len(nums)-index) 287. 寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:12输入: [1,3,4,2,2]输出: 2 示例 2:12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路123456789101112131415161718192021class Solution(object): def findDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[fast] slow = nums[slow] return fast 289. 生命游戏题目描述根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例:1234567891011121314输入: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]输出: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] 进阶: 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def gameOfLife(self, board): """ :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. """ if len(board) == 0: return Live = [] Dead = [] for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: if self.judgeLive(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) else: if self.judgeDead(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) for pair in Live: board[pair[0]][pair[1]] = 1 for pair in Dead: board[pair[0]][pair[1]] = 0 def judgeLive(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if 2&lt;=count&lt;=3 else False def judgeDead(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if count==3 else False 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 381. O(1) 时间插入、删除和获取随机元素 - 允许重复题目描述设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。 remove(val)：当 val 存在时，从集合中移除一个 val。 getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例:1234567891011121314151617181920// 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection();// 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2);// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom();// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1);// getRandom 应有相同概率返回 1 和 2 。collection.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class RandomizedCollection(object): def __init__(self): """ Initialize your data structure here. """ self.data = [] def insert(self, val): """ Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.data: self.data.append(val) return True else: self.data.append(val) return False def remove(self, val): """ Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool """ if val not in self.data: return False else: self.data.remove(val) return True def getRandom(self): """ Get a random element from the collection. :rtype: int """ return random.choice(self.data)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 414. 第三大的数题目描述给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2:12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路123456789101112131415161718192021222324class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) s1, s2, s3 = float('-inf'), float('-inf'), float('-inf') for num in nums: if num &gt; s1: s1, s2, s3 = num, s1, s2 elif num &lt; s1 and num &gt; s2: s2, s3 = num, s2 elif num &lt; s2 and num &gt; s3: s3 = num return s3 if s3 != float('-inf') else max(s1, s2) 442. 数组中重复的数据题目描述给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例：12345输入:[4,3,2,7,8,2,3,1]输出:[2,3] 解题思路12345678910111213141516171819class Solution(object): def findDuplicates(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) &lt;= 1: return [] res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res 448. 找到所有数组中消失的数字题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路123456789101112131415161718192021class Solution(object): def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1] *= -1 res = [] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i+1) return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 链表]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是链表相关题目题解总结。 [TOC] 链表2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路设置哨兵节点，每次新建节点保存当前位的值，并将进位给下一次迭代用。 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = ListNode(0) cur = dummy plus = 0 while l1 or l2 or plus: if l1: plus += l1.val l1 = l1.next if l2: plus += l2.val l2 = l2.next cur.next = ListNode(plus%10) plus //= 10 cur = cur.next return dummy.next 19. 删除链表的倒数第N个节点题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 解题思路新建伪结点，先让原指针走n步，寻找到删除的位置，然后一起遍历，原指针走到尾了，伪指针走到要删除节点的前一个，将伪指针的下一个节点跳过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head or n &lt; 0: return None dummy = ListNode(0) dummy.next = head pre = dummy for i in range(n): head = head.next while head: head = head.next pre = pre.next pre.next = pre.next.next return dummy.next 21. 合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1: return l2 if not l2: return l1 dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val &lt; l2.val: pre.next = ListNode(l1.val) l1 = l1.next else: pre.next = ListNode(l2.val) l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路设置头节点，向后遍历。 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while pre.next and pre.next.next: cur = pre.next pre.next = pre.next.next cur.next = cur.next.next pre.next.next = cur pre = pre.next.next return dummy.next 61. 旋转链表题目描述给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题思路先求链表长度，当k&gt;length时，k对length求余，然后将链表后k个移到开头；使用快慢指针的方法找到后面k个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head length = 0 cur = head while cur: cur = cur.next length += 1 k = k % length if k == 0: return head fast, slow = head, head for i in range(k): fast = fast.next while fast.next: fast = fast.next slow = slow.next temp = slow.next slow.next = None fast.next = head # temp 就是结果，直接返回也可 head = temp return head 82. 删除排序链表中的重复元素 II题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2:12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解题思路要删除重复的节点，而头节点就有可能是重复的节点，因此新建头节点，同样的值略过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while head and head.next: if head.val != head.next.val: head = head.next pre = pre.next else: val = head.val while head and head.val == val: head = head.next pre.next = head return dummy.next 83. 删除排序链表中的重复元素题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2:12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路每次迭代判断当前节点和下一节点是否相等，若相等，该节点的下个节点等于下个节点的下个节点，相当于下个节点和当前节点相等，就跳过下个节点。 当当前节点和下一节点不相等时，当前节点往前走，判断下一节点。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head cur = head while cur.next: if cur.val == cur.next.val: cur.next = cur.next.next else: cur = cur.next return head 86. 分隔链表题目描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例:12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路用两个指针，分别保存比x小的及比x大的值，对原链表进行遍历根据值的大小拼接在相应的链表后面，最后在把两个链表拼接在一起就可以了。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) pre = dummy larger = ListNode(0) temp = larger while head: if head.val &lt; x: pre.next = head pre = pre.next else: node = ListNode(head.val) temp.next = node temp = temp.next head = head.next pre.next = larger.next return dummy.next 92. 反转链表 II题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy count = 1 while pre.next and count &lt; m: pre = pre.next count += 1 if count &lt; m: return head mNode = pre.next cur = mNode.next while cur and count &lt; n: Next = cur.next cur.next = pre.next pre.next = cur mNode.next = Next cur = Next count += 1 return dummy.next 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy for i in range(m-1): pre = pre.next cur = pre.next for i in range(n-m): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 109. 有序链表转换二叉搜索树题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路将链表转换为数组，然后构建二叉搜索树。 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ if not head: return None array = [] while head: array.append(head.val) head = head.next return self.helper(array) def helper(self, array): if len(array) == 0: return None mid = len(array)//2 root = TreeNode(array[mid]) root.left = self.helper(array[:mid]) root.right = self.helper(array[mid+1:]) return root 138. 复制带随机指针的链表题目描述给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深度拷贝。 解题思路首先复制label和next指针，然后复制random指针，最后拆分新旧链表。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def copyRandomList(self, head): """ :type head: RandomListNode :rtype: RandomListNode """ if not head: return head pre = head while pre: temp = pre.next pre.next = RandomListNode(pre.label) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next cur = res pre = head while pre: pre.next = pre.next.next if cur.next: cur.next = cur.next.next pre = pre.next cur = cur.next return res 二刷1234567891011121314151617181920212223242526272829303132333435363738394041"""# Definition for a Node.class Node(object): def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""class Solution(object): def copyRandomList(self, head): """ :type head: Node :rtype: Node """ if not head: return head pre = head while pre: temp = pre.next pre.next = Node(pre.val, None, None) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next pre = res while head: head.next = head.next.next if pre.next: pre.next = pre.next.next head = head.next pre = pre.next return res 141. 环形链表题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用快慢指针，如果有环一定相遇。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 142. 环形链表 II题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路快慢指针，找到换之后，一个指针从头遍历。 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: fast = head while fast != slow: fast = fast.next slow = slow.next return fast return None 集合。将访问过的节点保存起来，遍历节点，如果节点在字典中，则说明重复是为环的入口；否则没有环。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None Dict = set() while head: if head in Dict: return head Dict.add(head) head = head.next return None 143. 重排链表题目描述给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2:1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路 使用快慢指针先将链表从中间截断为两个链表，如果链表长度为奇数，则第一条链表长度多1；如1,2,3,4,5，拆分为1,2,3和4,5； 将第二条链表翻转；即4,5翻转为5,4 然后归并合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head or not head.next or not head.next.next: return fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next frontend = head backend = slow.next slow.next = None dummy = ListNode(0) dummy.next = backend cur = backend.next backend.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp backend = dummy.next p1 = frontend p2 = backend while p2: temp1 = p1.next temp2 = p2.next p1.next = p2 p2.next = temp1 p1 = temp1 p2 = temp2 147. 对链表进行插入排序题目描述对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2：12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路如果链表本来就是升序的，则往后遍历；否则如果一个节点的值小于前一个节点，寻找合适的位置插入。12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head while cur.next: if cur.val &lt; cur.next.val: cur = cur.next else: pre = dummy while pre.next and pre.next.val &lt; cur.next.val: pre = pre.next temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None left = self.sortList(leftHead) right = self.sortList(rightHead) return self.merge(left, right) def getmiddle(self, head): if not head or not head.next: return head fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self, left, right): dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 160. 相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1：123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路链表拼接 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None a, b = headA, headB while a or b: if not a: a = headB if not b: b = headA if a == b: return a a, b = a.next, b.next return None 第一次遍历，先计算两个链表的长度；第二次遍历，让长的先走长度差，然后同时移动，判断是否有相同节点。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None countA = countB = 0 a, b = headA, headB while a: a = a.next countA += 1 while b: b = b.next countB += 1 if countA &gt; countB: for i in range(countA-countB): headA = headA.next else: for i in range(countB-countA): headB = headB.next while headA and headB: if headA == headB: return headA headA, headB = headA.next, headB.next return None 206. 反转链表题目描述反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路迭代123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head return self.helper(head, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 234. 回文链表题目描述请判断一个链表是否为回文链表。 示例 1:12输入: 1-&gt;2输出: false 示例 2:12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None dummy = ListNode(0) dummy.next = right cur = right.next right.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp right = dummy.next while right: if right.val != left.val: return False right = right.next left = left.next return True 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True res = [] while head: res.append(head.val) head = head.next return res == res[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 分治算法]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是分治算法相关题目题解总结。 [TOC] 分治算法基本概念分治法字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或者更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。如快速排序，归并排序。 基本思想及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治法的策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 分治法使用场景分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题； 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑使用贪心法或者动态规划法； 第四条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可以使用分治法，但一般动态规划较好。 分治法的基本步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 分治法的应用二分搜索大整数乘法Strassen矩阵乘法棋盘覆盖合并排序快速排序线性时间选择最接近点对问题循环赛日程表汉诺塔 二分搜索 二分搜索的要求：线性表为有序表，并且要用向量作为表的存储结构； 二分搜索得基本思想：先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录位置。1234567891011121314151617class Solution(object): def searchRange(self, nums, key): """ :type nums: List[int] :type target: int :rtype: List[int] """ return self.bSearch(nums, 0, len(nums)-1,key) def bSearch(self, nums, left, right, key): mid = (left+right) // 2 if nums[mid] == key: return mid elif nums[mid] &gt; key: return self.bSearch(nums,left,mid-1,key) else: return self.bSearch(nums, mid+1,right,key) 汉诺塔从左到右 A B C 柱 大盘子在下, 小盘子在上, 借助B柱将所有盘子从A柱移动到C柱, 期间只有一个原则: 大盘子只能在小盘子的下面。求解思路： 当盘子只有一个的时候,只有一个动作 从 A 移动到 C 即结束； 当有N个盘子的时候, 中间的动作是从 A 移动到 C, 表示最下面的第N个盘子移动完毕； 中间动作之上都可以认为是: 从 A 移动到 B； 中间动作之下都可以认为是: 从 B 移动到 C。 12345678910class Solution(object): def move(self, n, a, b, c): if n == 1: print(a+'-&gt;'+c) else: self.move(n-1, a, c, b) print(a+'-&gt;'+ c) self.move(n-1, b, a, c)if __name__ == '__main__': Solution().move(3,'a','b','c') 参考https://www.cnblogs.com/xsyfl/p/6921687.htmlhttps://blog.csdn.net/not_guy/article/details/72823951 241. 为运算表达式设计优先级题目描述给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: “2-1-1”输出: [0, 2]解释:((2-1)-1) = 0(2-(1-1)) = 2 示例 2: 输入: “23-45”输出: [-34, -14, -10, -10, 10]解释:(2(3-(45))) = -34((23)-(45)) = -14((2(3-4))5) = -10(2((3-4)5)) = -10(((23)-4)5) = 10 解题思路如果字符串为数字直接返回；使用分治法，遍历字符串，当遇到运算符时，将字符串分为运算符前及运算符后两部分，根据运算符做相应运算。1234567891011121314151617181920212223242526272829class Solution(object): def diffWaysToCompute(self, input): """ :type input: str :rtype: List[int] """ if input.isdigit(): return [int(input)] res = [] for i in range(len(input)): if input[i] in '+-*': left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) for j in left: for k in right: res.append(self.helper(j, k, input[i])) return res def helper(self, j, k, op): if op == '+': return j + k elif op == '-': return j - k elif op == '*': return j * kif __name__ == '__main__': result = Solution().diffWaysToCompute("2*3-4*5") print(result) 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 解题思路摩尔投票法 维护一个候选数candidate和计数器counter。遍历数组中所有的元素， 设当前的元素为x，若 counter = 0,则 candidate = x, counter = 1; 否则， 根据candidate 与x是否相等来更新counter（相等+1，不等-1）在遍历一次，判断候选数是否为合法的主元素。为什么这样做是对的呢？因为若在有解的情况下，一个元素y出现&gt;n/2次，那么要抵消掉它，必然也要有相同的元素才行，而总的元素才n个，也就是说元素y在这样的计数中不会被抵消。保证有解的情况最后的候选数就是主要元素。1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ candidate = 0 count = 0 for x in nums: if count == 0: count = 1 candidate = x elif x == candidate: count += 1 else: count -= 1 return candidateif __name__ == '__main__': result = Solution().majorityElement([6,5,5]) print(result) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路 堆排序。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k, len(nums)+1): if change: for j in range(k//2, -1, -1): self.adjust(res, j, k) for j in range(k-1, 0, -1): res[j], res[0] = res[0], res[j] self.adjust(res, 0, j) change = False if i != len(nums) and nums[i] &gt; res[-1]: res[-1] = nums[i] change = True return res[-1] def adjust(self, res, parent, length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1] &lt; res[child]: child += 1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = temp 分治算法，这里使用快速排序算法。 通过一趟排序将要排序的数据分割成两个独立的两部分：左部分都是比它小的数，右部分都是比它大的数； 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，最终使整个数据变成有序序列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums[-k] def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 树]]></title>
    <url>%2F2019%2F05%2F14%2FLeetcode-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 题目主要以Easy和Medium为主,刷题按Tag分类。本系列题解汇总如下 (持续更新…)： Leetcode题解 - 数组 Leetcode题解 - 动态规划 Leetcode题解 - 数学 Leetcode题解 - 字符串 Leetcode题解 - 树 Leetcode题解 - 哈希表 Leetcode题解 - 搜索 Leetcode题解 - 二分查找 Leetcode题解 - 双指针 Leetcode题解 - 贪心算法 Leetcode题解 - 栈和队列 Leetcode题解 - 回溯算法 Leetcode题解 - 链表 Leetcode题解 - 位运算 Leetcode题解 - 排序 Leetcode题解 - 分治算法 本文主要是树相关题目题解总结。 [TOC] 94. 二叉树的中序遍历题目描述给定一个二叉树，返回它的中序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) return res 迭代123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] while True: while root: stack.append(root) root = root.left if not stack: return res root = stack.pop() res.append(root.val) root = root.right 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] self.allLeftIntoStack(root, stack) while stack: root = stack.pop() res.append(root.val) if root.right: self.allLeftIntoStack(root.right, stack) return res def allLeftIntoStack(self, root, stack): while root: stack.append(root) root = root.left 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:123456789101112131415161718输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路依次以1~n作为根节点，其左边的为左子树，右边的为右子树。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划 给定一个序列1,…,n，为了构造所有的二叉树，我们遍历以i为节点，则1,…,i-1为构成左子树，i+1,…,n构成右子树；然后通过递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。 设dp[n]为1,…,n组成二叉搜索树的个数，初始化dp[0]=1,dp[1]=1,dp[2]=2； dp[n] = F(1,n)+F(2,n)+…+F(n,n)F(i,n) = dp(i-1)dp(n-i-1), 如F(1,3) = dp[0]dp[2]F(i,n)为以i为根节点的二叉树个数。等于左右子树的排列的乘积。 dp[3] = dp[0]dp[2] + dp[1]dp[1] + dp[2]*dp[0] 因为dp[n] = dp[0]*dp[n-1] + dp[1][n-2] + … + dp[n-1]dp[0] 12345678910111213141516class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt; 3: return dp[n] dp += [0]*(n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[-1] 98. 验证二叉搜索树题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:12345输入: 2 / \ 1 3输出: true 示例 2:123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路根据二叉搜索树的定义，左子树的值在(left, root.val)之间，右子树的值在(root.val, right)，每次递归是判断当前节点值是否满足取值上界和下界，计算下一节点是要根据左右节点进行更新上下界。 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.dfs(root, float('-inf'), float('inf')) def dfs(self, root, left, right): if not root: return True if root.val &lt;= left or root.val &gt;= right: return False return self.dfs(root.left, left, root.val) and self.dfs(root.right, root.val, right) 先中序遍历（递归），判断数组是否升序。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] self.inorder(root, queue) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def inorder(self, root, queue): if not root: return self.inorder(root.left, queue) queue.append(root.val) self.inorder(root.right, queue) return queue 先中序遍历（迭代），判断数组是否升序。1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] stack = [] self.LeftintoStack(root, stack) while stack: root = stack.pop() queue.append(root.val) if root.right: self.LeftintoStack(root.right, stack) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def LeftintoStack(self, root, stack): if not root: return while root: stack.append(root) root = root.left 100. 相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1:1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2:1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3:1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题思路123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 101. 对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.judge(root.left, root.right) def judge(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.judge(left.left, right.right) and self.judge(left.right, right.left) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = collections.deque() queue.append([root.left, root.right]) while queue: pair = queue.popleft() left, right = pair[0], pair[1] if not left and not right: continue if not left or not right: return False if left.val != right.val: return False queue.append([left.left, right.right]) queue.append([left.right, right.left]) return True 102. 二叉树的层次遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其层次遍历结果：12345[ [3], [9,20], [15,7]] 解题思路迭代1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res 递归123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 103. 二叉树的锯齿形层次遍历题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]] 解题思路迭代123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res 递归123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 104. 二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解题思路递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res += 1 return res 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for node in queue: if node.left: temp.append(node.left) if node.right: temp.append(node.right) res += 1 queue = temp return res 105. 从前序与中序遍历序列构造二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if not preorder or not inorder: return None rootval = preorder[0] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root 106. 从中序与后序遍历序列构造二叉树题目描述根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ if not inorder or not postorder: return None rootval = postorder[-1] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root 107. 二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为：12345[ [15,7], [9,20], [3]] 解题思路递归1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res[::-1] def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res[::-1] 108. 将有序数组转换为二叉搜索树题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ if len(nums) == 0: return None mid = len(nums)//2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 110. 平衡二叉树题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7]12345 3 / \9 20 / \ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True leftdepth = self.getdepth(root.left) rightdepth = self.getdepth(root.right) if abs(leftdepth-rightdepth) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) def getdepth(self, root): if not root: return 0 return max(self.getdepth(root.left), self.getdepth(root.right)) + 1 111. 二叉树的最小深度题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回它的最小深度 2. 解题思路迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: res += 1 for i in range(len(queue)): node = queue.pop(0) if not node.left and not node.right: return res if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 递归1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if not root.left and root.right: return self.minDepth(root.right) + 1 if not root.right and root.left: return self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 112. 路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路递归12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False if not root.left and not root.right: return root.val == sum return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 回溯123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False return self.dfs(root, sum-root.val) def dfs(self, root, target): if not root: return False if target == 0 and not root.left and not root.right: return True left, right = False, False if root.left: left = self.dfs(root.left, target-root.left.val) if root.right: right = self.dfs(root.right, target-root.right.val) return left or right 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False queue = [(root, sum-root.val)] while queue: node, target = queue.pop(0) if not node: continue if not node.left and not node.right and target == 0: return True if node.left: queue.append((node.left, target-node.left.val)) if node.right: queue.append((node.right, target-node.right.val)) return False 113. 路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 解题思路回溯1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [root.val], res, sum) return res def dfs(self, root, path, res, target): if not root: return if sum(path) == target and not root.left and not root.right: res.append(path) if root.left: self.dfs(root.left, path+[root.left.val], res, target) if root.right: self.dfs(root.right, path+[root.right.val], res, target) 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [], res, sum) return res def dfs(self, root, path, res, target): if not root: return if not root.left and not root.right and target == root.val: path.append(root.val) res.append(path) if root.left: self.dfs(root.left, path+[root.val], res, target-root.val) if root.right: self.dfs(root.right, path+[root.val], res, target-root.val) 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] #if not root.left and not root.right and root.val == sum: # return [[root.val]] #temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) #return [[root.val]+i for i in temp] res = [] if not root.left and not root.right and root.val == sum: return [[root.val]] temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) for i in temp: res.append([root.val]+i) return res 迭代12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: node, target, temp = queue.pop(0) if not node.left and not node.right and target == sum: res.append(temp) if node.left: queue.append((node.left, target+node.left.val, temp+[node.left.val])) if node.right: queue.append((node.right, target+node.right.val, temp+[node.right.val])) return res 114. 二叉树展开为链表题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树12345 1 / \ 2 5 / \ \3 4 6 将其展开为：12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路先前序遍历，在讲所有节点的左子树置空，并将右子树置为下一节点。空间复杂度为O(n)。12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return root #迭代 res = [] stack = [root] while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) if node.left: stack.append(node.left) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] # 递归 res = [] self.preorder(root, res) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] def preorder(self, root, res): if not root: return res.append(root) self.preorder(root.left, res) self.preorder(root.right, res) 116. 填充同一层的兄弟节点题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。示例: 给定完美二叉树，12345 1 / \ 2 3 / \ / \4 5 6 7 调用你的函数后，该完美二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路递归，从根节点开始找到任意节点，将其左孩子指向其右孩子，如果该节点的next节点已经指向其他节点，说明需要连接两个子树；比如2-&gt;3，需要把2的左子树4指向5，同时需要将左右子树连接起来，即5-&gt;6。 1234567891011121314151617181920# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.right: root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) 迭代。层次遍历，将队列中的元素弹出时，如果他不是最后一个元素，则将其的next节点指向队列中的下一个节点。1234567891011121314151617181920212223242526# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = [root] while queue: length = len(queue) for i in range(length): node = queue.pop(0) if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 117. 填充同一层的兄弟节点 II题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例: 给定二叉树，12345 1 / \ 2 3 / \ \4 5 7 调用你的函数后，该二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路递归。主要先右再左，因为在递归左子树的时候，需要不断寻找同层的next节点，需要保证右子树先建立好next节点。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.left and root.right: root.left.next = root.right temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next elif root.left: temp = root.next while temp: if temp.left: root.left.next = temp.left; break if temp.right: root.left.next = temp.right; break temp = temp.next elif root.right: temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next self.connect(root.right) self.connect(root.left) 迭代。和上题思路代码一样123456789101112131415161718192021222324252627# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = collections.deque() queue.append(root) while queue: length = len(queue) for i in range(length): node = queue.popleft() if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 129. 求根到叶子节点数字之和题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2:123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 self.res = 0 self.dfs(root, root.val) return self.res def dfs(self, root, path): if not root.left and not root.right: self.res += path if root.left: self.dfs(root.left, path*10+root.left.val) if root.right: self.dfs(root.right, path*10+root.right.val) 迭代。栈123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 stack = [(root, root.val)] while stack: node, val = stack.pop() if not node.left and not node.right: res += val if node.left: stack.append((root.left, val*10+root.left.val)) if node.right: stack.append((root.right, val*10+root.right.val)) return res 迭代。队列 144. 二叉树的前序遍历题目描述给定一个二叉树，返回它的 前序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return res.append(root.val) self.dfs(root.left, res) self.dfs(root.right,res) 迭代。栈12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 迭代。队列1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] queue = collections.deque() queue.append(root) while queue: node = queue.pop() res.append(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return res 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.level(root, 0, res) return [res[i][-1] for i in range(len(res))] def level(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res 222. 完全二叉树的节点个数题目描述给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 解题思路分治递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 226. 翻转二叉树题目描述翻转一棵二叉树。 示例：1234567891011121314输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if not root: return root temp = root.left root.left = root.right root.right = temp self.invertTree(root.left) self.invertTree(root.right) return root 230. 二叉搜索树中第K小的元素题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 解题思路中序遍历。12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ if not root or k &lt;= 0: return 0 res = [] self.inorder(root, res) return res[k-1] def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) python3的yield。1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if not root or k &lt;= 0: return 0 iteration = self.inorder(root) res = 0 for i in range(k): res = next(iteration) return res def inorder(self, root): if root: yield from self.inorder(root.left) yield root.val yield from self.inorder(root.right) 235. 二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路首先保证p的值一定比q的小利用二叉搜索树的特性，左子树一定比根节点小，右子树一定比根节点大； p和q在root两侧，那么root就是公共祖先 pq均小于root，那么从左子树寻找 pq均大于root，那么从右子树寻找 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if p.val &gt; q.val: p, q = q, p node = root while True: if node.val == p.val or node.val == q.val: return node elif p.val &lt; node.val &lt; q.val: return node elif q.val &lt; node.val: node = node.left else: node = node.right 236. 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路递归。对以root为根的树进行查找p和q 如果root为空或root==p或root==q，直接返回root，表明当前树已经查询完成；否则对左右子树进行查找，根据左右子树的返回值进行判断： 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA 左右子树返回值均为null, p和q均不在树中, 返回null 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left and not right: return None elif left and right: return root else: return left if left else right 257. 二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 / \2 3 \ 5输出: ["1-&gt;2-&gt;5", "1-&gt;3"]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 解题思路递归1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] self.dfs(root, str(root.val), res) return res def dfs(self, root, path, res): if not root: return if not root.left and not root.right: res.append(path) return if root.left: self.dfs(root.left, path + '-&gt;' + str(root.left.val), res) if root.right: self.dfs(root.right, path + '-&gt;' + str(root.right.val), res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] stack = [(root, str(root.val))] while stack: node, path = stack.pop(0) if not node.left and not node.right: res.append(path) if node.left: stack.append((node.left, path + '-&gt;' + str(node.left.val))) if node.right: stack.append((node.right, path + '-&gt;' + str(node.right.val))) return res 297. 二叉树的序列化与反序列化题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例:123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 "[1,2,3,null,null,4,5]" 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路采用前序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return '#' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ tree = data.split(',') return self.Tree(tree) def Tree(self, tree): if not tree: return None root = None val = tree.pop(0) if val != '#': root = TreeNode(int(val)) root.left = self.Tree(tree) root.right = self.Tree(tree) return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 337. 打家劫舍 III题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1:12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2:12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路对于一个以root为根节点的二叉树而言： 如果偷root节点，那么不能偷其左右子节点 如果不偷该节点，那么可以偷其左右子节点 比较两种方式的大小，取大值 递归完成，每次返回的是(偷，不偷)当前节点的值，如果偷根节点了，那么不能偷其子节点，即加上的是left[1]，和right[1]，1表示的是返回不偷该节点的值。 如果不偷根节点，那么可以偷左右子节点 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rob(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.tryrob(root)) def tryrob(self, root): if not root: return (0, 0) left = self.tryrob(root.left) right = self.tryrob(root.right) # rob now now = root.val + left[1] + right[1] # rob later later = max(left) + max(right) return (now, later) 404. 左叶子之和题目描述计算给定二叉树的所有左叶子之和。 示例：1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回24 解题思路递归，当遇到左叶子节点时加到和里，然后取递归右子树 否则，还没遇到左叶子节点，遍历左子树和右子树123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumOfLeftLeaves(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if root.left and not root.left.left and not root.left.right: return root.left.val + self.sumOfLeftLeaves(root.right) else: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Project - 建筑物能源之星分数预测]]></title>
    <url>%2F2019%2F05%2F14%2FProjectExperience-BuildingEnergyStarScorePrediction%2F</url>
    <content type="text"><![CDATA[Note: 由于Jupyter Notebook运行的一些中间结果在markdown上显示效果不好，因此注释了一些类似于.head() .describe()等内容不在本文中显示，但总体不影响阅读，完整.ipynb文件可以在GitHub查看。 项目来源这是在Github 上找到的一个美国数据科学家在申请工作时的”作业”，英文作业链接。 项目目标 使用提供的建筑能源数据开发一个模型，该模型可以预测建筑物的能源之星分数（building’s Energy Star score）； 解释结果以找到最能预测分数的变量。 这是一个有监督的回归机器学习任务：给定一组包含目标（在本项目中为ENERGY STAR Score能源之星分数）的数据，我们希望训练一个可以学习将特征（也称为解释变量）映射到目标的模型。 监督学习：数据集中同时存在特征和目标变量； 回归任务：目标变量时连续值，在本项目中为0~100。 在训练过程中，我们希望模型学习特征和分数之间的关系；然后，为了测试模型的学习效果，我们在一个没有分数的测试集上进行评估！ 机器学习工作流程虽然每一个机器学习任务的实现细节可能会有所不同，但一般有以下几个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 尽可能地解释模型结果 得出结论并撰写详尽记录的报告 提前设置步骤让我们可以看到一步流入另一步。但是，机器学习过程是一个迭代过程，因此我们并不总是以线性方式遵循这些步骤。我们可能会根据下一步的结果重新审视上一步。例如： 虽然我们可以在构建任何模型之前执行特征选择，但我们可以使用建模结果返回并选择一组不同的特征； 或者，建模可能会出现意想不到的结果，这意味着我们希望从另一个角度探索我们的数据； 一般来说，你必须先完成一步才能继续下一步，但不要觉得一旦你第一次完成一步，你就不能回头做出改进，你可以在任何时候返回前面的步骤做响应的修改。 0 导入库文件使用标准的数据科学和机器学习库:numpy、panda和scikit-learn，同时使用matplotlib和seaborn进行可视化。 123456789101112131415161718192021222324# 用于数值计算的 Pandas和numpyimport pandas as pdimport numpy as np# 不显示在切片副本上的警告pd.options.mode.chained_assignment = None# Matplotlib可视化import matplotlib.pyplot as plt%matplotlib inline# 设置默认字体plt.rcParams['font.size'] = 24# 用于设置图形大小的内部ipython工具from IPython.core.pylabtools import figsize# Seaborn可视化import seaborn as sns# 缩放因子sns.set(font_scale = 2)# 将数据划分为训练集和测试集from sklearn.model_selection import train_test_split 1 数据清理和格式化1.1 导入并检查数据将数据加载到pandas数据帧中，这是数据科学最有用的数据结构之一。 将其视为Python中的电子表格，我们可以轻松地操作，清理和可视化。Pandas官方文档。 123456# 读取数据data = pd.read_csv('dataset/Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv')# 显示数据大小print('datashape:',data.shape)# 显示表头data.head() datashape: (11746, 60) 原始数据中有看一下原始数据11746行，60列，我们的目标是预测ENERGY STAR Score列中的数字，其他列作为特征。 根据数据集的文件名为 Energy_and_Water_Data_Disclosure_for_Local_Law_84_2017__Data_for_Calendar_Year_2016_.csv 这里面有一个Local_Law_84，根据Local_Law_84进行搜索，得到两个比较关键的资料： Local_Law_84网站 基准化公开数据定义 第一个网站告诉我们，当地Local_Law_84是纽约市的一项要求，规定所有超过50,000𝑓𝑡2的建筑物必须每年报告一组与能源相关的数字。pdf文档说明每列代表的含义，虽然我们不需要研究每一列，但至少要理解我们想要预测的目标是个好主意。以下是ENERGY STAR Score能源之星分数的定义： 基于报告年度自我报告的能源使用情况，在投资组合管理器中计算的指定建筑类型的的分数：范围在1到100。 这看起来非常简单：能源之星分数是一种根据能源效率对建筑物进行排名的方法，其中最差的是1，最好是100。它是相对百分位排名，这意味着建筑物相对于彼此进行评分，并且应该在整个值范围内显示均匀分布。 1.2 数据类型和缺失值处理dataframe.info方法是一种通过显示每列的数据类型和非缺失值的数量来评估数据的快速方法。 从查看数据帧开始，可能会出现问题，因为缺失值被编码为“Not Available”而不是np.nan（不是数字）（因为csv文件某些列同时包含数字和字符两种类型）。 这意味着具有数字的列将不会表示为数字，因为pandas会将具有字符串值的列转换为字符串的列。 12# 查看数据列的数据类型和非缺失值数量data.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 11746 entries, 0 to 11745 Data columns (total 60 columns): Order 11746 non-null int64 Property Id 11746 non-null int64 Property Name 11746 non-null object Parent Property Id 11746 non-null object Parent Property Name 11746 non-null object BBL - 10 digits 11735 non-null object NYC Borough, Block and Lot (BBL) self-reported 11746 non-null object NYC Building Identification Number (BIN) 11746 non-null object Address 1 (self-reported) 11746 non-null object Address 2 11746 non-null object Postal Code 11746 non-null object Street Number 11622 non-null object Street Name 11624 non-null object Borough 11628 non-null object DOF Gross Floor Area 11628 non-null float64 Primary Property Type - Self Selected 11746 non-null object List of All Property Use Types at Property 11746 non-null object Largest Property Use Type 11746 non-null object Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object 2nd Largest Property Use Type 11746 non-null object 2nd Largest Property Use - Gross Floor Area (ft²) 11746 non-null object 3rd Largest Property Use Type 11746 non-null object 3rd Largest Property Use Type - Gross Floor Area (ft²) 11746 non-null object Year Built 11746 non-null int64 Number of Buildings - Self-reported 11746 non-null int64 Occupancy 11746 non-null int64 Metered Areas (Energy) 11746 non-null object Metered Areas (Water) 11746 non-null object ENERGY STAR Score 11746 non-null object Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site EUI (kBtu/ft²) 11746 non-null object Weather Normalized Site Electricity Intensity (kWh/ft²) 11746 non-null object Weather Normalized Site Natural Gas Intensity (therms/ft²) 11746 non-null object Weather Normalized Source EUI (kBtu/ft²) 11746 non-null object Fuel Oil #1 Use (kBtu) 11746 non-null object Fuel Oil #2 Use (kBtu) 11746 non-null object Fuel Oil #4 Use (kBtu) 11746 non-null object Fuel Oil #5 &amp; 6 Use (kBtu) 11746 non-null object Diesel #2 Use (kBtu) 11746 non-null object District Steam Use (kBtu) 11746 non-null object Natural Gas Use (kBtu) 11746 non-null object Weather Normalized Site Natural Gas Use (therms) 11746 non-null object Electricity Use - Grid Purchase (kBtu) 11746 non-null object Weather Normalized Site Electricity (kWh) 11746 non-null object Total GHG Emissions (Metric Tons CO2e) 11746 non-null object Direct GHG Emissions (Metric Tons CO2e) 11746 non-null object Indirect GHG Emissions (Metric Tons CO2e) 11746 non-null object Property GFA - Self-Reported (ft²) 11746 non-null int64 Water Use (All Water Sources) (kgal) 11746 non-null object Water Intensity (All Water Sources) (gal/ft²) 11746 non-null object Source EUI (kBtu/ft²) 11746 non-null object Release Date 11746 non-null object Water Required? 11628 non-null object DOF Benchmarking Submission Status 11716 non-null object Latitude 9483 non-null float64 Longitude 9483 non-null float64 Community Board 9483 non-null float64 Council District 9483 non-null float64 Census Tract 9483 non-null float64 NTA 9483 non-null object dtypes: float64(6), int64(6), object(48) memory usage: 5.4+ MB 果然，有许多列的数字已被标记为对象数据类型（object）。 在我们进行数值分析之前，必须将它们转换为float数据类型。 1.3 将数据转换为正确的数据类型将带有数字的列转换为数字数据类型，方法是将“Not Available”条目替换为可以解释为浮点数的np.nan。 然后我们将包含数值（例如$ft^2$或$kWh$）的列转换为数值数据类型。 1234567# 用np.nan替换所有的Not Available”data = data.replace(&#123;'Not Available': np.nan&#125;)# 将应该为数值类型的列转换为数值类型for col in list(data.columns): if ('ft²' in col or 'kBtu' in col or 'Metric Tons CO2e' in col or 'kWh' in col or 'therms' in col or 'gal' in col or 'Score' in col): data[col] = data[col].astype(float) 12# 每一列的统计信息data.describe() 1.4 缺失值处理现在我们有了正确的列数据类型，我们可以通过查看每列中缺失值的百分比来开始分析。 当我们进行探索性数据分析时，需要计算缺失值的数量以及每列缺少的总值的百分比。处理方式参考Stack Overflow forum的函数。 1234567891011121314151617181920212223242526272829# 计算每一列中缺失值占比def missing_values_table(df): # 计算总的缺失值 mis_val = df.isnull().sum() # 计算缺失值的百分比 mis_val_percent = 100 * df.isnull().sum() / len(df) # 保存缺失值信息的表格 mis_val_table = pd.concat([mis_val, mis_val_percent], axis=1) # 列重命名 mis_val_table_ren_columns = mis_val_table.rename( columns = &#123;0 : 'Missing Values', 1 : '% of Total Values'&#125;) # 缺失值比例按列降序 mis_val_table_ren_columns = mis_val_table_ren_columns[ mis_val_table_ren_columns.iloc[:,1] != 0].sort_values( '% of Total Values', ascending=False).round(1) # 打印总结信息 print ("Your selected dataframe has " + str(df.shape[1]) + " columns.\n" "There are " + str(mis_val_table_ren_columns.shape[0]) + " columns that have missing values.") # 返回各列缺失值占比信息 return mis_val_table_ren_columns# 调用函数missing_values_table(data) Your selected dataframe has 60 columns. There are 46 columns that have missing values. 根据前面的data.shape可知数据集里一共有11746个实例。我们可以看到我们的目标ENERGY STAR Score能源之星分数有2104个缺失值，占比17.9%，非缺失值有9642个。 虽然我们尽量不能丢失信息，但如果列的丢失值占比很高，那么它可能对结果预测没什么帮助。要保留哪些列在这里有一些讨论，本项目中，我们将删除缺失值超过50％的列。一般来说，要特别小心丢弃任何特征，因为即使有一些缺失值，该特征仍然有可能对于预测目标值有帮助。 1234567# 获得缺失值大于50%的列missing_df = missing_values_table(data)missing_columns = list(missing_df[missing_df['% of Total Values'] &gt; 50].index)print('We will remove %d columns.' % len(missing_columns))# 删除缺失值大于50%的列data = data.drop(columns = list(missing_columns)) ! Your selected dataframe has 60 columns. There are 46 columns that have missing values. We will remove 11 columns. 其他的具有缺失值的列将用合适的缺失值填充方法补全。 2 探索性数据分析探索性数据分析(EDA)是一个开放式流程，我们绘图并计算统计数据，以便探索我们的数据。 目的是找到异常，模式，趋势或关系。 这些可能是有趣的（例如，找到两个变量之间的相关性），或者它们可用于通知建模决策，例如使用哪些特征。 简而言之，探索性数据分析的目标是确定我们的数据可以告诉我们什么！ 探索性数据分析通常从数据整体开始，然后在我们找到要检查的区域时缩小到数据集的特定部分。 要开始探索性数据分析，我们将关注目标变量，即Energy Star Score能源之星分数，因为这是我们的机器学习模型的目标。 为简单起见，我们可以将列重命名为score分数，然后开始探索此值。 2.1 单变量分析单变量图显示单个变量的分布，例如直方图。 1234567891011figsize(8, 8)# 将Energy Star Score 重命名为scoredata = data.rename(columns= &#123;'ENERGY STAR Score': 'score'&#125;)# score直方图plt.style.use('fivethirtyeight')plt.hist(data['score'].dropna(), bins = 100, edgecolor = 'k')plt.xlabel('Score')plt.ylabel('Number of Buildings')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &#39;Energy Star Score Distribution&#39;) 由于能源之星分数是百分位数，我们预计会看到完全平坦的分布，每个分数占分布的1％（约90个建筑物）。然而，这绝对不是这种情况，因为我们可以看到两个最常见的分数，1和100，构成总分数的不相称的数字。即在两端出现了异常值。 如果我们回到分数的定义，我们会看到它是基于自我报告的能量使用情况。这造成了一个问题，因为建筑物所有者可能想要报告较低的用电量以人为地提高他们的建筑物的分数。这就像给学生一个基于自我报告的考试成绩的成绩。这种行为可以解释高比例的建筑物满分为100，但不能解释为什么这么多建筑物在最底层分数！ 为了对比能源之星分数，我们可以看一下能源使用强度（EUI），它是总能源消耗除以建筑物的平方英尺。在这里，能源使用量不是自我报告的，因此这可以更加客观地衡量建筑物的能源效率。此外，这不是百分位数，因此绝对值很重要，我们希望它们大致正态分布，可能在低端或高端有一些异常值。 123456# Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &#39;Site EUI distribution&#39;) 这表明我们还有另一个问题：异常值！ 由于存在一些分数非常高的建筑物，因此图表非常偏斜。 因此我们需要首先处理异常值。我们来看看EUI这个特征的统计数据。 1data['Site EUI (kBtu/ft²)'].describe() count 11583.000000 mean 280.071484 std 8607.178877 min 0.000000 25% 61.800000 50% 78.500000 75% 97.600000 max 869265.000000 Name: Site EUI (kBtu/ft²), dtype: float64 12# 我们看一下EUI特征最大的10个值data['Site EUI (kBtu/ft²)'].dropna().sort_values().tail(10) 3173 51328.8 3170 51831.2 3383 78360.1 8269 84969.6 3263 95560.2 8268 103562.7 8174 112173.6 3898 126307.4 7 143974.4 8068 869265.0 Name: Site EUI (kBtu/ft²), dtype: float64 其中一栋建筑的EUI远高于其他的，我们看一下这个建筑。 1data.loc[data['Site EUI (kBtu/ft²)'] == 869265.0, :] 异常值可能由于多种原因发生： 拼写错误 测量设备故障 不正确的单位 或者它们可能是合法的但是极端值。 异常值可以删除，因为它们并不表示数据的实际分布。 2.2 删除异常值当我们删除异常值时，我们要小心，我们不能因为异常值就直接删除。 它们可能是我们应该进一步调查的实际现象的结果。 当删除异常值时，可以尝试使用极端异常值的定义来处理，这样可以尽可能保守： 在低端，极端异常值低于 $\text{First Quartile} -3 * \text{Interquartile Range}$ 在高端，极端异常值高于 $\text{Third Quartile} + 3 * \text{Interquartile Range}$ 在这种情况下，我将只删除单个外围点并查看分布情况。 12345678910# 计算第一和第三分位点first_quartile = data['Site EUI (kBtu/ft²)'].describe()['25%']third_quartile = data['Site EUI (kBtu/ft²)'].describe()['75%']# 计算四分位范围：即第一第三分位之间的范围iqr = third_quartile - first_quartile# 去除异常值data = data[(data['Site EUI (kBtu/ft²)'] &gt; (first_quartile - 3 * iqr)) &amp; (data['Site EUI (kBtu/ft²)'] &lt; (third_quartile + 3 * iqr))] 123456# 重画Site EUI的直方图分布figsize(8, 8)plt.hist(data['Site EUI (kBtu/ft²)'].dropna(), bins = 20, edgecolor = 'black')plt.xlabel('Site EUI')plt.ylabel('Count')plt.title('Site EUI distribution') Text(0.5, 1.0, &#39;Site EUI distribution&#39;) 删除异常值后，这个直方图分布看起来比较正常，并且接近正态分布，右侧有一条长尾（它有一个正偏斜）。 虽然这可能是一个更客观的衡量标准，但我们的目标仍然是预测能源之星分数，因此我们将回过头来研究该变量。 即使能源之星分数不是一个好的衡量标准，我们仍然需要预测它，这就是我们要做的事情！ 在回到公司的最终报告中，我将指出这可能不是一个客观的衡量标准，并且使用不同的指标来确定建筑物的效率是个好主意。 此外，看看分数为1和100的建筑物可能会很有趣，看看它们是否有任何共同之处。 2.3 寻找关系为了查看分类变量 - categorical variables对分数的影响，我们可以通过分类变量的值来绘制密度图。 密度图还显示单个变量的分布，可以认为是平滑的直方图。 如果我们通过为分类变量密度曲线着色，这将向我们展示分布如何基于类别变化的。 我们将制作的第一个图表显示了Largest Property Use Type建筑类型的分布。 为了不使图形混乱，我们将图形限制为在数据集中具有超过100个观测值的建筑类型。 “具有超过100个观测值的建筑类型” 这句话是什么意思呢？ 有的建筑是住宅楼，有的是酒店，有的是写字楼办公楼，有的是医院等等。 如果用作住宅楼的建筑和用作办公楼的建筑都超过100栋了，那我们就把这两种类型的建筑物的分数分布画出来。例如下图中的红色曲线就代表Office这个类型的建筑物的能源之星分数分布 1234# 统计每个属性值的个数types = data.dropna(subset=['score'])types = types['Largest Property Use Type'].value_counts()types Multifamily Housing 7464 Office 1157 Hotel 202 Non-Refrigerated Warehouse 156 K-12 School 97 Residence Hall/Dormitory 96 Senior Care Community 85 Distribution Center 61 Retail Store 57 Medical Office 23 Hospital (General Medical &amp; Surgical) 15 Financial Office 12 Supermarket/Grocery Store 10 Worship Facility 9 Refrigerated Warehouse 8 Wholesale Club/Supercenter 3 Parking 3 Courthouse 2 Bank Branch 1 Name: Largest Property Use Type, dtype: int64 可以看到，属性值大于100个的有四个： Multifamily Housing Office Hotel Non-Refrigerated Warehouse 12345678910111213141516# 取出属性值个数大于100个的属性types = list(types[types.values &gt; 100].index)# 建筑类型的密度图figsize(12,10)# 绘制每一种建筑类型for b_type in types: # 选出建筑类型 subset = data[data['Largest Property Use Type'] == b_type] # 绘制对应建筑类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = b_type, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Building Type', size = 28) C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &#39;Density Plot of Energy Star Scores by Building Type&#39;) 从该图中，我们可以看到建筑类型确实对分数有影响（图上的负分数是核密度估计过程的人工产物）。 虽然我最初将重点放在用于预测分数的数字列上，但此图表告诉我们应该包含属性类型，因为此信息可用于确定分数。 由于建筑类型是一个分类变量，因此在将其输入机器学习模型之前，必须对其进行独热编码。 为检查另一个分类变量，行政区Borough，我们可以制作类似的图表。 1234# 统计每个属性值的个数boroughs = data.dropna(subset = ['score'])boroughs = boroughs['Borough'].value_counts()boroughs Manhattan 3985 Brooklyn 1947 Queens 1707 Bronx 1655 Staten Island 119 Name: Borough, dtype: int64 12345678910111213141516# 取出属性值个数大于100个的属性boroughs = list(boroughs[boroughs.values &gt; 100].index)# Borough类型的密度图figsize(12,10)# 绘制每一种Borough类型for borough in boroughs: # 选出Borough类型 subset = data[data['Borough'] == borough] # 绘制对应Borough类型的分数密度图 sns.kdeplot(subset['score'].dropna(), label = borough, shade = False, alpha = 0.8)plt.xlabel('Energy Star Score', size = 20)plt.ylabel('Density', size = 20)plt.title('Density Plot of Energy Star Scores by Borough', size = 28) Text(0.5, 1.0, &#39;Density Plot of Energy Star Scores by Borough&#39;) 建筑的Borough似乎没有像建筑type那样在分数分布上产生显着差异。 尽管如此，将Borough纳入分类变量可能是有意义的。 2.4 特征变量和目标变量的关系为了量化特征（变量）和目标之间的相关性，我们可以计算Pearson相关系数。 这是两个变量之间线性关系的强度和方向的度量：值-1表示两个变量完全负线性相关，值+1表示两个变量完全正线性相关。 尽管特征和目标之间可能存在非线性关系，并且相关系数不考虑特征之间的相互作用，但线性关系是开始探索数据趋势的好方法。 然后，我们可以使用这些值来选择要在我们的模型中使用的特征。 下面的代码计算所有变量和目标变量score之间的相关系数。 12345678910# 计算所有变量和score的相关系数correlations_data = data.corr()['score'].sort_values()# 最负相关的15个特征print(correlations_data.head(15))print('===================================')# 最正相关的15个特征print(correlations_data.tail(15)) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Weather Normalized Site Natural Gas Intensity (therms/ft²) -0.346046 Direct GHG Emissions (Metric Tons CO2e) -0.147792 Weather Normalized Site Natural Gas Use (therms) -0.135211 Natural Gas Use (kBtu) -0.133648 Year Built -0.121249 Total GHG Emissions (Metric Tons CO2e) -0.113136 Electricity Use - Grid Purchase (kBtu) -0.050639 Weather Normalized Site Electricity (kWh) -0.048207 Latitude -0.048196 Property Id -0.046605 Name: score, dtype: float64 =================================== Property Id -0.046605 Indirect GHG Emissions (Metric Tons CO2e) -0.043982 Longitude -0.037455 Occupancy -0.033215 Number of Buildings - Self-reported -0.022407 Water Use (All Water Sources) (kgal) -0.013681 Water Intensity (All Water Sources) (gal/ft²) -0.012148 Census Tract -0.002299 DOF Gross Floor Area 0.013001 Property GFA - Self-Reported (ft²) 0.017360 Largest Property Use Type - Gross Floor Area (ft²) 0.018330 Order 0.036827 Community Board 0.056612 Council District 0.061639 score 1.000000 Name: score, dtype: float64 可以看到，有几个特征与目标变量score存在强负相关关系，与score最负相关的是： Energy Use Intensity (EUI) Site EUI (kBtu/ft²) Weather Normalized Site EUI (kBtu/ft²)（这些只在计算方式上略有不同）。 EUI是建筑使用的能量除以建筑物的平方英尺，并且用于衡量建筑物的效率，其中分数越低越好。 直观地说，这些相关性是有意义的：随着EUI的增加，能源之星分数score趋于下降。 为了考虑可能的非线性关系，我们可以采用特征的平方根和自然对数变换，然后用分数计算相关系数。 为了尝试捕获行政区Borough或建筑type之间的任何可能的关系（这两个特征是类别变量）和分数，我们将对这些特征进行独热编码。 在下面的代码中，我们采用以下策略： 对数值特征：进行平方根和对数变换； 对两个类别变量（Borough和type）进行独热编码； 最后计算所有特征与score之间的相关性，并显示前15个 最积极的和前15个最负相关。 1234567891011121314151617181920212223242526# 选择数值特征numeric_subset = data.select_dtypes('number')# 创建平方根和对数列for col in numeric_subset.columns: # 跳过 Energy Star Score 列 if col == 'score': next else: numeric_subset['sqrt_' + col] = np.sqrt(numeric_subset[col]) numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 独热编码categorical_subset = pd.get_dummies(categorical_subset)# 使用concat对两个数据帧进行拼接，axis=1列绑定features = pd.concat([numeric_subset, categorical_subset], axis = 1)# 去掉没有评分的建筑物features = features.dropna(subset = ['score'])# 计算特征与score之间的相关性correlations = features.corr()['score'].dropna().sort_values() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: divide by zero encountered in log # This is added back by InteractiveShellApp.init_path() C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:10: RuntimeWarning: invalid value encountered in sqrt # Remove the CWD from sys.path while we load stuff. C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:11: RuntimeWarning: invalid value encountered in log # This is added back by InteractiveShellApp.init_path() 12# 显示最负相关的15个特征correlations.head(15) Site EUI (kBtu/ft²) -0.723864 Weather Normalized Site EUI (kBtu/ft²) -0.713993 sqrt_Site EUI (kBtu/ft²) -0.699817 sqrt_Weather Normalized Site EUI (kBtu/ft²) -0.689019 sqrt_Weather Normalized Source EUI (kBtu/ft²) -0.671044 sqrt_Source EUI (kBtu/ft²) -0.669396 Weather Normalized Source EUI (kBtu/ft²) -0.645542 Source EUI (kBtu/ft²) -0.641037 log_Source EUI (kBtu/ft²) -0.622892 log_Weather Normalized Source EUI (kBtu/ft²) -0.620329 log_Site EUI (kBtu/ft²) -0.612039 log_Weather Normalized Site EUI (kBtu/ft²) -0.601332 log_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.424246 sqrt_Weather Normalized Site Electricity Intensity (kWh/ft²) -0.406669 Weather Normalized Site Electricity Intensity (kWh/ft²) -0.358394 Name: score, dtype: float64 12# # 显示最正相关的15个特征correlations.tail(15) sqrt_Order 0.028662 Borough_Queens 0.029545 Largest Property Use Type_Supermarket/Grocery Store 0.030038 Largest Property Use Type_Residence Hall/Dormitory 0.035407 Order 0.036827 Largest Property Use Type_Hospital (General Medical &amp; Surgical) 0.048410 Borough_Brooklyn 0.050486 log_Community Board 0.055495 Community Board 0.056612 sqrt_Community Board 0.058029 sqrt_Council District 0.060623 log_Council District 0.061101 Council District 0.061639 Largest Property Use Type_Office 0.158484 score 1.000000 Name: score, dtype: float64 在进行非线性转换特征之后： 最强的特征仍然是与能量使用强度（EUI）相关的特征。 对数和平方根变换似乎没有产生任何更强的特征。 尽管我们确实看到建筑类型的办公室（Largest Property Use Type_Office ）与score略微正相关，但没有强烈的正线性关系。此变量是建筑类型的分类变量的独热编码表示。 我们可以使用这些相关性来执行特征选择。 现在，让我们绘制数据集中最重要的相关性（就绝对值而言），即Site EUI (kBtu/ft²)。 我们可以通过建筑类型为图形着色，以显示它如何影响关系。 2.5 双变量分析为了可视化两个变量之间的关系，我们使用散点图。我们还可以使用标记的颜色或大小等方面包含其他变量。在这里，我们将绘制两个数值变量，并使用颜色表示第三个分类变量。 12345678910111213141516figsize(12, 10)# 提取建筑类型特征features['Largest Property Use Type'] = data.dropna(subset=['score'])['Largest Property Use Type']# 限制只取观测值大于100的建筑类型 (从前面的代码)features = features[features['Largest Property Use Type'].isin(types)]# 利用seaborn画score和Site EUI的回归散点图sns.lmplot('Site EUI (kBtu/ft²)', 'score', hue = 'Largest Property Use Type', data = features, scatter_kws = &#123;'alpha': 0.8, 's': 60&#125;, fit_reg = False, size = 12, aspect = 1.2);plt.xlabel('Site EUI', size = 28)plt.ylabel('Energy Star Score', size = 28)plt.title('Energy Star Score vs Site EUI', size = 36) C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\regression.py:546: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(msg, UserWarning) Text(0.5, 1.0, &#39;Energy Star Score vs Site EUI&#39;) Site EUI与score之间存在明显的负相关关系。 这种关系不是完全线性的（相似系数为-0.7，但看起来这个特征对预测建筑物的score很重要。 2.6 多变量分析（pairs plot）我们还可以在几个不同的变量之间建立Pairs Plot。 Pairs Plot是一次检查多个变量的好方法，因为它显示了对角线上的变量对和单个变量直方图之间的散点图。 使用seaborn PairGrid函数，我们可以将不同的图绘制到网格中: 上三角：散点图 对角线：直方图 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计。 123456789101112131415161718192021222324252627282930313233343536373839# 提取需要绘制的变量plot_data = features[['score', 'Site EUI (kBtu/ft²)', 'Weather Normalized Source EUI (kBtu/ft²)', 'log_Total GHG Emissions (Metric Tons CO2e)']]# 使用nan代替infplot_data = plot_data.replace(&#123;np.inf: np.nan, -np.inf:np.nan&#125;)# 重命名列plot_data = plot_data.rename(columns = &#123;'Site EUI (kBtu/ft²)': 'Site EUI', 'Weather Normalized Source EUI (kBtu/ft²)': 'Weather Norm EUI', 'log_Total GHG Emissions (Metric Tons CO2e)': 'log GHG Emissions'&#125;)# 删除缺失值plot_data = plot_data.dropna()# 用于计算两个特征的相关系数的函数def corr_func(x, y, **kwargs): # 计算皮尔逊积矩相关系数 r = np.corrcoef(x, y)[0][1] ax = plt.gca() ax.annotate("r = &#123;:.2f&#125;".format(r), xy=(.2, .8), xycoords=ax.transAxes, size = 20)# 创建绘图网格矩阵grid = sns.PairGrid(data = plot_data, size = 3)# 上三角：散点图grid.map_upper(plt.scatter, color = 'red', alpha = 0.6)# 对角线：直方图grid.map_diag(plt.hist, color = 'red', edgecolor = 'black')# 下三角：两个变量之间的相关系数和两个变量的2-D核密度估计grid.map_lower(corr_func);grid.map_lower(sns.kdeplot, cmap = plt.cm.Reds)# 整张图的标题plt.suptitle('Pairs Plot of Energy Data', size = 36, y = 1.02); C:\Users\huangqiancun\Anaconda3\lib\site-packages\seaborn\axisgrid.py:1241: UserWarning: The `size` paramter has been renamed to `height`; please update your code. warnings.warn(UserWarning(msg)) 为了解释图中的关系，我们可以查找一行中的变量与一列中的变量相交的位置。 例如， 要查找score与log of GHG Emissions之间的关系，我们会查看score列和 log of GHG Emissions行。在交叉点（左下图），我们看到分数与该变量的相关系数为-0.35。如果我们查看对应的右上角图，我们可以看到这种关系的散点图。 同样，要查看Weather EUorm EUI与score的相关性，我们查看Weather EUorm EUI行和score列，可以看到相关系数为-0.67。 3 特征工程和特征选择现在我们已经探索了数据中的趋势和关系，我们可以为我们的模型设计一组功能。 我们可以使用EDA的结果来进行特征工程。 特别是，我们从EDA学到了以下知识，可以帮助我们设计/选择特征： 分数score分布因建筑类型type而异，并且在较小程度上因行政区Borough而异。 因此我们不仅需要关注数值特征，还应该在模型中包含这两个类别特征； 对特征进行对数或平方根变换不会导致特征与分数之间的线性相关性显着增加。 在我们进一步讨论之前，我们应该理解特征工程和特征选择，这些定义是非正式的，并且有相当大的重叠，但我喜欢将它们视为两个独立的过程： 特征工程: 获取原始数据并提取或创建新特征的过程，这些特征允许机器学习模型学习这些特征与目标之间的映射。 这可能意味着对变量进行转换，例如我们对数值特征进行对数和平方根转换，或者对类别变量使用独热编码，以便可以在模型中使用它们。 通常，我认为特征工程是添加从原始数据派生的附加特征。 特征选择: 选择数据中最相关特征的过程。 “最相关”可能取决于许多因素，但它可能与目标的最高相关性或具有最大差异的特征most variance。 在特征选择中，我们会删除对模型学习无用的特征。 这可以帮助模型更好地概括新数据并产生更可解释的模型。 一般来说，我认为特征选择是减去特征，所以我们只留下最重要的特征。 特征工程和选择是迭代过程，通常需要多次尝试才能得到较好的结果。 通常，我们将使用建模结果（例如来自随机森林的特征重要性排序）返回并重做特征选择，或者需要创建新特征的关系。 此外，这些过程通常包含领域知识和数据统计质量的混合。 特征工程和选择 对于获得一个高精度的机器学习模型至关重要。 它可能需要耗费很长时间，但通常比用于模型的算法和超参数选择更重要。 如果我们不为模型提供正确的数据，那么我们将其视为失败，我们不应期望它能够学习！ 在本项目中，我们将采用以下步骤进行特征工程： 仅选择数值变量和两个分类变量（行政区borough和建筑物类型property use type） 对数值变量进行对数变换 对类别变量进行One-hot编码 对于特征选择，我们将执行以下操作： 删除共线性特征 当我们进行特征选择时，我们将讨论共线性（也称为多重共线性）！ 以下代码选择数值特征，并进行对数变换，选择类别特征进行独热编码，并将特征拼接在一起。 1234567891011121314151617181920212223# 复制原始数据features = data.copy# 选择数值特征numeric_subset = data.select_dtypes('number')# 对每一个数值特征进行对数变换for col in numeric_subset.columns: # score为要预测的目标变量，跳过 if col == 'score': next else: numeric_subset['log_' + col] = np.log(numeric_subset[col])# 选择类别特征categorical_subset = data[['Borough', 'Largest Property Use Type']]# 进行独热编码categorical_subset = pd.get_dummies(categorical_subset)# 列拼接，axis = 1features = pd.concat([numeric_subset, categorical_subset], axis = 1)features.shape C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: divide by zero encountered in log del sys.path[0] C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:13: RuntimeWarning: invalid value encountered in log del sys.path[0] (11319, 110) 此时，我们有11319个观测（建筑物），具有109个不同的特征（其中一列是分数score）。 并非所有这些特征对于预测分数有帮助，其中一些特征也许是多余的，因为它们具有高度相关性。 我们将在下面讨论第二个问题。 3.1 删除共线性特征高共线特征在它们之间具有显着的相关系数。 例如，在我们的数据集中，Site EUI和Weather Normalized Site EUI高度相关，因为它们只是略微不同的计算能源使用强度的方法。 12345plot_data = data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna()plt.plot(plot_data['Site EUI (kBtu/ft²)'], plot_data['Weather Normalized Site EUI (kBtu/ft²)'], 'bo')plt.xlabel('Site EUI')plt.ylabel('Weather Norm EUI')plt.title('Weather Norm EUI vs Site EUI, R = %0.4f' % np.corrcoef(data[['Weather Normalized Site EUI (kBtu/ft²)', 'Site EUI (kBtu/ft²)']].dropna(), rowvar=False)[0][1]); 高度共线性的特征可能是多余的，我们只需保留其中一个特征即可为模型提供必要的信息。 删除共线性特征是一种通过减少特征数量来降低模型复杂性的方法，可以提高模型泛化能力。 它还可以帮助我们解释模型，因为我们只需要考虑单一变量，例如EUI，而不是 EUI 和 weather normalized EUI 如何影响分数。 有许多方法可以消除共线特征，例如使用方差膨胀因子。 我们将使用更简单的度量，并删除具有高于某个阈值的相关系数的特征（不是分数，因为我们需要与分数高度相关的特征！）有关删除共线性特征的更全面的讨论， 可以看Kaggle的这个notebook。 以下代码通过删除所比较的两个特征之一，根据我们为相关系数选择的阈值来移除共线性特征。 它还会打印它删除的相关性，以便我们可以看到调整阈值的效果。 我们将使用0.6的阈值，如果特征之间的相关系数超过该值，则删除一对特征中的一个。 代码改编自Stack Overflow的答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def remove_collinear_features(x, threshold): ''' Objective: Remove collinear features in a dataframe with a correlation coefficient greater than the threshold. Removing collinear features can help a model to generalize and improves the interpretability of the model. Inputs: threshold: any features with correlations greater than this value are removed Output: dataframe that contains only the non-highly-collinear features ''' # 不要删除与目标变量score之间的相关性 y = x['score'] x = x.drop(columns = ['score']) # 计算相关性矩阵 corr_matrix = x.corr() iters = range(len(corr_matrix.columns) - 1) drop_cols = [] # 遍历相关性矩阵并进行比较 for i in iters: for j in range(i): item = corr_matrix.iloc[j:(j+1), (i+1):(i+2)] col = item.columns row = item.index val = abs(item.values) # 如果有相关性超过阈值 if val &gt;= threshold: # Print the correlated features and the correlation value print(col.values[0], "|", row.values[0], "|", round(val[0][0], 2)) drop_cols.append(col.values[0]) # 删除每对相关特征中的一个 drops = set(drop_cols) x = x.drop(columns = drops) # 删除具有明显相关性的特征，知识计算方式不同 x = x.drop(columns = ['Weather Normalized Site EUI (kBtu/ft²)', 'Water Use (All Water Sources) (kgal)', 'log_Water Use (All Water Sources) (kgal)', 'Largest Property Use Type - Gross Floor Area (ft²)']) # 将目标变量添加回数据帧 x['score'] = y return x 12# 删除相关系数大于指定阈值的特征features = remove_collinear_features(features, 0.6) Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.83 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.81 Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.85 Natural Gas Use (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Weather Normalized Site Natural Gas Use (therms) | Largest Property Use Type - Gross Floor Area (ft²) | 0.61 Electricity Use - Grid Purchase (kBtu) | DOF Gross Floor Area | 0.63 Electricity Use - Grid Purchase (kBtu) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 Weather Normalized Site Electricity (kWh) | DOF Gross Floor Area | 0.66 Weather Normalized Site Electricity (kWh) | Largest Property Use Type - Gross Floor Area (ft²) | 0.66 Total GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.75 Total GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.79 Total GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.69 Total GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.92 Direct GHG Emissions (Metric Tons CO2e) | Natural Gas Use (kBtu) | 0.97 Direct GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Natural Gas Use (therms) | 0.96 Indirect GHG Emissions (Metric Tons CO2e) | DOF Gross Floor Area | 0.61 Indirect GHG Emissions (Metric Tons CO2e) | Largest Property Use Type - Gross Floor Area (ft²) | 0.64 Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.95 Indirect GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.87 Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.86 Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.99 Property GFA - Self-Reported (ft²) | Natural Gas Use (kBtu) | 0.6 Property GFA - Self-Reported (ft²) | Weather Normalized Site Natural Gas Use (therms) | 0.6 Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.7 Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.7 Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.81 Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.81 Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.79 Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 1.0 Council District | Order | 0.86 Council District | Latitude | 0.68 log_Order | Order | 0.88 log_Order | Council District | 0.64 log_Property Id | Property Id | 0.93 log_DOF Gross Floor Area | DOF Gross Floor Area | 0.69 log_DOF Gross Floor Area | Largest Property Use Type - Gross Floor Area (ft²) | 0.63 log_DOF Gross Floor Area | Electricity Use - Grid Purchase (kBtu) | 0.62 log_DOF Gross Floor Area | Weather Normalized Site Electricity (kWh) | 0.62 log_DOF Gross Floor Area | Total GHG Emissions (Metric Tons CO2e) | 0.65 log_DOF Gross Floor Area | Property GFA - Self-Reported (ft²) | 0.65 log_Largest Property Use Type - Gross Floor Area (ft²) | DOF Gross Floor Area | 0.61 log_Largest Property Use Type - Gross Floor Area (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.68 log_Largest Property Use Type - Gross Floor Area (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Largest Property Use Type - Gross Floor Area (ft²) | Property GFA - Self-Reported (ft²) | 0.68 log_Year Built | Year Built | 1.0 log_Number of Buildings - Self-reported | Number of Buildings - Self-reported | 0.73 log_Occupancy | Occupancy | 0.93 log_Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.87 log_Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.71 log_Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.86 log_Weather Normalized Site EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.69 log_Weather Normalized Site EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.68 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.86 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Electricity Intensity (kWh/ft²) | Source EUI (kBtu/ft²) | 0.77 log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.93 log_Weather Normalized Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.78 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.65 log_Weather Normalized Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.84 log_Weather Normalized Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.91 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.9 log_Weather Normalized Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.76 log_Natural Gas Use (kBtu) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Natural Gas Use (kBtu) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Weather Normalized Site Natural Gas Use (therms) | Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.73 log_Weather Normalized Site Natural Gas Use (therms) | log_Weather Normalized Site Natural Gas Intensity (therms/ft²) | 0.72 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Electricity Use - Grid Purchase (kBtu) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | Weather Normalized Site Electricity (kWh) | 0.62 log_Electricity Use - Grid Purchase (kBtu) | log_DOF Gross Floor Area | 0.74 log_Electricity Use - Grid Purchase (kBtu) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Electricity Use - Grid Purchase (kBtu) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.69 log_Weather Normalized Site Electricity (kWh) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Weather Normalized Site Electricity (kWh) | Weather Normalized Site Electricity (kWh) | 0.62 log_Weather Normalized Site Electricity (kWh) | log_DOF Gross Floor Area | 0.75 log_Weather Normalized Site Electricity (kWh) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.74 log_Weather Normalized Site Electricity (kWh) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.79 log_Total GHG Emissions (Metric Tons CO2e) | Total GHG Emissions (Metric Tons CO2e) | 0.63 log_Total GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.73 log_Total GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.76 log_Total GHG Emissions (Metric Tons CO2e) | log_Site EUI (kBtu/ft²) | 0.6 log_Total GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Source EUI (kBtu/ft²) | 0.67 log_Total GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.84 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.68 log_Indirect GHG Emissions (Metric Tons CO2e) | Electricity Use - Grid Purchase (kBtu) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | Weather Normalized Site Electricity (kWh) | 0.62 log_Indirect GHG Emissions (Metric Tons CO2e) | log_DOF Gross Floor Area | 0.74 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.73 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.77 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Electricity Use - Grid Purchase (kBtu) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Weather Normalized Site Electricity (kWh) | 0.99 log_Indirect GHG Emissions (Metric Tons CO2e) | log_Total GHG Emissions (Metric Tons CO2e) | 0.84 log_Property GFA - Self-Reported (ft²) | DOF Gross Floor Area | 0.61 log_Property GFA - Self-Reported (ft²) | Largest Property Use Type - Gross Floor Area (ft²) | 0.67 log_Property GFA - Self-Reported (ft²) | Electricity Use - Grid Purchase (kBtu) | 0.61 log_Property GFA - Self-Reported (ft²) | Weather Normalized Site Electricity (kWh) | 0.61 log_Property GFA - Self-Reported (ft²) | Total GHG Emissions (Metric Tons CO2e) | 0.64 log_Property GFA - Self-Reported (ft²) | Property GFA - Self-Reported (ft²) | 0.69 log_Property GFA - Self-Reported (ft²) | log_DOF Gross Floor Area | 0.92 log_Property GFA - Self-Reported (ft²) | log_Largest Property Use Type - Gross Floor Area (ft²) | 0.98 log_Property GFA - Self-Reported (ft²) | log_Electricity Use - Grid Purchase (kBtu) | 0.75 log_Property GFA - Self-Reported (ft²) | log_Weather Normalized Site Electricity (kWh) | 0.76 log_Property GFA - Self-Reported (ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.77 log_Source EUI (kBtu/ft²) | Site EUI (kBtu/ft²) | 0.78 log_Source EUI (kBtu/ft²) | Weather Normalized Site EUI (kBtu/ft²) | 0.77 log_Source EUI (kBtu/ft²) | Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.66 log_Source EUI (kBtu/ft²) | Weather Normalized Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | Source EUI (kBtu/ft²) | 0.85 log_Source EUI (kBtu/ft²) | log_Site EUI (kBtu/ft²) | 0.9 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site EUI (kBtu/ft²) | 0.89 log_Source EUI (kBtu/ft²) | log_Weather Normalized Site Electricity Intensity (kWh/ft²) | 0.78 log_Source EUI (kBtu/ft²) | log_Weather Normalized Source EUI (kBtu/ft²) | 1.0 log_Source EUI (kBtu/ft²) | log_Total GHG Emissions (Metric Tons CO2e) | 0.67 log_Latitude | Latitude | 1.0 log_Latitude | Council District | 0.68 log_Community Board | Community Board | 0.92 log_Council District C:\Users\huangqiancun\Anaconda3\lib\site-packages\ipykernel_launcher.py:33: RuntimeWarning: invalid value encountered in greater_equal | Order | 0.92 log_Council District | Council District | 0.91 log_Council District | log_Order | 0.79 log_Census Tract | Census Tract | 0.78 Borough_Bronx | Latitude | 0.62 Borough_Bronx | Longitude | 0.69 Borough_Bronx | log_Latitude | 0.62 Borough_Brooklyn | Latitude | 0.74 Borough_Brooklyn | Council District | 0.89 Borough_Brooklyn | log_Latitude | 0.74 Borough_Brooklyn | log_Council District | 0.75 Borough_Manhattan | Order | 0.81 Borough_Manhattan | Council District | 0.78 Borough_Manhattan | log_Order | 0.63 Borough_Manhattan | log_Council District | 0.84 Borough_Queens | Order | 0.62 Largest Property Use Type_Office | Largest Property Use Type_Multifamily Housing | 0.63 12features = features.dropna(axis=1, how = 'all')features.shape (11319, 65) 我们的最终数据集有64个特征（其中一列是目标score）。 这仍然不少，但主要是因为我们有一个独热编码的分类变量。 诸如线性回归之类的模型可能存在大量特征， 但诸如随机森林之类的模型执行隐式特征选择并自动确定在训练期间哪些特征是重要的。 还有其他特征选择步骤，但是现在我们将保留我们拥有的所有特征用于训练模型并检验模型的性能。 其他选择选择方法还有很多特征选择的方法，比如主成分分析（PCA），其将特征降低为若干个最大方差的维度，或独立成分分析（ICA），其旨在在一组特征中找到独立源。 然而，虽然这些方法在减少特征数量方面是有效的，但它们创造了没有物理意义的新特征，因此几乎不可能解释模型。 这些方法对于处理高维数据非常有用，更多相关内容。 3.2 训练集和测试集的划分在机器学习中，我们通常需要将我们的数据分为两组： 训练集：有特征和目标值的，用于学习特征和目标之间的映射。 测试集：用于验证模型的效果，该模型从未在测试集上看到过目标值，而是必须使用这些特征进行预测。当我们知道测试集的真实答案时，我们可以将测试预测值与真实值进行比较，以估计我们的模型在现实世界中部署时的表现。 本项目中，我们将首先提取所有没有Energy Star Score能源之星分数的建筑物（我们不知道这些建筑物的真实答案，因此它们对训练或测试没有帮助）。然后，我们将有分数的建筑物分成70&amp;的训练集和30%的测试集。 使用scikit-learn将数据随机拆分为训练和测试集很简单。我们可以设置拆分的random_state以确保一致的结果。 123456# 将数据按照有无score分类no_score = features[features['score'].isna()]score = features[features['score'].notnull()]print(no_score.shape)print(score.shape) (1858, 65) (9461, 65) 1234567891011121314# 将特征和目标变量拆分features = score.drop(columns='score')targets = pd.DataFrame(score['score'])# 为了方便后续的填充，用np.nan替换np.inf和-np.inffeatures = features.replace(&#123;np.inf: np.nan, -np.inf: np.nan&#125;)# 划分70%的训练集和30%的测试集X, X_test, y, y_test = train_test_split(features, targets, test_size = 0.3, random_state = 42)print(X.shape)print(y.shape)print(X_test.shape)print(y_test.shape) (6622, 64) (6622, 1) (2839, 64) (2839, 1) 我们有1858座没有分数的建筑；有分数的建筑中，6622座用作训练集，2839座用作测试集中，接下来建立一个naive 的 baseline以在后续模型中不断优化。 3.3 建立一个baseline在我们开始建立机器学习模型之前建立一个naive的基线是很重要的。 如果我们构建的模型不能胜过naive的猜测，那么我们可能不得不承认机器学习不适合这个问题。 这可能是因为我们没有使用正确的模型，需要更多的数据，或者因为有一个更简单的解决方案，不需要机器学习。 建立基线至关重要，因此我们最终可能不会去建立机器学习模型，只是意识到我们无法真正解决问题。 对于回归任务，良好的基线是使用训练集上目标的中值作为所有所有测试集样本的预测值。这很容易实现，并为我们的模型设置了相对较低的标准：如果它们不能比猜测的中值更好，那么我们需要重新思考我们的方法。 度量标准：平均绝对误差机器学习任务中使用了许多指标，很难知道选择哪一个指标。 大多数情况下，它将取决于特定问题，如果有一个特定的目标来优化。 Andrew Ng建议使用单个实值性能指标来比较模型，因为它简化了评估过程。 我们应该使用一个数字，而不是计算多个指标并尝试确定每个指标的重要程度。 在这种情况下，因为我们进行回归，所以平均绝对误差是适当的度量。 这也是可以解释的，因为它表示我们的估计的平均分数数量，并且与目标值的单位相同 下面的函数计算真实值和预测值之间的平均绝对误差。 123# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred)) 现在我们可以做中值猜测并用于测试集。 1234baseline_guess = np.median(y)print('The baseline guess is a score of %0.2f' % baseline_guess)print("Baseline Performance on the test set: MAE = %0.4f" % mae(y_test, baseline_guess)) The baseline guess is a score of 66.00 Baseline Performance on the test set: MAE = 24.5164 这表明我们对测试集的平均估计偏差约25%。 因为分数在1到100之间，因此这意味着来自baseline的平均误差约25%。猜测训练集中值的naive方法为我们的后续的模型提供了一个低基线！ 3.4 小结到目前为止，我们完成了开头所说机器学习工作流程的前三个步骤： 数据清理和格式化 探索性数据分析 特征工程和选择 我们还完成了建立基线指标的关键任务，以便我们确定我们的模型是否比猜测更好！ 以上我们了解了流程中的每个部分是如何流入下一个部分的： 清理数据并将其转换为正确的格式允许我们执行探索性数据分析(EDA)； EDA的结果辅助我们进行特征工程和选择。 这三个步骤通常按此顺序执行，但我们可能会稍后再回来，根据我们的建模结果进行更多的EDA或特征工程。数据科学是一个迭代过程，我们一直在寻找改进以前工作的方法。这意味着我们不必第一次完成任务（尽管我们可以尽力），因为一旦我们对问题有了更多的了解，总有机会重新审视我们的决策。 接下来，我们将重点实现几种机器学习方法，选择最佳模型，并使用交叉验证的超参数调整方法优化我们的问题。 同时，把我们处理过的数据集保存起来，以便在后续步骤中再次使用。 123456# 保存没有分数的数据集，训练集，测试集no_score.to_csv('dataset/no_score.csv', index = False)X.to_csv('dataset/training_features.csv', index = False)X_test.to_csv('dataset/testing_features.csv', index = False)y.to_csv('dataset/training_labels.csv', index = False)y_test.to_csv('dataset/testing_labels.csv', index = False) 4 评估和比较机器学习模型4.1 导入库文件在本项目中，我们使用各种标准的数据科学和机器学习库。 1234567891011# 缺失值填充和最大最小归一化处理from sklearn.preprocessing import Imputer, MinMaxScaler# 机器学习模型from sklearn.linear_model import LinearRegressionfrom sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressorfrom sklearn.svm import SVRfrom sklearn.neighbors import KNeighborsRegressor# 超参数调整from sklearn.model_selection import RandomizedSearchCV, GridSearchCV 4.2 导入数据读取前面部分处理好的数据。 1234567891011# 使用数据帧读取数据train_features = pd.read_csv('dataset/training_features.csv')train_labels = pd.read_csv('dataset/training_labels.csv')test_features = pd.read_csv('dataset/testing_features.csv')test_labels = pd.read_csv('dataset/testing_labels.csv')# 数据维度print('Training Feature Size:', train_features.shape)print('Training Labels Size:', train_labels.shape)print('Testing Feature Size:', test_features.shape)print('Testing Labels Size:', test_labels.shape) Training Feature Size: (6622, 64) Training Labels Size: (6622, 1) Testing Feature Size: (2839, 64) Testing Labels Size: (2839, 1) 这是格式化后的数据。 在前文，我们对数值特征进行了对数变换，对两个类别特征进行独热编码，并通过删除高共线特征来选择特征子集。 1train_features.head(12) training_labels包含能源之星分数，这是我们机器学习问题的目标。 能源之星评分是对建筑物能效的比较测量。 这是能源之星分数的分布。 1234567figsize(8, 8)# score的直方图分布plt.hist(train_labels['score'].dropna(), bins = 100);plt.xlabel('Score')plt.ylabel('Number of Building')plt.title('Energy Star Score Distribution') Text(0.5, 1.0, &#39;Energy Star Score Distribution&#39;) 4.3 评估和比较机器学习模型在本节中，我们将为我们的监督回归任务构建、训练及评估几种机器学习方法。 目标是确定哪个模型最有希望进一步开发（例如超参数调整）。 我们使用平均绝对误差作为指标来比较模型。 从3.3节可知随机猜测分数中值的基线模型平均偏离25分。 4.3.1 填充缺失值通常机器学习模型无法处理缺失值，这意味着我们必须找到一种方法来填充或忽略任何缺少值的特征。由于我们在1.4节已经删除了缺失值超过50%的特征，因此我们将重点填充剩下特征的缺失值)。有许多填充方法，但在这里我们将使用相对简单的方法用列的中位数替换缺失值。 （这是关于缺失值填充的更全面的讨论） 在下面的代码中，我们创建一个Scikit-learn Imputer对象，用列的中值填充缺失值。请注意，我们只在训练数据上使用Imputer.fit，但在测试数据集没有使用。然后我们使用Imputer.transform同时处理训练数据集和测试数据集。这意味着测试集中的缺失值用训练集中相应列的中值填充。我们必须现在这么做而不是部署时，我们必须根据训练数据集将测试集的缺失值填充。这是避免数据泄漏问题的一种方法，数据泄露指来自测试集的信息“泄漏”到训练过程中。 123456789# 使用中位数填充策略创建一个imputer对象imputer = Imputer(strategy = 'median')# imputer对象作用于训练集imputer.fit(train_features)# 转换训练数据和测试数据X = imputer.transform(train_features)X_test = imputer.transform(test_features) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\utils\deprecation.py:58: DeprecationWarning: Class Imputer is deprecated; Imputer was deprecated in version 0.20 and will be removed in 0.22. Import impute.SimpleImputer from sklearn instead. warnings.warn(msg, category=DeprecationWarning) 12print('Missing values in training features: ', np.sum(np.isnan(X)))print('Missing values in testing features: ', np.sum(np.isnan(X_test))) Missing values in training features: 0 Missing values in testing features: 0 123# 保证所有数字都是有限值print(np.where(~np.isfinite(X)))print(np.where(~np.isfinite(X_test))) (array([], dtype=int64), array([], dtype=int64)) (array([], dtype=int64), array([], dtype=int64)) 在填充之后，所有特征都是实值的。 对于更复杂的缺失值处理方法（尽管中值通常很有效），请查看本文 4.3.2 特征缩放在我们构建模型之前要采取的最后一步是特征缩放。这是必要的，因为特征之间具有不同的单位度量，我们希望对特征进行标准化，以使单位不影响算法的结果。 线性回归和随机森林不需要特征缩放 但是其他方法（例如支持向量机和kNN）需要进行特征缩放，因为它们考虑了样本之间的欧几里德距离。因此，在比较多个算法时，最佳做法是进行特征缩放。 有两种常用的特征缩放方法： 对于每个值，减去特征的平均值并除以特征的标准偏差。这称为标准化，并且导致每个特征具有0均值和1标准差。 对于每个值，减去特征的最小值并除以最大值减去最小值（范围）。这确保了特征的所有取值都在0和1之间，这称为归一化。 这是一篇关于规范化和标准化的好文章。 与缺失值处理一样，当我们进行特征缩放时，我们只使用训练集计算缩放对象。当我们转换特征时，我们将转换训练集和测试集。 123456789# 创建（0,1）之间的缩放对象scaler = MinMaxScaler(feature_range=(0, 1))# 拟合训练集scaler.fit(X)# 对训练集和测试集进行变换X = scaler.transform(X)X_test = scaler.transform(X_test) 123# 将y转换为一维数组y = np.array(train_labels).reshape((-1, ))y_test = np.array(test_labels).reshape((-1, )) 1y.shape (6622,) 4.4 评估模型我们将使用Scikit-Learn库比较五种不同的机器学习模型： 线性回归 支持向量机回归 随机森林回归 梯度提升回归 K-Nearest Neighbors回归 在本节，我专注于模型实现过程，而不是解释这些模型是如何工作的。除了动手机器学习之外，阅读机器学习模型的另一个重要资源（这是免费的在线）是统计学习简介。 为了比较模型，我们将主要使用模型超参数的Scikit-Learn默认值。通常这些将表现得很好，但应该在实际使用模型之前进行优化。首先，我们只想确定每个模型的基线性能，然后我们可以选择性能最佳的模型，再使用超参数调整进一步优化。请记住，默认的超参数将启动并运行模型，但几乎总是应该使用某种搜索来调整以找到问题的最佳设置！ 以下是Scikit-learn文档中有关默认值的内容： __Sensible defaults__: Whenever an operation requires a user-defined parameter,an appropriate default value is defined by the library. The default value should cause the operation to be performed in a sensible way (giving a baseline solution for the task at hand.) 关于scikit-learn的最大的特点是所有模型都以相同的方式实现：一旦你知道如何构建一个模型，你就可以实现一系列极其多样化的模型。在这里，我们将用几行代码实现多个模型。 123456789101112131415# 计算平均绝对误差的函数def mae(y_true, y_pred): return np.mean(abs(y_true - y_pred))# 模型训练和预测过程，输入任意模型，输出maedef fit_and_evaluate(model): # 训练模型 model.fit(X, y) # 预测和评估 model_pred = model.predict(X_test) model_mae = mae(y_test, model_pred) # 返回误差指标 return model_mae 12345# 线性回归lr = LinearRegression()lr_mae = fit_and_evaluate(lr)print('Linear Regression Performance on the test set: MAE = %0.4f' % lr_mae) Linear Regression Performance on the test set: MAE = 13.4651 12345# 支持向量回归svm = SVR(C = 1000, gamma = 0.1)svm_mae = fit_and_evaluate(svm)print('Support Vector Machine Regression Performance on the test set: MAE = %0.4f' % svm_mae) Support Vector Machine Regression Performance on the test set: MAE = 10.9337 12345# 随机森林random_forest = RandomForestRegressor(random_state=60)random_forest_mae = fit_and_evaluate(random_forest)print('Random Forest Regression Performance on the test set: MAE = %0.4f' % random_forest_mae) C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\ensemble\forest.py:246: FutureWarning: The default value of n_estimators will change from 10 in version 0.20 to 100 in 0.22. &quot;10 in version 0.20 to 100 in 0.22.&quot;, FutureWarning) Random Forest Regression Performance on the test set: MAE = 10.0073 12345# 梯度提升回归gradient_boosted = GradientBoostingRegressor(random_state=60)gradient_boosted_mae = fit_and_evaluate(gradient_boosted)print('Gradient Boosted Regression Performance on the test set: MAE = %0.4f' % gradient_boosted_mae) Gradient Boosted Regression Performance on the test set: MAE = 10.0144 12345# k近邻回归knn = KNeighborsRegressor(n_neighbors=10)knn_mae = fit_and_evaluate(knn)print('K-Nearest Neighbors Regression Performance on the test set: MAE = %0.4f' % knn_mae) K-Nearest Neighbors Regression Performance on the test set: MAE = 13.0131 123456789101112131415161718# 可视化比较不同模型的结果figsize(8, 4)# 保存结果的数据帧model_comparison = pd.DataFrame(&#123;'model': ['Linear Regression', 'Support Vector Machine', 'Random Forest', 'Gradient Boosted', 'K-Nearest Neighbors'], 'mae': [lr_mae, svm_mae, random_forest_mae, gradient_boosted_mae, knn_mae]&#125;)# 直方图model_comparison.sort_values('mae', ascending = False).plot(x = 'model', y = 'mae', kind = 'barh', color = 'red', edgecolor = 'black')plt.ylabel('')plt.yticks(size = 14)plt.xlabel('Mean Absolute Error')plt.xticks(size = 14)plt.title('Model Comparison on Test MAE', size = 20) Text(0.5, 1.0, &#39;Model Comparison on Test MAE&#39;) 根据模型结果比较（每次结果会略有变化），随机森林表现最佳，其次是梯度提升回归。 然而这不是最公平的比较，因为我们主要使用默认的超参数。特别是使用支持向量回归器，超参数对性能有显着影响。 （随机森林和梯度提升方法非常适合开始，因为性能较少依赖于模型设置）。 尽管如此，从这些结果中，我们可以得出结论，机器学习是适用的，因为所有模型都明显优于基线（3.3节25%的mae）！ 接下来，我将专注于使用超参数调整来优化最佳模型。鉴于此处的结果，我将专注于使用Gradient Boosting Regressor。因为Gradient Boosted Trees的Scikit-Learn实现，在过去的几年中赢得了许多Kaggle比赛。 Scikit-Learn版本通常比XGBoost版本慢，但在这里我们将坚持使用Scikit-Learn，因为语法更为熟悉。这是XGBoost包中使用实现的指南。 5 模型优化在机器学习中，优化模型意味着为特定问题找到最佳的超参数集。 5.1 超参数首先，我们需要了解哪些模型超参数与模型参数的对比： 模型超参数被认为是机器学习算法的设置，在训练之前由数据科学家调整。例如，随机森林中的树的数量，或者K Nearest Neighbors Regression中使用的近邻数量。 模型参数是模型在训练期间学习的内容，例如线性回归中的权重。 我们通过选择超参数来控制模型，这些选择会对模型的最终性能产生重大影响（尽管通常不会像获取更多数据或特征工程那么有效）。 调整模型超参数可以控制模型欠拟合与过拟合的平衡。 我们可以尝试通过更复杂的模型来校正欠拟合，例如在随机森林中使用更多树或在深度神经网络中使用更多层。不合适的模型具有高偏差，并且当我们的模型没有足够的容量（自由度）来学习特征和目标之间的关系时发生。 我们可以通过限制模型的复杂性和应用正则化来尝试纠正过拟合。这可能意味着降低多项式回归的阶数，或将dropout 层添加到深度神经网络。过拟合的模型具有高方差并且实际上记忆了训练集。 欠拟合和过拟合都会导致测试集上的泛化性能变差。 选择超参数的问题在于，没有任何超参数可以在所有问题中发挥最佳效果。因此，对于每个新数据集，我们必须找到最佳设置。这可能是一个耗时的过程，但幸运的是，在Scikit-Learn中执行此过程的方法有多种选择。更好的是，新的库，例如epistasis labs的TPOT，旨在自动完成此过程！本项目中，我们将坚持在Scikit-Learn中手动完成，但请继续关注自动模型选择的文章！ 5.2 使用随机搜索和交叉验证进行超参数调整我们可以通过随机搜索和交叉验证为模型选择最佳超参数。 随机搜索是指我们选择超参数来评估模型的方法： 我们定义一系列选项，然后随机选择要尝试的组合。这与网格搜索形成对比，网格搜索评估我们指定的每个组合。 通常，当我们对最佳模型超参数的知识有限时，随机搜索会更好，我们可以使用随机搜索缩小选项范围，然后使用更有限的选项范围进行网格搜索。 交叉验证是用于评估超参数性能的方法： 我们使用K-Fold交叉验证，而不是将数据集拆分为单独训练集的和验证集，以减少我们可以使用的训练数据量。 将训练数据划分为K个部分，然后遍历迭代过程，其中我们首先在K-1个数据集上训练，然后评估在第k个数据集的性能。 重复这个过程K次，所以最终我们将测试训练数据中的每个例子，关键是每次迭代我们都在测试我们没有训练过的数据。 在K折交叉验证结束时，我们将每次K次迭代的平均误差作为最终性能度量，然后在所有训练数据上训练模型。然后，我们记录的性能用于比较超参数的不同组合。 使用k = 5的k折交叉验证图片如下所示： 在这里，我们将使用交叉验证实现随机搜索，以选择梯度梯度回归模型的最佳超参数。 我们首先定义一个网格然后执行迭代过程：从网格中随机抽样一组超参数，使用4折交叉验证评估超参数，然后选择具有最佳性能的超参数。 当然我们实际上并没有自己做这个迭代，我们让Scikit-Learn和RandomizedSearchCV为我们完成这个过程！ 12345678910111213141516171819202122232425# 损失函数 均方差"ls", 绝对损失"lad", Huber损失"huber"loss = ['ls', 'lad', 'huber']# 提升过程使用的树的数量n_estimators = [100, 500, 900, 1100, 1500]# 每棵树的最大深度max_depth = [2, 3, 5, 10, 15]# 每个叶子节点的最少样本min_samples_leaf = [1, 2, 4, 6, 8]# 拆分节点的最小样本数min_samples_split = [2, 4, 6, 10]# 分割时要考虑的最大特征的数量max_features = ['auto', 'sqrt', 'log2', None]# 定义要进行超参数搜索的网络hyperparameter_grid = &#123;'loss': loss, 'n_estimators': n_estimators, 'max_depth': max_depth, 'min_samples_leaf': min_samples_leaf, 'min_samples_split': min_samples_split, 'max_features': max_features&#125; 我们选择了6个不同的超参数来调整GBDT回归。 这些都将以不同的方式影响模型，这些方法很难提前确定，找到特定问题的最佳组合的唯一方法是测试它们！ 要了解超参数，可以查看Scikit-Learn文档。现在，只要知道我们正在努力寻找超参数的最佳组合，并且因为没有理论告诉我们哪种方法效果最好，我们只需要评估它们，就像运行实验一样！ 在下面的代码中，我们创建了随机搜索对象，传递以下参数： estimator: 模型 param_distributions: 我们定义的超参数网络分布 cv ：用于k-fold交叉验证的folds 数量 n_iter: 不同的参数组合的数量 scoring: 评估候选参数时使用的指标 n_jobs: 并行运行时核的数量（-1 时全部使用） verbose: 显示信息的数量（1显示有限信息） return_train_score: 每一个cross-validation fold 返回的分数 random_state: 固定使用的随机数生成器，因此每次运行都会得到相同的结果 随机搜索对象的训练方式与任何scikit-learn模型相同。训练之后，我们可以比较所有不同的超参数组合，找到效果最好的组合。 1234567891011# 建立一个模型用于超参数搜索model = GradientBoostingRegressor(random_state = 42)# 配置具有4折交叉验证的随机搜索random_cv = RandomizedSearchCV(estimator=model, param_distributions=hyperparameter_grid, cv=4, n_iter=25, scoring = 'neg_mean_absolute_error', n_jobs = -1, verbose = 1, return_train_score = True, random_state=42) 12# 拟合训练数据random_cv.fit(X, y) Fitting 4 folds for each of 25 candidates, totalling 100 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 13.5min [Parallel(n_jobs=-1)]: Done 100 out of 100 | elapsed: 21.9min finished RandomizedSearchCV(cv=4, error_score=&#39;raise-deprecating&#39;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;ls&#39;, max_depth=3, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_sampl...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&#39;warn&#39;, n_iter=25, n_jobs=-1, param_distributions={&#39;loss&#39;: [&#39;ls&#39;, &#39;lad&#39;, &#39;huber&#39;], &#39;n_estimators&#39;: [100, 500, 900, 1100, 1500], &#39;max_depth&#39;: [2, 3, 5, 10, 15], &#39;min_samples_leaf&#39;: [1, 2, 4, 6, 8], &#39;min_samples_split&#39;: [2, 4, 6, 10], &#39;max_features&#39;: [&#39;auto&#39;, &#39;sqrt&#39;, &#39;log2&#39;, None]}, pre_dispatch=&#39;2*n_jobs&#39;, random_state=42, refit=True, return_train_score=True, scoring=&#39;neg_mean_absolute_error&#39;, verbose=1) Scikit-learn使用负平均绝对误差进行评估，因为它希望度量最大化。 因此，更好的分数将更接近0.我们可以将随机搜索的结果导入数据帧，并按性能进行排序。 123# 获取cv的结果并按性能排序random_result = pd.DataFrame(random_cv.cv_results_).sort_values('mean_test_score', ascending = False)random_result.head(10) 1random_cv.best_estimator_ GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=500, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 最佳梯度增强模型具有以下超参数: loss = lad n_estimators = 500 max_depth = 5 min_samples_leaf = 6 min_samples_split = 6 max_features = None (这意味着最大特征数量等于数据集中特征的数量) 使用随机搜索是缩小可能的超参数的好方法。最初，我们不知道哪种组合效果最好，但这至少缩小了选项的范围。 我们可以使用随机搜索结果来通过创建具有超参数的网格来通知网格搜索，这些参数接近于在随机搜索期间最有效的参数。接下来将重点放在单个树中的树数量（n_estimators）。通过仅改变一个超参数，我们可以直接观察它如何影响性能。在这种情况情况下，我们预计会看到对过拟合的影响。 在这里，我们将使用网格搜索，网格只有n_estimators超参数。我们将评估树的个数，然后绘制训练和测试性能，以了解增加树数量对模型的影响。我们将其他超参数固定为从随机搜索返回的最佳值，以直接查看树的数量对模型的影响。 12345678910111213# 创建一系列树的数量trees_grid = &#123;'n_estimators': [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]&#125;model = GradientBoostingRegressor(loss = 'lad', max_depth = 5, min_samples_leaf = 6, min_samples_split = 6, max_features = None, random_state = 42)# 对树的数量进行网络搜索grid_search = GridSearchCV(estimator = model, param_grid=trees_grid, cv = 4, scoring = 'neg_mean_absolute_error', verbose = 1, n_jobs = -1, return_train_score = True) 12# 拟合训练数据grid_search.fit(X, y) Fitting 4 folds for each of 15 candidates, totalling 60 fits [Parallel(n_jobs=-1)]: Using backend LokyBackend with 4 concurrent workers. [Parallel(n_jobs=-1)]: Done 42 tasks | elapsed: 3.4min [Parallel(n_jobs=-1)]: Done 60 out of 60 | elapsed: 6.2min finished GridSearchCV(cv=4, error_score=&#39;raise-deprecating&#39;, estimator=GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samp...te=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False), fit_params=None, iid=&#39;warn&#39;, n_jobs=-1, param_grid={&#39;n_estimators&#39;: [100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800]}, pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=True, scoring=&#39;neg_mean_absolute_error&#39;, verbose=1) 123456789101112# 获取结果results = pd.DataFrame(grid_search.cv_results_)# 绘制不同树的数量的训练和测试误差figsize(8, 8)plt.style.use('fivethirtyeight')plt.plot(results['param_n_estimators'], -1 * results['mean_test_score'], label = 'Testing Error')plt.plot(results['param_n_estimators'], -1 * results['mean_train_score'], label = 'Training Error')plt.xlabel('Number of Trees')plt.ylabel('Mean Abosolute Error')plt.legend();plt.title('Performance vs Number of Trees') Text(0.5, 1.0, &#39;Performance vs Number of Trees&#39;) 1results.sort_values('mean_test_score', ascending = False).head() 从上图来看，很明显我们的模型过拟合了！训练误差明显低于测试误差，这表明模型正在很好地学习训练数据，但是无法泛化到测试数据。随着树数量的增加，对训练集的拟合效果变好，测试和训练误差都会减少，但训练误差会更快地减少。 训练误差和测试误差之间始终存在显著的差异（训练误差始终较低），我们希望通过获取更多训练数据或降低模型的复杂性来尝试降低过拟合，例如可以进行超参数调整或正则化。对于GDBT回归，可以减少树的数量，减少每棵树的最大深度，以及增加叶节点中的最小样本数。对于任何想要进一步了解GDBT回归的人来说，这是一篇很棒的文章。目前，我们将使用具有最佳性能的模型，并接受它可能对训练集过拟合的事实。 根据交叉验证结果，使用800棵树的最佳模型的交叉验证误差在9以下。这表明Energy Star Score能源之星分数的平均交叉验证估计在真实答案的9分之内，即使模型过拟合了，但仍然是一个不错的结果。 6 使用最佳模型评估测试集我们将使用超参数调整中的最佳模型来对测试集进行预测。 请记住，我们的模型以前从未见过测试集，所以这个性能应该是模型在现实世界中部署时的表现的一个很好的指标。 为了比较，我们还可以查看使用默认参数的模型的性能并和最佳模型进行比较。 下面的代码创建最终模型，训练它（带有时间），并评估测试集。 1234567# 默认模型default_model = GradientBoostingRegressor(random_state = 42)# 选择最优模型final_model = grid_search.best_estimator_final_model GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 12%%timeit -n 1 -r 5default_model.fit(X, y) 1.36 s ± 117 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12%%timeit -n 1 -r 5final_model.fit(X, y) 18.6 s ± 471 ms per loop (mean ± std. dev. of 5 runs, 1 loop each) 12345default_pred = default_model.predict(X_test)final_pred = final_model.predict(X_test)print('Default model performance on the test set: MAE = %0.4f.' % mae(y_test, default_pred))print('Final model performance on the test set: MAE = %0.4f.' % mae(y_test, final_pred)) Default model performance on the test set: MAE = 10.0130. Final model performance on the test set: MAE = 9.0453. 最终的模型比基线模型的性能提高了大约10％，但代价是显著增加了运行时间。 机器学习通常是一个需要权衡的领域： 偏差与方差 准确性与可解释性 准确性与运行时间 以及使用哪种模型 最终决定取决于具体情况。 这里，运行时间的增加不是障碍，因为虽然相对差异很大，但训练时间的绝对量值并不显着。 在不同的情况下，权衡可能不一样，因此我们需要考虑我们正在优化的内容以及我们必须使用的限制。 为直观地了解预测效果，我们可以绘制下面两个值的分布：测试集上的真实值和最终模型的预测值 123456789figsize(8, 8)# 测试集上的真实值和预测值的密度图sns.kdeplot(final_pred, label = 'Predictions')sns.kdeplot(y_test, label = 'True Values')plt.xlabel('Energy Star Score')plt.ylabel('Density')plt.title('Test Values and Predictions') C:\Users\huangqiancun\Anaconda3\lib\site-packages\scipy\stats\stats.py:1713: FutureWarning: Using a non-tuple sequence for multidimensional indexing is deprecated; use `arr[tuple(seq)]` instead of `arr[seq]`. In the future this will be interpreted as an array index, `arr[np.array(seq)]`, which will result either in an error or a different result. return np.add.reduce(sorted[indexer] * weights, axis=axis) / sumval Text(0.5, 1.0, &#39;Test Values and Predictions&#39;) 虽然预测值的密度更接近测试值的中值而不是100的实际峰值，但分布看起来几乎相同。看来模型在预测极值时可能不太准确 而是预测值更接近中位数。 接下来，我们画一下预测值与真实值残差的直方图。 理想情况下，我们希望残差是正态分布的，这意味着模型在两个方向（高和低）上都是预测误差情况是一样的。 1234567891011figsize(6, 6)# 计算残差residuals = final_pred - y_test# 残差的直方图plt.hist(residuals, color = 'red', bins = 20, edgecolor = 'black')plt.xlabel('Error')plt.ylabel('Count')plt.title('Distribution of Residuals') Text(0.5, 1.0, &#39;Distribution of Residuals&#39;) 残差接近正态分布，低端有一些明显的异常值。 这些表明模型估计远低于真实值。 6.1 小结以上我们完成了机器学习的4到6三个步骤： 建立baseline并根据性能指标比较多个机器学习模型 对最佳模型执行超参数调整，以针对该问题进行优化 使用最佳模型评估测试集 结果表明机器学习适用于我们的问题，最终模型能够将建筑物的能源之星分数预测到9.1分以内（尽管存在过拟合现象）。我们还看到： 超参数调整能够略微改善模型的性能，但同时会消耗大量的时间。这表明，正确的特征工程和收集更多数据（如果可能！）比微调模型有更大的回报。我们还观察了运行时间与精度之间的权衡，这是我们在设计机器学习模型时必须考虑的众多因素之一。 我们知道我们的模型是准确的，但是我们需要知道为什么它能做出正确预测！机器学习过程的下一步至关重要：尝试理解模型如何进行预测，即尽可能地解释模型结果。实现高精度是很好的，但如果我们能够找出模型能够准确预测的原因，那么我们也可以使用这些信息来更好地理解问题。例如，模型依靠什么特征来推断能源之星分数？可以使用此模型进行特征选择，并实现更易于解释的更简单模型吗？ 在接下来的部分，我们将尝试回答这些问题并从项目中得出最终结论！ 7 解释模型本节，我们将查看我们构建的黑盒子模型。我们知道这是准确的，因为它可以预测能源之星分数在真实值的相对误差在9分之内，但它究竟是如何做出预测的呢？ 我们将研究一些尝试理解GBDT回归然后得出结论。 123456# 引入树模型from sklearn import tree# LIME 用于解释预测import lime import lime.lime_tabular 7.1 重新构建最终模型123456# 使用超参数搜索的结果重构模型model = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)model.fit(X, y) GradientBoostingRegressor(alpha=0.9, criterion=&#39;friedman_mse&#39;, init=None, learning_rate=0.1, loss=&#39;lad&#39;, max_depth=5, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=6, min_samples_split=6, min_weight_fraction_leaf=0.0, n_estimators=800, n_iter_no_change=None, presort=&#39;auto&#39;, random_state=42, subsample=1.0, tol=0.0001, validation_fraction=0.1, verbose=0, warm_start=False) 1234# 在测试集上做预测model_pred = model.predict(X_test)print('Final Model Performance on the test set: MAE = %0.4f' % mae(y_test, model_pred)) Final Model Performance on the test set: MAE = 9.0453 7.2 解释模型机器学习经常被批评为一个黑盒子： 我们把数据丢进去，它给了我们预测答案。 虽然这些答案通常非常准确，但该模型并未告诉我们它是如何实际做出预测的。 这在某种程度上是正确的，但我们可以通过多种方式尝试并发现模型如何“思考”，例如局部可理解的与模型无关的解释器(Locally Interpretable Model-agnostic Explainer, LIME)。 这种方法试图通过学习围绕预测的线性回归来解释模型预测，这是一个易于解释的模型！ 我们将探索几种解释模型的方法： 特征重要性 局部可理解的与模型无关的解释器（LIME） 检查整体中的单个决策树 7.2 特征重要性我们可以解释决策树集成的基本方法之一是通过特征重要性。 这些可以解释为最能预测目标的特征。 虽然特征重要性的实际细节非常复杂(这里是相关讨论)，我们可以使用相对值来比较特征并确定哪些与我们的问题最相关。 在scikit-learn中，从经过训练的树集成中提取特征重要性非常容易。 我们将特征重要性存储在数据帧中以分析和可视化它们。 12345678# 提取特征重要性，保存到数据帧中feature_results = pd.DataFrame(&#123;'feature': list(train_features.columns), 'importance': model.feature_importances_&#125;)# 显示最重要的10个特征feature_results = feature_results.sort_values('importance', ascending = False).reset_index(drop=True)feature_results.head(10) Site EUI (kBtu/ft²) 和Weather Normalized Site Electricity Intensity (kWh/ft²)是两个相对最重要的两个特征。之后，相对重要性大幅下降，这表明我们可能不需要保留所有特征来创建具有几乎相同性能的模型。 让我们可视化特征重要性。 12345678figsize(12, 10)# 将最重要的10个特征画成直方图feature_results.loc[:9, :].plot(x = 'feature', y = 'importance', edgecolor = 'k', kind = 'barh', color = 'blue')plt.xlabel('Relative Importance', size = 20)plt.ylabel('')plt.title('Feature Importance from Random Forest', size = 30) Text(0.5, 1.0, &#39;Feature Importance from Random Forest&#39;) 利用特征重要性进行特征选择: 鉴于并非每个特征对于影响分数都很重要，如果我们将随机森林中最重要特征的子集用于更简单的模型（如线性回归），会发生什么？ 线性回归确实优于基线，但与模型复杂模型相比表现不佳。 让我们尝试仅在线性回归中的使用10个最重要的特征来查看性能是否得到改善。 我们还可以限制这些功能并重新评估随机森林。 123456789101112# 提取重要的10个特征名称most_important_features = feature_results['feature'][:10]# 寻找对应特征的indexindices = [list(train_features.columns).index(x) for x in most_important_features]# 仅保留最重要的10个特征X_reduced = X[:, indices]X_test_reduced = X_test[:, indices]print('Most important training features shape: ', X_reduced.shape)print('Most important testing features shape: ', X_test_reduced.shape) Most important training features shape: (6622, 10) Most important testing features shape: (2839, 10) 12345678910111213lr = LinearRegression()# 拟合所有特征lr.fit(X, y)lr_full_pred = lr.predict(X_test)# 仅拟合最重要的10个特征lr.fit(X_reduced, y)lr_reduced_pred = lr.predict(X_test_reduced)# 结果对比print('Linear Regression Full Results: MAE = %0.4f.' % mae(y_test, lr_full_pred))print('Linear Regression Reduced Results: MAE = %0.4f.' % mae(y_test, lr_reduced_pred)) Linear Regression Full Results: MAE = 13.4651. Linear Regression Reduced Results: MAE = 14.4016. 可以看到，减少特征并没有改善线性回归结果！ 事实证明，低重要性特征中的额外信息确实可以提高性能。 让我们再看看在梯度提升回归中使用减少的特征集。 性能如何受到影响？ 12345678910# 使用一样的超参数建立梯度提升模型model_reduced = GradientBoostingRegressor(loss='lad', max_depth=5, max_features=None, min_samples_leaf=6, min_samples_split=6, n_estimators=800, random_state=42)# 拟合并预测model_reduced.fit(X_reduced, y)model_reduced_pred = model_reduced.predict(X_test_reduced)print('Gradient Boosted Reduced Results: MAE = %0.4f' % mae(y_test, model_reduced_pred)) Gradient Boosted Reduced Results: MAE = 9.5251 随着特征的减少，模型结果略差，我们将为最终模型保留所有特征。 减少特征数量是因为我们总是希望构建最简约的模型： 即具有足够性能的最简单模型。 使用较少特征的模型将更快地训练并且通常更容易解释。 在这种情况下，保留所有特征并不是主要问题，因为训练时间在本项目中并不重要，我们仍然可以使用许多特征进行解释。 7.3 局部可理解的与模型无关的解释器（LIME）我们将使用LIME来解释模型所做的个别预测。 LIME是一项相对较新的工作，旨在通过用线性模型近似一个预测周围的区域来展示机器学习模型的思考方式。 我们将试图解释模型在两个例子上得到的预测结果：其中一个例子得到的预测结果非常差，另一个例子得到的预测结果非常好。 我们将限制使用的10个最重要的特征来帮助解释。 虽然在10个最重要的特征上训练的模型稍微不准确，但我们通常必须权衡可解释性的准确性！ 123456# 计算残差residuals = abs(model_reduced_pred - y_test)# 提取最差和最好的预测wrong = X_test_reduced[np.argmax(residuals), :]right = X_test_reduced[np.argmin(residuals), :] 12345# 创建lime解释器explainer = lime.lime_tabular.LimeTabularExplainer(training_data = X_reduced, mode = 'regression', training_labels = y, feature_names = list(most_important_features)) 1234567891011# 为错误示例显示预测值和真实值print('Prediction: %0.4f' % model_reduced.predict(wrong.reshape(1, -1)))print('Actual Value: %0.4f' % y_test[np.argmax(residuals)])# 解释错误预测wrong_exp = explainer.explain_instance(data_row = wrong, predict_fn = model_reduced.predict)# 绘制预测解释wrong_exp.as_pyplot_figure()plt.title('Explanation of Prediction', size = 28);plt.xlabel('Effect on Prediction', size = 22); Prediction: 14.1601 Actual Value: 96.0000 C:\Users\huangqiancun\Anaconda3\lib\site-packages\sklearn\linear_model\ridge.py:125: LinAlgWarning: scipy.linalg.solve Ill-conditioned matrix detected. Result is not guaranteed to be accurate. Reciprocal condition number3.113013e-27 overwrite_a=True).T 1wrong_exp.show_in_notebook(show_predicted_value=False) var lime = /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = ""; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); exports.PredictedValue = exports.PredictProba = exports.Barchart = exports.Explanation = undefined; var _explanation = __webpack_require__(1); var _explanation2 = _interopRequireDefault(_explanation); var _bar_chart = __webpack_require__(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _predict_proba = __webpack_require__(6); var _predict_proba2 = _interopRequireDefault(_predict_proba); var _predicted_value = __webpack_require__(7); var _predicted_value2 = _interopRequireDefault(_predicted_value); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } if (!global._babelPolyfill) { __webpack_require__(8); } __webpack_require__(339); exports.Explanation = _explanation2.default; exports.Barchart = _bar_chart2.default; exports.PredictProba = _predict_proba2.default; exports.PredictedValue = _predicted_value2.default; //require('style-loader'); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _bar_chart = __webpack_require__(3); var _bar_chart2 = _interopRequireDefault(_bar_chart); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var Explanation = function () { function Explanation(class_names) { _classCallCheck(this, Explanation); this.names = class_names; if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } } // exp: [(feature-name, weight), ...] // label: int // div: d3 selection Explanation.prototype.show = function show(exp, label, div) { var svg = div.append('svg').style('width', '100%'); var colors = ['#5F9EA0', this.colors_i(label)]; var names = ['NOT ' + this.names[label], this.names[label]]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; names = this.names; } var plot = new _bar_chart2.default(svg, exp, true, names, colors, true, 10); svg.style('height', plot.svg_height + 'px'); }; // exp has all ocurrences of words, with start index and weight: // exp = [('word', 132, -0.13), ('word3', 111, 1.3) Explanation.prototype.show_raw_text = function show_raw_text(exp, label, raw, div) { var opacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true; //let colors=['#5F9EA0', this.colors(this.exp['class'])]; var colors = ['#5F9EA0', this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var word_lists = [[], []]; var max_weight = -1; var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = exp[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var _step$value = _slicedToArray(_step.value, 3), word = _step$value[0], start = _step$value[1], weight = _step$value[2]; if (weight > 0) { word_lists[1].push([start, start + word.length, weight]); } else { word_lists[0].push([start, start + word.length, -weight]); } max_weight = Math.max(max_weight, Math.abs(weight)); } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } if (!opacity) { max_weight = 0; } this.display_raw_text(div, raw, word_lists, colors, max_weight, true); }; // exp is list of (feature_name, value, weight) Explanation.prototype.show_raw_tabular = function show_raw_tabular(exp, label, div) { div.classed('lime', true).classed('table_div', true); var colors = ['#5F9EA0', this.colors_i(label)]; if (this.names.length == 2) { colors = [this.colors_i(0), this.colors_i(1)]; } var table = div.append('table'); var thead = table.append('tr'); thead.append('td').text('Feature'); thead.append('td').text('Value'); thead.style('color', 'black').style('font-size', '20px'); var _iteratorNormalCompletion2 = true; var _didIteratorError2 = false; var _iteratorError2 = undefined; try { for (var _iterator2 = exp[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) { var _step2$value = _slicedToArray(_step2.value, 3), fname = _step2$value[0], value = _step2$value[1], weight = _step2$value[2]; var tr = table.append('tr'); tr.style('border-style', 'hidden'); tr.append('td').text(fname); tr.append('td').text(value); if (weight > 0) { tr.style('background-color', colors[1]); } else if (weight < 0) { tr.style('background-color', colors[0]); } else { tr.style('color', 'black'); } } } catch (err) { _didIteratorError2 = true; _iteratorError2 = err; } finally { try { if (!_iteratorNormalCompletion2 && _iterator2.return) { _iterator2.return(); } } finally { if (_didIteratorError2) { throw _iteratorError2; } } } }; Explanation.prototype.hexToRgb = function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }; Explanation.prototype.applyAlpha = function applyAlpha(hex, alpha) { var components = this.hexToRgb(hex); return 'rgba(' + components.r + "," + components.g + "," + components.b + "," + alpha.toFixed(3) + ")"; }; // sord_lists is an array of arrays, of length (colors). if with_positions is true, // word_lists is an array of [start,end] positions instead Explanation.prototype.display_raw_text = function display_raw_text(div, raw_text) { var word_lists = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : []; var colors = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; var max_weight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1; var positions = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; div.classed('lime', true).classed('text_div', true); div.append('h3').text('Text with highlighted words'); var highlight_tag = 'span'; var text_span = div.append('span').style('white-space', 'pre-wrap').text(raw_text); var position_lists = word_lists; if (!positions) { position_lists = this.wordlists_to_positions(word_lists, raw_text); } var objects = []; var _iteratorNormalCompletion3 = true; var _didIteratorError3 = false; var _iteratorError3 = undefined; try { var _loop = function _loop() { var i = _step3.value; position_lists[i].map(function (x) { return objects.push({ 'label': i, 'start': x[0], 'end': x[1], 'alpha': max_weight === 0 ? 1 : x[2] / max_weight }); }); }; for (var _iterator3 = (0, _lodash.range)(position_lists.length)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) { _loop(); } } catch (err) { _didIteratorError3 = true; _iteratorError3 = err; } finally { try { if (!_iteratorNormalCompletion3 && _iterator3.return) { _iterator3.return(); } } finally { if (_didIteratorError3) { throw _iteratorError3; } } } objects = (0, _lodash.sortBy)(objects, function (x) { return x['start']; }); var node = text_span.node().childNodes[0]; var subtract = 0; var _iteratorNormalCompletion4 = true; var _didIteratorError4 = false; var _iteratorError4 = undefined; try { for (var _iterator4 = objects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) { var obj = _step4.value; var word = raw_text.slice(obj.start, obj.end); var start = obj.start - subtract; var end = obj.end - subtract; var match = document.createElement(highlight_tag); match.appendChild(document.createTextNode(word)); match.style.backgroundColor = this.applyAlpha(colors[obj.label], obj.alpha); var after = node.splitText(start); after.nodeValue = after.nodeValue.substring(word.length); node.parentNode.insertBefore(match, after); subtract += end; node = after; } } catch (err) { _didIteratorError4 = true; _iteratorError4 = err; } finally { try { if (!_iteratorNormalCompletion4 && _iterator4.return) { _iterator4.return(); } } finally { if (_didIteratorError4) { throw _iteratorError4; } } } }; Explanation.prototype.wordlists_to_positions = function wordlists_to_positions(word_lists, raw_text) { var ret = []; var _iteratorNormalCompletion5 = true; var _didIteratorError5 = false; var _iteratorError5 = undefined; try { for (var _iterator5 = word_lists[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) { var words = _step5.value; if (words.length === 0) { ret.push([]); continue; } var re = new RegExp("\\b(" + words.join('|') + ")\\b", 'gm'); var temp = void 0; var list = []; while ((temp = re.exec(raw_text)) !== null) { list.push([temp.index, temp.index + temp[0].length]); } ret.push(list); } } catch (err) { _didIteratorError5 = true; _iteratorError5 = err; } finally { try { if (!_iteratorNormalCompletion5 && _iterator5.return) { _iterator5.return(); } } finally { if (_didIteratorError5) { throw _iteratorError5; } } } return ret; }; return Explanation; }(); exports.default = Explanation; /***/ }), /* 2 */ /***/ (function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() { var d3 = { version: "3.5.17" }; var d3_arraySlice = [].slice, d3_array = function(list) { return d3_arraySlice.call(list); }; var d3_document = this.document; function d3_documentElement(node) { return node && (node.ownerDocument || node.document || node).documentElement; } function d3_window(node) { return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView); } if (d3_document) { try { d3_array(d3_document.documentElement.childNodes)[0].nodeType; } catch (e) { d3_array = function(list) { var i = list.length, array = new Array(i); while (i--) array[i] = list[i]; return array; }; } } if (!Date.now) Date.now = function() { return +new Date(); }; if (d3_document) { try { d3_document.createElement("DIV").style.setProperty("opacity", 0, ""); } catch (error) { var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty; d3_element_prototype.setAttribute = function(name, value) { d3_element_setAttribute.call(this, name, value + ""); }; d3_element_prototype.setAttributeNS = function(space, local, value) { d3_element_setAttributeNS.call(this, space, local, value + ""); }; d3_style_prototype.setProperty = function(name, value, priority) { d3_style_setProperty.call(this, name, value + "", priority); }; } } d3.ascending = d3_ascending; function d3_ascending(a, b) { return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN; } d3.descending = function(a, b) { return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN; }; d3.min = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; } while (++i < n) if ((b = array[i]) != null && a > b) a = b; } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b; } return a; }; d3.max = function(array, f) { var i = -1, n = array.length, a, b; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; } while (++i < n) if ((b = array[i]) != null && b > a) a = b; } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b; } return a; }; d3.extent = function(array, f) { var i = -1, n = array.length, a, b, c; if (arguments.length === 1) { while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; } while (++i < n) if ((b = array[i]) != null) { if (a > b) a = b; if (c < b) c = b; } } else { while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) { a = c = b; break; } while (++i < n) if ((b = f.call(array, array[i], i)) != null) { if (a > b) a = b; if (c < b) c = b; } } return [ a, c ]; }; function d3_number(x) { return x === null ? NaN : +x; } function d3_numeric(x) { return !isNaN(x); } d3.sum = function(array, f) { var s = 0, n = array.length, a, i = -1; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = +array[i])) s += a; } else { while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a; } return s; }; d3.mean = function(array, f) { var s = 0, n = array.length, a, i = -1, j = n; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j; } else { while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j; } if (j) return s / j; }; d3.quantile = function(values, p) { var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h; return e ? v + e * (values[h] - v) : v; }; d3.median = function(array, f) { var numbers = [], n = array.length, a, i = -1; if (arguments.length === 1) { while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a); } else { while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a); } if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5); }; d3.variance = function(array, f) { var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0; if (arguments.length === 1) { while (++i < n) { if (d3_numeric(a = d3_number(array[i]))) { d = a - m; m += d / ++j; s += d * (a - m); } } } else { while (++i < n) { if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) { d = a - m; m += d / ++j; s += d * (a - m); } } } if (j > 1) return s / (j - 1); }; d3.deviation = function() { var v = d3.variance.apply(this, arguments); return v ? Math.sqrt(v) : v; }; function d3_bisector(compare) { return { left: function(a, x, lo, hi) { if (arguments.length < 3) lo = 0; if (arguments.length < 4) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid; } return lo; }, right: function(a, x, lo, hi) { if (arguments.length < 3) lo = 0; if (arguments.length < 4) hi = a.length; while (lo < hi) { var mid = lo + hi >>> 1; if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1; } return lo; } }; } var d3_bisect = d3_bisector(d3_ascending); d3.bisectLeft = d3_bisect.left; d3.bisect = d3.bisectRight = d3_bisect.right; d3.bisector = function(f) { return d3_bisector(f.length === 1 ? function(d, x) { return d3_ascending(f(d), x); } : f); }; d3.shuffle = function(array, i0, i1) { if ((m = arguments.length) < 3) { i1 = array.length; if (m < 2) i0 = 0; } var m = i1 - i0, t, i; while (m) { i = Math.random() * m-- | 0; t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t; } return array; }; d3.permute = function(array, indexes) { var i = indexes.length, permutes = new Array(i); while (i--) permutes[i] = array[indexes[i]]; return permutes; }; d3.pairs = function(array) { var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n); while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ]; return pairs; }; d3.transpose = function(matrix) { if (!(n = matrix.length)) return []; for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) { for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) { row[j] = matrix[j][i]; } } return transpose; }; function d3_transposeLength(d) { return d.length; } d3.zip = function() { return d3.transpose(arguments); }; d3.keys = function(map) { var keys = []; for (var key in map) keys.push(key); return keys; }; d3.values = function(map) { var values = []; for (var key in map) values.push(map[key]); return values; }; d3.entries = function(map) { var entries = []; for (var key in map) entries.push({ key: key, value: map[key] }); return entries; }; d3.merge = function(arrays) { var n = arrays.length, m, i = -1, j = 0, merged, array; while (++i < n) j += arrays[i].length; merged = new Array(j); while (--n >= 0) { array = arrays[n]; m = array.length; while (--m >= 0) { merged[--j] = array[m]; } } return merged; }; var abs = Math.abs; d3.range = function(start, stop, step) { if (arguments.length < 3) { step = 1; if (arguments.length < 2) { stop = start; start = 0; } } if ((stop - start) / step === Infinity) throw new Error("infinite range"); var range = [], k = d3_range_integerScale(abs(step)), i = -1, j; start *= k, stop *= k, step *= k; if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k); return range; }; function d3_range_integerScale(x) { var k = 1; while (x * k % 1) k *= 10; return k; } function d3_class(ctor, properties) { for (var key in properties) { Object.defineProperty(ctor.prototype, key, { value: properties[key], enumerable: false }); } } d3.map = function(object, f) { var map = new d3_Map(); if (object instanceof d3_Map) { object.forEach(function(key, value) { map.set(key, value); }); } else if (Array.isArray(object)) { var i = -1, n = object.length, o; if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o); } else { for (var key in object) map.set(key, object[key]); } return map; }; function d3_Map() { this._ = Object.create(null); } var d3_map_proto = "__proto__", d3_map_zero = "\x00"; d3_class(d3_Map, { has: d3_map_has, get: function(key) { return this._[d3_map_escape(key)]; }, set: function(key, value) { return this._[d3_map_escape(key)] = value; }, remove: d3_map_remove, keys: d3_map_keys, values: function() { var values = []; for (var key in this._) values.push(this._[key]); return values; }, entries: function() { var entries = []; for (var key in this._) entries.push({ key: d3_map_unescape(key), value: this._[key] }); return entries; }, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]); } }); function d3_map_escape(key) { return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key; } function d3_map_unescape(key) { return (key += "")[0] === d3_map_zero ? key.slice(1) : key; } function d3_map_has(key) { return d3_map_escape(key) in this._; } function d3_map_remove(key) { return (key = d3_map_escape(key)) in this._ && delete this._[key]; } function d3_map_keys() { var keys = []; for (var key in this._) keys.push(d3_map_unescape(key)); return keys; } function d3_map_size() { var size = 0; for (var key in this._) ++size; return size; } function d3_map_empty() { for (var key in this._) return false; return true; } d3.nest = function() { var nest = {}, keys = [], sortKeys = [], sortValues, rollup; function map(mapType, array, depth) { if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array; var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values; while (++i < n) { if (values = valuesByKey.get(keyValue = key(object = array[i]))) { values.push(object); } else { valuesByKey.set(keyValue, [ object ]); } } if (mapType) { object = mapType(); setter = function(keyValue, values) { object.set(keyValue, map(mapType, values, depth)); }; } else { object = {}; setter = function(keyValue, values) { object[keyValue] = map(mapType, values, depth); }; } valuesByKey.forEach(setter); return object; } function entries(map, depth) { if (depth >= keys.length) return map; var array = [], sortKey = sortKeys[depth++]; map.forEach(function(key, keyMap) { array.push({ key: key, values: entries(keyMap, depth) }); }); return sortKey ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array; } nest.map = function(array, mapType) { return map(mapType, array, 0); }; nest.entries = function(array) { return entries(map(d3.map, array, 0), 0); }; nest.key = function(d) { keys.push(d); return nest; }; nest.sortKeys = function(order) { sortKeys[keys.length - 1] = order; return nest; }; nest.sortValues = function(order) { sortValues = order; return nest; }; nest.rollup = function(f) { rollup = f; return nest; }; return nest; }; d3.set = function(array) { var set = new d3_Set(); if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]); return set; }; function d3_Set() { this._ = Object.create(null); } d3_class(d3_Set, { has: d3_map_has, add: function(key) { this._[d3_map_escape(key += "")] = true; return key; }, remove: d3_map_remove, values: d3_map_keys, size: d3_map_size, empty: d3_map_empty, forEach: function(f) { for (var key in this._) f.call(this, d3_map_unescape(key)); } }); d3.behavior = {}; function d3_identity(d) { return d; } d3.rebind = function(target, source) { var i = 1, n = arguments.length, method; while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]); return target; }; function d3_rebind(target, source, method) { return function() { var value = method.apply(source, arguments); return value === source ? target : value; }; } function d3_vendorSymbol(object, name) { if (name in object) return name; name = name.charAt(0).toUpperCase() + name.slice(1); for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) { var prefixName = d3_vendorPrefixes[i] + name; if (prefixName in object) return prefixName; } } var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ]; function d3_noop() {} d3.dispatch = function() { var dispatch = new d3_dispatch(), i = -1, n = arguments.length; while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); return dispatch; }; function d3_dispatch() {} d3_dispatch.prototype.on = function(type, listener) { var i = type.indexOf("."), name = ""; if (i >= 0) { name = type.slice(i + 1); type = type.slice(0, i); } if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener); if (arguments.length === 2) { if (listener == null) for (type in this) { if (this.hasOwnProperty(type)) this[type].on(name, null); } return this; } }; function d3_dispatch_event(dispatch) { var listeners = [], listenerByName = new d3_Map(); function event() { var z = listeners, i = -1, n = z.length, l; while (++i < n) if (l = z[i].on) l.apply(this, arguments); return dispatch; } event.on = function(name, listener) { var l = listenerByName.get(name), i; if (arguments.length < 2) return l && l.on; if (l) { l.on = null; listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1)); listenerByName.remove(name); } if (listener) listeners.push(listenerByName.set(name, { on: listener })); return dispatch; }; return event; } d3.event = null; function d3_eventPreventDefault() { d3.event.preventDefault(); } function d3_eventSource() { var e = d3.event, s; while (s = e.sourceEvent) e = s; return e; } function d3_eventDispatch(target) { var dispatch = new d3_dispatch(), i = 0, n = arguments.length; while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch); dispatch.of = function(thiz, argumentz) { return function(e1) { try { var e0 = e1.sourceEvent = d3.event; e1.target = target; d3.event = e1; dispatch[e1.type].apply(thiz, argumentz); } finally { d3.event = e0; } }; }; return dispatch; } d3.requote = function(s) { return s.replace(d3_requote_re, "\\$&"); }; var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g; var d3_subclass = {}.__proto__ ? function(object, prototype) { object.__proto__ = prototype; } : function(object, prototype) { for (var property in prototype) object[property] = prototype[property]; }; function d3_selection(groups) { d3_subclass(groups, d3_selectionPrototype); return groups; } var d3_select = function(s, n) { return n.querySelector(s); }, d3_selectAll = function(s, n) { return n.querySelectorAll(s); }, d3_selectMatches = function(n, s) { var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")]; d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); }; return d3_selectMatches(n, s); }; if (typeof Sizzle === "function") { d3_select = function(s, n) { return Sizzle(s, n)[0] || null; }; d3_selectAll = Sizzle; d3_selectMatches = Sizzle.matchesSelector; } d3.selection = function() { return d3.select(d3_document.documentElement); }; var d3_selectionPrototype = d3.selection.prototype = []; d3_selectionPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, group, node; selector = d3_selection_selector(selector); for (var j = -1, m = this.length; ++j < m; ) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroup.push(subnode = selector.call(node, node.__data__, i, j)); if (subnode && "__data__" in node) subnode.__data__ = node.__data__; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; function d3_selection_selector(selector) { return typeof selector === "function" ? selector : function() { return d3_select(selector, this); }; } d3_selectionPrototype.selectAll = function(selector) { var subgroups = [], subgroup, node; selector = d3_selection_selectorAll(selector); for (var j = -1, m = this.length; ++j < m; ) { for (var group = this[j], i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j))); subgroup.parentNode = node; } } } return d3_selection(subgroups); }; function d3_selection_selectorAll(selector) { return typeof selector === "function" ? selector : function() { return d3_selectAll(selector, this); }; } var d3_nsXhtml = "http://www.w3.org/1999/xhtml"; var d3_nsPrefix = { svg: "http://www.w3.org/2000/svg", xhtml: d3_nsXhtml, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }; d3.ns = { prefix: d3_nsPrefix, qualify: function(name) { var i = name.indexOf(":"), prefix = name; if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1); return d3_nsPrefix.hasOwnProperty(prefix) ? { space: d3_nsPrefix[prefix], local: name } : name; } }; d3_selectionPrototype.attr = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") { var node = this.node(); name = d3.ns.qualify(name); return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name); } for (value in name) this.each(d3_selection_attr(value, name[value])); return this; } return this.each(d3_selection_attr(name, value)); }; function d3_selection_attr(name, value) { name = d3.ns.qualify(name); function attrNull() { this.removeAttribute(name); } function attrNullNS() { this.removeAttributeNS(name.space, name.local); } function attrConstant() { this.setAttribute(name, value); } function attrConstantNS() { this.setAttributeNS(name.space, name.local, value); } function attrFunction() { var x = value.apply(this, arguments); if (x == null) this.removeAttribute(name); else this.setAttribute(name, x); } function attrFunctionNS() { var x = value.apply(this, arguments); if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x); } return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant; } function d3_collapse(s) { return s.trim().replace(/\s+/g, " "); } d3_selectionPrototype.classed = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") { var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1; if (value = node.classList) { while (++i < n) if (!value.contains(name[i])) return false; } else { value = node.getAttribute("class"); while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false; } return true; } for (value in name) this.each(d3_selection_classed(value, name[value])); return this; } return this.each(d3_selection_classed(name, value)); }; function d3_selection_classedRe(name) { return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g"); } function d3_selection_classes(name) { return (name + "").trim().split(/^|\s+/); } function d3_selection_classed(name, value) { name = d3_selection_classes(name).map(d3_selection_classedName); var n = name.length; function classedConstant() { var i = -1; while (++i < n) name[i](this, value); } function classedFunction() { var i = -1, x = value.apply(this, arguments); while (++i < n) name[i](this, x); } return typeof value === "function" ? classedFunction : classedConstant; } function d3_selection_classedName(name) { var re = d3_selection_classedRe(name); return function(node, value) { if (c = node.classList) return value ? c.add(name) : c.remove(name); var c = node.getAttribute("class") || ""; if (value) { re.lastIndex = 0; if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name)); } else { node.setAttribute("class", d3_collapse(c.replace(re, " "))); } }; } d3_selectionPrototype.style = function(name, value, priority) { var n = arguments.length; if (n < 3) { if (typeof name !== "string") { if (n < 2) value = ""; for (priority in name) this.each(d3_selection_style(priority, name[priority], value)); return this; } if (n < 2) { var node = this.node(); return d3_window(node).getComputedStyle(node, null).getPropertyValue(name); } priority = ""; } return this.each(d3_selection_style(name, value, priority)); }; function d3_selection_style(name, value, priority) { function styleNull() { this.style.removeProperty(name); } function styleConstant() { this.style.setProperty(name, value, priority); } function styleFunction() { var x = value.apply(this, arguments); if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority); } return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant; } d3_selectionPrototype.property = function(name, value) { if (arguments.length < 2) { if (typeof name === "string") return this.node()[name]; for (value in name) this.each(d3_selection_property(value, name[value])); return this; } return this.each(d3_selection_property(name, value)); }; function d3_selection_property(name, value) { function propertyNull() { delete this[name]; } function propertyConstant() { this[name] = value; } function propertyFunction() { var x = value.apply(this, arguments); if (x == null) delete this[name]; else this[name] = x; } return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant; } d3_selectionPrototype.text = function(value) { return arguments.length ? this.each(typeof value === "function" ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? "" : v; } : value == null ? function() { this.textContent = ""; } : function() { this.textContent = value; }) : this.node().textContent; }; d3_selectionPrototype.html = function(value) { return arguments.length ? this.each(typeof value === "function" ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? "" : v; } : value == null ? function() { this.innerHTML = ""; } : function() { this.innerHTML = value; }) : this.node().innerHTML; }; d3_selectionPrototype.append = function(name) { name = d3_selection_creator(name); return this.select(function() { return this.appendChild(name.apply(this, arguments)); }); }; function d3_selection_creator(name) { function create() { var document = this.ownerDocument, namespace = this.namespaceURI; return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name); } function createNS() { return this.ownerDocument.createElementNS(name.space, name.local); } return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create; } d3_selectionPrototype.insert = function(name, before) { name = d3_selection_creator(name); before = d3_selection_selector(before); return this.select(function() { return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null); }); }; d3_selectionPrototype.remove = function() { return this.each(d3_selectionRemove); }; function d3_selectionRemove() { var parent = this.parentNode; if (parent) parent.removeChild(this); } d3_selectionPrototype.data = function(value, key) { var i = -1, n = this.length, group, node; if (!arguments.length) { value = new Array(n = (group = this[0]).length); while (++i < n) { if (node = group[i]) { value[i] = node.__data__; } } return value; } function bind(group, groupData) { var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData; if (key) { var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue; for (i = -1; ++i < n; ) { if (node = group[i]) { if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) { exitNodes[i] = node; } else { nodeByKeyValue.set(keyValue, node); } keyValues[i] = keyValue; } } for (i = -1; ++i < m; ) { if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) { enterNodes[i] = d3_selection_dataNode(nodeData); } else if (node !== true) { updateNodes[i] = node; node.__data__ = nodeData; } nodeByKeyValue.set(keyValue, true); } for (i = -1; ++i < n; ) { if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) { exitNodes[i] = group[i]; } } } else { for (i = -1; ++i < n0; ) { node = group[i]; nodeData = groupData[i]; if (node) { node.__data__ = nodeData; updateNodes[i] = node; } else { enterNodes[i] = d3_selection_dataNode(nodeData); } } for (;i < m; ++i) { enterNodes[i] = d3_selection_dataNode(groupData[i]); } for (;i < n; ++i) { exitNodes[i] = group[i]; } } enterNodes.update = updateNodes; enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode; enter.push(enterNodes); update.push(updateNodes); exit.push(exitNodes); } var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]); if (typeof value === "function") { while (++i < n) { bind(group = this[i], value.call(group, group.parentNode.__data__, i)); } } else { while (++i < n) { bind(group = this[i], value); } } update.enter = function() { return enter; }; update.exit = function() { return exit; }; return update; }; function d3_selection_dataNode(data) { return { __data__: data }; } d3_selectionPrototype.datum = function(value) { return arguments.length ? this.property("__data__", value) : this.property("__data__"); }; d3_selectionPrototype.filter = function(filter) { var subgroups = [], subgroup, group, node; if (typeof filter !== "function") filter = d3_selection_filter(filter); for (var j = 0, m = this.length; j < m; j++) { subgroups.push(subgroup = []); subgroup.parentNode = (group = this[j]).parentNode; for (var i = 0, n = group.length; i < n; i++) { if ((node = group[i]) && filter.call(node, node.__data__, i, j)) { subgroup.push(node); } } } return d3_selection(subgroups); }; function d3_selection_filter(selector) { return function() { return d3_selectMatches(this, selector); }; } d3_selectionPrototype.order = function() { for (var j = -1, m = this.length; ++j < m; ) { for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) { if (node = group[i]) { if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next); next = node; } } } return this; }; d3_selectionPrototype.sort = function(comparator) { comparator = d3_selection_sortComparator.apply(this, arguments); for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator); return this.order(); }; function d3_selection_sortComparator(comparator) { if (!arguments.length) comparator = d3_ascending; return function(a, b) { return a && b ? comparator(a.__data__, b.__data__) : !a - !b; }; } d3_selectionPrototype.each = function(callback) { return d3_selection_each(this, function(node, i, j) { callback.call(node, node.__data__, i, j); }); }; function d3_selection_each(groups, callback) { for (var j = 0, m = groups.length; j < m; j++) { for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) { if (node = group[i]) callback(node, i, j); } } return groups; } d3_selectionPrototype.call = function(callback) { var args = d3_array(arguments); callback.apply(args[0] = this, args); return this; }; d3_selectionPrototype.empty = function() { return !this.node(); }; d3_selectionPrototype.node = function() { for (var j = 0, m = this.length; j < m; j++) { for (var group = this[j], i = 0, n = group.length; i < n; i++) { var node = group[i]; if (node) return node; } } return null; }; d3_selectionPrototype.size = function() { var n = 0; d3_selection_each(this, function() { ++n; }); return n; }; function d3_selection_enter(selection) { d3_subclass(selection, d3_selection_enterPrototype); return selection; } var d3_selection_enterPrototype = []; d3.selection.enter = d3_selection_enter; d3.selection.enter.prototype = d3_selection_enterPrototype; d3_selection_enterPrototype.append = d3_selectionPrototype.append; d3_selection_enterPrototype.empty = d3_selectionPrototype.empty; d3_selection_enterPrototype.node = d3_selectionPrototype.node; d3_selection_enterPrototype.call = d3_selectionPrototype.call; d3_selection_enterPrototype.size = d3_selectionPrototype.size; d3_selection_enterPrototype.select = function(selector) { var subgroups = [], subgroup, subnode, upgroup, group, node; for (var j = -1, m = this.length; ++j < m; ) { upgroup = (group = this[j]).update; subgroups.push(subgroup = []); subgroup.parentNode = group.parentNode; for (var i = -1, n = group.length; ++i < n; ) { if (node = group[i]) { subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j)); subnode.__data__ = node.__data__; } else { subgroup.push(null); } } } return d3_selection(subgroups); }; d3_selection_enterPrototype.insert = function(name, before) { if (arguments.length < 2) before = d3_selection_enterInsertBefore(this); return d3_selectionPrototype.insert.call(this, name, before); }; function d3_selection_enterInsertBefore(enter) { var i0, j0; return function(d, i, j) { var group = enter[j].update, n = group.length, node; if (j != j0) j0 = j, i0 = 0; if (i >= i0) i0 = i + 1; while (!(node = group[i0]) && ++i0 < n) ; return node; }; } d3.select = function(node) { var group; if (typeof node === "string") { group = [ d3_select(node, d3_document) ]; group.parentNode = d3_document.documentElement; } else { group = [ node ]; group.parentNode = d3_documentElement(node); } return d3_selection([ group ]); }; d3.selectAll = function(nodes) { var group; if (typeof nodes === "string") { group = d3_array(d3_selectAll(nodes, d3_document)); group.parentNode = d3_document.documentElement; } else { group = d3_array(nodes); group.parentNode = null; } return d3_selection([ group ]); }; d3_selectionPrototype.on = function(type, listener, capture) { var n = arguments.length; if (n < 3) { if (typeof type !== "string") { if (n < 2) listener = false; for (capture in type) this.each(d3_selection_on(capture, type[capture], listener)); return this; } if (n < 2) return (n = this.node()["__on" + type]) && n._; capture = false; } return this.each(d3_selection_on(type, listener, capture)); }; function d3_selection_on(type, listener, capture) { var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener; if (i > 0) type = type.slice(0, i); var filter = d3_selection_onFilters.get(type); if (filter) type = filter, wrap = d3_selection_onFilter; function onRemove() { var l = this[name]; if (l) { this.removeEventListener(type, l, l.$); delete this[name]; } } function onAdd() { var l = wrap(listener, d3_array(arguments)); onRemove.call(this); this.addEventListener(type, this[name] = l, l.$ = capture); l._ = listener; } function removeAll() { var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match; for (var name in this) { if (match = name.match(re)) { var l = this[name]; this.removeEventListener(match[1], l, l.$); delete this[name]; } } } return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll; } var d3_selection_onFilters = d3.map({ mouseenter: "mouseover", mouseleave: "mouseout" }); if (d3_document) { d3_selection_onFilters.forEach(function(k) { if ("on" + k in d3_document) d3_selection_onFilters.remove(k); }); } function d3_selection_onListener(listener, argumentz) { return function(e) { var o = d3.event; d3.event = e; argumentz[0] = this.__data__; try { listener.apply(this, argumentz); } finally { d3.event = o; } }; } function d3_selection_onFilter(listener, argumentz) { var l = d3_selection_onListener(listener, argumentz); return function(e) { var target = this, related = e.relatedTarget; if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) { l.call(target, e); } }; } var d3_event_dragSelect, d3_event_dragId = 0; function d3_event_dragSuppress(node) { var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault); if (d3_event_dragSelect == null) { d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect"); } if (d3_event_dragSelect) { var style = d3_documentElement(node).style, select = style[d3_event_dragSelect]; style[d3_event_dragSelect] = "none"; } return function(suppressClick) { w.on(name, null); if (d3_event_dragSelect) style[d3_event_dragSelect] = select; if (suppressClick) { var off = function() { w.on(click, null); }; w.on(click, function() { d3_eventPreventDefault(); off(); }, true); setTimeout(off, 0); } }; } d3.mouse = function(container) { return d3_mousePoint(container, d3_eventSource()); }; var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0; function d3_mousePoint(container, e) { if (e.changedTouches) e = e.changedTouches[0]; var svg = container.ownerSVGElement || container; if (svg.createSVGPoint) { var point = svg.createSVGPoint(); if (d3_mouse_bug44083 < 0) { var window = d3_window(container); if (window.scrollX || window.scrollY) { svg = d3.select("body").append("svg").style({ position: "absolute", top: 0, left: 0, margin: 0, padding: 0, border: "none" }, "important"); var ctm = svg[0][0].getScreenCTM(); d3_mouse_bug44083 = !(ctm.f || ctm.e); svg.remove(); } } if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, point.y = e.clientY; point = point.matrixTransform(container.getScreenCTM().inverse()); return [ point.x, point.y ]; } var rect = container.getBoundingClientRect(); return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ]; } d3.touch = function(container, touches, identifier) { if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches; if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) { if ((touch = touches[i]).identifier === identifier) { return d3_mousePoint(container, touch); } } }; d3.behavior.drag = function() { var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend"); function drag() { this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart); } function dragstart(id, position, subject, move, end) { return function() { var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId); if (origin) { dragOffset = origin.apply(that, arguments); dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ]; } else { dragOffset = [ 0, 0 ]; } dispatch({ type: "dragstart" }); function moved() { var position1 = position(parent, dragId), dx, dy; if (!position1) return; dx = position1[0] - position0[0]; dy = position1[1] - position0[1]; dragged |= dx | dy; position0 = position1; dispatch({ type: "drag", x: position1[0] + dragOffset[0], y: position1[1] + dragOffset[1], dx: dx, dy: dy }); } function ended() { if (!position(parent, dragId)) return; dragSubject.on(move + dragName, null).on(end + dragName, null); dragRestore(dragged); dispatch({ type: "dragend" }); } }; } drag.origin = function(x) { if (!arguments.length) return origin; origin = x; return drag; }; return d3.rebind(drag, event, "on"); }; function d3_behavior_dragTouchId() { return d3.event.changedTouches[0].identifier; } d3.touches = function(container, touches) { if (arguments.length < 2) touches = d3_eventSource().touches; return touches ? d3_array(touches).map(function(touch) { var point = d3_mousePoint(container, touch); point.identifier = touch.identifier; return point; }) : []; }; var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π; function d3_sgn(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; } function d3_cross2d(a, b, c) { return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]); } function d3_acos(x) { return x > 1 ? 0 : x < -1 ? π : Math.acos(x); } function d3_asin(x) { return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x); } function d3_sinh(x) { return ((x = Math.exp(x)) - 1 / x) / 2; } function d3_cosh(x) { return ((x = Math.exp(x)) + 1 / x) / 2; } function d3_tanh(x) { return ((x = Math.exp(2 * x)) - 1) / (x + 1); } function d3_haversin(x) { return (x = Math.sin(x / 2)) * x; } var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4; d3.interpolateZoom = function(p0, p1) { var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S; if (d2 < ε2) { S = Math.log(w1 / w0) / ρ; i = function(t) { return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ]; }; } else { var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1); S = (r1 - r0) / ρ; i = function(t) { var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0)); return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ]; }; } i.duration = S * 1e3; return i; }; d3.behavior.zoom = function() { var view = { x: 0, y: 0, k: 1 }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1; if (!d3_behavior_zoomWheel) { d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() { return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1); }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() { return d3.event.wheelDelta; }, "mousewheel") : (d3_behavior_zoomDelta = function() { return -d3.event.detail; }, "MozMousePixelScroll"); } function zoom(g) { g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted); } zoom.event = function(g) { g.each(function() { var dispatch = event.of(this, arguments), view1 = view; if (d3_transitionInheritId) { d3.select(this).transition().each("start.zoom", function() { view = this.__chart__ || { x: 0, y: 0, k: 1 }; zoomstarted(dispatch); }).tween("zoom:zoom", function() { var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]); return function(t) { var l = i(t), k = dx / l[2]; this.__chart__ = view = { x: cx - l[0] * k, y: cy - l[1] * k, k: k }; zoomed(dispatch); }; }).each("interrupt.zoom", function() { zoomended(dispatch); }).each("end.zoom", function() { zoomended(dispatch); }); } else { this.__chart__ = view; zoomstarted(dispatch); zoomed(dispatch); zoomended(dispatch); } }); }; zoom.translate = function(_) { if (!arguments.length) return [ view.x, view.y ]; view = { x: +_[0], y: +_[1], k: view.k }; rescale(); return zoom; }; zoom.scale = function(_) { if (!arguments.length) return view.k; view = { x: view.x, y: view.y, k: null }; scaleTo(+_); rescale(); return zoom; }; zoom.scaleExtent = function(_) { if (!arguments.length) return scaleExtent; scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ]; return zoom; }; zoom.center = function(_) { if (!arguments.length) return center; center = _ && [ +_[0], +_[1] ]; return zoom; }; zoom.size = function(_) { if (!arguments.length) return size; size = _ && [ +_[0], +_[1] ]; return zoom; }; zoom.duration = function(_) { if (!arguments.length) return duration; duration = +_; return zoom; }; zoom.x = function(z) { if (!arguments.length) return x1; x1 = z; x0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; zoom.y = function(z) { if (!arguments.length) return y1; y1 = z; y0 = z.copy(); view = { x: 0, y: 0, k: 1 }; return zoom; }; function location(p) { return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ]; } function point(l) { return [ l[0] * view.k + view.x, l[1] * view.k + view.y ]; } function scaleTo(s) { view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s)); } function translateTo(p, l) { l = point(l); view.x += p[0] - l[0]; view.y += p[1] - l[1]; } function zoomTo(that, p, l, k) { that.__chart__ = { x: view.x, y: view.y, k: view.k }; scaleTo(Math.pow(2, k)); translateTo(center0 = p, l); that = d3.select(that); if (duration > 0) that = that.transition().duration(duration); that.call(zoom.event); } function rescale() { if (x1) x1.domain(x0.range().map(function(x) { return (x - view.x) / view.k; }).map(x0.invert)); if (y1) y1.domain(y0.range().map(function(y) { return (y - view.y) / view.k; }).map(y0.invert)); } function zoomstarted(dispatch) { if (!zooming++) dispatch({ type: "zoomstart" }); } function zoomed(dispatch) { rescale(); dispatch({ type: "zoom", scale: view.k, translate: [ view.x, view.y ] }); } function zoomended(dispatch) { if (!--zooming) dispatch({ type: "zoomend" }), center0 = null; } function mousedowned() { var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that); d3_selection_interrupt.call(that); zoomstarted(dispatch); function moved() { dragged = 1; translateTo(d3.mouse(that), location0); zoomed(dispatch); } function ended() { subject.on(mousemove, null).on(mouseup, null); dragRestore(dragged); zoomended(dispatch); } } function touchstarted() { var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that); started(); zoomstarted(dispatch); subject.on(mousedown, null).on(touchstart, started); function relocate() { var touches = d3.touches(that); scale0 = view.k; touches.forEach(function(t) { if (t.identifier in locations0) locations0[t.identifier] = location(t); }); return touches; } function started() { var target = d3.event.target; d3.select(target).on(touchmove, moved).on(touchend, ended); targets.push(target); var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i < n; ++i) { locations0[changed[i].identifier] = null; } var touches = relocate(), now = Date.now(); if (touches.length === 1) { if (now - touchtime < 500) { var p = touches[0]; zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1); d3_eventPreventDefault(); } touchtime = now; } else if (touches.length > 1) { var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1]; distance0 = dx * dx + dy * dy; } } function moved() { var touches = d3.touches(that), p0, l0, p1, l1; d3_selection_interrupt.call(that); for (var i = 0, n = touches.length; i < n; ++i, l1 = null) { p1 = touches[i]; if (l1 = locations0[p1.identifier]) { if (l0) break; p0 = p1, l0 = l1; } } if (l1) { var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0); p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ]; l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ]; scaleTo(scale1 * scale0); } touchtime = null; translateTo(p0, l0); zoomed(dispatch); } function ended() { if (d3.event.touches.length) { var changed = d3.event.changedTouches; for (var i = 0, n = changed.length; i < n; ++i) { delete locations0[changed[i].identifier]; } for (var identifier in locations0) { return void relocate(); } } d3.selectAll(targets).on(zoomName, null); subject.on(mousedown, mousedowned).on(touchstart, touchstarted); dragRestore(); zoomended(dispatch); } } function mousewheeled() { var dispatch = event.of(this, arguments); if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch); mousewheelTimer = setTimeout(function() { mousewheelTimer = null; zoomended(dispatch); }, 50); d3_eventPreventDefault(); scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k); translateTo(center0, translate0); zoomed(dispatch); } function dblclicked() { var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2; zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1); } return d3.rebind(zoom, event, "on"); }; var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel; d3.color = d3_color; function d3_color() {} d3_color.prototype.toString = function() { return this.rgb() + ""; }; d3.hsl = d3_hsl; function d3_hsl(h, s, l) { return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l); } var d3_hslPrototype = d3_hsl.prototype = new d3_color(); d3_hslPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, this.l / k); }; d3_hslPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_hsl(this.h, this.s, k * this.l); }; d3_hslPrototype.rgb = function() { return d3_hsl_rgb(this.h, this.s, this.l); }; function d3_hsl_rgb(h, s, l) { var m1, m2; h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h; s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s; l = l < 0 ? 0 : l > 1 ? 1 : l; m2 = l 360) h -= 360; else if (h < 0) h += 360; if (h < 60) return m1 + (m2 - m1) * h / 60; if (h < 180) return m2; if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60; return m1; } function vv(h) { return Math.round(v(h) * 255); } return new d3_rgb(vv(h + 120), vv(h), vv(h - 120)); } d3.hcl = d3_hcl; function d3_hcl(h, c, l) { return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l); } var d3_hclPrototype = d3_hcl.prototype = new d3_color(); d3_hclPrototype.brighter = function(k) { return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1))); }; d3_hclPrototype.darker = function(k) { return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1))); }; d3_hclPrototype.rgb = function() { return d3_hcl_lab(this.h, this.c, this.l).rgb(); }; function d3_hcl_lab(h, c, l) { if (isNaN(h)) h = 0; if (isNaN(c)) c = 0; return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c); } d3.lab = d3_lab; function d3_lab(l, a, b) { return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b); } var d3_lab_K = 18; var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883; var d3_labPrototype = d3_lab.prototype = new d3_color(); d3_labPrototype.brighter = function(k) { return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.darker = function(k) { return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b); }; d3_labPrototype.rgb = function() { return d3_lab_rgb(this.l, this.a, this.b); }; function d3_lab_rgb(l, a, b) { var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200; x = d3_lab_xyz(x) * d3_lab_X; y = d3_lab_xyz(y) * d3_lab_Y; z = d3_lab_xyz(z) * d3_lab_Z; return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z)); } function d3_lab_hcl(l, a, b) { return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l); } function d3_lab_xyz(x) { return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037; } function d3_xyz_lab(x) { return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29; } function d3_xyz_rgb(r) { return Math.round(255 * (r 16, value >> 8 & 255, value & 255); } function d3_rgbString(value) { return d3_rgbNumber(value) + ""; } var d3_rgbPrototype = d3_rgb.prototype = new d3_color(); d3_rgbPrototype.brighter = function(k) { k = Math.pow(.7, arguments.length ? k : 1); var r = this.r, g = this.g, b = this.b, i = 30; if (!r && !g && !b) return new d3_rgb(i, i, i); if (r && r < i) r = i; if (g && g < i) g = i; if (b && b < i) b = i; return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k)); }; d3_rgbPrototype.darker = function(k) { k = Math.pow(.7, arguments.length ? k : 1); return new d3_rgb(k * this.r, k * this.g, k * this.b); }; d3_rgbPrototype.hsl = function() { return d3_rgb_hsl(this.r, this.g, this.b); }; d3_rgbPrototype.toString = function() { return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b); }; function d3_rgb_hex(v) { return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16); } function d3_rgb_parse(format, rgb, hsl) { var r = 0, g = 0, b = 0, m1, m2, color; m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase()); if (m1) { m2 = m1[2].split(","); switch (m1[1]) { case "hsl": { return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100); } case "rgb": { return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2])); } } } if (color = d3_rgb_names.get(format)) { return rgb(color.r, color.g, color.b); } if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) { if (format.length === 4) { r = (color & 3840) >> 4; r = r >> 4 | r; g = color & 240; g = g >> 4 | g; b = color & 15; b = b < 4 | b; } else if (format.length === 7) { r = (color & 16711680) >> 16; g = (color & 65280) >> 8; b = color & 255; } } return rgb(r, g, b); } function d3_rgb_hsl(r, g, b) { var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2; if (d) { s = l < .5 ? d / (max + min) : d / (2 - max - min); if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4; h *= 60; } else { h = NaN; s = l > 0 && l < 1 ? 0 : h; } return new d3_hsl(h, s, l); } function d3_rgb_lab(r, g, b) { r = d3_rgb_xyz(r); g = d3_rgb_xyz(g); b = d3_rgb_xyz(b); var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z); return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z)); } function d3_rgb_xyz(r) { return (r /= 255) = 200 && status < 300 || status === 304) { try { result = response.call(xhr, request); } catch (e) { dispatch.error.call(xhr, e); return; } dispatch.load.call(xhr, result); } else { dispatch.error.call(xhr, request); } } request.onprogress = function(event) { var o = d3.event; d3.event = event; try { dispatch.progress.call(xhr, request); } finally { d3.event = o; } }; xhr.header = function(name, value) { name = (name + "").toLowerCase(); if (arguments.length < 2) return headers[name]; if (value == null) delete headers[name]; else headers[name] = value + ""; return xhr; }; xhr.mimeType = function(value) { if (!arguments.length) return mimeType; mimeType = value == null ? null : value + ""; return xhr; }; xhr.responseType = function(value) { if (!arguments.length) return responseType; responseType = value; return xhr; }; xhr.response = function(value) { response = value; return xhr; }; [ "get", "post" ].forEach(function(method) { xhr[method] = function() { return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments))); }; }); xhr.send = function(method, data, callback) { if (arguments.length === 2 && typeof data === "function") callback = data, data = null; request.open(method, url, true); if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*"; if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]); if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType); if (responseType != null) request.responseType = responseType; if (callback != null) xhr.on("error", callback).on("load", function(request) { callback(null, request); }); dispatch.beforesend.call(xhr, request); request.send(data == null ? null : data); return xhr; }; xhr.abort = function() { request.abort(); return xhr; }; d3.rebind(xhr, dispatch, "on"); return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback)); } function d3_xhr_fixCallback(callback) { return callback.length === 1 ? function(error, request) { callback(error == null ? request : null); } : callback; } function d3_xhrHasResponse(request) { var type = request.responseType; return type && type !== "text" ? request.response : request.responseText; } d3.dsv = function(delimiter, mimeType) { var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0); function dsv(url, row, callback) { if (arguments.length < 3) callback = row, row = null; var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback); xhr.row = function(_) { return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row; }; return xhr; } function response(request) { return dsv.parse(request.responseText); } function typedResponse(f) { return function(request) { return dsv.parse(request.responseText, f); }; } dsv.parse = function(text, f) { var o; return dsv.parseRows(text, function(row, i) { if (o) return o(row, i - 1); var a = new Function("d", "return {" + row.map(function(name, i) { return JSON.stringify(name) + ": d[" + i + "]"; }).join(",") + "}"); o = f ? function(row, i) { return f(a(row), i); } : a; }); }; dsv.parseRows = function(text, f) { var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol; function token() { if (I >= N) return EOF; if (eol) return eol = false, EOL; var j = I; if (text.charCodeAt(j) === 34) { var i = j; while (i++ < N) { if (text.charCodeAt(i) === 34) { if (text.charCodeAt(i + 1) !== 34) break; ++i; } } I = i + 2; var c = text.charCodeAt(i + 1); if (c === 13) { eol = true; if (text.charCodeAt(i + 2) === 10) ++I; } else if (c === 10) { eol = true; } return text.slice(j + 1, i).replace(/""/g, '"'); } while (I < N) { var c = text.charCodeAt(I++), k = 1; if (c === 10) eol = true; else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } else if (c !== delimiterCode) continue; return text.slice(j, I - k); } return text.slice(j); } while ((t = token()) !== EOF) { var a = []; while (t !== EOL && t !== EOF) { a.push(t); t = token(); } if (f && (a = f(a, n++)) == null) continue; rows.push(a); } return rows; }; dsv.format = function(rows) { if (Array.isArray(rows[0])) return dsv.formatRows(rows); var fieldSet = new d3_Set(), fields = []; rows.forEach(function(row) { for (var field in row) { if (!fieldSet.has(field)) { fields.push(fieldSet.add(field)); } } }); return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) { return fields.map(function(field) { return formatValue(row[field]); }).join(delimiter); })).join("\n"); }; dsv.formatRows = function(rows) { return rows.map(formatRow).join("\n"); }; function formatRow(row) { return row.map(formatValue).join(delimiter); } function formatValue(text) { return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text; } return dsv; }; d3.csv = d3.dsv(",", "text/csv"); d3.tsv = d3.dsv(" ", "text/tab-separated-values"); var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) { setTimeout(callback, 17); }; d3.timer = function() { d3_timer.apply(this, arguments); }; function d3_timer(callback, delay, then) { var n = arguments.length; if (n < 2) delay = 0; if (n < 3) then = Date.now(); var time = then + delay, timer = { c: callback, t: time, n: null }; if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer; d3_timer_queueTail = timer; if (!d3_timer_interval) { d3_timer_timeout = clearTimeout(d3_timer_timeout); d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } return timer; } function d3_timer_step() { var now = d3_timer_mark(), delay = d3_timer_sweep() - now; if (delay > 24) { if (isFinite(delay)) { clearTimeout(d3_timer_timeout); d3_timer_timeout = setTimeout(d3_timer_step, delay); } d3_timer_interval = 0; } else { d3_timer_interval = 1; d3_timer_frame(d3_timer_step); } } d3.timer.flush = function() { d3_timer_mark(); d3_timer_sweep(); }; function d3_timer_mark() { var now = Date.now(), timer = d3_timer_queueHead; while (timer) { if (now >= timer.t && timer.c(now - timer.t)) timer.c = null; timer = timer.n; } return now; } function d3_timer_sweep() { var t0, t1 = d3_timer_queueHead, time = Infinity; while (t1) { if (t1.c) { if (t1.t < time) time = t1.t; t1 = (t0 = t1).n; } else { t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n; } } d3_timer_queueTail = t0; return time; } function d3_format_precision(x, p) { return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1); } d3.round = function(x, n) { return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x); }; var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix); d3.formatPrefix = function(value, precision) { var i = 0; if (value = +value) { if (value < 0) value *= -1; if (precision) value = d3.round(value, d3_format_precision(value, precision)); i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10); i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3)); } return d3_formatPrefixes[8 + i / 3]; }; function d3_formatPrefix(d, i) { var k = Math.pow(10, abs(8 - i) * 3); return { scale: i > 8 ? function(d) { return d / k; } : function(d) { return d * k; }, symbol: d }; } function d3_locale_numberFormat(locale) { var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) { var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0; while (i > 0 && g > 0) { if (length + g + 1 > width) g = Math.max(1, width - length); t.push(value.substring(i -= g, i + g)); if ((length += g + 1) > width) break; g = locale_grouping[j = (j + 1) % locale_grouping.length]; } return t.reverse().join(locale_thousands); } : d3_identity; return function(specifier) { var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true; if (precision) precision = +precision.substring(1); if (zfill || fill === "0" && align === "=") { zfill = fill = "0"; align = "="; } switch (type) { case "n": comma = true; type = "g"; break; case "%": scale = 100; suffix = "%"; type = "f"; break; case "p": scale = 100; suffix = "%"; type = "r"; break; case "b": case "o": case "x": case "X": if (symbol === "#") prefix = "0" + type.toLowerCase(); case "c": exponent = false; case "d": integer = true; precision = 0; break; case "s": scale = -1; type = "r"; break; } if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1]; if (type == "r" && !precision) type = "g"; if (precision != null) { if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision)); } type = d3_format_types.get(type) || d3_format_typeDefault; var zcomma = zfill && comma; return function(value) { var fullSuffix = suffix; if (integer && value % 1) return ""; var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign; if (scale < 0) { var unit = d3.formatPrefix(value, precision); value = unit.scale(value); fullSuffix = unit.symbol + suffix; } else { value *= scale; } value = type(value, precision); var i = value.lastIndexOf("."), before, after; if (i < 0) { var j = exponent ? value.lastIndexOf("e") : -1; if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j); } else { before = value.substring(0, i); after = locale_decimal + value.substring(i + 1); } if (!zfill && comma) before = formatGroup(before, Infinity); var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : ""; if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity); negative += prefix; value = before + after; return (align === "" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix; }; }; } var d3_format_re = /(?:([^{])?([=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i; var d3_format_types = d3.map({ b: function(x) { return x.toString(2); }, c: function(x) { return String.fromCharCode(x); }, o: function(x) { return x.toString(8); }, x: function(x) { return x.toString(16); }, X: function(x) { return x.toString(16).toUpperCase(); }, g: function(x, p) { return x.toPrecision(p); }, e: function(x, p) { return x.toExponential(p); }, f: function(x, p) { return x.toFixed(p); }, r: function(x, p) { return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p)))); } }); function d3_format_typeDefault(x) { return x + ""; } var d3_time = d3.time = {}, d3_date = Date; function d3_date_utc() { this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]); } d3_date_utc.prototype = { getDate: function() { return this._.getUTCDate(); }, getDay: function() { return this._.getUTCDay(); }, getFullYear: function() { return this._.getUTCFullYear(); }, getHours: function() { return this._.getUTCHours(); }, getMilliseconds: function() { return this._.getUTCMilliseconds(); }, getMinutes: function() { return this._.getUTCMinutes(); }, getMonth: function() { return this._.getUTCMonth(); }, getSeconds: function() { return this._.getUTCSeconds(); }, getTime: function() { return this._.getTime(); }, getTimezoneOffset: function() { return 0; }, valueOf: function() { return this._.valueOf(); }, setDate: function() { d3_time_prototype.setUTCDate.apply(this._, arguments); }, setDay: function() { d3_time_prototype.setUTCDay.apply(this._, arguments); }, setFullYear: function() { d3_time_prototype.setUTCFullYear.apply(this._, arguments); }, setHours: function() { d3_time_prototype.setUTCHours.apply(this._, arguments); }, setMilliseconds: function() { d3_time_prototype.setUTCMilliseconds.apply(this._, arguments); }, setMinutes: function() { d3_time_prototype.setUTCMinutes.apply(this._, arguments); }, setMonth: function() { d3_time_prototype.setUTCMonth.apply(this._, arguments); }, setSeconds: function() { d3_time_prototype.setUTCSeconds.apply(this._, arguments); }, setTime: function() { d3_time_prototype.setTime.apply(this._, arguments); } }; var d3_time_prototype = Date.prototype; function d3_time_interval(local, step, number) { function round(date) { var d0 = local(date), d1 = offset(d0, 1); return date - d0 < d1 - date ? d0 : d1; } function ceil(date) { step(date = local(new d3_date(date - 1)), 1); return date; } function offset(date, k) { step(date = new d3_date(+date), k); return date; } function range(t0, t1, dt) { var time = ceil(t0), times = []; if (dt > 1) { while (time < t1) { if (!(number(time) % dt)) times.push(new Date(+time)); step(time, 1); } } else { while (time < t1) times.push(new Date(+time)), step(time, 1); } return times; } function range_utc(t0, t1, dt) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = t0; return range(utc, t1, dt); } finally { d3_date = Date; } } local.floor = local; local.round = round; local.ceil = ceil; local.offset = offset; local.range = range; var utc = local.utc = d3_time_interval_utc(local); utc.floor = utc; utc.round = d3_time_interval_utc(round); utc.ceil = d3_time_interval_utc(ceil); utc.offset = d3_time_interval_utc(offset); utc.range = range_utc; return local; } function d3_time_interval_utc(method) { return function(date, k) { try { d3_date = d3_date_utc; var utc = new d3_date_utc(); utc._ = date; return method(utc, k)._; } finally { d3_date = Date; } }; } d3_time.year = d3_time_interval(function(date) { date = d3_time.day(date); date.setMonth(0, 1); return date; }, function(date, offset) { date.setFullYear(date.getFullYear() + offset); }, function(date) { return date.getFullYear(); }); d3_time.years = d3_time.year.range; d3_time.years.utc = d3_time.year.utc.range; d3_time.day = d3_time_interval(function(date) { var day = new d3_date(2e3, 0); day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()); return day; }, function(date, offset) { date.setDate(date.getDate() + offset); }, function(date) { return date.getDate() - 1; }); d3_time.days = d3_time.day.range; d3_time.days.utc = d3_time.day.utc.range; d3_time.dayOfYear = function(date) { var year = d3_time.year(date); return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5); }; [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) { i = 7 - i; var interval = d3_time[day] = d3_time_interval(function(date) { (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7); return date; }, function(date, offset) { date.setDate(date.getDate() + Math.floor(offset) * 7); }, function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i); }); d3_time[day + "s"] = interval.range; d3_time[day + "s"].utc = interval.utc.range; d3_time[day + "OfYear"] = function(date) { var day = d3_time.year(date).getDay(); return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7); }; }); d3_time.week = d3_time.sunday; d3_time.weeks = d3_time.sunday.range; d3_time.weeks.utc = d3_time.sunday.utc.range; d3_time.weekOfYear = d3_time.sundayOfYear; function d3_locale_timeFormat(locale) { var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths; function d3_time_format(template) { var n = template.length; function format(date) { var string = [], i = -1, j = 0, c, p, f; while (++i < n) { if (template.charCodeAt(i) === 37) { string.push(template.slice(j, i)); if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i); if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p); string.push(c); j = i + 1; } } string.push(template.slice(j, i)); return string.join(""); } format.parse = function(string) { var d = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, i = d3_time_parse(d, template, string, 0); if (i != string.length) return null; if ("p" in d) d.H = d.H % 12 + d.p * 12; var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)(); if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) { if (!("w" in d)) d.w = "W" in d ? 1 : 0; date.setFullYear(d.y, 0, 1); date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7); } else date.setFullYear(d.y, d.m, d.d); date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L); return localZ ? date._ : date; }; format.toString = function() { return template; }; return format; } function d3_time_parse(date, template, string, j) { var c, p, t, i = 0, n = template.length, m = string.length; while (i < n) { if (j >= m) return -1; c = template.charCodeAt(i++); if (c === 37) { t = template.charAt(i++); p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t]; if (!p || (j = p(date, string, j)) < 0) return -1; } else if (c != string.charCodeAt(j++)) { return -1; } } return j; } d3_time_format.utc = function(template) { var local = d3_time_format(template); function format(date) { try { d3_date = d3_date_utc; var utc = new d3_date(); utc._ = date; return local(utc); } finally { d3_date = Date; } } format.parse = function(string) { try { d3_date = d3_date_utc; var date = local.parse(string); return date && date._; } finally { d3_date = Date; } }; format.toString = local.toString; return format; }; d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti; var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths); locale_periods.forEach(function(p, i) { d3_time_periodLookup.set(p.toLowerCase(), i); }); var d3_time_formats = { a: function(d) { return locale_shortDays[d.getDay()]; }, A: function(d) { return locale_days[d.getDay()]; }, b: function(d) { return locale_shortMonths[d.getMonth()]; }, B: function(d) { return locale_months[d.getMonth()]; }, c: d3_time_format(locale_dateTime), d: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, e: function(d, p) { return d3_time_formatPad(d.getDate(), p, 2); }, H: function(d, p) { return d3_time_formatPad(d.getHours(), p, 2); }, I: function(d, p) { return d3_time_formatPad(d.getHours() % 12 || 12, p, 2); }, j: function(d, p) { return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3); }, L: function(d, p) { return d3_time_formatPad(d.getMilliseconds(), p, 3); }, m: function(d, p) { return d3_time_formatPad(d.getMonth() + 1, p, 2); }, M: function(d, p) { return d3_time_formatPad(d.getMinutes(), p, 2); }, p: function(d) { return locale_periods[+(d.getHours() >= 12)]; }, S: function(d, p) { return d3_time_formatPad(d.getSeconds(), p, 2); }, U: function(d, p) { return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2); }, w: function(d) { return d.getDay(); }, W: function(d, p) { return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2); }, x: d3_time_format(locale_date), X: d3_time_format(locale_time), y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 100, p, 2); }, Y: function(d, p) { return d3_time_formatPad(d.getFullYear() % 1e4, p, 4); }, Z: d3_time_zone, "%": function() { return "%"; } }; var d3_time_parsers = { a: d3_time_parseWeekdayAbbrev, A: d3_time_parseWeekday, b: d3_time_parseMonthAbbrev, B: d3_time_parseMonth, c: d3_time_parseLocaleFull, d: d3_time_parseDay, e: d3_time_parseDay, H: d3_time_parseHour24, I: d3_time_parseHour24, j: d3_time_parseDayOfYear, L: d3_time_parseMilliseconds, m: d3_time_parseMonthNumber, M: d3_time_parseMinutes, p: d3_time_parseAmPm, S: d3_time_parseSeconds, U: d3_time_parseWeekNumberSunday, w: d3_time_parseWeekdayNumber, W: d3_time_parseWeekNumberMonday, x: d3_time_parseLocaleDate, X: d3_time_parseLocaleTime, y: d3_time_parseYear, Y: d3_time_parseFullYear, Z: d3_time_parseZone, "%": d3_time_parseLiteralPercent }; function d3_time_parseWeekdayAbbrev(date, string, i) { d3_time_dayAbbrevRe.lastIndex = 0; var n = d3_time_dayAbbrevRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseWeekday(date, string, i) { d3_time_dayRe.lastIndex = 0; var n = d3_time_dayRe.exec(string.slice(i)); return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonthAbbrev(date, string, i) { d3_time_monthAbbrevRe.lastIndex = 0; var n = d3_time_monthAbbrevRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseMonth(date, string, i) { d3_time_monthRe.lastIndex = 0; var n = d3_time_monthRe.exec(string.slice(i)); return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1; } function d3_time_parseLocaleFull(date, string, i) { return d3_time_parse(date, d3_time_formats.c.toString(), string, i); } function d3_time_parseLocaleDate(date, string, i) { return d3_time_parse(date, d3_time_formats.x.toString(), string, i); } function d3_time_parseLocaleTime(date, string, i) { return d3_time_parse(date, d3_time_formats.X.toString(), string, i); } function d3_time_parseAmPm(date, string, i) { var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase()); return n == null ? -1 : (date.p = n, i); } return d3_time_format; } var d3_time_formatPads = { "-": "", _: " ", "0": "0" }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/; function d3_time_formatPad(value, fill, width) { var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length; return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string); } function d3_time_formatRe(names) { return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i"); } function d3_time_formatLookup(names) { var map = new d3_Map(), i = -1, n = names.length; while (++i < n) map.set(names[i].toLowerCase(), i); return map; } function d3_time_parseWeekdayNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 1)); return n ? (date.w = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberSunday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.U = +n[0], i + n[0].length) : -1; } function d3_time_parseWeekNumberMonday(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i)); return n ? (date.W = +n[0], i + n[0].length) : -1; } function d3_time_parseFullYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 4)); return n ? (date.y = +n[0], i + n[0].length) : -1; } function d3_time_parseYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1; } function d3_time_parseZone(date, string, i) { return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1; } function d3_time_expandYear(d) { return d + (d > 68 ? 1900 : 2e3); } function d3_time_parseMonthNumber(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.m = n[0] - 1, i + n[0].length) : -1; } function d3_time_parseDay(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.d = +n[0], i + n[0].length) : -1; } function d3_time_parseDayOfYear(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.j = +n[0], i + n[0].length) : -1; } function d3_time_parseHour24(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.H = +n[0], i + n[0].length) : -1; } function d3_time_parseMinutes(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.M = +n[0], i + n[0].length) : -1; } function d3_time_parseSeconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 2)); return n ? (date.S = +n[0], i + n[0].length) : -1; } function d3_time_parseMilliseconds(date, string, i) { d3_time_numberRe.lastIndex = 0; var n = d3_time_numberRe.exec(string.slice(i, i + 3)); return n ? (date.L = +n[0], i + n[0].length) : -1; } function d3_time_zone(d) { var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60; return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2); } function d3_time_parseLiteralPercent(date, string, i) { d3_time_percentRe.lastIndex = 0; var n = d3_time_percentRe.exec(string.slice(i, i + 1)); return n ? i + n[0].length : -1; } function d3_time_formatMulti(formats) { var n = formats.length, i = -1; while (++i < n) formats[i][0] = this(formats[i][0]); return function(date) { var i = 0, f = formats[i]; while (!f[1](date)) f = formats[++i]; return f[0](date); }; } d3.locale = function(locale) { return { numberFormat: d3_locale_numberFormat(locale), timeFormat: d3_locale_timeFormat(locale) }; }; var d3_locale_enUS = d3.locale({ decimal: ".", thousands: ",", grouping: [ 3 ], currency: [ "$", "" ], dateTime: "%a %b %e %X %Y", date: "%m/%d/%Y", time: "%H:%M:%S", periods: [ "AM", "PM" ], days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ] }); d3.format = d3_locale_enUS.numberFormat; d3.geo = {}; function d3_adder() {} d3_adder.prototype = { s: 0, t: 0, add: function(y) { d3_adderSum(y, this.t, d3_adderTemp); d3_adderSum(d3_adderTemp.s, this.s, this); if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t; }, reset: function() { this.s = this.t = 0; }, valueOf: function() { return this.s; } }; var d3_adderTemp = new d3_adder(); function d3_adderSum(a, b, o) { var x = o.s = a + b, bv = x - a, av = x - bv; o.t = a - av + (b - bv); } d3.geo.stream = function(object, listener) { if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) { d3_geo_streamObjectType[object.type](object, listener); } else { d3_geo_streamGeometry(object, listener); } }; function d3_geo_streamGeometry(geometry, listener) { if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) { d3_geo_streamGeometryType[geometry.type](geometry, listener); } } var d3_geo_streamObjectType = { Feature: function(feature, listener) { d3_geo_streamGeometry(feature.geometry, listener); }, FeatureCollection: function(object, listener) { var features = object.features, i = -1, n = features.length; while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener); } }; var d3_geo_streamGeometryType = { Sphere: function(object, listener) { listener.sphere(); }, Point: function(object, listener) { object = object.coordinates; listener.point(object[0], object[1], object[2]); }, MultiPoint: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]); }, LineString: function(object, listener) { d3_geo_streamLine(object.coordinates, listener, 0); }, MultiLineString: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0); }, Polygon: function(object, listener) { d3_geo_streamPolygon(object.coordinates, listener); }, MultiPolygon: function(object, listener) { var coordinates = object.coordinates, i = -1, n = coordinates.length; while (++i < n) d3_geo_streamPolygon(coordinates[i], listener); }, GeometryCollection: function(object, listener) { var geometries = object.geometries, i = -1, n = geometries.length; while (++i < n) d3_geo_streamGeometry(geometries[i], listener); } }; function d3_geo_streamLine(coordinates, listener, closed) { var i = -1, n = coordinates.length - closed, coordinate; listener.lineStart(); while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]); listener.lineEnd(); } function d3_geo_streamPolygon(coordinates, listener) { var i = -1, n = coordinates.length; listener.polygonStart(); while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1); listener.polygonEnd(); } d3.geo.area = function(object) { d3_geo_areaSum = 0; d3.geo.stream(object, d3_geo_area); return d3_geo_areaSum; }; var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder(); var d3_geo_area = { sphere: function() { d3_geo_areaSum += 4 * π; }, point: d3_noop, lineStart: d3_noop, lineEnd: d3_noop, polygonStart: function() { d3_geo_areaRingSum.reset(); d3_geo_area.lineStart = d3_geo_areaRingStart; }, polygonEnd: function() { var area = 2 * d3_geo_areaRingSum; d3_geo_areaSum += area < 0 ? 4 * π + area : area; d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop; } }; function d3_geo_areaRingStart() { var λ00, φ00, λ0, cosφ0, sinφ0; d3_geo_area.point = function(λ, φ) { d3_geo_area.point = nextPoint; λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ); }; function nextPoint(λ, φ) { λ *= d3_radians; φ = φ * d3_radians / 2 + π / 4; var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ); d3_geo_areaRingSum.add(Math.atan2(v, u)); λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ; } d3_geo_area.lineEnd = function() { nextPoint(λ00, φ00); }; } function d3_geo_cartesian(spherical) { var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ); return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ]; } function d3_geo_cartesianDot(a, b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]; } function d3_geo_cartesianCross(a, b) { return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ]; } function d3_geo_cartesianAdd(a, b) { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; } function d3_geo_cartesianScale(vector, k) { return [ vector[0] * k, vector[1] * k, vector[2] * k ]; } function d3_geo_cartesianNormalize(d) { var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]); d[0] /= l; d[1] /= l; d[2] /= l; } function d3_geo_spherical(cartesian) { return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ]; } function d3_geo_sphericalEqual(a, b) { return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε; } d3.geo.bounds = function() { var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range; var bound = { point: point, lineStart: lineStart, lineEnd: lineEnd, polygonStart: function() { bound.point = ringPoint; bound.lineStart = ringStart; bound.lineEnd = ringEnd; dλSum = 0; d3_geo_area.polygonStart(); }, polygonEnd: function() { d3_geo_area.polygonEnd(); bound.point = point; bound.lineStart = lineStart; bound.lineEnd = lineEnd; if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90; range[0] = λ0, range[1] = λ1; } }; function point(λ, φ) { ranges.push(range = [ λ0 = λ, λ1 = λ ]); if (φ < φ0) φ0 = φ; if (φ > φ1) φ1 = φ; } function linePoint(λ, φ) { var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]); if (p0) { var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal); d3_geo_cartesianNormalize(inflection); inflection = d3_geo_spherical(inflection); var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180; if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) { var φi = inflection[1] * d3_degrees; if (φi > φ1) φ1 = φi; } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) { var φi = -inflection[1] * d3_degrees; if (φi < φ0) φ0 = φi; } else { if (φ < φ0) φ0 = φ; if (φ > φ1) φ1 = φ; } if (antimeridian) { if (λ < λ_) { if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ; } } else { if (λ1 >= λ0) { if (λ < λ0) λ0 = λ; if (λ > λ1) λ1 = λ; } else { if (λ > λ_) { if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ; } else { if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ; } } } } else { point(λ, φ); } p0 = p, λ_ = λ; } function lineStart() { bound.point = linePoint; } function lineEnd() { range[0] = λ0, range[1] = λ1; bound.point = point; p0 = null; } function ringPoint(λ, φ) { if (p0) { var dλ = λ - λ_; dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ; } else λ__ = λ, φ__ = φ; d3_geo_area.point(λ, φ); linePoint(λ, φ); } function ringStart() { d3_geo_area.lineStart(); } function ringEnd() { ringPoint(λ__, φ__); d3_geo_area.lineEnd(); if (abs(dλSum) > ε) λ0 = -(λ1 = 180); range[0] = λ0, range[1] = λ1; p0 = null; } function angle(λ0, λ1) { return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1; } function compareRanges(a, b) { return a[0] - b[0]; } function withinRange(x, range) { return range[0] true * * _.inRange(4, 2); * // => false * * _.inRange(2, 2); * // => false * * _.inRange(1.2, 2); * // => true * * _.inRange(5.2, 4); * // => false * * _.inRange(-3, -2, -6); * // => true */ function inRange(number, start, end) { start = toFinite(start); if (end === undefined) { end = start; start = 0; } else { end = toFinite(end); } number = toNumber(number); return baseInRange(number, start, end); } /** * Produces a random number between the inclusive `lower` and `upper` bounds. * If only one argument is provided a number between `0` and the given number * is returned. If `floating` is `true`, or either `lower` or `upper` are * floats, a floating-point number is returned instead of an integer. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @memberOf _ * @since 0.7.0 * @category Number * @param {number} [lower=0] The lower bound. * @param {number} [upper=1] The upper bound. * @param {boolean} [floating] Specify returning a floating-point number. * @returns {number} Returns the random number. * @example * * _.random(0, 5); * // => an integer between 0 and 5 * * _.random(5); * // => also an integer between 0 and 5 * * _.random(5, true); * // => a floating-point number between 0 and 5 * * _.random(1.2, 5.2); * // => a floating-point number between 1.2 and 5.2 */ function random(lower, upper, floating) { if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) { upper = floating = undefined; } if (floating === undefined) { if (typeof upper == 'boolean') { floating = upper; upper = undefined; } else if (typeof lower == 'boolean') { floating = lower; lower = undefined; } } if (lower === undefined && upper === undefined) { lower = 0; upper = 1; } else { lower = toFinite(lower); if (upper === undefined) { upper = lower; lower = 0; } else { upper = toFinite(upper); } } if (lower > upper) { var temp = lower; lower = upper; upper = temp; } if (floating || lower % 1 || upper % 1) { var rand = nativeRandom(); return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper); } return baseRandom(lower, upper); } /*------------------------------------------------------------------------*/ /** * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the camel cased string. * @example * * _.camelCase('Foo Bar'); * // => 'fooBar' * * _.camelCase('--foo-bar--'); * // => 'fooBar' * * _.camelCase('__FOO_BAR__'); * // => 'fooBar' */ var camelCase = createCompounder(function(result, word, index) { word = word.toLowerCase(); return result + (index ? capitalize(word) : word); }); /** * Converts the first character of `string` to upper case and the remaining * to lower case. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to capitalize. * @returns {string} Returns the capitalized string. * @example * * _.capitalize('FRED'); * // => 'Fred' */ function capitalize(string) { return upperFirst(toString(string).toLowerCase()); } /** * Deburrs `string` by converting * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table) * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A) * letters to basic Latin letters and removing * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to deburr. * @returns {string} Returns the deburred string. * @example * * _.deburr('déjà vu'); * // => 'deja vu' */ function deburr(string) { string = toString(string); return string && string.replace(reLatin, deburrLetter).replace(reComboMark, ''); } /** * Checks if `string` ends with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=string.length] The position to search up to. * @returns {boolean} Returns `true` if `string` ends with `target`, * else `false`. * @example * * _.endsWith('abc', 'c'); * // => true * * _.endsWith('abc', 'b'); * // => false * * _.endsWith('abc', 'b', 2); * // => true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position >= 0 && string.slice(position, end) == target; } /** * Converts the characters "&", "", '"', and "'" in `string` to their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the ">" character is escaped for symmetry, characters like * ">" and "/" don't need escaping in HTML and have no special meaning * unless they're part of a tag or unquoted attribute value. See * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under "semi-related fun fact") for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape('fred, barney, & pebbles'); * // => 'fred, barney, &amp; pebbles' */ function escape(string) { string = toString(string); return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+", * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp('[lodash](https://lodash.com/)'); * // => '\[lodash\]\(https://lodash\.com/\)' */ function escapeRegExp(string) { string = toString(string); return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string; } /** * Converts `string` to * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase('Foo Bar'); * // => 'foo-bar' * * _.kebabCase('fooBar'); * // => 'foo-bar' * * _.kebabCase('__FOO_BAR__'); * // => 'foo-bar' */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? '-' : '') + word.toLowerCase(); }); /** * Converts `string`, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase('--Foo-Bar--'); * // => 'foo bar' * * _.lowerCase('fooBar'); * // => 'foo bar' * * _.lowerCase('__FOO_BAR__'); * // => 'foo bar' */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toLowerCase(); }); /** * Converts the first character of `string` to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst('Fred'); * // => 'fred' * * _.lowerFirst('FRED'); * // => 'fRED' */ var lowerFirst = createCaseFirst('toLowerCase'); /** * Pads `string` on the left and right sides if it's shorter than `length`. * Padding characters are truncated if they can't be evenly divided by `length`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad('abc', 8); * // => ' abc ' * * _.pad('abc', 8, '_-'); * // => '_-abc_-_' * * _.pad('abc', 3); * // => 'abc' */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength >= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Pads `string` on the right side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd('abc', 6); * // => 'abc ' * * _.padEnd('abc', 6, '_-'); * // => 'abc_-_' * * _.padEnd('abc', 3); * // => 'abc' */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Pads `string` on the left side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart('abc', 6); * // => ' abc' * * _.padStart('abc', 6, '_-'); * // => '_-_abc' * * _.padStart('abc', 3); * // => 'abc' */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Converts `string` to an integer of the specified radix. If `radix` is * `undefined` or `0`, a `radix` of `10` is used unless `value` is a * hexadecimal, in which case a `radix` of `16` is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpret `value` by. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {number} Returns the converted integer. * @example * * _.parseInt('08'); * // => 8 * * _.map(['6', '08', '10'], _.parseInt); * // => [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0); } /** * Repeats the given string `n` times. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the repeated string. * @example * * _.repeat('*', 3); * // => '***' * * _.repeat('abc', 2); * // => 'abcabc' * * _.repeat('abc', 0); * // => '' */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches for `pattern` in `string` with `replacement`. * * **Note:** This method is based on * [`String#replace`](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace('Hi Fred', 'Fred', 'Barney'); * // => 'Hi Barney' */ function replace() { var args = arguments, string = toString(args[0]); return args.length < 3 ? string : string.replace(args[1], args[2]); } /** * Converts `string` to * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase('Foo Bar'); * // => 'foo_bar' * * _.snakeCase('fooBar'); * // => 'foo_bar' * * _.snakeCase('--FOO-BAR--'); * // => 'foo_bar' */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? '_' : '') + word.toLowerCase(); }); /** * Splits `string` by `separator`. * * **Note:** This method is based on * [`String#split`](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split('a-b-c', '-', 2); * // => ['a', 'b'] */ function split(string, separator, limit) { if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0; if (!limit) { return []; } string = toString(string); if (string && ( typeof separator == 'string' || (separator != null && !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator && hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Converts `string` to * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase('--foo-bar--'); * // => 'Foo Bar' * * _.startCase('fooBar'); * // => 'Foo Bar' * * _.startCase('__FOO_BAR__'); * // => 'FOO BAR' */ var startCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + upperFirst(word); }); /** * Checks if `string` starts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returns `true` if `string` starts with `target`, * else `false`. * @example * * _.startsWith('abc', 'a'); * // => true * * _.startsWith('abc', 'b'); * // => false * * _.startsWith('abc', 'b', 1); * // => true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in "interpolate" delimiters, HTML-escape interpolated data properties in * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over `_.templateSettings` values. * * **Note:** In the development build `_.template` utilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash's custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML "escape" delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The "evaluate" delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The "interpolate" delimiter. * @param {string} [options.sourceURL='lodash.templateSources[n]'] * The sourceURL of the compiled template. * @param {string} [options.variable='obj'] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Function} Returns the compiled template function. * @example * * // Use the "interpolate" delimiter to create a compiled template. * var compiled = _.template('hello !'); * compiled({ 'user': 'fred' }); * // => 'hello fred!' * * // Use the HTML "escape" delimiter to escape data property values. * var compiled = _.template(''); * compiled({ 'value': '' }); * // => '&lt;script&gt;' * * // Use the "evaluate" delimiter to execute JavaScript and generate HTML. * var compiled = _.template(''); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the internal `print` function in "evaluate" delimiters. * var compiled = _.template('!'); * compiled({ 'user': 'barney' }); * // => 'hello barney!' * * // Use the ES template literal delimiter as an "interpolate" delimiter. * // Disable support by replacing the "interpolate" delimiter. * var compiled = _.template('hello ${ user }!'); * compiled({ 'user': 'pebbles' }); * // => 'hello pebbles!' * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(''); * compiled({ 'value': 'ignored' }); * // => '' * * // Use the `imports` option to import `jQuery` as `jq`. * var text = ''; * var compiled = _.template(text, { 'imports': { 'jq': jQuery } }); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the `sourceURL` option to specify a custom sourceURL for the template. * var compiled = _.template('hello !', { 'sourceURL': '/basic/greeting.jst' }); * compiled(data); * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector. * * // Use the `variable` option to ensure a with-statement isn't used in the compiled template. * var compiled = _.template('hi !', { 'variable': 'data' }); * compiled.source; * // => function(data) { * // var __t, __p = ''; * // __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!'; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template('hello !'); * compiled({ 'user': 'mustache' }); * // => 'hello mustache!' * * // Use the `source` property to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\ * var JST = {\ * "main": ' + _.template(mainText).source + '\ * };\ * '); */ function template(string, options, guard) { // Based on John Resig's `tmpl` implementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova's doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard && isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '"; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$' , 'g'); // Use a sourceURL for easier debugging. var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']') ) + '\n'; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += "' +\n__e(" + escapeValue + ") +\n'"; } if (evaluateValue) { isEvaluating = true; source += "';\n" + evaluateValue + ";\n__p += '"; } if (interpolateValue) { source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"; } index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in // order to produce the correct `offset` value. return match; }); source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = 'with (obj) {\n' + source + '\n}\n'; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source) .replace(reEmptyStringMiddle, '$1') .replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body. source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n' ) + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '' ) + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n' ) + source + 'return __p\n}'; var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); // Provide the compiled function's source by its `toString` method or // the `source` property as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Converts `string`, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower('--Foo-Bar--'); * // => '--foo-bar--' * * _.toLower('fooBar'); * // => 'foobar' * * _.toLower('__FOO_BAR__'); * // => '__foo_bar__' */ function toLower(value) { return toString(value).toLowerCase(); } /** * Converts `string`, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper('--foo-bar--'); * // => '--FOO-BAR--' * * _.toUpper('fooBar'); * // => 'FOOBAR' * * _.toUpper('__foo_bar__'); * // => '__FOO_BAR__' */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trim(' abc '); * // => 'abc' * * _.trim('-_-abc-_-', '_-'); * // => 'abc' * * _.map([' foo ', ' bar '], _.trim); * // => ['foo', 'bar'] */ function trim(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrim, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(''); } /** * Removes trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(' abc '); * // => ' abc' * * _.trimEnd('-_-abc-_-', '_-'); * // => '-_-abc' */ function trimEnd(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimEnd, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(''); } /** * Removes leading whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(' abc '); * // => 'abc ' * * _.trimStart('-_-abc-_-', '_-'); * // => 'abc-_-' */ function trimStart(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimStart, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(''); } /** * Truncates `string` if it's longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to "...". * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission='...'] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate('hi-diddly-ho there, neighborino'); * // => 'hi-diddly-ho there, neighbo...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': ' ' * }); * // => 'hi-diddly-ho there,...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': /,? +/ * }); * // => 'hi-diddly-ho there...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'omission': ' [...]' * }); * // => 'hi-diddly-ho there, neig [...]' */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = 'separator' in options ? options.separator : separator; length = 'length' in options ? toInteger(options.length) : length; omission = 'omission' in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length >= strLength) { return string; } var end = length - stringSize(omission); if (end < 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g'); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index > -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of `_.escape`; this method converts the HTML entities * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=''] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape('fred, barney, &amp; pebbles'); * // => 'fred, barney, & pebbles' */ function unescape(string) { string = toString(string); return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Converts `string`, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase('--foo-bar'); * // => 'FOO BAR' * * _.upperCase('fooBar'); * // => 'FOO BAR' * * _.upperCase('__foo_bar__'); * // => 'FOO BAR' */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toUpperCase(); }); /** * Converts the first character of `string` to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst('fred'); * // => 'Fred' * * _.upperFirst('FRED'); * // => 'FRED' */ var upperFirst = createCaseFirst('toUpperCase'); /** * Splits `string` into an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Array} Returns the words of `string`. * @example * * _.words('fred, barney, & pebbles'); * // => ['fred', 'barney', 'pebbles'] * * _.words('fred, barney, & pebbles', /[^, ]+/g); * // => ['fred', 'barney', '&', 'pebbles'] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invoke `func` with. * @returns {*} Returns the `func` result or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, '>_>'); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn't set the "length" property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returns `object`. * @example * * var view = { * 'label': 'docs', * 'click': function() { * console.log('clicked ' + this.label); * } * }; * * _.bindAll(view, ['click']); * jQuery(element).on('click', view.click); * // => Logs 'clicked docs' when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ 'a': 1 }), _.constant('matches A')], * [_.conforms({ 'b': _.isNumber }), _.constant('matches B')], * [_.stubTrue, _.constant('no match')] * ]); * * func({ 'a': 1, 'b': 2 }); * // => 'matches A' * * func({ 'a': 0, 'b': 1 }); * // => 'matches B' * * func({ 'a': '1', 'b': '2' }); * // => 'no match' */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != 'function') { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index < length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `_.conformsTo` with * `source` partially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 2, 'b': 1 }, * { 'a': 1, 'b': 2 } * ]; * * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } })); * // => [{ 'a': 1, 'b': 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returns `value`. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ 'a': 1 })); * * console.log(objects); * // => [{ 'a': 1 }, { 'a': 1 }] * * console.log(objects[0] === objects[1]); * // => true */ function constant(value) { return function() { return value; }; } /** * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // => 1 * * _.defaultTo(undefined, 10); * // => 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with the `this` binding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // => 9 */ var flow = createFlow(); /** * This method is like `_.flow` except that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // => 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returns `value`. * @example * * var object = { 'a': 1 }; * * console.log(_.identity(object) === object); * // => true */ function identity(value) { return value; } /** * Creates a function that invokes `func` with the arguments of the created * function. If `func` is a property name, the created function returns the * property value for a given element. If `func` is an array or object, the * created function returns `true` for elements that contain the equivalent * source properties, otherwise it returns `false`. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { 'user': 'barney', 'age': 36, 'active': true }, * { 'user': 'fred', 'age': 40, 'active': false } * ]; * * // The `_.matches` iteratee shorthand. * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true })); * // => [{ 'user': 'barney', 'age': 36, 'active': true }] * * // The `_.matchesProperty` iteratee shorthand. * _.filter(users, _.iteratee(['user', 'fred'])); * // => [{ 'user': 'fred', 'age': 40 }] * * // The `_.property` iteratee shorthand. * _.map(users, _.iteratee('user')); * // => ['barney', 'fred'] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter(['abc', 'def'], /ef/); * // => ['def'] */ function iteratee(func) { return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object and `source`, returning `true` if the given object has equivalent * property values, else `false`. * * **Note:** The created function is equivalent to `_.isMatch` with `source` * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `_.isEqual` * for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.filter(objects, _.matches({ 'a': 4, 'c': 6 })); * // => [{ 'a': 4, 'b': 5, 'c': 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value at `path` of a given object to `srcValue`, returning `true` if the * object value is equivalent, else `false`. * * **Note:** Partial comparisons will match empty array and empty object * `srcValue` values against any array or object value, respectively. See * `_.isEqual` for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.find(objects, _.matchesProperty('a', 4)); * // => { 'a': 4, 'b': 5, 'c': 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method at `path` of a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { 'a': { 'b': _.constant(2) } }, * { 'a': { 'b': _.constant(1) } } * ]; * * _.map(objects, _.method('a.b')); * // => [2, 1] * * _.map(objects, _.method(['a', 'b'])); * // => [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of `_.method`; this method creates a function that invokes * the method at a given path of `object`. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.methodOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.methodOf(object)); * // => [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. If `object` is a function, then methods * are added to its prototype as well. * * **Note:** Use `_.runInContext` to create a pristine `lodash` function to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returns `object`. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ 'vowels': vowels }); * _.vowels('fred'); * // => ['e'] * * _('fred').vowels().value(); * // => ['e'] * * _.mixin({ 'vowels': vowels }, { 'chain': false }); * _('fred').vowels(); * // => ['e'] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null && !(isObject(source) && (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ 'func': func, 'args': arguments, 'thisArg': object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the `_` variable to its previous value and returns a reference to * the `lodash` function. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns the `lodash` function. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returns `undefined`. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // => [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at index `n`. If `n` is negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func('a', 'b', 'c', 'd'); * // => 'b' * * var func = _.nthArg(-2); * func('a', 'b', 'c', 'd'); * // => 'c' */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokes `iteratees` with the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // => [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => false * * func(NaN); * // => false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => true * * func(NaN); * // => false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value at `path` of a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { 'a': { 'b': 2 } }, * { 'a': { 'b': 1 } } * ]; * * _.map(objects, _.property('a.b')); * // => [2, 1] * * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b'); * // => [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of `_.property`; this method creates a function that returns * the value at a given path of `object`. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.propertyOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.propertyOf(object)); * // => [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from * `start` up to, but not including, `end`. A step of `-1` is used if a negative * `start` is specified without an `end` or `step`. If `end` is not specified, * it's set to `start` with `start` then set to `0`. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // => [0, 1, 2, 3] * * _.range(-4); * // => [0, -1, -2, -3] * * _.range(1, 5); * // => [1, 2, 3, 4] * * _.range(0, 20, 5); * // => [0, 5, 10, 15] * * _.range(0, -4, -1); * // => [0, -1, -2, -3] * * _.range(1, 4, 0); * // => [1, 1, 1] * * _.range(0); * // => [] */ var range = createRange(); /** * This method is like `_.range` except that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // => [3, 2, 1, 0] * * _.rangeRight(-4); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // => [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // => [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // => [1, 1, 1] * * _.rangeRight(0); * // => [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // => [[], []] * * console.log(arrays[0] === arrays[1]); * // => false */ function stubArray() { return []; } /** * This method returns `false`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `false`. * @example * * _.times(2, _.stubFalse); * // => [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // => [{}, {}] * * console.log(objects[0] === objects[1]); * // => false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // => ['', ''] */ function stubString() { return ''; } /** * This method returns `true`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `true`. * @example * * _.times(2, _.stubTrue); * // => [true, true] */ function stubTrue() { return true; } /** * Invokes the iteratee `n` times, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invoke `iteratee`. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // => ['0', '1', '2'] * * _.times(4, _.constant(0)); * // => [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n < 1 || n > MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index < n) { iteratee(index); } return result; } /** * Converts `value` to a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath('a.b.c'); * // => ['a', 'b', 'c'] * * _.toPath('a[0].b.c'); * // => ['a', '0', 'b', 'c'] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. If `prefix` is given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=''] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId('contact_'); * // => 'contact_104' * * _.uniqueId(); * // => '105' */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // => 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computes `number` rounded up to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // => 5 * * _.ceil(6.004, 2); * // => 6.01 * * _.ceil(6040, -2); * // => 6100 */ var ceil = createRound('ceil'); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // => 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computes `number` rounded down to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // => 4 * * _.floor(0.046, 2); * // => 0.04 * * _.floor(4060, -2); * // => 4000 */ var floor = createRound('floor'); /** * Computes the maximum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // => 8 * * _.max([]); * // => undefined */ function max(array) { return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like `_.max` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // => { 'n': 2 } * * // The `_.property` iteratee shorthand. * _.maxBy(objects, 'n'); * // => { 'n': 2 } */ function maxBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values in `array`. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // => 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like `_.mean` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // => 5 * * // The `_.property` iteratee shorthand. * _.meanBy(objects, 'n'); * // => 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // => 2 * * _.min([]); * // => undefined */ function min(array) { return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like `_.min` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // => { 'n': 1 } * * // The `_.property` iteratee shorthand. * _.minBy(objects, 'n'); * // => { 'n': 1 } */ function minBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // => 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computes `number` rounded to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // => 4 * * _.round(4.006, 2); * // => 4.01 * * _.round(4060, -2); * // => 4100 */ var round = createRound('round'); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // => 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values in `array`. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // => 20 */ function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; } /** * This method is like `_.sum` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // => 20 * * // The `_.property` iteratee shorthand. * _.sumBy(objects, 'n'); * // => 20 */ function sumBy(array, iteratee) { return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { 'chain': false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) { lodash[methodName].placeholder = lodash; }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants. arrayEach(['drop', 'take'], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ && !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') }); } return result; }; LazyWrapper.prototype[methodName + 'Right'] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // Add `LazyWrapper` methods that accept an `iteratee` value. arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // Add `LazyWrapper` methods for `_.head` and `_.last`. arrayEach(['head', 'last'], function(methodName, index) { var takeName = 'take' + (index ? 'Right' : ''); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`. arrayEach(['initial', 'tail'], function(methodName, index) { var dropName = 'drop' + (index ? '' : 'Right'); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == 'function') { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ && (start > 0 || end < 0)) { return new LazyWrapper(result); } if (start < 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end < 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // Add `LazyWrapper` methods to `lodash.prototype`. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker && chainAll) ? result[0] : result; }; if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) { // Avoid lazy use if the iteratee has a "length" value other than `1`. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid; if (!retUnwrapped && useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped && onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // Add `Array` methods to `lodash.prototype`. arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped && !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + ''), names = realNames[key] || (realNames[key] = []); names.push({ 'name': methodName, 'func': lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }]; // Add methods to `LazyWrapper`. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use `_.noConflict` to remove Lodash from the global object. root._ = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the "underscore" module. !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return _; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } // Check for `exports` after `define` in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = _; // Export for CommonJS support. freeExports._ = _; } else { // Export to the global object. root._ = _; } }.call(this)); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module))) /***/ }), /* 5 */ /***/ (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Prediction probabilities'; _classCallCheck(this, PredictProba); var width = parseInt(svg.style('width')); this.names = class_names; this.names.push('Other'); if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === '' ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars * (bar_height + space_between_bars) + bar_yshift; svg.style('height', this.svg_height + 'px'); var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) * i + bar_yshift; }; var bar = svg.append("g"); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == 'Other' && this.names.length > 20) { color = '#5F9EA0'; } var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", x_scale(data[i])).style("fill", color); bar.append("rect").attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", bar_width - 1).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); text = bar.append("text"); text.attr("x", bar_x + x_scale(data[i]) + 5).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif").text(data[i].toFixed(2)); text = bar.append("text"); text.attr("x", bar_x - 10).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(names[i]); while (text.node().getBBox()['width'] + 1 > class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + '...'); if (cur_text === '') { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length 4 && arguments[4] !== undefined ? arguments[4] : 'Predicted value'; var log_coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style('width')); this.color = _d2.default.scale.category10(); this.color('predicted_value'); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 * num_digits; var corner_padding = 5.5 * num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width * 2 - corner_padding * 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === '' ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = bar_yshift; var bar = svg.append("g"); //filled in bar representing predicted value in range var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(width_proportion)).style("fill", this.color); //empty box representing range bar.append("rect").attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(1)).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); //text for min value text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text("(min)"); //text for predicted value // console.log('bar height: ' + bar_height) text = bar.append("text"); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr("x", bar_x + x_scale(width_proportion)).attr("y", bar_y + bar_height + v_adjust_predicted_value_text).attr("fill", "black").attr("text-anchor", "middle").style("font", "14px tahoma, sans-serif"); //text for max value text = bar.append("text"); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif"); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif").text("(max)"); //readjust svg size // let svg_width = width + 1 * h_adjust; // svg.style('width', svg_width + 'px'); this.svg_height = n_bars * bar_height + bar_yshift + 2 * text.node().getBBox().height + 10; svg.style('height', this.svg_height + 'px'); if (log_coords) { console.log("svg width: " + svg_width); console.log("svg height: " + this.svg_height); console.log("bar_y: " + bar_y); console.log("bar_x: " + bar_x); console.log("Min value: " + min_value); console.log("Max value: " + max_value); console.log("Pred value: " + predicted_value); } }; exports.default = PredictedValue; /***/ }), /* 8 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {"use strict"; __webpack_require__(9); __webpack_require__(335); __webpack_require__(336); if (global._babelPolyfill) { throw new Error("only one instance of babel-polyfill is allowed"); } global._babelPolyfill = true; var DEFINE_PROPERTY = "defineProperty"; function define(O, key, value) { O[key] || Object[DEFINE_PROPERTY](O, key, { writable: true, configurable: true, value: value }); } define(String.prototype, "padLeft", "".padStart); define(String.prototype, "padRight", "".padEnd); "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) { [][key] && define(Array, key, Function.call.bind([][key])); }); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(10); __webpack_require__(59); __webpack_require__(60); __webpack_require__(61); __webpack_require__(62); __webpack_require__(64); __webpack_require__(67); __webpack_require__(68); __webpack_require__(69); __webpack_require__(70); __webpack_require__(71); __webpack_require__(72); __webpack_require__(73); __webpack_require__(74); __webpack_require__(75); __webpack_require__(77); __webpack_require__(79); __webpack_require__(81); __webpack_require__(83); __webpack_require__(86); __webpack_require__(87); __webpack_require__(88); __webpack_require__(92); __webpack_require__(94); __webpack_require__(96); __webpack_require__(99); __webpack_require__(100); __webpack_require__(101); __webpack_require__(102); __webpack_require__(104); __webpack_require__(105); __webpack_require__(106); __webpack_require__(107); __webpack_require__(108); __webpack_require__(109); __webpack_require__(110); __webpack_require__(112); __webpack_require__(113); __webpack_require__(114); __webpack_require__(116); __webpack_require__(117); __webpack_require__(118); __webpack_require__(120); __webpack_require__(122); __webpack_require__(123); __webpack_require__(124); __webpack_require__(125); __webpack_require__(126); __webpack_require__(127); __webpack_require__(128); __webpack_require__(129); __webpack_require__(130); __webpack_require__(131); __webpack_require__(132); __webpack_require__(133); __webpack_require__(134); __webpack_require__(139); __webpack_require__(140); __webpack_require__(144); __webpack_require__(145); __webpack_require__(146); __webpack_require__(147); __webpack_require__(149); __webpack_require__(150); __webpack_require__(151); __webpack_require__(152); __webpack_require__(153); __webpack_require__(154); __webpack_require__(155); __webpack_require__(156); __webpack_require__(157); __webpack_require__(158); __webpack_require__(159); __webpack_require__(160); __webpack_require__(161); __webpack_require__(162); __webpack_require__(163); __webpack_require__(165); __webpack_require__(166); __webpack_require__(168); __webpack_require__(169); __webpack_require__(175); __webpack_require__(176); __webpack_require__(178); __webpack_require__(179); __webpack_require__(180); __webpack_require__(184); __webpack_require__(185); __webpack_require__(186); __webpack_require__(187); __webpack_require__(188); __webpack_require__(190); __webpack_require__(191); __webpack_require__(192); __webpack_require__(193); __webpack_require__(196); __webpack_require__(198); __webpack_require__(199); __webpack_require__(200); __webpack_require__(202); __webpack_require__(204); __webpack_require__(206); __webpack_require__(208); __webpack_require__(209); __webpack_require__(210); __webpack_require__(214); __webpack_require__(215); __webpack_require__(216); __webpack_require__(218); __webpack_require__(228); __webpack_require__(232); __webpack_require__(233); __webpack_require__(235); __webpack_require__(236); __webpack_require__(240); __webpack_require__(241); __webpack_require__(243); __webpack_require__(244); __webpack_require__(245); __webpack_require__(246); __webpack_require__(247); __webpack_require__(248); __webpack_require__(249); __webpack_require__(250); __webpack_require__(251); __webpack_require__(252); __webpack_require__(253); __webpack_require__(254); __webpack_require__(255); __webpack_require__(256); __webpack_require__(257); __webpack_require__(258); __webpack_require__(259); __webpack_require__(260); __webpack_require__(261); __webpack_require__(263); __webpack_require__(264); __webpack_require__(265); __webpack_require__(266); __webpack_require__(267); __webpack_require__(269); __webpack_require__(270); __webpack_require__(271); __webpack_require__(273); __webpack_require__(274); __webpack_require__(275); __webpack_require__(276); __webpack_require__(277); __webpack_require__(278); __webpack_require__(279); __webpack_require__(280); __webpack_require__(282); __webpack_require__(283); __webpack_require__(285); __webpack_require__(286); __webpack_require__(287); __webpack_require__(288); __webpack_require__(291); __webpack_require__(292); __webpack_require__(294); __webpack_require__(295); __webpack_require__(296); __webpack_require__(297); __webpack_require__(299); __webpack_require__(300); __webpack_require__(301); __webpack_require__(302); __webpack_require__(303); __webpack_require__(304); __webpack_require__(305); __webpack_require__(306); __webpack_require__(307); __webpack_require__(308); __webpack_require__(310); __webpack_require__(311); __webpack_require__(312); __webpack_require__(313); __webpack_require__(314); __webpack_require__(315); __webpack_require__(316); __webpack_require__(317); __webpack_require__(318); __webpack_require__(319); __webpack_require__(320); __webpack_require__(322); __webpack_require__(323); __webpack_require__(324); __webpack_require__(325); __webpack_require__(326); __webpack_require__(327); __webpack_require__(328); __webpack_require__(329); __webpack_require__(330); __webpack_require__(331); __webpack_require__(332); __webpack_require__(333); __webpack_require__(334); module.exports = __webpack_require__(16); /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // ECMAScript 6 symbols shim var global = __webpack_require__(11); var has = __webpack_require__(12); var DESCRIPTORS = __webpack_require__(13); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var META = __webpack_require__(32).KEY; var $fails = __webpack_require__(14); var shared = __webpack_require__(28); var setToStringTag = __webpack_require__(33); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var wksExt = __webpack_require__(35); var wksDefine = __webpack_require__(36); var enumKeys = __webpack_require__(37); var isArray = __webpack_require__(52); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var createDesc = __webpack_require__(24); var _create = __webpack_require__(53); var gOPNExt = __webpack_require__(56); var $GOPD = __webpack_require__(58); var $DP = __webpack_require__(18); var $keys = __webpack_require__(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON && $JSON.stringify; var PROTOTYPE = 'prototype'; var HIDDEN = wks('_hidden'); var TO_PRIMITIVE = wks('toPrimitive'); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared('symbol-registry'); var AllSymbols = shared('symbols'); var OPSymbols = shared('op-symbols'); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == 'function'; var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS && $fails(function () { return _create(dP({}, 'a', { get: function () { return dP(this, 'a', { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) { return typeof it == 'symbol'; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l > i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!'); var tag = uid(arguments.length > 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], 'toString', function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames; __webpack_require__(51).f = $propertyIsEnumerable; __webpack_require__(50).f = $getOwnPropertySymbols; if (DESCRIPTORS && !__webpack_require__(29)) { redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables' ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F * !USE_NATIVE, 'Symbol', { // 19.4.2.1 Symbol.for(key) 'for': function (key) { return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!'); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F * !USE_NATIVE, 'Object', { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}'; })), 'JSON', { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length > i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == 'function') value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint) $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, 'JSON', true); /***/ }), /* 11 */ /***/ (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 12 */ /***/ (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(14)(function () { return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 14 */ /***/ (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var hide = __webpack_require__(17); var redefine = __webpack_require__(25); var ctx = __webpack_require__(30); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 16 */ /***/ (function(module, exports) { var core = module.exports = { version: '2.6.5' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var createDesc = __webpack_require__(24); module.exports = __webpack_require__(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { var anObject = __webpack_require__(19); var IE8_DOM_DEFINE = __webpack_require__(21); var toPrimitive = __webpack_require__(23); var dP = Object.defineProperty; exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { /* empty */ } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 20 */ /***/ (function(module, exports) { module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () { return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 22 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var document = __webpack_require__(11).document; // typeof document.createElement is 'object' in old IE var is = isObject(document) && isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; }; /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = __webpack_require__(20); // instead of the ES6 spec version, we didn't implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val; if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; throw TypeError("Can't convert object to primitive value"); }; /***/ }), /* 24 */ /***/ (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 25 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var hide = __webpack_require__(17); var has = __webpack_require__(12); var SRC = __webpack_require__(26)('src'); var $toString = __webpack_require__(27); var TO_STRING = 'toString'; var TPL = ('' + $toString).split(TO_STRING); __webpack_require__(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == 'function'; if (isFunction) has(val, 'name') || hide(val, 'name', key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == 'function' && this[SRC] || $toString.call(this); }); /***/ }), /* 26 */ /***/ (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 27 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(28)('native-function-to-string', Function.toString); /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { var core = __webpack_require__(16); var global = __webpack_require__(11); var SHARED = '__core-js_shared__'; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: core.version, mode: __webpack_require__(29) ? 'pure' : 'global', copyright: '© 2019 Denis Pushkarev (zloirock.ru)' }); /***/ }), /* 29 */ /***/ (function(module, exports) { module.exports = false; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { // optional / simple context binding var aFunction = __webpack_require__(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/* ...args */) { return fn.apply(that, arguments); }; }; /***/ }), /* 31 */ /***/ (function(module, exports) { module.exports = function (it) { if (typeof it != 'function') throw TypeError(it + ' is not a function!'); return it; }; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { var META = __webpack_require__(26)('meta'); var isObject = __webpack_require__(20); var has = __webpack_require__(12); var setDesc = __webpack_require__(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !__webpack_require__(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: 'O' + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return 'F'; // not necessary to add metadata if (!create) return 'E'; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze }; /***/ }), /* 33 */ /***/ (function(module, exports, __webpack_require__) { var def = __webpack_require__(18).f; var has = __webpack_require__(12); var TAG = __webpack_require__(34)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { var store = __webpack_require__(28)('wks'); var uid = __webpack_require__(26); var Symbol = __webpack_require__(11).Symbol; var USE_SYMBOL = typeof Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { exports.f = __webpack_require__(34); /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var LIBRARY = __webpack_require__(29); var wksExt = __webpack_require__(35); var defineProperty = __webpack_require__(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); }; /***/ }), /* 37 */ /***/ (function(module, exports, __webpack_require__) { // all enumerable object keys, includes symbols var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(39); var enumBugKeys = __webpack_require__(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { var has = __webpack_require__(12); var toIObject = __webpack_require__(40); var arrayIndexOf = __webpack_require__(44)(false); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys while (names.length > i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(41); var defined = __webpack_require__(43); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = __webpack_require__(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == 'String' ? it.split('') : Object(it); }; /***/ }), /* 42 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); }; /***/ }), /* 43 */ /***/ (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError("Can't call method on " + it); return it; }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { // false -> Array#indexOf // true -> Array#includes var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); var toAbsoluteIndex = __webpack_require__(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length > index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.15 ToLength var toInteger = __webpack_require__(46); var min = Math.min; module.exports = function (it) { return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 }; /***/ }), /* 46 */ /***/ (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it); }; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index < 0 ? max(index + length, 0) : min(index, length); }; /***/ }), /* 48 */ /***/ (function(module, exports, __webpack_require__) { var shared = __webpack_require__(28)('keys'); var uid = __webpack_require__(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); }; /***/ }), /* 49 */ /***/ (function(module, exports) { // IE 8- don't enum bug keys module.exports = ( 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf' ).split(','); /***/ }), /* 50 */ /***/ (function(module, exports) { exports.f = Object.getOwnPropertySymbols; /***/ }), /* 51 */ /***/ (function(module, exports) { exports.f = {}.propertyIsEnumerable; /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.2 IsArray(argument) var cof = __webpack_require__(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == 'Array'; }; /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(19); var dPs = __webpack_require__(54); var enumBugKeys = __webpack_require__(49); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var Empty = function () { /* empty */ }; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(22)('iframe'); var i = enumBugKeys.length; var lt = ''; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(55).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 54 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var anObject = __webpack_require__(19); var getKeys = __webpack_require__(38); module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length > i) dP.f(O, P = keys[i++], Properties[P]); return O; }; /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { var document = __webpack_require__(11).document; module.exports = document && document.documentElement; /***/ }), /* 56 */ /***/ (function(module, exports, __webpack_require__) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = __webpack_require__(40); var gOPN = __webpack_require__(57).f; var toString = {}.toString; var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it)); }; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = __webpack_require__(39); var hiddenKeys = __webpack_require__(49).concat('length', 'prototype'); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); }; /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { var pIE = __webpack_require__(51); var createDesc = __webpack_require__(24); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var IE8_DOM_DEFINE = __webpack_require__(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { /* empty */ } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); }; /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, 'Object', { create: __webpack_require__(53) }); /***/ }), /* 60 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(18).f }); /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(54) }); /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = __webpack_require__(40); var $getOwnPropertyDescriptor = __webpack_require__(58).f; __webpack_require__(63)('getOwnPropertyDescriptor', function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; }); /***/ }), /* 63 */ /***/ (function(module, exports, __webpack_require__) { // most Object methods by ES6 should accept primitives var $export = __webpack_require__(15); var core = __webpack_require__(16); var fails = __webpack_require__(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp); }; /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = __webpack_require__(65); var $getPrototypeOf = __webpack_require__(66); __webpack_require__(63)('getPrototypeOf', function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; }); /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.13 ToObject(argument) var defined = __webpack_require__(43); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = __webpack_require__(12); var toObject = __webpack_require__(65); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; }; /***/ }), /* 67 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 Object.keys(O) var toObject = __webpack_require__(65); var $keys = __webpack_require__(38); __webpack_require__(63)('keys', function () { return function keys(it) { return $keys(toObject(it)); }; }); /***/ }), /* 68 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 Object.getOwnPropertyNames(O) __webpack_require__(63)('getOwnPropertyNames', function () { return __webpack_require__(56).f; }); /***/ }), /* 69 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.5 Object.freeze(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('freeze', function ($freeze) { return function freeze(it) { return $freeze && isObject(it) ? $freeze(meta(it)) : it; }; }); /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.17 Object.seal(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('seal', function ($seal) { return function seal(it) { return $seal && isObject(it) ? $seal(meta(it)) : it; }; }); /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.15 Object.preventExtensions(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('preventExtensions', function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it; }; }); /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.12 Object.isFrozen(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isFrozen', function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; }); /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.13 Object.isSealed(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isSealed', function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; }); /***/ }), /* 74 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.11 Object.isExtensible(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isExtensible', function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; }); /***/ }), /* 75 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.1 Object.assign(target, source) var $export = __webpack_require__(15); $export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) }); /***/ }), /* 76 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.1 Object.assign(target, source, ...) var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || __webpack_require__(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = 'abcdefghijklmnopqrst'; A[S] = 7; K.split('').forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen > index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.10 Object.is(value1, value2) var $export = __webpack_require__(15); $export($export.S, 'Object', { is: __webpack_require__(78) }); /***/ }), /* 78 */ /***/ (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y; }; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = __webpack_require__(15); $export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set }); /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { // Works with __proto__ only. Old v8 can't work with null proto objects. /* eslint-disable no-proto */ var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!"); }; module.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line function (test, buggy, set) { try { set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.__proto__ = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check }; /***/ }), /* 81 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.3.6 Object.prototype.toString() var classof = __webpack_require__(82); var test = {}; test[__webpack_require__(34)('toStringTag')] = 'z'; if (test + '' != '[object z]') { __webpack_require__(25)(Object.prototype, 'toString', function toString() { return '[object ' + classof(this) + ']'; }, true); } /***/ }), /* 82 */ /***/ (function(module, exports, __webpack_require__) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = __webpack_require__(42); var TAG = __webpack_require__(34)('toStringTag'); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == 'Arguments'; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { /* empty */ } }; module.exports = function (it) { var O, T, B; return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B; }; /***/ }), /* 83 */ /***/ (function(module, exports, __webpack_require__) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...) var $export = __webpack_require__(15); $export($export.P, 'Function', { bind: __webpack_require__(84) }); /***/ }), /* 84 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var aFunction = __webpack_require__(31); var isObject = __webpack_require__(20); var invoke = __webpack_require__(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')'); } return factories[len](F, args); }; module.exports = Function.bind || function bind(that /* , ...args */) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/* args... */) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; }; /***/ }), /* 85 */ /***/ (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); }; /***/ }), /* 86 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18).f; var FProto = Function.prototype; var nameRE = /^\s*function ([^ (]*)/; var NAME = 'name'; // 19.2.4.2 name NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, { configurable: true, get: function () { try { return ('' + this).match(nameRE)[1]; } catch (e) { return ''; } } }); /***/ }), /* 87 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(20); var getPrototypeOf = __webpack_require__(66); var HAS_INSTANCE = __webpack_require__(34)('hasInstance'); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V) if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != 'function' || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } }); /***/ }), /* 88 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseInt = __webpack_require__(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt }); /***/ }), /* 89 */ /***/ (function(module, exports, __webpack_require__) { var $parseInt = __webpack_require__(11).parseInt; var $trim = __webpack_require__(90).trim; var ws = __webpack_require__(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10)); } : $parseInt; /***/ }), /* 90 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var defined = __webpack_require__(43); var fails = __webpack_require__(14); var spaces = __webpack_require__(91); var space = '[' + spaces + ']'; var non = '\u200b\u0085'; var ltrim = RegExp('^' + space + space + '*'); var rtrim = RegExp(space + space + '*$'); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spaces[KEY]() || non[KEY]() != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F * FORCE, 'String', exp); }; // 1 -> String#trimLeft // 2 -> String#trimRight // 3 -> String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE & 1) string = string.replace(ltrim, ''); if (TYPE & 2) string = string.replace(rtrim, ''); return string; }; module.exports = exporter; /***/ }), /* 91 */ /***/ (function(module, exports) { module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'; /***/ }), /* 92 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseFloat = __webpack_require__(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat }); /***/ }), /* 93 */ /***/ (function(module, exports, __webpack_require__) { var $parseFloat = __webpack_require__(11).parseFloat; var $trim = __webpack_require__(90).trim; module.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 && string.charAt(0) == '-' ? -0 : result; } : $parseFloat; /***/ }), /* 94 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var has = __webpack_require__(12); var cof = __webpack_require__(42); var inheritIfRequired = __webpack_require__(95); var toPrimitive = __webpack_require__(23); var fails = __webpack_require__(14); var gOPN = __webpack_require__(57).f; var gOPD = __webpack_require__(58).f; var dP = __webpack_require__(18).f; var $trim = __webpack_require__(90).trim; var NUMBER = 'Number'; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER; var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == 'string' && it.length > 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code < 48 || code > maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) { $Number = function Number(value) { var it = arguments.length < 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = __webpack_require__(13) ? gOPN(Base) : ( // ES3: 'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before): 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger' ).split(','), j = 0, key; keys.length > j; j++) { if (has(Base, key = keys[j]) && !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; __webpack_require__(25)(global, NUMBER, $Number); } /***/ }), /* 95 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var setPrototypeOf = __webpack_require__(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) { setPrototypeOf(that, P); } return that; }; /***/ }), /* 96 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toInteger = __webpack_require__(46); var aNumberValue = __webpack_require__(97); var repeat = __webpack_require__(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = 'Number.toFixed: incorrect invocation!'; var ZERO = '0'; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i < 6) { c2 += n * data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (--i >= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) * 1e7; } }; var numToString = function () { var i = 6; var s = ''; while (--i >= 0) { if (s !== '' || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 >= 4096) { n += 12; x2 /= 4096; } while (x2 >= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F * (!!$toFixed && ( 0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128' ) || !__webpack_require__(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), 'Number', { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ''; var m = ZERO; var e, z, j, k; if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return 'NaN'; if (x = 1e21) return String(x); if (x < 0) { s = '-'; x = -x; } if (x > 1e-21) { e = log(x * pow(2, 69, 1)) - 69; z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1); z *= 0x10000000000000; e = 52 - e; if (e > 0) { multiply(0, z); j = f; while (j >= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j >= 23) { divide(1 < 23); j -= 23; } divide(1 < j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 < -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f > 0) { k = m.length; m = s + (k -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x); }; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.5 Math.asinh(x) var $export = __webpack_require__(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1)); } // Tor Browser bug: Math.asinh(0) -> -0 $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh }); /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.7 Math.atanh(x) var $export = __webpack_require__(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0 $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } }); /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.9 Math.cbrt(x) var $export = __webpack_require__(15); var sign = __webpack_require__(115); $export($export.S, 'Math', { cbrt: function cbrt(x) { return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3); } }); /***/ }), /* 115 */ /***/ (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1; }; /***/ }), /* 116 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.11 Math.clz32(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { clz32: function clz32(x) { return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32; } }); /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.12 Math.cosh(x) var $export = __webpack_require__(15); var exp = Math.exp; $export($export.S, 'Math', { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } }); /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.14 Math.expm1(x) var $export = __webpack_require__(15); var $expm1 = __webpack_require__(119); $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 }); /***/ }), /* 119 */ /***/ (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1; } : $expm1; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { fround: __webpack_require__(121) }); /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var sign = __webpack_require__(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) * (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32; a = (1 + EPSILON32 / EPSILON) * $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result > MAX32 || result != result) return $sign * Infinity; return $sign * result; }; /***/ }), /* 122 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = __webpack_require__(15); var abs = Math.abs; $export($export.S, 'Math', { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i < aLen) { arg = abs(arguments[i++]); if (larg < arg) { div = larg / arg; sum = sum * div * div + 1; larg = arg; } else if (arg > 0) { div = arg / larg; sum += div * div; } else sum += arg; } return larg === Infinity ? Infinity : larg * Math.sqrt(sum); } }); /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.18 Math.imul(x, y) var $export = __webpack_require__(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F * __webpack_require__(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), 'Math', { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 & xn; var yl = UINT16 & yn; return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) < 16 >>> 0); } }); /***/ }), /* 124 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.21 Math.log10(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log10: function log10(x) { return Math.log(x) * Math.LOG10E; } }); /***/ }), /* 125 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.20 Math.log1p(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log1p: __webpack_require__(111) }); /***/ }), /* 126 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.22 Math.log2(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log2: function log2(x) { return Math.log(x) / Math.LN2; } }); /***/ }), /* 127 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.28 Math.sign(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { sign: __webpack_require__(115) }); /***/ }), /* 128 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.30 Math.sinh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F * __webpack_require__(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), 'Math', { sinh: function sinh(x) { return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2); } }); /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.33 Math.tanh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; $export($export.S, 'Math', { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } }); /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.34 Math.trunc(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { trunc: function trunc(it) { return (it > 0 ? Math.floor : Math.ceil)(it); } }); /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toAbsoluteIndex = __webpack_require__(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', { // 21.1.2.2 String.fromCodePoint(...codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen > i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point'); res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(''); } }); /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); $export($export.S, 'String', { // 21.1.2.4 String.raw(callSite, ...substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len > i) { res.push(String(tpl[i++])); if (i < aLen) res.push(String(arguments[i])); } return res.join(''); } }); /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.1.3.25 String.prototype.trim() __webpack_require__(90)('trim', function ($trim) { return function trim() { return $trim(this, 3); }; }); /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $at = __webpack_require__(135)(true); // 21.1.3.27 String.prototype[@@iterator]() __webpack_require__(136)(String, 'String', function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index >= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; }); /***/ }), /* 135 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var defined = __webpack_require__(43); // true -> String#at // false -> String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i < 0 || i >= l) return TO_STRING ? '' : undefined; a = s.charCodeAt(i); return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 < 10) + (b - 0xdc00) + 0x10000; }; }; /***/ }), /* 136 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var LIBRARY = __webpack_require__(29); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var $iterCreate = __webpack_require__(138); var setToStringTag = __webpack_require__(33); var getPrototypeOf = __webpack_require__(66); var ITERATOR = __webpack_require__(34)('iterator'); var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next` var FF_ITERATOR = '@@iterator'; var KEYS = 'keys'; var VALUES = 'values'; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY && kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ' Iterator'; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined; var $anyNative = NAME == 'Array' ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES && $native && $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods); } return methods; }; /***/ }), /* 137 */ /***/ (function(module, exports) { module.exports = {}; /***/ }), /* 138 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var create = __webpack_require__(53); var descriptor = __webpack_require__(24); var setToStringTag = __webpack_require__(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]() __webpack_require__(17)(IteratorPrototype, __webpack_require__(34)('iterator'), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ' Iterator'); }; /***/ }), /* 139 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $at = __webpack_require__(135)(false); $export($export.P, 'String', { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } }); /***/ }), /* 140 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var ENDS_WITH = 'endsWith'; var $endsWith = ''[ENDS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', { endsWith: function endsWith(searchString /* , endPosition = @length */) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length > 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } }); /***/ }), /* 141 */ /***/ (function(module, exports, __webpack_require__) { // helper for String#{startsWith, endsWith, includes} var isRegExp = __webpack_require__(142); var defined = __webpack_require__(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!"); return String(defined(that)); }; /***/ }), /* 142 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.8 IsRegExp(argument) var isObject = __webpack_require__(20); var cof = __webpack_require__(42); var MATCH = __webpack_require__(34)('match'); module.exports = function (it) { var isRegExp; return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp'); }; /***/ }), /* 143 */ /***/ (function(module, exports, __webpack_require__) { var MATCH = __webpack_require__(34)('match'); module.exports = function (KEY) { var re = /./; try { '/./'[KEY](re); } catch (e) { try { re[MATCH] = false; return !'/./'[KEY](re); } catch (f) { /* empty */ } } return true; }; /***/ }), /* 144 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) 'use strict'; var $export = __webpack_require__(15); var context = __webpack_require__(141); var INCLUDES = 'includes'; $export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', { includes: function includes(searchString /* , position = 0 */) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined); } }); /***/ }), /* 145 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.P, 'String', { // 21.1.3.13 String.prototype.repeat(count) repeat: __webpack_require__(98) }); /***/ }), /* 146 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var STARTS_WITH = 'startsWith'; var $startsWith = ''[STARTS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', { startsWith: function startsWith(searchString /* , position = 0 */) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } }); /***/ }), /* 147 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // B.2.3.2 String.prototype.anchor(name) __webpack_require__(148)('anchor', function (createHTML) { return function anchor(name) { return createHTML(this, 'a', 'name', name); }; }); /***/ }), /* 148 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ' Array#map // 2 -> Array#filter // 3 -> Array#some // 4 -> Array#every // 5 -> Array#find // 6 -> Array#findIndex var ctx = __webpack_require__(30); var IObject = __webpack_require__(41); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var asc = __webpack_require__(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length > index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; }; /***/ }), /* 182 */ /***/ (function(module, exports, __webpack_require__) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = __webpack_require__(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); }; /***/ }), /* 183 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var isArray = __webpack_require__(52); var SPECIES = __webpack_require__(34)('species'); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; }; /***/ }), /* 184 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $map = __webpack_require__(181)(1); $export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn /* , thisArg */) { return $map(this, callbackfn, arguments[1]); } }); /***/ }), /* 185 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $filter = __webpack_require__(181)(2); $export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn /* , thisArg */) { return $filter(this, callbackfn, arguments[1]); } }); /***/ }), /* 186 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $some = __webpack_require__(181)(3); $export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn /* , thisArg */) { return $some(this, callbackfn, arguments[1]); } }); /***/ }), /* 187 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $every = __webpack_require__(181)(4); $export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn /* , thisArg */) { return $every(this, callbackfn, arguments[1]); } }); /***/ }), /* 188 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } }); /***/ }), /* 189 */ /***/ (function(module, exports, __webpack_require__) { var aFunction = __webpack_require__(31); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var toLength = __webpack_require__(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen < 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index < 0 : length = 0 : length > index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; }; /***/ }), /* 190 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } }); /***/ }), /* 191 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $indexOf = __webpack_require__(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement /* , fromIndex = 0 */) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } }); /***/ }), /* 192 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1])); if (index < 0) index = length + index; for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } }); /***/ }), /* 193 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { copyWithin: __webpack_require__(194) }); __webpack_require__(195)('copyWithin'); /***/ }), /* 194 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length > 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from < to && to < from + count) { inc = -1; from += count - 1; to += count - 1; } while (count-- > 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; }; /***/ }), /* 195 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = __webpack_require__(34)('unscopables'); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; }; /***/ }), /* 196 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { fill: __webpack_require__(197) }); __webpack_require__(195)('fill'); /***/ }), /* 197 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = function fill(value /* , start = 0, end = @length */) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length); var end = aLen > 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos > index) O[index++] = value; return O; }; /***/ }), /* 198 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(5); var KEY = 'find'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { find: function find(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 199 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(6); var KEY = 'findIndex'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { findIndex: function findIndex(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 200 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(201)('Array'); /***/ }), /* 201 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var dP = __webpack_require__(18); var DESCRIPTORS = __webpack_require__(13); var SPECIES = __webpack_require__(34)('species'); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); }; /***/ }), /* 202 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var addToUnscopables = __webpack_require__(195); var step = __webpack_require__(203); var Iterators = __webpack_require__(137); var toIObject = __webpack_require__(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype[@@iterator]() module.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index >= O.length) { this._t = undefined; return step(1); } if (kind == 'keys') return step(0, index); if (kind == 'values') return step(0, O[index]); return step(0, [index, O[index]]); }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries'); /***/ }), /* 203 */ /***/ (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; }; /***/ }), /* 204 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var inheritIfRequired = __webpack_require__(95); var dP = __webpack_require__(18).f; var gOPN = __webpack_require__(57).f; var isRegExp = __webpack_require__(142); var $flags = __webpack_require__(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // "new" creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(14)(function () { re2[__webpack_require__(34)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i'; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; __webpack_require__(25)(global, 'RegExp', $RegExp); } __webpack_require__(201)('RegExp'); /***/ }), /* 205 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.2.5.3 get RegExp.prototype.flags var anObject = __webpack_require__(19); module.exports = function () { var that = anObject(this); var result = ''; if (that.global) result += 'g'; if (that.ignoreCase) result += 'i'; if (that.multiline) result += 'm'; if (that.unicode) result += 'u'; if (that.sticky) result += 'y'; return result; }; /***/ }), /* 206 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpExec = __webpack_require__(207); __webpack_require__(15)({ target: 'RegExp', proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec }); /***/ }), /* 207 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpFlags = __webpack_require__(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = 'lastIndex'; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b*/g; nativeExec.call(re1, 'a'); nativeExec.call(re2, 'a'); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim's String#split patch. var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG && match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED && match && match.length > 1) { // Fix browsers whose `exec` methods don't consistently return `undefined` // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i < arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec; /***/ }), /* 208 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(209); var anObject = __webpack_require__(19); var $flags = __webpack_require__(205); var DESCRIPTORS = __webpack_require__(13); var TO_STRING = 'toString'; var $toString = /./[TO_STRING]; var define = function (fn) { __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (__webpack_require__(14)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) { define(function toString() { var R = anObject(this); return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); } /***/ }), /* 209 */ /***/ (function(module, exports, __webpack_require__) { // 21.2.5.3 get RegExp.prototype.flags() if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(18).f(RegExp.prototype, 'flags', { configurable: true, get: __webpack_require__(205) }); /***/ }), /* 210 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toLength = __webpack_require__(45); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); // @@match logic __webpack_require__(213)('match', 1, function (defined, MATCH, $match, maybeCallNative) { return [ // `String.prototype.match` method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O)); }, // `RegExp.prototype[@@match]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; }); /***/ }), /* 211 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var at = __webpack_require__(135)(true); // `AdvanceStringIndex` abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); }; /***/ }), /* 212 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var classof = __webpack_require__(82); var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === 'function') { var result = exec.call(R, S); if (typeof result !== 'object') { throw new TypeError('RegExp exec method returned something other than an Object or null'); } return result; } if (classof(R) !== 'RegExp') { throw new TypeError('RegExp#exec called on incompatible receiver'); } return builtinExec.call(R, S); }; /***/ }), /* 213 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(206); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var wks = __webpack_require__(34); var regexpExec = __webpack_require__(207); var SPECIES = wks('species'); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a "grops" property. var re = /./; re.exec = function () { var result = []; result.groups = { a: '7' }; return result; }; return ''.replace(re, '$') !== '7'; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = 'ab'.split(re); return result.length === 2 && result[0] === 'a' && result[1] === 'b'; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ''[KEY](O) != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === 'split') { // RegExp[@@split] doesn't call the regex's exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } re[SYMBOL](''); return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL && !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue) // 21.2.5.11 RegExp.prototype[@@split](string, limit) ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype[@@match](string) // 21.2.5.9 RegExp.prototype[@@search](string) : function (string) { return rxfn.call(string, this); } ); } }; /***/ }), /* 214 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|]*>)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ // `String.prototype.replace` method // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, // `RegExp.prototype[@@replace]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === 'function'; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = ''; var nextSourcePosition = 0; for (var i = 0; i < results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reason `nativeSlice.call(result, 1, result.length)` (called in // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position >= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case '$': return '$'; case '&': return matched; case '`': return str.slice(0, position); case "'": return str.slice(tailPos); case '>> 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q < S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i 0; m = m * 256 + buffer[i], i--, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) * m * pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] < 24 | bytes[2] < 16 | bytes[1] < 8 | bytes[0]; } function packI8(it) { return [it & 0xff]; } function packI16(it) { return [it & 0xff, it >> 8 & 0xff]; } function packI32(it) { return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!'); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, '_l'); addGetter($DataView, BUFFER, '_b'); addGetter($DataView, BYTE_LENGTH, '_l'); addGetter($DataView, BYTE_OFFSET, '_o'); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] < 24 >> 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] < 8 | bytes[0]) < 16 >> 16; }, getUint16: function getUint16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] < 8 | bytes[0]; }, getInt32: function getInt32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0; }, getFloat32: function getFloat32(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView; /***/ }), /* 239 */ /***/ (function(module, exports, __webpack_require__) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError('Wrong length!'); return length; }; /***/ }), /* 240 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.G + $export.W + $export.F * !__webpack_require__(237).ABV, { DataView: __webpack_require__(238).DataView }); /***/ }), /* 241 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int8', 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 242 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; if (__webpack_require__(13)) { var LIBRARY = __webpack_require__(29); var global = __webpack_require__(11); var fails = __webpack_require__(14); var $export = __webpack_require__(15); var $typed = __webpack_require__(237); var $buffer = __webpack_require__(238); var ctx = __webpack_require__(30); var anInstance = __webpack_require__(219); var propertyDesc = __webpack_require__(24); var hide = __webpack_require__(17); var redefineAll = __webpack_require__(227); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var toIndex = __webpack_require__(239); var toAbsoluteIndex = __webpack_require__(47); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var classof = __webpack_require__(82); var isObject = __webpack_require__(20); var toObject = __webpack_require__(65); var isArrayIter = __webpack_require__(171); var create = __webpack_require__(53); var getPrototypeOf = __webpack_require__(66); var gOPN = __webpack_require__(57).f; var getIterFn = __webpack_require__(173); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var createArrayMethod = __webpack_require__(181); var createArrayIncludes = __webpack_require__(44); var speciesConstructor = __webpack_require__(217); var ArrayIterators = __webpack_require__(202); var Iterators = __webpack_require__(137); var $iterDetect = __webpack_require__(174); var setSpecies = __webpack_require__(201); var arrayFill = __webpack_require__(197); var arrayCopyWithin = __webpack_require__(194); var $DP = __webpack_require__(18); var $GOPD = __webpack_require__(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = 'ArrayBuffer'; var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER; var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'; var PROTOTYPE = 'prototype'; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks('iterator'); var TAG = wks('toStringTag'); var TYPED_CONSTRUCTOR = uid('typed_constructor'); var DEF_CONSTRUCTOR = uid('def_constructor'); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = 'Wrong length!'; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!'); return offset; }; var validate = function (it) { if (isObject(it) && TYPED_ARRAY in it) return it; throw TypeError(it + ' is not a typed array!'); }; var allocate = function (C, length) { if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) { throw TypeError('It is not a typed array constructor!'); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length > index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source /* , mapfn, thisArg */) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen > 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined && !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/* ...items */) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length > index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start /* , end */) { return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined); }, every: function every(callbackfn /* , thisArg */) { return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn /* , thisArg */) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)); }, find: function find(predicate /* , thisArg */) { return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate /* , thisArg */) { return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn /* , thisArg */) { arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement /* , fromIndex */) { return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, includes: function includes(searchElement /* , fromIndex */) { return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn /* , thisArg */) { return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index < middle) { value = that[index]; that[index++] = that[--length]; that[length] = value; } return that; }, some: function some(callbackfn /* , thisArg */) { return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike /* , offset */) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset > length) throw RangeError(WRONG_LENGTH); while (index < len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { /* noop */ }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, 'buffer', 'b'); addGetter($TypedArrayPrototype$, 'byteOffset', 'o'); addGetter($TypedArrayPrototype$, 'byteLength', 'l'); addGetter($TypedArrayPrototype$, 'length', 'e'); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'; var GETTER = 'get' + KEY; var SETTER = 'set' + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray && getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff; data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN); }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, '_d'); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length * BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength < 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) * BYTES; if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, '_d', { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index < length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, 'constructor', TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // `ws` module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F * (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F * FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F * fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F * (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { /* empty */ }; /***/ }), /* 243 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 244 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true); /***/ }), /* 245 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int16', 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 246 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint16', 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 247 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int32', 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 248 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint32', 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 249 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float32', 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 250 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float64', 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 251 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = __webpack_require__(15); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var rApply = (__webpack_require__(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F * !__webpack_require__(14)(function () { rApply(function () { /* empty */ }); }), 'Reflect', { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } }); /***/ }), /* 252 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = __webpack_require__(15); var create = __webpack_require__(53); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var fails = __webpack_require__(14); var bind = __webpack_require__(84); var rConstruct = (__webpack_require__(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as `new.target`, but does not create `this` from it var NEW_TARGET_BUG = fails(function () { function F() { /* empty */ } return !(rConstruct(function () { /* empty */ }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { /* empty */ }); }); $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', { construct: function construct(Target, args /* , newTarget */) { aFunction(Target); anObject(args); var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } }); /***/ }), /* 253 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = __webpack_require__(18); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var toPrimitive = __webpack_require__(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F * __webpack_require__(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), 'Reflect', { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } }); /***/ }), /* 254 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = __webpack_require__(15); var gOPD = __webpack_require__(58).f; var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc && !desc.configurable ? false : delete target[propertyKey]; } }); /***/ }), /* 255 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 26.1.5 Reflect.enumerate(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; __webpack_require__(138)(Enumerate, 'Object', function () { var that = this; var keys = that._k; var key; do { if (that._i >= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, 'Reflect', { enumerate: function enumerate(target) { return new Enumerate(target); } }); /***/ }), /* 256 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); function get(target, propertyKey /* , receiver */) { var receiver = arguments.length < 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, 'Reflect', { get: get }); /***/ }), /* 257 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = __webpack_require__(58); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } }); /***/ }), /* 258 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = __webpack_require__(15); var getProto = __webpack_require__(66); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } }); /***/ }), /* 259 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.9 Reflect.has(target, propertyKey) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { has: function has(target, propertyKey) { return propertyKey in target; } }); /***/ }), /* 260 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.10 Reflect.isExtensible(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $isExtensible = Object.isExtensible; $export($export.S, 'Reflect', { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } }); /***/ }), /* 261 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.11 Reflect.ownKeys(target) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { ownKeys: __webpack_require__(262) }); /***/ }), /* 262 */ /***/ (function(module, exports, __webpack_require__) { // all object keys, includes non-enumerable and symbols var gOPN = __webpack_require__(57); var gOPS = __webpack_require__(50); var anObject = __webpack_require__(19); var Reflect = __webpack_require__(11).Reflect; module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; }; /***/ }), /* 263 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.12 Reflect.preventExtensions(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $preventExtensions = Object.preventExtensions; $export($export.S, 'Reflect', { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } }); /***/ }), /* 264 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = __webpack_require__(18); var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var createDesc = __webpack_require__(24); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); function set(target, propertyKey, V /* , receiver */) { var receiver = arguments.length < 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, 'value')) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, 'Reflect', { set: set }); /***/ }), /* 265 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = __webpack_require__(15); var setProto = __webpack_require__(80); if (setProto) $export($export.S, 'Reflect', { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } }); /***/ }), /* 266 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/Array.prototype.includes var $export = __webpack_require__(15); var $includes = __webpack_require__(44)(true); $export($export.P, 'Array', { includes: function includes(el /* , fromIndex = 0 */) { return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)('includes'); /***/ }), /* 267 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var aFunction = __webpack_require__(31); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatMap: function flatMap(callbackfn /* , thisArg */) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); __webpack_require__(195)('flatMap'); /***/ }), /* 268 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = __webpack_require__(52); var isObject = __webpack_require__(20); var toLength = __webpack_require__(45); var ctx = __webpack_require__(30); var IS_CONCAT_SPREADABLE = __webpack_require__(34)('isConcatSpreadable'); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex < sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable && depth > 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex >= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray; /***/ }), /* 269 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatten: function flatten(/* depthArg = 1 */) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); __webpack_require__(195)('flatten'); /***/ }), /* 270 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/mathiasbynens/String.prototype.at var $export = __webpack_require__(15); var $at = __webpack_require__(135)(true); $export($export.P, 'String', { at: function at(pos) { return $at(this, pos); } }); /***/ }), /* 271 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-string-pad-start-end var $export = __webpack_require__(15); var $pad = __webpack_require__(272); var userAgent = __webpack_require__(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F * WEBKIT_BUG, 'String', { padStart: function padStart(maxLength /* , fillString = ' ' */) { return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true); } }); /***/ }), /* 272 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = __webpack_require__(45); var repeat = __webpack_require__(98); var defined = __webpack_require__(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ' ' : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength 0; var $y0 = y0 >>> 0; return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0; } }); /***/ }), /* 311 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 >>> 0; var $x1 = x1 >>> 0; var $y0 = y0 >>> 0; return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0; } }); /***/ }), /* 312 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >> 16; var v1 = $v >> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16); } }); /***/ }), /* 313 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI }); /***/ }), /* 314 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, 'Math', { radians: function radians(degrees) { return degrees * DEG_PER_RAD; } }); /***/ }), /* 315 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { scale: __webpack_require__(309) }); /***/ }), /* 316 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >>> 16; var v1 = $v >>> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16); } }); /***/ }), /* 317 */ /***/ (function(module, exports, __webpack_require__) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = __webpack_require__(15); $export($export.S, 'Math', { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0; } }); /***/ }), /* 318 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-promise-finally 'use strict'; var $export = __webpack_require__(15); var core = __webpack_require__(16); var global = __webpack_require__(11); var speciesConstructor = __webpack_require__(217); var promiseResolve = __webpack_require__(226); $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == 'function'; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } }); /***/ }), /* 319 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-promise-try var $export = __webpack_require__(15); var newPromiseCapability = __webpack_require__(223); var perform = __webpack_require__(224); $export($export.S, 'Promise', { 'try': function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } }); /***/ }), /* 320 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } }); /***/ }), /* 321 */ /***/ (function(module, exports, __webpack_require__) { var Map = __webpack_require__(228); var $export = __webpack_require__(15); var shared = __webpack_require__(28)('metadata'); var store = shared.store || (shared.store = new (__webpack_require__(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == 'symbol' ? it : String(it); }; var exp = function (O) { $export($export.S, 'Reflect', O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp }; /***/ }), /* 322 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) { var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata['delete'](targetKey); return !!targetMetadata.size || store['delete'](target); } }); /***/ }), /* 323 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 324 */ /***/ (function(module, exports, __webpack_require__) { var Set = __webpack_require__(232); var from = __webpack_require__(290); var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) { return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 325 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 326 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 327 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 328 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 329 */ /***/ (function(module, exports, __webpack_require__) { var $metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var aFunction = __webpack_require__(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } }); /***/ }), /* 330 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = __webpack_require__(15); var microtask = __webpack_require__(222)(); var process = __webpack_require__(11).process; var isNode = __webpack_require__(42)(process) == 'process'; $export($export.G, { asap: function asap(fn) { var domain = isNode && process.domain; microtask(domain ? domain.bind(fn) : fn); } }); /***/ }), /* 331 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/zenparsing/es-observable var $export = __webpack_require__(15); var global = __webpack_require__(11); var core = __webpack_require__(16); var microtask = __webpack_require__(222)(); var OBSERVABLE = __webpack_require__(34)('observable'); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var anInstance = __webpack_require__(219); var redefineAll = __webpack_require__(227); var hide = __webpack_require__(17); var forOf = __webpack_require__(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === 'function' ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++]; return new (typeof this === 'function' ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j < items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); __webpack_require__(201)('Observable'); /***/ }), /* 332 */ /***/ (function(module, exports, __webpack_require__) { // ie9- setTimeout & setInterval additional parameters fix var global = __webpack_require__(11); var $export = __webpack_require__(15); var userAgent = __webpack_require__(225); var slice = [].slice; var MSIE = /MSIE .\./.test(userAgent); // 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == 'function' ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F * MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) }); /***/ }), /* 333 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $task = __webpack_require__(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear }); /***/ }), /* 334 */ /***/ (function(module, exports, __webpack_require__) { var $iterators = __webpack_require__(202); var getKeys = __webpack_require__(38); var redefine = __webpack_require__(25); var global = __webpack_require__(11); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var wks = __webpack_require__(34); var ITERATOR = wks('iterator'); var TO_STRING_TAG = wks('toStringTag'); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } } /***/ }), /* 335 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) {/** * Copyright (c) 2014, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * https://raw.github.com/facebook/regenerator/master/LICENSE file. An * additional grant of patent rights can be found in the PATENTS file in * the same directory. */ !(function(global) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; var inModule = typeof module === "object"; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we're in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don't bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we're in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there's no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don't have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don't natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = "GeneratorFunction"; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, "__await")` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { __await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && typeof value === "object" && hasOwn.call(value, "__await")) { return Promise.resolve(value.__await).then(function(value) { invoke("next", value, resolve, reject); }, function(err) { invoke("throw", err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === "object" && global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { // Setting context._sent for legacy support of Babel's // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = "throw"; context.arg = record.arg; } } }; } // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === "throw") { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { // If maybeInvokeDelegate(context) changed context.method from // "return" to "throw", let that override the TypeError below. return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError( "The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was "next", forget context.arg since it has been // "consumed" by the delegate iterator. If context.method was // "return", allow the original .return call to continue in the // outer generator. if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers' implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn't happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel's // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = "next"; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle("end"); } if (entry.tryLoc true * * _.endsWith('abc', 'b'); * // => false * * _.endsWith('abc', 'b', 2); * // => true */ function endsWith(string, target, position) { string = toString(string); target = baseToString(target); var length = string.length; position = position === undefined ? length : baseClamp(toInteger(position), 0, length); var end = position; position -= target.length; return position >= 0 && string.slice(position, end) == target; } /** * Converts the characters "&", "", '"', and "'" in `string` to their * corresponding HTML entities. * * **Note:** No other characters are escaped. To escape additional * characters use a third-party library like [_he_](https://mths.be/he). * * Though the ">" character is escaped for symmetry, characters like * ">" and "/" don't need escaping in HTML and have no special meaning * unless they're part of a tag or unquoted attribute value. See * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands) * (under "semi-related fun fact") for more details. * * When working with HTML you should always * [quote attribute values](http://wonko.com/post/html-escaping) to reduce * XSS vectors. * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escape('fred, barney, & pebbles'); * // => 'fred, barney, &amp; pebbles' */ function escape(string) { string = toString(string); return (string && reHasUnescapedHtml.test(string)) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string; } /** * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+", * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to escape. * @returns {string} Returns the escaped string. * @example * * _.escapeRegExp('[lodash](https://lodash.com/)'); * // => '\[lodash\]\(https://lodash\.com/\)' */ function escapeRegExp(string) { string = toString(string); return (string && reHasRegExpChar.test(string)) ? string.replace(reRegExpChar, '\\$&') : string; } /** * Converts `string` to * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the kebab cased string. * @example * * _.kebabCase('Foo Bar'); * // => 'foo-bar' * * _.kebabCase('fooBar'); * // => 'foo-bar' * * _.kebabCase('__FOO_BAR__'); * // => 'foo-bar' */ var kebabCase = createCompounder(function(result, word, index) { return result + (index ? '-' : '') + word.toLowerCase(); }); /** * Converts `string`, as space separated words, to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.lowerCase('--Foo-Bar--'); * // => 'foo bar' * * _.lowerCase('fooBar'); * // => 'foo bar' * * _.lowerCase('__FOO_BAR__'); * // => 'foo bar' */ var lowerCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toLowerCase(); }); /** * Converts the first character of `string` to lower case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.lowerFirst('Fred'); * // => 'fred' * * _.lowerFirst('FRED'); * // => 'fRED' */ var lowerFirst = createCaseFirst('toLowerCase'); /** * Pads `string` on the left and right sides if it's shorter than `length`. * Padding characters are truncated if they can't be evenly divided by `length`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.pad('abc', 8); * // => ' abc ' * * _.pad('abc', 8, '_-'); * // => '_-abc_-_' * * _.pad('abc', 3); * // => 'abc' */ function pad(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; if (!length || strLength >= length) { return string; } var mid = (length - strLength) / 2; return ( createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars) ); } /** * Pads `string` on the right side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padEnd('abc', 6); * // => 'abc ' * * _.padEnd('abc', 6, '_-'); * // => 'abc_-_' * * _.padEnd('abc', 3); * // => 'abc' */ function padEnd(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (string + createPadding(length - strLength, chars)) : string; } /** * Pads `string` on the left side if it's shorter than `length`. Padding * characters are truncated if they exceed `length`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to pad. * @param {number} [length=0] The padding length. * @param {string} [chars=' '] The string used as padding. * @returns {string} Returns the padded string. * @example * * _.padStart('abc', 6); * // => ' abc' * * _.padStart('abc', 6, '_-'); * // => '_-_abc' * * _.padStart('abc', 3); * // => 'abc' */ function padStart(string, length, chars) { string = toString(string); length = toInteger(length); var strLength = length ? stringSize(string) : 0; return (length && strLength < length) ? (createPadding(length - strLength, chars) + string) : string; } /** * Converts `string` to an integer of the specified radix. If `radix` is * `undefined` or `0`, a `radix` of `10` is used unless `value` is a * hexadecimal, in which case a `radix` of `16` is used. * * **Note:** This method aligns with the * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`. * * @static * @memberOf _ * @since 1.1.0 * @category String * @param {string} string The string to convert. * @param {number} [radix=10] The radix to interpret `value` by. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {number} Returns the converted integer. * @example * * _.parseInt('08'); * // => 8 * * _.map(['6', '08', '10'], _.parseInt); * // => [6, 8, 10] */ function parseInt(string, radix, guard) { if (guard || radix == null) { radix = 0; } else if (radix) { radix = +radix; } return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0); } /** * Repeats the given string `n` times. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to repeat. * @param {number} [n=1] The number of times to repeat the string. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the repeated string. * @example * * _.repeat('*', 3); * // => '***' * * _.repeat('abc', 2); * // => 'abcabc' * * _.repeat('abc', 0); * // => '' */ function repeat(string, n, guard) { if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) { n = 1; } else { n = toInteger(n); } return baseRepeat(toString(string), n); } /** * Replaces matches for `pattern` in `string` with `replacement`. * * **Note:** This method is based on * [`String#replace`](https://mdn.io/String/replace). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to modify. * @param {RegExp|string} pattern The pattern to replace. * @param {Function|string} replacement The match replacement. * @returns {string} Returns the modified string. * @example * * _.replace('Hi Fred', 'Fred', 'Barney'); * // => 'Hi Barney' */ function replace() { var args = arguments, string = toString(args[0]); return args.length < 3 ? string : string.replace(args[1], args[2]); } /** * Converts `string` to * [snake case](https://en.wikipedia.org/wiki/Snake_case). * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the snake cased string. * @example * * _.snakeCase('Foo Bar'); * // => 'foo_bar' * * _.snakeCase('fooBar'); * // => 'foo_bar' * * _.snakeCase('--FOO-BAR--'); * // => 'foo_bar' */ var snakeCase = createCompounder(function(result, word, index) { return result + (index ? '_' : '') + word.toLowerCase(); }); /** * Splits `string` by `separator`. * * **Note:** This method is based on * [`String#split`](https://mdn.io/String/split). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to split. * @param {RegExp|string} separator The separator pattern to split by. * @param {number} [limit] The length to truncate results to. * @returns {Array} Returns the string segments. * @example * * _.split('a-b-c', '-', 2); * // => ['a', 'b'] */ function split(string, separator, limit) { if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) { separator = limit = undefined; } limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0; if (!limit) { return []; } string = toString(string); if (string && ( typeof separator == 'string' || (separator != null && !isRegExp(separator)) )) { separator = baseToString(separator); if (!separator && hasUnicode(string)) { return castSlice(stringToArray(string), 0, limit); } } return string.split(separator, limit); } /** * Converts `string` to * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage). * * @static * @memberOf _ * @since 3.1.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the start cased string. * @example * * _.startCase('--foo-bar--'); * // => 'Foo Bar' * * _.startCase('fooBar'); * // => 'Foo Bar' * * _.startCase('__FOO_BAR__'); * // => 'FOO BAR' */ var startCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + upperFirst(word); }); /** * Checks if `string` starts with the given target string. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {string} [target] The string to search for. * @param {number} [position=0] The position to search from. * @returns {boolean} Returns `true` if `string` starts with `target`, * else `false`. * @example * * _.startsWith('abc', 'a'); * // => true * * _.startsWith('abc', 'b'); * // => false * * _.startsWith('abc', 'b', 1); * // => true */ function startsWith(string, target, position) { string = toString(string); position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length); target = baseToString(target); return string.slice(position, position + target.length) == target; } /** * Creates a compiled template function that can interpolate data properties * in "interpolate" delimiters, HTML-escape interpolated data properties in * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data * properties may be accessed as free variables in the template. If a setting * object is given, it takes precedence over `_.templateSettings` values. * * **Note:** In the development build `_.template` utilizes * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl) * for easier debugging. * * For more information on precompiling templates see * [lodash's custom builds documentation](https://lodash.com/custom-builds). * * For more information on Chrome extension sandboxes see * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval). * * @static * @since 0.1.0 * @memberOf _ * @category String * @param {string} [string=''] The template string. * @param {Object} [options={}] The options object. * @param {RegExp} [options.escape=_.templateSettings.escape] * The HTML "escape" delimiter. * @param {RegExp} [options.evaluate=_.templateSettings.evaluate] * The "evaluate" delimiter. * @param {Object} [options.imports=_.templateSettings.imports] * An object to import into the template as free variables. * @param {RegExp} [options.interpolate=_.templateSettings.interpolate] * The "interpolate" delimiter. * @param {string} [options.sourceURL='lodash.templateSources[n]'] * The sourceURL of the compiled template. * @param {string} [options.variable='obj'] * The data object variable name. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Function} Returns the compiled template function. * @example * * // Use the "interpolate" delimiter to create a compiled template. * var compiled = _.template('hello !'); * compiled({ 'user': 'fred' }); * // => 'hello fred!' * * // Use the HTML "escape" delimiter to escape data property values. * var compiled = _.template(''); * compiled({ 'value': '' }); * // => '&lt;script&gt;' * * // Use the "evaluate" delimiter to execute JavaScript and generate HTML. * var compiled = _.template(''); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the internal `print` function in "evaluate" delimiters. * var compiled = _.template('!'); * compiled({ 'user': 'barney' }); * // => 'hello barney!' * * // Use the ES template literal delimiter as an "interpolate" delimiter. * // Disable support by replacing the "interpolate" delimiter. * var compiled = _.template('hello ${ user }!'); * compiled({ 'user': 'pebbles' }); * // => 'hello pebbles!' * * // Use backslashes to treat delimiters as plain text. * var compiled = _.template(''); * compiled({ 'value': 'ignored' }); * // => '' * * // Use the `imports` option to import `jQuery` as `jq`. * var text = ''; * var compiled = _.template(text, { 'imports': { 'jq': jQuery } }); * compiled({ 'users': ['fred', 'barney'] }); * // => 'fredbarney' * * // Use the `sourceURL` option to specify a custom sourceURL for the template. * var compiled = _.template('hello !', { 'sourceURL': '/basic/greeting.jst' }); * compiled(data); * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector. * * // Use the `variable` option to ensure a with-statement isn't used in the compiled template. * var compiled = _.template('hi !', { 'variable': 'data' }); * compiled.source; * // => function(data) { * // var __t, __p = ''; * // __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!'; * // return __p; * // } * * // Use custom template delimiters. * _.templateSettings.interpolate = /undefined/g; * var compiled = _.template('hello !'); * compiled({ 'user': 'mustache' }); * // => 'hello mustache!' * * // Use the `source` property to inline compiled templates for meaningful * // line numbers in error messages and stack traces. * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\ * var JST = {\ * "main": ' + _.template(mainText).source + '\ * };\ * '); */ function template(string, options, guard) { // Based on John Resig's `tmpl` implementation // (http://ejohn.org/blog/javascript-micro-templating/) // and Laura Doktorova's doT.js (https://github.com/olado/doT). var settings = lodash.templateSettings; if (guard && isIterateeCall(string, options, guard)) { options = undefined; } string = toString(string); options = assignInWith({}, options, settings, customDefaultsAssignIn); var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys); var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '"; // Compile the regexp to match each delimiter. var reDelimiters = RegExp( (options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$' , 'g'); // Use a sourceURL for easier debugging. var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : ('lodash.templateSources[' + (++templateCounter) + ']') ) + '\n'; string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) { interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals. source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar); // Replace delimiters with snippets. if (escapeValue) { isEscaping = true; source += "' +\n__e(" + escapeValue + ") +\n'"; } if (evaluateValue) { isEvaluating = true; source += "';\n" + evaluateValue + ";\n__p += '"; } if (interpolateValue) { source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"; } index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in // order to produce the correct `offset` value. return match; }); source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated // code to add the data object to the top of the scope chain. var variable = options.variable; if (!variable) { source = 'with (obj) {\n' + source + '\n}\n'; } // Cleanup code by stripping empty strings. source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source) .replace(reEmptyStringMiddle, '$1') .replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body. source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n' ) + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '' ) + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n' ) + source + 'return __p\n}'; var result = attempt(function() { return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues); }); // Provide the compiled function's source by its `toString` method or // the `source` property as a convenience for inlining compiled templates. result.source = source; if (isError(result)) { throw result; } return result; } /** * Converts `string`, as a whole, to lower case just like * [String#toLowerCase](https://mdn.io/toLowerCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the lower cased string. * @example * * _.toLower('--Foo-Bar--'); * // => '--foo-bar--' * * _.toLower('fooBar'); * // => 'foobar' * * _.toLower('__FOO_BAR__'); * // => '__foo_bar__' */ function toLower(value) { return toString(value).toLowerCase(); } /** * Converts `string`, as a whole, to upper case just like * [String#toUpperCase](https://mdn.io/toUpperCase). * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.toUpper('--foo-bar--'); * // => '--FOO-BAR--' * * _.toUpper('fooBar'); * // => 'FOOBAR' * * _.toUpper('__foo_bar__'); * // => '__FOO_BAR__' */ function toUpper(value) { return toString(value).toUpperCase(); } /** * Removes leading and trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trim(' abc '); * // => 'abc' * * _.trim('-_-abc-_-', '_-'); * // => 'abc' * * _.map([' foo ', ' bar '], _.trim); * // => ['foo', 'bar'] */ function trim(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrim, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1; return castSlice(strSymbols, start, end).join(''); } /** * Removes trailing whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimEnd(' abc '); * // => ' abc' * * _.trimEnd('-_-abc-_-', '_-'); * // => '-_-abc' */ function trimEnd(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimEnd, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1; return castSlice(strSymbols, 0, end).join(''); } /** * Removes leading whitespace or specified characters from `string`. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to trim. * @param {string} [chars=whitespace] The characters to trim. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {string} Returns the trimmed string. * @example * * _.trimStart(' abc '); * // => 'abc ' * * _.trimStart('-_-abc-_-', '_-'); * // => 'abc-_-' */ function trimStart(string, chars, guard) { string = toString(string); if (string && (guard || chars === undefined)) { return string.replace(reTrimStart, ''); } if (!string || !(chars = baseToString(chars))) { return string; } var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars)); return castSlice(strSymbols, start).join(''); } /** * Truncates `string` if it's longer than the given maximum string length. * The last characters of the truncated string are replaced with the omission * string which defaults to "...". * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to truncate. * @param {Object} [options={}] The options object. * @param {number} [options.length=30] The maximum string length. * @param {string} [options.omission='...'] The string to indicate text is omitted. * @param {RegExp|string} [options.separator] The separator pattern to truncate to. * @returns {string} Returns the truncated string. * @example * * _.truncate('hi-diddly-ho there, neighborino'); * // => 'hi-diddly-ho there, neighbo...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': ' ' * }); * // => 'hi-diddly-ho there,...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'length': 24, * 'separator': /,? +/ * }); * // => 'hi-diddly-ho there...' * * _.truncate('hi-diddly-ho there, neighborino', { * 'omission': ' [...]' * }); * // => 'hi-diddly-ho there, neig [...]' */ function truncate(string, options) { var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION; if (isObject(options)) { var separator = 'separator' in options ? options.separator : separator; length = 'length' in options ? toInteger(options.length) : length; omission = 'omission' in options ? baseToString(options.omission) : omission; } string = toString(string); var strLength = string.length; if (hasUnicode(string)) { var strSymbols = stringToArray(string); strLength = strSymbols.length; } if (length >= strLength) { return string; } var end = length - stringSize(omission); if (end < 1) { return omission; } var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end); if (separator === undefined) { return result + omission; } if (strSymbols) { end += (result.length - end); } if (isRegExp(separator)) { if (string.slice(end).search(separator)) { var match, substring = result; if (!separator.global) { separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g'); } separator.lastIndex = 0; while ((match = separator.exec(substring))) { var newEnd = match.index; } result = result.slice(0, newEnd === undefined ? end : newEnd); } } else if (string.indexOf(baseToString(separator), end) != end) { var index = result.lastIndexOf(separator); if (index > -1) { result = result.slice(0, index); } } return result + omission; } /** * The inverse of `_.escape`; this method converts the HTML entities * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to * their corresponding characters. * * **Note:** No other HTML entities are unescaped. To unescape additional * HTML entities use a third-party library like [_he_](https://mths.be/he). * * @static * @memberOf _ * @since 0.6.0 * @category String * @param {string} [string=''] The string to unescape. * @returns {string} Returns the unescaped string. * @example * * _.unescape('fred, barney, &amp; pebbles'); * // => 'fred, barney, & pebbles' */ function unescape(string) { string = toString(string); return (string && reHasEscapedHtml.test(string)) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string; } /** * Converts `string`, as space separated words, to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the upper cased string. * @example * * _.upperCase('--foo-bar'); * // => 'FOO BAR' * * _.upperCase('fooBar'); * // => 'FOO BAR' * * _.upperCase('__foo_bar__'); * // => 'FOO BAR' */ var upperCase = createCompounder(function(result, word, index) { return result + (index ? ' ' : '') + word.toUpperCase(); }); /** * Converts the first character of `string` to upper case. * * @static * @memberOf _ * @since 4.0.0 * @category String * @param {string} [string=''] The string to convert. * @returns {string} Returns the converted string. * @example * * _.upperFirst('fred'); * // => 'Fred' * * _.upperFirst('FRED'); * // => 'FRED' */ var upperFirst = createCaseFirst('toUpperCase'); /** * Splits `string` into an array of its words. * * @static * @memberOf _ * @since 3.0.0 * @category String * @param {string} [string=''] The string to inspect. * @param {RegExp|string} [pattern] The pattern to match words. * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`. * @returns {Array} Returns the words of `string`. * @example * * _.words('fred, barney, & pebbles'); * // => ['fred', 'barney', 'pebbles'] * * _.words('fred, barney, & pebbles', /[^, ]+/g); * // => ['fred', 'barney', '&', 'pebbles'] */ function words(string, pattern, guard) { string = toString(string); pattern = guard ? undefined : pattern; if (pattern === undefined) { return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string); } return string.match(pattern) || []; } /*------------------------------------------------------------------------*/ /** * Attempts to invoke `func`, returning either the result or the caught error * object. Any additional arguments are provided to `func` when it's invoked. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Function} func The function to attempt. * @param {...*} [args] The arguments to invoke `func` with. * @returns {*} Returns the `func` result or error object. * @example * * // Avoid throwing errors for invalid selectors. * var elements = _.attempt(function(selector) { * return document.querySelectorAll(selector); * }, '>_>'); * * if (_.isError(elements)) { * elements = []; * } */ var attempt = baseRest(function(func, args) { try { return apply(func, undefined, args); } catch (e) { return isError(e) ? e : new Error(e); } }); /** * Binds methods of an object to the object itself, overwriting the existing * method. * * **Note:** This method doesn't set the "length" property of bound functions. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Object} object The object to bind and assign the bound methods to. * @param {...(string|string[])} methodNames The object method names to bind. * @returns {Object} Returns `object`. * @example * * var view = { * 'label': 'docs', * 'click': function() { * console.log('clicked ' + this.label); * } * }; * * _.bindAll(view, ['click']); * jQuery(element).on('click', view.click); * // => Logs 'clicked docs' when clicked. */ var bindAll = flatRest(function(object, methodNames) { arrayEach(methodNames, function(key) { key = toKey(key); baseAssignValue(object, key, bind(object[key], object)); }); return object; }); /** * Creates a function that iterates over `pairs` and invokes the corresponding * function of the first predicate to return truthy. The predicate-function * pairs are invoked with the `this` binding and arguments of the created * function. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Array} pairs The predicate-function pairs. * @returns {Function} Returns the new composite function. * @example * * var func = _.cond([ * [_.matches({ 'a': 1 }), _.constant('matches A')], * [_.conforms({ 'b': _.isNumber }), _.constant('matches B')], * [_.stubTrue, _.constant('no match')] * ]); * * func({ 'a': 1, 'b': 2 }); * // => 'matches A' * * func({ 'a': 0, 'b': 1 }); * // => 'matches B' * * func({ 'a': '1', 'b': '2' }); * // => 'no match' */ function cond(pairs) { var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee(); pairs = !length ? [] : arrayMap(pairs, function(pair) { if (typeof pair[1] != 'function') { throw new TypeError(FUNC_ERROR_TEXT); } return [toIteratee(pair[0]), pair[1]]; }); return baseRest(function(args) { var index = -1; while (++index < length) { var pair = pairs[index]; if (apply(pair[0], this, args)) { return apply(pair[1], this, args); } } }); } /** * Creates a function that invokes the predicate properties of `source` with * the corresponding property values of a given object, returning `true` if * all predicates return truthy, else `false`. * * **Note:** The created function is equivalent to `_.conformsTo` with * `source` partially applied. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {Object} source The object of property predicates to conform to. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 2, 'b': 1 }, * { 'a': 1, 'b': 2 } * ]; * * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } })); * // => [{ 'a': 1, 'b': 2 }] */ function conforms(source) { return baseConforms(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that returns `value`. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {*} value The value to return from the new function. * @returns {Function} Returns the new constant function. * @example * * var objects = _.times(2, _.constant({ 'a': 1 })); * * console.log(objects); * // => [{ 'a': 1 }, { 'a': 1 }] * * console.log(objects[0] === objects[1]); * // => true */ function constant(value) { return function() { return value; }; } /** * Checks `value` to determine whether a default value should be returned in * its place. The `defaultValue` is returned if `value` is `NaN`, `null`, * or `undefined`. * * @static * @memberOf _ * @since 4.14.0 * @category Util * @param {*} value The value to check. * @param {*} defaultValue The default value. * @returns {*} Returns the resolved value. * @example * * _.defaultTo(1, 10); * // => 1 * * _.defaultTo(undefined, 10); * // => 10 */ function defaultTo(value, defaultValue) { return (value == null || value !== value) ? defaultValue : value; } /** * Creates a function that returns the result of invoking the given functions * with the `this` binding of the created function, where each successive * invocation is supplied the return value of the previous. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flowRight * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flow([_.add, square]); * addSquare(1, 2); * // => 9 */ var flow = createFlow(); /** * This method is like `_.flow` except that it creates a function that * invokes the given functions from right to left. * * @static * @since 3.0.0 * @memberOf _ * @category Util * @param {...(Function|Function[])} [funcs] The functions to invoke. * @returns {Function} Returns the new composite function. * @see _.flow * @example * * function square(n) { * return n * n; * } * * var addSquare = _.flowRight([square, _.add]); * addSquare(1, 2); * // => 9 */ var flowRight = createFlow(true); /** * This method returns the first argument it receives. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {*} value Any value. * @returns {*} Returns `value`. * @example * * var object = { 'a': 1 }; * * console.log(_.identity(object) === object); * // => true */ function identity(value) { return value; } /** * Creates a function that invokes `func` with the arguments of the created * function. If `func` is a property name, the created function returns the * property value for a given element. If `func` is an array or object, the * created function returns `true` for elements that contain the equivalent * source properties, otherwise it returns `false`. * * @static * @since 4.0.0 * @memberOf _ * @category Util * @param {*} [func=_.identity] The value to convert to a callback. * @returns {Function} Returns the callback. * @example * * var users = [ * { 'user': 'barney', 'age': 36, 'active': true }, * { 'user': 'fred', 'age': 40, 'active': false } * ]; * * // The `_.matches` iteratee shorthand. * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true })); * // => [{ 'user': 'barney', 'age': 36, 'active': true }] * * // The `_.matchesProperty` iteratee shorthand. * _.filter(users, _.iteratee(['user', 'fred'])); * // => [{ 'user': 'fred', 'age': 40 }] * * // The `_.property` iteratee shorthand. * _.map(users, _.iteratee('user')); * // => ['barney', 'fred'] * * // Create custom iteratee shorthands. * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) { * return !_.isRegExp(func) ? iteratee(func) : function(string) { * return func.test(string); * }; * }); * * _.filter(['abc', 'def'], /ef/); * // => ['def'] */ function iteratee(func) { return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between a given * object and `source`, returning `true` if the given object has equivalent * property values, else `false`. * * **Note:** The created function is equivalent to `_.isMatch` with `source` * partially applied. * * Partial comparisons will match empty array and empty object `source` * values against any array or object value, respectively. See `_.isEqual` * for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} source The object of property values to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.filter(objects, _.matches({ 'a': 4, 'c': 6 })); * // => [{ 'a': 4, 'b': 5, 'c': 6 }] */ function matches(source) { return baseMatches(baseClone(source, CLONE_DEEP_FLAG)); } /** * Creates a function that performs a partial deep comparison between the * value at `path` of a given object to `srcValue`, returning `true` if the * object value is equivalent, else `false`. * * **Note:** Partial comparisons will match empty array and empty object * `srcValue` values against any array or object value, respectively. See * `_.isEqual` for a list of supported value comparisons. * * @static * @memberOf _ * @since 3.2.0 * @category Util * @param {Array|string} path The path of the property to get. * @param {*} srcValue The value to match. * @returns {Function} Returns the new spec function. * @example * * var objects = [ * { 'a': 1, 'b': 2, 'c': 3 }, * { 'a': 4, 'b': 5, 'c': 6 } * ]; * * _.find(objects, _.matchesProperty('a', 4)); * // => { 'a': 4, 'b': 5, 'c': 6 } */ function matchesProperty(path, srcValue) { return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG)); } /** * Creates a function that invokes the method at `path` of a given object. * Any additional arguments are provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Array|string} path The path of the method to invoke. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var objects = [ * { 'a': { 'b': _.constant(2) } }, * { 'a': { 'b': _.constant(1) } } * ]; * * _.map(objects, _.method('a.b')); * // => [2, 1] * * _.map(objects, _.method(['a', 'b'])); * // => [2, 1] */ var method = baseRest(function(path, args) { return function(object) { return baseInvoke(object, path, args); }; }); /** * The opposite of `_.method`; this method creates a function that invokes * the method at a given path of `object`. Any additional arguments are * provided to the invoked method. * * @static * @memberOf _ * @since 3.7.0 * @category Util * @param {Object} object The object to query. * @param {...*} [args] The arguments to invoke the method with. * @returns {Function} Returns the new invoker function. * @example * * var array = _.times(3, _.constant), * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.methodOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.methodOf(object)); * // => [2, 0] */ var methodOf = baseRest(function(object, args) { return function(path) { return baseInvoke(object, path, args); }; }); /** * Adds all own enumerable string keyed function properties of a source * object to the destination object. If `object` is a function, then methods * are added to its prototype as well. * * **Note:** Use `_.runInContext` to create a pristine `lodash` function to * avoid conflicts caused by modifying the original. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {Function|Object} [object=lodash] The destination object. * @param {Object} source The object of functions to add. * @param {Object} [options={}] The options object. * @param {boolean} [options.chain=true] Specify whether mixins are chainable. * @returns {Function|Object} Returns `object`. * @example * * function vowels(string) { * return _.filter(string, function(v) { * return /[aeiou]/i.test(v); * }); * } * * _.mixin({ 'vowels': vowels }); * _.vowels('fred'); * // => ['e'] * * _('fred').vowels().value(); * // => ['e'] * * _.mixin({ 'vowels': vowels }, { 'chain': false }); * _('fred').vowels(); * // => ['e'] */ function mixin(object, source, options) { var props = keys(source), methodNames = baseFunctions(source, props); if (options == null && !(isObject(source) && (methodNames.length || !props.length))) { options = source; source = object; object = this; methodNames = baseFunctions(source, keys(source)); } var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object); arrayEach(methodNames, function(methodName) { var func = source[methodName]; object[methodName] = func; if (isFunc) { object.prototype[methodName] = function() { var chainAll = this.__chain__; if (chain || chainAll) { var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__); actions.push({ 'func': func, 'args': arguments, 'thisArg': object }); result.__chain__ = chainAll; return result; } return func.apply(object, arrayPush([this.value()], arguments)); }; } }); return object; } /** * Reverts the `_` variable to its previous value and returns a reference to * the `lodash` function. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @returns {Function} Returns the `lodash` function. * @example * * var lodash = _.noConflict(); */ function noConflict() { if (root._ === this) { root._ = oldDash; } return this; } /** * This method returns `undefined`. * * @static * @memberOf _ * @since 2.3.0 * @category Util * @example * * _.times(2, _.noop); * // => [undefined, undefined] */ function noop() { // No operation performed. } /** * Creates a function that gets the argument at index `n`. If `n` is negative, * the nth argument from the end is returned. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [n=0] The index of the argument to return. * @returns {Function} Returns the new pass-thru function. * @example * * var func = _.nthArg(1); * func('a', 'b', 'c', 'd'); * // => 'b' * * var func = _.nthArg(-2); * func('a', 'b', 'c', 'd'); * // => 'c' */ function nthArg(n) { n = toInteger(n); return baseRest(function(args) { return baseNth(args, n); }); } /** * Creates a function that invokes `iteratees` with the arguments it receives * and returns their results. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [iteratees=[_.identity]] * The iteratees to invoke. * @returns {Function} Returns the new function. * @example * * var func = _.over([Math.max, Math.min]); * * func(1, 2, 3, 4); * // => [4, 1] */ var over = createOver(arrayMap); /** * Creates a function that checks if **all** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overEvery([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => false * * func(NaN); * // => false */ var overEvery = createOver(arrayEvery); /** * Creates a function that checks if **any** of the `predicates` return * truthy when invoked with the arguments it receives. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {...(Function|Function[])} [predicates=[_.identity]] * The predicates to check. * @returns {Function} Returns the new function. * @example * * var func = _.overSome([Boolean, isFinite]); * * func('1'); * // => true * * func(null); * // => true * * func(NaN); * // => false */ var overSome = createOver(arraySome); /** * Creates a function that returns the value at `path` of a given object. * * @static * @memberOf _ * @since 2.4.0 * @category Util * @param {Array|string} path The path of the property to get. * @returns {Function} Returns the new accessor function. * @example * * var objects = [ * { 'a': { 'b': 2 } }, * { 'a': { 'b': 1 } } * ]; * * _.map(objects, _.property('a.b')); * // => [2, 1] * * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b'); * // => [1, 2] */ function property(path) { return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path); } /** * The opposite of `_.property`; this method creates a function that returns * the value at a given path of `object`. * * @static * @memberOf _ * @since 3.0.0 * @category Util * @param {Object} object The object to query. * @returns {Function} Returns the new accessor function. * @example * * var array = [0, 1, 2], * object = { 'a': array, 'b': array, 'c': array }; * * _.map(['a[2]', 'c[0]'], _.propertyOf(object)); * // => [2, 0] * * _.map([['a', '2'], ['c', '0']], _.propertyOf(object)); * // => [2, 0] */ function propertyOf(object) { return function(path) { return object == null ? undefined : baseGet(object, path); }; } /** * Creates an array of numbers (positive and/or negative) progressing from * `start` up to, but not including, `end`. A step of `-1` is used if a negative * `start` is specified without an `end` or `step`. If `end` is not specified, * it's set to `start` with `start` then set to `0`. * * **Note:** JavaScript follows the IEEE-754 standard for resolving * floating-point values which can produce unexpected results. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.rangeRight * @example * * _.range(4); * // => [0, 1, 2, 3] * * _.range(-4); * // => [0, -1, -2, -3] * * _.range(1, 5); * // => [1, 2, 3, 4] * * _.range(0, 20, 5); * // => [0, 5, 10, 15] * * _.range(0, -4, -1); * // => [0, -1, -2, -3] * * _.range(1, 4, 0); * // => [1, 1, 1] * * _.range(0); * // => [] */ var range = createRange(); /** * This method is like `_.range` except that it populates values in * descending order. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {number} [start=0] The start of the range. * @param {number} end The end of the range. * @param {number} [step=1] The value to increment or decrement by. * @returns {Array} Returns the range of numbers. * @see _.inRange, _.range * @example * * _.rangeRight(4); * // => [3, 2, 1, 0] * * _.rangeRight(-4); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 5); * // => [4, 3, 2, 1] * * _.rangeRight(0, 20, 5); * // => [15, 10, 5, 0] * * _.rangeRight(0, -4, -1); * // => [-3, -2, -1, 0] * * _.rangeRight(1, 4, 0); * // => [1, 1, 1] * * _.rangeRight(0); * // => [] */ var rangeRight = createRange(true); /** * This method returns a new empty array. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Array} Returns the new empty array. * @example * * var arrays = _.times(2, _.stubArray); * * console.log(arrays); * // => [[], []] * * console.log(arrays[0] === arrays[1]); * // => false */ function stubArray() { return []; } /** * This method returns `false`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `false`. * @example * * _.times(2, _.stubFalse); * // => [false, false] */ function stubFalse() { return false; } /** * This method returns a new empty object. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {Object} Returns the new empty object. * @example * * var objects = _.times(2, _.stubObject); * * console.log(objects); * // => [{}, {}] * * console.log(objects[0] === objects[1]); * // => false */ function stubObject() { return {}; } /** * This method returns an empty string. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {string} Returns the empty string. * @example * * _.times(2, _.stubString); * // => ['', ''] */ function stubString() { return ''; } /** * This method returns `true`. * * @static * @memberOf _ * @since 4.13.0 * @category Util * @returns {boolean} Returns `true`. * @example * * _.times(2, _.stubTrue); * // => [true, true] */ function stubTrue() { return true; } /** * Invokes the iteratee `n` times, returning an array of the results of * each invocation. The iteratee is invoked with one argument; (index). * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {number} n The number of times to invoke `iteratee`. * @param {Function} [iteratee=_.identity] The function invoked per iteration. * @returns {Array} Returns the array of results. * @example * * _.times(3, String); * // => ['0', '1', '2'] * * _.times(4, _.constant(0)); * // => [0, 0, 0, 0] */ function times(n, iteratee) { n = toInteger(n); if (n < 1 || n > MAX_SAFE_INTEGER) { return []; } var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH); iteratee = getIteratee(iteratee); n -= MAX_ARRAY_LENGTH; var result = baseTimes(length, iteratee); while (++index < n) { iteratee(index); } return result; } /** * Converts `value` to a property path array. * * @static * @memberOf _ * @since 4.0.0 * @category Util * @param {*} value The value to convert. * @returns {Array} Returns the new property path array. * @example * * _.toPath('a.b.c'); * // => ['a', 'b', 'c'] * * _.toPath('a[0].b.c'); * // => ['a', '0', 'b', 'c'] */ function toPath(value) { if (isArray(value)) { return arrayMap(value, toKey); } return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value))); } /** * Generates a unique ID. If `prefix` is given, the ID is appended to it. * * @static * @since 0.1.0 * @memberOf _ * @category Util * @param {string} [prefix=''] The value to prefix the ID with. * @returns {string} Returns the unique ID. * @example * * _.uniqueId('contact_'); * // => 'contact_104' * * _.uniqueId(); * // => '105' */ function uniqueId(prefix) { var id = ++idCounter; return toString(prefix) + id; } /*------------------------------------------------------------------------*/ /** * Adds two numbers. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {number} augend The first number in an addition. * @param {number} addend The second number in an addition. * @returns {number} Returns the total. * @example * * _.add(6, 4); * // => 10 */ var add = createMathOperation(function(augend, addend) { return augend + addend; }, 0); /** * Computes `number` rounded up to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round up. * @param {number} [precision=0] The precision to round up to. * @returns {number} Returns the rounded up number. * @example * * _.ceil(4.006); * // => 5 * * _.ceil(6.004, 2); * // => 6.01 * * _.ceil(6040, -2); * // => 6100 */ var ceil = createRound('ceil'); /** * Divide two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} dividend The first number in a division. * @param {number} divisor The second number in a division. * @returns {number} Returns the quotient. * @example * * _.divide(6, 4); * // => 1.5 */ var divide = createMathOperation(function(dividend, divisor) { return dividend / divisor; }, 1); /** * Computes `number` rounded down to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round down. * @param {number} [precision=0] The precision to round down to. * @returns {number} Returns the rounded down number. * @example * * _.floor(4.006); * // => 4 * * _.floor(0.046, 2); * // => 0.04 * * _.floor(4060, -2); * // => 4000 */ var floor = createRound('floor'); /** * Computes the maximum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the maximum value. * @example * * _.max([4, 2, 8, 6]); * // => 8 * * _.max([]); * // => undefined */ function max(array) { return (array && array.length) ? baseExtremum(array, identity, baseGt) : undefined; } /** * This method is like `_.max` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the maximum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.maxBy(objects, function(o) { return o.n; }); * // => { 'n': 2 } * * // The `_.property` iteratee shorthand. * _.maxBy(objects, 'n'); * // => { 'n': 2 } */ function maxBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined; } /** * Computes the mean of the values in `array`. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the mean. * @example * * _.mean([4, 2, 8, 6]); * // => 5 */ function mean(array) { return baseMean(array, identity); } /** * This method is like `_.mean` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be averaged. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the mean. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.meanBy(objects, function(o) { return o.n; }); * // => 5 * * // The `_.property` iteratee shorthand. * _.meanBy(objects, 'n'); * // => 5 */ function meanBy(array, iteratee) { return baseMean(array, getIteratee(iteratee, 2)); } /** * Computes the minimum value of `array`. If `array` is empty or falsey, * `undefined` is returned. * * @static * @since 0.1.0 * @memberOf _ * @category Math * @param {Array} array The array to iterate over. * @returns {*} Returns the minimum value. * @example * * _.min([4, 2, 8, 6]); * // => 2 * * _.min([]); * // => undefined */ function min(array) { return (array && array.length) ? baseExtremum(array, identity, baseLt) : undefined; } /** * This method is like `_.min` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the criterion by which * the value is ranked. The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {*} Returns the minimum value. * @example * * var objects = [{ 'n': 1 }, { 'n': 2 }]; * * _.minBy(objects, function(o) { return o.n; }); * // => { 'n': 1 } * * // The `_.property` iteratee shorthand. * _.minBy(objects, 'n'); * // => { 'n': 1 } */ function minBy(array, iteratee) { return (array && array.length) ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined; } /** * Multiply two numbers. * * @static * @memberOf _ * @since 4.7.0 * @category Math * @param {number} multiplier The first number in a multiplication. * @param {number} multiplicand The second number in a multiplication. * @returns {number} Returns the product. * @example * * _.multiply(6, 4); * // => 24 */ var multiply = createMathOperation(function(multiplier, multiplicand) { return multiplier * multiplicand; }, 1); /** * Computes `number` rounded to `precision`. * * @static * @memberOf _ * @since 3.10.0 * @category Math * @param {number} number The number to round. * @param {number} [precision=0] The precision to round to. * @returns {number} Returns the rounded number. * @example * * _.round(4.006); * // => 4 * * _.round(4.006, 2); * // => 4.01 * * _.round(4060, -2); * // => 4100 */ var round = createRound('round'); /** * Subtract two numbers. * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {number} minuend The first number in a subtraction. * @param {number} subtrahend The second number in a subtraction. * @returns {number} Returns the difference. * @example * * _.subtract(6, 4); * // => 2 */ var subtract = createMathOperation(function(minuend, subtrahend) { return minuend - subtrahend; }, 0); /** * Computes the sum of the values in `array`. * * @static * @memberOf _ * @since 3.4.0 * @category Math * @param {Array} array The array to iterate over. * @returns {number} Returns the sum. * @example * * _.sum([4, 2, 8, 6]); * // => 20 */ function sum(array) { return (array && array.length) ? baseSum(array, identity) : 0; } /** * This method is like `_.sum` except that it accepts `iteratee` which is * invoked for each element in `array` to generate the value to be summed. * The iteratee is invoked with one argument: (value). * * @static * @memberOf _ * @since 4.0.0 * @category Math * @param {Array} array The array to iterate over. * @param {Function} [iteratee=_.identity] The iteratee invoked per element. * @returns {number} Returns the sum. * @example * * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }]; * * _.sumBy(objects, function(o) { return o.n; }); * // => 20 * * // The `_.property` iteratee shorthand. * _.sumBy(objects, 'n'); * // => 20 */ function sumBy(array, iteratee) { return (array && array.length) ? baseSum(array, getIteratee(iteratee, 2)) : 0; } /*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences. lodash.after = after; lodash.ary = ary; lodash.assign = assign; lodash.assignIn = assignIn; lodash.assignInWith = assignInWith; lodash.assignWith = assignWith; lodash.at = at; lodash.before = before; lodash.bind = bind; lodash.bindAll = bindAll; lodash.bindKey = bindKey; lodash.castArray = castArray; lodash.chain = chain; lodash.chunk = chunk; lodash.compact = compact; lodash.concat = concat; lodash.cond = cond; lodash.conforms = conforms; lodash.constant = constant; lodash.countBy = countBy; lodash.create = create; lodash.curry = curry; lodash.curryRight = curryRight; lodash.debounce = debounce; lodash.defaults = defaults; lodash.defaultsDeep = defaultsDeep; lodash.defer = defer; lodash.delay = delay; lodash.difference = difference; lodash.differenceBy = differenceBy; lodash.differenceWith = differenceWith; lodash.drop = drop; lodash.dropRight = dropRight; lodash.dropRightWhile = dropRightWhile; lodash.dropWhile = dropWhile; lodash.fill = fill; lodash.filter = filter; lodash.flatMap = flatMap; lodash.flatMapDeep = flatMapDeep; lodash.flatMapDepth = flatMapDepth; lodash.flatten = flatten; lodash.flattenDeep = flattenDeep; lodash.flattenDepth = flattenDepth; lodash.flip = flip; lodash.flow = flow; lodash.flowRight = flowRight; lodash.fromPairs = fromPairs; lodash.functions = functions; lodash.functionsIn = functionsIn; lodash.groupBy = groupBy; lodash.initial = initial; lodash.intersection = intersection; lodash.intersectionBy = intersectionBy; lodash.intersectionWith = intersectionWith; lodash.invert = invert; lodash.invertBy = invertBy; lodash.invokeMap = invokeMap; lodash.iteratee = iteratee; lodash.keyBy = keyBy; lodash.keys = keys; lodash.keysIn = keysIn; lodash.map = map; lodash.mapKeys = mapKeys; lodash.mapValues = mapValues; lodash.matches = matches; lodash.matchesProperty = matchesProperty; lodash.memoize = memoize; lodash.merge = merge; lodash.mergeWith = mergeWith; lodash.method = method; lodash.methodOf = methodOf; lodash.mixin = mixin; lodash.negate = negate; lodash.nthArg = nthArg; lodash.omit = omit; lodash.omitBy = omitBy; lodash.once = once; lodash.orderBy = orderBy; lodash.over = over; lodash.overArgs = overArgs; lodash.overEvery = overEvery; lodash.overSome = overSome; lodash.partial = partial; lodash.partialRight = partialRight; lodash.partition = partition; lodash.pick = pick; lodash.pickBy = pickBy; lodash.property = property; lodash.propertyOf = propertyOf; lodash.pull = pull; lodash.pullAll = pullAll; lodash.pullAllBy = pullAllBy; lodash.pullAllWith = pullAllWith; lodash.pullAt = pullAt; lodash.range = range; lodash.rangeRight = rangeRight; lodash.rearg = rearg; lodash.reject = reject; lodash.remove = remove; lodash.rest = rest; lodash.reverse = reverse; lodash.sampleSize = sampleSize; lodash.set = set; lodash.setWith = setWith; lodash.shuffle = shuffle; lodash.slice = slice; lodash.sortBy = sortBy; lodash.sortedUniq = sortedUniq; lodash.sortedUniqBy = sortedUniqBy; lodash.split = split; lodash.spread = spread; lodash.tail = tail; lodash.take = take; lodash.takeRight = takeRight; lodash.takeRightWhile = takeRightWhile; lodash.takeWhile = takeWhile; lodash.tap = tap; lodash.throttle = throttle; lodash.thru = thru; lodash.toArray = toArray; lodash.toPairs = toPairs; lodash.toPairsIn = toPairsIn; lodash.toPath = toPath; lodash.toPlainObject = toPlainObject; lodash.transform = transform; lodash.unary = unary; lodash.union = union; lodash.unionBy = unionBy; lodash.unionWith = unionWith; lodash.uniq = uniq; lodash.uniqBy = uniqBy; lodash.uniqWith = uniqWith; lodash.unset = unset; lodash.unzip = unzip; lodash.unzipWith = unzipWith; lodash.update = update; lodash.updateWith = updateWith; lodash.values = values; lodash.valuesIn = valuesIn; lodash.without = without; lodash.words = words; lodash.wrap = wrap; lodash.xor = xor; lodash.xorBy = xorBy; lodash.xorWith = xorWith; lodash.zip = zip; lodash.zipObject = zipObject; lodash.zipObjectDeep = zipObjectDeep; lodash.zipWith = zipWith; // Add aliases. lodash.entries = toPairs; lodash.entriesIn = toPairsIn; lodash.extend = assignIn; lodash.extendWith = assignInWith; // Add methods to `lodash.prototype`. mixin(lodash, lodash); /*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences. lodash.add = add; lodash.attempt = attempt; lodash.camelCase = camelCase; lodash.capitalize = capitalize; lodash.ceil = ceil; lodash.clamp = clamp; lodash.clone = clone; lodash.cloneDeep = cloneDeep; lodash.cloneDeepWith = cloneDeepWith; lodash.cloneWith = cloneWith; lodash.conformsTo = conformsTo; lodash.deburr = deburr; lodash.defaultTo = defaultTo; lodash.divide = divide; lodash.endsWith = endsWith; lodash.eq = eq; lodash.escape = escape; lodash.escapeRegExp = escapeRegExp; lodash.every = every; lodash.find = find; lodash.findIndex = findIndex; lodash.findKey = findKey; lodash.findLast = findLast; lodash.findLastIndex = findLastIndex; lodash.findLastKey = findLastKey; lodash.floor = floor; lodash.forEach = forEach; lodash.forEachRight = forEachRight; lodash.forIn = forIn; lodash.forInRight = forInRight; lodash.forOwn = forOwn; lodash.forOwnRight = forOwnRight; lodash.get = get; lodash.gt = gt; lodash.gte = gte; lodash.has = has; lodash.hasIn = hasIn; lodash.head = head; lodash.identity = identity; lodash.includes = includes; lodash.indexOf = indexOf; lodash.inRange = inRange; lodash.invoke = invoke; lodash.isArguments = isArguments; lodash.isArray = isArray; lodash.isArrayBuffer = isArrayBuffer; lodash.isArrayLike = isArrayLike; lodash.isArrayLikeObject = isArrayLikeObject; lodash.isBoolean = isBoolean; lodash.isBuffer = isBuffer; lodash.isDate = isDate; lodash.isElement = isElement; lodash.isEmpty = isEmpty; lodash.isEqual = isEqual; lodash.isEqualWith = isEqualWith; lodash.isError = isError; lodash.isFinite = isFinite; lodash.isFunction = isFunction; lodash.isInteger = isInteger; lodash.isLength = isLength; lodash.isMap = isMap; lodash.isMatch = isMatch; lodash.isMatchWith = isMatchWith; lodash.isNaN = isNaN; lodash.isNative = isNative; lodash.isNil = isNil; lodash.isNull = isNull; lodash.isNumber = isNumber; lodash.isObject = isObject; lodash.isObjectLike = isObjectLike; lodash.isPlainObject = isPlainObject; lodash.isRegExp = isRegExp; lodash.isSafeInteger = isSafeInteger; lodash.isSet = isSet; lodash.isString = isString; lodash.isSymbol = isSymbol; lodash.isTypedArray = isTypedArray; lodash.isUndefined = isUndefined; lodash.isWeakMap = isWeakMap; lodash.isWeakSet = isWeakSet; lodash.join = join; lodash.kebabCase = kebabCase; lodash.last = last; lodash.lastIndexOf = lastIndexOf; lodash.lowerCase = lowerCase; lodash.lowerFirst = lowerFirst; lodash.lt = lt; lodash.lte = lte; lodash.max = max; lodash.maxBy = maxBy; lodash.mean = mean; lodash.meanBy = meanBy; lodash.min = min; lodash.minBy = minBy; lodash.stubArray = stubArray; lodash.stubFalse = stubFalse; lodash.stubObject = stubObject; lodash.stubString = stubString; lodash.stubTrue = stubTrue; lodash.multiply = multiply; lodash.nth = nth; lodash.noConflict = noConflict; lodash.noop = noop; lodash.now = now; lodash.pad = pad; lodash.padEnd = padEnd; lodash.padStart = padStart; lodash.parseInt = parseInt; lodash.random = random; lodash.reduce = reduce; lodash.reduceRight = reduceRight; lodash.repeat = repeat; lodash.replace = replace; lodash.result = result; lodash.round = round; lodash.runInContext = runInContext; lodash.sample = sample; lodash.size = size; lodash.snakeCase = snakeCase; lodash.some = some; lodash.sortedIndex = sortedIndex; lodash.sortedIndexBy = sortedIndexBy; lodash.sortedIndexOf = sortedIndexOf; lodash.sortedLastIndex = sortedLastIndex; lodash.sortedLastIndexBy = sortedLastIndexBy; lodash.sortedLastIndexOf = sortedLastIndexOf; lodash.startCase = startCase; lodash.startsWith = startsWith; lodash.subtract = subtract; lodash.sum = sum; lodash.sumBy = sumBy; lodash.template = template; lodash.times = times; lodash.toFinite = toFinite; lodash.toInteger = toInteger; lodash.toLength = toLength; lodash.toLower = toLower; lodash.toNumber = toNumber; lodash.toSafeInteger = toSafeInteger; lodash.toString = toString; lodash.toUpper = toUpper; lodash.trim = trim; lodash.trimEnd = trimEnd; lodash.trimStart = trimStart; lodash.truncate = truncate; lodash.unescape = unescape; lodash.uniqueId = uniqueId; lodash.upperCase = upperCase; lodash.upperFirst = upperFirst; // Add aliases. lodash.each = forEach; lodash.eachRight = forEachRight; lodash.first = head; mixin(lodash, (function() { var source = {}; baseForOwn(lodash, function(func, methodName) { if (!hasOwnProperty.call(lodash.prototype, methodName)) { source[methodName] = func; } }); return source; }()), { 'chain': false }); /*------------------------------------------------------------------------*/ /** * The semantic version number. * * @static * @memberOf _ * @type {string} */ lodash.VERSION = VERSION; // Assign default placeholders. arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) { lodash[methodName].placeholder = lodash; }); // Add `LazyWrapper` methods for `_.drop` and `_.take` variants. arrayEach(['drop', 'take'], function(methodName, index) { LazyWrapper.prototype[methodName] = function(n) { n = n === undefined ? 1 : nativeMax(toInteger(n), 0); var result = (this.__filtered__ && !index) ? new LazyWrapper(this) : this.clone(); if (result.__filtered__) { result.__takeCount__ = nativeMin(n, result.__takeCount__); } else { result.__views__.push({ 'size': nativeMin(n, MAX_ARRAY_LENGTH), 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') }); } return result; }; LazyWrapper.prototype[methodName + 'Right'] = function(n) { return this.reverse()[methodName](n).reverse(); }; }); // Add `LazyWrapper` methods that accept an `iteratee` value. arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) { var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG; LazyWrapper.prototype[methodName] = function(iteratee) { var result = this.clone(); result.__iteratees__.push({ 'iteratee': getIteratee(iteratee, 3), 'type': type }); result.__filtered__ = result.__filtered__ || isFilter; return result; }; }); // Add `LazyWrapper` methods for `_.head` and `_.last`. arrayEach(['head', 'last'], function(methodName, index) { var takeName = 'take' + (index ? 'Right' : ''); LazyWrapper.prototype[methodName] = function() { return this[takeName](1).value()[0]; }; }); // Add `LazyWrapper` methods for `_.initial` and `_.tail`. arrayEach(['initial', 'tail'], function(methodName, index) { var dropName = 'drop' + (index ? '' : 'Right'); LazyWrapper.prototype[methodName] = function() { return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1); }; }); LazyWrapper.prototype.compact = function() { return this.filter(identity); }; LazyWrapper.prototype.find = function(predicate) { return this.filter(predicate).head(); }; LazyWrapper.prototype.findLast = function(predicate) { return this.reverse().find(predicate); }; LazyWrapper.prototype.invokeMap = baseRest(function(path, args) { if (typeof path == 'function') { return new LazyWrapper(this); } return this.map(function(value) { return baseInvoke(value, path, args); }); }); LazyWrapper.prototype.reject = function(predicate) { return this.filter(negate(getIteratee(predicate))); }; LazyWrapper.prototype.slice = function(start, end) { start = toInteger(start); var result = this; if (result.__filtered__ && (start > 0 || end < 0)) { return new LazyWrapper(result); } if (start < 0) { result = result.takeRight(-start); } else if (start) { result = result.drop(start); } if (end !== undefined) { end = toInteger(end); result = end < 0 ? result.dropRight(-end) : result.take(end - start); } return result; }; LazyWrapper.prototype.takeRightWhile = function(predicate) { return this.reverse().takeWhile(predicate).reverse(); }; LazyWrapper.prototype.toArray = function() { return this.take(MAX_ARRAY_LENGTH); }; // Add `LazyWrapper` methods to `lodash.prototype`. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName); if (!lodashFunc) { return; } lodash.prototype[methodName] = function() { var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value); var interceptor = function(value) { var result = lodashFunc.apply(lodash, arrayPush([value], args)); return (isTaker && chainAll) ? result[0] : result; }; if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) { // Avoid lazy use if the iteratee has a "length" value other than `1`. isLazy = useLazy = false; } var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid; if (!retUnwrapped && useLazy) { value = onlyLazy ? value : new LazyWrapper(this); var result = func.apply(value, args); result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined }); return new LodashWrapper(result, chainAll); } if (isUnwrapped && onlyLazy) { return func.apply(this, args); } result = this.thru(interceptor); return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result; }; }); // Add `Array` methods to `lodash.prototype`. arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) { var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName); lodash.prototype[methodName] = function() { var args = arguments; if (retUnwrapped && !this.__chain__) { var value = this.value(); return func.apply(isArray(value) ? value : [], args); } return this[chainName](function(value) { return func.apply(isArray(value) ? value : [], args); }); }; }); // Map minified method names to their real names. baseForOwn(LazyWrapper.prototype, function(func, methodName) { var lodashFunc = lodash[methodName]; if (lodashFunc) { var key = (lodashFunc.name + ''), names = realNames[key] || (realNames[key] = []); names.push({ 'name': methodName, 'func': lodashFunc }); } }); realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{ 'name': 'wrapper', 'func': undefined }]; // Add methods to `LazyWrapper`. LazyWrapper.prototype.clone = lazyClone; LazyWrapper.prototype.reverse = lazyReverse; LazyWrapper.prototype.value = lazyValue; // Add chain sequence methods to the `lodash` wrapper. lodash.prototype.at = wrapperAt; lodash.prototype.chain = wrapperChain; lodash.prototype.commit = wrapperCommit; lodash.prototype.next = wrapperNext; lodash.prototype.plant = wrapperPlant; lodash.prototype.reverse = wrapperReverse; lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue; // Add lazy aliases. lodash.prototype.first = lodash.prototype.head; if (symIterator) { lodash.prototype[symIterator] = wrapperToIterator; } return lodash; }); /*--------------------------------------------------------------------------*/ // Export lodash. var _ = runInContext(); // Some AMD build optimizers, like r.js, check for condition patterns like: if (true) { // Expose Lodash on the global object to prevent errors when Lodash is // loaded by a script tag in the presence of an AMD loader. // See http://requirejs.org/docs/errors.html#mismatch for more details. // Use `_.noConflict` to remove Lodash from the global object. root._ = _; // Define as an anonymous module so, through path mapping, it can be // referenced as the "underscore" module. !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return _; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); } // Check for `exports` after `define` in case a build optimizer adds it. else if (freeModule) { // Export for Node.js. (freeModule.exports = _)._ = _; // Export for CommonJS support. freeExports._ = _; } else { // Export to the global object. root._ = _; } }.call(this)); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)(module))) /***/ }), /* 5 */ /***/ (function(module, exports) { module.exports = function(module) { if(!module.webpackPolyfill) { module.deprecate = function() {}; module.paths = []; // module.parent = undefined by default module.children = []; module.webpackPolyfill = 1; } return module; } /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; Object.defineProperty(exports, "__esModule", { value: true }); var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); var _d2 = __webpack_require__(2); var _d3 = _interopRequireDefault(_d2); var _lodash = __webpack_require__(4); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } var PredictProba = function () { // svg: d3 object with the svg in question // class_names: array of class names // predict_probas: array of prediction probabilities function PredictProba(svg, class_names, predict_probas) { var title = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'Prediction probabilities'; _classCallCheck(this, PredictProba); var width = parseInt(svg.style('width')); this.names = class_names; this.names.push('Other'); if (class_names.length < 10) { this.colors = _d3.default.scale.category10().domain(this.names); this.colors_i = _d3.default.scale.category10().domain((0, _lodash.range)(this.names.length)); } else { this.colors = _d3.default.scale.category20().domain(this.names); this.colors_i = _d3.default.scale.category20().domain((0, _lodash.range)(this.names.length)); } var _map_classes = this.map_classes(this.names, predict_probas), _map_classes2 = _slicedToArray(_map_classes, 2), names = _map_classes2[0], data = _map_classes2[1]; var bar_x = width - 125; var class_names_width = bar_x; var bar_width = width - bar_x - 32; var x_scale = _d3.default.scale.linear().range([0, bar_width]); var bar_height = 17; var space_between_bars = 5; var bar_yshift = title === '' ? 0 : 35; var n_bars = Math.min(5, data.length); this.svg_height = n_bars * (bar_height + space_between_bars) + bar_yshift; svg.style('height', this.svg_height + 'px'); var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = function bar_y(i) { return (bar_height + space_between_bars) * i + bar_yshift; }; var bar = svg.append("g"); var _iteratorNormalCompletion = true; var _didIteratorError = false; var _iteratorError = undefined; try { for (var _iterator = (0, _lodash.range)(data.length)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) { var i = _step.value; var color = this.colors(names[i]); if (names[i] == 'Other' && this.names.length > 20) { color = '#5F9EA0'; } var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", x_scale(data[i])).style("fill", color); bar.append("rect").attr("x", bar_x).attr("y", bar_y(i)).attr("height", bar_height).attr("width", bar_width - 1).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); text = bar.append("text"); text.attr("x", bar_x + x_scale(data[i]) + 5).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif").text(data[i].toFixed(2)); text = bar.append("text"); text.attr("x", bar_x - 10).attr("y", bar_y(i) + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(names[i]); while (text.node().getBBox()['width'] + 1 > class_names_width - 10) { // TODO: ta mostrando só dois, e talvez quando hover mostrar o texto // todo var cur_text = text.text().slice(0, text.text().length - 5); text.text(cur_text + '...'); if (cur_text === '') { break; } } } } catch (err) { _didIteratorError = true; _iteratorError = err; } finally { try { if (!_iteratorNormalCompletion && _iterator.return) { _iterator.return(); } } finally { if (_didIteratorError) { throw _iteratorError; } } } } PredictProba.prototype.map_classes = function map_classes(class_names, predict_proba) { if (class_names.length 4 && arguments[4] !== undefined ? arguments[4] : 'Predicted value'; var log_coords = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false; _classCallCheck(this, PredictedValue); if (min_value == max_value) { var width_proportion = 1.0; } else { var width_proportion = (predicted_value - min_value) / (max_value - min_value); } var width = parseInt(svg.style('width')); this.color = _d2.default.scale.category10(); this.color('predicted_value'); // + 2 is due to it being a float var num_digits = Math.floor(Math.max(Math.log10(min_value), Math.log10(max_value))) + 2; num_digits = Math.max(num_digits, 3); var corner_width = 12 * num_digits; var corner_padding = 5.5 * num_digits; var bar_x = corner_width + corner_padding; var bar_width = width - corner_width * 2 - corner_padding * 2; var x_scale = _d2.default.scale.linear().range([0, bar_width]); var bar_height = 17; var bar_yshift = title === '' ? 0 : 35; var n_bars = 1; var this_object = this; if (title !== '') { svg.append('text').text(title).attr('x', 20).attr('y', 20); } var bar_y = bar_yshift; var bar = svg.append("g"); //filled in bar representing predicted value in range var rect = bar.append("rect"); rect.attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(width_proportion)).style("fill", this.color); //empty box representing range bar.append("rect").attr("x", bar_x).attr("y", bar_y).attr("height", bar_height).attr("width", x_scale(1)).attr("fill-opacity", 0).attr("stroke", "black"); var text = bar.append("text"); text.classed("prob_text", true); text.attr("y", bar_y + bar_height - 3).attr("fill", "black").style("font", "14px tahoma, sans-serif"); //text for min value text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text(min_value.toFixed(2)); //text for range min annotation var v_adjust_min_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x - corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "end").style("font", "14px tahoma, sans-serif").text("(min)"); //text for predicted value // console.log('bar height: ' + bar_height) text = bar.append("text"); text.text(predicted_value.toFixed(2)); // let h_adjust_predicted_value_text = text.node().getBBox().width / 2; var v_adjust_predicted_value_text = text.node().getBBox().height; text.attr("x", bar_x + x_scale(width_proportion)).attr("y", bar_y + bar_height + v_adjust_predicted_value_text).attr("fill", "black").attr("text-anchor", "middle").style("font", "14px tahoma, sans-serif"); //text for max value text = bar.append("text"); text.text(max_value.toFixed(2)); // let h_adjust = text.node().getBBox().width; text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif"); //text for range max annotation var v_adjust_max_value_annotation = text.node().getBBox().height; text = bar.append("text"); text.attr("x", bar_x + bar_width + corner_padding).attr("y", bar_y + bar_height - 3 + v_adjust_min_value_annotation).attr("fill", "black").attr("text-anchor", "begin").style("font", "14px tahoma, sans-serif").text("(max)"); //readjust svg size // let svg_width = width + 1 * h_adjust; // svg.style('width', svg_width + 'px'); this.svg_height = n_bars * bar_height + bar_yshift + 2 * text.node().getBBox().height + 10; svg.style('height', this.svg_height + 'px'); if (log_coords) { console.log("svg width: " + svg_width); console.log("svg height: " + this.svg_height); console.log("bar_y: " + bar_y); console.log("bar_x: " + bar_x); console.log("Min value: " + min_value); console.log("Max value: " + max_value); console.log("Pred value: " + predicted_value); } }; exports.default = PredictedValue; /***/ }), /* 8 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {"use strict"; __webpack_require__(9); __webpack_require__(335); __webpack_require__(336); if (global._babelPolyfill) { throw new Error("only one instance of babel-polyfill is allowed"); } global._babelPolyfill = true; var DEFINE_PROPERTY = "defineProperty"; function define(O, key, value) { O[key] || Object[DEFINE_PROPERTY](O, key, { writable: true, configurable: true, value: value }); } define(String.prototype, "padLeft", "".padStart); define(String.prototype, "padRight", "".padEnd); "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) { [][key] && define(Array, key, Function.call.bind([][key])); }); /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()))) /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(10); __webpack_require__(59); __webpack_require__(60); __webpack_require__(61); __webpack_require__(62); __webpack_require__(64); __webpack_require__(67); __webpack_require__(68); __webpack_require__(69); __webpack_require__(70); __webpack_require__(71); __webpack_require__(72); __webpack_require__(73); __webpack_require__(74); __webpack_require__(75); __webpack_require__(77); __webpack_require__(79); __webpack_require__(81); __webpack_require__(83); __webpack_require__(86); __webpack_require__(87); __webpack_require__(88); __webpack_require__(92); __webpack_require__(94); __webpack_require__(96); __webpack_require__(99); __webpack_require__(100); __webpack_require__(101); __webpack_require__(102); __webpack_require__(104); __webpack_require__(105); __webpack_require__(106); __webpack_require__(107); __webpack_require__(108); __webpack_require__(109); __webpack_require__(110); __webpack_require__(112); __webpack_require__(113); __webpack_require__(114); __webpack_require__(116); __webpack_require__(117); __webpack_require__(118); __webpack_require__(120); __webpack_require__(122); __webpack_require__(123); __webpack_require__(124); __webpack_require__(125); __webpack_require__(126); __webpack_require__(127); __webpack_require__(128); __webpack_require__(129); __webpack_require__(130); __webpack_require__(131); __webpack_require__(132); __webpack_require__(133); __webpack_require__(134); __webpack_require__(139); __webpack_require__(140); __webpack_require__(144); __webpack_require__(145); __webpack_require__(146); __webpack_require__(147); __webpack_require__(149); __webpack_require__(150); __webpack_require__(151); __webpack_require__(152); __webpack_require__(153); __webpack_require__(154); __webpack_require__(155); __webpack_require__(156); __webpack_require__(157); __webpack_require__(158); __webpack_require__(159); __webpack_require__(160); __webpack_require__(161); __webpack_require__(162); __webpack_require__(163); __webpack_require__(165); __webpack_require__(166); __webpack_require__(168); __webpack_require__(169); __webpack_require__(175); __webpack_require__(176); __webpack_require__(178); __webpack_require__(179); __webpack_require__(180); __webpack_require__(184); __webpack_require__(185); __webpack_require__(186); __webpack_require__(187); __webpack_require__(188); __webpack_require__(190); __webpack_require__(191); __webpack_require__(192); __webpack_require__(193); __webpack_require__(196); __webpack_require__(198); __webpack_require__(199); __webpack_require__(200); __webpack_require__(202); __webpack_require__(204); __webpack_require__(206); __webpack_require__(208); __webpack_require__(209); __webpack_require__(210); __webpack_require__(214); __webpack_require__(215); __webpack_require__(216); __webpack_require__(218); __webpack_require__(228); __webpack_require__(232); __webpack_require__(233); __webpack_require__(235); __webpack_require__(236); __webpack_require__(240); __webpack_require__(241); __webpack_require__(243); __webpack_require__(244); __webpack_require__(245); __webpack_require__(246); __webpack_require__(247); __webpack_require__(248); __webpack_require__(249); __webpack_require__(250); __webpack_require__(251); __webpack_require__(252); __webpack_require__(253); __webpack_require__(254); __webpack_require__(255); __webpack_require__(256); __webpack_require__(257); __webpack_require__(258); __webpack_require__(259); __webpack_require__(260); __webpack_require__(261); __webpack_require__(263); __webpack_require__(264); __webpack_require__(265); __webpack_require__(266); __webpack_require__(267); __webpack_require__(269); __webpack_require__(270); __webpack_require__(271); __webpack_require__(273); __webpack_require__(274); __webpack_require__(275); __webpack_require__(276); __webpack_require__(277); __webpack_require__(278); __webpack_require__(279); __webpack_require__(280); __webpack_require__(282); __webpack_require__(283); __webpack_require__(285); __webpack_require__(286); __webpack_require__(287); __webpack_require__(288); __webpack_require__(291); __webpack_require__(292); __webpack_require__(294); __webpack_require__(295); __webpack_require__(296); __webpack_require__(297); __webpack_require__(299); __webpack_require__(300); __webpack_require__(301); __webpack_require__(302); __webpack_require__(303); __webpack_require__(304); __webpack_require__(305); __webpack_require__(306); __webpack_require__(307); __webpack_require__(308); __webpack_require__(310); __webpack_require__(311); __webpack_require__(312); __webpack_require__(313); __webpack_require__(314); __webpack_require__(315); __webpack_require__(316); __webpack_require__(317); __webpack_require__(318); __webpack_require__(319); __webpack_require__(320); __webpack_require__(322); __webpack_require__(323); __webpack_require__(324); __webpack_require__(325); __webpack_require__(326); __webpack_require__(327); __webpack_require__(328); __webpack_require__(329); __webpack_require__(330); __webpack_require__(331); __webpack_require__(332); __webpack_require__(333); __webpack_require__(334); module.exports = __webpack_require__(16); /***/ }), /* 10 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // ECMAScript 6 symbols shim var global = __webpack_require__(11); var has = __webpack_require__(12); var DESCRIPTORS = __webpack_require__(13); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var META = __webpack_require__(32).KEY; var $fails = __webpack_require__(14); var shared = __webpack_require__(28); var setToStringTag = __webpack_require__(33); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var wksExt = __webpack_require__(35); var wksDefine = __webpack_require__(36); var enumKeys = __webpack_require__(37); var isArray = __webpack_require__(52); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var createDesc = __webpack_require__(24); var _create = __webpack_require__(53); var gOPNExt = __webpack_require__(56); var $GOPD = __webpack_require__(58); var $DP = __webpack_require__(18); var $keys = __webpack_require__(38); var gOPD = $GOPD.f; var dP = $DP.f; var gOPN = gOPNExt.f; var $Symbol = global.Symbol; var $JSON = global.JSON; var _stringify = $JSON && $JSON.stringify; var PROTOTYPE = 'prototype'; var HIDDEN = wks('_hidden'); var TO_PRIMITIVE = wks('toPrimitive'); var isEnum = {}.propertyIsEnumerable; var SymbolRegistry = shared('symbol-registry'); var AllSymbols = shared('symbols'); var OPSymbols = shared('op-symbols'); var ObjectProto = Object[PROTOTYPE]; var USE_NATIVE = typeof $Symbol == 'function'; var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173 var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687 var setSymbolDesc = DESCRIPTORS && $fails(function () { return _create(dP({}, 'a', { get: function () { return dP(this, 'a', { value: 7 }).a; } })).a != 7; }) ? function (it, key, D) { var protoDesc = gOPD(ObjectProto, key); if (protoDesc) delete ObjectProto[key]; dP(it, key, D); if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc); } : dP; var wrap = function (tag) { var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]); sym._k = tag; return sym; }; var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) { return typeof it == 'symbol'; } : function (it) { return it instanceof $Symbol; }; var $defineProperty = function defineProperty(it, key, D) { if (it === ObjectProto) $defineProperty(OPSymbols, key, D); anObject(it); key = toPrimitive(key, true); anObject(D); if (has(AllSymbols, key)) { if (!D.enumerable) { if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {})); it[HIDDEN][key] = true; } else { if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false; D = _create(D, { enumerable: createDesc(0, false) }); } return setSymbolDesc(it, key, D); } return dP(it, key, D); }; var $defineProperties = function defineProperties(it, P) { anObject(it); var keys = enumKeys(P = toIObject(P)); var i = 0; var l = keys.length; var key; while (l > i) $defineProperty(it, key = keys[i++], P[key]); return it; }; var $create = function create(it, P) { return P === undefined ? _create(it) : $defineProperties(_create(it), P); }; var $propertyIsEnumerable = function propertyIsEnumerable(key) { var E = isEnum.call(this, key = toPrimitive(key, true)); if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false; return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) { it = toIObject(it); key = toPrimitive(key, true); if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return; var D = gOPD(it, key); if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true; return D; }; var $getOwnPropertyNames = function getOwnPropertyNames(it) { var names = gOPN(toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key); } return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(it) { var IS_OP = it === ObjectProto; var names = gOPN(IS_OP ? OPSymbols : toIObject(it)); var result = []; var i = 0; var key; while (names.length > i) { if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]); } return result; }; // 19.4.1.1 Symbol([description]) if (!USE_NATIVE) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!'); var tag = uid(arguments.length > 0 ? arguments[0] : undefined); var $set = function (value) { if (this === ObjectProto) $set.call(OPSymbols, value); if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDesc(this, tag, createDesc(1, value)); }; if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set }); return wrap(tag); }; redefine($Symbol[PROTOTYPE], 'toString', function toString() { return this._k; }); $GOPD.f = $getOwnPropertyDescriptor; $DP.f = $defineProperty; __webpack_require__(57).f = gOPNExt.f = $getOwnPropertyNames; __webpack_require__(51).f = $propertyIsEnumerable; __webpack_require__(50).f = $getOwnPropertySymbols; if (DESCRIPTORS && !__webpack_require__(29)) { redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true); } wksExt.f = function (name) { return wrap(wks(name)); }; } $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol }); for (var es6Symbols = ( // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14 'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables' ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]); for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]); $export($export.S + $export.F * !USE_NATIVE, 'Symbol', { // 19.4.2.1 Symbol.for(key) 'for': function (key) { return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key); }, // 19.4.2.5 Symbol.keyFor(sym) keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!'); for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key; }, useSetter: function () { setter = true; }, useSimple: function () { setter = false; } }); $export($export.S + $export.F * !USE_NATIVE, 'Object', { // 19.1.2.2 Object.create(O [, Properties]) create: $create, // 19.1.2.4 Object.defineProperty(O, P, Attributes) defineProperty: $defineProperty, // 19.1.2.3 Object.defineProperties(O, Properties) defineProperties: $defineProperties, // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) getOwnPropertyDescriptor: $getOwnPropertyDescriptor, // 19.1.2.7 Object.getOwnPropertyNames(O) getOwnPropertyNames: $getOwnPropertyNames, // 19.1.2.8 Object.getOwnPropertySymbols(O) getOwnPropertySymbols: $getOwnPropertySymbols }); // 24.3.2 JSON.stringify(value [, replacer [, space]]) $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () { var S = $Symbol(); // MS Edge converts symbol values to JSON as {} // WebKit converts symbol values to JSON as null // V8 throws on boxed symbols return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}'; })), 'JSON', { stringify: function stringify(it) { var args = [it]; var i = 1; var replacer, $replacer; while (arguments.length > i) args.push(arguments[i++]); $replacer = replacer = args[1]; if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == 'function') value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return _stringify.apply($JSON, args); } }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint) $Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(17)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag] setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag] setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag] setToStringTag(global.JSON, 'JSON', true); /***/ }), /* 11 */ /***/ (function(module, exports) { // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028 var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func : Function('return this')(); if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef /***/ }), /* 12 */ /***/ (function(module, exports) { var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); }; /***/ }), /* 13 */ /***/ (function(module, exports, __webpack_require__) { // Thank's IE8 for his funny defineProperty module.exports = !__webpack_require__(14)(function () { return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 14 */ /***/ (function(module, exports) { module.exports = function (exec) { try { return !!exec(); } catch (e) { return true; } }; /***/ }), /* 15 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var hide = __webpack_require__(17); var redefine = __webpack_require__(25); var ctx = __webpack_require__(30); var PROTOTYPE = 'prototype'; var $export = function (type, name, source) { var IS_FORCED = type & $export.F; var IS_GLOBAL = type & $export.G; var IS_STATIC = type & $export.S; var IS_PROTO = type & $export.P; var IS_BIND = type & $export.B; var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]; var exports = IS_GLOBAL ? core : core[name] || (core[name] = {}); var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {}); var key, own, out, exp; if (IS_GLOBAL) source = name; for (key in source) { // contains in native own = !IS_FORCED && target && target[key] !== undefined; // export native or passed out = (own ? target : source)[key]; // bind timers to global for call from export context exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global if (target) redefine(target, key, out, type & $export.U); // export if (exports[key] != out) hide(exports, key, exp); if (IS_PROTO && expProto[key] != out) expProto[key] = out; } }; global.core = core; // type bitmap $export.F = 1; // forced $export.G = 2; // global $export.S = 4; // static $export.P = 8; // proto $export.B = 16; // bind $export.W = 32; // wrap $export.U = 64; // safe $export.R = 128; // real proto method for `library` module.exports = $export; /***/ }), /* 16 */ /***/ (function(module, exports) { var core = module.exports = { version: '2.6.5' }; if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef /***/ }), /* 17 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var createDesc = __webpack_require__(24); module.exports = __webpack_require__(13) ? function (object, key, value) { return dP.f(object, key, createDesc(1, value)); } : function (object, key, value) { object[key] = value; return object; }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { var anObject = __webpack_require__(19); var IE8_DOM_DEFINE = __webpack_require__(21); var toPrimitive = __webpack_require__(23); var dP = Object.defineProperty; exports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return dP(O, P, Attributes); } catch (e) { /* empty */ } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!'); if ('value' in Attributes) O[P] = Attributes.value; return O; }; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); module.exports = function (it) { if (!isObject(it)) throw TypeError(it + ' is not an object!'); return it; }; /***/ }), /* 20 */ /***/ (function(module, exports) { module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; }; /***/ }), /* 21 */ /***/ (function(module, exports, __webpack_require__) { module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () { return Object.defineProperty(__webpack_require__(22)('div'), 'a', { get: function () { return 7; } }).a != 7; }); /***/ }), /* 22 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var document = __webpack_require__(11).document; // typeof document.createElement is 'object' in old IE var is = isObject(document) && isObject(document.createElement); module.exports = function (it) { return is ? document.createElement(it) : {}; }; /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.1 ToPrimitive(input [, PreferredType]) var isObject = __webpack_require__(20); // instead of the ES6 spec version, we didn't implement @@toPrimitive case // and the second argument - flag - preferred type is a string module.exports = function (it, S) { if (!isObject(it)) return it; var fn, val; if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val; if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val; throw TypeError("Can't convert object to primitive value"); }; /***/ }), /* 24 */ /***/ (function(module, exports) { module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; }; /***/ }), /* 25 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var hide = __webpack_require__(17); var has = __webpack_require__(12); var SRC = __webpack_require__(26)('src'); var $toString = __webpack_require__(27); var TO_STRING = 'toString'; var TPL = ('' + $toString).split(TO_STRING); __webpack_require__(16).inspectSource = function (it) { return $toString.call(it); }; (module.exports = function (O, key, val, safe) { var isFunction = typeof val == 'function'; if (isFunction) has(val, 'name') || hide(val, 'name', key); if (O[key] === val) return; if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key))); if (O === global) { O[key] = val; } else if (!safe) { delete O[key]; hide(O, key, val); } else if (O[key]) { O[key] = val; } else { hide(O, key, val); } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative })(Function.prototype, TO_STRING, function toString() { return typeof this == 'function' && this[SRC] || $toString.call(this); }); /***/ }), /* 26 */ /***/ (function(module, exports) { var id = 0; var px = Math.random(); module.exports = function (key) { return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36)); }; /***/ }), /* 27 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(28)('native-function-to-string', Function.toString); /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { var core = __webpack_require__(16); var global = __webpack_require__(11); var SHARED = '__core-js_shared__'; var store = global[SHARED] || (global[SHARED] = {}); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: core.version, mode: __webpack_require__(29) ? 'pure' : 'global', copyright: '© 2019 Denis Pushkarev (zloirock.ru)' }); /***/ }), /* 29 */ /***/ (function(module, exports) { module.exports = false; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { // optional / simple context binding var aFunction = __webpack_require__(31); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function (/* ...args */) { return fn.apply(that, arguments); }; }; /***/ }), /* 31 */ /***/ (function(module, exports) { module.exports = function (it) { if (typeof it != 'function') throw TypeError(it + ' is not a function!'); return it; }; /***/ }), /* 32 */ /***/ (function(module, exports, __webpack_require__) { var META = __webpack_require__(26)('meta'); var isObject = __webpack_require__(20); var has = __webpack_require__(12); var setDesc = __webpack_require__(18).f; var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var FREEZE = !__webpack_require__(14)(function () { return isExtensible(Object.preventExtensions({})); }); var setMeta = function (it) { setDesc(it, META, { value: { i: 'O' + ++id, // object ID w: {} // weak collections IDs } }); }; var fastKey = function (it, create) { // return primitive with prefix if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return 'F'; // not necessary to add metadata if (!create) return 'E'; // add missing metadata setMeta(it); // return object ID } return it[META].i; }; var getWeak = function (it, create) { if (!has(it, META)) { // can't set metadata to uncaught frozen object if (!isExtensible(it)) return true; // not necessary to add metadata if (!create) return false; // add missing metadata setMeta(it); // return hash weak collections IDs } return it[META].w; }; // add metadata on freeze-family methods calling var onFreeze = function (it) { if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it); return it; }; var meta = module.exports = { KEY: META, NEED: false, fastKey: fastKey, getWeak: getWeak, onFreeze: onFreeze }; /***/ }), /* 33 */ /***/ (function(module, exports, __webpack_require__) { var def = __webpack_require__(18).f; var has = __webpack_require__(12); var TAG = __webpack_require__(34)('toStringTag'); module.exports = function (it, tag, stat) { if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag }); }; /***/ }), /* 34 */ /***/ (function(module, exports, __webpack_require__) { var store = __webpack_require__(28)('wks'); var uid = __webpack_require__(26); var Symbol = __webpack_require__(11).Symbol; var USE_SYMBOL = typeof Symbol == 'function'; var $exports = module.exports = function (name) { return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name)); }; $exports.store = store; /***/ }), /* 35 */ /***/ (function(module, exports, __webpack_require__) { exports.f = __webpack_require__(34); /***/ }), /* 36 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var core = __webpack_require__(16); var LIBRARY = __webpack_require__(29); var wksExt = __webpack_require__(35); var defineProperty = __webpack_require__(18).f; module.exports = function (name) { var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {}); if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) }); }; /***/ }), /* 37 */ /***/ (function(module, exports, __webpack_require__) { // all enumerable object keys, includes symbols var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); module.exports = function (it) { var result = getKeys(it); var getSymbols = gOPS.f; if (getSymbols) { var symbols = getSymbols(it); var isEnum = pIE.f; var i = 0; var key; while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key); } return result; }; /***/ }), /* 38 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 / 15.2.3.14 Object.keys(O) var $keys = __webpack_require__(39); var enumBugKeys = __webpack_require__(49); module.exports = Object.keys || function keys(O) { return $keys(O, enumBugKeys); }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { var has = __webpack_require__(12); var toIObject = __webpack_require__(40); var arrayIndexOf = __webpack_require__(44)(false); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); module.exports = function (object, names) { var O = toIObject(object); var i = 0; var result = []; var key; for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys while (names.length > i) if (has(O, key = names[i++])) { ~arrayIndexOf(result, key) || result.push(key); } return result; }; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { // to indexed object, toObject with fallback for non-array-like ES3 strings var IObject = __webpack_require__(41); var defined = __webpack_require__(43); module.exports = function (it) { return IObject(defined(it)); }; /***/ }), /* 41 */ /***/ (function(module, exports, __webpack_require__) { // fallback for non-array-like ES3 and non-enumerable old V8 strings var cof = __webpack_require__(42); // eslint-disable-next-line no-prototype-builtins module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) { return cof(it) == 'String' ? it.split('') : Object(it); }; /***/ }), /* 42 */ /***/ (function(module, exports) { var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); }; /***/ }), /* 43 */ /***/ (function(module, exports) { // 7.2.1 RequireObjectCoercible(argument) module.exports = function (it) { if (it == undefined) throw TypeError("Can't call method on " + it); return it; }; /***/ }), /* 44 */ /***/ (function(module, exports, __webpack_require__) { // false -> Array#indexOf // true -> Array#includes var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); var toAbsoluteIndex = __webpack_require__(47); module.exports = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; // Array#includes uses SameValueZero equality algorithm // eslint-disable-next-line no-self-compare if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; // eslint-disable-next-line no-self-compare if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not } else for (;length > index; index++) if (IS_INCLUDES || index in O) { if (O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; /***/ }), /* 45 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.15 ToLength var toInteger = __webpack_require__(46); var min = Math.min; module.exports = function (it) { return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991 }; /***/ }), /* 46 */ /***/ (function(module, exports) { // 7.1.4 ToInteger var ceil = Math.ceil; var floor = Math.floor; module.exports = function (it) { return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it); }; /***/ }), /* 47 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var max = Math.max; var min = Math.min; module.exports = function (index, length) { index = toInteger(index); return index < 0 ? max(index + length, 0) : min(index, length); }; /***/ }), /* 48 */ /***/ (function(module, exports, __webpack_require__) { var shared = __webpack_require__(28)('keys'); var uid = __webpack_require__(26); module.exports = function (key) { return shared[key] || (shared[key] = uid(key)); }; /***/ }), /* 49 */ /***/ (function(module, exports) { // IE 8- don't enum bug keys module.exports = ( 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf' ).split(','); /***/ }), /* 50 */ /***/ (function(module, exports) { exports.f = Object.getOwnPropertySymbols; /***/ }), /* 51 */ /***/ (function(module, exports) { exports.f = {}.propertyIsEnumerable; /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.2 IsArray(argument) var cof = __webpack_require__(42); module.exports = Array.isArray || function isArray(arg) { return cof(arg) == 'Array'; }; /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) var anObject = __webpack_require__(19); var dPs = __webpack_require__(54); var enumBugKeys = __webpack_require__(49); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var Empty = function () { /* empty */ }; var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype var createDict = function () { // Thrash, waste and sodomy: IE GC bug var iframe = __webpack_require__(22)('iframe'); var i = enumBugKeys.length; var lt = ''; var iframeDocument; iframe.style.display = 'none'; __webpack_require__(55).appendChild(iframe); iframe.src = 'javascript:'; // eslint-disable-line no-script-url // createDict = iframe.contentWindow.Object; // html.removeChild(iframe); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt); iframeDocument.close(); createDict = iframeDocument.F; while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]]; return createDict(); }; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { Empty[PROTOTYPE] = anObject(O); result = new Empty(); Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill result[IE_PROTO] = O; } else result = createDict(); return Properties === undefined ? result : dPs(result, Properties); }; /***/ }), /* 54 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18); var anObject = __webpack_require__(19); var getKeys = __webpack_require__(38); module.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = getKeys(Properties); var length = keys.length; var i = 0; var P; while (length > i) dP.f(O, P = keys[i++], Properties[P]); return O; }; /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { var document = __webpack_require__(11).document; module.exports = document && document.documentElement; /***/ }), /* 56 */ /***/ (function(module, exports, __webpack_require__) { // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window var toIObject = __webpack_require__(40); var gOPN = __webpack_require__(57).f; var toString = {}.toString; var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return gOPN(it); } catch (e) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it)); }; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O) var $keys = __webpack_require__(39); var hiddenKeys = __webpack_require__(49).concat('length', 'prototype'); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return $keys(O, hiddenKeys); }; /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { var pIE = __webpack_require__(51); var createDesc = __webpack_require__(24); var toIObject = __webpack_require__(40); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var IE8_DOM_DEFINE = __webpack_require__(21); var gOPD = Object.getOwnPropertyDescriptor; exports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) { O = toIObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return gOPD(O, P); } catch (e) { /* empty */ } if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]); }; /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties]) $export($export.S, 'Object', { create: __webpack_require__(53) }); /***/ }), /* 60 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(18).f }); /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties) $export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperties: __webpack_require__(54) }); /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P) var toIObject = __webpack_require__(40); var $getOwnPropertyDescriptor = __webpack_require__(58).f; __webpack_require__(63)('getOwnPropertyDescriptor', function () { return function getOwnPropertyDescriptor(it, key) { return $getOwnPropertyDescriptor(toIObject(it), key); }; }); /***/ }), /* 63 */ /***/ (function(module, exports, __webpack_require__) { // most Object methods by ES6 should accept primitives var $export = __webpack_require__(15); var core = __webpack_require__(16); var fails = __webpack_require__(14); module.exports = function (KEY, exec) { var fn = (core.Object || {})[KEY] || Object[KEY]; var exp = {}; exp[KEY] = exec(fn); $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp); }; /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 Object.getPrototypeOf(O) var toObject = __webpack_require__(65); var $getPrototypeOf = __webpack_require__(66); __webpack_require__(63)('getPrototypeOf', function () { return function getPrototypeOf(it) { return $getPrototypeOf(toObject(it)); }; }); /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { // 7.1.13 ToObject(argument) var defined = __webpack_require__(43); module.exports = function (it) { return Object(defined(it)); }; /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O) var has = __webpack_require__(12); var toObject = __webpack_require__(65); var IE_PROTO = __webpack_require__(48)('IE_PROTO'); var ObjectProto = Object.prototype; module.exports = Object.getPrototypeOf || function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectProto : null; }; /***/ }), /* 67 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.14 Object.keys(O) var toObject = __webpack_require__(65); var $keys = __webpack_require__(38); __webpack_require__(63)('keys', function () { return function keys(it) { return $keys(toObject(it)); }; }); /***/ }), /* 68 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.7 Object.getOwnPropertyNames(O) __webpack_require__(63)('getOwnPropertyNames', function () { return __webpack_require__(56).f; }); /***/ }), /* 69 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.5 Object.freeze(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('freeze', function ($freeze) { return function freeze(it) { return $freeze && isObject(it) ? $freeze(meta(it)) : it; }; }); /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.17 Object.seal(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('seal', function ($seal) { return function seal(it) { return $seal && isObject(it) ? $seal(meta(it)) : it; }; }); /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.15 Object.preventExtensions(O) var isObject = __webpack_require__(20); var meta = __webpack_require__(32).onFreeze; __webpack_require__(63)('preventExtensions', function ($preventExtensions) { return function preventExtensions(it) { return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it; }; }); /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.12 Object.isFrozen(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isFrozen', function ($isFrozen) { return function isFrozen(it) { return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true; }; }); /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.13 Object.isSealed(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isSealed', function ($isSealed) { return function isSealed(it) { return isObject(it) ? $isSealed ? $isSealed(it) : false : true; }; }); /***/ }), /* 74 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.2.11 Object.isExtensible(O) var isObject = __webpack_require__(20); __webpack_require__(63)('isExtensible', function ($isExtensible) { return function isExtensible(it) { return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false; }; }); /***/ }), /* 75 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.1 Object.assign(target, source) var $export = __webpack_require__(15); $export($export.S + $export.F, 'Object', { assign: __webpack_require__(76) }); /***/ }), /* 76 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.2.1 Object.assign(target, source, ...) var getKeys = __webpack_require__(38); var gOPS = __webpack_require__(50); var pIE = __webpack_require__(51); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug) module.exports = !$assign || __webpack_require__(14)(function () { var A = {}; var B = {}; // eslint-disable-next-line no-undef var S = Symbol(); var K = 'abcdefghijklmnopqrst'; A[S] = 7; K.split('').forEach(function (k) { B[k] = k; }); return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K; }) ? function assign(target, source) { // eslint-disable-line no-unused-vars var T = toObject(target); var aLen = arguments.length; var index = 1; var getSymbols = gOPS.f; var isEnum = pIE.f; while (aLen > index) { var S = IObject(arguments[index++]); var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S); var length = keys.length; var j = 0; var key; while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key]; } return T; } : $assign; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.10 Object.is(value1, value2) var $export = __webpack_require__(15); $export($export.S, 'Object', { is: __webpack_require__(78) }); /***/ }), /* 78 */ /***/ (function(module, exports) { // 7.2.9 SameValue(x, y) module.exports = Object.is || function is(x, y) { // eslint-disable-next-line no-self-compare return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y; }; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { // 19.1.3.19 Object.setPrototypeOf(O, proto) var $export = __webpack_require__(15); $export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set }); /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { // Works with __proto__ only. Old v8 can't work with null proto objects. /* eslint-disable no-proto */ var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); var check = function (O, proto) { anObject(O); if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!"); }; module.exports = { set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line function (test, buggy, set) { try { set = __webpack_require__(30)(Function.call, __webpack_require__(58).f(Object.prototype, '__proto__').set, 2); set(test, []); buggy = !(test instanceof Array); } catch (e) { buggy = true; } return function setPrototypeOf(O, proto) { check(O, proto); if (buggy) O.__proto__ = proto; else set(O, proto); return O; }; }({}, false) : undefined), check: check }; /***/ }), /* 81 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 19.1.3.6 Object.prototype.toString() var classof = __webpack_require__(82); var test = {}; test[__webpack_require__(34)('toStringTag')] = 'z'; if (test + '' != '[object z]') { __webpack_require__(25)(Object.prototype, 'toString', function toString() { return '[object ' + classof(this) + ']'; }, true); } /***/ }), /* 82 */ /***/ (function(module, exports, __webpack_require__) { // getting tag from 19.1.3.6 Object.prototype.toString() var cof = __webpack_require__(42); var TAG = __webpack_require__(34)('toStringTag'); // ES3 wrong here var ARG = cof(function () { return arguments; }()) == 'Arguments'; // fallback for IE11 Script Access Denied error var tryGet = function (it, key) { try { return it[key]; } catch (e) { /* empty */ } }; module.exports = function (it) { var O, T, B; return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case : ARG ? cof(O) // ES3 arguments fallback : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B; }; /***/ }), /* 83 */ /***/ (function(module, exports, __webpack_require__) { // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...) var $export = __webpack_require__(15); $export($export.P, 'Function', { bind: __webpack_require__(84) }); /***/ }), /* 84 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var aFunction = __webpack_require__(31); var isObject = __webpack_require__(20); var invoke = __webpack_require__(85); var arraySlice = [].slice; var factories = {}; var construct = function (F, len, args) { if (!(len in factories)) { for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')'); } return factories[len](F, args); }; module.exports = Function.bind || function bind(that /* , ...args */) { var fn = aFunction(this); var partArgs = arraySlice.call(arguments, 1); var bound = function (/* args... */) { var args = partArgs.concat(arraySlice.call(arguments)); return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that); }; if (isObject(fn.prototype)) bound.prototype = fn.prototype; return bound; }; /***/ }), /* 85 */ /***/ (function(module, exports) { // fast apply, http://jsperf.lnkit.com/fast-apply/5 module.exports = function (fn, args, that) { var un = that === undefined; switch (args.length) { case 0: return un ? fn() : fn.call(that); case 1: return un ? fn(args[0]) : fn.call(that, args[0]); case 2: return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]); case 3: return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]); case 4: return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]); } return fn.apply(that, args); }; /***/ }), /* 86 */ /***/ (function(module, exports, __webpack_require__) { var dP = __webpack_require__(18).f; var FProto = Function.prototype; var nameRE = /^\s*function ([^ (]*)/; var NAME = 'name'; // 19.2.4.2 name NAME in FProto || __webpack_require__(13) && dP(FProto, NAME, { configurable: true, get: function () { try { return ('' + this).match(nameRE)[1]; } catch (e) { return ''; } } }); /***/ }), /* 87 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var isObject = __webpack_require__(20); var getPrototypeOf = __webpack_require__(66); var HAS_INSTANCE = __webpack_require__(34)('hasInstance'); var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V) if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(18).f(FunctionProto, HAS_INSTANCE, { value: function (O) { if (typeof this != 'function' || !isObject(O)) return false; if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this: while (O = getPrototypeOf(O)) if (this.prototype === O) return true; return false; } }); /***/ }), /* 88 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseInt = __webpack_require__(89); // 18.2.5 parseInt(string, radix) $export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt }); /***/ }), /* 89 */ /***/ (function(module, exports, __webpack_require__) { var $parseInt = __webpack_require__(11).parseInt; var $trim = __webpack_require__(90).trim; var ws = __webpack_require__(91); var hex = /^[-+]?0[xX]/; module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) { var string = $trim(String(str), 3); return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10)); } : $parseInt; /***/ }), /* 90 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var defined = __webpack_require__(43); var fails = __webpack_require__(14); var spaces = __webpack_require__(91); var space = '[' + spaces + ']'; var non = '\u200b\u0085'; var ltrim = RegExp('^' + space + space + '*'); var rtrim = RegExp(space + space + '*$'); var exporter = function (KEY, exec, ALIAS) { var exp = {}; var FORCE = fails(function () { return !!spaces[KEY]() || non[KEY]() != non; }); var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY]; if (ALIAS) exp[ALIAS] = fn; $export($export.P + $export.F * FORCE, 'String', exp); }; // 1 -> String#trimLeft // 2 -> String#trimRight // 3 -> String#trim var trim = exporter.trim = function (string, TYPE) { string = String(defined(string)); if (TYPE & 1) string = string.replace(ltrim, ''); if (TYPE & 2) string = string.replace(rtrim, ''); return string; }; module.exports = exporter; /***/ }), /* 91 */ /***/ (function(module, exports) { module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF'; /***/ }), /* 92 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $parseFloat = __webpack_require__(93); // 18.2.4 parseFloat(string) $export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat }); /***/ }), /* 93 */ /***/ (function(module, exports, __webpack_require__) { var $parseFloat = __webpack_require__(11).parseFloat; var $trim = __webpack_require__(90).trim; module.exports = 1 / $parseFloat(__webpack_require__(91) + '-0') !== -Infinity ? function parseFloat(str) { var string = $trim(String(str), 3); var result = $parseFloat(string); return result === 0 && string.charAt(0) == '-' ? -0 : result; } : $parseFloat; /***/ }), /* 94 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var has = __webpack_require__(12); var cof = __webpack_require__(42); var inheritIfRequired = __webpack_require__(95); var toPrimitive = __webpack_require__(23); var fails = __webpack_require__(14); var gOPN = __webpack_require__(57).f; var gOPD = __webpack_require__(58).f; var dP = __webpack_require__(18).f; var $trim = __webpack_require__(90).trim; var NUMBER = 'Number'; var $Number = global[NUMBER]; var Base = $Number; var proto = $Number.prototype; // Opera ~12 has broken Object#toString var BROKEN_COF = cof(__webpack_require__(53)(proto)) == NUMBER; var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument) var toNumber = function (argument) { var it = toPrimitive(argument, false); if (typeof it == 'string' && it.length > 2) { it = TRIM ? it.trim() : $trim(it, 3); var first = it.charCodeAt(0); var third, radix, maxCode; if (first === 43 || first === 45) { third = it.charCodeAt(2); if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix } else if (first === 48) { switch (it.charCodeAt(1)) { case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i default: return +it; } for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) { code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol // but ToNumber should return NaN if a string contains unavailable symbols if (code < 48 || code > maxCode) return NaN; } return parseInt(digits, radix); } } return +it; }; if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) { $Number = function Number(value) { var it = arguments.length < 1 ? 0 : value; var that = this; return that instanceof $Number // check on 1..constructor(foo) case && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it); }; for (var keys = __webpack_require__(13) ? gOPN(Base) : ( // ES3: 'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before): 'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger' ).split(','), j = 0, key; keys.length > j; j++) { if (has(Base, key = keys[j]) && !has($Number, key)) { dP($Number, key, gOPD(Base, key)); } } $Number.prototype = proto; proto.constructor = $Number; __webpack_require__(25)(global, NUMBER, $Number); } /***/ }), /* 95 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var setPrototypeOf = __webpack_require__(80).set; module.exports = function (that, target, C) { var S = target.constructor; var P; if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) { setPrototypeOf(that, P); } return that; }; /***/ }), /* 96 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toInteger = __webpack_require__(46); var aNumberValue = __webpack_require__(97); var repeat = __webpack_require__(98); var $toFixed = 1.0.toFixed; var floor = Math.floor; var data = [0, 0, 0, 0, 0, 0]; var ERROR = 'Number.toFixed: incorrect invocation!'; var ZERO = '0'; var multiply = function (n, c) { var i = -1; var c2 = c; while (++i < 6) { c2 += n * data[i]; data[i] = c2 % 1e7; c2 = floor(c2 / 1e7); } }; var divide = function (n) { var i = 6; var c = 0; while (--i >= 0) { c += data[i]; data[i] = floor(c / n); c = (c % n) * 1e7; } }; var numToString = function () { var i = 6; var s = ''; while (--i >= 0) { if (s !== '' || i === 0 || data[i] !== 0) { var t = String(data[i]); s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t; } } return s; }; var pow = function (x, n, acc) { return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc); }; var log = function (x) { var n = 0; var x2 = x; while (x2 >= 4096) { n += 12; x2 /= 4096; } while (x2 >= 2) { n += 1; x2 /= 2; } return n; }; $export($export.P + $export.F * (!!$toFixed && ( 0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128' ) || !__webpack_require__(14)(function () { // V8 ~ Android 4.3- $toFixed.call({}); })), 'Number', { toFixed: function toFixed(fractionDigits) { var x = aNumberValue(this, ERROR); var f = toInteger(fractionDigits); var s = ''; var m = ZERO; var e, z, j, k; if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare if (x != x) return 'NaN'; if (x = 1e21) return String(x); if (x < 0) { s = '-'; x = -x; } if (x > 1e-21) { e = log(x * pow(2, 69, 1)) - 69; z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1); z *= 0x10000000000000; e = 52 - e; if (e > 0) { multiply(0, z); j = f; while (j >= 7) { multiply(1e7, 0); j -= 7; } multiply(pow(10, j, 1), 0); j = e - 1; while (j >= 23) { divide(1 < 23); j -= 23; } divide(1 < j); multiply(1, 1); divide(2); m = numToString(); } else { multiply(0, z); multiply(1 < -e, 0); m = numToString() + repeat.call(ZERO, f); } } if (f > 0) { k = m.length; m = s + (k -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x); }; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.5 Math.asinh(x) var $export = __webpack_require__(15); var $asinh = Math.asinh; function asinh(x) { return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1)); } // Tor Browser bug: Math.asinh(0) -> -0 $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh }); /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.7 Math.atanh(x) var $export = __webpack_require__(15); var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0 $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', { atanh: function atanh(x) { return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2; } }); /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.9 Math.cbrt(x) var $export = __webpack_require__(15); var sign = __webpack_require__(115); $export($export.S, 'Math', { cbrt: function cbrt(x) { return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3); } }); /***/ }), /* 115 */ /***/ (function(module, exports) { // 20.2.2.28 Math.sign(x) module.exports = Math.sign || function sign(x) { // eslint-disable-next-line no-self-compare return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1; }; /***/ }), /* 116 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.11 Math.clz32(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { clz32: function clz32(x) { return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32; } }); /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.12 Math.cosh(x) var $export = __webpack_require__(15); var exp = Math.exp; $export($export.S, 'Math', { cosh: function cosh(x) { return (exp(x = +x) + exp(-x)) / 2; } }); /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.14 Math.expm1(x) var $export = __webpack_require__(15); var $expm1 = __webpack_require__(119); $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 }); /***/ }), /* 119 */ /***/ (function(module, exports) { // 20.2.2.14 Math.expm1(x) var $expm1 = Math.expm1; module.exports = (!$expm1 // Old FF bug || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug || $expm1(-2e-17) != -2e-17 ) ? function expm1(x) { return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1; } : $expm1; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { fround: __webpack_require__(121) }); /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.16 Math.fround(x) var sign = __webpack_require__(115); var pow = Math.pow; var EPSILON = pow(2, -52); var EPSILON32 = pow(2, -23); var MAX32 = pow(2, 127) * (2 - EPSILON32); var MIN32 = pow(2, -126); var roundTiesToEven = function (n) { return n + 1 / EPSILON - 1 / EPSILON; }; module.exports = Math.fround || function fround(x) { var $abs = Math.abs(x); var $sign = sign(x); var a, result; if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32; a = (1 + EPSILON32 / EPSILON) * $abs; result = a - (a - $abs); // eslint-disable-next-line no-self-compare if (result > MAX32 || result != result) return $sign * Infinity; return $sign * result; }; /***/ }), /* 122 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.17 Math.hypot([value1[, value2[, … ]]]) var $export = __webpack_require__(15); var abs = Math.abs; $export($export.S, 'Math', { hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars var sum = 0; var i = 0; var aLen = arguments.length; var larg = 0; var arg, div; while (i < aLen) { arg = abs(arguments[i++]); if (larg < arg) { div = larg / arg; sum = sum * div * div + 1; larg = arg; } else if (arg > 0) { div = arg / larg; sum += div * div; } else sum += arg; } return larg === Infinity ? Infinity : larg * Math.sqrt(sum); } }); /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.18 Math.imul(x, y) var $export = __webpack_require__(15); var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity $export($export.S + $export.F * __webpack_require__(14)(function () { return $imul(0xffffffff, 5) != -5 || $imul.length != 2; }), 'Math', { imul: function imul(x, y) { var UINT16 = 0xffff; var xn = +x; var yn = +y; var xl = UINT16 & xn; var yl = UINT16 & yn; return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) < 16 >>> 0); } }); /***/ }), /* 124 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.21 Math.log10(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log10: function log10(x) { return Math.log(x) * Math.LOG10E; } }); /***/ }), /* 125 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.20 Math.log1p(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log1p: __webpack_require__(111) }); /***/ }), /* 126 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.22 Math.log2(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { log2: function log2(x) { return Math.log(x) / Math.LN2; } }); /***/ }), /* 127 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.28 Math.sign(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { sign: __webpack_require__(115) }); /***/ }), /* 128 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.30 Math.sinh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers $export($export.S + $export.F * __webpack_require__(14)(function () { return !Math.sinh(-2e-17) != -2e-17; }), 'Math', { sinh: function sinh(x) { return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2); } }); /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.33 Math.tanh(x) var $export = __webpack_require__(15); var expm1 = __webpack_require__(119); var exp = Math.exp; $export($export.S, 'Math', { tanh: function tanh(x) { var a = expm1(x = +x); var b = expm1(-x); return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x)); } }); /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { // 20.2.2.34 Math.trunc(x) var $export = __webpack_require__(15); $export($export.S, 'Math', { trunc: function trunc(it) { return (it > 0 ? Math.floor : Math.ceil)(it); } }); /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toAbsoluteIndex = __webpack_require__(47); var fromCharCode = String.fromCharCode; var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', { // 21.1.2.2 String.fromCodePoint(...codePoints) fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars var res = []; var aLen = arguments.length; var i = 0; var code; while (aLen > i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point'); res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00) ); } return res.join(''); } }); /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toLength = __webpack_require__(45); $export($export.S, 'String', { // 21.1.2.4 String.raw(callSite, ...substitutions) raw: function raw(callSite) { var tpl = toIObject(callSite.raw); var len = toLength(tpl.length); var aLen = arguments.length; var res = []; var i = 0; while (len > i) { res.push(String(tpl[i++])); if (i < aLen) res.push(String(arguments[i])); } return res.join(''); } }); /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.1.3.25 String.prototype.trim() __webpack_require__(90)('trim', function ($trim) { return function trim() { return $trim(this, 3); }; }); /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $at = __webpack_require__(135)(true); // 21.1.3.27 String.prototype[@@iterator]() __webpack_require__(136)(String, 'String', function (iterated) { this._t = String(iterated); // target this._i = 0; // next index // 21.1.5.2.1 %StringIteratorPrototype%.next() }, function () { var O = this._t; var index = this._i; var point; if (index >= O.length) return { value: undefined, done: true }; point = $at(O, index); this._i += point.length; return { value: point, done: false }; }); /***/ }), /* 135 */ /***/ (function(module, exports, __webpack_require__) { var toInteger = __webpack_require__(46); var defined = __webpack_require__(43); // true -> String#at // false -> String#codePointAt module.exports = function (TO_STRING) { return function (that, pos) { var s = String(defined(that)); var i = toInteger(pos); var l = s.length; var a, b; if (i < 0 || i >= l) return TO_STRING ? '' : undefined; a = s.charCodeAt(i); return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 < 10) + (b - 0xdc00) + 0x10000; }; }; /***/ }), /* 136 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var LIBRARY = __webpack_require__(29); var $export = __webpack_require__(15); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var $iterCreate = __webpack_require__(138); var setToStringTag = __webpack_require__(33); var getPrototypeOf = __webpack_require__(66); var ITERATOR = __webpack_require__(34)('iterator'); var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next` var FF_ITERATOR = '@@iterator'; var KEYS = 'keys'; var VALUES = 'values'; var returnThis = function () { return this; }; module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) { $iterCreate(Constructor, NAME, next); var getMethod = function (kind) { if (!BUGGY && kind in proto) return proto[kind]; switch (kind) { case KEYS: return function keys() { return new Constructor(this, kind); }; case VALUES: return function values() { return new Constructor(this, kind); }; } return function entries() { return new Constructor(this, kind); }; }; var TAG = NAME + ' Iterator'; var DEF_VALUES = DEFAULT == VALUES; var VALUES_BUG = false; var proto = Base.prototype; var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]; var $default = $native || getMethod(DEFAULT); var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined; var $anyNative = NAME == 'Array' ? proto.entries || $native : $native; var methods, key, IteratorPrototype; // Fix native if ($anyNative) { IteratorPrototype = getPrototypeOf($anyNative.call(new Base())); if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) { // Set @@toStringTag to native iterators setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis); } } // fix Array#{values, @@iterator}.name in V8 / FF if (DEF_VALUES && $native && $native.name !== VALUES) { VALUES_BUG = true; $default = function values() { return $native.call(this); }; } // Define iterator if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) { hide(proto, ITERATOR, $default); } // Plug for library Iterators[NAME] = $default; Iterators[TAG] = returnThis; if (DEFAULT) { methods = { values: DEF_VALUES ? $default : getMethod(VALUES), keys: IS_SET ? $default : getMethod(KEYS), entries: $entries }; if (FORCED) for (key in methods) { if (!(key in proto)) redefine(proto, key, methods[key]); } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods); } return methods; }; /***/ }), /* 137 */ /***/ (function(module, exports) { module.exports = {}; /***/ }), /* 138 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var create = __webpack_require__(53); var descriptor = __webpack_require__(24); var setToStringTag = __webpack_require__(33); var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]() __webpack_require__(17)(IteratorPrototype, __webpack_require__(34)('iterator'), function () { return this; }); module.exports = function (Constructor, NAME, next) { Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) }); setToStringTag(Constructor, NAME + ' Iterator'); }; /***/ }), /* 139 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $at = __webpack_require__(135)(false); $export($export.P, 'String', { // 21.1.3.3 String.prototype.codePointAt(pos) codePointAt: function codePointAt(pos) { return $at(this, pos); } }); /***/ }), /* 140 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.6 String.prototype.endsWith(searchString [, endPosition]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var ENDS_WITH = 'endsWith'; var $endsWith = ''[ENDS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(ENDS_WITH), 'String', { endsWith: function endsWith(searchString /* , endPosition = @length */) { var that = context(this, searchString, ENDS_WITH); var endPosition = arguments.length > 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len); var search = String(searchString); return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } }); /***/ }), /* 141 */ /***/ (function(module, exports, __webpack_require__) { // helper for String#{startsWith, endsWith, includes} var isRegExp = __webpack_require__(142); var defined = __webpack_require__(43); module.exports = function (that, searchString, NAME) { if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!"); return String(defined(that)); }; /***/ }), /* 142 */ /***/ (function(module, exports, __webpack_require__) { // 7.2.8 IsRegExp(argument) var isObject = __webpack_require__(20); var cof = __webpack_require__(42); var MATCH = __webpack_require__(34)('match'); module.exports = function (it) { var isRegExp; return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp'); }; /***/ }), /* 143 */ /***/ (function(module, exports, __webpack_require__) { var MATCH = __webpack_require__(34)('match'); module.exports = function (KEY) { var re = /./; try { '/./'[KEY](re); } catch (e) { try { re[MATCH] = false; return !'/./'[KEY](re); } catch (f) { /* empty */ } } return true; }; /***/ }), /* 144 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.7 String.prototype.includes(searchString, position = 0) 'use strict'; var $export = __webpack_require__(15); var context = __webpack_require__(141); var INCLUDES = 'includes'; $export($export.P + $export.F * __webpack_require__(143)(INCLUDES), 'String', { includes: function includes(searchString /* , position = 0 */) { return !!~context(this, searchString, INCLUDES) .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined); } }); /***/ }), /* 145 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.P, 'String', { // 21.1.3.13 String.prototype.repeat(count) repeat: __webpack_require__(98) }); /***/ }), /* 146 */ /***/ (function(module, exports, __webpack_require__) { // 21.1.3.18 String.prototype.startsWith(searchString [, position ]) 'use strict'; var $export = __webpack_require__(15); var toLength = __webpack_require__(45); var context = __webpack_require__(141); var STARTS_WITH = 'startsWith'; var $startsWith = ''[STARTS_WITH]; $export($export.P + $export.F * __webpack_require__(143)(STARTS_WITH), 'String', { startsWith: function startsWith(searchString /* , position = 0 */) { var that = context(this, searchString, STARTS_WITH); var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } }); /***/ }), /* 147 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // B.2.3.2 String.prototype.anchor(name) __webpack_require__(148)('anchor', function (createHTML) { return function anchor(name) { return createHTML(this, 'a', 'name', name); }; }); /***/ }), /* 148 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value) var createHTML = function (string, tag, attribute, value) { var S = String(defined(string)); var p1 = ' Array#map // 2 -> Array#filter // 3 -> Array#some // 4 -> Array#every // 5 -> Array#find // 6 -> Array#findIndex var ctx = __webpack_require__(30); var IObject = __webpack_require__(41); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var asc = __webpack_require__(182); module.exports = function (TYPE, $create) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; var create = $create || asc; return function ($this, callbackfn, that) { var O = toObject($this); var self = IObject(O); var f = ctx(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var val, res; for (;length > index; index++) if (NO_HOLES || index in self) { val = self[index]; res = f(val, index, O); if (TYPE) { if (IS_MAP) result[index] = res; // map else if (res) switch (TYPE) { case 3: return true; // some case 5: return val; // find case 6: return index; // findIndex case 2: result.push(val); // filter } else if (IS_EVERY) return false; // every } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result; }; }; /***/ }), /* 182 */ /***/ (function(module, exports, __webpack_require__) { // 9.4.2.3 ArraySpeciesCreate(originalArray, length) var speciesConstructor = __webpack_require__(183); module.exports = function (original, length) { return new (speciesConstructor(original))(length); }; /***/ }), /* 183 */ /***/ (function(module, exports, __webpack_require__) { var isObject = __webpack_require__(20); var isArray = __webpack_require__(52); var SPECIES = __webpack_require__(34)('species'); module.exports = function (original) { var C; if (isArray(original)) { C = original.constructor; // cross-realm fallback if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined; if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return C === undefined ? Array : C; }; /***/ }), /* 184 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $map = __webpack_require__(181)(1); $export($export.P + $export.F * !__webpack_require__(177)([].map, true), 'Array', { // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg]) map: function map(callbackfn /* , thisArg */) { return $map(this, callbackfn, arguments[1]); } }); /***/ }), /* 185 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $filter = __webpack_require__(181)(2); $export($export.P + $export.F * !__webpack_require__(177)([].filter, true), 'Array', { // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg]) filter: function filter(callbackfn /* , thisArg */) { return $filter(this, callbackfn, arguments[1]); } }); /***/ }), /* 186 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $some = __webpack_require__(181)(3); $export($export.P + $export.F * !__webpack_require__(177)([].some, true), 'Array', { // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg]) some: function some(callbackfn /* , thisArg */) { return $some(this, callbackfn, arguments[1]); } }); /***/ }), /* 187 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $every = __webpack_require__(181)(4); $export($export.P + $export.F * !__webpack_require__(177)([].every, true), 'Array', { // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg]) every: function every(callbackfn /* , thisArg */) { return $every(this, callbackfn, arguments[1]); } }); /***/ }), /* 188 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduce, true), 'Array', { // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue]) reduce: function reduce(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], false); } }); /***/ }), /* 189 */ /***/ (function(module, exports, __webpack_require__) { var aFunction = __webpack_require__(31); var toObject = __webpack_require__(65); var IObject = __webpack_require__(41); var toLength = __webpack_require__(45); module.exports = function (that, callbackfn, aLen, memo, isRight) { aFunction(callbackfn); var O = toObject(that); var self = IObject(O); var length = toLength(O.length); var index = isRight ? length - 1 : 0; var i = isRight ? -1 : 1; if (aLen < 2) for (;;) { if (index in self) { memo = self[index]; index += i; break; } index += i; if (isRight ? index < 0 : length = 0 : length > index; index += i) if (index in self) { memo = callbackfn(memo, self[index], index, O); } return memo; }; /***/ }), /* 190 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $reduce = __webpack_require__(189); $export($export.P + $export.F * !__webpack_require__(177)([].reduceRight, true), 'Array', { // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue]) reduceRight: function reduceRight(callbackfn /* , initialValue */) { return $reduce(this, callbackfn, arguments.length, arguments[1], true); } }); /***/ }), /* 191 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var $indexOf = __webpack_require__(44)(false); var $native = [].indexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex]) indexOf: function indexOf(searchElement /* , fromIndex = 0 */) { return NEGATIVE_ZERO // convert -0 to +0 ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]); } }); /***/ }), /* 192 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var $export = __webpack_require__(15); var toIObject = __webpack_require__(40); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var $native = [].lastIndexOf; var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0; $export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(177)($native)), 'Array', { // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex]) lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) { // convert -0 to +0 if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0; var O = toIObject(this); var length = toLength(O.length); var index = length - 1; if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1])); if (index < 0) index = length + index; for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0; return -1; } }); /***/ }), /* 193 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { copyWithin: __webpack_require__(194) }); __webpack_require__(195)('copyWithin'); /***/ }), /* 194 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) { var O = toObject(this); var len = toLength(O.length); var to = toAbsoluteIndex(target, len); var from = toAbsoluteIndex(start, len); var end = arguments.length > 2 ? arguments[2] : undefined; var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to); var inc = 1; if (from < to && to < from + count) { inc = -1; from += count - 1; to += count - 1; } while (count-- > 0) { if (from in O) O[to] = O[from]; else delete O[to]; to += inc; from += inc; } return O; }; /***/ }), /* 195 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.31 Array.prototype[@@unscopables] var UNSCOPABLES = __webpack_require__(34)('unscopables'); var ArrayProto = Array.prototype; if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(17)(ArrayProto, UNSCOPABLES, {}); module.exports = function (key) { ArrayProto[UNSCOPABLES][key] = true; }; /***/ }), /* 196 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) var $export = __webpack_require__(15); $export($export.P, 'Array', { fill: __webpack_require__(197) }); __webpack_require__(195)('fill'); /***/ }), /* 197 */ /***/ (function(module, exports, __webpack_require__) { // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length) 'use strict'; var toObject = __webpack_require__(65); var toAbsoluteIndex = __webpack_require__(47); var toLength = __webpack_require__(45); module.exports = function fill(value /* , start = 0, end = @length */) { var O = toObject(this); var length = toLength(O.length); var aLen = arguments.length; var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length); var end = aLen > 2 ? arguments[2] : undefined; var endPos = end === undefined ? length : toAbsoluteIndex(end, length); while (endPos > index) O[index++] = value; return O; }; /***/ }), /* 198 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(5); var KEY = 'find'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { find: function find(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 199 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined) var $export = __webpack_require__(15); var $find = __webpack_require__(181)(6); var KEY = 'findIndex'; var forced = true; // Shouldn't skip holes if (KEY in []) Array(1)[KEY](function () { forced = false; }); $export($export.P + $export.F * forced, 'Array', { findIndex: function findIndex(callbackfn /* , that = undefined */) { return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)(KEY); /***/ }), /* 200 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(201)('Array'); /***/ }), /* 201 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var global = __webpack_require__(11); var dP = __webpack_require__(18); var DESCRIPTORS = __webpack_require__(13); var SPECIES = __webpack_require__(34)('species'); module.exports = function (KEY) { var C = global[KEY]; if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, { configurable: true, get: function () { return this; } }); }; /***/ }), /* 202 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var addToUnscopables = __webpack_require__(195); var step = __webpack_require__(203); var Iterators = __webpack_require__(137); var toIObject = __webpack_require__(40); // 22.1.3.4 Array.prototype.entries() // 22.1.3.13 Array.prototype.keys() // 22.1.3.29 Array.prototype.values() // 22.1.3.30 Array.prototype[@@iterator]() module.exports = __webpack_require__(136)(Array, 'Array', function (iterated, kind) { this._t = toIObject(iterated); // target this._i = 0; // next index this._k = kind; // kind // 22.1.5.2.1 %ArrayIteratorPrototype%.next() }, function () { var O = this._t; var kind = this._k; var index = this._i++; if (!O || index >= O.length) { this._t = undefined; return step(1); } if (kind == 'keys') return step(0, index); if (kind == 'values') return step(0, O[index]); return step(0, [index, O[index]]); }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7) Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries'); /***/ }), /* 203 */ /***/ (function(module, exports) { module.exports = function (done, value) { return { value: value, done: !!done }; }; /***/ }), /* 204 */ /***/ (function(module, exports, __webpack_require__) { var global = __webpack_require__(11); var inheritIfRequired = __webpack_require__(95); var dP = __webpack_require__(18).f; var gOPN = __webpack_require__(57).f; var isRegExp = __webpack_require__(142); var $flags = __webpack_require__(205); var $RegExp = global.RegExp; var Base = $RegExp; var proto = $RegExp.prototype; var re1 = /a/g; var re2 = /a/g; // "new" creates a new object, old webkit buggy here var CORRECT_NEW = new $RegExp(re1) !== re1; if (__webpack_require__(13) && (!CORRECT_NEW || __webpack_require__(14)(function () { re2[__webpack_require__(34)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i'; }))) { $RegExp = function RegExp(p, f) { var tiRE = this instanceof $RegExp; var piRE = isRegExp(p); var fiU = f === undefined; return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f) , tiRE ? this : proto, $RegExp); }; var proxy = function (key) { key in $RegExp || dP($RegExp, key, { configurable: true, get: function () { return Base[key]; }, set: function (it) { Base[key] = it; } }); }; for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]); proto.constructor = $RegExp; $RegExp.prototype = proto; __webpack_require__(25)(global, 'RegExp', $RegExp); } __webpack_require__(201)('RegExp'); /***/ }), /* 205 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 21.2.5.3 get RegExp.prototype.flags var anObject = __webpack_require__(19); module.exports = function () { var that = anObject(this); var result = ''; if (that.global) result += 'g'; if (that.ignoreCase) result += 'i'; if (that.multiline) result += 'm'; if (that.unicode) result += 'u'; if (that.sticky) result += 'y'; return result; }; /***/ }), /* 206 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpExec = __webpack_require__(207); __webpack_require__(15)({ target: 'RegExp', proto: true, forced: regexpExec !== /./.exec }, { exec: regexpExec }); /***/ }), /* 207 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var regexpFlags = __webpack_require__(205); var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js, // which loads this file before patching the method. var nativeReplace = String.prototype.replace; var patchedExec = nativeExec; var LAST_INDEX = 'lastIndex'; var UPDATES_LAST_INDEX_WRONG = (function () { var re1 = /a/, re2 = /b*/g; nativeExec.call(re1, 'a'); nativeExec.call(re2, 'a'); return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0; })(); // nonparticipating capturing group, copied from es5-shim's String#split patch. var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined; var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED; if (PATCH) { patchedExec = function exec(str) { var re = this; var lastIndex, reCopy, match, i; if (NPCG_INCLUDED) { reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re)); } if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX]; match = nativeExec.call(re, str); if (UPDATES_LAST_INDEX_WRONG && match) { re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex; } if (NPCG_INCLUDED && match && match.length > 1) { // Fix browsers whose `exec` methods don't consistently return `undefined` // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/ // eslint-disable-next-line no-loop-func nativeReplace.call(match[0], reCopy, function () { for (i = 1; i < arguments.length - 2; i++) { if (arguments[i] === undefined) match[i] = undefined; } }); } return match; }; } module.exports = patchedExec; /***/ }), /* 208 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(209); var anObject = __webpack_require__(19); var $flags = __webpack_require__(205); var DESCRIPTORS = __webpack_require__(13); var TO_STRING = 'toString'; var $toString = /./[TO_STRING]; var define = function (fn) { __webpack_require__(25)(RegExp.prototype, TO_STRING, fn, true); }; // 21.2.5.14 RegExp.prototype.toString() if (__webpack_require__(14)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) { define(function toString() { var R = anObject(this); return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined); }); // FF44- RegExp#toString has a wrong name } else if ($toString.name != TO_STRING) { define(function toString() { return $toString.call(this); }); } /***/ }), /* 209 */ /***/ (function(module, exports, __webpack_require__) { // 21.2.5.3 get RegExp.prototype.flags() if (__webpack_require__(13) && /./g.flags != 'g') __webpack_require__(18).f(RegExp.prototype, 'flags', { configurable: true, get: __webpack_require__(205) }); /***/ }), /* 210 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toLength = __webpack_require__(45); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); // @@match logic __webpack_require__(213)('match', 1, function (defined, MATCH, $match, maybeCallNative) { return [ // `String.prototype.match` method // https://tc39.github.io/ecma262/#sec-string.prototype.match function match(regexp) { var O = defined(this); var fn = regexp == undefined ? undefined : regexp[MATCH]; return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O)); }, // `RegExp.prototype[@@match]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match function (regexp) { var res = maybeCallNative($match, regexp, this); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); if (!rx.global) return regExpExec(rx, S); var fullUnicode = rx.unicode; rx.lastIndex = 0; var A = []; var n = 0; var result; while ((result = regExpExec(rx, S)) !== null) { var matchStr = String(result[0]); A[n] = matchStr; if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); n++; } return n === 0 ? null : A; } ]; }); /***/ }), /* 211 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var at = __webpack_require__(135)(true); // `AdvanceStringIndex` abstract operation // https://tc39.github.io/ecma262/#sec-advancestringindex module.exports = function (S, index, unicode) { return index + (unicode ? at(S, index).length : 1); }; /***/ }), /* 212 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var classof = __webpack_require__(82); var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation // https://tc39.github.io/ecma262/#sec-regexpexec module.exports = function (R, S) { var exec = R.exec; if (typeof exec === 'function') { var result = exec.call(R, S); if (typeof result !== 'object') { throw new TypeError('RegExp exec method returned something other than an Object or null'); } return result; } if (classof(R) !== 'RegExp') { throw new TypeError('RegExp#exec called on incompatible receiver'); } return builtinExec.call(R, S); }; /***/ }), /* 213 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(206); var redefine = __webpack_require__(25); var hide = __webpack_require__(17); var fails = __webpack_require__(14); var defined = __webpack_require__(43); var wks = __webpack_require__(34); var regexpExec = __webpack_require__(207); var SPECIES = wks('species'); var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () { // #replace needs built-in support for named groups. // #match works fine because it just return the exec results, even if it has // a "grops" property. var re = /./; re.exec = function () { var result = []; result.groups = { a: '7' }; return result; }; return ''.replace(re, '$') !== '7'; }); var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () { // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec var re = /(?:)/; var originalExec = re.exec; re.exec = function () { return originalExec.apply(this, arguments); }; var result = 'ab'.split(re); return result.length === 2 && result[0] === 'a' && result[1] === 'b'; })(); module.exports = function (KEY, length, exec) { var SYMBOL = wks(KEY); var DELEGATES_TO_SYMBOL = !fails(function () { // String methods call symbol-named RegEp methods var O = {}; O[SYMBOL] = function () { return 7; }; return ''[KEY](O) != 7; }); var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () { // Symbol-named RegExp methods call .exec var execCalled = false; var re = /a/; re.exec = function () { execCalled = true; return null; }; if (KEY === 'split') { // RegExp[@@split] doesn't call the regex's exec method, but first creates // a new one. We need to return the patched regex when creating the new one. re.constructor = {}; re.constructor[SPECIES] = function () { return re; }; } re[SYMBOL](''); return !execCalled; }) : undefined; if ( !DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) || (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) ) { var nativeRegExpMethod = /./[SYMBOL]; var fns = exec( defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) { if (regexp.exec === regexpExec) { if (DELEGATES_TO_SYMBOL && !forceStringMethod) { // The native String method already delegates to @@method (this // polyfilled function), leasing to infinite recursion. // We avoid it by directly calling the native @@method method. return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) }; } return { done: true, value: nativeMethod.call(str, regexp, arg2) }; } return { done: false }; } ); var strfn = fns[0]; var rxfn = fns[1]; redefine(String.prototype, KEY, strfn); hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue) // 21.2.5.11 RegExp.prototype[@@split](string, limit) ? function (string, arg) { return rxfn.call(string, this, arg); } // 21.2.5.6 RegExp.prototype[@@match](string) // 21.2.5.9 RegExp.prototype[@@search](string) : function (string) { return rxfn.call(string, this); } ); } }; /***/ }), /* 214 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var anObject = __webpack_require__(19); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var advanceStringIndex = __webpack_require__(211); var regExpExec = __webpack_require__(212); var max = Math.max; var min = Math.min; var floor = Math.floor; var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|]*>)/g; var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g; var maybeToString = function (it) { return it === undefined ? it : String(it); }; // @@replace logic __webpack_require__(213)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) { return [ // `String.prototype.replace` method // https://tc39.github.io/ecma262/#sec-string.prototype.replace function replace(searchValue, replaceValue) { var O = defined(this); var fn = searchValue == undefined ? undefined : searchValue[REPLACE]; return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue); }, // `RegExp.prototype[@@replace]` method // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace function (regexp, replaceValue) { var res = maybeCallNative($replace, regexp, this, replaceValue); if (res.done) return res.value; var rx = anObject(regexp); var S = String(this); var functionalReplace = typeof replaceValue === 'function'; if (!functionalReplace) replaceValue = String(replaceValue); var global = rx.global; if (global) { var fullUnicode = rx.unicode; rx.lastIndex = 0; } var results = []; while (true) { var result = regExpExec(rx, S); if (result === null) break; results.push(result); if (!global) break; var matchStr = String(result[0]); if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode); } var accumulatedResult = ''; var nextSourcePosition = 0; for (var i = 0; i < results.length; i++) { result = results[i]; var matched = String(result[0]); var position = max(min(toInteger(result.index), S.length), 0); var captures = []; // NOTE: This is equivalent to // captures = result.slice(1).map(maybeToString) // but for some reason `nativeSlice.call(result, 1, result.length)` (called in // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it. for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j])); var namedCaptures = result.groups; if (functionalReplace) { var replacerArgs = [matched].concat(captures, position, S); if (namedCaptures !== undefined) replacerArgs.push(namedCaptures); var replacement = String(replaceValue.apply(undefined, replacerArgs)); } else { replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue); } if (position >= nextSourcePosition) { accumulatedResult += S.slice(nextSourcePosition, position) + replacement; nextSourcePosition = position + matched.length; } } return accumulatedResult + S.slice(nextSourcePosition); } ]; // https://tc39.github.io/ecma262/#sec-getsubstitution function getSubstitution(matched, str, position, captures, namedCaptures, replacement) { var tailPos = position + matched.length; var m = captures.length; var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED; if (namedCaptures !== undefined) { namedCaptures = toObject(namedCaptures); symbols = SUBSTITUTION_SYMBOLS; } return $replace.call(replacement, symbols, function (match, ch) { var capture; switch (ch.charAt(0)) { case '$': return '$'; case '&': return matched; case '`': return str.slice(0, position); case "'": return str.slice(tailPos); case '>> 0; if (lim === 0) return []; if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : []; var p = 0; var q = 0; var A = []; while (q < S.length) { splitter.lastIndex = SUPPORTS_Y ? q : 0; var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q)); var e; if ( z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p ) { q = advanceStringIndex(S, q, unicodeMatching); } else { A.push(S.slice(p, q)); if (A.length === lim) return A; for (var i = 1; i 0; m = m * 256 + buffer[i], i--, nBits -= 8); if (e === 0) { e = 1 - eBias; } else if (e === eMax) { return m ? NaN : s ? -Infinity : Infinity; } else { m = m + pow(2, mLen); e = e - eBias; } return (s ? -1 : 1) * m * pow(2, e - mLen); } function unpackI32(bytes) { return bytes[3] < 24 | bytes[2] < 16 | bytes[1] < 8 | bytes[0]; } function packI8(it) { return [it & 0xff]; } function packI16(it) { return [it & 0xff, it >> 8 & 0xff]; } function packI32(it) { return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff]; } function packF64(it) { return packIEEE754(it, 52, 8); } function packF32(it) { return packIEEE754(it, 23, 4); } function addGetter(C, key, internal) { dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } }); } function get(view, bytes, index, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = store.slice(start, start + bytes); return isLittleEndian ? pack : pack.reverse(); } function set(view, bytes, index, conversion, value, isLittleEndian) { var numIndex = +index; var intIndex = toIndex(numIndex); if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX); var store = view[$BUFFER]._b; var start = intIndex + view[$OFFSET]; var pack = conversion(+value); for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1]; } if (!$typed.ABV) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer, ARRAY_BUFFER); var byteLength = toIndex(length); this._b = arrayFill.call(new Array(byteLength), 0); this[$LENGTH] = byteLength; }; $DataView = function DataView(buffer, byteOffset, byteLength) { anInstance(this, $DataView, DATA_VIEW); anInstance(buffer, $ArrayBuffer, DATA_VIEW); var bufferLength = buffer[$LENGTH]; var offset = toInteger(byteOffset); if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!'); byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength); if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH); this[$BUFFER] = buffer; this[$OFFSET] = offset; this[$LENGTH] = byteLength; }; if (DESCRIPTORS) { addGetter($ArrayBuffer, BYTE_LENGTH, '_l'); addGetter($DataView, BUFFER, '_b'); addGetter($DataView, BYTE_LENGTH, '_l'); addGetter($DataView, BYTE_OFFSET, '_o'); } redefineAll($DataView[PROTOTYPE], { getInt8: function getInt8(byteOffset) { return get(this, 1, byteOffset)[0] < 24 >> 24; }, getUint8: function getUint8(byteOffset) { return get(this, 1, byteOffset)[0]; }, getInt16: function getInt16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return (bytes[1] < 8 | bytes[0]) < 16 >> 16; }, getUint16: function getUint16(byteOffset /* , littleEndian */) { var bytes = get(this, 2, byteOffset, arguments[1]); return bytes[1] < 8 | bytes[0]; }, getInt32: function getInt32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])); }, getUint32: function getUint32(byteOffset /* , littleEndian */) { return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0; }, getFloat32: function getFloat32(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4); }, getFloat64: function getFloat64(byteOffset /* , littleEndian */) { return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8); }, setInt8: function setInt8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setUint8: function setUint8(byteOffset, value) { set(this, 1, byteOffset, packI8, value); }, setInt16: function setInt16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setUint16: function setUint16(byteOffset, value /* , littleEndian */) { set(this, 2, byteOffset, packI16, value, arguments[2]); }, setInt32: function setInt32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setUint32: function setUint32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packI32, value, arguments[2]); }, setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) { set(this, 4, byteOffset, packF32, value, arguments[2]); }, setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) { set(this, 8, byteOffset, packF64, value, arguments[2]); } }); } else { if (!fails(function () { $ArrayBuffer(1); }) || !fails(function () { new $ArrayBuffer(-1); // eslint-disable-line no-new }) || fails(function () { new $ArrayBuffer(); // eslint-disable-line no-new new $ArrayBuffer(1.5); // eslint-disable-line no-new new $ArrayBuffer(NaN); // eslint-disable-line no-new return $ArrayBuffer.name != ARRAY_BUFFER; })) { $ArrayBuffer = function ArrayBuffer(length) { anInstance(this, $ArrayBuffer); return new BaseBuffer(toIndex(length)); }; var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE]; for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) { if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]); } if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer; } // iOS Safari 7.x bug var view = new $DataView(new $ArrayBuffer(2)); var $setInt8 = $DataView[PROTOTYPE].setInt8; view.setInt8(0, 2147483648); view.setInt8(1, 2147483649); if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], { setInt8: function setInt8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); }, setUint8: function setUint8(byteOffset, value) { $setInt8.call(this, byteOffset, value < 24 >> 24); } }, true); } setToStringTag($ArrayBuffer, ARRAY_BUFFER); setToStringTag($DataView, DATA_VIEW); hide($DataView[PROTOTYPE], $typed.VIEW, true); exports[ARRAY_BUFFER] = $ArrayBuffer; exports[DATA_VIEW] = $DataView; /***/ }), /* 239 */ /***/ (function(module, exports, __webpack_require__) { // https://tc39.github.io/ecma262/#sec-toindex var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); module.exports = function (it) { if (it === undefined) return 0; var number = toInteger(it); var length = toLength(number); if (number !== length) throw RangeError('Wrong length!'); return length; }; /***/ }), /* 240 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); $export($export.G + $export.W + $export.F * !__webpack_require__(237).ABV, { DataView: __webpack_require__(238).DataView }); /***/ }), /* 241 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int8', 1, function (init) { return function Int8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 242 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; if (__webpack_require__(13)) { var LIBRARY = __webpack_require__(29); var global = __webpack_require__(11); var fails = __webpack_require__(14); var $export = __webpack_require__(15); var $typed = __webpack_require__(237); var $buffer = __webpack_require__(238); var ctx = __webpack_require__(30); var anInstance = __webpack_require__(219); var propertyDesc = __webpack_require__(24); var hide = __webpack_require__(17); var redefineAll = __webpack_require__(227); var toInteger = __webpack_require__(46); var toLength = __webpack_require__(45); var toIndex = __webpack_require__(239); var toAbsoluteIndex = __webpack_require__(47); var toPrimitive = __webpack_require__(23); var has = __webpack_require__(12); var classof = __webpack_require__(82); var isObject = __webpack_require__(20); var toObject = __webpack_require__(65); var isArrayIter = __webpack_require__(171); var create = __webpack_require__(53); var getPrototypeOf = __webpack_require__(66); var gOPN = __webpack_require__(57).f; var getIterFn = __webpack_require__(173); var uid = __webpack_require__(26); var wks = __webpack_require__(34); var createArrayMethod = __webpack_require__(181); var createArrayIncludes = __webpack_require__(44); var speciesConstructor = __webpack_require__(217); var ArrayIterators = __webpack_require__(202); var Iterators = __webpack_require__(137); var $iterDetect = __webpack_require__(174); var setSpecies = __webpack_require__(201); var arrayFill = __webpack_require__(197); var arrayCopyWithin = __webpack_require__(194); var $DP = __webpack_require__(18); var $GOPD = __webpack_require__(58); var dP = $DP.f; var gOPD = $GOPD.f; var RangeError = global.RangeError; var TypeError = global.TypeError; var Uint8Array = global.Uint8Array; var ARRAY_BUFFER = 'ArrayBuffer'; var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER; var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT'; var PROTOTYPE = 'prototype'; var ArrayProto = Array[PROTOTYPE]; var $ArrayBuffer = $buffer.ArrayBuffer; var $DataView = $buffer.DataView; var arrayForEach = createArrayMethod(0); var arrayFilter = createArrayMethod(2); var arraySome = createArrayMethod(3); var arrayEvery = createArrayMethod(4); var arrayFind = createArrayMethod(5); var arrayFindIndex = createArrayMethod(6); var arrayIncludes = createArrayIncludes(true); var arrayIndexOf = createArrayIncludes(false); var arrayValues = ArrayIterators.values; var arrayKeys = ArrayIterators.keys; var arrayEntries = ArrayIterators.entries; var arrayLastIndexOf = ArrayProto.lastIndexOf; var arrayReduce = ArrayProto.reduce; var arrayReduceRight = ArrayProto.reduceRight; var arrayJoin = ArrayProto.join; var arraySort = ArrayProto.sort; var arraySlice = ArrayProto.slice; var arrayToString = ArrayProto.toString; var arrayToLocaleString = ArrayProto.toLocaleString; var ITERATOR = wks('iterator'); var TAG = wks('toStringTag'); var TYPED_CONSTRUCTOR = uid('typed_constructor'); var DEF_CONSTRUCTOR = uid('def_constructor'); var ALL_CONSTRUCTORS = $typed.CONSTR; var TYPED_ARRAY = $typed.TYPED; var VIEW = $typed.VIEW; var WRONG_LENGTH = 'Wrong length!'; var $map = createArrayMethod(1, function (O, length) { return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length); }); var LITTLE_ENDIAN = fails(function () { // eslint-disable-next-line no-undef return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1; }); var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () { new Uint8Array(1).set({}); }); var toOffset = function (it, BYTES) { var offset = toInteger(it); if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!'); return offset; }; var validate = function (it) { if (isObject(it) && TYPED_ARRAY in it) return it; throw TypeError(it + ' is not a typed array!'); }; var allocate = function (C, length) { if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) { throw TypeError('It is not a typed array constructor!'); } return new C(length); }; var speciesFromList = function (O, list) { return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list); }; var fromList = function (C, list) { var index = 0; var length = list.length; var result = allocate(C, length); while (length > index) result[index] = list[index++]; return result; }; var addGetter = function (it, key, internal) { dP(it, key, { get: function () { return this._d[internal]; } }); }; var $from = function from(source /* , mapfn, thisArg */) { var O = toObject(source); var aLen = arguments.length; var mapfn = aLen > 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iterFn = getIterFn(O); var i, length, values, result, step, iterator; if (iterFn != undefined && !isArrayIter(iterFn)) { for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) { values.push(step.value); } O = values; } if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2); for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) { result[i] = mapping ? mapfn(O[i], i) : O[i]; } return result; }; var $of = function of(/* ...items */) { var index = 0; var length = arguments.length; var result = allocate(this, length); while (length > index) result[index] = arguments[index++]; return result; }; // iOS Safari 6.x fails here var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); }); var $toLocaleString = function toLocaleString() { return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments); }; var proto = { copyWithin: function copyWithin(target, start /* , end */) { return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined); }, every: function every(callbackfn /* , thisArg */) { return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars return arrayFill.apply(validate(this), arguments); }, filter: function filter(callbackfn /* , thisArg */) { return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined)); }, find: function find(predicate /* , thisArg */) { return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, findIndex: function findIndex(predicate /* , thisArg */) { return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined); }, forEach: function forEach(callbackfn /* , thisArg */) { arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, indexOf: function indexOf(searchElement /* , fromIndex */) { return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, includes: function includes(searchElement /* , fromIndex */) { return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined); }, join: function join(separator) { // eslint-disable-line no-unused-vars return arrayJoin.apply(validate(this), arguments); }, lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars return arrayLastIndexOf.apply(validate(this), arguments); }, map: function map(mapfn /* , thisArg */) { return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined); }, reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduce.apply(validate(this), arguments); }, reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars return arrayReduceRight.apply(validate(this), arguments); }, reverse: function reverse() { var that = this; var length = validate(that).length; var middle = Math.floor(length / 2); var index = 0; var value; while (index < middle) { value = that[index]; that[index++] = that[--length]; that[length] = value; } return that; }, some: function some(callbackfn /* , thisArg */) { return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined); }, sort: function sort(comparefn) { return arraySort.call(validate(this), comparefn); }, subarray: function subarray(begin, end) { var O = validate(this); var length = O.length; var $begin = toAbsoluteIndex(begin, length); return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))( O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin) ); } }; var $slice = function slice(start, end) { return speciesFromList(this, arraySlice.call(validate(this), start, end)); }; var $set = function set(arrayLike /* , offset */) { validate(this); var offset = toOffset(arguments[1], 1); var length = this.length; var src = toObject(arrayLike); var len = toLength(src.length); var index = 0; if (len + offset > length) throw RangeError(WRONG_LENGTH); while (index < len) this[offset + index] = src[index++]; }; var $iterators = { entries: function entries() { return arrayEntries.call(validate(this)); }, keys: function keys() { return arrayKeys.call(validate(this)); }, values: function values() { return arrayValues.call(validate(this)); } }; var isTAIndex = function (target, key) { return isObject(target) && target[TYPED_ARRAY] && typeof key != 'symbol' && key in target && String(+key) == String(key); }; var $getDesc = function getOwnPropertyDescriptor(target, key) { return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key); }; var $setDesc = function defineProperty(target, key, desc) { if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable) ) { target[key] = desc.value; return target; } return dP(target, key, desc); }; if (!ALL_CONSTRUCTORS) { $GOPD.f = $getDesc; $DP.f = $setDesc; } $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', { getOwnPropertyDescriptor: $getDesc, defineProperty: $setDesc }); if (fails(function () { arrayToString.call({}); })) { arrayToString = arrayToLocaleString = function toString() { return arrayJoin.call(this); }; } var $TypedArrayPrototype$ = redefineAll({}, proto); redefineAll($TypedArrayPrototype$, $iterators); hide($TypedArrayPrototype$, ITERATOR, $iterators.values); redefineAll($TypedArrayPrototype$, { slice: $slice, set: $set, constructor: function () { /* noop */ }, toString: arrayToString, toLocaleString: $toLocaleString }); addGetter($TypedArrayPrototype$, 'buffer', 'b'); addGetter($TypedArrayPrototype$, 'byteOffset', 'o'); addGetter($TypedArrayPrototype$, 'byteLength', 'l'); addGetter($TypedArrayPrototype$, 'length', 'e'); dP($TypedArrayPrototype$, TAG, { get: function () { return this[TYPED_ARRAY]; } }); // eslint-disable-next-line max-statements module.exports = function (KEY, BYTES, wrapper, CLAMPED) { CLAMPED = !!CLAMPED; var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'; var GETTER = 'get' + KEY; var SETTER = 'set' + KEY; var TypedArray = global[NAME]; var Base = TypedArray || {}; var TAC = TypedArray && getPrototypeOf(TypedArray); var FORCED = !TypedArray || !$typed.ABV; var O = {}; var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE]; var getter = function (that, index) { var data = that._d; return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN); }; var setter = function (that, index, value) { var data = that._d; if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff; data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN); }; var addElement = function (that, index) { dP(that, index, { get: function () { return getter(this, index); }, set: function (value) { return setter(this, index, value); }, enumerable: true }); }; if (FORCED) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME, '_d'); var index = 0; var offset = 0; var buffer, byteLength, length, klass; if (!isObject(data)) { length = toIndex(data); byteLength = length * BYTES; buffer = new $ArrayBuffer(byteLength); } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { buffer = data; offset = toOffset($offset, BYTES); var $len = data.byteLength; if ($length === undefined) { if ($len % BYTES) throw RangeError(WRONG_LENGTH); byteLength = $len - offset; if (byteLength < 0) throw RangeError(WRONG_LENGTH); } else { byteLength = toLength($length) * BYTES; if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH); } length = byteLength / BYTES; } else if (TYPED_ARRAY in data) { return fromList(TypedArray, data); } else { return $from.call(TypedArray, data); } hide(that, '_d', { b: buffer, o: offset, l: byteLength, e: length, v: new $DataView(buffer) }); while (index < length) addElement(that, index++); }); TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$); hide(TypedArrayPrototype, 'constructor', TypedArray); } else if (!fails(function () { TypedArray(1); }) || !fails(function () { new TypedArray(-1); // eslint-disable-line no-new }) || !$iterDetect(function (iter) { new TypedArray(); // eslint-disable-line no-new new TypedArray(null); // eslint-disable-line no-new new TypedArray(1.5); // eslint-disable-line no-new new TypedArray(iter); // eslint-disable-line no-new }, true)) { TypedArray = wrapper(function (that, data, $offset, $length) { anInstance(that, TypedArray, NAME); var klass; // `ws` module bug, temporarily remove validation length for Uint8Array // https://github.com/websockets/ws/pull/645 if (!isObject(data)) return new Base(toIndex(data)); if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) { return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data); } if (TYPED_ARRAY in data) return fromList(TypedArray, data); return $from.call(TypedArray, data); }); arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) { if (!(key in TypedArray)) hide(TypedArray, key, Base[key]); }); TypedArray[PROTOTYPE] = TypedArrayPrototype; if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray; } var $nativeIterator = TypedArrayPrototype[ITERATOR]; var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined); var $iterator = $iterators.values; hide(TypedArray, TYPED_CONSTRUCTOR, true); hide(TypedArrayPrototype, TYPED_ARRAY, NAME); hide(TypedArrayPrototype, VIEW, true); hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray); if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) { dP(TypedArrayPrototype, TAG, { get: function () { return NAME; } }); } O[NAME] = TypedArray; $export($export.G + $export.W + $export.F * (TypedArray != Base), O); $export($export.S, NAME, { BYTES_PER_ELEMENT: BYTES }); $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, { from: $from, of: $of }); if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES); $export($export.P, NAME, proto); setSpecies(NAME); $export($export.P + $export.F * FORCED_SET, NAME, { set: $set }); $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators); if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString; $export($export.P + $export.F * fails(function () { new TypedArray(1).slice(); }), NAME, { slice: $slice }); $export($export.P + $export.F * (fails(function () { return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString(); }) || !fails(function () { TypedArrayPrototype.toLocaleString.call([1, 2]); })), NAME, { toLocaleString: $toLocaleString }); Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator; if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator); }; } else module.exports = function () { /* empty */ }; /***/ }), /* 243 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 244 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint8', 1, function (init) { return function Uint8ClampedArray(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }, true); /***/ }), /* 245 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int16', 2, function (init) { return function Int16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 246 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint16', 2, function (init) { return function Uint16Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 247 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Int32', 4, function (init) { return function Int32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 248 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Uint32', 4, function (init) { return function Uint32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 249 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float32', 4, function (init) { return function Float32Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 250 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(242)('Float64', 8, function (init) { return function Float64Array(data, byteOffset, length) { return init(this, data, byteOffset, length); }; }); /***/ }), /* 251 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.1 Reflect.apply(target, thisArgument, argumentsList) var $export = __webpack_require__(15); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var rApply = (__webpack_require__(11).Reflect || {}).apply; var fApply = Function.apply; // MS Edge argumentsList argument is optional $export($export.S + $export.F * !__webpack_require__(14)(function () { rApply(function () { /* empty */ }); }), 'Reflect', { apply: function apply(target, thisArgument, argumentsList) { var T = aFunction(target); var L = anObject(argumentsList); return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L); } }); /***/ }), /* 252 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.2 Reflect.construct(target, argumentsList [, newTarget]) var $export = __webpack_require__(15); var create = __webpack_require__(53); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); var fails = __webpack_require__(14); var bind = __webpack_require__(84); var rConstruct = (__webpack_require__(11).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional // FF Nightly sets third argument as `new.target`, but does not create `this` from it var NEW_TARGET_BUG = fails(function () { function F() { /* empty */ } return !(rConstruct(function () { /* empty */ }, [], F) instanceof F); }); var ARGS_BUG = !fails(function () { rConstruct(function () { /* empty */ }); }); $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', { construct: function construct(Target, args /* , newTarget */) { aFunction(Target); anObject(args); var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]); if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget); if (Target == newTarget) { // w/o altered newTarget, optimization for 0-4 arguments switch (args.length) { case 0: return new Target(); case 1: return new Target(args[0]); case 2: return new Target(args[0], args[1]); case 3: return new Target(args[0], args[1], args[2]); case 4: return new Target(args[0], args[1], args[2], args[3]); } // w/o altered newTarget, lot of arguments case var $args = [null]; $args.push.apply($args, args); return new (bind.apply(Target, $args))(); } // with altered newTarget, not support built-in constructors var proto = newTarget.prototype; var instance = create(isObject(proto) ? proto : Object.prototype); var result = Function.apply.call(Target, instance, args); return isObject(result) ? result : instance; } }); /***/ }), /* 253 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes) var dP = __webpack_require__(18); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var toPrimitive = __webpack_require__(23); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false $export($export.S + $export.F * __webpack_require__(14)(function () { // eslint-disable-next-line no-undef Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 }); }), 'Reflect', { defineProperty: function defineProperty(target, propertyKey, attributes) { anObject(target); propertyKey = toPrimitive(propertyKey, true); anObject(attributes); try { dP.f(target, propertyKey, attributes); return true; } catch (e) { return false; } } }); /***/ }), /* 254 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.4 Reflect.deleteProperty(target, propertyKey) var $export = __webpack_require__(15); var gOPD = __webpack_require__(58).f; var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { deleteProperty: function deleteProperty(target, propertyKey) { var desc = gOPD(anObject(target), propertyKey); return desc && !desc.configurable ? false : delete target[propertyKey]; } }); /***/ }), /* 255 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // 26.1.5 Reflect.enumerate(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var Enumerate = function (iterated) { this._t = anObject(iterated); // target this._i = 0; // next index var keys = this._k = []; // keys var key; for (key in iterated) keys.push(key); }; __webpack_require__(138)(Enumerate, 'Object', function () { var that = this; var keys = that._k; var key; do { if (that._i >= keys.length) return { value: undefined, done: true }; } while (!((key = keys[that._i++]) in that._t)); return { value: key, done: false }; }); $export($export.S, 'Reflect', { enumerate: function enumerate(target) { return new Enumerate(target); } }); /***/ }), /* 256 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.6 Reflect.get(target, propertyKey [, receiver]) var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var isObject = __webpack_require__(20); var anObject = __webpack_require__(19); function get(target, propertyKey /* , receiver */) { var receiver = arguments.length < 3 ? target : arguments[2]; var desc, proto; if (anObject(target) === receiver) return target[propertyKey]; if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined; if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver); } $export($export.S, 'Reflect', { get: get }); /***/ }), /* 257 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey) var gOPD = __webpack_require__(58); var $export = __webpack_require__(15); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) { return gOPD.f(anObject(target), propertyKey); } }); /***/ }), /* 258 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.8 Reflect.getPrototypeOf(target) var $export = __webpack_require__(15); var getProto = __webpack_require__(66); var anObject = __webpack_require__(19); $export($export.S, 'Reflect', { getPrototypeOf: function getPrototypeOf(target) { return getProto(anObject(target)); } }); /***/ }), /* 259 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.9 Reflect.has(target, propertyKey) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { has: function has(target, propertyKey) { return propertyKey in target; } }); /***/ }), /* 260 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.10 Reflect.isExtensible(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $isExtensible = Object.isExtensible; $export($export.S, 'Reflect', { isExtensible: function isExtensible(target) { anObject(target); return $isExtensible ? $isExtensible(target) : true; } }); /***/ }), /* 261 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.11 Reflect.ownKeys(target) var $export = __webpack_require__(15); $export($export.S, 'Reflect', { ownKeys: __webpack_require__(262) }); /***/ }), /* 262 */ /***/ (function(module, exports, __webpack_require__) { // all object keys, includes non-enumerable and symbols var gOPN = __webpack_require__(57); var gOPS = __webpack_require__(50); var anObject = __webpack_require__(19); var Reflect = __webpack_require__(11).Reflect; module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) { var keys = gOPN.f(anObject(it)); var getSymbols = gOPS.f; return getSymbols ? keys.concat(getSymbols(it)) : keys; }; /***/ }), /* 263 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.12 Reflect.preventExtensions(target) var $export = __webpack_require__(15); var anObject = __webpack_require__(19); var $preventExtensions = Object.preventExtensions; $export($export.S, 'Reflect', { preventExtensions: function preventExtensions(target) { anObject(target); try { if ($preventExtensions) $preventExtensions(target); return true; } catch (e) { return false; } } }); /***/ }), /* 264 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.13 Reflect.set(target, propertyKey, V [, receiver]) var dP = __webpack_require__(18); var gOPD = __webpack_require__(58); var getPrototypeOf = __webpack_require__(66); var has = __webpack_require__(12); var $export = __webpack_require__(15); var createDesc = __webpack_require__(24); var anObject = __webpack_require__(19); var isObject = __webpack_require__(20); function set(target, propertyKey, V /* , receiver */) { var receiver = arguments.length < 4 ? target : arguments[3]; var ownDesc = gOPD.f(anObject(target), propertyKey); var existingDescriptor, proto; if (!ownDesc) { if (isObject(proto = getPrototypeOf(target))) { return set(proto, propertyKey, V, receiver); } ownDesc = createDesc(0); } if (has(ownDesc, 'value')) { if (ownDesc.writable === false || !isObject(receiver)) return false; if (existingDescriptor = gOPD.f(receiver, propertyKey)) { if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false; existingDescriptor.value = V; dP.f(receiver, propertyKey, existingDescriptor); } else dP.f(receiver, propertyKey, createDesc(0, V)); return true; } return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true); } $export($export.S, 'Reflect', { set: set }); /***/ }), /* 265 */ /***/ (function(module, exports, __webpack_require__) { // 26.1.14 Reflect.setPrototypeOf(target, proto) var $export = __webpack_require__(15); var setProto = __webpack_require__(80); if (setProto) $export($export.S, 'Reflect', { setPrototypeOf: function setPrototypeOf(target, proto) { setProto.check(target, proto); try { setProto.set(target, proto); return true; } catch (e) { return false; } } }); /***/ }), /* 266 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/Array.prototype.includes var $export = __webpack_require__(15); var $includes = __webpack_require__(44)(true); $export($export.P, 'Array', { includes: function includes(el /* , fromIndex = 0 */) { return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined); } }); __webpack_require__(195)('includes'); /***/ }), /* 267 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var aFunction = __webpack_require__(31); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatMap: function flatMap(callbackfn /* , thisArg */) { var O = toObject(this); var sourceLen, A; aFunction(callbackfn); sourceLen = toLength(O.length); A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]); return A; } }); __webpack_require__(195)('flatMap'); /***/ }), /* 268 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray var isArray = __webpack_require__(52); var isObject = __webpack_require__(20); var toLength = __webpack_require__(45); var ctx = __webpack_require__(30); var IS_CONCAT_SPREADABLE = __webpack_require__(34)('isConcatSpreadable'); function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) { var targetIndex = start; var sourceIndex = 0; var mapFn = mapper ? ctx(mapper, thisArg, 3) : false; var element, spreadable; while (sourceIndex < sourceLen) { if (sourceIndex in source) { element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex]; spreadable = false; if (isObject(element)) { spreadable = element[IS_CONCAT_SPREADABLE]; spreadable = spreadable !== undefined ? !!spreadable : isArray(element); } if (spreadable && depth > 0) { targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1; } else { if (targetIndex >= 0x1fffffffffffff) throw TypeError(); target[targetIndex] = element; } targetIndex++; } sourceIndex++; } return targetIndex; } module.exports = flattenIntoArray; /***/ }), /* 269 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten var $export = __webpack_require__(15); var flattenIntoArray = __webpack_require__(268); var toObject = __webpack_require__(65); var toLength = __webpack_require__(45); var toInteger = __webpack_require__(46); var arraySpeciesCreate = __webpack_require__(182); $export($export.P, 'Array', { flatten: function flatten(/* depthArg = 1 */) { var depthArg = arguments[0]; var O = toObject(this); var sourceLen = toLength(O.length); var A = arraySpeciesCreate(O, 0); flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg)); return A; } }); __webpack_require__(195)('flatten'); /***/ }), /* 270 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/mathiasbynens/String.prototype.at var $export = __webpack_require__(15); var $at = __webpack_require__(135)(true); $export($export.P, 'String', { at: function at(pos) { return $at(this, pos); } }); /***/ }), /* 271 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-string-pad-start-end var $export = __webpack_require__(15); var $pad = __webpack_require__(272); var userAgent = __webpack_require__(225); // https://github.com/zloirock/core-js/issues/280 var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent); $export($export.P + $export.F * WEBKIT_BUG, 'String', { padStart: function padStart(maxLength /* , fillString = ' ' */) { return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true); } }); /***/ }), /* 272 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-string-pad-start-end var toLength = __webpack_require__(45); var repeat = __webpack_require__(98); var defined = __webpack_require__(43); module.exports = function (that, maxLength, fillString, left) { var S = String(defined(that)); var stringLength = S.length; var fillStr = fillString === undefined ? ' ' : String(fillString); var intMaxLength = toLength(maxLength); if (intMaxLength 0; var $y0 = y0 >>> 0; return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0; } }); /***/ }), /* 311 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { isubh: function isubh(x0, x1, y0, y1) { var $x0 = x0 >>> 0; var $x1 = x1 >>> 0; var $y0 = y0 >>> 0; return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0; } }); /***/ }), /* 312 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { imulh: function imulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >> 16; var v1 = $v >> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16); } }); /***/ }), /* 313 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI }); /***/ }), /* 314 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); var DEG_PER_RAD = Math.PI / 180; $export($export.S, 'Math', { radians: function radians(degrees) { return degrees * DEG_PER_RAD; } }); /***/ }), /* 315 */ /***/ (function(module, exports, __webpack_require__) { // https://rwaldron.github.io/proposal-math-extensions/ var $export = __webpack_require__(15); $export($export.S, 'Math', { scale: __webpack_require__(309) }); /***/ }), /* 316 */ /***/ (function(module, exports, __webpack_require__) { // https://gist.github.com/BrendanEich/4294d5c212a6d2254703 var $export = __webpack_require__(15); $export($export.S, 'Math', { umulh: function umulh(u, v) { var UINT16 = 0xffff; var $u = +u; var $v = +v; var u0 = $u & UINT16; var v0 = $v & UINT16; var u1 = $u >>> 16; var v1 = $v >>> 16; var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16); return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16); } }); /***/ }), /* 317 */ /***/ (function(module, exports, __webpack_require__) { // http://jfbastien.github.io/papers/Math.signbit.html var $export = __webpack_require__(15); $export($export.S, 'Math', { signbit: function signbit(x) { // eslint-disable-next-line no-self-compare return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0; } }); /***/ }), /* 318 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/tc39/proposal-promise-finally 'use strict'; var $export = __webpack_require__(15); var core = __webpack_require__(16); var global = __webpack_require__(11); var speciesConstructor = __webpack_require__(217); var promiseResolve = __webpack_require__(226); $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) { var C = speciesConstructor(this, core.Promise || global.Promise); var isFunction = typeof onFinally == 'function'; return this.then( isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally ); } }); /***/ }), /* 319 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/tc39/proposal-promise-try var $export = __webpack_require__(15); var newPromiseCapability = __webpack_require__(223); var perform = __webpack_require__(224); $export($export.S, 'Promise', { 'try': function (callbackfn) { var promiseCapability = newPromiseCapability.f(this); var result = perform(callbackfn); (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v); return promiseCapability.promise; } }); /***/ }), /* 320 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var ordinaryDefineOwnMetadata = metadata.set; metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) { ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey)); } }); /***/ }), /* 321 */ /***/ (function(module, exports, __webpack_require__) { var Map = __webpack_require__(228); var $export = __webpack_require__(15); var shared = __webpack_require__(28)('metadata'); var store = shared.store || (shared.store = new (__webpack_require__(233))()); var getOrCreateMetadataMap = function (target, targetKey, create) { var targetMetadata = store.get(target); if (!targetMetadata) { if (!create) return undefined; store.set(target, targetMetadata = new Map()); } var keyMetadata = targetMetadata.get(targetKey); if (!keyMetadata) { if (!create) return undefined; targetMetadata.set(targetKey, keyMetadata = new Map()); } return keyMetadata; }; var ordinaryHasOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? false : metadataMap.has(MetadataKey); }; var ordinaryGetOwnMetadata = function (MetadataKey, O, P) { var metadataMap = getOrCreateMetadataMap(O, P, false); return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey); }; var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) { getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue); }; var ordinaryOwnMetadataKeys = function (target, targetKey) { var metadataMap = getOrCreateMetadataMap(target, targetKey, false); var keys = []; if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); }); return keys; }; var toMetaKey = function (it) { return it === undefined || typeof it == 'symbol' ? it : String(it); }; var exp = function (O) { $export($export.S, 'Reflect', O); }; module.exports = { store: store, map: getOrCreateMetadataMap, has: ordinaryHasOwnMetadata, get: ordinaryGetOwnMetadata, set: ordinaryDefineOwnMetadata, keys: ordinaryOwnMetadataKeys, key: toMetaKey, exp: exp }; /***/ }), /* 322 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var toMetaKey = metadata.key; var getOrCreateMetadataMap = metadata.map; var store = metadata.store; metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) { var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]); var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false); if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false; if (metadataMap.size) return true; var targetMetadata = store.get(target); targetMetadata['delete'](targetKey); return !!targetMetadata.size || store['delete'](target); } }); /***/ }), /* 323 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; var ordinaryGetMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P); var parent = getPrototypeOf(O); return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined; }; metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 324 */ /***/ (function(module, exports, __webpack_require__) { var Set = __webpack_require__(232); var from = __webpack_require__(290); var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; var ordinaryMetadataKeys = function (O, P) { var oKeys = ordinaryOwnMetadataKeys(O, P); var parent = getPrototypeOf(O); if (parent === null) return oKeys; var pKeys = ordinaryMetadataKeys(parent, P); return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys; }; metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) { return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 325 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryGetOwnMetadata = metadata.get; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryGetOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 326 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryOwnMetadataKeys = metadata.keys; var toMetaKey = metadata.key; metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) { return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1])); } }); /***/ }), /* 327 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var getPrototypeOf = __webpack_require__(66); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; var ordinaryHasMetadata = function (MetadataKey, O, P) { var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P); if (hasOwn) return true; var parent = getPrototypeOf(O); return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false; }; metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 328 */ /***/ (function(module, exports, __webpack_require__) { var metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var ordinaryHasOwnMetadata = metadata.has; var toMetaKey = metadata.key; metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) { return ordinaryHasOwnMetadata(metadataKey, anObject(target) , arguments.length < 3 ? undefined : toMetaKey(arguments[2])); } }); /***/ }), /* 329 */ /***/ (function(module, exports, __webpack_require__) { var $metadata = __webpack_require__(321); var anObject = __webpack_require__(19); var aFunction = __webpack_require__(31); var toMetaKey = $metadata.key; var ordinaryDefineOwnMetadata = $metadata.set; $metadata.exp({ metadata: function metadata(metadataKey, metadataValue) { return function decorator(target, targetKey) { ordinaryDefineOwnMetadata( metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey) ); }; } }); /***/ }), /* 330 */ /***/ (function(module, exports, __webpack_require__) { // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask var $export = __webpack_require__(15); var microtask = __webpack_require__(222)(); var process = __webpack_require__(11).process; var isNode = __webpack_require__(42)(process) == 'process'; $export($export.G, { asap: function asap(fn) { var domain = isNode && process.domain; microtask(domain ? domain.bind(fn) : fn); } }); /***/ }), /* 331 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // https://github.com/zenparsing/es-observable var $export = __webpack_require__(15); var global = __webpack_require__(11); var core = __webpack_require__(16); var microtask = __webpack_require__(222)(); var OBSERVABLE = __webpack_require__(34)('observable'); var aFunction = __webpack_require__(31); var anObject = __webpack_require__(19); var anInstance = __webpack_require__(219); var redefineAll = __webpack_require__(227); var hide = __webpack_require__(17); var forOf = __webpack_require__(220); var RETURN = forOf.RETURN; var getMethod = function (fn) { return fn == null ? undefined : aFunction(fn); }; var cleanupSubscription = function (subscription) { var cleanup = subscription._c; if (cleanup) { subscription._c = undefined; cleanup(); } }; var subscriptionClosed = function (subscription) { return subscription._o === undefined; }; var closeSubscription = function (subscription) { if (!subscriptionClosed(subscription)) { subscription._o = undefined; cleanupSubscription(subscription); } }; var Subscription = function (observer, subscriber) { anObject(observer); this._c = undefined; this._o = observer; observer = new SubscriptionObserver(this); try { var cleanup = subscriber(observer); var subscription = cleanup; if (cleanup != null) { if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); }; else aFunction(cleanup); this._c = cleanup; } } catch (e) { observer.error(e); return; } if (subscriptionClosed(this)) cleanupSubscription(this); }; Subscription.prototype = redefineAll({}, { unsubscribe: function unsubscribe() { closeSubscription(this); } }); var SubscriptionObserver = function (subscription) { this._s = subscription; }; SubscriptionObserver.prototype = redefineAll({}, { next: function next(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; try { var m = getMethod(observer.next); if (m) return m.call(observer, value); } catch (e) { try { closeSubscription(subscription); } finally { throw e; } } } }, error: function error(value) { var subscription = this._s; if (subscriptionClosed(subscription)) throw value; var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.error); if (!m) throw value; value = m.call(observer, value); } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; }, complete: function complete(value) { var subscription = this._s; if (!subscriptionClosed(subscription)) { var observer = subscription._o; subscription._o = undefined; try { var m = getMethod(observer.complete); value = m ? m.call(observer, value) : undefined; } catch (e) { try { cleanupSubscription(subscription); } finally { throw e; } } cleanupSubscription(subscription); return value; } } }); var $Observable = function Observable(subscriber) { anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber); }; redefineAll($Observable.prototype, { subscribe: function subscribe(observer) { return new Subscription(observer, this._f); }, forEach: function forEach(fn) { var that = this; return new (core.Promise || global.Promise)(function (resolve, reject) { aFunction(fn); var subscription = that.subscribe({ next: function (value) { try { return fn(value); } catch (e) { reject(e); subscription.unsubscribe(); } }, error: reject, complete: resolve }); }); } }); redefineAll($Observable, { from: function from(x) { var C = typeof this === 'function' ? this : $Observable; var method = getMethod(anObject(x)[OBSERVABLE]); if (method) { var observable = anObject(method.call(x)); return observable.constructor === C ? observable : new C(function (observer) { return observable.subscribe(observer); }); } return new C(function (observer) { var done = false; microtask(function () { if (!done) { try { if (forOf(x, false, function (it) { observer.next(it); if (done) return RETURN; }) === RETURN) return; } catch (e) { if (done) throw e; observer.error(e); return; } observer.complete(); } }); return function () { done = true; }; }); }, of: function of() { for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++]; return new (typeof this === 'function' ? this : $Observable)(function (observer) { var done = false; microtask(function () { if (!done) { for (var j = 0; j < items.length; ++j) { observer.next(items[j]); if (done) return; } observer.complete(); } }); return function () { done = true; }; }); } }); hide($Observable.prototype, OBSERVABLE, function () { return this; }); $export($export.G, { Observable: $Observable }); __webpack_require__(201)('Observable'); /***/ }), /* 332 */ /***/ (function(module, exports, __webpack_require__) { // ie9- setTimeout & setInterval additional parameters fix var global = __webpack_require__(11); var $export = __webpack_require__(15); var userAgent = __webpack_require__(225); var slice = [].slice; var MSIE = /MSIE .\./.test(userAgent); // 2; var args = boundArgs ? slice.call(arguments, 2) : false; return set(boundArgs ? function () { // eslint-disable-next-line no-new-func (typeof fn == 'function' ? fn : Function(fn)).apply(this, args); } : fn, time); }; }; $export($export.G + $export.B + $export.F * MSIE, { setTimeout: wrap(global.setTimeout), setInterval: wrap(global.setInterval) }); /***/ }), /* 333 */ /***/ (function(module, exports, __webpack_require__) { var $export = __webpack_require__(15); var $task = __webpack_require__(221); $export($export.G + $export.B, { setImmediate: $task.set, clearImmediate: $task.clear }); /***/ }), /* 334 */ /***/ (function(module, exports, __webpack_require__) { var $iterators = __webpack_require__(202); var getKeys = __webpack_require__(38); var redefine = __webpack_require__(25); var global = __webpack_require__(11); var hide = __webpack_require__(17); var Iterators = __webpack_require__(137); var wks = __webpack_require__(34); var ITERATOR = wks('iterator'); var TO_STRING_TAG = wks('toStringTag'); var ArrayValues = Iterators.Array; var DOMIterables = { CSSRuleList: true, // TODO: Not spec compliant, should be false. CSSStyleDeclaration: false, CSSValueList: false, ClientRectList: false, DOMRectList: false, DOMStringList: false, DOMTokenList: true, DataTransferItemList: false, FileList: false, HTMLAllCollection: false, HTMLCollection: false, HTMLFormElement: false, HTMLSelectElement: false, MediaList: true, // TODO: Not spec compliant, should be false. MimeTypeArray: false, NamedNodeMap: false, NodeList: true, PaintRequestList: false, Plugin: false, PluginArray: false, SVGLengthList: false, SVGNumberList: false, SVGPathSegList: false, SVGPointList: false, SVGStringList: false, SVGTransformList: false, SourceBufferList: false, StyleSheetList: true, // TODO: Not spec compliant, should be false. TextTrackCueList: false, TextTrackList: false, TouchList: false }; for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) { var NAME = collections[i]; var explicit = DOMIterables[NAME]; var Collection = global[NAME]; var proto = Collection && Collection.prototype; var key; if (proto) { if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues); if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME); Iterators[NAME] = ArrayValues; if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true); } } /***/ }), /* 335 */ /***/ (function(module, exports) { /* WEBPACK VAR INJECTION */(function(global) {/** * Copyright (c) 2014, Facebook, Inc. * All rights reserved. * * This source code is licensed under the BSD-style license found in the * https://raw.github.com/facebook/regenerator/master/LICENSE file. An * additional grant of patent rights can be found in the PATENTS file in * the same directory. */ !(function(global) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; var inModule = typeof module === "object"; var runtime = global.regeneratorRuntime; if (runtime) { if (inModule) { // If regeneratorRuntime is defined globally and we're in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; } // Don't bother evaluating the rest of this file if the runtime was // already defined globally. return; } // Define the runtime globally (as expected by generated code) as either // module.exports (if we're in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : {}; function wrap(innerFn, outerFn, self, tryLocsList) { // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there's no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don't have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that // don't natively support it. var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function(method) { prototype[method] = function(arg) { return this._invoke(method, arg); }; }); } runtime.isGeneratorFunction = function(genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; runtime.mark = function(genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) { genFun[toStringTagSymbol] = "GeneratorFunction"; } } genFun.prototype = Object.create(Gp); return genFun; }; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, "__await")` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) { return { __await: arg }; }; function AsyncIterator(generator) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && typeof value === "object" && hasOwn.call(value, "__await")) { return Promise.resolve(value.__await).then(function(value) { invoke("next", value, resolve, reject); }, function(err) { invoke("throw", err, resolve, reject); }); } return Promise.resolve(value).then(function(unwrapped) { // When a yielded Promise is resolved, its final value becomes // the .value of the Promise result for the // current iteration. If the Promise is rejected, however, the // result for this iteration will be rejected with the same // reason. Note that rejections of yielded Promises are not // thrown back into the generator function, as is the case // when an awaited Promise is rejected. This difference in // behavior between yield and await is important, because it // allows the consumer to decide what to do with the yielded // rejection (swallow it and continue, manually .throw it back // into the generator, abandon iteration, whatever). With // await, by contrast, there is no opportunity to examine the // rejection reason outside the generator function, so the // only option is to throw it from the await expression, and // let the generator function handle the exception. result.value = unwrapped; resolve(result); }, reject); } } if (typeof global.process === "object" && global.process.domain) { invoke = global.process.domain.bind(invoke); } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new Promise(function(resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); } // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) { var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { // Setting context._sent for legacy support of Babel's // function.sent implementation. context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = "throw"; context.arg = record.arg; } } }; } // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a { value, done } result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === "throw") { if (delegate.iterator.return) { // If the delegate iterator has a return method, give it a // chance to clean up. context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { // If maybeInvokeDelegate(context) changed context.method from // "return" to "throw", let that override the TypeError below. return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError( "The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (! info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was "next", forget context.arg since it has been // "consumed" by the delegate iterator. If context.method was // "return", allow the original .return call to continue in the // outer generator. if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { // Re-yield the result returned by the delegate method. return info; } // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; } // Define Generator.prototype.{next,throw,return} in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers' implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn't happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() { return this; }; Gp.toString = function() { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } runtime.keys = function(object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } // Return an iterator with no values. return { next: doneResult }; } runtime.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function(skipTempReset) { this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel's // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { // Not sure about the optimal order of these conditions: if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = "next"; context.arg = undefined; } return !! caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle("end"); } if (entry.tryLoc]]></content>
      <categories>
        <category>Project Experience</category>
      </categories>
      <tags>
        <tag>Project Experience</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是字符串相关题目题解总结。 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑’*’： 如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符’‘考虑进去，它可以匹配任意次的字符，当然出现0次也可以： 而当模式中的第二个字符是时： 如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 1. 模式后移2字符，相当于x*被忽略； 2. 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 3. 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位； 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符&#39;.&#39;的情况。 1. 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为&#39;.&#39;的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 2. 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1.1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 1234567891011121314151617181920212223# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = left+(right-left)//2 if data[mid] == k: temp = 0 for i in range(left, right+1): if data[i] == k: temp += 1 return temp elif data[mid] &lt; k: left += 1 else: right -= 1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 0: return False Dict = &#123;&#125; for i in range(len(numbers)): if numbers[i] not in Dict: Dict[numbers[i]] = 1 else: Dict[numbers[i]] += 1 if Dict[numbers[i]] == 2: duplication[0] = numbers[i] return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1—&gt;0k+2—&gt;1n-1 —&gt; n-k-20 — &gt; n-k-1 k-1 —&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # 思路1 # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res # 思路2 res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。题量为66道，本系列所有题解汇总如下： 剑指offer题解 - 链表 剑指offer题解 - 树 剑指offer题解 - 数组 剑指offer题解 - 字符串 剑指offer题解 - 栈 剑指offer题解 - 递归 剑指offer题解 - 回溯 剑指offer题解 - 其他 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) —&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
