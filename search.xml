<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode第166场周赛]]></title>
    <url>%2F2019%2F12%2F08%2FLeetCodeWeeklyContest%2FLeetCode%E7%AC%AC166%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[本文是leetcode contest 106的题解，包括：12345279.整数的各位积和之差（简单）5280.用户分组 （中等）5281.使结果不超过阈值的最小除数 （中等）5282.转化为全零矩阵的最少反转次数（困难） 第一次打比赛，AC前三题，全国248 / 1675，全球1289 / 5585。 5279. 整数的各位积和之差题目描述给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例 1：123456输入：n = 234输出：15 解释：各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2：123456输入：n = 4421输出：21解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示：11 &lt;= n &lt;= 10^5 解题思路123456789101112class Solution &#123; public int subtractProductAndSum(int n) &#123; int mut = 1, sum = 0; while (n &gt; 0)&#123; int temp = n % 10; mut *= temp; sum += temp; n /= 10; &#125; return mut - sum; &#125;&#125; 5280. 用户分组题目描述有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。 你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。 示例 1：1234输入：groupSizes = [3,3,3,3,3,1,3]输出：[[5],[0,1,2],[3,4,6]]解释： 其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 示例 2：12输入：groupSizes = [2,1,3,3,3,2]输出：[[1],[0,5],[2,3,4]] 提示：123groupSizes.length == n1 &lt;= n &lt;= 5001 &lt;= groupSizes[i] &lt;= n 解题思路12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; groupThePeople(int[] groupSizes) &#123; // 将原数据转化为map，key为分组长度，value为索引 Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; groupSizes.length; i++)&#123; if (!map.containsKey(groupSizes[i]))&#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(i); map.put(groupSizes[i], temp); &#125;else&#123; map.get(groupSizes[i]).add(i); &#125; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 将map中数据按照长度拆分存入res for (Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry:map.entrySet())&#123; if (entry.getKey() == entry.getValue().size())&#123; res.add(entry.getValue()); &#125;else&#123; for (int i = 0; i &lt; entry.getValue().size(); i += entry.getKey())&#123; List&lt;Integer&gt; temp = entry.getValue().subList(i, i+entry.getKey()); res.add(temp); &#125; &#125; &#125; return res; &#125;&#125; 5281. 使结果不超过阈值的最小除数题目描述给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。 请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。 示例 1：1234输入：nums = [1,2,5,9], threshold = 6输出：5解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。 示例 2：12输入：nums = [2,3,5,7,11], threshold = 11输出：3 示例 3：12输入：nums = [19], threshold = 5输出：4 提示：1231 &lt;= nums.length &lt;= 5 * 10^41 &lt;= nums[i] &lt;= 10^6nums.length &lt;= threshold &lt;= 10^6 解题思路除数越大，除法结果和越小。 使用二分，除数范围为1~ max(nums)。因为提示中nums有界，为了少一轮遍历求数组最大值，可直接将上界取为10^6+1。 如果这个除法结果和大于阀值， 说明除数mid取的太小了，我们在[mid+1, right]中继续查找 如果这个除法结果和小于等于阀值，说明除数mid或者取得太大，或者满足要求，我们在[left,mid]中继续查找。 注意在2的情形下，mid可能是我们所要求的解，不应被剔除在搜索区间之外。 1234567891011121314151617181920class Solution &#123; public int smallestDivisor(int[] nums, int threshold) &#123; int left = 1, right = 1000000+1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int sum = 0; for (int num : nums) &#123; //向上取整 sum += num / mid + ((num % mid == 0) ? 0 : 1); &#125; if (sum &gt; threshold) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return right; &#125;&#125; 5282. 转化为全零矩阵的最少反转次数题目描述给你一个 m x n 的二进制矩阵 mat。 每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。（注：相邻的两个单元格共享同一条边。） 请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。 二进制矩阵的每一个格子要么是 0 要么是 1 。 全零矩阵是所有格子都为 0 的矩阵。 示例 1：123输入：mat = [[0,0],[0,1]]输出：3解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。 示例 2：123输入：mat = [[0]]输出：0解释：给出的矩阵是全零矩阵，所以你不需要改变它。 示例 3：12输入：mat = [[1,1,1],[1,0,1],[0,0,0]]输出：6 示例 4：123输入：mat = [[1,0,0],[1,0,0]]输出：-1解释：该矩阵无法转变成全零矩阵 提示：12345m == mat.lengthn == mat[0].length1 &lt;= m &lt;= 31 &lt;= n &lt;= 3mat[i][j] 是 0 或 1 。 解题思路使用位向量（即整数）保存矩阵的状态，使用BFS对每一个可能的状态，对其中的每一位进行翻转。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.util.ArrayDeque;import java.util.HashSet;import java.util.Queue;import java.util.Set;class Solution &#123; int n, m; public int minFlips(int[][] mat) &#123; n = mat.length; m = mat[0].length; //初始化状态 int bitVec = createBitVec(mat); if (bitVec == 0) &#123; return 0; &#125; Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); // 队列 queue.offer(bitVec); Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); // 保存访问过的数 int res = 0; // 常规BFS while (!queue.isEmpty()) &#123; int queueLen = queue.size(); for (int k = 0; k &lt; queueLen; k++) &#123; int curVec = queue.poll(); // 取出队顶元素 if (curVec == 0) &#123; //如果为0,返回 return res; &#125; //如果当前元素不为0,对其中每一位进行翻转 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; bitVec = getFlip(i, j, curVec); // 获取翻转后的数值 if (!visited.contains(bitVec)) &#123; //如果没访问过，加入队列和访问过的数的集合 queue.offer(bitVec); visited.add(bitVec); &#125; &#125; &#125; &#125; res++; &#125; return -1; &#125; public int createBitVec(int[][] mat) &#123; /*初始状态：获得矩阵的值 [[1,1,1], [1,0,1], [0,0,0]] 转化为二进制 111101000-&gt;十进制 488 */ int bitVec = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; bitVec &lt;&lt;= 1; bitVec |= mat[i][j]; &#125; &#125; return bitVec; &#125; public int getFlip(int i, int j, int bitVec) &#123; int pos = i * m + j; //根据i,j位置得到对应位 bitVec ^= (1 &lt;&lt; pos); //翻转 int[][] dirs = new int[][]&#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; //翻转四个方向的 for (int[] dir : dirs) &#123; int x = i + dir[0], y = j + dir[1]; if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m) &#123; pos = x * m + y; bitVec ^= (1 &lt;&lt; pos); &#125; &#125; return bitVec; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode周赛</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-缓存算法]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[LRU缓存LRU（Least recently used，最近最少使用）首先淘汰最长时间未被使用的页面。 leetcode 146. LRU缓存机制链接运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例:1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 思路：get()相当于读，put()即是写。一次读或写意味着对缓存块使用了一次，该缓存的优先级就提高。 思路比较简单，基于哈希表和双向链表。先通过哈希表查找缓存块的位置，也就是缓存块在链表中的位置。然后在表中删除该缓存块，重新把该缓存块置于链表表尾。如果插入后缓存已经满了，那就把表头的缓存块丢掉，同时删除哈希表对应的记录。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Node(object): def __init__(self, k, v): self.key = k self.val = v self.prev = None self.next = Noneclass LRUCache(object): def __init__(self, capacity): """ :type capacity: int """ self.capacity = capacity self.dic = dict() self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key): """ :type key: int :rtype: int """ if key in self.dic: node = self.dic[key] self.remove(node) self.add(node) return node.val return -1 def put(self, key, value): """ :type key: int :type value: int :rtype: None """ if key in self.dic: self.remove(self.dic[key]) node = Node(key, value) self.add(node) self.dic[key] = node if len(self.dic) &gt; self.capacity: node = self.head.next self.remove(node) del self.dic[node.key] def remove(self, node): pNode = node.prev nNode = node.next pNode.next = nNode nNode.prev = pNode def add(self, node): pNode = self.tail.prev pNode.next = node self.tail.prev = node node.prev = pNode node.next = self.tail# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)if __name__ == '__main__': cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) #// 返回 1 cache.put(3, 3) #// 该操作会使得密钥 2 作废 print(cache.get(2)) # // 返回 -1 (未找到) cache.put(4, 4) # // 该操作会使得密钥 1 作废 print(cache.get(1)) #// 返回 -1 (未找到) print(cache.get(3)) # // 返回 3 print(cache.get(4)) #// 返回 4 LFU缓存LRU（Least recently used，最近最少使用）首先淘汰最近一定时期内被访问次数最少的页面。 leetcode 460. LFU缓存链接 设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。 进阶：你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例：123456789101112LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 去除 key 2cache.get(2); // 返回 -1 (未找到key 2)cache.get(3); // 返回 3cache.put(4, 4); // 去除 key 1cache.get(1); // 返回 -1 (未找到 key 1)cache.get(3); // 返回 3cache.get(4); // 返回 4 待续…]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树形DP]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%BD%A2DP%2F</url>
    <content type="text"><![CDATA[树上的动态规划，即树形DP。做树形DP一般步骤是先将树转换为有根树，然后在树上进行深搜操作，从子节点或子树中返回信息层层往上更新至根节点。 思路：小树计算完，再算父亲树。 分析可能性（先计算小树，再计算大树） 列信息全集，定下返回值结构。 编写代码的时候，默认每颗子树都给你这样的信息，然后看拿到这些子树信息后怎么加工出父的信息。 Basecase要单独考虑一下，作为最简单的情况，要给父返回啥，不至于让他干扰。 1. 给定一棵二叉树的头节点head，请返回最大搜索二叉子树的大小假设以每个节点为头的树，求出它的最大二叉子树，答案一定在所有节点的最大二叉子树中。 第一步：列出可能性 可能来自左子树的某棵子树 可能来自右子树的某棵子树 整棵树都是，左右子树都是搜索二叉树并且左子树最大值小于该节点，右子树最小值大于该节点 第二步：收集信息 左子树最大搜索子树大小 右子树最大搜索子树大小 左子树中最大二叉搜索子树的头部（通过查看这个头部是否等于节点的左孩子，来判断整个左子树是否都是二叉搜索树）4、右子树最大二叉搜索子树的头部5、左子树最大值6、右子树最小值 因此不管对于左子树还是右子树都需要收集的信息： 最大搜索子树大小 最大搜索子树的头部 这棵树的最大值 这棵树的最小值 第三步：改递归先假设左和右都给我这样的信息了，然后怎么利用左边和右边的信息，组出来我该返回的信息。 对于某节点，如果其左子树返回的头结点是该节点的左孩子，且其右子树返回的头结点是该节点的右孩子，且左子树的最大值小于该节点值，且右子树的最小值大于该节点值，则以该节点为根的整棵子树是二叉搜索树，长度是左长+1+右长。 如果1不成立，则判断左搜和右搜的大小，以该节点为根的最大二叉搜索树的大小为其中较大者。 BaseCase是当一棵树为空时，大小为0，头部为空，最小值为系统最小，最大值为系统最大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, size, root, min, max): self.size = size self.root = root self.min = min self.max = maxclass Solution(object): def BiggestSubBSTInTree(self, root): if not root: return 0 res = self.process(root) return res.size def process(self, root): if not root: return returnData(0, None, float('inf'), float('-inf')) leftData = self.process(root.left) rightData = self.process(root.right) includeItSelf = 0 if leftData.root == root.left and rightData.root == root.right and root.val &gt; leftData.max and root.val &lt; rightData.min: includeItSelf = leftData.size + 1 + rightData.size p1 = leftData.size p2 = rightData.size maxSize = max(p1, p2, includeItSelf) maxHead = leftData.root if p1 &gt; p2 else rightData.root if maxSize == includeItSelf: maxHead = root return returnData(maxSize, maxHead, min(leftData.min, rightData.min, root.val), max(leftData.max, rightData.max, root.val))if __name__ == '__main__': root = TreeNode(16) root.left = TreeNode(200) root.left.left = TreeNode(6) root.left.right = TreeNode(9) root.left.left.left = TreeNode(5) root.left.left.right = TreeNode(7) root.left.right.right = TreeNode(12) root.right = TreeNode(20) root.right.left = TreeNode(17) root.right.right = TreeNode(21) res = Solution().BiggestSubBSTInTree(root) print(res) 2 求二叉树中节点的最大距离二叉树中，一个节点可以往上走和往下走，那么从节点A总能走到节点B。节点A走到节点B的距离为：A走到B最短路径上的节点个数。求一棵二叉树上的最远距离。 考虑每一个节点为根节点的情况，答案一定在其中。 第一步：列出可能性 来自左子树的最长距离 来自右子树的最长距离 经过该节点情况下的最远距离，左子树深度+1+右子树深度 第二步：收集信息 最长距离 树的深度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, maxLen, depth): self.maxLen = maxLen self.depth = depthclass Solution(object): def MaxDistanceInTree(self, root): if not root: return 0 res = self.process(root) return res.maxLen def process(self, root): if not root: return returnData(0, 0) leftData = self.process(root.left) rightData = self.process(root.right) includeHeadDLen = leftData.depth + 1 + rightData.depth maxLen = max(leftData.maxLen, rightData.maxLen, includeHeadDLen) depth = max(leftData.depth, rightData.depth) + 1 return returnData(maxLen, depth)if __name__ == '__main__': root = TreeNode(16) root.left = TreeNode(200) root.left.left = TreeNode(6) root.left.right = TreeNode(9) root.left.left.left = TreeNode(5) root.left.left.right = TreeNode(7) root.left.right.right = TreeNode(12) root.right = TreeNode(20) root.right.left = TreeNode(17) root.right.right = TreeNode(21) res = Solution().MaxDistanceInTree(root) print(res) 3 没有上司的晚会一个公司的上下节关系是一棵多叉树，这个公司要举办晚会，你作为组织者已经摸清了大家的心理：一个员工的直接上级如果到场，这个员工肯定不会来。每个员工都有一个活跃度的值，决定谁来你会给这个员工发邀请函，怎么让舞会的气氛最活跃？返回最大的活跃值。 给定一个矩阵来表述这种关系 matrix = [[1,6],[1,5],[1,4]] 这个矩阵的含义是：matrix[0] = {1 , 6}，表示0这个员工的直接上级为1,0这个员工自己的活跃度为6matrix[1] = {1 , 5}，表示1这个员工的直接上级为1（他自己是这个公司的最大boss）,1这个员工自己的活跃度为5matrix[2] = {1 , 4}，表示2这个员工的直接上级为1,2这个员工自己的活跃度为4为了让晚会活跃度最大，应该让1不来，0和2来。最后返回活跃度为10 对于某节点 i可能性： i 来，活跃度就是X的活跃度+下属员工不来的活跃度总和 i 不来，活跃度就是每个下属员工来或不来中选最大的总和 我们可以定义 $ f(i, 0 / 1)$ 代表以 i 为根的子树的最优解（第二维的值为 0 代表不来的情况，1 代表 来的情况）。则转移方程为（其中下面的 x 都是 i 的儿子）：）： $f(i, 0)=\sum \max \{f(x, 1), f(x, 0)\}$（上司不来时，下属可以来，也可以不来）$f(i, 1)=\sum f(x, 0)+a_{i}$ (上司来时，下属都不会来） 结果返回 $max(f(i, 0), f(i, 1))$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Node(object): def __init__(self, happy): self.happy = happy self.nexts = []class returnData(object): def __init__(self, comeHappy, notComeHappy): self.comeHappy = comeHappy self.notComeHappy = notComeHappyclass Solution(object): def MaxHappy(self, root): if not root: return 0 # 找到大Boss，后面从大Boss开始计算 root = 0 for i in range(len(matrix)): if i == matrix[i][0]: root = i break # 构建数据结构 Node [happy, nexts] happy表示活跃度，nexts表示它的直接下属 Nodes = [] for i in range(len(matrix)): Nodes.append(Node(matrix[i][1])) Dicts = &#123;&#125; for i in range(len(matrix)): if matrix[i][0] == i: continue if matrix[i][0] not in Dicts: Dicts[matrix[i][0]] = [i] else: Dicts[matrix[i][0]].append(i) for i in range(len(matrix)): if i in Dicts: for j in Dicts[i]: Nodes[i].nexts.append(Nodes[j]) res = self.process(Nodes[root]) return max(res.comeHappy, res.notComeHappy) def process(self, root): if not root: return returnData(0, 0) comeHappy = root.happy notComeHappy = 0 for i in range(len(root.nexts)): data = self.process(root.nexts[i]) comeHappy += data.notComeHappy notComeHappy += max(data.comeHappy, data.notComeHappy) return returnData(comeHappy, notComeHappy)if __name__ == '__main__': matrix = [[0,16],[0,5],[0,4],[0,300], [1,6],[1,7],[1,9], [2,3],[2,7], [3,10],[3,2],[3,3],[3,5]] res = Solution().MaxHappy(matrix) print(res) 4 判断一棵树是否是平衡二叉树1234567891011121314151617181920212223242526272829303132333435363738394041424344class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = Noneclass returnData(object): def __init__(self, isB, depth): self.isB = isB self.depth = depthclass Solution(object): def IsBalancedTree(self, root): if not root: return True return self.process(root).isB def process(self, root): if not root: return returnData(True, 0) leftData = self.process(root.left) if not leftData.isB: return returnData(False, 0) rightData = self.process(root.right) if not rightData.isB: return returnData(False, 0) if abs(leftData.depth - rightData.depth) &gt; 1: return returnData(False, 0) return returnData(True, max(leftData.depth, rightData.depth)+1)if __name__ == '__main__': root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.left.left.left = TreeNode(6) res = Solution().IsBalancedTree (root) print(res)`]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-Morris遍历]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Morris%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[背景对二叉树节点的遍历一般来说有中序，后序，和前序三种遍历方法，如果二叉树的高用$h$来表示，那三种遍历方法所需要的空间复杂度为$O(h)$。遍历的时候因为没有指向父节点的指针，无法从下往上走，所以采用栈，但是树的节点有很多的left，right指向null，Morris遍历利用了这些指针实现了$O(1)$的空间复杂度。 Morris遍历原理要使用$O(1)$空间进行遍历，最大的难点在于，遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针），由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了线索二叉树（threaded binary tree）的概念。在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了。 使用Morris实现中序，后序，和前序的历程都是一样的，区别在于输出打印的时机不同。记当前节点为cur。 如果当前节点无左子树，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 Morris前序顺序当前节点的mostRight的右指针指向空，或者当前节点左子树为空格，打印该节点。具体过程为： 如果当前节点无左子树，打印当前节点，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，打印当前节点，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空(恢复树的形状)，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 图示： 代码：leetcode 144. 二叉树的前序遍历 测试通过。12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: res.append(cur.val) cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: res.append(cur.val) mostRight.right = cur cur = cur.left elif mostRight.right == cur: mostRight.right = None cur = cur.right return res 复杂度分析：空间复杂度：$O(1)$，因为只用了两个辅助指针。时间复杂度：$O(n)$。证明时间复杂度为$O(n)$，最大的疑惑在于寻找中序遍历下二叉树中所有节点的前驱节点的时间复杂度是多少，即以下两行代码：12while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right 直觉上，认为它的复杂度是$O(nlgn)$，因为找单个节点的前驱节点与树的高度有关。但事实上，寻找所有节点的前驱节点只需要$O(n)$时间。n个节点的二叉树中一共有n-1条边，整个过程中每条边最多只走2次，一次是为了定位到某个节点，另一次是为了寻找上面某个节点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点。所以复杂度为$O(n)$。 Morris中序遍历当前节点往右移动之前打印。具体过程为： 如果当前节点无左子树，打印当前节点，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，打印当前节点，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空。 图示： 代码：leetcode 94. 二叉树的中序遍历 测试通过。123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: res.append(cur.val) cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: mostRight.right = cur cur = cur.left elif mostRight.right == cur: res.append(cur.val) mostRight.right = None cur = cur.right return res 复杂度分析：时间复杂度和空间复杂度都与前序遍历情况相同。 Morris后序遍历当发现当前节点的mostRight的右指针指向自己，逆序打印左子树的右边界，直到当前节点为空时，逆序打印整棵树根节点的右边界。具体过程为 如果当前节点无左子树，cur向右移动，cur=cur.right； 如果当前节点有左子树，找到cur左子树最右节点，记为mostRight； 1) 如果mostRight的右指针为空，则让mostRight的右指针指向cur，cur向左移动，cur=cur.left; 2) 如果mostRight的右指针指向cur，则让mostRight的右指针指向空，逆序打印从当前节点的左子树的右边界，cur向右移动，cur=cur.right; 重复以上过程直到当前节点为空； 逆序打印整棵树根节点的右边界。 逆序打印的过程可以将该右边界上的节点看做以right指针为后继指针的链表，将其反转reverse然后打印，最后恢复成原始结构即可。 图示： 代码：leetcode 145. 二叉树的后序遍历 测试通过。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] cur = root while cur: if not cur.left: cur = cur.right else: mostRight = cur.left while mostRight.right != None and mostRight.right != cur: mostRight = mostRight.right if not mostRight.right: mostRight.right = cur cur = cur.left elif mostRight.right == cur: mostRight.right = None self.printEdge(cur.left,res) cur = cur.right self.printEdge(root, res) return res def printEdge(self, head, res): tail = self.reverseEdge(head) cur = tail while cur: res.append(cur.val) cur = cur.right self.reverseEdge(tail) def reverseEdge(self, head): pre = None while head: next = head.right head.right = pre pre = head head = next return pre 复杂度分析：空间复杂度同样是$O(1)$；时间复杂度也是$O(n)$，逆序输出过程只不过是加大了常数系数。 总结morris遍历结点的顺序不是先序、中序、后序，而是按照自己的一套标准来决定接下来要遍历哪个结点。morris遍历的独特之处就是充分利用了叶子结点的无效引用（引用指向的是空，但该引用变量仍然占内存），从而实现了$O(1)$的时间复杂度。 Reference：https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.htmlhttps://www.jianshu.com/p/484f587c967chttps://blog.csdn.net/zjucor/article/details/72898494]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-单调栈]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%2F</url>
    <content type="text"><![CDATA[单调栈的定义单调栈就是栈内元素单调递增或者单调递减的栈，单调栈只能在栈顶操作。 为了更好的理解单调栈，则可将单调栈用生活情形模拟实现，例如： 我们借用拿号排队的场景来说明下。现在有很多人在排队买可乐，每个人手里都拿着号，越靠前的人手里的号越小，但是号不一定是连续的。小明拿了号后并没有去排队，而是跑去约会了。等他回来后，发现队伍已经排得很长了，他不能直接插入到队伍里，不然人家以为他是来插队的。小明只能跑到队伍最后，挨个询问排队人手里的号，小明认为号比他大的人都是“插队”的，于是小明就会施魔法把这些人变消失，直到小明找到号比他小的为止。 在上面这个场景里，大家排的队伍就像是单调栈，因为大家手里拿的号是单调递增的。而小明找自己位置的这个过程就是元素加入单调栈的过程。新加入的元素如果加到栈顶后，如果栈里的元素不再是单调递增了，那么我们就删除加入前的栈顶元素，就像小明施魔法把“插队”的人变消失一样。直到新元素加入后，栈依然是单调递增时，我们才把元素加进栈里。 （这样做的目的是“维护”单调栈，是单调栈保持原来的单调性不变） 单调栈的一大优势就是线性的时间复杂度$O(N)$，所有的元素只会进栈一次，而且一旦出栈后就不会再进来了。 单调递增栈可以找到左右两边最近的且比当前数字小的元素。比如数组 [2 1 4 6 5]刚开始2入栈，栈为[2]；数字1入栈的时候，发现栈顶元素2比较大，将2移出栈，收集元素2左右两边最近的比2小的数，左边为null，右边为1，此后1入栈，栈为[1];然后数字4入栈的时候，栈顶元素1小于4，4入栈，此时栈里为[1,4]然后数字6入栈的时候，栈顶元素4小于6，6入栈，此时栈里有[1,4,6]然后数字5入栈的时候，栈顶元素6大于5，将6移除，收集元素6左右两边最近的比6小的数，左边为4，右边为5，栈为[1,4]，此时新的栈顶元素4小于5，那么4就是5左起的第一个小的数字，收集5入栈栈内数字为 [1,4,5]。 遍历完数组之后，栈中元素出栈。5出栈，栈为[1,4]，收集元素5左右两边最近的比5小的数，左边为4，右边为null；4出栈，栈为[1]，收集元素4左右两边最近的比4小的数，左边为1，右边为null；1出栈，栈为[]，收集元素1左右两边最近的比1小的数，左边为null，右边为null； 单调递减栈可以找到左右两边最近的且比当前数字大的元素。 单调栈的应用leetcode 84. 柱状图中最大的矩形题目描述给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3]输出: 10 解题思路使用一个递增单调栈，栈中保存坐标，数组中坐标依次入栈，当当前坐标的值小于栈顶坐标的值，则栈顶坐标弹出，并计算弹出坐标的面积，它的右边界是当前坐标的值（因为当前坐标让它出栈），左边界是栈顶坐标（当栈为空时为-1）。当数组遍历完成后，栈不为空，则依次弹出，计算弹出坐标的面积，右边界是数组长度，左边界是栈顶坐标（当栈为空时为-1）。 例如：[2,1,5,6,2,3]先将2的坐标入栈，栈为[0]；元素1的坐标1入栈前比较，因为1位置的元素比栈顶(0)位置的元素小，则位置0出栈，栈为空，计算0位置的面积(1-(-1)-1)*2=2，在将1入栈，栈为[1]；坐标2的元素5大于栈顶位置元素(1)，则坐标2入栈，栈为[1,2]；坐标3的元素6大于栈顶位置元素(5)，则坐标3入栈，栈为[1,2,3]；坐标4的元素2小于栈顶位置元素(6)，则将栈顶位置3弹出，栈为[1,2]，计算3位置的面积(4-2-1)*6 = 6，此时2依然小于栈顶位置2的元素5，则栈顶位置2出栈，栈为[1]，计算2位置的面积(4-1-1)*5=10；此时2大于栈顶位置元素，则2的坐标4入栈，栈为[1,4]；坐标5的元素3大于栈顶位置元素(2)，坐标5入栈，栈为[1,4,5]；数组遍历完成。 此时栈不为空，依次弹出计算面积。弹出位置5，栈为[1,4]，面积为(6-4-1)*3=3;弹出位置4，栈为[1]，面积为(6-1-1)*2=8;弹出位置1，栈为空，面积为(6-(-1)-1)*1=6;所以最大面积为max(2,6,10,3,8,6)=10。 123456789101112131415161718192021222324class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i-left-1)*heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1)*heights[index]) return res leetcode 85 最大矩形题目描述给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 解题思路使用一个辅助数组，大小为矩阵列宽，依次以矩阵每一行为底计算最大面积，直接调用上一题的代码计算。辅助数组计算方法：初始化为0，当当前元素为1是，高度加1，为0时直接为0。例如上例的辅助数组情况为：第一行 [1 0 1 0 0]第二行 [2 0 2 1 1]第三行 [3 1 3 2 2]第四行 [4 0 0 3 0] 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def maximalRectangle(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 heights = [0] * len(matrix[0]) res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 res = max(res, self.largestRectangleArea(heights)) return res def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i - left - 1) * heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1) * heights[index]) return res leetcode 42. 接雨水题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路解法一：先找出最高点，然后分别从左到最高点遍历，从右到最高点遍历。遍历过程中收集信息。123456789101112131415161718192021222324252627282930313233343536class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if len(height) &lt; 3: return 0 # 求最高点处的索引 #从左往最高点遍历 # 从右往最高点遍历 maxIndex = 0 for i in range(1, len(height)): if height[i] &gt; height[maxIndex]: maxIndex = i res = 0 curMax = height[0] for i in range(1, maxIndex): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] curMax = height[-1] for i in range(len(height)-2, maxIndex, -1): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] return res 解法二：单调栈利用一个单调递减栈，保存元素的坐标，当遇到当前高度比栈顶高度大的时候，说明有可能会有坑的存在，此时我们的栈里至少有一个高度，如果只有一个时，不能形成坑，弹出栈中元素，将当前高度压入栈，因为当前高度比栈顶高度大，替换即可。如果两个及以上时，说明形成坑了，弹出栈顶元素作为坑，右边界为当前高度，左边界为新的栈顶元素，取二者较小的减去坑的高度就为这个坑的高度，长度就是右边界坐标减去左边界左边再减1，二者相差就是这个坑的盛水量。 123456789101112131415161718192021class Solution(object): def trap(self, height): """ :type height: List[int] :rtype: int """ if len(height) &lt; 3: return 0 res = 0 stack = [] for i in range(len(height)): while stack and height[i] &gt; height[stack[-1]]: low = stack.pop() if not stack: break res += (min(height[i], height[stack[-1]]) - height[low]) * (i - stack[-1] -1) stack.append(i) return res 京东2017年笔试题 保卫方案（山峰对数量）题目描述战争游戏的至关重要环节就要到来了，这次的结果将决定王国的生死存亡，小B负责首都的防卫工作。首都位于一个四面环山的盆地中，周围的n个小山构成一个环，作为预警措施，小B计划在每个小山上设置一个观察哨，日夜不停的瞭望周围发生的情况。 一旦发生外地入侵事件，山顶上的岗哨将点燃烽烟，若两个岗哨所在的山峰之间没有更高的山峰遮挡且两者之间有相连通路，则岗哨可以观察到另一个山峰上的烽烟是否点燃。由于小山处于环上，任意两个小山之间存在两个不同的连接通路。满足上述不遮挡的条件下，一座山峰上岗哨点燃的烽烟至少可以通过一条通路被另一端观察到。对于任意相邻的岗哨，一端的岗哨一定可以发现一端点燃的烽烟。 小B设计的这种保卫方案的一个重要特性是能够观测到对方烽烟的岗哨对的数量，她希望你能够帮她解决这个问题。 输入描述:输入中有多组测试数据，每一组测试数据的第一行为一个整数$n(3&lt;=n&lt;=10^6)$,为首都周围的小山数量，第二行为n个整数，依次表示为小山的高度$h（1&lt;=h&lt;=10^9）$. 输出描述:对每组测试数据，在单独的一行中输出能相互观察到的岗哨的对数。示例1 12345输入51 2 4 5 3输出7 解题思路使用单调递减的栈，栈中的数据结构是高度和该高度连续出现的次数。找到最大值的下标，从最大值处开始循环遍历。当遇到当前高度大于栈顶高度时，弹出栈顶元素，收集该元素的山峰对数量，等于该高度山峰内部形成的对数与该高度山峰和两边的高点形成的山峰对。遍历完成之后，对栈中元素依次弹出，收集信息。 例如：1 2 4 5 3。找出最大值下标，从最大值开始遍历，遍历顺序为 5 3 1 2 4。res = 05入栈，stack=[(5,1)]3入栈，stack=[(5,1),(3,1)]1入栈，stack=[(5,1),(3,1),(1,1)]当前元素2，2大于栈顶元素1，(1,1)出栈，stack=[(5,1),(3,1)]，因为连续1只有一个，所以curTimes=1，所以连续1内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素1的左边高点为当前栈顶3，右边高点为当前栈顶2，所以山峰对数量 curTimes*2=2，res = 2。当前元素2小于当前栈顶3，2入栈，stack=[(5,1),(3,1),(2,1)]当前元素4，4大于栈顶元素2，(2,1)出栈，stack=[(5,1),(3,1)]，因为连续2只有一个，所以curTimes=1，所以连续2内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素2的左边高点为当前栈顶3，右边高点为当前栈顶4，所以山峰对数量 curTimes*2=2，res = 4。当前元素4，4大于栈顶元素3，(3,1)出栈，stack=[(5,1)]，因为连续3只有一个，所以curTimes=1，所以连续3内部山峰对数量为curTimes*(curTimes-1)//2=0， 元素3的左边高点为当前栈顶5，右边高点为当前栈顶4，所以山峰对数量 curTimes*2=2，res = 6。当前元素4小于当前栈顶5，4入栈，stack=[(5,1),(4,1)] 遍历完成之后，依次弹出栈中元素。弹出(4,1)，stack=[(5,1)]，因为连续4只有一个，所以curTimes=1，所以连续4内部山峰对数量为curTimes*(curTimes-1)//2=0， 栈中元素为1个，且次数为1，4的左边高点为当前栈顶5，右边无高点，所以山峰对数量 curTimes=1，res = 7。弹出(5,1)，stack=[]，山峰对为0。最终山峰对为7。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Pair(object): def __init__(self, value): self.value = value self.times = 1 # 默认个数为1class Solution(object): def main(self, height): if len(height) &lt;= 1: return 0 if len(height) == 2: return 1 res = 0 maxIndex = 0 for i in range(1, len(height)): maxIndex = i if height[i] &gt; height[maxIndex] else maxIndex stack = [Pair(height[maxIndex])] curIndex = self.nextIndex(maxIndex, len(height)) while curIndex != maxIndex: while stack and height[curIndex] &gt; stack[-1].value: curTimes = stack.pop().times # 连续相等高度内部的山峰对 + 到一个高点的山峰对 res += curTimes*(curTimes-1)//2 + curTimes # 到另一个高点的山峰对 res += curTimes if stack else 0 if stack and stack[-1].value == height[curIndex]: stack[-1].times += 1 else: stack.append(Pair(height[curIndex])) curIndex = self.nextIndex(curIndex, len(height)) while stack: curTimes = stack.pop().times res += curTimes*(curTimes-1)//2 # 当前高度山峰内部的对数 if stack: res += curTimes # 到一个高点的对数 # 如果剩下两个以上高点的话，加上另一个高点的对数 if len(stack) &gt;= 2: res += curTimes else: # 如果只有一个的话，个数大于等于2，相当于有两个高点，加times # 个数等于1，则只有一个高点，加0 res += curTimes if stack[-1].times &gt;= 2 else 0 return res def nextIndex(self, curIndex, len): return curIndex+1 if curIndex &lt; len-1 else 0 if __name__ == '__main__': result = Solution().main([1,2,4,5,3]) print(result) 参考文献https://www.cnblogs.com/grandyang/p/8887985.htmlhttps://blog.csdn.net/qq_35314344/article/details/76083170]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-滑动窗口问题]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原始问题分析给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。常规解法：时间复杂度为$O(N * w)$，也就是每次对一个窗口都需要遍历其中的 w 个数，选出最大值。 $O(N)$解法：准备一个双端队列，双端队列存放着数组中的下标值。假设当前为 arr[i]，则放入规则如下：left 和 right 指针都只会向右移动，不会回退。 right 右滑，窗口加数： 1）如果 queue 为空，直接把下标 i 放入 queue 中； 2）如果 queue 不为空，取出当前 queue 队尾存放的下标 j。如果 arr[j] &gt; arr[i]，则直接把 i 放入队尾； 3）如果 arr[j] &lt;= arr[i]，则一直从 queue 的队尾弹出下标，直到某个下标在 queue 中的对应值大于 arr[i]，然后把 i 放入队尾 【为什么可以弹出，因为我永远比你晚过期，我又比你大或者和你一样大，有我在，你永远不可能最大，所以你可以弹出了】 left 右滑，窗口减数： 1）看弹出的 left 是否与队列头相等，如果相等，说明这个队列头已经不在窗口内了，所以弹出 queue 当前的队首元素 。 双端队列的队头就是当前窗口最大值的下标。 应用上面的滑动窗口的实现是通用结构，即 left 和 right 指针随便往右移，而在实际解题过程在，都是会限制窗口的大小。 1. 剑指offer：滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 常规解法：时间复杂度为O(N * w)，也就是每次对一个窗口都需要遍历其中的 w 个数，选出最大值。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result) $O(N)$解法：和通用结构相比。只在弹出时稍微改变：如果queue对应的下标等于i-size, 说明当前队首下标已经过期，则弹出queue当前队首下标。 1234567891011121314151617181920from collections import deque# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] res = [0] * (len(num)-size+1) index = 0 queue = deque() for i in range(len(num)): while len(queue) != 0 and num[queue[-1]] &lt;= num[i]: queue.pop() queue.append(i) if queue[0] == i-size: queue.popleft() if i &gt;= size-1: # 有窗口形成后，在计算窗口内最大值 res[index] = num[queue[0]] index += 1 return res 2. 最大值减去最小值小于或等于num的子数组数量给定数组arr和整数num，返回有多少个子数组满足如下情况: $max(arr[i:j]) - min(arr[i:j]) &lt;= num$ $max(arr[i:j])$表示子数组$arr[i:j]$中的最大值，$min(arr[i:j])$表示子数组$arr[i:j]$中的最小值。 要求：如果数组长度为 N，请实现时间复杂度为 O(N)的解法。 解题思路子数组的数量：以0开始：0~0，0~1，...，0~N-1，共N种情况；以1开始：1~1，1~2，...，1~N-1，共N-1种情况；……以N-1开始：N-1~N-1，共1种情况。所以总共有 $N+N-1+N-2+…+2+1=\frac{N(N-1)}{2}$种情况。 暴力解法：两层遍历所有情况，一层遍历求最大最小值，共三层遍历，时间复杂度$O(N^3)$。 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def main(self, arr, num): # write code here res = 0 for start in range(len(arr)): for end in range(start, len(arr)): if self.isValid(arr, start, end, num): res += 1 return res def isValid(self, arr, start, end , num): max_value = float('-inf') min_value = float('inf') for i in range(start, end+1): max_value = max(max_value, arr[i]) min_value = min(min_value, arr[i]) return max_value-min_value &lt;= numif __name__ == '__main__': result = Solution().main([1,3,5,7,9,11,13,15],4) print(result) $O(N)$解法： 两个结论： 如果子数组arr[i:j]满足条件，那么arr[k:l]（i&lt;=k&lt;=l&lt;=j）一定满足条件，即若一个数组满足条件，它的所有子数组肯定满足条件，因为[max 变小 - min 变大 &lt;= num 肯定成立]。 如果子数组 arr[i:j] 不满足条件，那么 arr[k:l] （k &lt;= i，I &gt;= j） 都不满足条件，即若一个数组不满足条件，所有包含它的数组肯定都不满足条件。因为[max变大 - min变小 &gt;= num肯定成立]。 步骤：准备两个双端队列，一个 maxQueue 是窗口内最大值更新结构，一个 minQueue 是窗口内最小值更新结构，left、right 表示窗口的左右边，窗口范围为 [left , right - 1]；算以 left 开头达标的子数组个数，每个 left 就可以算出一批答案，相加即可。 1)以 left 开头的情况下，right 往外扩，扩到不达标就停【因为再往外肯定也不达标】，算以 left 开头的子数组有多少个【这些子数组都达标的】； 2)left 右移一位，然后重复 1）。 因为 left，right 都不后退，且每个数都只进出一次，所以时间复杂度是 $O(N)$。 12345678910111213141516171819202122232425262728293031323334353637383940from collections import deque# -*- coding:utf-8 -*-class Solution: def main(self, arr, num): # write code here maxQueue = deque() minQueue = deque() left, right = 0, 0 res = 0 while left &lt; len(arr): while right &lt; len(arr): while len(maxQueue) != 0 and arr[maxQueue[-1]] &lt;= arr[right]: maxQueue.pop() maxQueue.append(right) while len(minQueue) != 0 and arr[minQueue[-1]] &gt;= arr[right]: minQueue.pop() minQueue.append(right) if arr[maxQueue[0]] - arr[minQueue[0]] &gt; num: # 不满足 break right += 1 # left向前推动， 两个双端队列调整 if maxQueue[0] == left: maxQueue.popleft() if minQueue[0] == left: minQueue.popleft() res += right - left # 收集满足的结果 left += 1 # 下一个开头 return res if __name__ == '__main__': result = Solution().main([1,3,5,7,9,11,13,15],4) print(result) 参考文献：https://blog.csdn.net/pcwl1206/article/details/96431668https://www.cnblogs.com/xieyupeng/p/10373585.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-BFPRT算法]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-BFPRT%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景在一大堆数中求其前k大或前k小的问题，简称TOP-K问题。而目前解决TOP-K问题最有效的算法即是BFPRT算法，其又称为中位数的中位数算法，该算法由Blum、Floyd、Pratt、Rivest、Tarjan提出，最坏时间复杂度为$O(n)$。 在首次接触TOP-K问题时，我们的第一反应就是可以先对所有数据进行一次排序，然后取其前k即可，但是这么做有两个问题：（1）快速排序的平均复杂度为$O(nlogn)$，但最坏时间复杂度为$O(n^2)$，不能始终保证较好的复杂度。（2）我们只需要前k大的，而对其余不需要的数也进行了排序，浪费了大量排序时间。 除这种方法之外，堆排序也是一个比较好的选择，可以维护一个大小为k的堆，时间复杂度为$O(nlogk)$。 那是否还存在更有效的方法呢？受到快速排序的启发，通过修改快速排序中主元的选取方法可以降低快速排序在最坏情况下的时间复杂度（即BFPRT算法），并且我们的目的只是求出前k，故递归的规模变小，速度也随之提高。下面来简单回顾下快速排序的过程，以升序为例：（1）选取主元（首元素，尾元素或一个随机元素）；（2）以选取的主元为分界点，把小于主元的放在左边，大于主元的放在右边；（3）分别对左边和右边进行递归，重复上述过程。 快速排序代码12345678910111213141516171819202122232425262728293031323334class Solution(object): def main(self, nums, k): self.quickSort(nums, 0, len(nums)-1) return nums[k] def quickSort(self, nums, left, right): if left &gt;= right: return povit = self.partition(nums, left, right) self.quickSort(nums, left, povit-1) self.quickSort(nums, povit+1, right) def partition(self, nums, left, right): temp = nums[left] while left &lt; right: while left &lt; right and nums[right] &gt;= temp: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &lt;= temp: left += 1 self.swap(nums, left, right) return left def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = tempif __name__ == '__main__': res = Solution().main([3,4,1,2,5,7,23,4,1,5], 4) print(res) BFPRT算法BFPRT算法步骤如下：（1）选取主元； （1.1）将n个元素划分为$n/5$个组，每组5个元素，最后不足5个的为一组； （1.2）使用插入排序找到$n/5$个组中每一组的中位数； （1.3）对于（1.2）中找到的所有中位数，调用BFPRT算法求出它们的中位数，作为主元；（2）以（1.3）选取的主元为分界点，把小于主元的放在左边，等于主元的放中间，大于主元的放在右边，返回等于主元的左右边界；（3）判断主元的位置与k的大小，有选择的对左边或右边递归。 下面为代码实现，其所求为前K小的数：注意：在partition()中，需要首先将主元和最左边的元素进行交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution(object): def main(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ return self.bfprt(nums, 0, len(nums)-1, k-1) def bfprt(self, nums, left, right, k): if left &gt;= right: return nums[left] povitValue = self.medianOfMedians(nums, left, right) povitRange = self.partition(nums, left, right, povitValue) # 等于区域的左右边界 if k &gt;= povitRange[0] and k &lt;= povitRange[1]: # k 在左右边界内 直接返回 return nums[k] elif k &lt; povitRange[0]: # k在左边 return self.bfprt(nums, left, povitRange[0]-1, k) else: # k在右边 return self.bfprt(nums, povitRange[1]+1, right, k) def medianOfMedians(self, nums, left, right): len_ = right-left + 1 offset = 0 if len_%5 == 0 else 1 mArr = [0]*(len_//5+offset) for i in range(len(mArr)): left_I = left + i*5 right_I = left_I + 4 mArr[i] = self.getMedian(nums, left_I, min(right, right_I)) return self.bfprt(mArr, 0, len(mArr)-1, len(mArr)//2) def getMedian(self, nums, left, right): for i in range(left+1, right+1): j = i temp = nums[i] while j-1 &gt;= left and nums[j-1] &gt; temp: nums[j] = nums[j-1] j -= 1 nums[j] = temp return nums[(left+right)//2 + (left+right)%2] def partition(self, nums, left, right, povitValue): index = nums.index(povitValue) self.swap(nums, left, index) while left &lt; right: while left &lt; right and nums[right] &gt;= povitValue: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &lt;= povitValue: left += 1 self.swap(nums, left, right) return [left, right] def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = tempif __name__ == '__main__': res = Solution().main([7,6,5,4,3,2,1], 5) print(res) 时间复杂度分析BFPRT算法在最坏情况下的时间复杂度是$O(n)$，下面予以证明。令$T(n)$为所求的时间复杂度，则有： $T(n)≤T(\frac{n}{5})+T(\frac{7n}{10})+c⋅n$ (c为一个正常数) 其中： $T(\frac{n}{5})$来自medianOfMedians()，n个元素，5个一组，共有$\frac{n}{5}$个中位数； $T(\frac{7n}{10})$来自bfprt()，在$\frac{n}{5}$个中位数中，主元x大于其中 $\frac{1}{2}\frac{n}{5} = \frac{n}{10}$的中位数，而每个中位数在其本来的5个数的小组中又大于或等于其中的3个数，所以主元x至少大于所有数中的 $\frac{n}{10}3=\frac{3n}{10}$个。即划分之后，任意一边的长度至少为$\frac{3}{10}$，在最坏情况下，每次选择都选到了$\frac{7}{10}$的那一部分。 $c⋅n$来自其它操作，比如getMedian()中的插入排序，以及medianOfMedians()和partition()里所需的一些额外操作。 设$T(n)=t \cdot n$，其中t为未知，它可以是一个正常数，也可以是一个关于n的函数，代入上式： $t \cdot n \leq \frac{t \cdot n}{5}+\frac{7 t \cdot n}{10}+c \cdot n$ (两边消去n)$t \leq \frac{t}{5}+\frac{7 t}{10}+c$ (再化简)$t \leq \frac{9t}{10}+ c$ (c为一个正常数)$t \leq 10 c$ 其中c为一个正常数，故t也是一个正常数，即$T(n) \leq 10 c \cdot n$ (c为一个正常数)，因此$T(n)=O(n)$，至此证明结束。 例题： leetcode 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路可以使用快排，堆排，归并排序等算法进行解题，但平均复杂度为$O(nlogn)$。 以下代码为使用BFPRT算法解决，复杂度为$O(n)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 return self.bfprt(nums, 0, len(nums)-1, k-1) def bfprt(self, nums, left, right, k): if left &gt;= right: return nums[left] povitValue = self.medianOfMedians(nums, left, right) povitRange = self.partition(nums, left, right, povitValue) # 等于区域的左右边界 if k &gt;= povitRange[0] and k &lt;= povitRange[1]: # k 在左右边界内 直接返回 return nums[k] elif k &lt; povitRange[0]: # k在左边 return self.bfprt(nums, left, povitRange[0]-1, k) else: # k在右边 return self.bfprt(nums, povitRange[1]+1, right, k) def medianOfMedians(self, nums, left, right): len_ = right-left + 1 offset = 0 if len_%5 == 0 else 1 mArr = [0]*(len_//5+offset) for i in range(len(mArr)): left_I = left + i*5 right_I = left_I + 4 mArr[i] = self.getMedian(nums, left_I, min(right, right_I)) return self.bfprt(mArr, 0, len(mArr)-1, len(mArr)//2) def getMedian(self, nums, left, right): self.insertSort(nums, left, right) return nums[(left+right)//2 + (left+right)%2] def partition(self, nums, left, right, povitValue): index = nums.index(povitValue) self.swap(nums, left, index) while left &lt; right: while left &lt; right and nums[right] &lt;= povitValue: right -= 1 self.swap(nums, left, right) while left &lt; right and nums[left] &gt;= povitValue: left += 1 self.swap(nums, left, right) return [left, right] def swap(self, nums, left, right): temp = nums[left] nums[left] = nums[right] nums[right] = temp def insertSort(self, nums, left, right): for i in range(left+1, right+1): j = i temp = nums[i] while j-1 &gt;= left and nums[j-1] &lt; temp: nums[j] = nums[j-1] j -= 1 nums[j] = temp 参考文献：https://en.wikipedia.org/wiki/Median_of_medianshttps://blog.csdn.net/laojiu_/article/details/54986553]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-Manacher算法]]></title>
    <url>%2F2019%2F08%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-Manacher%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[背景给定一个字符串，求出其最长回文子串。例如： s=”abcd”，最长回文长度为 1； s=”ababa”，最长回文长度为 5； s=”abccb”，最长回文长度为 4，即 bccb。 以上问题的传统思路大概是，遍历每一个字符，以该字符为中心向两边查找。其时间复杂度为 $O(n^2)$，效率很差。 1975 年，一个叫 Manacher 的人发明了一个算法，Manacher 算法（中文名：马拉车算法），该算法可以把时间复杂度提升到 $O(n)$。下面来看看马拉车算法是如何工作的。 算法过程由于回文分为偶回文（比如 bccb）和奇回文（比如 bcacb），而在处理奇偶问题上会比较繁琐，所以这里我们使用一个技巧，具体做法是：在字符串首尾，及各字符间各插入一个字符（前提这个字符未出现在串里）。 举个例子：s=&quot;abbahopxpo&quot;，转换为s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;（这里的字符 $ 只是为了防止越界，下面代码会有说明），如此，s 里起初有一个偶回文abba和一个奇回文opxpo，被转换为#a#b#b#a#和#o#p#x#p#o#，长度都转换成了奇数。 定义一个辅助数组int p[]，其中p[i]表示以 i 为中心的最长回文的半径，例如： i 0 1 2 3 4 5 6 7 8 9 10 … s[i] # a # b # b # a # h # … p[i] 1 2 1 2 5 2 1 2 1 2 1 … 可以看出，p[i] - 1正好是原字符串中最长回文串的长度。 接下来的重点就是求解 p 数组，如下图： 设置两个变量，mx 和 id 。mx 代表以 id 为中心的最长回文的右边界，也就是mx = id + p[id]。 假设我们现在求p[i]，也就是以 i 为中心的最长回文半径，如果i &lt; mx，如上图，那么： if (i &lt; mx) p[i] = min(p[2 * id - i], mx - i); 2 * id - i为 i 关于 id 的对称点，即上图的 j 点，而p[j]表示以 j 为中心的最长回文半径，因此我们可以利用p[j]来加快查找。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def manacher(self, s): if len(s) == 0: return 0 s = self.init(s) p = [0] * len(s) id = -1 mx = -1 res = 0 center = 0 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i # id是最右回文子串的中心 return res-1 def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return resif __name__ == '__main__': res = Solution().manacher("cbbd") print(res)` 算法复杂度分析文章开头已经提及，Manacher 算法为线性算法，即使最差情况下其时间复杂度亦为 O(n)O(n)，在进行证明之前，我们还需要更加深入地理解上述算法过程。 根据回文的性质，p[i]的值基于以下三种情况得出： （1）：j 的回文串有一部分在 id 的之外，如下图：上图中，黑线为 id 的回文，i 与 j 关于 id 对称，红线为 j 的回文。那么根据代码此时p[i] = mx - i，即紫线。那么p[i]还可以更大么？答案是不可能！见下图：假设右侧新增的紫色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 d ，也就是说 id 的回文不仅仅是黑线，而是黑线 + 两条紫线，矛盾，所以假设不成立，故p[i] = mx - i，不可以再增加一分。 （2）：j 回文串全部在 id 的内部，如下图：根据代码，此时p[i] = p[j]，那么p[i]还可以更大么？答案亦是不可能！见下图：假设右侧新增的红色部分是p[i]可以增加的部分，那么根据回文的性质，a 等于 b ，也就是说 j 的回文应该再加上 a 和 b ，矛盾，所以假设不成立，故p[i] = p[j]，也不可以再增加一分。 （3）：j 回文串左端正好与 id 的回文串左端重合，见下图：根据代码，此时p[i] = p[j]或p[i] = mx - i，并且p[i]还可以继续增加，所以需要 while (s[i - p[i]] == s[i + p[i]]) p[i]++; 根据（1）（2）（3），很容易推出 Manacher 算法的最坏情况，即为字符串内全是相同字符的时候。在这里我们重点研究 Manacher（）中的 for 语句，推算发现 for 语句内平均访问每个字符 5 次，即时间复杂度为：$T_{worst}(n)=O(n)$。 同理，我们也很容易知道最佳情况下的时间复杂度，即字符串内字符各不相同的时候。推算得平均访问每个字符 4 次，即时间复杂度为：$T_{best}(n)=O(n)$。 综上，Manacher 算法的时间复杂度为 $O(n)$。 例子： leetcode 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。 12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] Manacher算法 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) == 0: return '' s = self.init(s) p = [0] * len(s) id = -1 # 记录最右回文子串的中心 mx = -1 res = 0 maxCenter = 0 # 记录最长回文子串的中心 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if p[i] &gt; res: maxCenter = i res = p[i] return ''.join(s[maxCenter-(res-1):maxCenter+res-1+1].split('#')) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return res` 在字符串后面添加最少字符使成为回文字符串解题思路使用马拉车算法求解，求得最右回文子串，其左边的逆序添加到后面即整体变为回文。添加的长度为最右回文子串的左边部分长度。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def manacher(self, s): if len(s) == 0: return 0 new_s = self.init(s) p = [0] * len(new_s) id = -1 mx = -1 maxContainsEnd = -1 for i in range(len(new_s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(new_s) and i - p[i] &gt; -1: if new_s[i+p[i]] == new_s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if mx == len(new_s): maxContainsEnd = p[i] break return len(s) - (maxContainsEnd -1) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return resif __name__ == '__main__': res = Solution().manacher("abcd123321") print(res) Reference：https://subetter.com/algorithm/manacher-algorithm.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-并查集]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 合并-查找问题什么是合并查找问题呢？顾名思义，就是既有合并又有查找操作的问题。举个例子，有一群人，他们之间有若干好友关系。如果两个人有直接或者间接好友关系，那么我们就说他们在同一个朋友圈中，这里解释下，如果Alice是Bob好友的好友，或者好友的好友的好友等等，即通过若干好友可以认识，那么我们说Alice和Bob是间接好友。随着时间的变化，这群人中有可能会有新的朋友关系，这时候我们会对当中某些人是否在同一朋友圈进行询问。这就是一个典型的合并－查找操作问题，既包含了合并操作，又包含了查找操作。 这个问题很容易想到朴素算法，每个人用一个编号来表示他所在的朋友圈，如果有新认识的朋友，我们就合并朋友圈，即把两人的朋友圈中所有人编号标识成一样。 简单解释一下这个图，刚开始A和B是好友，用蓝色背景标记，C和D是好友，用绿色背景标记，如果询问两个人是否在同一个朋友圈，那么只要看一下他们标记是否相同。过了不久，A和D又成为了好友，我们把两个朋友圈中所有的人标记变成相同的颜色，这就完成了一次合并的操作。 我们来粗略的计算下复杂度，假设我们要合并Alice和Bob的朋友圈，需要找到所有和Bob在同一朋友圈里的人，并标记为Alice所在的朋友圈。代码如下 12345# group[i]表示i所在的朋友圈编号# 将朋友圈B合并到朋友圈A中for i in range(n): if group[i] == group[B]: group[i] = group[A] 合并代码非常简单，那么可以看到一次合并的复杂度为$O(n)$，一共有n个人，因此最多可能要合并$n-1$次，合并的复杂度为$n^2$，加上Q个朋友圈询问，那么总的复杂度就是$O(n^2+Q)$。当n很大的时候，算法是不可接受的。 并查集这个时候我们就希望重新设计一种数据结构，能够高效的处理这三种操作，分别是 MAKE-SET(x)，创建一个只有元素x的集合，且x不应出现在其他的集合中 UNION(x, y)，将元素x所在集合Sx和元素y所在的集合Sy合并，这里我们假定Sx不等于Sy FIND-SET(x)，查找元素x所在集合的代表 现在我们再来看一下刚刚那道题，起初每个人都互相不认识，我们可以调用n次MAKE-SET来创建n个集合，当有两个人互相认识的时候，那么我们用UNION来合并两个集合。最后，如果询问x和y是否在同一个朋友圈的时候，我们调用两次FIND-SET来判断x和y所在集合的代表是否相同，从而判断他们是否在同一个集合内。 这个时候就该并查集出场了，它能够高效的处理前面提到的三种操作，用于维护一系列不相交集合动态操作的数据结构。每个不相交集合都有一个代表用于表示整个集合，并且这个代表也是集合内的成员。下面来说一下并查集是如何工作的。在并查集中，每个不相交的集合都用一颗有根树来表示，每个元素都是树上的一个节点，我们继续用刚刚的朋友圈问题来解释。 我们来解释下这个图，起初有5个人，编号为1-5，刚开始大家都互不认识，所以各自为一个节点的树。这时候如果1和2认识了，那么我们就把这两个节点所代表的树合并起来，由编号较小的1作为根。接着3和4又认识了，那么我们重复刚刚的过程，把3和4所代表树合并起来。现在1和4认识了，该怎么办呢，首先我们先找到1和4所在树的根，1的根就是1，而4的根就是3，这时候我们把这两颗树合并，并把1设置为3的父亲节点，这时候就完成了两颗树的合并。在这系列操作中，初始化构建树就是MAKE-SET操作，树的合并就是UNION操作，而找根的过程就是FIND-SET操作。 下面讲一讲并查集的具体实现。对于有根树或者说森林的表示，可以用一个数组parent来实现。parent[i]记录元素i的父节点的编号，如果节点i本身就是根节点，那么parent[i]就是-1。MAKE-SET操作就是将parent数组赋值为-1。123def MAKE_SET(self, arr): parent = [-1]*len(arr) return parent UNION操作需要找到两个元素的根，并把其中一个元素的根节点设置为另一个元素的根节点，其实就是调用了两次FIND-SET，代码如下12345678# 将y所在的集合合并到x所在的集合中# 分别查找出x和y所在集合的根节点# 将y元素所在的集合的代表节点的根节点设置为x所在集合的根节点def union(self, x, y): px = find_set(x) py = find_set(y) if px != py: parent[py] = px 再来说下FIND-SET这个操作的实现。首先有个很朴素的算法，对父节点递归调用FIND-SET，直到找到根为止。如果父节点是-1，那么返回当前节点，否则递归调用查询父亲的根节点。代码如下12345# 递归查找x所在集合的根节点def find_set(self, x): if parent[x] == -1: return x return find_set(parent[x]) 但是，如果我们这棵树很深，那么每次调用FIND-SET可能会需要O(n)的时间。 这时候，我们就要引入路径压缩这个概念。什么是路径压缩呢？就是在递归找到根节点的时候，把当前节点到根节点间所有节点的父节点都设置为根节点。举个例子 我们来看下图，首先我们有个这样的一棵树，现在要找到元素9所在树的根节点，在找根节点的过程中使用路径压缩，也就是说9到根的路径上的节点9，6，3，1的父节点都设置成为根节点0，所以呢，在FIND-SET(9)之后，树的形态就变成了下面的样子 我们可以看到经过路径压缩的节点及其子树到根节点的深度减小了很多，所以在以后的操作中，查找根节点的速度会快很多，平摊下来每次FIND-SET的操作几乎是常数级别的。代码也相当简单，就只多了一句话123456# 带有路径压缩的并查集def find_set(self, x): if parent[x] == -1: return x parent[x] = find_set(parent[x]) return parent[x] 刚刚在合并的过程中，并没有提到说到如何选取根，一般情况下两个根节点随意选取一个，如果需要更优的算法，可以按秩合并，就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。 12345678910111213141516171819# 初始化根节点为-1# 初始化各集合大小为1def MAKE_SET(self, arr): parent = [-1] * len(arr) sizeMap = [1] * len(arr) return parentdef union(self, x, y): px = find_set(x) py = find_set(y) if px != py: xSize = sizeMap[px] ySize = sizeMap[py] if xSize &lt;= ySize: parent[px] = py sizeMap[py] = xSize + ySize else: parent[py] = px sizeMap[px] = xSize + ySize 并查集是一种支持合并集合和查找集合的一种数据结构，能用均摊线性的复杂度执行各种操作，在kruskal算法、求联通分支数等算法中起到关键的作用。 总结为了表示一个元素所属的集合，我们从一个集合当中挑选出一个代表元素作为根节点。对于每个元素，都记录一下它对应的根节点是谁，这样就可以通过根节点来表示它所述的集合。在集合合并时，如果对一个小集合中的所有元素都修改其根节点，则会造成合并的开销过大。为了减小开销，我们在合并时采取层次化的结构，按照按秩合并的方法，可以使合并操作的复杂度降为O(1)，但是这在减少合并开销的同时又增加了查询开销，使得总开销并没有降低。为了进一步减少查询开销，引入了路径压缩这个操作，使得长路径上的检索只需要发生一次。 参考文献：https://mp.weixin.qq.com/s/50QN956P6Udpo4AKlWfeewhttps://zhuanlan.zhihu.com/p/54567565https://zhuanlan.zhihu.com/p/54727138]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-一致性哈希]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 一、Redis集群的使用我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示： 同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。 假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下： 由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。 二、为Redis集群使用Hash可想而知，如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如下： 上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！ 三、使用Hash的问题上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！ 试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了hash(a.png) % 5 = ？ ， 可想而知这个结果肯定不是2的，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的《缓存雪崩》吗？）！ 同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！ 所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！ 四、一致性Hash算法的神秘面纱一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下： 整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1，也就是说0点左侧的第一个点代表2^32-1， 0和2^32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。 下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下： 接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！ 例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下： 根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 五、一致性Hash算法的容错性和可扩展性现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如下所示： 下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示： 此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。 六、Hash环的数据倾斜问题一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下： 此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。 例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点： 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。 注意：上图有些误导性，实际上要把NodeA#1, NodeA#2, NodeA#3, NodeB#1, NodeB#2, NodeB#3打乱。 七、总结上文中，我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！ 原文链接：https://zhuanlan.zhihu.com/p/34985026感谢原作者的辛勤付出！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 哈希表]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 散列表散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。即:存储位置=f(关键字)采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称为散列表或哈希表，关键字对应的记录存储位置称为散列地址。散列技术既是一种存储方法，也是一种查找方法。它也线性表、树、图等结构不同的是，前面几种结构，数据元素之间都存在某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字关联。因此，散列主要是面向查找的存储结构，适合求解的问题是查找与给定值相等的记录。 1.1 散列冲突每个关键字 $key1 \not= key2$，但却有$f(key1) = f(key2)$，这种现象称为冲突，并把key1和key2称为这个散列函数的同义词。出现了冲突当然非常糟糕，那将造成数 据查找错误。 2 散列函数的构造方法2.1 构造原则 计算简单。散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。 散列地址分布均匀。尽量让散列地址均匀地分布在存储空间中，保证存储空间的有效利用，并减少为处理冲突而耗费的时间。 2.2 构造方法2.2.1 直接定址法取关键字的某个线性函数值为散列函数，即：$f(key) = a * key + b$，（a、b为常数） 优点是简单、均匀、不会产生冲突 缺点是需要首先知道关键字的分布情况，适合查找表较小且连续的情况 2.2.2 数字分析法基于抽取的方法，即使用关键字的一部分来计算散列存储位置的方法。适合处理关键字位数比较大的情况，如果事先知道关键字的分布 且关键字的若干位分布较均匀，就可以考虑用这个方法。 2.2.3 平均取中法先对关键字求平方，在抽取中间的k位作为散列地址。比如关键字是 1234， 那么它的平方就是 1522756，再抽取中间的 3 位就是 227 ，用做散列地址。适合于不知道关键字的分布，且位数不是很大的情况。 2.2.4 折叠法将关键字从左到右分割成位数相等的几部分(注意最后一部分位数不够 时可以短些) ，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如我们的关键字是 9876543210 ，散列表表长为三位，我们将它分为四组， 9871654132110， 然后将它们叠加求和987+654+321+0=1962，再求后 3 位得到散列 地址为 962。有时可能这还不能够保证分布均匀 ， 不妨从一端向另一端来回折叠后对齐相加。 比如我们将 987 和 321 反转，再与 654 和 0 相加， 变成 789+654+123+0=1566，此时散列地址为 566.折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。 2.2.5 除留余数法对于散列表长为m的散列函数公式为：$f(key) = key mod p, (p \leq m)$不仅可以对关键字直接取模，还可在折叠、平方取中后再取模。 2.2.6 随机数法选择一个随机数，取关键字的随机函数值为它的散列地址。即：$f (key) =random (key)$这里 random 是随机函数。当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 3 散列冲突的处理方法3.1 开放定址法 (线性探测法)一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。公式为：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1,2,3,…,m-1)$ 堆积：两个关键字同时争夺同一个地址。此时需要不断处理冲突，降低存入和查找的效率。 解决方法1：二次探测法，增加平方运算使关键字尽可能分散。即：$f_i (key) = (f(key) + d_i) mod m, (d_i = 1^2, -1^2, 2^2, -2^2 ,…,q^2, -q^2, q \leq m/2)$ 解决方法2：随机探测法，在冲突时，对于位移量 $d_i$，采用随机函数计算得到。即：$f_i (key) = (f(key) + d_i) mod m, d_i )$是一个随机数列 3.2 再散列函数法换一个不同的函数重新计算散列地址。$f_i (key) = RH_i(key), i=1,2,…,ki )$$RH_i$为不同的散列函数，如除留余数、折叠、平方取中等。 3.3 链地址法不存在冲突换址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。但带来了查找时需要遍历单链装的性能损耗。 3.4 公共溢出区法为所有冲突的关键字建立一个公共的溢出区来存放。查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对， 如果相等，则查找成功； 如果不相等，则到溢出表去进顺序查找； 如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。 4 散列表查找性能时间复杂度为O(1)。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-布隆过滤器]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 布隆过滤器背景虽然位图可以节省空间，但是数据量大的时候需要的内存还是比较大的。布隆过滤器就是为了解决这个问题，对位图数据结构的一种改进。 举例：考虑数据个数是1千万，数字范围是1到10亿，使用位图需要10亿个二进制位，而布隆过滤器的做法是，使用一个1亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这1到1亿范围内。比如我们把哈希函数设计成 $f(x)=x%n$。其中，x表示数字，n表示位图的大小（1亿），也就是，对数字跟位图的大小进行取模求余。 这时哈希函数会存在冲突的问题啊，一亿零一和1两个数字，经过你刚刚那个取模求余的哈希函数处理之后，最后的结果都是1。这样我就无法区分，位图存储的是1还是一亿零一了。如何降低冲突的概率？用K个哈希函数！！ 布隆过滤器定义布隆过滤器是一种空间效率很高的随机数据结构，它的原理是当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位阵列（Bit array）中的K个点，将它们置为1。检索时，我们只要看看这些点是不是都是1就大约知道集合中有没有它了：如果这些点有任何一个点为0，则被检索元素一定不在；如果都是1，则被检索元素很可能在。这就是布隆过滤器的基本思想。 但布隆过滤器的这种高效是有代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom filter不适合那些“零错误”的应用场合。而在能容忍低错误率的场景下，布隆过滤器通过极少的错误换取了存储空间的极大节省。 布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。 集合表示和元素查询具体来看Bloom Filter是如何用位数组表示集合的。初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0。 为了表达$ \mathrm{S}=\left\{\mathrm{x}_{1}, \mathrm{x}_{2}, \ldots, \mathrm{x}_{\mathrm{n}}\right\} $这样一个$n$个元素的集合，Bloom Filter使用$k$个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到$\{1,…,m\}$的范围中。对任意一个元素$x$，第$i$个哈希函数映射的位置$h_i(x)$就会被置为1（$1≤i≤k$）。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位，即第二个“1“处）。 在判断y是否属于这个集合时，我们对y应用k次哈希函数，如果所有$h_i(y)$的位置都是1（1≤i≤k），那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中$y_1$就不是集合中的元素（因为$y_1$有一处指向了“0”位）。$y_2$或者属于这个集合，或者刚好是一个false positive。 位数组大小对于给定的p（误判率）和将要加入集合的元素个数n，位数组大小m由如下公式定义： m=-\frac{n \cdot \ln p}{(\ln 2)^{2}}最优的哈希函数个数对于给定的位数组大小m和将要加入集合的元素个数n，使得误判率最小的哈希函数个数k通过如下公式定义： k=\frac{m}{n} \ln 2 \approx 0.7 \cdot \frac{m}{n}误判率估计对于给定的位数组大小m，将要加入集合的元素个数n，及哈希函数个数k，误判率可以重新计算为： p=\left(1-\mathrm{e}^{-k n / m}\right)^{k}应用在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。Bloom Filter在时间空间这两个因素之外又引入了另一个因素：错误率。在使用Bloom Filter判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（False Positive），但不会把属于这个集合的元素误认为不属于这个集合（False Negative）。在增加了错误率这个因素之后，Bloom Filter通过允许少量的错误来节省大量的存储空间。 Bloom Filter就被广泛用于拼写检查和数据库系统中。 也可以用来实现数据字典，进行数据的判重，或者集合求交集 。 参考文献：https://blog.csdn.net/v_july_v/article/details/6685894https://blog.csdn.net/jiaomeng/article/details/1495500https://blog.csdn.net/tick_tock97/article/details/78688159]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-跳表]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 跳表跳表(SkipList)：增加了向前指针的链表叫做跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质是一种可以进行二分查找的有序链表。跳表在原有的有序链表上增加了多级索引，通过索引来实现快速查询。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。 跳表是redis的一个核心组件，也同时被广泛地运用到了各种缓存地实现当中，它的主要优点，就是可以跟红黑树、AVL等平衡树一样，做到比较稳定地插入、查询与删除。理论插入查询删除的算法时间复杂度为O(logN)。 有序表的搜索背景：考虑一个有序表，我们要查找其中的元素，我们只能从头开始遍历链表，直到查找到元素为止。链表是有序的，但是不能使用二分查找，是不是很捉急？（P.S.数组可以实现二分查找）那么，有没有什么方法可以实现有序链表的二分查找呢？答案是肯定的，那就是我们将要介绍的这种数据结构——跳表。 从该有序表中搜索元素 &lt; 23, 43, 59 &gt; ，需要比较的次数分别为 &lt; 2, 4, 6 &gt;，总共比较的次数为 2 + 4 + 6 = 12 次。有没有优化的算法吗? 链表是有序的，但不能使用二分查找。类似二叉搜索树，我们把一些节点提取出来，作为索引。得到如下结构： 这里我们把 &lt; 14, 34, 50, 72 &gt; 提取出来作为一级索引，这样搜索的时候就可以减少比较次数了。我们还可以再从一级索引提取一些元素出来，作为二级索引，变成如下结构： 这里元素不多，体现不出优势，如果元素足够多，这种索引结构就能体现出优势来了。 跳表的结构下面的结构是就是跳表：其中 -1 表示 INT_MIN， 链表的最小值，1 表示 INT_MAX，链表的最大值。 跳表的性质(1) 由很多层结构组成(2) 每一层都是一个有序的链表(3) 最底层(Level 1)的链表包含所有元素(4) 如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现。(5) 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。 跳表的搜索 例子：查找元素 117(1) 比较 21， 比 21 大，往后面找(2) 比较 37, 比 37大，比链表最大值小，从 37 的下面一层开始找(3) 比较 71, 比 71 大，比链表最大值小，从 71 的下面一层开始找(4) 比较 85， 比 85 大，从后面找(5) 比较 117， 等于 117， 找到了节点。 具体的搜索算法如下，C代码12345678910111213/* 如果存在 x, 返回 x 所在的节点， * 否则返回 x 的后继节点 */ find(x) &#123; p = top; while (1) &#123; while (p-&gt;next-&gt;key &lt; x) p = p-&gt;next; if (p-&gt;down == NULL) return p-&gt;next; p = p-&gt;down; &#125; &#125; 跳表的插入先确定该元素要占据的层数 K（采用丢硬币的方式，这完全是随机的）然后在 Level 1 … Level K 各个层的链表都插入元素。例子：插入 119， K = 2 如果 K 大于链表的层数，则要添加新的层。例子：插入 119， K = 4 丢硬币决定 K插入元素的时候，元素所占有的层数完全是随机的，通过一下随机算法产生：1234567int random_level() &#123; K = 1; while (random(0,1)) K++; return K; &#125; 相当与做一次丢硬币的实验，如果遇到正面，继续丢，遇到反面，则停止，用实验中丢硬币的次数 K 作为元素占有的层数。显然随机变量 K 满足参数为 $p = 1/2$ 的几何分布，K 的期望值 $E[K] = 1/p = 2$. 就是说，各个元素的层数，期望值是 2 层。 跳表的复杂度在跳表中每两个结点都会抽出一个结点作为上一级索引的结点。如果链表里有n个结点，那么第一级索引的个数大约就是n/2，第二级的索引大约就是n/4，第三级的索引就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那么第k级的索引结点个数为：$\frac{n}{2^k}$。如果最高级索引有 2 个结点，即$\frac{n}{2^k}=2$，那总的索引级数 $k=log_2n−1$，如果我们算上原始链表的话，那也就是跳表的高度为$log_2n$级。 在第 k 级索引中，假设我们要查找的数据为 x，当我们查找到 y 结点时，发现 $y&lt;x&lt;z $时此时我们就要下降到 k−1 级索引继续查找。在第 k−1 级索引中，y 和 z 之间只有三个结点，因此，我们最多只需要查找 3 个结点。以此类推，每一级的索引最多都只需要遍历 3 个结点。 而总的级别数为 $log_2n$，因此查找的时间复杂度就为 $3∗log_2n=logn$。跳表查找的时间复杂度和二分查找一样，但这其实是以空间来换时间的设计思路。 跳表的所有额外索引结点总数为 $\frac{n}{2} + \frac{n}{4} + \frac{n}{8} + … + 4 + 2 = n-2$，所以跳表的空间复杂度为$O(n)$。 跳表的删除在各个层中找到包含 x 的节点，使用标准的 delete from list 方法删除该节点。例子：删除 71 跳表的应用Redis中的有序集合使用跳表。Redis 中的有序集合支持的核心操作主要有以下几个： 插入一个数据 删除一个数据 查找一个数据 按照区间查找数据 迭代输出有序序列 其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度和跳表是一样的。 但是，按照区间查找数据这个操作，红黑树的效率没有跳表高。跳表可以在 O(logn) 时间复杂度定位区间的起点，然后在原始链表中顺序向后查询就可以了，这样非常高效。 此外，相比于红黑树，跳表还具有代码更容易实现、可读性好、不容易出错、更加灵活等优点，因此 Redis 用跳表来实现有序集合。 参考文献：SkipList 跳表数据结构和算法之——跳表]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解-数据库]]></title>
    <url>%2F2019%2F07%2F18%2FLeetCode%2FLeetcode-%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[175. 组合两个表题目描述表1: Person12345678+-------------+---------+| 列名 | 类型 |+-------------+---------+| PersonId | int || FirstName | varchar || LastName | varchar |+-------------+---------+PersonId 是上表主键 表2: Address123456789+-------------+---------+| 列名 | 类型 |+-------------+---------+| AddressId | int || PersonId | int || City | varchar || State | varchar |+-------------+---------+AddressId 是上表主键 编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供?person 的以下信息： 1FirstName, LastName, City, State 解题思路123select p.FirstName, p.LastName, a.City, a.Statefrom Person as p left join Address as aon p.PersonId = a.PersonId; 176. 第二高的薪水题目描述编写一个 SQL 查询，获取 Employee?表中第二高的薪水（Salary）?。1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述?Employee?表，SQL查询应该返回?200 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 null。12345+---------------------+| SecondHighestSalary |+---------------------+| 200 |+---------------------+ 解题思路直接select无法输出第二高薪水为空的情况。1select distinct salary as SecondHighestSalary from Employee order by salary desc limit 1, 1; 在外面加一层select，可以将空的赋值给SecondHighestSalary。1select(select distinct salary from Employee order by salary desc limit 1, 1) as SecondHighestSalary; 177. 第N高的薪水题目描述编写一个 SQL 查询，获取 Employee 表中第?n?高的薪水（Salary）。1234567+----+--------+| Id | Salary |+----+--------+| 1 | 100 || 2 | 200 || 3 | 300 |+----+--------+ 例如上述?Employee?表，n = 2?时，应返回第二高的薪水?200。如果不存在第?n?高的薪水，那么查询应返回?null。12345+------------------------+| getNthHighestSalary(2) |+------------------------+| 200 |+------------------------+ 解题思路123456789CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN SET N = N-1; RETURN ( # Write your MySQL query statement below. select distinct ifnull(salary, null) from Employee order by salary desc limit N, 1 ); END 178. 分数排名题目描述编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。12345678910+----+-------+| Id | Score |+----+-------+| 1 | 3.50 || 2 | 3.65 || 3 | 4.00 || 4 | 3.85 || 5 | 4.00 || 6 | 3.65 |+----+-------+ 例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：12345678910+-------+------+| Score | Rank |+-------+------+| 4.00 | 1 || 4.00 | 1 || 3.85 | 2 || 3.65 | 3 || 3.65 | 3 || 3.50 | 4 |+-------+------+ 解题思路12345# Write your MySQL query statement belowselect p1.Score as Score,(select Count(distinct p2.score) from Scores as p2 where p2.score &gt;= p1.score) as Rankfrom Scores as p1order by Score desc; 180. 连续出现的数字题目描述编写一个 SQL 查询，查找所有至少连续出现三次的数字。1234567891011+----+-----+| Id | Num |+----+-----+| 1 | 1 || 2 | 1 || 3 | 1 || 4 | 2 || 5 | 1 || 6 | 2 || 7 | 2 |+----+-----+ 例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。12345+-----------------+| ConsecutiveNums |+-----------------+| 1 |+-----------------+ 解题思路1234# Write your MySQL query statement belowselect distinct l1.Num as ConsecutiveNumsfrom Logs l1, Logs l2, Logs l3where l1.num = l2.num and l2.num = l3.Num and l2.Id = l1.Id+1 and l3.Id = l2.id+1 181. 超过经理收入的员工题目描述Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。12345678+----+-------+--------+-----------+| Id | Name | Salary | ManagerId |+----+-------+--------+-----------+| 1 | Joe | 70000 | 3 || 2 | Henry | 80000 | 4 || 3 | Sam | 60000 | NULL || 4 | Max | 90000 | NULL |+----+-------+--------+-----------+ 给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。12345+----------+| Employee |+----------+| Joe |+----------+ 解题思路1234# Write your MySQL query statement belowselect e1.Name as Employee from Employee e1, Employee e2where e1.ManagerId = e2.Id and e1.salary &gt; e2.salary 182. 查找重复的电子邮箱题目描述编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。 示例：1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果：12345+---------+| Email |+---------+| a@b.com |+---------+ 说明：所有电子邮箱都是小写字母。 解题思路123# Write your MySQL query statement belowselect Email from Person group by Email having count(ID)&gt;1 123# Write your MySQL query statement belowselect distinct p1.Email from Person p1, Person p2 where p1.Email = p2.Email and p1.Id != p2.Id 183. 从不订购的客户题目描述某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。 Customers 表：12345678+----+-------+| Id | Name |+----+-------+| 1 | Joe || 2 | Henry || 3 | Sam || 4 | Max |+----+-------+ Orders 表：123456+----+------------+| Id | CustomerId |+----+------------+| 1 | 3 || 2 | 1 |+----+------------+ 例如给定上述表格，你的查询应返回：123456+-----------+| Customers |+-----------+| Henry || Max |+-----------+ 解题思路1234# Write your MySQL query statement belowselect c.Name as Customers from Customers c left join Orders o on c.Id = o.CustomerId where o.id is null 123# Write your MySQL query statement belowselect Name as Customers from Customers where Id not in (select CustomerId from Orders) 184. 部门工资最高的员工题目描述Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。12345678+----+-------+--------+--------------+| Id | Name | Salary | DepartmentId |+----+-------+--------+--------------+| 1 | Joe | 70000 | 1 || 2 | Henry | 80000 | 2 || 3 | Sam | 60000 | 2 || 4 | Max | 90000 | 1 |+----+-------+--------+--------------+ Department 表包含公司所有部门的信息。123456+----+----------+| Id | Name |+----+----------+| 1 | IT || 2 | Sales |+----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。123456+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT | Max | 90000 || Sales | Henry | 80000 |+------------+----------+--------+ 解题思路12345678# Write your MySQL query statement belowselect d.Name as Department, e.Name as Employee, e.Salaryfrom Employee as e,Department as d,(select DepartmentId, max(Salary) as max from Employee group by DepartmentId) as mwhere e.DepartmentId = m.DepartmentIdand e.Salary = m.maxand e.DepartmentId = d.Id]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 贪心算法]]></title>
    <url>%2F2019%2F07%2F18%2FLeetCode%2FLeetcode-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是贪心算法相关题目题解总结。 [TOC] 贪心思想概念 最优子结构：最优子结构反映了分解问题的方式，我们在解决问题的时候，都会尝试将问题分解进行解决，产生的子问题，进而会产生局部解（总体解的子结构）。通常而言局部解也不仅只有一个，当局部解是局部最优解，并且该局部最优解是全局最优解的一部分时，我们称子问题的最优解为最优子结构。 最优子结构的性质：问题的最优解由相关自问题的最优解组合而成，而这些子问题可以独立求解。（需要注意这里独立求解的含义：当前最优，不考虑后面的步骤）；最优子结构的形式（或者是否有最优子结构）取决于你分解问题的方式。合理的分解达到的效果是：与最终问题的目标存在紧密的关系。如果分解问题之后却无法导出最终问题的解，那么这种问题分解的方式就是无意义的。 基本思想 贪心算法的基本思想是找出整体当中每个小的局部的最优解，并且将所有的这些局部最优解合起来形成整体上的一个最优解。因此能够使用贪心算法的问题必须满足下面的两个性质： 整体的最优解可以通过局部的最优解来求出； 一个整体能够被分为多个局部，并且这些局部都能够求出最优解。使用贪心算法当中的两个典型问题是活动安排问题和背包问题。 主要步骤 建立对问题精确描述的数学模型，包括定义最优解的模型； 将问题分解为一系列子问题，同时定义子问题的最优解结构； 应用贪心原则确定每个子问题的局部最优解，并根据最优解的模型，用子问题的局部最优解堆叠出全局最优解。 0.1 拼接所有字符串产生字典顺序最小的字符串123456789101112class Solution: def lowerString(self, strs): for i in range(len(strs)): for j in range(i+1, len(strs)): if strs[i] + strs[j] &gt; strs[j] + strs[i]: strs[i], strs[j] = strs[j], strs[i] return ''.join(strs)if __name__ == '__main__': res = Solution().lowerString(['b','ba','abc']) print(res) 0.2 分金条一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。一群人想整分整块金 条，怎么分最省铜板？ 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60. 金条要分成10,20,30三个部分。 如果， 先把长度60的金条分成10和50，花费60 再把长度50的金条分成20和30，花费50 一共花费110铜板。但是如果， 先把长度60的金条分成30和30，花费60 再把长度30金条分成10和20，花费30 一共花费90铜板。 输入一个数组，返回分割的最小代价 123456789101112131415161718from heapq import *class Solution: def gold(self, nums): heap = [] for x in nums : heappush(heap, x) res = 0 while len(heap) &gt; 1: cur = heappop(heap) + heappop(heap) res += cur heappush(heap, cur) return resif __name__ == '__main__': res = Solution().gold([10,20,30]) print(res) 0.3 IPO解题思路以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:12345678910输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意: 假设所有输入数字都是非负整数。表示利润和资本的数组的长度不超过 50000。答案保证在 32 位有符号整数范围内。 解题思路用两个堆。所有项目进入按照启动资金进小根堆。每一次做项目时，先将当前资本能做的项目从小根堆中弹出，进入大根堆，大根堆按照最大利润组织，然后从大根堆中弹出利润最大的项目，将所得利润加到资本中。这样可以保证每次先做当前资本所有能做的项目中利润最大的项目。 1234567891011121314151617181920212223242526272829from heapq import *class Solution(object): def findMaximizedCapital(self, k, W, Profits, Capital): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ minCHeap = [] # 项目启动资金的小根堆 for i in range(len(Profits)): heappush(minCHeap, [Capital[i], Profits[i]]) # 资本大于项目启动资金的所有项目按利润大根堆 maxPHeap = [] while k &gt; 0: while minCHeap and W &gt;= minCHeap[0][0]: pair = heappop(minCHeap) heappush(maxPHeap, -pair[1]) if maxPHeap: W += -heappop(maxPHeap) k -= 1 return W` 0.4 最多的会议场数一些项目要占用一个会议室宣讲， 会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间(给你一个数组， 里面 是一个个具体的项目)，你来安排宣讲的日程， 要求会议室进行 的宣讲的场次最多。返回这个最多的宣讲场次。输入：n 代表有n个会议需要安排之后的 n 行，每行有两个数子，代表会议的开始和结束的时间 思路：我们只需要按照会议结束的时间进行排序，然后依次安排，就能够安排最多的场数 123456789101112131415161718192021222324252627282930313233343536373839class Meeting(object): def __init__(self, start, end): self.start = start self.end = endclass Solution(object): def Main (self): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ n = int(input()) # 按结束时间排序 meeting = [None]*n for i in range(n): pair = [int(x) for x in input().split()] meeting[i] = Meeting(pair[0], pair[1]) meeting = sorted(meeting, key = lambda x:x.end) res = 1 lastEnd = meeting[0].end for i in range(len(meeting)): if meeting[i].start &lt; lastEnd: continue res += 1 lastEnd = meeting[i].end return resif __name__ == '__main__': res = Solution().Main () print(res)` 45. 跳跃游戏 II题目描述给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。示例:1234输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 解题思路需要知道每一步能跳的范围，然后遍历这个范围，根据该位置上的跳力来预测下一步能跳到的最远范围，贪的是一个能达到的最远范围。一旦这个范围达到了末尾，则返回。cur表示当前能达到的最远位置，初始为0pre表示之前能达到的最远位置，初始为0在每一次循环中， pre = cur，表示上一次循环后能达到的最远位置，在范围内求解当前位置能达到的最远距离cur。 1234567891011121314151617181920212223class Solution(object): def jump(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 res = 0 cur = 0 i = 0 while cur &lt; len(nums) - 1: res += 1 pre = cur while i &lt; pre+1: cur = max(cur, i+nums[i]) if cur &gt;= len(nums)-1: return res i += 1 return res` 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路设置最大和maxsub = nums[0]，中间和temp = 0；遍历数组加到temp中，若temp &gt; maxsub，则更新最大和maxsun；若temp &lt; 0，则置为0从新开始。 1234567891011121314151617class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 maxsub = nums[0] temp = 0 for i in range(len(nums)): temp += nums[i] if temp &gt; maxsub: maxsub = temp if temp &lt; 0: temp = 0 return maxsub 55. 跳跃游戏题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1:123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2:123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解题思路贪心。使用一个变量保存当前能到达的最后位置的索引，向后遍历每个位置，如果该位置大于前面能到达的最大位置，则返回False，如果这个位置可以达到，则更新能达到的最后位置索引，更新策略是当前位置索引+这个数字能走多少步和原来能到的最大值。12345678910111213141516class Solution(object): def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 0: return True reach = 0 for i in range(len(nums)): if i &gt; reach: return False reach = max(reach, i+nums[i]) return True 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对数组进行遍历，定义到目前为止最大利润maxsum和加上当前利润的中间利润temp； 如果temp&gt;maxsum，则到目前最大利润maxsum = temp； 如果temp小于0，舍弃，temp = 0。 1234567891011121314151617class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxsum = 0 temp = 0 for i in range(1,len(prices)): temp += prices[i] - prices[i-1] if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路 对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ； 因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中，从而在局部最优的情况下也保证全局最优。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxp = 0 for i in range(1,len(prices)): if prices[i] &gt; prices[i-1]: maxp += prices[i] - prices[i-1] return maxp 134. 加油站题目描述在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 说明: 如果题目有解，该答案即为唯一答案。 输入数组均为非空数组，且长度相同。 输入数组中的元素均为非负数。 示例 1:1234567891011121314输入: gas = [1,2,3,4,5]cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。 示例 2:12345678910111213输入: gas = [2,3,4]cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。 解题思路12345678910111213141516171819202122class Solution(object): def canCompleteCircuit(self, gas, cost): """ :type gas: List[int] :type cost: List[int] :rtype: int """ if len(gas) != len(cost) or len(gas) == 0: return -1 start = 0 rest = 0 overall = 0 for i in range(len(gas)): rest += gas[i]-cost[i] overall += gas[i]-cost[i] if rest &lt; 0: rest = 0 start = i+1 return start if overall &gt;= 0 else -1 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: s = “abc”, t = “ahbgdc”返回 true. 示例 2: s = “axc”, t = “ahbgdc”返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路双指针，遍历两个序列。 1234567891011121314151617181920class Solution(object): def isSubsequence(self, s, t): """ :type s: str :type t: str :rtype: bool """ if not s: return True if not t or len(s) &gt; len(t): return False i = j = 0 while i &lt; len(s) and j &lt; len(t): if s[i] == t[j]: i += 1 j += 1 return i == len(s)if __name__ == '__main__': result = Solution().isSubsequence("ace","abcde") print(result) 406. 根据身高重建队列题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意： 总人数少于1100人。 示例 输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 解题思路 对people进行排序，h越大k越小的在前； 然后按顺序给个高的先排序，因为个高的排好后，再怎么对矮个排序，都不会影响个高人的相对位置。 12345678910111213class Solution(object): def reconstructQueue(self, people): """ :type people: List[List[int]] :rtype: List[List[int]] """ if len(people) &lt;= 1: return people people.sort(key = lambda x:[-x[0],x[1]]) res = [] for i in range(len(people)): res.insert(people[i][1],people[i]) return res 435. 无重叠区间题目描述给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 注意: 可以认为区间的终点总是大于它的起点。区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。 示例 1: 输入: [ [1,2], [2,3], [3,4], [1,3] ]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 解题思路区间题目一般按照排序+贪心去求解： 先将区间按照起点升序； 令第一个区间为起始老区间，然后从第二个起进行遍历，如果遍历到的区间的起点比老区间的终点小，说明有重叠； 此时计数并移除区间，移除的为终点大的区间，即将老区间设置为终点小的区间； 如果没有重叠，则更新老区间为当前遍历到的区间。 12345678910111213141516171819202122232425# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def eraseOverlapIntervals(self, intervals): """ :type intervals: List[Interval] :rtype: int """ if len(intervals) &lt;= 1: return 0 intervals = sorted(intervals, key = lambda interval:interval.start) last = 0 count = 0 for i in range(1,len(intervals)): if intervals[i].start &lt; intervals[last].end: count += 1 if intervals[i].end &lt;intervals[last].end: last = i else: last = i return count 452. 用最少数量的箭引爆气球题目描述在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 Example: 输入:[[10,16], [2,8], [1,6], [7,12]]输出:2解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 解题思路 使用排序+贪心。把所有坐标按照右边界进行排序，因为每个气球都要被打破，初始当前最远的位置curr_pos为第一个坐标的右边界，对坐标进行遍历； 如果当前遍历到的坐标左边界小于curr_pos，则说明有重叠，继续； 否则说明没有重叠，修改curr_pos为当前坐标的右边界，计数加1。 1234567891011121314151617181920class Solution(object): def findMinArrowShots(self, points): """ :type points: List[List[int]] :rtype: int """ if not points: return 0 points.sort(key=lambda x: x[1]) curr_pos = points[0][1] ans = 1 for i in range(len(points)): if curr_pos &gt;= points[i][0]: continue curr_pos = points[i][1] ans += 1 return ansif __name__ == '__main__': result = Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) print(result) 455. 分发饼干题目描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 注意： 你可以假设胃口值为正。一个小朋友最多只能拥有一块饼干。 示例 1: 输入: [1,2,3], [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 示例 2: 输入: [1,2], [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2. 解题思路对孩子胃口值g和饼干尺寸s排序，先用最小的饼干满足最小胃口值的孩子，如果最小饼干满足不了最小胃口值的孩子，则加大饼干值去满足该孩子。 1234567891011121314151617181920class Solution(object): def findContentChildren(self, g, s): """ :type g: List[int] :type s: List[int] :rtype: int """ if len(g)==0 or len(s)==0: return 0 g.sort() s.sort() child = i = 0 while child &lt; len(g) and i &lt; len(s): if s[i] &gt;= g[child]: child += 1 i += 1 return childif __name__ == '__main__': result = Solution().findContentChildren([10,9,8,7],[5,6,7,8]) print(result) 763. 划分字母区间题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。 示例 1: 输入: S = “ababcbacadefegdehijhklij”输出: [9,7,8]解释:划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。 注意: S的长度在[1, 500]之间。S只包含小写字母’a’到’z’。 解题思路 用字典记录每个字母在字符串中出现的最右位置； 然后对每个字母和位置进行遍历，找到最靠右位置end； 如果遍历到的当前位置和最靠右位置重合，说明已经找到了一个划分； 更新开始位置start，继续。 1234567891011121314151617181920class Solution(object): def partitionLabels(self, S): """ :type S: str :rtype: List[int] """ if not S: return [] charIndex = &#123;c: i for i, c in enumerate(S)&#125; end = start = 0 ans = [] for i, c in enumerate(S): end = max(end,charIndex[c]) if i == end: ans.append(end-start+1) start = end + 1 return ansif __name__ == '__main__': result = Solution().partitionLabels("ababcbacadefegdehijhklij") print(result) 502. IPO解题思路以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。 给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。 总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。 示例 1:12345678910输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].输出: 4解释:由于你的初始资本为 0，你尽可以从 0 号项目开始。在完成后，你将获得 1 的利润，你的总资本将变为 1。此时你可以选择开始 1 号或 2 号项目。由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。 注意: 假设所有输入数字都是非负整数。表示利润和资本的数组的长度不超过 50000。答案保证在 32 位有符号整数范围内。 解题思路用两个堆。所有项目进入按照启动资金进小根堆。每一次做项目时，先将当前资本能做的项目从小根堆中弹出，进入大根堆，大根堆按照最大利润组织，然后从大根堆中弹出利润最大的项目，将所得利润加到资本中。这样可以保证每次先做当前资本所有能做的项目中利润最大的项目。 1234567891011121314151617181920212223242526272829from heapq import *class Solution(object): def findMaximizedCapital(self, k, W, Profits, Capital): """ :type k: int :type W: int :type Profits: List[int] :type Capital: List[int] :rtype: int """ minCHeap = [] # 项目启动资金的小根堆 for i in range(len(Profits)): heappush(minCHeap, [Capital[i], Profits[i]]) # 资本大于项目启动资金的所有项目按利润大根堆 maxPHeap = [] while k &gt; 0: while minCHeap and W &gt;= minCHeap[0][0]: pair = heappop(minCHeap) heappush(maxPHeap, -pair[1]) if maxPHeap: W += -heappop(maxPHeap) k -= 1 return W`]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-串的模式匹配]]></title>
    <url>%2F2019%2F07%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 朴素的模式匹配算法对主串的每一个字符作为子串开头，与要匹配的字符串进行匹 配。对主串做大循环，每个字符开头做 子串 的长度的小循环，直到匹配成功或全部遍历完成为止。 Python实现：123456789101112131415161718def index(S,T): if len(T)&gt;len(S): return False i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if S[i] == T[j]: i += 1 j += 1 else: i = i-j+1 j = 0 if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': result = index('goodgoogle','google') print(result) 时间复杂度： 最坏情况：一开始就匹配成功，时间复杂度为$O(1)$； 稍差一些：如果每次都是首字母就不匹配，那么对子串的循环就不必进行了，时间复杂度为$O(n+m)$，其中 n 为主串长度， m 为要匹配的子串长度； 平均情况：根据等概率原则，平均是 $(n+m) /2$ 次查找，时间复杂度为 $O(n+m)$； 最差情况： 每次不成功的匹配都发生在子串 的最后一个字符，时间复杂度为 $O((n- m+ 1)*m)$。 2 KMP模式匹配算法通过对模式串(子串)的一个预处理，将时间复杂度减少到了一个线性的水平。 举例：首先我们有主串：acabaabaabcacaabc，有模式串：abaabcac，现在假设我们匹配到了如下的图的步骤： 现在模式串的第六个字符和主串匹配不上了，那么现在我们就需要把模式串往右移动，并且重新选择主串和模式串的比较位置重新开始比较。 朴素模式匹配的做法是直接把子串向右移动一位，然后，主串的第四个字符和我们模式串的第一个字符重新开始做比较。 但是其实主串的第三个字符到第六个字符我们都是已经和模式串做过比较的，而且我们知道他们的各个位置上的内容是什么，那么为什么不把这些已经知道的信息充分利用起来了？比如：我们知道模式串中红色的两个字符和绿色的两个字符是相等的，而且红色的两个字符正好是模式串开始的两个字符，所以我们可以直接把模式串向右移动四位，然后，我们主串从刚才发现不匹配那个字符位置开始和模式串的第三个位置比较，这样我们就可以减少五次比较。 这个时候，我们就需要对我们的模式串做一个预处理，通过预处理我们可得到一个next数组，它保存的就是当我们在模式串某个位置匹配失败后，应该从模式串的哪个位置重新开始比较。 12345678910111213141516171819202122232425262728293031323334def get_next(T): #KMP next = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 next.append(j) else: j = next[j-1] return nextdef index(S,T): if len(T)&gt;len(S): return False next = get_next(T) i, j = 0, 0 while i &lt;len(S) and j &lt; len(T): if j == 0 or S[i] == T[j]: i += 1 j += 1 else: j = next[j-1] if j == len(T): return i-len(T) else: return Falseif __name__ == '__main__': next = get_next('ababaaaba') print(next) result = index('ababaabc','abc') print(result) 改进的KMP模式匹配算法如果模式串中的当前位置的字符与前缀字符相等，则将该前缀字符的next值赋给当前next值。 123456789101112131415def get_nextval(T):#改进的KMP nextval = [0] i = 1 j = 0 while i &lt; len(T): if j == 0 or T[j-1] == T[i-1]: i += 1 j += 1 if T[j-1] != T[i-1]: nextval.append(j) else: nextval.append(nextval[j-1]) else: j = nextval[j-1] return nextval 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-字典树]]></title>
    <url>%2F2019%2F07%2F17%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 字典树字典树，即Trie树，又称单词查找树或键树，是一种树形结构，常用于统计和排序大量字符串等场景（但不限于字符串），且经常被搜索引擎用于文本词频统计。它的优点是最大限度减少无谓的字符串比较，查询效率比较高。Trie树的核心思想是以空间换时间，利用字符串的公共前缀来降低查询时间的开销，以达到提高效率的目的。它有以下三个基本性质： 根结点不包含字符，除根结点外每一个结点都只包含一个字符； 从根节点到某一节点。路径上经过的字符连接起来，就是该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。 树的构建举例：题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。现在回到例子中，如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是$O(n^2)$。显然对于100000的范围难以接受。现在我们换个思路想。假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。好比假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的： 如上图所示，从根结点遍历到每个结点的路径就是一个单词，如果这个结点被标记为红色，就表示这个单词存在，否则不存在。那么，对于一个单词，只要顺着它从根走到对应的结点，再看这个结点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。这样一来我们查询和插入可以一起完成我们可以看到，trie树每一层的节点数是$26^i$级别的。为了节省空间，还可以动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数乘以单词长度。 查询Trie树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的AJAX搜索框时，就是Trie开始。本质上，Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie： 可以看出： 每条边对应一个字母。 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。 单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。 查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。 搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步：考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。 实现性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import collectionsclass Node(object): def __init__(self): self.children = collections.defaultdict(Node) self.isWord = Falseclass Trie(object): def __init__(self): """ Initialize your data structure here. """ self.root = Node() def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: None """ cur = self.root for w in word: cur = cur.children[w] cur.isWord = True def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ cur = self.root for w in word: cur = cur.children.get(w) if not cur: return False return cur.isWord def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ cur = self.root for w in prefix: cur = cur.children.get(w) if not cur: return False return Trueif __name__ == '__main__':# Your Trie object will be instantiated and called as such: obj = Trie() obj.insert('apple') print(obj.search('apple')) print(obj.search('app')) print(obj.startsWith('app')) obj.insert('app') print(obj.search('app')) 问题实例 Q. 10个频繁出现的词： 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。A. 用Trie树统计每个词出现的次数，时间复杂度是$O(nl)$（$l$表示单词的平均长度，最终用最小堆找到出现次数最频繁的10个词，时间复杂度为$O(nlog10)$ 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有1000万个记录，这些查询串的重复度比较高，虽然总数是1000万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。A. 可以使用Trie树，观察关键字在该查询串出现的次数，若没有出现则为0，最后用10个元素的最小堆来对出现频率进行排序。 参考文献：从Trie树（字典树）谈到后缀树]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 动态规划]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是动态规划相关题目题解总结。 [TOC] 动态规划递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是动态规划保存了子问题的解，避免重复计算。 动态规划与分治算法类似，都是通过组合子问题的解来求解原问题的： 分治算法将问题划分为互不相关的子问题，再递归地求解子问题，最后将它们的解组合起来，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子子问题）。在这种情况下，分治方法会做许多不必要的工作，需要反复求解那些公共子问题，而动态规划对于每个子子问题只求解一次，将其保存在一个表格里面，从而无需每次求解一个子子问题时都需要重新计算，避免了不必要的计算工作。 动态规划的应用场景 动态规划方法一般用来求解最优化问题。这类问题可以有很多可行解，每个解都有一个值，我们希望找到具有最优值的解，我们称这样的解为问题的一个最优解，而不是最优解，因为可能有多个解都达到最优值。 动态规划的一般步骤 定义一个状态，这是一个最优解的结构特征； 进行状态递推，得到递推公式； 进行初始化； 返回结果。 动态规划的实质就是分治思想和解决冗余。将原来具有指数级复杂性的算法改进成具有多项式时间的算法，这是动态规划算法的目的。由于在实现的过程中，需要存储各种状态，所以它的空间复杂性要大于其他算法，这是一种以空间换时间的技术。 动态规划三要素最优子结构性质、子问题重叠性、自底向上的求解方法。 最优子结构性质 最优子结构性质，就是问题的最优解包含其子问题的最优解。如果不具备该性质，就不能使用动态规划来解决。常用反证法分析论证问题是否具备最优子结构的性质； 有时对某个子问题的解不一定达到最优，但是当把它延伸成整个问题的解时反而成了最优解，这种问题不满足最优子结构性质，无法使用动态规划。 子问题重叠性质 动态规划对每个子问题只求解一次，并把其答案保存在表格里，因此可以避免重复计算； 子问题重叠性质并不是动态规划适用的必要条件，但是如果该性质无法满足，动态规划算法同其他算法相比就不具备优势。 自底向上的求解方法由于动态规划解决的问题具有子问题重叠的问题，求解时需要自底向上的方法： 首先选择合适的表格（一维或二维），将递归的停止条件填入表格的相应位置； 然后将问题的规模一级一级放大，求出每一级子问题的最优解，并将其填入表格的相应位置 ； 直到问题所要求的规模，此时求出的便是原问题的最优解。 除了自底向上的方法，还可以使用 “带备忘录的自顶向下方法”。此方法仍按自然的递归形式编写过程，但过程会保存每个子问题的解（用数组或列表保存）。当需要子问题的解时，过程首先检查是否已经保存过此解。如果是，直接返回保存的值，从而节省时间；否则，按通常方式计算这个子问题。这个递归过程是带备忘的，因为它记住了之前已经计算出的结果。 贪婪算法的局限性动态规划的一个关键特点是每次做选择之前，对所有选择的效果进行计算。在计算的结果上选择能够达到最优的选项，从而保证每次选择都是最优的。 但是这种策略在当选项的数量非常巨大的时候将不堪重负。例如下围棋的时候，如果采用动态规划策略，则需要先对每步可能的行棋的影响进行计算，然后比较选择最优的走法。但每一步可行进的走法实在太多，如果再考虑到一盘棋有几乎不计其数的步骤，所以计算任务非常大几乎不可能完成。这种情况就是上面介绍的动态规划的缺点。这个时候应该采用贪婪策略。 贪婪策略运行我们不对所有可能选择的影响计算一遍后作出决策。我们可以在进行选择的时候不进行任何计算，而根据当时的情况作出我们认为最好的选择，这样就避免了大量计算，从而大大提高了算法的效率。 【算法】详解动态规划算法导论——-动态规划是什么 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] 53. 最大子序和题目描述给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路动态规划：当我们想要获得0~n中最大的子串和时，如果0~n-1的连续和小于0，则连续和等于它自己nums[n]，如果为正，则连续和等于它自己加上0~n-1的连续和。 12345678910111213141516class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dp = [0]*len(nums) dp[0] = nums[0] for i in range(1,len(nums)): if dp[i-1] &lt; 0: dp[i] = nums[i] else: dp[i] = nums[i] + dp[i-1] return max(dp) temp比0小，那就从开始重新记录 12345678910111213141516171819class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] res = nums[0] temp = 0 for x in nums: temp += x if temp &gt; res: res = temp if temp &lt; 0: temp = 0 return res 讨论区里很精巧的解法。将每一个nums[i]的值，看成是存放前面连续的和大于0的序列；通过遍历，纠正错误存放的值；nums[i]中的每一个数存放的都是序号i前面连续数据的最大和。 123456789101112class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 for i in range(1,len(nums)): if nums[i-1] &gt; 0: nums[i] += nums[i-1] return max(nums) 62. 不同路径题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1:1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2:12输入: m = 7, n = 3输出: 28 解题思路动态规划。 当只有一行或者一列的时候，只有一种方式； 遍历其余位置，每一个位置只能由其左边或上边的元素达到，即迭代公式为: 遍历完成后，dp矩阵存放了每一个位置的走法数，因此返回最后一个数即为所求。 1234567891011121314151617181920class Solution(object): def uniquePaths(self, m, n): """ :type m: int :type n: int :rtype: int """ if m &lt; 1 or n &lt; 1: return 0 if m == 1 or n == 1: return 1 dp = [[1]*n for i in range(m)] for i in range(m): dp[i][0] = 1 for i in range(n): dp[0][i] == 1 for i in range(1,m): for j in range(1,n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1] 63. 不同路径 II题目描述一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1:123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解题思路有障碍物的地方走法为0。 12345678910111213141516171819202122232425262728293031class Solution(object): def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ if len(obstacleGrid) == 0: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) dp = [[0]*n for i in range(m)] for i in range(m): if obstacleGrid[i][0] == 0: dp[i][0] = 1 else: break for i in range(n): if obstacleGrid[0][i] == 0: dp[0][i] = 1 else: break for i in range(1,m): for j in range(1,n): if obstacleGrid[i][j] == 0: dp[i][j] = dp[i-1][j] + dp[i][j-1] else: dp[i][j] = 0 return dp[m-1][n-1] 64. 最小路径和题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例:12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路每个位置的最小数字总和为当前位置数值加上 上方及左方数字总和 较小的数。 1234567891011121314151617181920212223class Solution(object): def minPathSum(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for i in range(m)] dp[0][0] = grid[0][0] for i in range(1,m): dp[i][0] = grid[i][0] + dp[i-1][0] for i in range(1,n): dp[0][i] = grid[0][i] + dp[0][i-1] for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1] 70. 爬楼梯题目描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1：12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2：123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解题思路递归 (超时)1234567891011class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n == 1: return 1 if n == 2: return 2 return self.climbStairs(n-1) + self.climbStairs(n-2) 动态规划1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n dp = [0]*n dp[0] = 1 dp[1] = 2 for i in range(2,n): dp[i] = dp[i-1] + dp[i-2] return dp[-1] 1234567891011121314class Solution(object): def climbStairs(self, n): """ :type n: int :rtype: int """ if n &lt;= 3: return n a, b = 1, 2 res = 0 for i in range(3, n+1): res = a + b a, b = b, res return res 72. 编辑距离题目描述给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1:123456输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出: 3解释: horse -&gt; rorse (将 &apos;h&apos; 替换为 &apos;r&apos;)rorse -&gt; rose (删除 &apos;r&apos;)rose -&gt; ros (删除 &apos;e&apos;) 示例 2:12345678输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出: 5解释: intention -&gt; inention (删除 &apos;t&apos;)inention -&gt; enention (将 &apos;i&apos; 替换为 &apos;e&apos;)enention -&gt; exention (将 &apos;n&apos; 替换为 &apos;x&apos;)exention -&gt; exection (将 &apos;n&apos; 替换为 &apos;c&apos;)exection -&gt; execution (插入 &apos;u&apos;) 解题思路维护一个二维的数组dp，其大小为 (m+1)x(n+1)，m和n分别为 word1 和word2 的长度。$dp[i][j] $表示从 word1 的前i个字符转换到 word2 的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，这个很简单，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。当$word1[i] == word2[j]$时，$dp[i][j] = dp[i - 1][j - 1]$当$word1[i] != word2[j]$时，有三种处理方法，首先是直接插入一个 word2[j]，那么 word2[j] 位置的字符就跳过了，接着比较 $word1[i+1]$ 和 $word2[j+1] $即可。第二个种方法是删除，即将 $word1[i]$ 字符直接删掉，接着比较 $word1[i+1]$ 和 $word2[j]$ 即可。第三种则是将 $word1[i]$ 修改为 $word2[j]$，接着比较 $word1[i+1]$ 和 $word[j+1]$ 即可。所以 $dp[i][j]$是其左，左上，上的三个值中的最小值加1，其实这里的左，上，和左上，分别对应的增加，删除，修改操作。转移方程为：如果 $word1[i - 1] == word2[j - 1]$, $dp[i][j] = dp[i - 1][j - 1]$否则 $dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1$ 123456789101112131415161718192021222324class Solution(object): def minDistance(self, word1, word2): """ :type word1: str :type word2: str :rtype: int """ dp = [[0] * (len(word1)+1) for _ in range(len(word2)+1)] for i in range(1, len(word1)+1): dp[0][i] = i for i in range(1, len(word2)+1): dp[i][0] = i for i in range(1, len(word2)+1): for j in range(1, len(word1)+1): if word2[i-1] == word1[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 return dp[-1][-1] 91. 解码方法题目描述一条包含字母 A-Z 的消息通过以下方式进行了编码：1234&apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1:123输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2:123输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 解题思路dp[i]代表解析是s[:i]字符串的所有可能的方式数目。则：12dp[i] = dp[i-1] if s[i] != &apos;0&apos; + dp[i-2] if &apos;9&apos; &lt; s[i-2:i] &lt; &apos;27&apos; 举例子：对于’226’： 令dp=[0,0,0,0]，初始化为[1,0,0,0]； 从第一个位置开始，输入’2’，不为0，dp=[1,1,0,0]； 第二个位置为’2’，不为0，所以dp=[1,1,1,0]，此时前两位为’22’，满足区间，所以变为[1,1,2,0]; 第三个位置为’6’，不为0，所以dp=[1,1,2,2]，此时前两位为’26’，满足区间，所以变为[1,1,2,3]。 12345678910111213141516class Solution(object): def numDecodings(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 dp = [0] * (len(s)+1) dp[0] = 1 for i in range(1, len(s)+1): if s[i-1] != '0': dp[i] = dp[i-1] if i != 1 and '09' &lt; s[i-2:i] &lt; '27': dp[i] += dp[i-2] return dp[len(s)] 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 解题思路12345678910111213141516171819202122232425262728给定一个数n，求1到n这些数可以构成多少棵二叉树。给定一个序列1.....n，为了构造所有二叉树，我们可以使用1......n中的每一个数i作为根节点，自然1......(i-1)必然位于树的左子树中，(i+1).....n位于树的右子树中。然后可以递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。使用两个状态来记录：dp(n)：长度为n的序列的所有唯一的二叉树。dp(i,n)，1&lt;=i&lt;=n：以i作为根节点的二叉树的数量。dp(n)就是我们要求解的答案，dp(n)可以由F(i,n)计算而来。dp(n)=F(1,n)+F(2,n)+...+F(n,n) (1)dp(0)=1,dp(1)=1对于给定的一个序列1.....n，我们取i作为它的根节点，那么以i作为根节点的二叉树的数量F(i)可以由下面的公式计算而来：F(i,n)=dp(i-1)*dp(n-i-1) 1&lt;=i&lt;=n (2)比i小的数1...i-1作为左子树，比i大的数i+1...n作为右子树，左子树的排列和右子树的排列的乘积是此时的数目。例如 i=3，n=3时， dp[3] = dp[0]*dp[2]+dp[1]*dp[1]+dp[2]dp[0]。即左右子树节点数量分别为(0,2),(1,1),(2,0)。综合公式（1）和公式（2），可以看出：dp(n) = dp(0) * dp(n-1) + dp(1) * dp(n-2) + … + dp(n-1) * dp(0)[参考](https://blog.csdn.net/u012501459/article/details/46622501) 1234567891011121314class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt;= 2: return dp[n] dp += [0] * (n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[n] 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:1234567891011输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 解题思路 遍历1~n选择一个数当作根节点，所以其左边的数字构成左子树，右边的数字构成右子树。 当左子树固定的时候，把所有可能的右子树都构成，然后再变换左子树。（两层for循环遍历leftnodes和rightnodes）。 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 120. 三角形最小路径和题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形：123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 解题思路新建dp和三角形一样大小，dp[i][j]为第i层第j个位置的最短路径，dp初始化为最下面一层，从倒数第二层自底向上遍历，则：1dp[i][j] = min(dp[i+1][j],dp[i+1][j+1]) + triangle[i][j] 123456789101112131415161718class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = [] for i in range(len(triangle)): dp.append([0]*len(triangle[i])) dp[-1] = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j] return dp[0][0] 由于 $dp[i][j]$ 只被用了一次，所以可以变为一维dp：1dp[i] = min(dp[i],dp[i+1]) + triangle[i][j] 1234567891011121314class Solution(object): def minimumTotal(self, triangle): """ :type triangle: List[List[int]] :rtype: int """ if len(triangle) == 0: return 0 dp = triangle[-1] for i in range(len(triangle)-2, -1, -1): for j in range(i+1): dp[j] = min(dp[j], dp[j+1]) + triangle[i][j] return dp[0] 121. 买卖股票的最佳时机题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1:1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路维护两个变量，到目前为止的最小值和最大收益。 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 minprice = prices[0] for i in range(1, len(prices)): minprice = min(minprice, prices[i]) maxprofit = max(maxprofit, prices[i]-minprice) return maxprofit 动态规划dp[i]为前i天的最大收益 = max(前i-1天的最大收益，第i天的价格-前i-1种的最小价格) dp[i] = max(dp[i-1]-min(prices[:i]) 123456789101112class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0]*len(prices) for i in range(1,len(prices)): dp[i] = max(dp[i-1], prices[i]-min(prices[:i])) return dp[-1] 122. 买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路当今天价格比昨天价格高时，就做一次交易。 12345678910111213class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 maxprofit = 0 for i in range(1,len(prices)): if prices[i]&gt;prices[i-1]: maxprofit += prices[i]-prices[i-1] return maxprofit 动态规划，dp[i]为到第i天的最大收益，当今天价格比昨天价格高时，就做一次交易，dp[i] = dp[i-1]+prices[i]-prices[i-1] if prices[i]&gt;prices[i-1] else 0. 1234567891011121314class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) &lt;= 1: return 0 dp = [0] * len(prices) for i in range(1,len(prices)): dp[i] = dp[i-1] if prices[i] &gt; prices[i-1]: dp[i] += prices[i]-prices[i-1] return dp[-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = &quot;Leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;Leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2：1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 152. 乘积最大子序列题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1:123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 解题思路暴力，超时。12345678910111213141516171819class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = nums[0] for i in range(len(nums)): res = max(res, nums[i]) cur = nums[i] for j in range(i+1,len(nums)): cur *= nums[j] res = max(res, cur) return res 动态规划 考虑某个位置出现负数或0的情况。当遇到0时，整个乘积变为0；当遇到负数时，当前的最大乘积变为最小乘积，最小乘积变为最大乘积。 使用两个数组分别记录以某个位置i结尾时的最大乘积和最小乘积，另最大乘积为dpmax，最小乘积为dpmin： 当前最大值为已知最大值乘当前值，当前值，已知最小值乘当前值，三者中的最大值； 当前最小值为已知最小值乘当前值，当前值，已知最大值乘当前值，三者中的最小值； 结果为最大值数组中的最大值。 1234567891011121314151617181920class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = [0]*len(nums) dpmax = [0]*len(nums) dpmin[0] = dpmax[0] = nums[0] res = nums[0] for i in range(1,len(nums)): dpmin[i] = min(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) dpmax[i] = max(dpmax[i-1]*nums[i], nums[i], dpmin[i-1]*nums[i]) res = max(res, dpmax[i]) # return max(dpmax) return res 空间优化。123456789101112131415161718class Solution(object): def maxProduct(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 dpmin = dpmax = nums[0] res = nums[0] for i in range(1,len(nums)): lastmin = dpmin lastmax = dpmax dpmin = min(lastmax*nums[i], nums[i], lastmin*nums[i]) dpmax = max(lastmax*nums[i], nums[i], *nums[i]) res = max(res, dpmax) return res 198. 打家劫舍题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2:1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 解题思路动态规划，维护一个长为len(nums)的数组dp，dp[i]代表在i处能取得的最大金额，这个房子该不该偷，这么决定的因素是这个房子偷了的话的收益和不偷留着偷下一个房子的收益那个比较高： 房子i的金额+dp[i-2]的金额 大于 dp[i-1]时，偷； 房子i的金额+dp[i-2]的金额 小于 dp[i-1]时，不偷。 即递推式为：123dp[0] = nums[0] dp[1] = nums[1] dp[i] = max(dp[i-2]+nums[i], dp[i-1]) 12345678910111213141516171819class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(2,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 213. 打家劫舍 II题目描述你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1:123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2:1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 解题思路本题相比第198题就多了不同时偷第一个和最后一个的约束条件。所以，两种偷的情况：第一种不偷最后一个房间，第二种不偷第一个房间，求这两种偷法能获得的最大值。 12345678910111213141516171819202122class Solution(object): def rob(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) return max(self.helper(nums[:len(nums)-1]), self.helper(nums[1:])) def helper(self, nums): if len(nums) == 2: return max(nums) dp = [0]*len(nums) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i in range(1,len(nums)): dp[i] = max(dp[i-2]+nums[i], dp[i-1]) return dp[-1] 221. 最大正方形题目描述在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例:12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 解题思路使用DP，设DP[i][j]为以i,j位置为右下角顶点的能构成的最大正方形的边长，DP数组的第一行和第一列和matrix相等，其他位置当matrix[i][j]==1时，能构成的正方形边长等于左边，上边，左上角能构成正方形边长的最小值+1.递推公式：12341 when i==0 or j == 0, dp[i][j] = matrix[i][j]2 when i &gt; 0 and j &gt; 0, if matrix[i][j] == 0 dp[i][j] = 0 if matrix[i][j] == 1 dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1 参考 12345678910111213141516171819202122class Solution(object): def maximalSquare(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 dp = [[0]*len(matrix[0]) for i in range(len(matrix))] res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): if i == 0 or j == 0: dp[i][j] = 1 if matrix[i][j] == '1' else 0 elif matrix[i][j] == '1': dp[i][j] = 1+ min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) res = max(res, dp[i][j]) return res*res 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明:121 是丑数。n 不超过1690。 解题思路123456789101112131415161718192021222324class Solution(object): def nthUglyNumber(self, n): &quot;&quot;&quot; :type n: int :rtype: int &quot;&quot;&quot; if n &lt;= 6: return n dp = [1] t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp.append(min(dp[t2]*2, dp[t3]*3, dp[t5]*5)) if dp[t2]*2 == dp[-1]: t2 += 1 if dp[t3]*3 == dp[-1]: t3 += 1 if dp[t5]*5 == dp[-1]: t5 += 1 return dp[-1] 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例 2:123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路dp[i] = 1+min(dp[i-1^2],dp[i-2^2],…,dp[i-k^2]) 12345678910111213141516171819class Solution(object): def numSquares(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0]*(n+1) for i in range(1, n+1): minval = float('inf') for j in range(1, int(i**0.5)+1): minval = min(minval, dp[i-j*j]) dp[i] = minval + 1 return dp[-1] 四平方数定理https://github.com/grandyang/Leetcode/issues/2791234567891011121314151617181920class Solution: def numSquares(self, n: int) -&gt; int: if n == 0: return 0 while n % 4 == 0: n //= 4 if n % 8 == 7: return 4 for i in range(int(n**0.5)+1): j = int((n - i*i)**0.5) if i*i + j*j == n: if i != 0 and j != 0: return 2 else: return 1 return 3 300. 最长上升子序列题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例:123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路使用dp保存包目前为止的最大递增子序列长度，最后求所有为止的最大值，而不是dp的最后元素1初始化dp[i]=12对每一个位置，如果当前位置比之前位置的大，则此时为递增子序列，更新之 1234567891011121314151617181920class Solution(object): def lengthOfLIS(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) res = 1 dp = [1]*len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) res = max(res, dp[i]) return res 303. 区域和检索 - 数组不可变题目描述给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例：12345给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 说明: 你可以假设数组不可变。 会多次调用 sumRange 方法。 解题思路先把到当前位置的和求出来，然后再调用的时候直接右边的和减去左边的和。 12345678910111213141516171819202122232425262728class NumArray(object): def __init__(self, nums): """ :type nums: List[int] """ self.data = [] total = 0 for num in nums: total += num self.data.append(total) def sumRange(self, i, j): """ :type i: int :type j: int :rtype: int """ if i == 0: return self.data[j] else: return self.data[j]-self.data[i-1]# Your NumArray object will be instantiated and called as such:# obj = NumArray(nums)# param_1 = obj.sumRange(i,j) 304. 二维区域和检索 - 矩阵不可变题目描述给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。 上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。 示例:1234567891011给定 matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 说明: 你可以假设矩阵不可变。 会多次调用 sumRegion 方法。 你可以假设 row1 ≤ row2 且 col1 ≤ col2。 解题思路使用dp保存当前位置到左上角元素构成的矩形的所有元素和，添加了第一列和第一行全是0，这样能保证在求和的时候，每个位置的和是是左边的和+上边的和-左上元素的和+当前位置的值1Sum(ABCD)=Sum(OD)−Sum(OB)−Sum(OC)+Sum(OA) 参考 123456789101112131415161718192021222324252627class NumMatrix(object): def __init__(self, matrix): """ :type matrix: List[List[int]] """ if not matrix or not matrix[0]: m, n = 0, 0 else: m, n = len(matrix), len(matrix[0]) self.dp = [[0]*(n+1) for _ in range(m+1)] for i in range(m): for j in range(n): self.dp[i+1][j+1] = self.dp[i+1][j]+self.dp[i][j+1]-self.dp[i][j] + matrix[i][j] def sumRegion(self, row1, col1, row2, col2): """ :type row1: int :type col1: int :type row2: int :type col2: int :rtype: int """ return self.dp[row2+1][col2+1]-self.dp[row2+1][col1]-self.dp[row1][col2+1]+self.dp[row1][col1] 309. 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。示例:123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 解题思路使用两个数组1 sell[i]表示该天结束之后手里没有股票的情况下的最大收益，可能情况为该天手里有股票卖了，或者该天没进行交易，即 max(hold[i-1]+prices[i]， sell[i-1]);2 hold[i]表示该天结束之后手里有股票的情况下的最大收益，可能情况为手里有股票但是没进行交易，或者手里没有股票买进股票，今天买进的条件是昨天必须休息，即max(hold[i-1], sell[i-2]-prices[i])。 注意：第一天不可能有卖股票的操作，hold[0] = -prices[0]。 该算法的时间复杂度是O(n)，空间复杂度是O(n)。123456789101112131415161718class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 sell = [0 for _ in range(len(prices))] hold = [0 for _ in range(len(prices))] hold[0] = -prices[0] for i in range(1, len(prices)): sell[i] = max(sell[i-1], hold[i-1]+prices[i]) hold[i] = max(hold[i-1], (sell[i-2] if i&gt;=2 else 0)-prices[i]) return sell[-1] 优化空间复杂度到O(1)123456789101112131415161718192021class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ if len(prices) == 0: return 0 cursell = 0 precell = 0 hold = -prices[0] for i in range(1, len(prices)): temp = cursell cursell = max(cursell, hold+prices[i]) hold = max(hold, (presell if i&gt;= 2 else 0)-prices[i]) presell = temp return cursell 322. 零钱兑换题目描述给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1:123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2:12输入: coins = [2], amount = 3输出: -1 说明: 你可以认为每种硬币的数量是无限的。 解题思路DP。构建一个amount+1的数组，保存面额从0到amount+1需要使用的最少硬币数量。对于每一个位置i，如果j-c &gt;= 0, dp[i] = min(dp[i],dp[i-c]+1) 1234567891011121314151617181920212223class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [float('inf')]*(amount+1) dp[0] = 0 for i in range(1, amount+1): for c in coins: if i-c &gt;= 0: dp[i] = min(dp[i], dp[i-c]+1) return dp[-1] if dp[-1] != float('inf') else -1 f(n) = min(f(n - c1), f(n - c2), … f(n - cn)) + 1123456789101112131415161718192021222324class Solution(object): def coinChange(self, coins, amount): """ :type coins: List[int] :type amount: int :rtype: int """ if amount == 0: return 0 if len(coins) == 0: return -1 dp = [0 for _ in range(amount+1)] for i in range(1, amount+1): cost = float('inf') for c in coins: if i-c &gt;= 0: cost = min(cost, dp[i-c]+1) dp[i] = cost return dp[-1] if dp[-1] != float('inf') else -1 338. 比特位计数题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。 示例 1:12输入: 2输出: [0,1,1] 示例 2:12输入: 5输出: [0,1,1,2,1,2] 进阶: 给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 builtin_popcount）来执行此操作。 解题思路找规律使用dp，如果i是偶数，它的二进制1的位数等于i//2中1的位数；如果i是奇数，那么它的二进制位数等于i-1的二进制位数+1.即 if i%2==0: dp[i] = dp[i//2]else: dp[i] = dp[i-1]+1 又因为i为奇数时，i-1为偶数，即dp[i-1]=dp[i//2]，此时dp[i] = dp[i//2]+1，综合起来可以写成dp[i] = dp[i//2] + (i&amp;1) 123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] dp = [0] * (num+1) for i in range(1, num+1): # if i % 2 == 0: # dp[i] = dp[i//2] # else: # dp[i] = dp[i-1] + 1 dp[i] = dp[i//2] + (i&amp;1) return dp 暴力，时间复杂度为O(n*sizeof(integer))123456789101112131415161718192021class Solution(object): def countBits(self, num): """ :type num: int :rtype: List[int] """ if num &lt; 0: return [] res = [] for i in range(num+1): count = 0 while i: if i&amp;1: count += 1 i &gt;&gt;= 1 res.append(count) return res 343. 整数拆分题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1:123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2:123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 说明: 你可以假设 n 不小于 2 且不大于 58。 解题思路使用dp，dp[i]表示i拆分后的最大乘积，将i分为两部分j和i-j，将这两部分相乘取最大的。 123456789101112131415161718192021class Solution(object): def integerBreak(self, n): """ :type n: int :rtype: int """ if n == 2: return 1 if n == 3: return 2 dp = [0]*(n+1) dp[2] = 1 dp[3] = 2 for i in range(4, n+1): for j in range(1, i//2 + 1): dp[i] = max(dp[i], max(j, dp[j]) * max(i-j, dp[i-j])) return dp[-1] 357. 计算各个位数不同的数字个数题目描述给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。 示例:123输入: 2输出: 91 解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。 解题思路//dp[i]=dp[i-1]+(dp[i-1]-dp[i-2])*(10-(i-1)); //加上dp[i-1]没什么可说的，加上之前的数字 //dp[i-1]-dp[i-2]的意思是我们之前判断各位不重复的数字 //我们要在这些数字后面填新的数字。当i=2时，说明之前选取的数字只有 //1位，那么我们只要与这一位不重复即可，所以其实有9(10-1)种情况（比如1，后面可以跟0,2,3,4,5,6,7,8,9）。 //当i=3时，说明之前选取的数字有2位，那么我们需要与2位不重复，所以剩余的 //有8（10-2）种（比如12，后面可以跟0,3,4,5,6,7,8,9） 123456789101112131415161718class Solution(object): def countNumbersWithUniqueDigits(self, n): """ :type n: int :rtype: int """ if n == 0: return 1 dp = [0] * (n+1) dp[0] = 1 dp[1] = 10 for i in range(2, n+1): dp[i] = dp[i-1] + (dp[i-1]-dp[i-2]) * (10-(i-1)) return dp[-1] 368. 最大整除子集题目描述给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。 如果有多个目标子集，返回其中任何一个均可。 示例 1:12输入: [1,2,3]输出: [1,2] (当然, [1,3] 也正确) 示例 2:12输入: [1,2,4,8]输出: [1,2,4,8] 解题思路首先对数组进行排序，使用dp，dp[i]的含义是从0~i位置满足题目的数组最长长度，先用i遍历每个数字，然后用j从后向前（从前到后也可以）寻找能被nums[i]整除的数字，这样如果判断能整除的时候，在判断dp[i]&lt;d[j]+1，即判断对于以i为结尾的最长数组是否变长了。在变长的情况下，需要更新dp[i]，同时使用parent[i]更新i的前面能整除的数字。另外还要统计对于整个数组最长的子数组长度。 知道了对于每个位置最长的子数组之后，我们也就知道了对于0~n区间内最长的满足题目条件的数组，最后需要再次遍历，使用parent就能把正儿个数组统计输出出来。因为这个最大的索引mx_index是对n而言的，所以输出是逆序的。 参考 1234567891011121314151617181920212223242526272829303132class Solution(object): def largestDivisibleSubset(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] nums.sort() dp = [0] * len(nums) parent = [0] * len(nums) maxlen = 0 maxlenIndex = -1 for i in range(len(nums)): for j in range(i-1, -1, -1): # for j in range(i): if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j]+1: dp[i] = dp[j] + 1 parent[i] = j if dp[i] &gt; maxlen: maxlen = dp[i] maxlenIndex = i res = [] for i in range(maxlen+1): res.append(nums[maxlenIndex]) maxlenIndex = parent[maxlenIndex] return res[::-1] 375. 猜数字大小 II题目描述我们正在玩一个猜数游戏，游戏规则如下： 我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。 每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。 然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。 示例:123456789n = 10, 我选择了8.第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。游戏结束。8 就是我选的数字。你最终要支付 5 + 7 + 9 = 21 块钱。 给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。 解题思路这题要求我们在猜测数字y未知的情况下（1~n任意一个数），要我们在最坏情况下我们支付最少的钱。也就是说要考虑所有y的情况。 我们假定选择了一个错误的数x，（1&lt;=x&lt;=n &amp;&amp; x!=y ）那么就知道接下来应该从[1,x-1 ] 或者[x+1,n]中进行查找。 假如我们已经解决了[1,x-1] 和 [x+1,n]计算问题，我们将其表示为solve(L,x-1) 和solve(x+1,n)，那么我们应该选择max(solve(L,x-1),solve(x+1,n)) 这样就是求最坏情况下的损失。总的损失就是 f(x) = x + max(solve(L,x-1),solve(x+1,n)) 那么将x从1~n进行遍历，取使得 f(x) 达到最小，来确定最坏情况下最小的损失，也就是我们初始应该选择哪个数。 上面的说法其实是一个自顶向下的过程（Top-down），可以用递归来解决。很容易得到如下的代码（这里用了记忆化搜索）： 参考 123456789101112131415161718class Solution(object): def getMoneyAmount(self, n): """ :type n: int :rtype: int """ dp = [[0]*(n+1) for _ in range(n+1)] return self.solve(dp, 1, n) def solve(self, dp, left, right): if left &gt;= right: return 0 if dp[left][right]: return dp[left][right] dp[left][right] = min(i + max(self.solve(dp, left, i-1), self.solve(dp, i+1, right)) for i in range(left, right+1)) return dp[left][right] 376. 摆动序列题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例 1:123输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。 示例 2:123输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 示例 3:12输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 解题思路摆动为一升一降，一个up就要配一个down构成一组。注意去重 123456789101112131415161718192021class Solution(object): def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) up = 1 down = 1 for i in range(1, len(nums)): if nums[i] &gt; nums[i-1]: up = down + 1 elif nums[i] &lt; nums[i-1]: down = up + 1 return max(up, down) 377. 组合总和 Ⅳ题目描述给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例:123456789101112131415nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)请注意，顺序不同的序列被视作不同的组合。因此输出为 7。 进阶： 如果给定的数组中含有负数会怎么样？ 问题会产生什么变化？ 我们需要在题目中添加什么限制来允许负数的出现？ 解题思路使用dp[i]表示组合数为i时使用nums中的数组能组成组合数的个数，因为都是正数，所以长度最多是target,target个1组成。 从1遍历到target，对于每一个数i，遍历nums数组，如果i&gt;=x, dp[i] += dp[i - x]。比如说对于[1,2,3] 4，在计算dp[3]的时候，3可以拆分为1+x，而x即为dp[2]，3也可以拆分为2+x，此时x为dp[1]，3同样可以拆为3+x，此时x为dp[0]，我们把所有的情况加起来就是组成3的所有情况了。 1234567891011121314151617181920class Solution(object): def combinationSum4(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 dp = [0] * (target+1) dp[0] = 1 for i in range(1, target+1): for x in nums: if i &gt;= x: dp[i] += dp[i-x] return dp[-1] 392. 判断子序列题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1:123s = &quot;abc&quot;, t = &quot;ahbgdc&quot;返回 true. 示例 2:123s = &quot;axc&quot;, t = &quot;ahbgdc&quot;返回 false. 后续挑战 : 如果有大量输入的 S，称作S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 解题思路dp的tag不用dp。使用一个指针index记录最后s[:index]在t中存在的最后位置。 123456789101112131415161718192021class Solution(object): def isSubsequence(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: bool &quot;&quot;&quot; if len(t) &lt; len(s): return False if len(s) == 0: return True index = 0 for i in range(len(t)): if t[i] == s[index]: index += 1 if index == len(s): return True return index == len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 位运算]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是位运算相关题目题解总结。 [TOC] 位运算基本原理0s表示一串0，1s表示一串1。123x^0s = x x&amp;0s = 0 x|0s = xx^1s = ~x x&amp;1s = x x|1s = 1sx^x = 0 x&amp;x = x x|x = x 利用x^1s=~x的特点，可以将位级表示翻转； 利用x^x=0的特点，可以将三个数中重复的两个数去除，只留下另一个数； 利用x&amp;0s=0和x&amp;1s=x的特点，可以实现掩码操作，一个数num与mask进行位与操作，只保留num中与mask的1部分相对应的位；例如num:10101010和mask:00111100，进行位与操作得00101000。 利用x|0s=x和x|1s=1s的特点，可以实现设值操作，一个数num与mask进行位或操作，将num中与mask中的1部分相对应的位都设置为1；例如num:10101010和mask:00111100，进行位或操作得10111110。 位与运算技巧： n&amp;(n-1) 表示去掉n的位级表示中最低位的1。例如n:10110100，减去1得到10110011，将这两个数相与得到10110000。 n&amp;(-n)表示n的位级表示中的最低位的1，-n得到n的反码加1，对于二进制表示10110100，-n得到01001100，相与得到00000100。 n-n&amp;(~n+1)表示去掉n的位级表示中的最高位的1。例如n:10110100，则n-n&amp;(~n+1): ??? 移位运算： &gt;&gt;n为算术右移，相当于除以2^n； &gt;&gt;n为无符号右移，左边会补上0； &lt;&lt;n为算术左移，相当于乘以2^n。 mask计算： 要获取11111111，将0取反即可，~0； 要得到只有第i位为1的mask，将1向左移动i-1位即可，1&lt;&lt;(i-1)。例如1&lt;&lt;4得到只有第5位为1的mask：00010000； 要得到1到i位为1的mask，(1&lt;&lt;(i+1))-1即可，例如将1&lt;&lt;(4+1)-1=00010000-1=00001111； 要得到1到i位为0的mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~(1&lt;&lt;(i+1)-1)。 参考 136. 只出现一次的数字题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,1]输出: 1 示例 2:12输入: [4,1,2,1,2]输出: 4 解题思路方法1：使用异或操作，一个数自己异或自己等于0, 一个数异或0等于数本身，即把所有数字进行异或操作，如果一个数出现两次，则变为0消失，最后剩下只出现一次的数字。 123456789101112class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for x in nums: res ^= x return res 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。1234567891011121314151617class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key in Dict: if Dict[key] == 1: return key 137. 只出现一次的数字 II题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1:12输入: [2,2,3,2]输出: 3 示例 2:12输入: [0,1,0,1,0,1,99]输出: 99 解题思路方法1：位运算，把32位的二进制数进行遍历，统计所有数字的每一位出现0或1的次数。因为每个数字出现3次或者1次，当某一位出现次数不为3时，则一定是出现1次，使用或操作将每个位置叠加起来。python的整形没有最大值，当输入是负数时，会认为是很大的正数，如果大于2^31-1时，则需要减去2^32。1234567891011121314151617181920class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count % 3 == 1: res |= mask mask &lt;&lt;= 1 return res if res &gt;&gt; 31 == 0 else res-(1&lt;&lt;32) 方法2：使用字典保存每个数字出现的次数，最后遍历字典返回出现次数等于1的数。123456789101112131415161718class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val == 1: return key 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1:12输入: [3,2,3]输出: 3 示例 2:12输入: [2,2,1,1,1,2,2]输出: 2 解题思路方法1：将原数组排序nums.sort()， 返回nums[len(nums)//2]; 方法2：使用字典记录每个数出现的次数，返回出现次数大于len(nums)//2的数；优化：在计数时同时判断数字出现的次数，只用一个for循环； 方法3：位运算，遍历二进制的每一位，每一位上的1或0（代码使用1）出现次数大于一半，即为所求的值在该位上的值，统计每一位的1或0组合即可，减去2^32对负数进行处理。以后出现位运算的时候，需要对结果进行判断一下最好。如果不在这个范围内，说明了结果被认为是无符号的数了，需要减去2 ^ 32。 1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ res = 0 mask = 1 for i in range(32): count = 0 for x in nums: if x &amp; mask: count += 1 if count &gt; len(nums)//2: res |= mask break mask &lt;&lt;= 1 return res if res&gt;&gt;31 == 0 else res - (1&lt;&lt;32) 方法4：摩尔投票法，待续。 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 解题思路方法1：遍历+set，从头到尾把字符串遍历，然后判断这10个字母是否已经出现过，如果出现过，则加入结果中，否则，加入辅助集合中。用set是因为一个字符串可能出现多次，为了防止重复添加到结果中，使用set去重。时间空间复杂度均为O(N)。1234567891011121314151617class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ if len(s) &lt; 10: return [] res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 方法2：位运算，待续 190. 颠倒二进制位题目描述颠倒给定的 32 位无符号整数的二进制位。 示例 1：1234输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596， 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 示例 2：1234输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293， 因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。 解题思路使用python二进制转换。12345678class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = '&#123;0:032b&#125;'.format(n) # 032b的0用于填充，0:32b为' 10100101000001111010011100'，0:032b为'00000010100101000001111010011100' res = res[::-1] res = int(res,2) return res 位运算。从n的最后一位向前遍历，放到res的后面，并且res向左移动。 12345678910class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 for i in range(32): res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 return res 12345678910111213class Solution: # @param n, an integer # @return an integer def reverseBits(self, n): res = 0 count = 0 while n: res = (res&lt;&lt;1) + (n&amp;1) n &gt;&gt;= 1 count += 1 res = res&lt;&lt;(32-count) return res 191. 位1的个数题目描述编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &apos;1&apos;。 示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &apos;1&apos;。 示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &apos;1&apos;。 提示：12请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 进阶:如果多次调用这个函数，你将如何优化你的算法？ 解题思路123456789101112class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 while n: if n&amp;1: res += 1 n &gt;&gt;= 1 return res 123456789101112131415class Solution(object): def hammingWeight(self, n): """ :type n: int :rtype: int """ res = 0 mask = 1 for i in range(32): if mask &amp; n: res += 1 mask &lt;&lt;= 1 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 树]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是树相关题目题解总结。 [TOC] 94. 二叉树的中序遍历题目描述给定一个二叉树，返回它的中序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return self.dfs(root.left, res) res.append(root.val) self.dfs(root.right, res) return res 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [] self.allLeftIntoStack(root, stack) while stack: root = stack.pop() res.append(root.val) if root.right: self.allLeftIntoStack(root.right, stack) return res def allLeftIntoStack(self, root, stack): while root: stack.append(root) root = root.left 95. 不同的二叉搜索树 II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例:123456789101112131415161718输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路依次以1~n作为根节点，其左边的为左子树，右边的为右子树。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def generateTrees(self, n): """ :type n: int :rtype: List[TreeNode] """ if n &lt;= 0: return [] return self.dfs(1, n+1) def dfs(self, left, right): res = [] for rootval in range(left, right): leftnodes = self.dfs(left, rootval) or [None] rightnodes = self.dfs(rootval+1, right) or [None] for leftnode in leftnodes: for rightnode in rightnodes: root = TreeNode(rootval) root.left = leftnode root.right = rightnode res.append(root) return res 96. 不同的二叉搜索树题目描述给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例:12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解题思路动态规划 给定一个序列1,…,n，为了构造所有的二叉树，我们遍历以i为节点，则1,…,i-1为构成左子树，i+1,…,n构成右子树；然后通过递归来构建左右子树，由于根节点是唯一的，所以可以保证构建的二叉树都是唯一的。 设dp[n]为1,…,n组成二叉搜索树的个数，初始化dp[0]=1,dp[1]=1,dp[2]=2； dp[n] = F(1,n)+F(2,n)+…+F(n,n)F(i,n) = dp(i-1)dp(n-i-1), 如F(1,3) = dp[0]dp[2]F(i,n)为以i为根节点的二叉树个数。等于左右子树的排列的乘积。 dp[3] = dp[0]dp[2] + dp[1]dp[1] + dp[2]*dp[0] 因为dp[n] = dp[0]*dp[n-1] + dp[1][n-2] + … + dp[n-1]dp[0] 12345678910111213141516class Solution(object): def numTrees(self, n): """ :type n: int :rtype: int """ dp = [1,1,2] if n &lt; 3: return dp[n] dp += [0]*(n-2) for i in range(3, n+1): for j in range(i): dp[i] += dp[j]*dp[i-j-1] return dp[-1] 98. 验证二叉搜索树题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1:12345输入: 2 / \ 1 3输出: true 示例 2:123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路根据二叉搜索树的定义，左子树的值在(left, root.val)之间，右子树的值在(root.val, right)，每次递归是判断当前节点值是否满足取值上界和下界，计算下一节点是要根据左右节点进行更新上下界。 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.dfs(root, float('-inf'), float('inf')) def dfs(self, root, left, right): if not root: return True if root.val &lt;= left or root.val &gt;= right: return False return self.dfs(root.left, left, root.val) and self.dfs(root.right, root.val, right) 先中序遍历（递归），判断数组是否升序。1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] self.inorder(root, queue) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def inorder(self, root, queue): if not root: return self.inorder(root.left, queue) queue.append(root.val) self.inorder(root.right, queue) return queue 先中序遍历（迭代），判断数组是否升序。1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isValidBST(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = [] stack = [] self.LeftintoStack(root, stack) while stack: root = stack.pop() queue.append(root.val) if root.right: self.LeftintoStack(root.right, stack) for i in range(1, len(queue)): if queue[i] &lt;= queue[i-1]: return False return True def LeftintoStack(self, root, stack): if not root: return while root: stack.append(root) root = root.left 100. 相同的树题目描述给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1:1234567输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2:1234567输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3:1234567输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解题思路123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if not p and not q: return True if not p or not q: return False if p.val != q.val: return False return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) 101. 对称二叉树题目描述给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:12345 1 / \2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True return self.judge(root.left, root.right) def judge(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.judge(left.left, right.right) and self.judge(left.right, right.left) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True queue = collections.deque() queue.append([root.left, root.right]) while queue: pair = queue.popleft() left, right = pair[0], pair[1] if not left and not right: continue if not left or not right: return False if left.val != right.val: return False queue.append([left.left, right.right]) queue.append([left.right, right.left]) return True 102. 二叉树的层次遍历题目描述给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其层次遍历结果：12345[ [3], [9,20], [15,7]] 解题思路迭代1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res 递归123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 103. 二叉树的锯齿形层次遍历题目描述给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回锯齿形层次遍历如下：12345[ [3], [20,9], [15,7]] 解题思路迭代123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res 递归123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 104. 二叉树的最大深度题目描述给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]，12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 解题思路递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res += 1 return res 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: temp = [] for node in queue: if node.left: temp.append(node.left) if node.right: temp.append(node.right) res += 1 queue = temp return res 105. 从前序与中序遍历序列构造二叉树题目描述根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ if not preorder or not inorder: return None rootval = preorder[0] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(preorder[1:index+1], inorder[:index]) root.right = self.buildTree(preorder[index+1:], inorder[index+1:]) return root 106. 从中序与后序遍历序列构造二叉树题目描述根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：12345 3 / \9 20 / \ 15 7 解题思路12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ if not inorder or not postorder: return None rootval = postorder[-1] index = inorder.index(rootval) root = TreeNode(rootval) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root 107. 二叉树的层次遍历 II题目描述给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回其自底向上的层次遍历为：12345[ [15,7], [9,20], [3]] 解题思路递归1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, 0, res) return res[::-1] def dfs(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] res = [] queue = [root] while queue: temp = [] for i in range(len(queue)): node = queue.pop(0) temp.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if temp: res.append(temp) return res[::-1] 108. 将有序数组转换为二叉搜索树题目描述将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ if len(nums) == 0: return None mid = len(nums)//2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root 110. 平衡二叉树题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7]12345 3 / \9 20 / \ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4]1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True leftdepth = self.getdepth(root.left) rightdepth = self.getdepth(root.right) if abs(leftdepth-rightdepth) &gt; 1: return False return self.isBalanced(root.left) and self.isBalanced(root.right) def getdepth(self, root): if not root: return 0 return max(self.getdepth(root.left), self.getdepth(root.right)) + 1 111. 二叉树的最小深度题目描述给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例: 给定二叉树 [3,9,20,null,null,15,7],12345 3 / \9 20 / \ 15 7 返回它的最小深度 2. 解题思路迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 queue = [root] while queue: res += 1 for i in range(len(queue)): node = queue.pop(0) if not node.left and not node.right: return res if node.left: queue.append(node.left) if node.right: queue.append(node.right) return res 递归1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def minDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if not root.left and root.right: return self.minDepth(root.right) + 1 if not root.right and root.left: return self.minDepth(root.left) + 1 return min(self.minDepth(root.left), self.minDepth(root.right)) + 1 112. 路径总和题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 解题思路递归12345678910111213141516171819# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): &quot;&quot;&quot; :type root: TreeNode :type sum: int :rtype: bool &quot;&quot;&quot; if not root: return False if not root.left and not root.right: return root.val == sum return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 回溯123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False return self.dfs(root, sum-root.val) def dfs(self, root, target): if not root: return False if target == 0 and not root.left and not root.right: return True left, right = False, False if root.left: left = self.dfs(root.left, target-root.left.val) if root.right: right = self.dfs(root.right, target-root.right.val) return left or right 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False queue = [(root, sum-root.val)] while queue: node, target = queue.pop(0) if not node: continue if not node.left and not node.right and target == 0: return True if node.left: queue.append((node.left, target-node.left.val)) if node.right: queue.append((node.right, target-node.right.val)) return False 113. 路径总和 II题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22，1234567 5 / \ 4 8 / / \ 11 13 4 / \ / \7 2 5 1 返回:1234[ [5,4,11,2], [5,8,4,5]] 解题思路回溯1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [root.val], res, sum) return res def dfs(self, root, path, res, target): if not root: return if sum(path) == target and not root.left and not root.right: res.append(path) if root.left: self.dfs(root.left, path+[root.left.val], res, target) if root.right: self.dfs(root.right, path+[root.right.val], res, target) 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] self.dfs(root, [], res, sum) return res def dfs(self, root, path, res, target): if not root: return if not root.left and not root.right and target == root.val: path.append(root.val) res.append(path) if root.left: self.dfs(root.left, path+[root.val], res, target-root.val) if root.right: self.dfs(root.right, path+[root.val], res, target-root.val) 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] #if not root.left and not root.right and root.val == sum: # return [[root.val]] #temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) #return [[root.val]+i for i in temp] res = [] if not root.left and not root.right and root.val == sum: return [[root.val]] temp = self.pathSum(root.left, sum-root.val) + self.pathSum(root.right, sum-root.val) for i in temp: res.append([root.val]+i) return res 迭代12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ if not root: return [] res = [] queue = [(root, root.val, [root.val])] while queue: node, target, temp = queue.pop(0) if not node.left and not node.right and target == sum: res.append(temp) if node.left: queue.append((node.left, target+node.left.val, temp+[node.left.val])) if node.right: queue.append((node.right, target+node.right.val, temp+[node.right.val])) return res 114. 二叉树展开为链表题目描述给定一个二叉树，原地将它展开为链表。 例如，给定二叉树12345 1 / \ 2 5 / \ \3 4 6 将其展开为：12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 解题思路先前序遍历，在讲所有节点的左子树置空，并将右子树置为下一节点。空间复杂度为O(n)。12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def flatten(self, root): """ :type root: TreeNode :rtype: void Do not return anything, modify root in-place instead. """ if not root: return root #迭代 res = [] stack = [root] while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) if node.left: stack.append(node.left) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] # 递归 res = [] self.preorder(root, res) for i in range(len(res)-1): res[i].left = None res[i].right = res[i+1] def preorder(self, root, res): if not root: return res.append(root) self.preorder(root.left, res) self.preorder(root.right, res) 116. 填充同一层的兄弟节点题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。示例: 给定完美二叉树，12345 1 / \ 2 3 / \ / \4 5 6 7 调用你的函数后，该完美二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路递归，从根节点开始找到任意节点，将其左孩子指向其右孩子，如果该节点的next节点已经指向其他节点，说明需要连接两个子树；比如2-&gt;3，需要把2的左子树4指向5，同时需要将左右子树连接起来，即5-&gt;6。 1234567891011121314151617181920# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.right: root.left.next = root.right if root.next: root.right.next = root.next.left self.connect(root.left) self.connect(root.right) 迭代。层次遍历，将队列中的元素弹出时，如果他不是最后一个元素，则将其的next节点指向队列中的下一个节点。1234567891011121314151617181920212223242526# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = [root] while queue: length = len(queue) for i in range(length): node = queue.pop(0) if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 117. 填充同一层的兄弟节点 II题目描述给定一个二叉树12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 说明: 你只能使用额外常数空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。 示例: 给定二叉树，12345 1 / \ 2 3 / \ \4 5 7 调用你的函数后，该二叉树变为：12345 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路递归。主要先右再左，因为在递归左子树的时候，需要不断寻找同层的next节点，需要保证右子树先建立好next节点。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return if root.left and root.right: root.left.next = root.right temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next elif root.left: temp = root.next while temp: if temp.left: root.left.next = temp.left; break if temp.right: root.left.next = temp.right; break temp = temp.next elif root.right: temp = root.next while temp: if temp.left: root.right.next = temp.left; break if temp.right: root.right.next = temp.right; break temp = temp.next self.connect(root.right) self.connect(root.left) 迭代。和上题思路代码一样123456789101112131415161718192021222324252627# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return queue = collections.deque() queue.append(root) while queue: length = len(queue) for i in range(length): node = queue.popleft() if i &lt; length - 1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) 129. 求根到叶子节点数字之和题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1:123456789输入: [1,2,3] 1 / \ 2 3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25. 示例 2:123456789101112输入: [4,9,0,5,1] 4 / \ 9 0 / \5 1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026. 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 self.res = 0 self.dfs(root, root.val) return self.res def dfs(self, root, path): if not root.left and not root.right: self.res += path if root.left: self.dfs(root.left, path*10+root.left.val) if root.right: self.dfs(root.right, path*10+root.right.val) 迭代。栈123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumNumbers(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 res = 0 stack = [(root, root.val)] while stack: node, val = stack.pop() if not node.left and not node.right: res += val if node.left: stack.append((root.left, val*10+root.left.val)) if node.right: stack.append((root.right, val*10+root.right.val)) return res 迭代。队列 144. 二叉树的前序遍历题目描述给定一个二叉树，返回它的 前序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, res) return res def dfs(self, root, res): if not root: return res.append(root.val) self.dfs(root.left, res) self.dfs(root.right,res) 迭代。栈12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return res 迭代。队列1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] queue = collections.deque() queue.append(root) while queue: node = queue.pop() res.append(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return res 145. 二叉树的后序遍历题目描述给定一个二叉树，返回它的 后序 遍历。 示例:12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 解题思路常规思路1 递归123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.postOrder(root, res) return res def postOrder(self, root, res): if not root: return self.postOrder(root.left, res) self.postOrder(root.right, res) res.append(root.val) 常规思路2 迭代 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] stack.append(root) while stack: node = stack.pop() if stack and node == stack[-1]: if node.right: stack.append(node.right) stack.append(node.right) if node.left: stack.append(node.left) stack.append(node.left) else: res.append(node.val) return res 思路3 借鉴前序根左右遍历的思路，按照根右左的方式遍历，最后的结果翻转即为后序遍历结果。以下为递归和非递归的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = None# 递归class Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.help(root, res) return res[::-1] def help(self, root, res): if not root: return res.append(root.val) self.help(root.right, res) self.help(root.left, res)# 非递归class Solution(object): def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] stack = [root] while stack: node = stack.pop() res.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return res[::-1] 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:123456789输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \2 3 &lt;--- \ \ 5 4 &lt;--- 解题思路递归12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.level(root, 0, res) return [res[i][-1] for i in range(len(res))] def level(self, root, level, res): if not root: return if len(res) == level: res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 迭代1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res 208. 实现 Trie (前缀树)题目描述实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例:12345678Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 truetrie.search(&quot;app&quot;); // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // 返回 true 说明: 你可以假设所有的输入都是由小写字母 a-z 构成的。 保证所有输入均为非空字符串。 解题思路字典树性质： 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符互不相同。 通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。 可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import collectionsclass Node(object): def __init__(self): self.children = collections.defaultdict(Node) self.isWord = Falseclass Trie(object): def __init__(self): """ Initialize your data structure here. """ self.root = Node() def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: None """ cur = self.root for w in word: cur = cur.children[w] cur.isWord = True def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ cur = self.root for w in word: cur = cur.children.get(w) if not cur: return False return cur.isWord def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ cur = self.root for w in prefix: cur = cur.children.get(w) if not cur: return False return True # Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) 222. 完全二叉树的节点个数题目描述给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 解题思路分治递归12345678910111213141516# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 对于一棵满二叉树，若其高度为l，则节点个数为2^l-1个节点。递归求解。 首先从根节点开始，沿左子树的左节点一路向下，得到整棵二叉树的最大深度h_l（因为是完全二叉树，所以最左侧叶节点的高度可以代表整棵树的最大高度）。 其次计算根节点右子树最左侧子节点的高度h_r。若h_l = h_r，则说明左子树为一满二叉树，可通过公式2^h_l计算其节点个数。若h_l &gt; h_r（h_l = h_r + 1），则说明右子树为满二叉树，可通过公式2^h_r计算其节点个数。 递归计算另一棵子树的节点数目。终止条件：当前节点高度为子树高度h_l，h_r均为0，说明其左右节点均为空，没有进入循环调节，即到达最后的叶节点。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def countNodes(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 h_l, h_r = 0, 0 curRoot = root.left while curRoot: h_l += 1 curRoot = curRoot.left curRoot = root.right if curRoot: h_r += 1 curRoot = curRoot.left while curRoot: h_r += 1 curRoot = curRoot.left if h_l == h_r: sum_l = 2**h_l - 1 sum_r = self.countNodes(root.right) if h_l &gt; h_r: sum_r = 2**h_r - 1 sum_l = self.countNodes(root.left) return sum_l + sum_r + 1 226. 翻转二叉树题目描述翻转一棵二叉树。 示例：1234567891011121314输入： 4 / \ 2 7 / \ / \1 3 6 9输出： 4 / \ 7 2 / \ / \9 6 3 1 解题思路12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def invertTree(self, root): """ :type root: TreeNode :rtype: TreeNode """ if not root: return root temp = root.left root.left = root.right root.right = temp self.invertTree(root.left) self.invertTree(root.right) return root 230. 二叉搜索树中第K小的元素题目描述给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。 说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。 示例 1:1234567输入: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2输出: 1 示例 2:123456789输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1输出: 3 解题思路中序遍历。12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def kthSmallest(self, root, k): """ :type root: TreeNode :type k: int :rtype: int """ if not root or k &lt;= 0: return 0 res = [] self.inorder(root, res) return res[k-1] def inorder(self, root, res): if not root: return self.inorder(root.left, res) res.append(root.val) self.inorder(root.right, res) python3的yield。1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def kthSmallest(self, root: TreeNode, k: int) -&gt; int: if not root or k &lt;= 0: return 0 iteration = self.inorder(root) res = 0 for i in range(k): res = next(iteration) return res def inorder(self, root): if root: yield from self.inorder(root.left) yield root.val yield from self.inorder(root.right) 235. 二叉搜索树的最近公共祖先题目描述给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2:123输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路首先保证p的值一定比q的小利用二叉搜索树的特性，左子树一定比根节点小，右子树一定比根节点大； p和q在root两侧，那么root就是公共祖先 pq均小于root，那么从左子树寻找 pq均大于root，那么从右子树寻找 1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if p.val &gt; q.val: p, q = q, p node = root while True: if node.val == p.val or node.val == q.val: return node elif p.val &lt; node.val &lt; q.val: return node elif q.val &lt; node.val: node = node.left else: node = node.right 可以将其看做普通的二叉树，使用236题的代码也可AC.123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root elif not left and not right: return None return left if left else right 236. 二叉树的最近公共祖先题目描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2:123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。 解题思路递归。对以root为根的树进行查找p和q 如果root为空或root==p或root==q，直接返回root，表明当前树已经查询完成； 如果当前结点不等于p或q，p和q要么分别位于左右子树中，要么同时位于左子树，或者同时位于右子树，那么我们分别来讨论： 否则对左右子树进行查找，根据左右子树的返回值进行判断： 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA 左右子树返回值均为null, p和q均不在树中, 返回null 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if not left and not right: return None elif left and right: return root else: return left if left else right 257. 二叉树的所有路径题目描述给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 / \2 3 \ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 解题思路递归1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] self.dfs(root, str(root.val), res) return res def dfs(self, root, path, res): if not root: return if not root.left and not root.right: res.append(path) return if root.left: self.dfs(root.left, path + '-&gt;' + str(root.left.val), res) if root.right: self.dfs(root.right, path + '-&gt;' + str(root.right.val), res) 迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def binaryTreePaths(self, root): """ :type root: TreeNode :rtype: List[str] """ if not root: return [] res = [] stack = [(root, str(root.val))] while stack: node, path = stack.pop(0) if not node.left and not node.right: res.append(path) if node.left: stack.append((node.left, path + '-&gt;' + str(node.left.val))) if node.right: stack.append((node.right, path + '-&gt;' + str(node.right.val))) return res 297. 二叉树的序列化与反序列化题目描述序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例:123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 提示: 这与 Leetcode 目前使用的方式一致，详情请参阅 Leetcode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 解题思路采用前序遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return '#' return str(root.val) + ',' + self.serialize(root.left) + ',' + self.serialize(root.right) def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ tree = data.split(',') return self.Tree(tree) def Tree(self, tree): if not tree: return None root = None val = tree.pop(0) if val != '#': root = TreeNode(int(val)) root.left = self.Tree(tree) root.right = self.Tree(tree) return root # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 337. 打家劫舍 III题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 示例 1:12345678910输入: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1输出: 7 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7. 示例 2:12345678910输入: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9. 解题思路对于一个以root为根节点的二叉树而言： 如果偷root节点，那么不能偷其左右子节点 如果不偷该节点，那么可以偷其左右子节点 比较两种方式的大小，取大值 递归完成，每次返回的是(偷，不偷)当前节点的值，如果偷根节点了，那么不能偷其子节点，即加上的是left[1]，和right[1]，1表示的是返回不偷该节点的值。 如果不偷根节点，那么可以偷左右子节点 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rob(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 return max(self.tryrob(root)) def tryrob(self, root): if not root: return (0, 0) left = self.tryrob(root.left) right = self.tryrob(root.right) # rob now now = root.val + left[1] + right[1] # rob later later = max(left) + max(right) return (now, later) 404. 左叶子之和题目描述计算给定二叉树的所有左叶子之和。 示例：1234567 3 / \ 9 20 / \ 15 7在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回24 解题思路递归，当遇到左叶子节点时加到和里，然后取递归右子树 否则，还没遇到左叶子节点，遍历左子树和右子树123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sumOfLeftLeaves(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 if root.left and not root.left.left and not root.left.right: return root.left.val + self.sumOfLeftLeaves(root.right) else: return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 二分查找]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是二分查找相关题目题解总结。 [TOC] 二分查找二分查找也称折半查找，它是一种效率较高的查找方法。但是折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排序。 查找过程二分查找适用于有序的顺序表。首先将表中间位置记录的关键字和查找关键字比较；如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表；如果中间位置记录的关键字大于查找关键字，则进入前一子表，否则进入后一子表；重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止。 算法要求 必须采用顺序存储结构； 必须按关键字大小有序排序。 复杂度时间复杂度O(log2n)，空间复杂度为O(1)。 中值mid的计算有两种计算中值mid的方式： mid = (left+right) // 2; mid = left + (right-left)//2left+right 可能出现加法溢出，最好使用第二种方式。 返回值 如果成功查找到key： 返回key所在的位置。 如果循环退出时仍然没有找到key，表示查找失败，有两种可能返回值： -1:以一个错误码表示没有查找到key；pos：将key插入到原列表中合适的位置。 正常实现1234567891011121314class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == key: return mid elif nums[mid] &gt; key: right = mid - 1 else: left = mid + 1 return -1 二分查找的变种二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：123456789101112131415class Solution(object): def binarySearch(self, nums, key): if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt; right: # 小于 而不是小于等于 mid = left + (right-left)//2 if nums[mid] &gt;= key: right = mid # mid 不是mid-1 else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().binarySearch([1,1,1,2,3,3,4,5,6,7],1) print(result) 与正常实现不同： right 的赋值表达式为 right = mid； 循环条件为left&lt;right; 最后返回left而不是-1。 解释： 在nums[mid] &gt;= key的情况下，可以推导出最左key位于[left,mid]区间中，right 的赋值表达式为 right = mid，因为mid位置也可能为解； 在right 的赋值表达式为 right = mid的情况下，如果循环条件为left&lt;=right，将会导致陷入死循环的情况； 当循环退出时，不表示没有查找成功，为了验证有没有查找到，应该在调用函数时判断一下返回值上的值和key是否相等。 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int divide(int dividend, int divisor) &#123; int flag = 1; if ((dividend&lt;0) != (divisor&lt;0)) flag = -1; long newDividend = Math.abs((long) dividend); long newDivisor = Math.abs((long) divisor); long res = 0; while (newDividend &gt;= newDivisor)&#123; long count = 1; long tempDivisor = newDivisor; while (tempDivisor &lt;= newDividend)&#123; res += count; newDividend -= tempDivisor; tempDivisor &lt;&lt;= 1; count &lt;&lt;= 1; &#125; &#125; if (flag == -1) res = -res; if (res &lt; Integer.MIN_VALUE || res &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; return (int)res; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int res = sol.divide(-2147483648, -1); System.out.println(res); &#125;&#125; 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 123456789101112131415161718192021222324252627282930class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return -1 34. 在排序数组中查找元素的第一个和最后一个位置题目描述给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解题思路二分查找。 当nums[mid] == target时，说明target在数组中的[left,right]中，其中开始位置在[left,mid]，结束位置在[mid,right]中； 从头遍历[left,mid]，找到第一个等于target的位置作为开始位置； 从后遍历[mid,right]，从后找到第一个等于target的位置作为结束位置； 当nums[mid] &gt; target时，right = mid-1 当nums[mid] &lt; target时，left = mid+1 12345678910111213141516171819202122232425262728293031class Solution(object): def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1,-1] left, right = 0 ,len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: temp = [] for i in range(left,mid+1): if nums[i] == target: temp.append(i) break for i in range(right, mid-1,-1): if nums[i] == target: temp.append(i) break return temp elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return [-1,-1]if __name__ == '__main__': result = Solution().searchRange([5,7,7,8,8,10],8) print(result) 35. 搜索插入位置题目描述给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1:12输入: [1,3,5,6], 5输出: 2 示例 2:12输入: [1,3,5,6], 2输出: 1 示例 3:12输入: [1,3,5,6], 7输出: 4 示例 4:12输入: [1,3,5,6], 0输出: 0 解题思路1234567891011121314151617181920212223class Solution(object): def searchInsert(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left+(right-left)//2 if nums[mid] == target: return mid elif nums[mid] &gt; target: right = mid - 1 else: left = mid + 1 return left 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: # return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4输出: 2 示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 解题思路 二分查找。一个数x的开根号一定在[1,x//2+1]之间，因为在(x//2+1)^2 &gt; x，所以我们将二分查找的终点设为x//2+1; 对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 left &lt;= right 并且循环退出时，right 总是比 left 小 1，也就是说 right = 2，left = 3，因此最后的返回值应该为 right 而不是 left。 1234567891011121314151617181920class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x == 0: return 0 if x == 1: return 1 left, right = 1, x//2+1 while left &lt;= right: mid = left + (right - left) // 2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在正式比较之前，先移动左指针，使它指向和右指针不同的数字上。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: while left &lt; right and nums[left] == nums[right]: left += 1 mid = left + (right-left)//2 if nums[mid] == target: return True if nums[mid] &lt;= nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 elif nums[mid] &gt;= nums[left]: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 153. 寻找旋转排序数组中的最小值题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 示例 2: 输入: [4,5,6,7,0,1,2]输出: 0 解题思路数组分为两个升序的数组，使用二分查找。 当nums[mid]&gt;nums[mid+1]时，最小值为nums[mid+1]; 当nums[mid]&gt;nums[right]时,left = mid+1; 当nums[mid]&gt;nums[right]时,right = mid，因为mid位置可能就是最小值了； 由于right = mid，则循环条件为left&lt;right。 1234567891011121314151617181920212223class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) == 1: return nums[0] left, right = 0, len(nums)-1 while left &lt; right: mid = left + (right-left)//2 if mid+1 &lt;= len(nums)-1 and nums[mid] &gt; nums[mid+1]: return nums[mid+1] if nums[mid] &gt; nums[right]: left = mid + 1 else: right = mid return nums[left]if __name__ == '__main__': result = Solution().findMin([4,5,6,7,0,1,2]) print(result) 二刷12345678910111213141516171819202122class Solution(object): def findMin(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if mid-1&gt;=0 and nums[mid-1] &gt; nums[mid]: return nums[mid] if nums[mid] &lt;= nums[right]: right = mid-1 else: left = mid + 1 return nums[left] 162. 寻找峰值题目描述峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1:123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2:1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 解题思路用两个mid，判断上坡还是下坡，上坡将left移到坡顶，下坡将right移到坡顶123456789101112131415161718192021class Solution(object): def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 left, right = 0, len(nums)-1 while left &lt; right: mid1 = left+(right-left)//2 mid2 = mid1 + 1 if nums[mid1] &lt; nums[mid2]: left = mid2 else: right = mid1 return left 278. 第一个错误的版本题目描述你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -false调用 isBadVersion(5) -true调用 isBadVersion(4) -true所以，4 是第一个错误的版本。 解题思路给定 n = 5，并且 version = 4 是第一个错误的版本时，输入分布为[1,2,3,4,5]，对应版本正误情况为[0,0,0,1,1]，题目要求出最靠左的1的位置。使用二分查找： 如果第mid个版本出错，则第一个出错版本在[left,mid]，有可能出现在mid位置，因此right = mid； 如果第mid个版本没错，则第一个出错版本在[mid+1,right]，因此left = mid+1; 当循环条件为left&lt;=right时，会陷入死循环。 总结：当right的赋值表达式为 right = mid 时，循环条件为 left &lt; right。 123456789101112131415161718192021222324252627# The isBadVersion API is already defined for you.# @param version, an integer# @return a booldef isBadVersion(version): if version in (1,2,3): return False elif version in (4,5): return Trueclass Solution(object): def firstBadVersion(self, n): """ :type n: int :rtype: int """ left, right = 1, n while left &lt; right: mid = left + (right-left)//2 if isBadVersion(mid): right = mid else: left = mid + 1 return leftif __name__ == '__main__': result = Solution().firstBadVersion(5) print(result) 540. 有序数组中的单一元素题目描述给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。 示例 1: 输入: [1,1,2,3,3,4,4,8,8]输出: 2 示例 2: 输入: [3,3,7,7,10,11,11]输出: 10 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。 解题思路如果题目不限制在 O(log n)时间复杂度运行，可使用异或运算。1234567891011def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = 0 for i in nums: res ^= i return res 使用二分查找法实现O(log n)时间复杂度和 O(1)空间复杂度。初始令左右指针分别为 0，len(nums)-1;当left&lt;= right时循环：mid = left+(right-left)//2 当nums[mid] == nums[mid-1]时，数组可以分为[left, mid-2], [mid+1, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-2]长度为偶数，则目标位于[mid+1, right]，令left = mid +1;当mid为偶数时，说明[left, mid-2]长度为奇数，则目标位于该数组内，令right = mid -1; 同理当nums[mid] == nums[mid+1]时，数组可以分为[left, mid-1], [mid+2, right]两部分，目标元素位于长度为奇数的子数组中; 当mid为奇数时，说明[left, mid-1]长度为奇数，则目标位于该数组内，令right = mid -1;当mid为偶数时，说明[left, mid-1]长度为偶数，则目标位于[mid+2, right]，令left = mid +1; 当nums[mid]与nums[mid - 1], nums[mid + 1]均不相等，则返回nums[mid]。 1234567891011121314151617181920212223242526class Solution(object): def singleNonDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left) //2 if mid-1 &gt;= 0 and nums[mid] == nums[mid-1]: if mid %2 == 1: left = mid + 1 else: right = mid - 2 elif mid+1 &lt;= len(nums)-1 and nums[mid] == nums[mid+1]: if mid %2 == 1: right = mid - 1 else: left = mid + 2 else: return nums[mid]if __name__ == '__main__': result = Solution().singleNonDuplicate([3,3,7,7,10,11,11]) print(result) 744. 寻找比目标字母大的最小字母题目描述给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。 数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。 示例: 输入:letters = [“c”, “f”, “j”]target = “a”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “c”输出: “f”输入:letters = [“c”, “f”, “j”]target = “d”输出: “f” 输入:letters = [“c”, “f”, “j”]target = “g”输出: “j” 输入:letters = [“c”, “f”, “j”]target = “j”输出: “c” 输入:letters = [“c”, “f”, “j”]target = “k”输出: “c” 注: letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 解题思路二分搜索。注意当有重复字母时，如[“e”,”e”,”e”,”e”,”e”,”e”,”n”,”n”,”n”,”n”],”e”，当letters[mid] 小于及 等于 target时，left都要向前走一步;如果left大于右边界时，说明target比数组里的所有字母都大，返回letters[0];否则返回letters[left]。 1234567891011121314151617181920class Solution(object): def nextGreatestLetter(self, letters, target): """ :type letters: List[str] :type target: str :rtype: str """ if len(letters) == 0: return '' left, right = 0, len(letters)-1 while left &lt;= right: mid = left + (right-left)//2 if letters[mid] &lt;= target: left = mid + 1 else: right = mid - 1 return letters[0] if left == len(letters) else letters[left]if __name__ == '__main__': result = Solution().nextGreatestLetter(["e","e","e","e","e","e","n","n","n","n"],"e") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 搜索]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是搜索相关题目题解总结。 [TOC] 搜索本文内容主要包括广度优先搜索(breadth first search)，深度优先搜索(depth first search)。 广度优先搜索(BFS)主要思想：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点依次访问它们的邻接点，并使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起点，重复上述过程，直至图中所有顶点都被访问到。 注意：遍历过的节点不能再次被遍历。 每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di &lt;= dj。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径。 实现 BFS 时需要考虑以下问题：队列：用来存储每一轮遍历得到的节点；标记：对于遍历过的节点，应该将它标记，防止重复遍历。 无向图的广度优先搜索 第1步：访问A。并将C，D，F加入到访问队列，[C,D,F] 第2步：访问C。并将 B加入到访问队列，[D,F,B] 第3步：访问D。由于D的邻接点C已经访问过，则不加入访问队列，[F,B]; 第4步：访问F。并将G加入访问队列，[B,G]; 第5步：访问B。 第6步：访问G。并将E加入到访问队列，[E]; 第7步：访问E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 有向图的广度优先搜索 访问顺序：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G 深度优先搜索(DFS)主要思想：假设初始状态所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历，直到所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作为起始点，重复上述过程，直到所有顶点都被访问到。 深度优先搜索是一个递归的过程。 从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种可达性问题。 实现 DFS 时需要考虑以下问题：栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。 无向图的深度优先搜索访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 有向图的深度优先搜索访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 参考 127. 单词接龙题目描述给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 输入:beginWord = “hit”,endWord = “cog”,wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]输出: 5解释: 一个最短转换序列是 “hit” -“hot” -“dot” -“dog” -“cog”, 返回它的长度 5。 示例 2: 输入:beginWord = “hit”endWord = “cog”wordList = [“hot”,”dot”,”dog”,”lot”,”log”]输出: 0解释: endWord “cog” 不在字典中，所以无法进行转换。 解题思路使用BFS，最短路的思路。将beginWord放进队列，如果队列不为空，那么取出第一个数，将其周围的在字典的字符放进队列，直到周围的存在endword。1234567891011121314151617181920212223242526import collectionsclass Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) queue = collections.deque() queue.append([beginWord, 1]) while queue: word, length = queue.popleft() if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i + 1:] if nextWord in wordList: wordList.remove(nextWord) queue.append([nextWord, length + 1]) return 0if __name__ == '__main__': result = Solution().ladderLength("hit","cog",["hot","dot","dog","lot","log","cog"]) print(result) 123456789101112131415161718192021222324class Solution(object): def ladderLength(self, beginWord, endWord, wordList): """ :type beginWord: str :type endWord: str :type wordList: List[str] :rtype: int """ wordList = set(wordList) stack = [(beginWord, 1)] while stack: word, length = stack.pop(0) if word == endWord: return length for i in range(len(word)): for c in 'abcdefghijklmnopqrstuvwxyz': nextWord = word[:i] + c + word[i+1:] if nextWord in wordList: wordList.remove(nextWord) stack.append((nextWord, length+1)) return 0 130. 被围绕的区域题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。 找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。 示例:1234X X X XX O O XX X O XX O X X 运行你的函数后，矩阵变为：1234X X X XX X X XX X X XX O X X 解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 解题思路从边上开始搜索，如果是’O’,那么搜索’O’周围的元素，并将’O’置换为’D’。如果该’O’周围都是’X’，则会跳出，这样内部的’O’将不受影响。最后没有被’X’围住的’O’都置换成了’D’,被围住的’O’还是’O’，没有改变。然后遍历一遍，将’O’置换为’X’，将’D’置换为’O’。 在Leetcode中文网站无法提交，英文网站正常。 迭代 BFS。123456789101112131415161718192021222324252627class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ import collections queue = collections.deque([]) for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board) - 1] or c in [0, len(board[0]) - 1]) and board[r][c] == "O": queue.append((r, c)) while queue: r, c = queue.popleft() if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == "O": board[r][c] = "D" queue.append((r - 1, c)) queue.append((r + 1, c)) queue.append((r, c - 1)) queue.append((r, c + 1)) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == "O": board[r][c] = "X" elif board[r][c] == "D": board[r][c] = "O" 递归 DFS1234567891011121314151617181920212223class Solution(object): def solve(self, board): """ :type board: List[List[str]] :rtype: void Do not return anything, modify board in-place instead. """ for r in range(len(board)): for c in range(len(board[0])): if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O': self.dfs(board, r, c) for r in range(len(board)): for c in range(len(board[0])): if board[r][c] == 'O': board[r][c] = 'X' elif board[r][c] == 'D': board[r][c] = 'O' def dfs(self, board, r, c): if 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] == 'O': board[r][c] = 'D' self.dfs(board, r-1, c) self.dfs(board, r+1, c) self.dfs(board, r, c-1) self.dfs(board, r, c+1) 133. 克隆图题目描述克隆一张无向图，图中的每个节点包含一个 label （标签）和一个 neighbors （邻接点）列表 。 OJ的无向图序列化： 节点被唯一标记。 我们用 # 作为每个节点的分隔符，用 , 作为节点标签和邻接点的分隔符。 例如，序列化无向图 {0,1,2#1,2#2,2}。 该图总共有三个节点, 被两个分隔符 # 分为三部分。 第一个节点的标签为 0，存在从节点 0 到节点 1 和节点 2 的两条边。 第二个节点的标签为 1，存在从节点 1 到节点 2 的一条边。 第三个节点的标签为 2，存在从节点 2 到节点 2 (本身) 的一条边，从而形成自环。 我们将图形可视化如下： 解题思路由于遍历一个图有两种方式：bfs和dfs。所以深拷贝一个图也可以采用这两种方法。不管使用dfs还是bfs都需要一个哈希表map来存储原图中的节点和新图中的节点的一一映射。map的作用在于替代bfs和dfs中的visit数组，一旦map中出现了映射关系，就说明已经复制完成，也就是已经访问过了。 BFS12345678910111213141516171819202122232425262728# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None queue = [] dic = &#123;&#125; newhead = UndirectedGraphNode(node.label) dic[node] = newhead queue.append(node) while queue: curr = queue.pop() for neighbor in curr.neighbors: if neighbor not in dic: copy = UndirectedGraphNode(neighbor.label) dic[curr].neighbors.append(copy) dic[neighbor] = copy queue.append(neighbor) else: dic[curr].neighbors.append(dic[neighbor]) return newhead DFS12345678910111213141516171819202122# Definition for a undirected graph node# class UndirectedGraphNode:# def __init__(self, x):# self.label = x# self.neighbors = []class Solution: # @param node, a undirected graph node # @return a undirected graph node def cloneGraph(self, node): if not node: return None return self.dfs(node, &#123;&#125;) def dfs(self, input, dic): if input in dic: return dic[input] output = UndirectedGraphNode(input.label) dic[input] = output for neighbor in input.neighbors: output.neighbors.append(self.dfs(neighbor, dic)) return output 199. 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例:输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 解题思路按层次遍历，没层取最右边元素。 BFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] queue = [root] res = [] while queue: temp = [] for i in range(len(queue)): cur = queue.pop(0) temp.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) if temp: res.append(temp[-1]) return res DFS1234567891011121314151617181920212223242526272829# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def rightSideView(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] res = [] self.dfs(root, 0, res) return [level[-1] for level in res] def dfs(self, root, level, res): if not root: return [] if level == len(res): res.append([]) res[level].append(root.val) if root.left: self.dfs(root.left, level+1, res) if root.right: self.dfs(root.right, level+1, res) 200. 岛屿的个数题目描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 解题思路给定由0和1组成的二维数组，求1的连通块。 BFS 超时12345678910111213141516171819202122232425262728class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.bfs(grid, i, j) count += 1 return count def bfs(self, grid, i, j): queue = collections.deque() queue.append((i,j)) grid[i][j] = '#' direction = [(0,1), (0,-1), (1,0), (-1,0)] while queue: i, j = queue.popleft() for d in direction: r, c = i + d[0], i + d[1] if 0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0]) and grid[r][c] == '1': grid[r][c] == '#' queue.append((r, c)) DFS12345678910111213141516171819202122class Solution(object): def numIslands(self, grid): """ :type grid: List[List[str]] :rtype: int """ if len(grid) == 0: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': self.dfs(grid, i, j) count += 1 return count def dfs(self, grid, i, j): if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0]) and grid[i][j] == '1': grid[i][j] = '#' self.dfs(grid, i-1, j) self.dfs(grid, i+1, j) self.dfs(grid, i, j-1) self.dfs(grid, i, j+1) 207. 课程表题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: **输入:** 2, [[1,0]] **输出: **true **解释:** 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: **输入:** 2, [[1,0],[0,1]] **输出: **false **解释:** 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 解题思路使用拓扑排序。在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件： 每个顶点出现且只出现一次。 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。 有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。 BFS方法：我们开始先根据输入来建立这个有向图，并将入度数组也初始化好。然后我们定义一个 queue 变量，将所有入度为0的点放入队列中，然后开始遍历队列，从 graph 里遍历其连接的点，每到达一个新节点，将其入度减一，如果此时该点入度为0，则放入队列末尾。直到遍历完队列中所有的值，若此时还有节点的入度不为0，则说明环存在，返回 false，反之则返回 true。 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ graph = collections.defaultdict(list) indegree = [0] * numCourses # 使用邻接表存储图 for u, v in prerequisites: graph[v].append(u) indegree[u] += 1 # 保存入度为0的课表 queue = [] for i in range(numCourses): if indegree[i] == 0: queue.append(i) while queue: node = queue.pop(0) if node not in graph: continue for i in graph[node]: indegree[i] -= 1 if indegree[i] == 0: queue.append(i) for i in range(numCourses): if indegree[i] != 0: return False return True DFS：这个方法是，我们每次找到一个新的点，判断从这个点出发是否有环。具体做法是使用一个visited数组，当visited[i]值为0，说明还没判断这个点；当visited[i]值为1，说明当前的循环正在判断这个点；当visited[i]值为2，说明已经判断过这个点，含义是从这个点往后的所有路径都没有环，认为这个点是安全的。 那么，我们对每个点出发都做这个判断，检查这个点出发的所有路径上是否有环，如果判断过程中找到了当前的正在判断的路径，说明有环；找到了已经判断正常的点，说明往后都不可能存在环，所以认为当前的节点也是安全的。如果当前点是未知状态，那么先把当前点标记成正在访问状态，然后找后续的节点，直到找到安全的节点为止。最后如果到达了无路可走的状态，说明当前节点是安全的。1234567891011121314151617181920212223242526272829303132class Solution(object): def canFinish(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: bool """ graph = collections.defaultdict(list) # 使用邻接表存储图 for u, v in prerequisites: graph[v].append(u) visited = [0] * numCourses for i in range(numCourses): if not self.judge(graph, visited, i): return False return True def judge(self, graph, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.judge(graph, visited, j): return False visited[i] = 2 return True 210. 课程表 II题目描述现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1:123**输入:** 2, [[1,0]] **输出: **[0,1]**解释:** 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152**输入:** 4, [[1,0],[2,0],[3,1],[3,2]]**输出: **[0,1,2,3] or [0,2,1,3]**解释:** 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。``` **说明:**1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。2. 你可以假定输入的先决条件中没有重复的边。**提示:**1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&amp;amp;fromid=2148012&amp;amp;fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2) 完成。### 解题思路拓扑排序BFS```pythonimport collectionsclass Solution(object): def findOrder(self, numCourses, prerequisites): &quot;&quot;&quot; :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] &quot;&quot;&quot; graph = collections.defaultdict(list) indegrees = [0] * numCourses for u, v in prerequisites: graph[v].append(u) indegrees[u] += 1 queue = [] for i in range(numCourses): if indegrees[i] == 0: queue.append(i) res = [] while queue: node = queue.pop(0) res.append(node) for t in graph[node]: indegrees[t] -= 1 if indegrees[t] == 0: queue.append(t) return res if len(res) == numCourses else [] DFS1234567891011121314151617181920212223242526272829303132333435import collectionsclass Solution(object): def findOrder(self, numCourses, prerequisites): """ :type numCourses: int :type prerequisites: List[List[int]] :rtype: List[int] """ graph = collections.defaultdict(list) for u, v in prerequisites: graph[v].append(u) res = [] visited = [0] * numCourses for i in range(numCourses): if not self.judge(graph, visited, i, res): return [] return res[::-1] if len(res) == numCourses else [] def judge(self, graph, visited, i, res): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.judge(graph, visited, j, res): return False visited[i] = 2 res.append(i) return True 279. 完全平方数题目描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1: 输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2： 输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路使用DFS，如n=12，首先计算出可能存在的平方数candidate = [1,4,9]，然后对当前残差及candidate进行遍历，直到残差等于candidate，则返回。 123456789101112131415161718192021222324252627282930313233class Solution: def numSquares(self, n): """ :type n: int :rtype: int """ if n &lt; 0: return 0 if n &lt;= 1: return 1 candidate = [] i = 1 while i*i &lt;= n: candidate.append(i*i) i += 1 count = 0 toCheck = &#123;n&#125; while toCheck: count += 1 temp = set() for residue in toCheck: for cand in candidate: if residue == cand: return count if residue &lt; cand: break temp.add(residue-cand) toCheck = temp return countif __name__ == '__main__': result = Solution().numSquares(12) print(result) 547. 朋友圈题目描述班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1:1234567输入: [[1,1,0], [1,1,0], [0,0,1]]输出: 2 说明：已知学生0和学生1互为朋友，他们在一个朋友圈。第2个学生自己在一个朋友圈。所以返回2。 示例 2:123456输入: [[1,1,0], [1,1,1], [0,1,1]]输出: 1说明：已知学生0和学生1互为朋友，学生1和学生2互为朋友，所以学生0和学生2也是朋友，所以他们三个在一个朋友圈，返回1。 注意：123N 在[1,200]的范围内。对于所有学生，有M[i][i] = 1。如果有M[i][j] = 1，则有M[j][i] = 1。 解题思路思路1 DFS1234567891011121314151617181920212223class Solution(object): def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ if len(M) == 0: return 0 res = 0 visited = [False]*len(M) for i in range(len(M)): if not visited[i]: res += 1 self.dfs(M, i, visited) return res def dfs(self, M, i, visited): visited[i] = True for j in range(len(M)): if M[i][j] == 1 and not visited[j]: self.dfs(M, j, visited) 思路2 并查集 核心思想是初始时给每一个对象都赋上不同的标签，然后对于属于同一类的对象，在root中查找其标签，如果不同，那么将其中一个对象的标签赋值给另一个对象，注意root数组中的数字跟数字的坐标是有很大关系的，root存的是属于同一组的另一个对象的坐标，这样通过getRoot函数可以使同一个组的对象返回相同的值。 123456789101112131415161718192021222324252627282930class Solution(object): def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ if len(M) == 0: return 0 res = len(M) root = [0] * len(M) for i in range(len(M)): root[i] = i for i in range(len(M)): for j in range(i+1, len(M)): if M[i][j] == 1: p1 = self.getRoot(root, i) p2 = self.getRoot(root, j) if p1!=p2: res -= 1 root[p2] = p1 return res def getRoot(self, root, i): while i != root[i]: root[i] = root[root[i]] i = root[i] return i]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 栈和队列]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是栈和队列相关题目题解总结。 [TOC] 栈和队列栈的顺序为后进先出，队列 的顺序为先进先出。 20. 有效的括号题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1:12输入: &quot;()&quot;输出: true 示例 2:12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:12输入: &quot;(]&quot;输出: false 示例 4:12输入: &quot;([)]&quot;输出: false 示例 5:12输入: &quot;&#123;[]&#125;&quot;输出: true 解题思路使用栈，遍历字符串，当栈为空或者当前字符为左括号’(‘,’[‘,’{‘时或者为右括号但是栈顶字符与其不匹配，则将字符加入栈，否则栈顶字符出栈。最后判断栈是否为空。12345678910111213141516class Solution(object): def isValid(self, s): """ :type s: str :rtype: bool """ if not s: return True Dict = &#123;')':'(', '&#125;':'&#123;', ']':'['&#125; stack = [] for c in s: if not stack or c not in Dict or stack[-1] != Dict[c]: stack.append(c) else: stack.pop() return True if not stack else False 71. 简化路径题目描述以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径 请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。 示例 1：123输入：&quot;/home/&quot;输出：&quot;/home&quot;解释：注意，最后一个目录名后面没有斜杠。 示例 2：123输入：&quot;/../&quot;输出：&quot;/&quot;解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。 示例 3：123输入：&quot;/home//foo/&quot;输出：&quot;/home/foo&quot;解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。 示例 4：12输入：&quot;/a/./b/../../c/&quot;输出：&quot;/c&quot; 示例 5：12输入：&quot;/a/../../b/../c//.//&quot;输出：&quot;/c&quot; 示例 6：12输入：&quot;/a//b////c/d//././/..&quot;输出：&quot;/a/b/c&quot; 解题思路将字符串按照‘/‘分隔得到了每个文件的目录，然后遍历每个目录进行入栈或者出栈。如果目录为空或者为当前目录’.’，则不进行任何操作；如果为’..’，表示返回上一级目录，如果栈中有上级目录，则将其弹出。 12345678910111213141516171819class Solution(object): def simplifyPath(self, path): """ :type path: str :rtype: str """ if not path: return '/' stack = [] path = path.split('/') for c in path: if not c or c == '.': continue if c == '..': if stack: stack.pop() else: stack.append(c) return '/'+'/'.join(stack) 84. 柱状图中最大的矩形题目描述给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3]输出: 10 解题思路使用一个递增单调栈，栈中保存坐标，数组中坐标依次入栈，当当前坐标的值小于栈顶坐标的值，则栈顶坐标弹出，并计算弹出坐标的面积，它的右边界是当前坐标的值（因为当前坐标让它出栈），左边界是栈顶坐标（当栈为空时为-1）。当数组遍历完成后，栈不为空，则依次弹出，计算弹出坐标的面积，右边界是数组长度，左边界是栈顶坐标（当栈为空时为-1）。 例如：[2,1,5,6,2,3]先将2的坐标入栈，栈为[0]；元素1的坐标1入栈前比较，因为1位置的元素比栈顶(0)位置的元素小，则位置0出栈，栈为空，计算0位置的面积(1-(-1)-1)*2=2，在将1入栈，栈为[1]；坐标2的元素5大于栈顶位置元素(1)，则坐标2入栈，栈为[1,2]；坐标3的元素6大于栈顶位置元素(5)，则坐标3入栈，栈为[1,2,3]；坐标4的元素2小于栈顶位置元素(6)，则将栈顶位置3弹出，栈为[1,2]，计算3位置的面积(4-2-1)*6 = 6，此时2依然小于栈顶位置2的元素5，则栈顶位置2出栈，栈为[1]，计算2位置的面积(4-1-1)*5=10；此时2大于栈顶位置元素，则2的坐标4入栈，栈为[1,4]；坐标5的元素3大于栈顶位置元素(2)，坐标5入栈，栈为[1,4,5]；数组遍历完成。 此时栈不为空，依次弹出计算面积。弹出位置5，栈为[1,4]，面积为(6-4-1)*3=3;弹出位置4，栈为[1]，面积为(6-1-1)*2=8;弹出位置1，栈为空，面积为(6-(-1)-1)*1=6;所以最大面积为max(2,6,10,3,8,6)=10。 123456789101112131415161718192021222324class Solution(object): def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i-left-1)*heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1)*heights[index]) return res 85. 最大矩形题目描述给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例:12345678输入:[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]输出: 6 解题思路使用一个辅助数组，大小为矩阵列宽，依次以矩阵每一行为底计算最大面积，直接调用上一题的代码计算。辅助数组计算方法：初始化为0，当当前元素为1是，高度加1，为0时直接为0。例如上例：第一行 [1 0 1 0 0]第二行 [2 0 2 1 1]第三行 [3 1 3 2 2]第四行 [4 0 0 3 0] 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def maximalRectangle(self, matrix): """ :type matrix: List[List[str]] :rtype: int """ if len(matrix) == 0: return 0 heights = [0] * len(matrix[0]) res = 0 for i in range(len(matrix)): for j in range(len(matrix[0])): heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0 res = max(res, self.largestRectangleArea(heights)) return res def largestRectangleArea(self, heights): """ :type heights: List[int] :rtype: int """ if len(heights) == 0: return 0 res = 0 stack = [] for i in range(len(heights)): while stack and heights[i] &lt; heights[stack[-1]]: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (i - left - 1) * heights[index]) stack.append(i) while stack: index = stack.pop() left = stack[-1] if stack else -1 res = max(res, (len(heights) - left - 1) * heights[index]) return res 150. 逆波兰表达式求值题目描述根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1：123输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9 示例 2：123输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6 示例 3：12345678910输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路在python中，(-1)/2=-1，而在c语言中，(-1)/2=0。也就是c语言中，除法是向零取整，即舍弃小数点后的数。而在python中，是向下取整的。而这道题的oj是默认的c语言中的语法，所以需要在遇到’/’的时候注意一下。 12345678910111213141516171819202122232425class Solution(object): def evalRPN(self, tokens): """ :type tokens: List[str] :rtype: int """ stack = [] for c in tokens: if c not in ('+','-','*','/'): stack.append(c) else: a = int(stack.pop()) b = int(stack.pop()) if c == '+': stack.append(str(b+a)) if c == '-': stack.append(str(b-a)) if c == '*': stack.append(str(b*a)) if c == '/': if b*a &lt; 0 and b%a != 0: stack.append(str(b/a+1)) else: stack.append(str(b/a)) return int(stack[0]) 155. 最小栈题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) — 将元素 x 推入栈中。 pop() — 删除栈顶的元素。 top() — 获取栈顶元素。 getMin() — 检索栈中的最小元素。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MinStack(object): def __init__(self): """ initialize your data structure here. """ self.data = [] self.min = [] def push(self, x): """ :type x: int :rtype: void """ self.data.append(x) if not self.min or x &lt;= self.min[-1]: self.min.append(x) def pop(self): """ :rtype: void """ val = self.data.pop() if val == self.min[-1]: self.min.pop() def top(self): """ :rtype: int """ return self.data[-1] def getMin(self): """ :rtype: int """ return self.min[-1] # Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.getMin() 224. 基本计算器题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。 示例 1:12输入: &quot;1 + 1&quot;输出: 2 示例 2:12输入: &quot; 2-1 + 2 &quot;输出: 3 示例 3:12输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;输出: 23 说明： 你可以假设所给定的表达式都是有效的。请不要使用内置的库函数 eval。 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 if len(s) == 1: return int(s[0]) stack = [] i = 0 while i &lt; len(s): if s[i] == ')': helpStack = [] while stack and stack[-1] != '(': helpStack.insert(0, stack.pop()) stack.pop() stack.append(self.help(helpStack)) elif s[i] in "+-(": stack.append(s[i]) elif s[i] in "0123456789": num = 0 while i &lt; len(s) and s[i] not in ['+', '-', '(', ')', ' ']: num = num * 10 + int(s[i]) i += 1 i -= 1 stack.append(num) i += 1 if len(stack) != 1: stack.append(self.help(stack)) return stack[0] def compute(self, b, op, a): if op == '+': return b + a elif op == '-': return b - a def help(self, stack): if len(stack) == 1: return int(stack[0]) while len(stack) &gt;= 3: a = int(stack.pop(0)) op = stack.pop(0) b = int(stack.pop(0)) stack.insert(0, self.compute(a, op, b)) return stack[0] 225. 用队列实现栈题目描述使用队列实现栈的下列操作：1234push(x) -- 元素 x 入栈pop() -- 移除栈顶元素top() -- 获取栈顶元素empty() -- 返回栈是否为空 注意: 你只能使用队列的基本操作— 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路使用一个队列，每次新元素进队列的时候，先把当前的数字进入队列，然后把它前面的所有的元素移到新进队的后面。 例如：1进队列， [1] -&gt; [1]2进队列, [1,2] -&gt;[2,1]3进队列, [2,1,3] -&gt;[3,2,1]4进队列, [3,2,1,4] -&gt;[4,3,2,1] 栈顶为第一个元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyStack(object): def __init__(self): """ Initialize your data structure here. """ self.queue = collections.deque() def push(self, x): """ Push element x onto stack. :type x: int :rtype: None """ self.queue.append(x) for i in range(len(self.queue)-1): self.queue.append(self.queue.popleft()) def pop(self): """ Removes the element on top of the stack and returns that element. :rtype: int """ return self.queue.popleft() def top(self): """ Get the top element. :rtype: int """ return self.queue[0] def empty(self): """ Returns whether the stack is empty. :rtype: bool """ return len(self.queue) == 0# Your MyStack object will be instantiated and called as such:# obj = MyStack()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.top()# param_4 = obj.empty() 232. 用栈实现队列题目描述使用栈实现队列的下列操作： push(x) — 将一个元素放入队列的尾部。pop() — 从队列首部移除元素。peek() — 返回队列首部的元素。empty() — 返回队列是否为空。示例:1234567MyQueue queue = new MyQueue();queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false 说明: 你只能使用标准的栈操作 — 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class MyQueue(object): def __init__(self): """ Initialize your data structure here. """ self.stack1 = [] self.stack2 = [] def push(self, x): """ Push element x to the back of queue. :type x: int :rtype: None """ self.stack1.append(x) def pop(self): """ Removes the element from in front of queue and returns that element. :rtype: int """ if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): """ Get the front element. :rtype: int """ if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def empty(self): """ Returns whether the queue is empty. :rtype: bool """ return not self.stack1 and not self.stack2 # Your MyQueue object will be instantiated and called as such:# obj = MyQueue()# obj.push(x)# param_2 = obj.pop()# param_3 = obj.peek()# param_4 = obj.empty()]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 字符串]]></title>
    <url>%2F2019%2F07%2F17%2FLeetCode%2FLeetcode-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是字符串相关题目题解总结。 [TOC] 5. 最长回文子串题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 解题思路暴力解决123456789101112131415161718class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s maxlen = 0 start = 0 for i in range(len(s)): for j in range(i+1, len(s)+1): if s[i:j] == s[i:j][::-1] and j-i &gt; maxlen: maxlen = j-i start = i if maxlen &gt; 0: return s[start:start+maxlen] return '' 动态规划 动态规划有两个特点：将大问题拆解为小问题，利用之前的计算结果。 例子：”babad”新建dp二维数组,$dp[i][j]=1$时则说明第i到第j为回文子串。12345[[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] 首先计算长度为1的子串，必定是回文； 然后判断长度为2的子串，根据相等与否判断是否为回文； 到长度为3时，就可以利用上次的计算结果： 如果中心对称的短字符串(去掉头尾，此时只有第2个位置的一个字符)是回文，且如果第1和第3个位置相等，则长字符串也是回文；如果第1和第3个位置不相等，则长字符串不是回文； 如果中心对称的短字符串(去掉头尾)不是回文，则长字符串也不是回文； 一直遍历到长度最长的字符串。 即当i=j+1时相邻是为长度为2的情况，当i-j &gt; 2时为长度为3的情况，递推式为：$dp[i][i] = 1$$dp[j][i] = (s[i] == s[j]) \&amp; (i-j&lt;=2 | dp[j + 1][i - 1])$ 12345678910111213141516171819class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) &lt; 2: return s dp = [[0]*len(s) for _ in range(len(s))] start, end, maxlen = 0, 0, 0 for i in range(len(s)): for j in range(i): dp[j][i] = (s[i]==s[j]) &amp; ((i-j&lt;=2) | dp[j+1][i-1]) if dp[j][i] and maxlen &lt; i-j+1: maxlen = i-j+1 start = j end = i dp[i][i] = 1 return s[start:end+1] Manacher算法 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ if len(s) == 0: return '' s = self.init(s) p = [0] * len(s) id = -1 # 记录最右回文子串的中心 mx = -1 res = 0 maxCenter = 0 # 记录最长回文子串的中心 for i in range(len(s)): p[i] = min(p[2*id-i], mx-i) if i &lt; mx else 1 while i + p[i] &lt; len(s) and i - p[i] &gt; -1: if s[i+p[i]] == s[i-p[i]]: p[i] += 1 else: break if i + p[i] &gt; mx: mx = i + p[i] id = i if p[i] &gt; res: maxCenter = i res = p[i] return ''.join(s[center-(res-1):center+res-1+1].split('#')) def init(self, s): res = '#' for i in range(len(s)): res += s[i] res += '#' return res` 6. Z 字形变换题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LeetcodeISHIRING” 行数为 3 时，排列如下：123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数：1string convert(string s, int numRows); 示例 1:12输入: s = &quot;LeetcodeISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:12345678输入: s = &quot;LeetcodeISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 解题思路将字符分为numRows保存，遍历字符串，从上到下和从下到上反复将字符加到对应的行里，当遍历到第一行时，index递增，当遍历到最后一行时，index递减。 12345678910111213141516171819202122232425class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1 or numRows &gt;= len(s): return s res = ['' for i in range(numRows)] index = 0 step = 1 for x in s: res[index] += x if index == 0: step = 1 elif index == numRows-1: step = -1 index += step return ''.join(res) 10. 正则表达式匹配题目描述给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 &#39;*&#39; 的正则表达式匹配。123&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明:12s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 解题思路以下超时，剑指中可以通过。 我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑&#39;*&#39;：如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符&#39;*&#39;考虑进去，它可以匹配任意次的字符，当然出现0次也可以：而当模式中的第二个字符是*时：如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 模式后移2字符，相当于x*被忽略； 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符’.’的情况。 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为’.’的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 1234567891011121314151617181920212223class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if not s and not p: return True if not p: return False if len(p) &gt;= 2 and p[1] == "*": if s and (s[0] == p[0] or p[0] == "."): return self.isMatch(s[1:], p[2:]) or self.isMatch(s, p[2:]) or self.isMatch(s[1:], p) else: return self.isMatch(s, p[2:]) else: if s and (s[0] == p[0] or p[0] == "."): return self.isMatch(s[1:],p[1:]) return False 动态规划AC1234定义一个二维的DP数组，其中dp[i][j]表示s[0,i)和p[0,j)是否match，然后有下面三种情况:1. P[i][j] = P[i - 1][j - 1], if p[j - 1] != &apos;*&apos; &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == &apos;.&apos;);2. P[i][j] = P[i][j - 2], if p[j - 1] == &apos;*&apos; and the pattern repeats for 0 times;3. P[i][j] = P[i - 1][j] &amp;&amp; (s[i - 1] == p[j - 2] || p[j - 2] == &apos;.&apos;), if p[j - 1] == &apos;*&apos; and the pattern repeats for at least 1 times. 参考 https://www.cnblogs.com/grandyang/p/4461713.html123456789101112131415161718192021222324class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if not s and not p: return True if not p: return False dp = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[0][0] = True for i in range(len(s)+1): for j in range(1, len(p)+1): if j&gt;1 and p[j-1] == '*': dp[i][j] = (dp[i][j-2]) or (i&gt;0 and dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.')) else: dp[i][j] = (i &gt; 0) and dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.') return dp[-1][-1] 14. 最长公共前缀题目描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 解题思路首先把第一个字符串作为答案，然后遍历后面的字符串，当后面的字符串长度小于第一个字符串时，需要对第一个字符串进行裁剪，然后依次判断每一个字符是否相等，不相等时将第一个字符串裁剪。 12345678910111213141516171819202122class Solution(object): def longestCommonPrefix(self, strs): """ :type strs: List[str] :rtype: str """ if len(strs) == 0: return '' res = strs[0] for i in range(1, len(strs)): if len(res) &gt; len(strs[i]): res = res[:len(strs[i])] for j in range(len(res)): if res[j] != strs[i][j]: res = res[:j] break if res == '': return '' return res 30. 串联所有单词的子串题目描述给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1：1234567输入： s = &quot;barfoothefoobarman&quot;, words = [&quot;foo&quot;,&quot;bar&quot;]输出：[0,9]解释：从索引 0 和 9 开始的子串分别是 &quot;barfoor&quot; 和 &quot;foobar&quot; 。输出的顺序不重要, [9,0] 也是有效答案。 示例 2：1234输入： s = &quot;wordgoodgoodgoodbestword&quot;, words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]输出：[] 解题思路用一个Map记录words中每个单词出现的次数。遍历s，对于每一个位置进行判断。 12345678910111213141516171819202122232425262728293031323334class Solution(object): def findSubstring(self, s, words): """ :type s: str :type words: List[str] :rtype: List[int] """ if not s or not words: return [] wordBag = &#123;&#125; for x in words: wordBag[x] = wordBag.get(x, 0) + 1 wordLen, numWords = len(words[0]), len(words), totalLen = wordLen * numWords res = [] for i in range(len(s) - totalLen + 1): seen = wordBag.copy() #深拷贝 for j in range(i, i + totalLen, wordLen): curWord = s[j:j + wordLen] if curWord in wordBag: seen[curWord] -= 1 if seen[curWord] &lt; 0: seen[curWord] = float('-inf') # 避免 [0,-1,1] sum(seen.values()) == 0 的情况 break else: break if sum(seen.values()) == 0: res.append(i) return res 32. 最长有效括号题目描述给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例 1:123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2:123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 解题思路思路一：遍历每个位置为起点，将’(‘看成1， ‘)’看成-1，如果和为0说明是有效括号，判断长度，如果和为负数，则说明一定无法构成有效括号，因为左边一定会多了一个’)’。 Python超时，JavaAC。123456789101112131415161718class Solution(object): def longestValidParentheses(self, s): """ :type s: str :rtype: int """ res = 0 for i in range(len(s)): num = 0 for j in range(i, len(s)): num += 1 if s[j] == '(' else -1 if num == 0 and res &lt; j-i+1: res = j-i+1 elif num &lt; 0: break return res 12345678910111213141516171819202122class Solution &#123; public int longestValidParentheses(String s) &#123; char[] array = s.toCharArray(); int num = 0; int res = 0; for (int i = 0; i&lt;array.length; i++)&#123; num = 0; for (int j = i; j&lt;array.length; j++)&#123; int temp = array[j] == '('?1:-1; num += temp; if (num == 0 &amp;&amp; res &lt; j-i+1)&#123; res = j-i+1; &#125; else if (num&lt;0)&#123; break; &#125; &#125; &#125; return res; &#125;&#125; 思路2：动态规划新建一个dp数组，数组的每个位置表示包含该位置及之前的所有字符所形成的有效括号的长度。从第二个下标开始遍历，当S[i]=’)’及S[i-1]=’(‘，形成一个有效括号长度加2。当S[i]=’)’及S[i-1]=’)’，判断S[i-1]形成的有效括号的前一位是否为’(‘，即S[i-dp[i-1]-1]是否为’(‘，如果是，则S[i-dp[i-1]-1]=’(‘和S[i]=’)’之间为有效括号，长度为dp[i-1]+2，然后再加上i-dp[i-1]-1的前一位i-dp[i-1]-2所形成的的有效括号数dp[i-dp[i-1]-2]. 123456789101112131415161718192021222324class Solution(object): def longestValidParentheses(self, s): """ :type s: str :rtype: int """ if len(s) &lt;= 1: return 0 dp = [0] * len(s) res = 0 for i in range(1, len(s)): if s[i] == ')': if s[i - 1] == '(': dp[i] = dp[i - 2] + 2 if i - 2 &gt;= 0 else 2 res = max(res, dp[i]) else: if i - dp[i - 1] - 1 &gt;= 0 and s[i - dp[i - 1] - 1] == '(': dp[i] = dp[i - 1] + 2 if i - dp[i - 1] - 2 &gt;= 0: dp[i] += dp[i - dp[i - 1] - 2] res = max(res, dp[i]) return res 38. 报数题目描述报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：123451. 12. 113. 214. 12115. 111221 1 被读作 “one 1” (“一个一”) , 即 11。 11 被读作 “two 1s” (“两个一”）, 即 21。 21 被读作 “one 2”, “one 1” （”一个二” , “一个一”) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1:12输入: 1输出: &quot;1&quot; 示例 2:12输入: 4输出: &quot;1211&quot; 解题思路1234567891011121314151617181920212223class Solution(object): def countAndSay(self, n): """ :type n: int :rtype: str """ if n == 1: return '1' pre = '1' for i in range(1, n): count = 1 res = '' for j in range(1, len(pre)): if pre[j] == pre[j-1]: count += 1 else: res += str(count) + pre[j-1] count = 1 res += str(count) + pre[-1] pre = res return res 44. 通配符匹配题目描述给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ‘?’ 和 ‘*’ 的通配符匹配。12&apos;?&apos; 可以匹配任何单个字符。&apos;*&apos; 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明:12s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &apos;*&apos; 可以匹配任意字符串。 示例 3:12345输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &apos;?&apos; 可以匹配 &apos;c&apos;, 但第二个 &apos;a&apos; 无法匹配 &apos;b&apos;。 示例 4:12345输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &apos;*&apos; 可以匹配空字符串, 第二个 &apos;*&apos; 可以匹配字符串 &quot;dce&quot;. 示例 5:1234输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输出: false 解题思路参考 这道题通配符外卡匹配问题还是小有难度的，有特殊字符 ‘’ 和 ‘?’，其中 ‘?’ 能代替任何字符，‘’ 能代替任何字符串，注意跟另一道 Regular Expression Matching 正则匹配的题目区分开来。两道题的星号的作用是不同的，注意对比区分一下。这道题最大的难点，就是对于星号的处理，可以匹配任意字符串，简直像开了挂一样，就是说在星号对应位置之前，不管你s中有任何字符串，我大星号都能匹配你，主角光环啊。但即便叼如斯的星号，也有其处理不了的问题，那就是一旦p中有s中不存在的字符，那么一定无法匹配，因为星号只能增加字符，不能消除字符，再有就是星号一旦确定了要匹配的字符串，对于星号位置后面的匹配情况也就鞭长莫及了。所以p串中星号的位置很重要，用 jStar 来表示，还有星号匹配到s串中的位置，使用 iStart 来表示，这里 iStar 和 jStar 均初始化为 -1，表示默认情况下是没有星号的。然后再用两个变量i和j分别指向当前s串和p串中遍历到的位置。 开始进行匹配，若i小于s串的长度，进行 while 循环。若当前两个字符相等，或着p中的字符是问号，则i和j分别加1。若 p[j] 是星号，那么我们要记录星号的位置，jStar 赋为j，此时j再自增1，iStar 赋为i。若当前 p[j] 不是星号，并且不能跟 p[i] 匹配上，那么此时就要靠星号了，若之前星号没出现过，那么就直接跪，比如 s = “aa” 和 p = “c“，此时 s[0] 和 p[0] 无法匹配，虽然 p[1] 是星号，但还是跪。如果星号之前出现过，可以强行续一波命，比如 s = “aa” 和 p = “c”，当发现 s[1] 和 p[1] 无法匹配时，但是好在之前 p[0] 出现了星号，我们把 s[1] 交给 p[0] 的星号去匹配。至于如何知道之前有没有星号，这时就能看出 iStar 的作用了，因为其初始化为 -1，而遇到星号时，其就会被更新为i，那么我们只要检测 iStar 的值，就能知道是否可以使用星号续命。虽然成功续了命，匹配完了s中的所有字符，但是之后我们还要检查p串，此时没匹配完的p串里只能剩星号，不能有其他的字符，将连续的星号过滤掉，如果j不等于p的长度，则返回false，参见代码如下： 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if p == "*": return True if p == '' and s == '': return True if p == '' or s == '': return False iStar, jStar = -1, -1 i, j = 0, 0 while i &lt; len(s): if j&lt;len(p) and (s[i] == p[j] or p[j] == '?'): i += 1 j += 1 elif j&lt;len(p) and p[j] == "*": iStar = i jStar = j j += 1 elif iStar &gt;= 0: iStar += 1 i = iStar j = jStar + 1 else: return False while j &lt; len(p) and p[j] == '*': j += 1 return j == len(p) 这道题也能用动态规划 Dynamic Programming 来解，写法跟之前那道题 Regular Expression Matching 很像，但是还是不一样。外卡匹配和正则匹配最大的区别就是在星号的使用规则上，对于正则匹配来说，星号不能单独存在，前面必须要有一个字符，而星号存在的意义就是表明前面这个字符的个数可以是任意个，包括0个，那么就是说即使前面这个字符并没有在s中出现过也无所谓，只要后面的能匹配上就可以了。而外卡匹配就不是这样的，外卡匹配中的星号跟前面的字符没有半毛钱关系，如果前面的字符没有匹配上，那么直接返回 false 了，根本不用管星号。而星号存在的作用是可以表示任意的字符串，当然只是当匹配字符串缺少一些字符的时候起作用，当匹配字符串p包含目标字符串s中没有的字符时，将无法成功匹配。 对于这种玩字符串的题目，动态规划 Dynamic Programming 是一大神器，因为字符串跟其子串之间的关系十分密切，正好适合DP这种靠推导状态转移方程的特性。那么先来定义dp数组吧，我们使用一个二维 dp 数组，其中 dp[i][j] 表示 s中前i个字符组成的子串和p中前j个字符组成的子串是否能匹配。大小初始化为 (m+1) x (n+1)，加1的原因是要包含 dp[0][0] 的情况，因为若s和p都为空的话，也应该返回 true，所以也要初始化 dp[0][0] 为 true。还需要提前处理的一种情况是，当s为空，p为连续的星号时的情况。由于星号是可以代表空串的，所以只要s为空，那么连续的星号的位置都应该为 true，所以我们现将连续星号的位置都赋为 true。然后就是推导一般的状态转移方程了，如何更新 dp[i][j]，首先处理比较 tricky 的情况，若p中第j个字符是星号，由于星号可以匹配空串，所以如果p中的前 j-1 个字符跟s中前i个字符匹配成功了（ dp[i][j-1] 为true）的话，那么 dp[i][j] 也能为 true。或者若p中的前j个字符跟s中的前i-1个字符匹配成功了（ dp[i-1][j] 为true ）的话，那么 dp[i][j] 也能为 true（因为星号可以匹配任意字符串，再多加一个任意字符也没问题）。若p中的第j个字符不是星号，对于一般情况，我们假设已经知道了s中前 i-1 个字符和p中前 j-1 个字符的匹配情况（即 dp[i-1][j-1] ），那么现在只需要匹配s中的第i个字符跟p中的第j个字符，若二者相等（s[i-1] == p[j-1] ），或者p中的第j个字符是问号（ p[j-1] == &#39;?&#39; ），再与上 dp[i-1][j-1] 的值，就可以更新 dp[i][j] 了，参见代码如下： 1234567891011121314151617181920212223242526272829class Solution(object): def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ if p == "*": return True if p == '' and s == '': return True if p == '' or s == '': return False dp = [[False]*(len(p)+1) for _ in range(len(s)+1)] dp[0][0] = True for j in range(1, len(p)+1): if p[j-1] == '*': dp[0][j] = dp[0][j-1] for i in range(1, len(s)+1): for j in range(1, len(p)+1): if p[j-1] == '*': dp[i][j] = dp[i][j-1] or dp[i-1][j] else: dp[i][j] = (s[i-1] == p[j-1] or p[j-1] == '?') and dp[i-1][j-1] return dp[-1][-1] 58. 最后一个单词的长度题目描述给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例:12输入: &quot;Hello World&quot;输出: 5 解题思路库函数。123456789101112class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 s = s.split() return len(s[-1]) if s else 0 双指针，一个指向最后一个单词的末尾，一个指向最后一个单词的开头。1234567891011121314151617181920class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ if not s: return 0 left, right = 0, len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 left = right while left &gt;= 0 and s[left] != ' ': left -= 1 return right - left 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 139. 单词拆分题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： - 拆分时可以重复使用字典中的单词。 - 你可以假设字典中没有重复的单词。 示例 1：123输入: s = &quot;Leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;Leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2：1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3：12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 解题思路dp[i]代表的时[0,i)满不满足单词拆分，需要遍历的范围为1~N+1，dp[0]初始化为True。两层循环，外层循环遍历每个位置的状态，内层判断前面是否有一个位置j的状态为真 and 位置j到当前位置i是否在wordDict中。 123456789101112131415161718192021class Solution(object): def wordBreak(self, s, wordDict): """ :type s: str :type wordDict: List[str] :rtype: bool """ if not s: return True if len(wordDict) == 0: return False dp = [False] * (len(s)+1) dp[0] = True for i in range(1,len(s)+1): for j in range(i): if dp[j] and s[j:i] in wordDict: dp[i] = True return dp[-1] 151. 翻转字符串里的单词题目描述给定一个字符串，逐个翻转字符串中的每个单词。 示例:12输入: &quot;the sky is blue&quot;,输出: &quot;blue is sky the&quot;. 说明: 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶: 请选用C语言的用户尝试使用 O(1) 空间复杂度的原地解法。 解题思路库函数1234567class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ return ' '.join(s.split()[::-1]) 自己写的。先将头尾的空格去掉，新建一个字符串，将单词字符加入，去掉多余的空格。 然后先将整个字符串翻转，在将每个单词翻转。123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def reverseWords(self, s): """ :type s: str :rtype: str """ if not s: return "" left = 0 while left &lt; len(s) and s[left] == ' ': left += 1 right = len(s)-1 while right &gt;= 0 and s[right] == ' ': right -= 1 s = s[left:right+1] newstring = '' i = 0 while i &lt; len(s): if s[i] != ' ': newstring += s[i] i += 1 else: newstring += ' ' while i &lt; len(s) and s[i] == ' ': i += 1 newstring = list(newstring) self.reverse(newstring, 0, len(newstring)) start, end = 0, 0 while end &lt; len(newstring): while end &lt; len(newstring) and newstring[end] != ' ': end += 1 self.reverse(newstring, start, end) start = end + 1 end = start return ''.join(newstring) def reverse(self, s, start, end): left, right = start, end-1 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 165. 比较版本号题目描述比较两个版本号 version1 和 version2。如果 version1 &gt; version2 返回 1，如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 你可以假设版本字符串非空，并且只包含数字和 . 字符。 . 字符不代表小数点，而是用于分隔数字序列。 例如，2.5 不是“两个半”，也不是“差一半到三”，而是第二版中的第五个小版本。 你可以假设版本号的每一级的默认修订版号为 0。例如，版本号 3.4 的第一级（大版本）和第二级（小版本）修订号分别为 3 和 4。其第三级和第四级修订号均为 0。 示例 1:12输入: version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot;输出: -1 示例 2:12输入: version1 = &quot;1.0.1&quot;, version2 = &quot;1&quot;输出: 1 示例 3:12输入: version1 = &quot;7.5.2.4&quot;, version2 = &quot;7.5.3&quot;输出: -1 示例 4：123输入：version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot;输出：0解释：忽略前导零，“01” 和 “001” 表示相同的数字 “1”。 示例 5：123输入：version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot;输出：0解释：version1 没有第三级修订号，这意味着它的第三级修订号默认为 “0”。 提示： 版本字符串由以点 （.） 分隔的数字字符串组成。这个数字字符串可能有前导零。 版本字符串不以点开始或结束，并且其中不会有两个连续的点。 解题思路先将两个版本号以’.’分隔为两个列表，然后按位比较，短的补零。1234567891011121314151617181920212223242526class Solution(object): def compareVersion(self, version1, version2): """ :type version1: str :type version2: str :rtype: int """ if not version1 or not version2: return 0 version1 = version1.split('.') version2 = version2.split('.') i = 0 while i &lt; len(version1) or i &lt; len(version2): v1 = version1[i] if i &lt; len(version1) else 0 v2 = version2[i] if i &lt; len(version2) else 0 if int(v1) &gt; int(v2): return 1 if int(v1) &lt; int(v2): return -1 i += 1 return 0 227. 基本计算器 II题目描述实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 示例 1:12输入: &quot;3+2*2&quot;输出: 7 示例 2:12输入: &quot; 3/2 &quot;输出: 1 示例 3:12输入: &quot; 3+5 / 2 &quot;输出: 5 说明： 你可以假设所给定的表达式都是有效的。 请不要使用内置的库函数 eval。 解题思路用num保存上一个数字，用pre_op保存上一个操作符。当遇到新的操作符的时候，需要根据pre_op进行操作。乘除的优先级高于加减。所以有以下规则： 之前的运算符是+，那么需要把之前的数字num进栈，然后等待下一个操作数的到来。 之前的运算符是-，那么需要把之前的数字求反-num进栈，然后等待下一个操作数的到来。 之前的运算符是×，那么需要立刻出栈和之前的数字相乘，重新进栈，然后等待下一个操作数的到来。 之前的运算符是/，那么需要立刻出栈和之前的数字相除，重新进栈，然后等待下一个操作数的到来。 注意比较的都是之前的操作符和操作数，现在遇到的操作符是没有什么用的。 另外，坑爹的Python地板除。 参考 12345678910111213141516171819202122232425262728293031323334class Solution(object): def calculate(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 stack = [] num = 0 pre_op = '+' for i in range(len(s)): if s[i] in '0123456789': num = num*10+int(s[i]) if i == len(s)-1 or s[i] in '+-*/': if pre_op == '+': stack.append(num) elif pre_op == '-': stack.append(-num) elif pre_op == '*': stack.append(stack.pop()*num) elif pre_op == '/': top = stack.pop() if top*num &lt; 0 and top % num != 0: stack.append(top // num + 1) else: stack.append(top // num) pre_op = s[i] num = 0 return sum(stack) 344. 反转字符串题目描述编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1：12输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2：12输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 解题思路12345678class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ s[:] = s[::-1] 1234567891011121314class Solution(object): def reverseString(self, s): """ :type s: List[str] :rtype: None Do not return anything, modify s in-place instead. """ left, right = 0, len(s)-1 while left &lt; right: s[left], s[right] = s[right], s[left] left, right = left + 1, right - 1 return 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1:12输入: &quot;hello&quot;输出: &quot;holle&quot; 示例 2:12输入: &quot;Leetcode&quot;输出: &quot;leotcede&quot; 说明:元音字母不包含字母”y”。 解题思路12345678910111213141516171819class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in 'aAeEiIoOuU': left += 1 while right &gt; left and s[right] not in 'aAeEiIoOuU': right -= 1 s[left], s[right] = s[right], s[left] left, right = left+1, right-1 return ''.join(s) 383. 赎金信题目描述给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。 (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。) 注意： 你可以假设两个字符串均只含有小写字母。123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 解题思路遍历ransomNote，如果不在magazine，返回False，如果在，删除magazine中对应的字符。 需要转成list才可以用remove。 12345678910111213141516171819202122class Solution(object): def canConstruct(self, ransomNote, magazine): """ :type ransomNote: str :type magazine: str :rtype: bool """ if len(ransomNote ) == 0: return True if len(magazine) == 0: return False magazine = list(magazine) for x in ransomNote: if x not in magazine: return False else: magazine.remove(x) return True 385. 迷你语法分析器题目描述给定一个用字符串表示的整数的嵌套列表，实现一个解析它的语法分析器。 列表中的每个元素只可能是整数或整数嵌套列表 提示：你可以假定这些字符串都是格式良好的： 字符串非空字符串不包含空格字符串只包含数字0-9, [, - ,, ] 示例 1：123给定 s = &quot;324&quot;,你应该返回一个 NestedInteger 对象，其中只包含整数值 324。 示例 2：123456789给定 s = &quot;[123,[456,[789]]]&quot;,返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：1. 一个 integer 包含值 1232. 一个包含两个元素的嵌套列表： i. 一个 integer 包含值 456 ii. 一个包含一个元素的嵌套列表 a. 一个 integer 包含值 789 解题思路不太理解。参考1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# """# This is the interface that allows for creating nested lists.# You should not implement it, or speculate about its implementation# """#class NestedInteger(object):# def __init__(self, value=None):# """# If value is not specified, initializes an empty list.# Otherwise initializes a single integer equal to value.# """## def isInteger(self):# """# @return True if this NestedInteger holds a single integer, rather than a nested list.# :rtype bool# """## def add(self, elem):# """# Set this NestedInteger to hold a nested list and adds a nested integer elem to it.# :rtype void# """## def setInteger(self, value):# """# Set this NestedInteger to hold a single integer equal to value.# :rtype void# """## def getInteger(self):# """# @return the single integer that this NestedInteger holds, if it holds a single integer# Return None if this NestedInteger holds a nested list# :rtype int# """## def getList(self):# """# @return the nested list that this NestedInteger holds, if it holds a nested list# Return None if this NestedInteger holds a single integer# :rtype List[NestedInteger]# """class Solution(object): def deserialize(self, s): """ :type s: str :rtype: NestedInteger """ if len(s) == 0: return NestedInteger() if s[0] != '[': return NestedInteger(int(s)) res = NestedInteger() numP, start = 0, 1 for i in range(1, len(s)): if (numP == 0 and s[i] == ',') or i == len(s)-1: if start &lt; i: res.add(self.deserialize(s[start:i])) start = i + 1 elif s[i] == '[': numP += 1 elif s[i] == ']': numP -= 1 return res 387. 字符串中的第一个唯一字符题目描述给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例:12345s = &quot;Leetcode&quot;返回 0.s = &quot;loveLeetcode&quot;,返回 2. 注意事项：您可以假定该字符串只包含小写字母。 解题思路两次遍历 12345678910111213141516171819202122class Solution(object): def firstUniqChar(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return -1 Dict = &#123;&#125; for x in s: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for i in range(len(s)): if Dict[s[i]] == 1: return i return -1 415. 字符串相加题目描述给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 解题思路123456789101112131415161718192021222324252627282930313233343536class Solution(object): def addStrings(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ midsum = [] num1, num2 = num1[::-1], num2[::-1] index = 0 while index &lt; len(num1) and index &lt; len(num2): midsum.append(ord(num1[index])-48 + ord(num2[index]) - 48) index += 1 if index == len(num1): for i in range(index, len(num2)): midsum.append(ord(num2[i]) - 48) else: for i in range(index, len(num1)): midsum.append(ord(num1[i]) - 48) res = '' plus = 0 for x in midsum: num = plus + x res = str(num % 10) + res plus = num // 10 if plus: res = str(plus) + res return res 434. 字符串中的单词数题目描述统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 请注意，你可以假定字符串里不包括任何不可打印的字符。 示例:12输入: &quot;Hello, my name is John&quot;输出: 5 解题思路12345678910class Solution(object): def countSegments(self, s): """ :type s: str :rtype: int """ s = s.split() return len(s)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数学]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是数学相关题目题解总结。 [TOC] 2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路使用哨兵节点，设置进位carry，直接相加，当进位为1时加到下一位。 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 dummy = cur = ListNode(0) carry = 0 while l1 or l2 or carry: if l1: carry += l1.val l1 = l1.next if l2: carry += l2.val l2 = l2.next cur.next = ListNode(carry%10) cur = cur.next carry //= 10 return dummy.next 第一次写的思路：先求和，在构建链表。123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l2: return l1 if not l1: return l2 num1, num2 = 0, 0 base = 1 while l1: num1 += l1.val * base base *= 10 l1 = l1.next base = 1 while l2: num2 += l2.val*base base *= 10 l2 = l2.next num = num1 + num2 if num == 0: root = ListNode(0) return root return self.helper(num) def helper(self, num): if num == 0: return None root = ListNode(num % 10) root.next = self.helper(num // 10) return root 7. 整数反转题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:12输入: 123输出: 321 示例 2:12输入: -123输出: -321 示例 3:12输入: 120输出: 21 注意:1假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路123456789101112131415class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ flag = 1 if x &lt; 0: x = -x flag = -1 res = 0 while x: res = res * 10 + x % 10 x = x // 10 return res * flag if -2**31 &lt;= res &lt;= 2**31-1 else 0 8. 字符串转换整数 (atoi)题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:12输入: &quot;42&quot;输出: 42 示例 2:1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4:1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解题思路一个一个条件判断。。。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def myAtoi(self, str): """ :type str: str :rtype: int """ if not str: return 0 i = 0 while i &lt; len(str) and str[i] == ' ': i += 1 if i == len(str) or str[i] not in '1234567890+-': return 0 flag = 1 if str[i] in '+-': if i == len(str)-1 or str[i+1] not in '1234567890': return 0 elif str[i] == '-': flag = -1 i = i+1 start = i end = start while end &lt; len(str) and str[end] in '1234567890': end += 1 res = flag*int(str[start:end]) if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 9. 回文数题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:1234输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。进阶: 你能不将整数转为字符串来解决这个问题吗？ 解题思路1234567891011121314151617class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False xhat = 0 temp = x while temp: xhat = xhat*10 + temp % 10 temp //= 10 return x == xhat 12345678910111213141516171819class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False x = str(x) left, right = 0, len(x)-1 while left &lt; right: if x[left] != x[right]: return False left += 1 right -= 1 return True 12. 整数转罗马数字题目描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:12输入: 3输出: &quot;III&quot; 示例 2:12输入: 4输出: &quot;IV&quot; 示例 3:12输入: 9输出: &quot;IX&quot; 示例 4:123输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例 5:123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920class Solution(object): def intToRoman(self, num): """ :type num: int :rtype: str """ if not num: return '' val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = '' for i in range(len(val)): while num &gt;= val[i]: res += st[i] num -= val[i] return res 13. 罗马数字转整数题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:12输入: &quot;III&quot;输出: 3 示例 2:12输入: &quot;IV&quot;输出: 4 示例 3:12输入: &quot;IX&quot;输出: 9 示例 4:123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解题思路1234567891011121314151617181920212223class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if not s: return 0 val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] st = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] Dict = &#123;'M':1000, 'CM':900, 'D':500, 'CD':400, 'C':100, 'XC':90, 'L':50, 'XL':40, 'X':10, 'IX':9, 'V':5, 'IV':4,'I':1&#125; res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in Dict: res += Dict[s[i:i+2]] i += 2 else: res += Dict[s[i]] i += 1 return res 1234567891011121314151617181920212223242526class Solution(object): def romanToInt(self, s): """ :type s: str :rtype: int """ if len(s) == 0: return 0 vals = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] strs = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV','I'] res = 0 i = 0 while i &lt; len(s): if i+1 &lt; len(s) and s[i:i+2] in strs: index = strs.index(s[i:i+2]) res += vals[index] i += 2 else: index = strs.index(s[i]) res += vals[index] i += 1 return res 29. 两数相除题目描述给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明:123被除数和除数均为 32 位有符号整数。除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 解题思路通过位运算模拟乘2的操作，加快扩大divisor的速度。使用两层while，外层用来控制最终跳出循环，同时初始化逼近的间隔；内层通过不断的乘2用来加快逼近速度。属于二分查找的变种。 123456789101112131415161718192021222324252627282930313233class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if divisor == 0: return False flag = (dividend &lt; 0) is (divisor &lt; 0) dividend, divisor = abs(dividend), abs(divisor) if dividend &lt; divisor: return 0 res = 0 while dividend &gt;= divisor: temp = divisor count = 1 while dividend &gt;= temp: dividend -= temp res += count temp = temp &lt;&lt; 1 count = count &lt;&lt; 1 if not flag: res = -res if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 一层循环超出时间限制12345678910111213141516171819202122232425class Solution(object): def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == 0: return 0 flag = 1 if (dividend &lt; 0) is (divisor &lt; 0) else -1 dividend, divisor = abs(dividend), abs(divisor) res = 0 while dividend &gt;= divisor: res += 1 dividend -= divisor res = res*flag if res &gt; 2**31-1: return 2**31-1 if res &lt; -2**31: return -2**31 return res 43. 字符串相乘题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1:12输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2:12输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 说明：1234num1 和 num2 的长度小于110。num1 和 num2 只包含数字 0-9。num1 和 num2 均不以零开头，除非是数字 0 本身。不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 解题思路按照乘法竖式计算，将num1和num2翻转，用num1中的每一个数和num2进行相乘，乘法过程中考虑进位和位数。 1234567891011121314151617181920212223class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ if num1 == '0' or num2 == '0': return '0' res = 0 for i, n1 in enumerate(num1[::-1]): carry = 0 temp = 0 for j, n2 in enumerate(num2[::-1]): multi = (ord(n1)-ord('0')) * (ord(n2)-ord('0')) carrytemp, val = multi//10, multi%10 temp += (val+carry) * (10**j) carry = carrytemp temp += carry * (10**len(num2)) res += temp * (10**i) return str(res) 二刷。 123456789101112131415161718192021222324252627282930class Solution(object): def multiply(self, num1, num2): """ :type num1: str :type num2: str :rtype: str """ num1, num2 = num1[::-1], num2[::-1] temp = [0]*(len(num1)+len(num2)) for i in range(len(num1)): for j in range(len(num2)): temp[i+j] += (ord(num1[i])-ord('0')) * (ord(num2[j])-ord('0')) res = [] for i in range(len(temp)): digit = temp[i] % 10 carry = temp[i] // 10 if i &lt; len(temp)-1: temp[i+1] += carry res.insert(0, str(digit)) i = 0 while i&lt;len(res)-1 and res[i] == '0': i += 1 res = res[i:] return ''.join(res) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public String multiply(String num1, String num2) &#123; if (num1.length()==0 || num2.length()==0) return "0"; int[] tempMulti = new int[(num1.length()+num2.length())]; num1 = new StringBuffer(num1).reverse().toString(); num2 = new StringBuffer(num2).reverse().toString(); for (int i=0; i&lt;num1.length(); i++)&#123; for (int j=0; j&lt;num2.length(); j++)&#123; tempMulti[i+j] += (num1.charAt(i)-'0') * (num2.charAt(j)-'0'); &#125; &#125; StringBuilder res = new StringBuilder(); int car =0; for (int i:tempMulti)&#123; int temp = (i+car)%10; res.insert(0, temp); car = (i+car) / 10; &#125; int index = 0; while (index &lt; res.length()-1 &amp;&amp; res.charAt(index) == '0') index ++; String ans = res.substring(index); return (res.length()==0)?"0":ans; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); String res = sol.multiply("0", "0"); System.out.print(res); &#125;&#125; 50. Pow(x, n)题目描述实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明:12-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解题思路直接乘，超时。 1234567891011121314151617181920212223class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if x == 0.0: return 0 if n == 0: return 1.0 flag = (n &lt; 0) n = abs(n) res = 1 while n &gt; 0: res *= x n -= 1 if flag: res = 1.0/res return res 二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 12345678910111213141516class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 elif n &lt; 0: return 1.0 / self.myPow(x, -n) elif n % 2 == 1: return self.myPow(x*x, n//2) * x return self.myPow(x, n-1) * x else: return self.myPow(x*x, n//2) 二分求幂，迭代。12345678910111213141516171819202122class Solution(object): def myPow(self, x, n): """ :type x: float :type n: int :rtype: float """ if n == 0: return 1.0 flag = (n&lt;0) n = abs(n) res = 1 while n: if n%2 == 1: res *= x n &gt;&gt;= 1 x *=x if flag: res = 1.0/res return res 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：123456&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明：12给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:12输入: n = 3, k = 3输出: &quot;213&quot; 示例 2:12输入: n = 4, k = 9输出: &quot;2314&quot; 解题思路以n=4, k=9为例，初始化k=k-1=8。 最高位可取数字为[1,2,3,4]，每一个取值都有3!=6种取法，那么第9个下标为k//(n-1)!=8//6=1，即2，可取数字删去2更新为[1,3,4]，k=k%(n-1)!=2； 次高位可取数字为[1,3,4]，每一个取值都有2!=2种取法，那么第九个下标为k//(n-1-1)!=2//2=1,即3，可取数字删去3更新为[1,4]，k=k%(n-1-1)!=0； 第三位可取数字为[1,4]，每一个取值都有1!=1中取法，那么第九个下标为k//(n-1-1-1)!=0//1=0，即1，可取数字删去1更新为[4]，k=k%(n-1-1-1)=0; 第四位为[4]。 123456789101112131415161718192021222324252627class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' num = [str(i) for i in range(1, n+1)] fact = [1] * n for i in range(1, n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' res = '' k = k-1 for i in range(n): index = k // fact[n-1-i] res += num[index] num.pop(index) k = k % fact[n-1-i] return res 66. 加一题目描述给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解题思路数九。从最后一位开始遍历，若当前遍历的值为9，则置为0；如果不是9，则当前位加1跳出循环；最后判断最高位是否为0，若为0，则需要在增加数组长度，即在最高位之前插入1。 123456789101112131415161718192021class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] for i in range(len(digits))[::-1]: if digits[i] == 9: digits[i] = 0 continue else: digits[i] += 1 break if digits[0] == 0: digits.insert(0, 1) return digits 采用进位。初始化进位为0，首先对最后一位加1操作，从后向前遍历，当当前位加上进位等于10时，将改为置0，进位置1，如小于10，则将进位置0，跳出循环。 1234567891011121314151617181920212223242526class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] pos = len(digits)-1 carry = 0 digits[-1] += 1 while pos &gt;= 0: digits[pos] += carry if digits[pos] &gt;= 10: digits[pos] -= 10 carry = 1 else: carry = 0 break pos -= 1 if carry: digits.insert(0, 1) return digits 一刷。 1234567891011121314151617181920class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ if len(digits) == 0: return [] temp = 0 for x in digits: temp = temp*10 + x temp += 1 res = [] while temp: res.insert(0, temp%10) temp //= 10 return res 67. 二进制求和题目描述给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1:12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2:12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 解题思路设置当前位和plus，从后向前遍历，将每一位(plus%2)加入到结果中，将进位(plus//2)赋给下一次迭代位和plus。 1234567891011121314151617181920212223242526class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ res = '' carry = 0 m, n, plus = len(a)-1, len(b)-1, 0 i, j = m, n res = '' while i &gt;= 0 or j &gt;= 0 or plus: if i &gt;= 0: plus += int(a[i]) i -= 1 if j &gt;= 0: plus += int(b[j]) j -= 1 res = str(plus%2) + res plus //= 2 return res 69. x 的平方根题目描述实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1:12输入: 4输出: 2 示例 2:1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路二分查找。 12345678910111213141516171819202122class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ if x &lt;= 1: return x left, right = 1, x while left &lt;= right: mid = left + (right-left)//2 if mid * mid == x: return mid elif mid * mid &gt; x: right = mid - 1 else: left = mid + 1 return right 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2:12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3:12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 解题思路先处理分子，分母为零，负数的情况。然后使用字典将余数保存起来，当余数不为零时，在结果后加小数位数，当余数重复出现时，找到最开始重复的位置，加括号返回。 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ if denominator == 0: return '' if numerator == 0: return '0' res = '' if numerator*denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) remainder = numerator % denominator if remainder == 0: return res res += '.' Dict = &#123;&#125; Dict[remainder] = len(res) while remainder: remainder *= 10 res += str(remainder // denominator) remainder %= denominator if remainder in Dict: start = Dict[remainder] res = res[:start] + '(' + res[start:] + ')' break else: Dict[remainder] = len(res) return res 168. Excel表列名称题目描述给定一个正整数，返回它在 Excel 表中相对应的列名称。 例如，123456781 -&gt; A2 -&gt; B3 -&gt; C...26 -&gt; Z27 -&gt; AA28 -&gt; AB ... 示例 1:12输入: 1输出: &quot;A&quot; 示例 2:12输入: 28输出: &quot;AB&quot; 示例 3:12输入: 701输出: &quot;ZY&quot; 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def convertToTitle(self, n): """ :type n: int :rtype: str """ res = '' while n: if n % 26 == 0: res = 'Z' + res n -= 26 else: res = chr(n % 26 -1 + ord('A')) + res n -= n % 26 n //= 26 return res 171. Excel表列序号题目描述给定一个Excel表格中的列名称，返回其相应的列序号。 例如，12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ... 示例 1:12输入: &quot;A&quot;输出: 1 示例 2:12输入: &quot;AB&quot;输出: 28 示例 3:12输入: &quot;ZY&quot;输出: 701 解题思路字母26为一个周期。 1234567891011121314151617class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 base = 1 for x in s[::-1]: res += (ord(x) - ord('A') + 1) * base base *= 26 return res 123456789101112class Solution(object): def titleToNumber(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 for x in s: res = res*26 + (ord(x) - ord('A') + 1) return res 172. 阶乘后的零题目描述给定一个整数 n，返回 n! 结果尾数中零的数量。 示例 1:123输入: 3输出: 0解释: 3! = 6, 尾数中没有零。 示例 2:123输入: 5输出: 1解释: 5! = 120, 尾数中有 1 个零. 说明: 你算法的时间复杂度应为 O(log n) 。 解题思路 6!=[123456]，其中25才有0，所以可以抛开其他数据，只看2,5出现的次数； 10!=[12345678910]，有2,5组成的有2,4(22),5,6(23),8(222),10(25)，一个2和一个5配对产生一个0，所以有两个配对有两个0。由于2一定比5多，只对5计数就可以了。 123456789101112class Solution(object): def trailingZeroes(self, n): """ :type n: int :rtype: int """ res = 0 while n: n //= 5 res += n return res 202. 快乐数题目描述编写一个算法来判断一个数是不是“快乐数”。 一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 示例:1234567输入: 19输出: true解释: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 解题思路12345678910111213141516171819202122232425262728class Solution(object): def isHappy(self, n): """ :type n: int :rtype: bool """ if n == 0: return False if n == 1: return True seen = [n] while n != 1: lastN = n nextN = 0 while lastN: nextN += (lastN % 10) ** 2 lastN //= 10 n = nextN if n in seen: return False seen.append(n) return True 204. 计数质数题目描述统计所有小于非负整数 n 的质数的数量。 示例:123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解题思路超时12345678910111213141516171819202122class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = 0 for i in range(2, n): flag = 1 for j in range(2, i): if i % j == 0: flag = 0 break if flag: res += 1 return res 厄拉多塞筛法.比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推. 首先生成了一个全部为1的列表 res= [1] * n 因为0和1不是质数,所以列表的前两个位置赋值为0 res[0],res[1] = 0,0 此时从index = 2开始遍历,res[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引,全部赋值为0.此时res[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推. 123456789101112131415161718class Solution(object): def countPrimes(self, n): """ :type n: int :rtype: int """ if n &lt;= 2: return 0 res = [1] * n res[0], res[1] = 0, 0 for i in range(2, int(n**0.5)+1): if res[i] == 1: res[i*i:n:i] = [0] * len(res[i*i:n:i]) return sum(res) 223. 矩形面积题目描述在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例:12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 解题思路分两种情况，第一种是不重叠，第二种重叠123456789101112131415161718class Solution(object): def computeArea(self, A, B, C, D, E, F, G, H): """ :type A: int :type B: int :type C: int :type D: int :type E: int :type F: int :type G: int :type H: int :rtype: int """ if E &gt;= C or A &gt;= G or F &gt;= D or B &gt;= H: return (C-A)*(D-B) + (G-E)*(H-F) else: return (C-A)*(D-B) + (G-E)*(H-F) - (min(G,C)-max(A,E)) * (min(D,H)-max(B,F)) 231. 2的幂题目描述12345678910111213141516给定一个整数，编写一个函数来判断它是否是 2 的幂次方。示例 1:输入: 1输出: true解释: 20 = 1示例 2:输入: 16输出: true解释: 24 = 16示例 3:输入: 218输出: false 解题思路2的幂的二进制中只有一位是1.12345678910111213141516171819class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False res = 0 while n: if n &amp; 1: res += 1 if res &gt;= 2: return False n &gt;&gt;= 1 return True 2的幂的数 n和(n-1)相与一定是0，不为0则不是2的幂 如8(0000 1000) &amp; 7 (0000 0111) ==024(0001 1000) &amp; 23 (0001 0111) != 0 1234567891011class Solution(object): def isPowerOfTwo(self, n): """ :type n: int :rtype: bool """ if n == 0: return False return n&amp;(n-1) == 0 258. 各位相加题目描述给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。 示例:123输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。 进阶: 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？ 解题思路暴力12345678910111213141516171819class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num while num &gt;= 10: lastn = num nextn = 0 while lastn: nextn += lastn % 10 lastn //= 10 num = nextn return num 余9法。1234567891011假设输入的数字是一个5位数字num，则num的各位分别为a、b、c、d、e。有如下关系：num = a * 10000 + b * 1000 + c * 100 + d * 10 + e即：num = (a + b + c + d + e) + (a * 9999 + b * 999 + c * 99 + d * 9)因为 a * 9999 + b * 999 + c * 99 + d * 9 一定可以被9整除，因此num模除9的结果与 a + b + c + d + e 模除9的结果是一样的。对数字 a + b + c + d + e 反复执行同类操作，最后的结果就是一个 1-9 的数字加上一串数字，最左边的数字是 1-9 之间的，右侧的数字永远都是可以被9整除的。这道题最后的目标，就是不断将各位相加，相加到最后，当结果小于10时返回。因为最后结果在1-9之间，得到9之后将不会再对各位进行相加，因此不会出现结果为0的情况。因为 (x + y) % z = (x % z + y % z) % z，又因为 x % z % z = x % z，因此结果为 (num - 1) % 9 + 1，只模除9一次，并将模除后的结果加一返回。 参考1234567891011121314class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ if num &lt;= 9: return num if num % 9 == 0: return 9 else: return num % 9 263. 丑数题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1:123输入: 6输出: true解释: 6 = 2 × 3 示例 2:123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3:123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明：121 是丑数。2 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。 解题思路不断的除5,3,2，最后为1则为丑数 12345678910111213141516class Solution(object): def isUgly(self, num): """ :type num: int :rtype: bool """ if num == 0: return False for x in [5,3,2]: while num and num % x == 0: num //= x if num == 1: return True return False 264. 丑数 II题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例:123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解题思路1234567891011121314151617181920212223242526class Solution(object): def nthUglyNumber(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 dp = [0] * (n) dp[0] = 1 t2, t3, t5 = 0, 0, 0 for i in range(1, n): dp[i] = min(dp[t2]*2, dp[t3]*3, dp[t5]*5) if dp[t2]*2 == dp[i]: t2 += 1 if dp[t3]*3 == dp[i]: t3 += 1 if dp[t5]*5 == dp[i]: t5 += 1 return dp[-1] 313. 超级丑数题目描述编写一段程序来查找第 n 个超级丑数。 超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。 示例:123输入: n = 12, primes = [2,7,13,19]输出: 32 解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。 说明:12341 是任何给定 primes 的超级丑数。 给定 primes 中的数字以升序排列。0 &lt; k ≤ 100, 0 &lt; n ≤ 106, 0 &lt; primes[i] &lt; 1000 。第 n 个超级丑数确保在 32 位有符整数范围内。 解题思路123456789101112131415161718192021222324252627class Solution(object): def nthSuperUglyNumber(self, n, primes): """ :type n: int :type primes: List[int] :rtype: int """ if n &lt;= 1: return n dp = [0] * n dp[0] = 1 t = [0] * len(primes) for i in range(1, n): temp = float('inf') for j in range(len(t)): temp = min(temp, dp[t[j]]*primes[j]) dp[i] = temp for j in range(len(t)): if temp == dp[t[j]]*primes[j]: t[j] += 1 return dp[-1] 319. 灯泡开关题目描述初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。 示例:123456789输入: 3输出: 1 解释: 初始时, 灯泡状态 [关闭, 关闭, 关闭].第一轮后, 灯泡状态 [开启, 开启, 开启].第二轮后, 灯泡状态 [开启, 关闭, 开启].第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 你应该返回 1，因为只有一个灯泡还亮着。 解题思路暴力超时。1234567891011121314151617181920class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 if n &lt;= 3: return 1 dp = [1] * n for i in range(1, n): for i in range(i, n, i+1): dp[i] *= -1 return dp.count(1) 数学法。开平方？12345678class Solution(object): def bulbSwitch(self, n): """ :type n: int :rtype: int """ return int(n**0.5) 326. 3的幂题目描述给定一个整数，写一个函数来判断它是否是 3 的幂次方。 示例 1: 输入: 27输出: true示例 2: 输入: 0输出: false示例 3: 输入: 9输出: true示例 4: 输入: 45输出: false进阶：你能不使用循环或者递归来完成本题吗？ 解题思路1234567891011121314class Solution(object): def isPowerOfThree(self, n): """ :type n: int :rtype: bool """ if n == 0: return False while n % 3 == 0: n //= 3 return n == 1 365. 水壶问题题目描述有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶清空任意一个水壶从一个水壶向另外一个水壶倒水，直到装满或者倒空示例 1: (From the famous “Die Hard” example)12输入: x = 3, y = 5, z = 4输出: True 示例 2:12输入: x = 2, y = 6, z = 5输出: False 解题思路1234567891011121314151617这是一道脑筋急转弯题，我想很多人以前应该听过这道题目，有一个容量为3升和一个容量为5升的水罐，问我们如何准确的称出4升的水。我想很多人都知道怎么做，先把5升水罐装满水，倒到3升水罐里，这时5升水罐里还有2升水，然后把3升水罐里的水都倒掉，把5升水罐中的2升水倒入3升水罐中，这时候把5升水罐解满，然后往此时有2升水的3升水罐里倒水，这样5升水罐倒出1升后还剩4升即为所求。这个很多人都知道，但是这道题随意给我们了三个参数，问有没有解法，这就比较难了。这里我就照搬网上大神的讲解吧：这道问题其实可以转换为有一个很大的容器，我们有两个杯子，容量分别为x和y，问我们通过用两个杯子往里倒水，和往出舀水，问能不能使容器中的水刚好为z升。那么我们可以用一个公式来表达：z = m * x + n * y其中m，n为舀水和倒水的次数，正数表示往里舀水，负数表示往外倒水，那么题目中的例子可以写成: 4 = (-2) * 3 + 2 * 5，即3升的水罐往外倒了两次水，5升水罐往里舀了两次水。那么问题就变成了对于任意给定的x,y,z，存不存在m和n使得上面的等式成立。根据裴蜀定理，ax + by = d的解为 d = gcd(x, y)，那么我们只要只要z % d == 0，上面的等式就有解，所以问题就迎刃而解了，我们只要看z是不是x和y的最大公约数的倍数就行了，别忘了还有个限制条件x + y &gt;= z，因为x和y不可能称出比它们之和还多的水，参见代码如下；时间复杂度很小，但是不会算，空间复杂度是O(1). 参考 123456789101112131415161718class Solution(object): def canMeasureWater(self, x, y, z): """ :type x: int :type y: int :type z: int :rtype: bool """ return z == 0 or (x+y &gt;= z and z % self.gcd(x, y) == 0) def gcd(self, x, y): res = x % y while res != 0: x, y = y, res res = x % y return y 367. 有效的完全平方数题目描述给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1：12输入：16输出：True 示例 2：12输入：14输出：False 解题思路二分搜索12345678910111213141516171819202122class Solution(object): def isPerfectSquare(self, num): """ :type num: int :rtype: bool """ if num == 0: return False left, right = 1, int(num**0.5)+1 while left &lt;= right: mid = left + (right-left)//2 if mid*mid == num: return True elif mid*mid &gt; num: right = mid-1 else: left = mid+1 return False 372. 超级次方题目描述你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1:12输入: a = 2, b = [3]输出: 8 示例 2:12输入: a = 2, b = [1,0]输出: 1024 解题思路二分求幂123456789101112131415161718192021class Solution(object): def superPow(self, a, b): """ :type a: int :type b: List[int] :rtype: int """ res = 1 for n in b: res = self.pow(res, 10) * self.pow(a, n) % 1337 return res def pow(self, x, n): if x == 1 or n == 0: return 1 if n % 2: return self.pow(x, n-1) * x % 1337 else: return self.pow(x*x%1337, n//2) % 1337 396. 旋转函数题目描述给定一个长度为 n 的整数数组 A 。 假设 Bk 是数组 A 顺时针旋转 k 个位置后的数组，我们定义 A 的“旋转函数” F 为：1F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。 计算F(0), F(1), …, F(n-1)中的最大值。 注意:可以认为 n 的值小于 105。 示例:12345678A = [4, 3, 2, 6]F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。 解题思路看了数据规模是10^5，可以知道时间复杂度是O(N)量级，这就难办了。我们为了找规律，先把具体的数字抽象为A,B,C,D，那么我们可以得到：123456789101112F(0) = 0A + 1B + 2C +3DF(1) = 0D + 1A + 2B +3CF(2) = 0C + 1D + 2A +3BF(3) = 0B + 1C + 2D +3A 那么，我们通过仔细观察，我们可以得出下面的规律：123456789F(1) = F(0) + sum - 4DF(2) = F(1) + sum - 4CF(3) = F(2) + sum - 4B 那么我们就找到规律了,1F(i) = F(i-1) + sum - n * A[n-i]， 是个递推公式。我们最后求的是这个所有F(i)中的最大值。 时间复杂度是O(N)，空间复杂度是O(1). 参考12345678910111213141516class Solution(object): def maxRotateFunction(self, A): """ :type A: List[int] :rtype: int """ sumA = sum(A) f = sum(i*A[i] for i in range(len(A))) res = f for i in range(1, len(A)): f = f + sumA - len(A)*A[-i] res = max(res, f) return res 397. 整数替换题目描述给定一个正整数 n，你可以做如下操作： 如果 n 是偶数，则用 n / 2替换 n。 如果 n 是奇数，则可以用 n + 1或n - 1替换 n。n 变为 1 所需的最小替换次数是多少？ 示例 1:12345678输入:8输出:3解释:8 -&gt; 4 -&gt; 2 -&gt; 1 示例 2:12345678910输入:7输出:4解释:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1或7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 解题思路思路1：递归，速度很慢1234567891011121314151617class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n &lt;= 1: return 0 if n == 2: return 1 if n % 2 == 0: return 1 + self.integerReplacement(n//2) else: return 1 + min(self.integerReplacement(n-1), self.integerReplacement(n+1)) 思路2：位运算，速度很快当n是偶数时，直接除2；当n是奇数时，-1还是+1？奇数二进制数一定是01或者11结尾，如果把一个奇数化为4的倍数，变成1的步骤会更少（3除外）：15-&gt;16-&gt;8-&gt;4-&gt;2-&gt;115-&gt;14-&gt;7-&gt;6-&gt;3-&gt;2-&gt;1 因此：如果结尾是01，减1，如果结尾时11，加1，3的时候直接减1。 1234567891011121314151617181920212223class Solution(object): def integerReplacement(self, n): """ :type n: int :rtype: int """ if n == 0: return 0 res = 0 while n &gt; 1: res += 1 if n % 2 == 0: n &gt;&gt;= 1 else: if n &amp; 2 and n != 3: n += 1 else: n -= 1 return res 400. 第N个数字题目描述在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 个数字。 注意:n 是正数且在32为整形范围内 ( n &lt; 231)。 示例 1:12345输入:3输出:3 示例 2:12345678输入:11输出:0说明:第11个数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... 里是0，它是10的一部分。 解题思路一位数字有9个，有9位；2位数字有9*10=90个，有2*90=180位；3位数字有9*100=900个，有3*900=2700位； 首先找到n是几位数字，然后找到n是所在位数的第几个数字，最后求在这个数字的第几位上。 1234567891011121314151617181920212223class Solution(object): def findNthDigit(self, n): """ :type n: int :rtype: int """ if n &lt;= 9: return n bitlen = 1 count = 9 start = 1 while n &gt; bitlen*count: n -= bitlen*count bitlen += 1 count *= 10 start *= 10 res = start + (n-1) // bitlen return str(res)[(n-1) % bitlen] 892. 三维形体的表面积题目描述在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： **输入：**[[2]] **输出：**10 示例 2： **输入：**[[1,2],[3,4]] **输出：**34 示例 3： **输入：**[[1,0],[0,2]] **输出：**16 示例 4： **输入：**[[1,1,1],[1,0,1],[1,1,1]] **输出：**32 示例 5： **输入：**[[2,2,2],[2,1,2],[2,2,2]] **输出：**46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 解题思路对矩阵进行遍历，分别求每个位置的表面积，当某个位置垒了n（n&gt;0）个正方体，则其表面积为4*n+2 (四个侧面+上下两个面)，如果其前面或者上面有立方体存在，则会产生重叠，需要减去，重叠部分为两者较矮的那堆立方体个数乘以2。 1234567891011121314151617181920class Solution(object): def surfaceArea(self, grid): """ :type grid: List[List[int]] :rtype: int """ if len(grid) == 0: return 0 res = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] &gt; 0: res += 4*grid[i][j] + 2 if i &gt; 0: res -= min(grid[i][j], grid[i-1][j]) * 2 if j &gt; 0: res -= min(grid[i][j], grid[i][j-1]) * 2 return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 数组]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站，刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是数组相关题目题解总结。 [TOC] 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415161718class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) &lt;= 1: return False Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i return False 4. 寻找两个有序数组的中位数题目描述给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。123456789101112示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解题思路 复杂度$O(log(m + n))$方法待续。。。 归并排序。复杂度为$O((m+n)log(m+n))$，不符合。 1234567891011121314151617181920212223242526272829class Solution(object): def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ if len(nums1) == 0 and len(nums2) == 0: return 0 res = [] i, j = 0, 0 while i &lt; len(nums1) and j &lt; len(nums2): if nums1[i] &lt; nums2[j]: res.append(nums1[i]) i += 1 else: res.append(nums2[j]) j += 1 if i != len(nums1): res.extend(nums1[i:]) else: res.extend(nums2[j:]) if len(res) % 2: return res[len(res)//2] else: return (res[len(res)//2-1] + res[len(res)//2]) / 2.0 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 31. 下一个排列题目描述解题思路先找到从后面开始数第一个降序的位置，在将这个位置之后的数字翻转，然后遍历翻转的部分数字，最后交换这个降序数字和后面第一个比他大的数。12345678910111213141516171819202122class Solution(object): def nextPermutation(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ if len(nums) &lt; 2: return index = len(nums) - 2 while index &gt;= 0: if nums[index] &lt; nums[index+1]: #从后找到第一个降序数字 break index -= 1 nums[index+1:] = nums[index+1:][::-1] #将降序数字后面的数字翻转 for i in range(index+1, len(nums)): if nums[i] &gt; nums[index]: #在翻转的数字中找到第一个大于降序数字的 nums[i], nums[index] = nums[index], nums[i] #交换 break 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public void nextPermutation(int[] nums) &#123; if (nums.length &lt;= 1) return; int index = nums.length-1; while (index &gt;= 1)&#123; if(nums[index] &gt; nums[index-1]) break; index --; &#125; reverse(nums, index, nums.length-1); if (index == 0) return; for (int i=index; i&lt;nums.length; i++)&#123; if (nums[i] &gt; nums[index-1])&#123; swap(nums, i, index-1); break; &#125; &#125; return; &#125; public void reverse(int[] nums, int start, int end)&#123; while (start &lt; end)&#123; swap(nums, start, end); start ++; end --; &#125; &#125; public void swap(int[] nums, int start, int end)&#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;3,2,1&#125;; sol.nextPermutation(nums); for (int i = 0; i &lt; nums.length; i++) System.out.print(nums[i]); &#125;&#125; 33. 搜索旋转排序数组题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:12输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:12输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解题思路双指针。 当nums[mid] == target时，返回mid； 当nums[mid] &lt; nums[right]，则[mid,right]一定有序，判断target是否在(mid,right]中，如果在则left = mid+1，否则在另一段中，right = mid-1 当nums[mid] &gt; nums[right]，则[left,mid]一定有序，判断target是否在[left,mid)中，如果在，则right=mid-1，否则，left = mid+1. 12345678910111213141516171819202122232425262728class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) == 0: return -1 left, right = 0, len(nums)-1 while left &lt;= right: mid = left + (right-left)//2 if nums[mid] == target: return mid if nums[mid] &lt; nums[right]: if target &gt; nums[mid] and target &lt;= nums[right]: left = mid+1 else: right = mid-1 else: if target &gt;= nums[left] and target &lt; nums[mid]: right = mid-1 else: left = mid+1 return -1 41. 缺失的第一个正数题目描述给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1:12输入: [1,2,0]输出: 3 示例 2:12输入: [3,4,-1,1]输出: 2 示例 3:12输入: [7,8,9,11,12]输出: 1 说明:你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 解题思路从第一个位置开始，让每个数字放在自己应该在的位置上，终止条件为一旦发现该位置的数字不应该出现在数组中（&lt;=0或&gt;len(nums)），则终止交换。然后遍历数组，将第一个不符合要求的数字输出。 123456789101112131415161718class Solution(object): def firstMissingPositive(self, nums): """ :type nums: List[int] :rtype: int """ for i in range(len(nums)): while nums[i] &gt; 0 and nums[i] &lt;= len(nums) and nums[i] != nums[nums[i]-1]: temp = nums[nums[i]-1] nums[nums[i]-1] = nums[i] nums[i] = temp # nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i] 这样交换错误 for i in range(len(nums)): if nums[i] != i+1: return i+1 return len(nums)+1 42. 接雨水题目描述给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例:12输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解题思路求最高点处的索引，从左往最高点遍历，从右往最高点遍历遍历过程以初始点为最高点，当遇到比其低的点，则说明可以接水，接水量为两者之差，当遇到比其高的点，则更新当前最高点。1234567891011121314151617181920212223242526272829303132class Solution(object): def trap(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; if len(height) &lt; 3: return 0 maxIndex = 0 for i in range(1, len(height)): if height[i] &gt; height[maxIndex]: maxIndex = i res = 0 curMax = height[0] for i in range(1, maxIndex): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] curMax = height[-1] for i in range(len(height)-2, maxIndex, -1): if height[i] &gt; curMax: curMax = height[i] else: res += curMax - height[i] return res 48. 旋转图像题目描述给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1:12345678910111213给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:123456789101112131415给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解题思路1234567891011121314class Solution(object): def rotate(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ # 先沿着左上右下的对角线翻转 for i in range(len(matrix)): for j in range(i+1, len(matrix)): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] #在翻转每一行 for i in range(len(matrix)): matrix[i] = matrix[i][::-1] 54. 螺旋矩阵题目描述给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1:1234567输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2:1234567输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解题思路从左到右，从上到下，从右到左，从下到上，循环。123456789101112131415161718192021222324252627282930313233class Solution(object): def spiralOrder(self, matrix): """ :type matrix: List[List[int]] :rtype: List[int] """ if len(matrix) == 0: return [] top, buttom = 0, len(matrix)-1 left, right = 0, len(matrix[0])-1 res = [] while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1, buttom+1): res.append(matrix[i][right]) if top &lt; buttom: # 当top==buttom时，最后为一行，前面已经从左到右遍历过，不需重复遍历 for i in range(right-1, left-1, -1): res.append(matrix[buttom][i]) if left &lt; right: # 当left == right时， 最后为一列，前面已经从上到下遍历过了，不需重复遍历 for i in range(buttom-1, top, -1): res.append(matrix[i][left]) top, buttom = top+1, buttom-1 left, right = left+1, right-1 return res 59. 螺旋矩阵 II题目描述给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例:1234567输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def generateMatrix(self, n): """ :type n: int :rtype: List[List[int]] """ if n == 0: return [] if n == 1: return [[1]] matrix = [[0]*n for i in range(n)] top, buttom = 0, n-1 left, right = 0, n-1 val = 1 while top &lt;= buttom and left &lt;= right: for i in range(left, right+1): matrix[top][i] = val val += 1 for i in range(top+1, buttom+1): matrix[i][right] = val val += 1 if top &lt; buttom: for i in range(right-1, left-1, -1): matrix[buttom][i] = val val += 1 if left &lt; right: for i in range(buttom-1, top, -1): matrix[i][left] = val val += 1 top, buttom = top+1, buttom-1 left, right = left+1, right-1 return matrix 73. 矩阵置零题目描述给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 示例 1:123456789101112输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2:123456789101112输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 解题思路O(m+n)12345678910111213141516171819202122class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ row = [False] * len(matrix) col = [False] * len(matrix[0]) # 找出0的位置 for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: row[i] = True col[j] = True # 将0所在的行和列置0 for i in range(len(matrix)): for j in range(len(matrix[0])): if row[i] or col[j]: matrix[i][j] = 0 将0所在的行或列的其他位置置为’#’，然后替换成0123456789101112131415161718192021222324class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. """ if len(matrix) == 0: return for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == 0: for k in range(len(matrix[0])): if matrix[i][k] != 0: matrix[i][k] = '#' for k in range(len(matrix)): if matrix[k][j] != 0: matrix[k][j] = '#' for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j] == '#': matrix[i][j] = 0 74. 搜索二维矩阵题目描述编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例 1:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2:12345678输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解题思路从左下角开始搜索12345678910111213141516171819202122class Solution(object): def searchMatrix(self, matrix, target): """ :type matrix: List[List[int]] :type target: int :rtype: bool """ if len(matrix) == 0: return False rows, cols = len(matrix)-1, len(matrix[0])-1 i, j = rows, 0 while i &gt;= 0 and j &lt;= cols: if matrix[i][j] == target: return True elif matrix[i][j] &gt; target: i -= 1 else: j += 1 return False 81. 搜索旋转排序数组 II题目描述假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1:12输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2:12输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解题思路在每个while循环中，先将开头重复的和结尾重复的去掉。123456789101112131415161718192021222324252627282930313233class Solution(object): def search(self, nums, target): """ :type nums: List[int] :type target: int :rtype: bool """ if len(nums) == 0: return False left, right = 0, len(nums)-1 while left &lt;= right: val = nums[left] while left &lt; right and nums[left+1] == val: left += 1 val = nums[right] while left &lt; right and nums[right-1] == val: right -= 1 mid = left + (right-left)//2 if nums[mid] == target: return True elif nums[mid] &lt; nums[right]: if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 else: right = mid - 1 else: if nums[left] &lt;= target &lt; nums[mid]: right = mid - 1 else: left = mid + 1 return False 118. 杨辉三角题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。示例:123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 解题思路12345678910111213141516171819202122class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ if numRows == 0: return [] res = [[1]] for i in range(2, numRows+1): pre = res[-1] temp = [] i = 0 while i &lt; len(pre)-1: temp.append(pre[i]+pre[i+1]) i += 1 res.append([1]+temp+[1]) return res 119. 杨辉三角 II题目描述给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例:12输入: 3输出: [1,3,3,1] 进阶： 你可以优化你的算法到 O(k) 空间复杂度吗？ 解题思路123456789101112131415161718class Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ if rowIndex == 0: return [1] res = [1] for i in range(2, rowIndex+2): temp = [] for i in range(len(res)-1): temp.append(res[i]+res[i+1]) res = [1]+temp+[1] return res 189. 旋转数组题目描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1:123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2:12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 解题思路切片，拼接1234567891011121314class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return nums k = k%len(nums) nums[:] = nums[-k:]+nums[:-k] 先把所有的翻转，然后在对0~k和k~n分别进行翻转。12345678910111213141516171819202122class Solution(object): def rotate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: void Do not return anything, modify nums in-place instead. """ if k &lt;= 0 or len(nums) == 0: return k = k%len(nums) self.reverse(nums, 0, len(nums)-1) self.reverse(nums, 0, k-1) self.reverse(nums, k, len(nums)-1) def reverse(self, nums, left, right): while left &lt; right: nums[left], nums[right] = nums[right], nums[left] left += 1 right -= 1 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路双指针 123456789101112131415161718192021222324class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = float('inf') left, right = 0, 0 while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res!=float('inf') else 0 216. 组合总和 III题目描述找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12输入: k = 3, n = 7输出: [[1,2,4]] 示例 2:12输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0 or n &gt; 45: return [] nums = [x for x in range(1, 10)] res = [] self.dfs(nums, [], 0, k, n, res) return res def dfs(self, nums, path, index, k, target, res): if k == 0 and target == 0 and path: res.append(path) return for i in range(index, len(nums)): if nums[i] &gt; target: return self.dfs(nums, path+[nums[i]], i+1, k-1, target-nums[i], res) 217. 存在重复元素题目描述给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1:12输入: [1,2,3,1]输出: true 示例 2:12输入: [1,2,3,4]输出: false 示例 3:12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 解题思路12345678910111213class Solution(object): def containsDuplicate(self, nums): """ :type nums: List[int] :rtype: bool """ if len(nums) &lt;= 1: return False set1 = set(nums) return len(set1) != len(nums) 219. 存在重复元素 II题目描述给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。 示例 1:12输入: nums = [1,2,3,1], k = 3输出: true 示例 2:12输入: nums = [1,0,1,1], k = 1输出: true 示例 3:12输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路123456789101112131415161718192021class Solution(object): def containsNearbyDuplicate(self, nums, k): """ :type nums: List[int] :type k: int :rtype: bool """ if len(nums) &lt;= 0 or k &lt;= 0: return False Dict = &#123;&#125; for i in range(len(nums)): if nums[i] not in Dict: Dict[nums[i]] = i else: if i - Dict[nums[i]] &lt;= k: return True Dict[nums[i]] = i return False 228. 汇总区间题目描述给定一个无重复元素的有序整数数组，返回数组区间范围的汇总。 示例 1:123输入: [0,1,2,4,5,7]输出: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]解释: 0,1,2 可组成一个连续的区间; 4,5 可组成一个连续的区间。 示例 2:123输入: [0,2,3,4,6,8,9]输出: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]解释: 2,3,4 可组成一个连续的区间; 8,9 可组成一个连续的区间。 解题思路1234567891011121314151617181920212223class Solution(object): def summaryRanges(self, nums): """ :type nums: List[int] :rtype: List[str] """ if len(nums) == 0: return [] res = [] i = 0 while i &lt; len(nums): j = i while j &lt; len(nums)-1 and nums[j+1] == nums[j]+1: j += 1 if i == j: res.append(str(nums[i])) else: res.append(str(nums[i])+'-&gt;'+str(nums[j])) i = j+1 return res 229. 求众数 II题目描述给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。 说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。 示例 1:12输入: [3,2,3]输出: [3] 示例 2:12输入: [1,1,1,3,3,2,2,2]输出: [1,2] 解题思路1234567891011121314151617181920212223class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in set(nums): if Dict[x] &gt; len(nums)//3: res.append(x) return res 238. 除自身以外数组的乘积题目描述给定长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例:12输入: [1,2,3,4]输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 解题思路123456789101112131415161718192021class Solution(object): def productExceptSelf(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] res = [1]*len(nums) for i in range(1, len(nums)): res[i] = res[i-1]*nums[i-1] temp = 1 for i in range(len(nums)-2, -1, -1): temp *= nums[i+1] res[i] *= temp return res 268. 缺失数字题目描述给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1:12输入: [3,0,1]输出: 2 示例 2:12输入: [9,6,4,2,3,5,7,0,1]输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 解题思路123456789101112131415class Solution(object): def missingNumber(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 res = len(nums) for i in range(len(nums)): res ^= nums[i]^i return res 283. 移动零题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例:12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路12345678910111213141516class Solution(object): def moveZeroes(self, nums): """ :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. """ if len(nums) &lt;= 1: return index = 0 for i in range(len(nums)): if nums[i] != 0: nums[index] = nums[i] index += 1 nums[index:] = [0] * (len(nums)-index) 287. 寻找重复数题目描述给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1:12输入: [1,3,4,2,2]输出: 2 示例 2:12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 解题思路123456789101112131415161718192021class Solution(object): def findDuplicate(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return 0 fast = nums[nums[0]] slow = nums[0] while fast != slow: fast = nums[nums[fast]] slow = nums[slow] fast = 0 while fast != slow: fast = nums[fast] slow = nums[slow] return fast 289. 生命游戏题目描述根据百度百科，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在1970年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞具有一个初始状态 live（1）即为活细胞， 或 dead（0）即为死细胞。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例:1234567891011121314输入: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0]]输出: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0]] 进阶: 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def gameOfLife(self, board): """ :type board: List[List[int]] :rtype: None Do not return anything, modify board in-place instead. """ if len(board) == 0: return Live = [] Dead = [] for i in range(len(board)): for j in range(len(board[0])): if board[i][j] == 1: if self.judgeLive(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) else: if self.judgeDead(board, i, j): Live.append((i,j)) else: Dead.append((i,j)) for pair in Live: board[pair[0]][pair[1]] = 1 for pair in Dead: board[pair[0]][pair[1]] = 0 def judgeLive(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if 2&lt;=count&lt;=3 else False def judgeDead(self, board, i, j): count = 0 move = [[0,1], [0,-1], [1,0], [-1,0],[1,1],[1,-1],[-1,1],[-1,-1]] for pair in move: xnext = i+pair[0] ynext = j+pair[1] if 0&lt;=xnext&lt;len(board) and 0&lt;=ynext&lt;len(board[0]) and board[xnext][ynext] == 1: count += 1 return True if count==3 else False 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.keyIndex = &#123;&#125;#记录键、下标对 self.indexKey = &#123;&#125;#记录下标、键对 self.len = 0#记录长度，便于随机返回元素 def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ #插入时，分别对两个哈希表都进行插入，同时len+1 if val not in self.keyIndex: self.len += 1 self.keyIndex[val] = self.len self.indexKey[self.len] = val return True return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ #删除时将index_key中键为len的覆盖到键为key_index[val]，然后删除键为len的；key_index操作类似。最后len-1 if val in self.keyIndex: self.indexKey[self.keyIndex[val]] = self.indexKey[self.len] self.keyIndex[self.indexKey[self.len]] = self.keyIndex[val] self.indexKey.pop(self.len) self.keyIndex.pop(val) self.len -= 1 return True return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return self.indexKey[random.randint(1, self.len)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 381. O(1) 时间插入、删除和获取随机元素 - 允许重复题目描述设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。 注意: 允许出现重复元素。 insert(val)：向集合中插入元素 val。 remove(val)：当 val 存在时，从集合中移除一个 val。 getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 示例:1234567891011121314151617181920// 初始化一个空的集合。RandomizedCollection collection = new RandomizedCollection();// 向集合中插入 1 。返回 true 表示集合不包含 1 。collection.insert(1);// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。collection.insert(1);// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。collection.insert(2);// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。collection.getRandom();// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。collection.remove(1);// getRandom 应有相同概率返回 1 和 2 。collection.getRandom(); 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class RandomizedCollection(object): def __init__(self): """ Initialize your data structure here. """ self.data = [] def insert(self, val): """ Inserts a value to the collection. Returns true if the collection did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.data: self.data.append(val) return True else: self.data.append(val) return False def remove(self, val): """ Removes a value from the collection. Returns true if the collection contained the specified element. :type val: int :rtype: bool """ if val not in self.data: return False else: self.data.remove(val) return True def getRandom(self): """ Get a random element from the collection. :rtype: int """ return random.choice(self.data)# Your RandomizedCollection object will be instantiated and called as such:# obj = RandomizedCollection()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 414. 第三大的数题目描述给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。 示例 1:12345输入: [3, 2, 1]输出: 1解释: 第三大的数是 1. 示例 2:12345输入: [1, 2]输出: 2解释: 第三大的数不存在, 所以返回最大的数 2 . 示例 3:123456输入: [2, 2, 3, 1]输出: 1解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。存在两个值为2的数，它们都排第二。 解题思路123456789101112131415161718192021222324class Solution(object): def thirdMax(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 if len(nums) &lt;= 2: return max(nums) s1, s2, s3 = float('-inf'), float('-inf'), float('-inf') for num in nums: if num &gt; s1: s1, s2, s3 = num, s1, s2 elif num &lt; s1 and num &gt; s2: s2, s3 = num, s2 elif num &lt; s2 and num &gt; s3: s3 = num return s3 if s3 != float('-inf') else max(s1, s2) 442. 数组中重复的数据题目描述给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 找到所有出现两次的元素。 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ 示例：12345输入:[4,3,2,7,8,2,3,1]输出:[2,3] 解题思路12345678910111213141516171819class Solution(object): def findDuplicates(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) &lt;= 1: return [] res = [] for x in nums: if nums[abs(x)-1] &lt; 0: res.append(abs(x)) else: nums[abs(x)-1] *= -1 return res 448. 找到所有数组中消失的数字题目描述给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例:12345输入:[4,3,2,7,8,2,3,1]输出:[5,6] 解题思路123456789101112131415161718192021class Solution(object): def findDisappearedNumbers(self, nums): """ :type nums: List[int] :rtype: List[int] """ if len(nums) == 0: return [] for x in nums: if nums[abs(x)-1] &gt; 0: nums[abs(x)-1] *= -1 res = [] for i in range(len(nums)): if nums[i] &gt; 0: res.append(i+1) return res]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 双指针]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是双指针相关题目题解总结。 [TOC] 双指针双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。 11. 盛最多水的容器题目描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路双指针法，一个从前往后，一个从后往前，计算两个挡板之间的面积，然后向中间移动，那个挡板比较矮，就舍弃这个挡板。123456789101112131415161718192021class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ if height &lt;= 1: return False res = 0 left, right = 0, len(height)-1 while left &lt; right: temp = (right-left)*min(height[left], height[right]) if temp &gt; res: res = temp if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 15. 三数之和题目描述给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路先对数组进行排序，然后遍历数组，对每个位置都从它的后一个元素到末尾取两个元素加和，如果为0就添加到结果数组中。需要跳过相同的数字。12345678910111213141516171819202122232425262728293031class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) &lt;= 2: return [] nums.sort() res = [] for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: if nums[i] + nums[left] + nums[right] == 0: res.append([nums[i], nums[left], nums[right]]) left += 1 right -= 1 while left &lt; right and nums[left] == nums[left-1]: left += 1 while right &gt; left and nums[right] == nums[right+1]: right -= 1 elif nums[i] + nums[left] + nums[right] &gt; 0: right -= 1 else: left += 1 return res 16. 最接近的三数之和题目描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路12345678910111213141516171819202122232425262728class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ if len(nums) &lt;= 2: return 0 nums.sort() res = float('inf') for i in range(len(nums)-2): if i &gt; 0 and nums[i] == nums[i-1]: continue left, right = i+1, len(nums)-1 while left &lt; right: temp = nums[i]+nums[left]+nums[right] if abs(temp-target) &lt; abs(res-target): res = temp if temp == target: return target elif temp &lt; target: left += 1 else: right -= 1 return res 26. 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路双指针。第一个指向当前不重复的位置len，另一个不断向后遍历遇到不重复的就写到len位置。1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) i = 0 for j in range(1, len(nums)): if nums[j] != nums[i]: i += 1 nums[i] = nums[j] return i + 1 27. 移除元素题目描述给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1:12345给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:1234567给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeElement(self, nums, val): """ :type nums: List[int] :type val: int :rtype: int """ if len(nums) == 0: return 0 i = 0 for j in range(len(nums)): if nums[j] != val: nums[i] = nums[j] i += 1 return i 28. 实现strStr()题目描述实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1:12输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:12输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解题思路123456789101112131415161718class Solution(object): def strStr(self, haystack, needle): """ :type haystack: str :type needle: str :rtype: int """ if len(needle) == 0: return 0 if len(haystack) == 0 or len(haystack) &lt; len(needle): return -1 for i in range(len(haystack)-len(needle)+1): if haystack[i:i+len(needle)] == needle: return i return -1 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 80. 删除排序数组中的重复项 II题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1:12345给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2:12345给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) &lt;= 1: return len(nums) left = 0 for n in nums: if left &lt; 2 or n &gt; nums[left-2]: nums[left] = n left += 1 return left 88. 合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出:[1,2,2,3,5,6] 解题思路 从尾向前遍历，设置两个指针p1和p2遍历数组，p1，p2分别从m-1和n-1开始向前遍历； 每一次遍历将大的元素放到nums1后面（最后一位为m-n+1），并向前移动一步，直到一个数组先遍历完成； 若nums1首先遍历完成，则需要将nums2剩下的元素放到nums1的前面。 123456789101112131415161718192021222324252627class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ if len(nums1)&lt; m+n: return False p1,p2 = m-1,n-1 point = m+n-1 while p1&gt;= 0 and p2 &gt;= 0: if nums1[p1]&lt;nums2[p2]: nums1[point] = nums2[p2] p2 -= 1 else: nums1[point] = nums1[p1] p1 -= 1 point -= 1 if p2 &gt;= 0: nums1[:p2+1] = nums2[:p2+1]if __name__ == '__main__': result = Solution().merge([1,2,3,0,0,0],3,[2,5,6],3) print(result) 125. 验证回文串题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明： 本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: “A man, a plan, a canal: Panama”输出: true 示例 2: 输入: “race a car”输出: false 解题思路新建一个字符串，将所有数字字母保存；使用双指针，left从头向后遍历，right从后向前遍历，判断left和right指向的元素是否相等。 1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if s == '': return True new = '' for x in s: if x.isalnum(): new += x.lower() left, right = 0, len(new)-1 while left &lt;= right: if new[left] != new[right]: return False left += 1 right -= 1 return True if __name__ == '__main__': result = Solution().isPalindrome("A man, a plan, a canal: Panama") print(result) 二刷1234567891011121314151617181920212223class Solution(object): def isPalindrome(self, s): """ :type s: str :rtype: bool """ if len(s) &lt;= 1: return True s = s.lower() left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and not s[left].isalnum(): left += 1 while left &lt; right and not s[right].isalnum(): right -= 1 if s[left] != s[right]: return False left += 1 right -= 1 return True 141. 环形链表题目描述给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用双指针，一个一次走两步，另一个一次走一步，若有环，则必然相遇。 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明： 返回的下标值（index1 和 index2）不是从零开始， 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例： 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2。 解题思路使用两个指针left和right，left指向数组第一个元素并从头向后遍历，right指向数组最后一个元素并从尾向前遍历： 如果两个指针指向元素之和numbers[left]+numbers[right] == target, 则返回 [left+1,right+1]，结束； 如果两个指针指向元素之和numbers[left]+numbers[right] &gt; target，则right -= 1； 如果两个指针指向元素之和numbers[left]+numbers[right] &lt; target，则left += 1。 12345678910111213141516171819202122class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt; 2: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().twoSum([2,7,11,15], 9) print(result) 167. 两数之和 II - 输入有序数组题目描述给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例:123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路123456789101112131415161718192021class Solution(object): def twoSum(self, numbers, target): """ :type numbers: List[int] :type target: int :rtype: List[int] """ if len(numbers) &lt;= 1: return [] left, right = 0, len(numbers)-1 while left &lt; right: if numbers[left]+numbers[right] == target: return [left+1, right+1] elif numbers[left]+numbers[right] &gt; target: right -= 1 else: left += 1 return [] 209. 长度最小的子数组题目描述给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。 示例:123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 解题思路12345678910111213141516171819class Solution(object): def minSubArrayLen(self, s, nums): """ :type s: int :type nums: List[int] :rtype: int """ left, right = 0, 0 res = float('inf') while right &lt; len(nums) and left &lt;= right: if sum(nums[left:right+1]) &gt;= s: res = min(res, right-left+1) left += 1 else: right += 1 return res if res != float('inf') else 0 345. 反转字符串中的元音字母题目描述编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: “hello”输出: “holle” 示例 2: 输入: “Leetcode”输出: “leotcede” 说明: 元音字母不包含字母”y”。 解题思路元音字母有五个：aAeEIioOuU。使用双指针，left从头向后遍历，right从后向前遍历，分别找到元音字母时时进行一次交换。 1234567891011121314151617181920212223class Solution(object): def reverseVowels(self, s): """ :type s: str :rtype: str """ vowels = 'aAeEiIoOuU' s = list(s) left, right = 0, len(s)-1 while left &lt; right: while left &lt; right and s[left] not in vowels: left += 1 while right &gt; left and s[right] not in vowels: right -= 1 if left &lt; right: s[left],s[right] = s[right], s[left] left += 1 right -= 1 return ''.join(s)if __name__ == '__main__': result = Solution().reverseVowels("Leetcode") print(result) 524. 通过删除字母匹配到字典里最长单词题目描述给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。 示例 1: 输入:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]输出:“apple” 示例 2: 输入:s = “abpcplea”, d = [“a”,”b”,”c”]输出:“a” 说明: 所有输入的字符串只包含小写字母。字典的大小不会超过 1000。所有输入的字符串长度不会超过 1000。 解题思路先把d中元素排序，以长度为主，字典序为辅；然后遍历d中字符串，依此判断是否满足条件，满足条件则返回；因为经过了排序，第一个满足条件的可以保证返回长度最长且字典顺序最小的字符串。 123456789101112131415161718192021222324252627282930313233class Solution(object): def findLongestWord(self, s, d): """ :type s: str :type d: List[str] :rtype: str """ if len(d) == 0 or len(s) == 0: return '' d = sorted(d, key=lambda x: (-len(x), x)) res = '' for x in d: if self.judge(s,x): return x return '' def judge(self,s,x): if len(s) &lt; len(x): return False p1,p2 = 0, 0 while p1 &lt; len(s) and p2 &lt; len(x): if s[p1] == x[p2]: p1 += 1 p2 += 1 else: p1 += 1 if p2 == len(x): return True return Falseif __name__ == '__main__': result = Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) print(result) 633. 平方数之和题目描述给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。 示例1： 输入: 5输出: True解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3输出: False 解题思路假设\(a=0\)，则 \(b=\sqrt{c}\)，则最大整数为 \(\sqrt{c}\)，设置两个指针，left指向0并向前遍历，right指向\(\sqrt{c}\)并向后遍历： 如果 left*left+right*right = c， 返回True,结束； 如果 left*left+right*right &gt; c， right -= 1； 如果 left*left+right*right &lt; c， left += 1； 123456789101112131415161718192021class Solution(object): def judgeSquareSum(self, c): """ :type c: int :rtype: bool """ if c &lt; 0: return False left, right = 0, int(pow(c,1.0/2)) while left &lt;= right: if left*left+right*right == c: return True elif left*left+right*right &gt; c: right -= 1 else: left += 1 return Falseif __name__ == '__main__': result = Solution().judgeSquareSum(6) print(result) 680. 验证回文字符串 Ⅱ题目描述给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 输入: “aba”输出: True 示例 2: 输入: “abca”输出: True解释: 你可以删除c字符。 注意： 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 解题思路使用双指针，找到第一个不相等的位置后，去除left或着right后判断是否成为回文。 12345678910111213141516171819202122232425class Solution(object): def validPalindrome(self, s): """ :type s: str :rtype: bool """ left, right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return self.isPalindrome(s[:left]+s[left+1:]) or self.isPalindrome(s[:right]+s[right+1:]) left += 1 right -= 1 return True def isPalindrome(self,s): left ,right = 0, len(s)-1 while left &lt;= right: if s[left] != s[right]: return False left += 1 right -= 1 return Trueif __name__ == '__main__': result = Solution().validPalindrome("aba") print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 排序]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是排序相关题目题解总结。 [TOC] 排序快速排序用于求解 Kth 问题，使用快速排序的partition()进行实现，需要首先打乱数组，否则最坏情况下时间复杂度为O(N^2)。 堆排序用于求解 TopK 问题，通过维护一个大小为K的堆，堆中的元素就是TopK elements； 堆排序也可以用于求解 Kth 问题，堆顶元素就是 Kth elements； 快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements； 因此快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 56. 合并区间题目描述给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路 将区间按起始元素排序，新建返回res数组，遍历所有区间； 若res为空或res中最后一个区间的结束元素小于当前区间的起始元素，则无需合并，直接将该区间添加到res中；若res中最后一个区间的结束元素大于当前区间的起始元素，则需要合并，将res最后区间的结束元素置为原来的值与当前区间结束值的最大值。 1234567891011121314151617181920# Definition for an interval.# class Interval(object):# def __init__(self, s=0, e=0):# self.start = s# self.end = eclass Solution(object): def merge(self, intervals): """ :type intervals: List[Interval] :rtype: List[Interval] """ intervals = sorted(intervals, key=lambda x:x.start) res = [] for t in intervals: if not res or res[-1].end &lt; t.start: res.append(t) else: res[-1].end = max(res[-1].end,t.end) return res 57. 插入区间题目描述给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1:12输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2:123输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 解题思路12345678910111213141516171819202122class Solution(object): def insert(self, intervals, newInterval): """ :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] """ cur = 0 res = [] while cur &lt; len(intervals) and intervals[cur][1] &lt; newInterval[0]: res.append(intervals[cur]) cur += 1 while cur &lt; len(intervals) and intervals[cur][0] &lt;= newInterval[1]: newInterval[0] = min(intervals[cur][0], newInterval[0]) newInterval[1] = max(intervals[cur][1], newInterval[1]) cur += 1 res.append(newInterval) while cur &lt; len(intervals): res.append(intervals[cur]) cur += 1 return res 123456789101112131415161718class Solution(object): def insert(self, intervals, newInterval): """ :type intervals: List[List[int]] :type newInterval: List[int] :rtype: List[List[int]] """ intervals.append(newInterval) intervals = sorted(intervals, key = lambda x:x[0]) res = [intervals[0]] for i in range(1, len(intervals)): if intervals[i][0] &lt;= res[-1][1]: res[-1][1] = max(intervals[i][1], res[-1][1]) else: res.append(intervals[i]) return res 75. 颜色分类题目描述给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意: 不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。你能想出一个仅使用常数空间的一趟扫描算法吗？ 解题思路 设置两个头尾指针，头指针p0指向的位置是0该放置的位置，尾指针p2指向的位置是2该放置的位置。 i用来遍历整个数组，碰到0把它和p0指向的数交换，碰到2把它和p2指向的数交换，碰到1继续向后遍历。 有点类似快速排序的分割数组这一步。 123456789101112131415161718class Solution: def sortColors(self, nums): """ :type nums: List[int] :rtype: void Do not return anything, modify nums in-place instead. """ p0, p2 = 0, len(nums) -1 i = 0 while i &lt;= p2: if nums[i] == 0: nums[i],nums[p0] = nums[p0], nums[i] i += 1 p0 += 1 elif nums[i] == 2: nums[i], nums[p2] = nums[p2], nums[i] p2 -= 1 else: i += 1 147. 对链表进行插入排序题目描述对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。重复直到所有输入数据插入完为止。 示例 1： 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路插入排序：插入排序的实现上，通常采用 in-place 排序（即只需用到O(1)的额外空间的排序），用指针 head 逐一向后遍历 申请一个 dummyHead 节点，其下一个节点指向头结点。如果要在头结点出插入，dummyHead 会给我们带来便利； 当 head 的值不大于下一节点值，就进行遍历下一节点； 当 head 的值大于下一节点，那么就将 head 的下一节点取出，从前向后扫描，在第一个比它的值大的节点之前插入该节点。 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head.next: if head.val &lt;= head.next.val: head = head.next else: temp = head.next q = dummy head.next = head.next.next while q.next and q.next.val &lt; temp.val: q = q.next temp.next = q.next q.next = temp return dummy.next 1234567891011121314151617181920212223242526272829303132# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head while head and head.next: if head.val &lt;= head.next.val: head = head.next else: pre = dummy while pre.next and pre.next.val &lt;= head.next.val: pre = pre.next temp = head.next head.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路使用归并排序，使用快慢指针找到中间结点后进行递归。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = Nonehead = ListNode(4)head.next = ListNode(2)head.next.next = ListNode(1)head.next.next.next = ListNode(3)class Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None # left = self.sortList(leftHead) # right = self.sortList(rightHead) # sortMerge = self.merge(left,right) # return sortMerge return self.merge(self.sortList(leftHead),self.sortList(rightHead)) def getmiddle(self,head): if not head: return head fast = slow = head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self,leftHead,rightHead): dummyNode = ListNode(0) dummyHead = dummyNode i,j = leftHead, rightHead while i and j: if i.val &lt; j.val: dummyNode.next = i i = i.next else: dummyNode.next = j j = j.next dummyNode = dummyNode.next if i: dummyNode.next = i if j: dummyNode.next = j return dummyHead.nextif __name__ == '__main__': result = Solution().sortList(head) while result: print(result.val,end = ' ') result = result.next 179. 最大数题目描述给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 输入: [10,2]输出: 210 示例 2: 输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 解题思路两层循环遍历，每一个数和之后的每一个数进行比较，交换大的数放在前面；两个数谁应该放在前面：拼接两个字符串进行比较 a+b&gt;b+a，则a在前面。 1234567891011121314151617class Solution(object): def largestNumber(self, nums): """ :type nums: List[int] :rtype: str """ if len(nums) == 0: return '0' if len(nums) == 1: return str(nums[0]) for i in range(len(nums)-1): for j in range(i+1, len(nums)): if str(nums[i])+str(nums[j]) &lt; str(nums[j])+str(nums[i]): nums[i], nums[j] = nums[j], nums[i] return '0' if nums[0] == 0 else ''.join([str(x) for x in nums]) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路思路1：利用堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质；即子结点的键值或索引总是小于（或者大于）它的父节点。 通常堆是通过一维数组来实现的。在起始数组为 0 的情形中 父节点i的左子节点在位置 (2i+1)；父节点i的右子节点在位置 (2i+2)；子节点i的父节点在位置 floor((i-1)/2)。 堆的操作：在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义以下几种操作 最大堆调整（Min_Heapify）：将堆的末端子结点作调整，使得子结点永远小于父结点；创建最大堆（Build_Min_Heap）：将堆所有数据重新排序;注：堆排序不是一种稳定排序。 用小根堆得办法寻找最大的K个数 用容量为K的最小堆来存储最大的K个数。最小堆的堆顶元素就是最大K个数中的最小的一个；每次扫描一个数据X，如果X比堆顶元素Y小，则不需要改变原来的堆。如果X比堆顶元素大；那么用X替换堆顶元素Y，在替换之后，X可能破坏了最小堆的结构，需要调整堆来维持堆的性质；调整过程时间复杂度为O(logK)。 全部的时间复杂度为O(N*logK)；这种方法当数据量比较大的时候，比较方便。因为对所有的数据只会遍历一次。 堆排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k,len(nums)+1): if change: for j in range(k//2,-1,-1): self.adjust(res,j,k) for j in range(k-1,0,-1): res[j],res[0] = res[0],res[j] self.adjust(res,0,j) change = False if i != len(nums) and nums[i] &gt; res[k-1]: res[k-1] = nums[i] change = True return res[k-1] def adjust(self,res,parent,length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1]&lt;res[child]: child = child+1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = tempif __name__ == '__main__': result = Solution().findKthLargest([3,2,3,1,2,4,5,5,6],4) print(result) 思路2：利用快速排序 快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分：分割左边都是比它小的数，右边都是比它大的数。 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，因此达到整个数据变成有序序列。 举例：nums = [3,2,1,5,6,4] 首先以nums[0]=3为基准点，设置指针left指向第一个元素(0)，right指向最后一个元素(len(nums)-1)； 从右至左偏移right指针，寻找到第一个比基准点3小的元素，将该元素(这里为1)赋给left指针所指的位置，此时数组为[1,2,1,5,6,4]; 从左至右偏移left指针，寻找到第一个比基准点3大的元素，将该元素赋给right指针所指的位置，此时数组 不断循环步骤一二，知道left和right重合，将基准点3赋给重合位置，一轮排序结束数组为[1,2,3,5,6,4]; 经过递归过程，最后排序结束。 **快速排序1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left 思路3：归并排序12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = self.dfs(nums) return res[-k] def dfs(self, nums): if len(nums) &lt;= 1: return nums mid = len(nums)//2 left = self.dfs(nums[:mid]) right = self.dfs(nums[mid:]) return self.merge(left, right) def merge(self, left, right): res = [] i, j = 0, 0 while i &lt; len(left) and j &lt; len(right): if left[i] &lt; right[j]: res.append(left[i]) i += 1 else: res.append(right[j]) j += 1 if i &lt; len(left): res += left[i:] else: res += right[j:] return res 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 451. 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 分治算法]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是分治算法相关题目题解总结。 [TOC] 分治算法基本概念分治法字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或者更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。如快速排序，归并排序。 基本思想及策略分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治法的策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 分治法使用场景分治法所能解决的问题一般具有以下几个特征： 该问题的规模缩小到一定的程度就可以容易地解决； 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质； 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题； 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提，它也是大多数问题可以满足的，此特征反映了递归思想的应用； 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑使用贪心法或者动态规划法； 第四条特征涉及到分治法的效率，如果各子问题是不独立的，则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可以使用分治法，但一般动态规划较好。 分治法的基本步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； 解决：若子问题规模较小容易被解决则直接解，否则递归地解各个子问题； 合并：将各个子问题的解合并为原问题的解。 分治法的应用二分搜索大整数乘法Strassen矩阵乘法棋盘覆盖合并排序快速排序线性时间选择最接近点对问题循环赛日程表汉诺塔 二分搜索 二分搜索的要求：线性表为有序表，并且要用向量作为表的存储结构； 二分搜索得基本思想：先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录位置。1234567891011121314151617class Solution(object): def searchRange(self, nums, key): """ :type nums: List[int] :type target: int :rtype: List[int] """ return self.bSearch(nums, 0, len(nums)-1,key) def bSearch(self, nums, left, right, key): mid = (left+right) // 2 if nums[mid] == key: return mid elif nums[mid] &gt; key: return self.bSearch(nums,left,mid-1,key) else: return self.bSearch(nums, mid+1,right,key) 汉诺塔从左到右 A B C 柱 大盘子在下, 小盘子在上, 借助B柱将所有盘子从A柱移动到C柱, 期间只有一个原则: 大盘子只能在小盘子的下面。求解思路： 当盘子只有一个的时候,只有一个动作 从 A 移动到 C 即结束； 当有N个盘子的时候, 中间的动作是从 A 移动到 C, 表示最下面的第N个盘子移动完毕； 中间动作之上都可以认为是: 从 A 移动到 B； 中间动作之下都可以认为是: 从 B 移动到 C。 12345678910class Solution(object): def move(self, n, a, b, c): if n == 1: print(a+&apos;-&gt;&apos;+c) else: self.move(n-1, a, c, b) print(a+&apos;-&gt;&apos;+ c) self.move(n-1, b, a, c)if __name__ == &apos;__main__&apos;: Solution().move(3,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;) 参考https://www.cnblogs.com/xsyfl/p/6921687.htmlhttps://blog.csdn.net/not_guy/article/details/72823951 241. 为运算表达式设计优先级题目描述给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。 示例 1: 输入: “2-1-1”输出: [0, 2]解释:((2-1)-1) = 0(2-(1-1)) = 2 示例 2: 输入: “23-45”输出: [-34, -14, -10, -10, 10]解释:(2(3-(45))) = -34((23)-(45)) = -14((2(3-4))5) = -10(2((3-4)5)) = -10(((23)-4)5) = 10 解题思路如果字符串为数字直接返回；使用分治法，遍历字符串，当遇到运算符时，将字符串分为运算符前及运算符后两部分，根据运算符做相应运算。1234567891011121314151617181920212223242526272829class Solution(object): def diffWaysToCompute(self, input): &quot;&quot;&quot; :type input: str :rtype: List[int] &quot;&quot;&quot; if input.isdigit(): return [int(input)] res = [] for i in range(len(input)): if input[i] in &apos;+-*&apos;: left = self.diffWaysToCompute(input[:i]) right = self.diffWaysToCompute(input[i+1:]) for j in left: for k in right: res.append(self.helper(j, k, input[i])) return res def helper(self, j, k, op): if op == &apos;+&apos;: return j + k elif op == &apos;-&apos;: return j - k elif op == &apos;*&apos;: return j * kif __name__ == &apos;__main__&apos;: result = Solution().diffWaysToCompute(&quot;2*3-4*5&quot;) print(result) 169. 求众数题目描述给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在众数。 示例 1: 输入: [3,2,3]输出: 3 示例 2: 输入: [2,2,1,1,1,2,2]输出: 2 解题思路摩尔投票法 维护一个候选数candidate和计数器counter。遍历数组中所有的元素， 设当前的元素为x，若 counter = 0,则 candidate = x, counter = 1; 否则， 根据candidate 与x是否相等来更新counter（相等+1，不等-1）在遍历一次，判断候选数是否为合法的主元素。为什么这样做是对的呢？因为若在有解的情况下，一个元素y出现&gt;n/2次，那么要抵消掉它，必然也要有相同的元素才行，而总的元素才n个，也就是说元素y在这样的计数中不会被抵消。保证有解的情况最后的候选数就是主要元素。1234567891011121314151617181920class Solution(object): def majorityElement(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; candidate = 0 count = 0 for x in nums: if count == 0: count = 1 candidate = x elif x == candidate: count += 1 else: count -= 1 return candidateif __name__ == &apos;__main__&apos;: result = Solution().majorityElement([6,5,5]) print(result) 215. 数组中的第K个最大元素题目描述在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 解题思路 堆排序。 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 res = nums[:k] change = True for i in range(k, len(nums)+1): if change: for j in range(k//2, -1, -1): self.adjust(res, j, k) for j in range(k-1, 0, -1): res[j], res[0] = res[0], res[j] self.adjust(res, 0, j) change = False if i != len(nums) and nums[i] &gt; res[-1]: res[-1] = nums[i] change = True return res[-1] def adjust(self, res, parent, length): temp = res[parent] child = 2*parent+1 while child &lt; length: if child+1 &lt; length and res[child+1] &lt; res[child]: child += 1 if temp &lt; res[child]: break res[parent] = res[child] parent = child child = 2*parent+1 res[parent] = temp 分治算法，这里使用快速排序算法。 通过一趟排序将要排序的数据分割成两个独立的两部分：左部分都是比它小的数，右部分都是比它大的数； 然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，最终使整个数据变成有序序列。 1234567891011121314151617181920212223242526272829303132class Solution(object): def findKthLargest(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ if len(nums) &lt; k or k &lt;= 0: return 0 self.Qsort(nums, 0, len(nums)-1) return nums[-k] def Qsort(self, nums, left, right): if left &lt; right: index = self.division(nums, left, right) self.Qsort(nums, left, index-1) self.Qsort(nums, index+1, right) def division(self, nums, left, right): base = nums[left] while left &lt; right: while right &gt; left and nums[right] &gt;= base: right -= 1 nums[left] = nums[right] while left &lt; right and nums[left] &lt;= base: left += 1 nums[right] = nums[left] nums[left] = base return left]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 回溯算法]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是回溯算法相关题目题解总结。 [TOC] 回溯算法回溯算法属于DFS。在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。 普通DFS主要用于可达性问题，这种问题只需要执行到特定的位置然后返回即可； 而Backtracking主要用于求解排列组合问题，例如有 { ‘a’,’b’,’c’ } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。 Backtracking的基本思想是： 从一条路往前走，能进则进，不能进则退回来，换一条路再试。 八皇后问题就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。 回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。 回溯算法说白了就是穷举法。 因为 Backtracking 不是立即就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素； 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。 17. 电话号码的字母组合题目描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 解题思路回溯。要求所有位置都要有字母，即组合的长度为数字的长度。 123456789101112131415161718192021class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] dic = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; res = [] self.dfs(digits, 0, '', dic, res) return res def dfs(self, digits, index, path, dic, res): if len(path) == len(digits): if path: res.append(path) return if digits[index] not in dic: return [] for j in dic[digits[index]]: self.dfs(digits, index+1, path+j, dic, res) 123456789101112131415161718192021222324252627class Solution(object): def letterCombinations(self, digits): """ :type digits: str :rtype: List[str] """ if len(digits) == 0: return [] Dict = &#123;'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'&#125; strs = [] for x in digits: strs.append(Dict[x]) res = [] self.dfs(strs, 0, '', res) return res def dfs(self, strs, index, path, res): if len(path) == len(strs): res.append(path) return for j in strs[index]: self.dfs(strs, index+1, path+j, res) 22. 括号生成题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 解题思路回溯。如果左括号还有剩余，则放置左括号，如果有括号剩余数大于左括号，则可以放置有括号，停止条件为所有括号全部放置完。 12345678910111213141516171819class Solution(object): def generateParenthesis(self, n): """ :type n: int :rtype: List[str] """ if n &lt;= 0: return [] res = [] self.dfs(n, n, '', res) return res def dfs(self, left, right, path, res): if left == 0 and right == 0: res.append(path) return if left &gt; 0: self.dfs(left-1, right, path+'(', res) if left &lt; right: self.dfs(left, right-1, path+')', res) 39. 组合总和题目描述给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解题思路先进行排序在dfs。123456789101112131415161718192021class Solution(object): def combinationSum(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, start, templist, res): if residue == 0: res.append(templist) return for i in range(start, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i, templist+[candidates[i]], res) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Arrays;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates.length==0) return res; Arrays.sort(candidates); dfs(candidates, new ArrayList&lt;&gt;(), 0, target, res); return res; &#125; public void dfs(int[] candidates, List&lt;Integer&gt; path, int index, int target, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (target == 0 &amp;&amp; !(res.contains(path)))&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i&lt; candidates.length;i++)&#123; if (candidates[i] &gt; target)&#123; break; &#125; path.add(candidates[i]); dfs(candidates, path, i, target-candidates[i], res); path.remove(path.size() - 1); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;2,3,5&#125;; List&lt;List&lt;Integer&gt;&gt; res = sol.combinationSum(nums, 8); System.out.print(res); &#125;&#125; 40. 组合总和 II题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解题思路和39差不多，加判断条件防止res中出现重复项，调用时为i+1，防止重复的数字。12345678910111213141516171819202122class Solution(object): def combinationSum2(self, candidates, target): """ :type candidates: List[int] :type target: int :rtype: List[List[int]] """ if len(candidates) == 0: return [] res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, candidates, residue, index, templist, res): if residue == 0 and templist not in res: res.append(templist) return for i in range(index, len(candidates)): if candidates[i] &gt; residue: return self.dfs(candidates, residue-candidates[i], i+1, templist+[candidates[i]], res) 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Arrays;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (candidates.length==0) return res; Arrays.sort(candidates); dfs(candidates, new ArrayList&lt;&gt;(), 0, target, res); return res; &#125; public void dfs(int[] candidates, List&lt;Integer&gt; path, int index, int target, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (target == 0 &amp;&amp; !(res.contains(path)))&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = index; i&lt; candidates.length;i++)&#123; if (candidates[i] &gt; target)&#123; break; &#125; path.add(candidates[i]); dfs(candidates, path, i+1, target-candidates[i], res); path.remove(path.size() - 1); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); int [] nums = new int[]&#123;2,3,5&#125;; List&lt;List&lt;Integer&gt;&gt; res = sol.combinationSum(nums, 8); System.out.print(res); &#125;&#125; 46. 全排列题目描述给定一个没有重复数字的序列，返回其所有可能的全排列。 示例:12345678910输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解题思路12345678910111213141516171819202122class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(temp) == len(nums): res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permute(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, path, res): if not nums: res.append(path) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res) 123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.List;class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); dfs(nums, new ArrayList&lt;&gt;(), res); return res; &#125; public void dfs(int[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)&#123; if (path.size() == nums.length)&#123; res.add(new ArrayList&lt;&gt;(path)); return; &#125; for (int i = 0; i&lt;nums.length; i++)&#123; if (!(path.contains(nums[i])))&#123; path.add(nums[i]); dfs(nums, path, res); path.remove(path.size()-1); &#125; &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Solution sol = new Solution(); List&lt;List&lt;Integer&gt;&gt; res = sol.permute(new int []&#123;1,2,3&#125;);// System.out.print(); &#125;&#125; 47. 全排列 II题目描述给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例:1234567输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解题思路123456789101112131415161718192021class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] visited = [False] * len(nums) self.dfs(nums, [], visited, res) return res def dfs(self, nums, temp, visited, res): if len(nums) == len(temp) and temp not in res: res.append(temp) return for i in range(len(nums)): if not visited[i]: visited[i] = True self.dfs(nums, temp+[nums[i]], visited, res) visited[i] = False 12345678910111213141516class Solution(object): def permuteUnique(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] res = [] self.dfs(nums, [], res) return res def dfs(self, nums, temp, res): if not nums and temp not in res: res.append(temp) for i in range(len(nums)): self.dfs(nums[:i]+nums[i+1:], temp+[nums[i]], res) 51. N皇后题目描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例:12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 解题思路N皇后定义：在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 回溯算法。建立一个nxn的全是点的数组，从第0行开始遍历。判断当前行是否已经超过矩阵范围，如果是，说明找到一种解法，加到res中。否则，遍历当前行的所有列的位置，对于每一个位置，判断当前位置是否会产生冲突（isValid，判断两条对角线和一个垂直线），若当前行找到一个没有冲突的位置，则对下一行进行递归查找。 12345678910111213141516171819202122232425262728293031323334353637383940import copyclass Solution(object): def solveNQueens(self, n): """ :type n: int :rtype: List[List[str]] """ res = [] queens = [['.'] * n for _ in range(n)] self.helper(0, queens, res) for queens in res: for i in range(len(queens)): queens[i] = ''.join(queens[i]) return res def helper(self, curRow, queens, res): if curRow == len(queens): res.append(copy.deepcopy(queens)) return for i in range(len(queens)): if self.isValid(queens, curRow, i): queens[curRow][i] = 'Q' self.helper(curRow + 1, queens, res) queens[curRow][i] = '.' def isValid(self, queens, row, col): for i in range(row): if queens[i][col] == 'Q': return False i, j = row - 1, col - 1 while i &gt;= 0 and j &gt;= 0: if queens[i][j] == 'Q': return False i, j = i - 1, j - 1 i, j = row - 1, col + 1 while i &gt;= 0 and j &lt; len(queens): if queens[i][j] == 'Q': return False i, j = i - 1, j + 1 return True 52. N皇后 II题目描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:1234567891011121314输入: 4输出: 2解释: 4 皇后问题存在如下两个不同的解法。[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]] 解题思路12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def totalNQueens(self, n): """ :type n: int :rtype: int """ self.res = 0 queens = [['.']*n for _ in range(n)] self.helper(0, queens) return self.res def helper(self, curRow, queens): if curRow == len(queens): self.res += 1 return for i in range(len(queens)): if self.isValid(queens, curRow, i): queens[curRow][i] = 'Q' self.helper(curRow+1, queens) queens[curRow][i] = '.' def isValid(self, queens, row, col): for i in range(row): if queens[i][col] == 'Q': return False i, j = row-1, col-1 while i &gt;= 0 and j &gt;= 0: if queens[i][j] == 'Q': return False i, j = i-1, j-1 i, j = row-1, col+1 while i &gt;= 0 and j &lt; len(queens): if queens[i][j] == 'Q': return False i, j = i-1, j+1 return True 60. 第k个排列题目描述给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： “123” “132” “213” “231” “312” “321” 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3输出: “213” 示例 2: 输入: n = 4, k = 9输出: “2314” 解题思路所有元素共有 n! 种排列。根据下图对’1234’的全排列，按照第一个字符可以分为4组，按照第二个字符可以分为3组，按照第三个字符可以分为2组，所以一共有4x3x2种排列方式。 要得到第九个排列’2314’，转换为数组下标也就是8，在level 1 中下标为1，level 2 中下标为1，level 3 中下标为0。具体过程为： 最高位可以取{1,2,3,4}，并且每个数在最高位出现3!=6次，第9个排序的最高位下标为：8//3!=1，也就是2； 次位可以取{1,3,4}，并且每个数在次位出现2!=2次，第9个排序的最高位下标为：(8%6)//2!=1，也就是3; 第三位可以取{1,4},并且每个数在第三位出现1次，第9个排列的第三位取值下标为：(8%6%2)//1=0，也就是1； 最后一位只有一个数字4。 用ki表示在数组中的取值下标，n表示集合中数字个数： k = k-1，此步是关键 k1 = k//(n-1)! k = k%(n-1)! k2 = k//(n-2)! k = k%(n-2)! … kn-1 = k//1 参考文章1234567891011121314151617181920212223class Solution(object): def getPermutation(self, n, k): """ :type n: int :type k: int :rtype: str """ if n &lt;= 0: return '' fact = [1]*n for i in range(1,n): fact[i] = fact[i-1]*i if k &gt; fact[-1]*n: return '' k = k-1 res = '' num = [str(i) for i in range(1,n+1)] for i in range(n, 0, -1): index = k // fact[i-1] res += num[index] k = k % fact[i-1] num.pop(index) return res 77. 组合题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:12345678910输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解题思路回溯法，我们抽取第一个字符，然后从后面n-1个字符中抽取k-1个；抽取第二个字符，再从后面的n-2个字符抽出k-1. 12345678910111213141516171819202122class Solution(object): def combine(self, n, k): """ :type n: int :type k: int :rtype: List[List[int]] """ if n &lt;= 0 or k &lt;= 0: return [] res = [] self.dfs(range(1, n+1), k, [], res) return res def dfs(self, nums, k, path, res): if k &gt; len(nums): return if k == 0: res.append(path) return for i in range(len(nums)): self.dfs(nums[i+1:], k-1, path+[nums[i]], res) 78. 子集题目描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:123456789101112输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解题思路12345678910111213141516class Solution(object): def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [[]] res = [] self.dfs(nums, 0, res, []) return res def dfs(self, nums, index, res, path): res.append(path) for i in range(index, len(nums)): self.dfs(nums, i+1, res, path+[nums[i]]) 79. 单词搜索题目描述给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例:12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true.给定 word = &quot;SEE&quot;, 返回 true.给定 word = &quot;ABCB&quot;, 返回 false. 解题思路Leetcode65题12345678910111213141516171819202122232425262728293031323334class Solution(object): def exist(self, board, word): """ :type board: List[List[str]] :type word: str :rtype: bool """ if len(board) == 0: return False if len(word) == 0: return True visited = [[False]*len(board[0]) for i in range(len(board))] for i in range(len(board)): for j in range(len(board[0])): if self.helper(board, word, i, j, 0, visited): return True return False def helper(self, board, word, i, j, pathlength, visited): if pathlength == len(word): return True curHaspath = False if 0&lt;=i&lt;len(board) and 0&lt;=j&lt;len(board[0]) and board[i][j] == word[pathlength] and not visited[i][j]: visited[i][j] = True pathlength += 1 curHaspath = self.helper(board,word,i+1,j,pathlength,visited) or self.helper(board,word,i-1,j,pathlength,visited) or self.helper(board,word,i,j+1,pathlength,visited) or self.helper(board,word,i,j-1,pathlength,visited) if not curHaspath: visited[i][j] = False pathlength -= 1 return curHaspath 89. 格雷编码题目描述格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例 1:123456789101112131415输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2:12345输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解题思路格雷码的生成过程：res[i] = i ^ (i//2)。如n = 3： res[0] = 0 = 000 res[1] = 1^(1//2) = 001^000 = 001 res[2] = 2^(2//2) = 010^001 = 011 res[3] = 3^(3//2) = 011^001 = 010 res[4] = 4^(4//2) = 100^010 = 110 res[5] = 5^(5//2) = 101^010 = 111 res[6] = 6^(6//2) = 110^011 = 101 res[7] = 7^(7//2) = 111^011 = 100 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] num = 1 for i in range(n): num *= 2 res = [0]*num while i &lt; num: res[i] = i ^ (i//2) i += 1 return res 12345678910111213141516class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ if n &lt; 0: return [] res = [0]*(2**n) for i in range(len(res)): res[i] = i^(i//2) return res 90. 子集 II题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例:12345678910输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解题思路123456789101112131415161718192021class Solution(object): def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ if len(nums) == 0: return [] nums.sort() res = [] self.dfs(nums, 0, [], res) return res def dfs(self, nums, index, path, res): if path not in res: res.append(path) for i in range(index, len(nums)): if i &gt; index and nums[i] == nums[i-1]: continue self.dfs(nums, i+1, path+[nums[i]], res) 93. 复原IP地址题目描述给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例: 输入: “25525511135”输出: [“255.255.11.135”, “255.255.111.35”] 解题思路IP地址由四部分组成，每一部分的数字为0~255，使用回溯算法验证每一部分的数字大小,一部分数字做多为3位（range(1,4))，在使用完字符串中所有字符且当前IP地址为四部分时添加到结果中。每次dfs的时候都去检查一下所有的字符串的长度是不是能满足在最多4个3位数字组成。 123456789101112131415161718192021222324class Solution(object): def restoreIpAddresses(self, s): """ :type s: str :rtype: List[str] """ if not s or len(s) &lt; 4 or len(s) &gt; 12: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and len(temp) == 4: res.append('.'.join(temp)) return if len(temp) &gt;= 4 or len(s) &gt; (4-len(temp))*3: return for i in range(1, 4): if i &gt; len(s): continue number = int(s[:i]) if str(number) == s[:i] and number &lt;= 255: self.dfs(s[i:], temp + [s[:i]], res) 131. 分割回文串题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。 返回 s 所有可能的分割方案。 示例:123456输入: &quot;aab&quot;输出:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 解题思路在每次回溯之前判断当前字符串是否为回文串。 1234567891011121314151617181920212223242526272829class Solution(object): def partition(self, s): """ :type s: str :rtype: List[List[str]] """ if not s: return [] res = [] self.dfs(s, [], res) return res def dfs(self, s, temp, res): if not s and temp: res.append(temp) return for i in range(1, len(s)+1): if self.isPalindrome(s[:i]): self.dfs(s[i:], temp+[s[:i]], res) def isPalindrome(self, s): # left, right = 0, len(s)-1 # while left &lt;= right: # if s[left] != s[right]: # return False # left += 1 # right -= 1 # return True return s == s[::-1] 216. 组合总和 III题目描述找出所有相加之和为 n的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1:12**输入:*****k*** = 3, ***n*** = 7**输出:** [[1,2,4]] 示例 2:12**输入:*****k*** = 3, ***n*** = 9**输出:** [[1,2,6], [1,3,5], [2,3,4]] 解题思路123456789101112131415161718192021222324class Solution(object): def combinationSum3(self, k, n): """ :type k: int :type n: int :rtype: List[List[int]] """ if k == 0 or n == 0: return [] res = [] self.help(k, 1, n, [], res) return res def help(self, k, index, n, path, res): if k == 0: if n == 0: res.append(path) return for i in range(index, 10): if n - i &lt; 0: break self.help(k-1, i+1, n-i, path + [i], res)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 链表]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是链表相关题目题解总结。 [TOC] 链表2. 两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 解题思路设置哨兵节点，每次新建节点保存当前位的值，并将进位给下一次迭代用。 1234567891011121314151617181920212223242526272829# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = ListNode(0) cur = dummy plus = 0 while l1 or l2 or plus: if l1: plus += l1.val l1 = l1.next if l2: plus += l2.val l2 = l2.next cur.next = ListNode(plus%10) plus //= 10 cur = cur.next return dummy.next 19. 删除链表的倒数第N个节点题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 解题思路新建伪结点，先让原指针走n步，寻找到删除的位置，然后一起遍历，原指针走到尾了，伪指针走到要删除节点的前一个，将伪指针的下一个节点跳过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def removeNthFromEnd(self, head, n): """ :type head: ListNode :type n: int :rtype: ListNode """ if not head or n &lt; 0: return None dummy = ListNode(0) dummy.next = head pre = dummy for i in range(n): head = head.next while head: head = head.next pre = pre.next pre.next = pre.next.next return dummy.next 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public String toString() &#123; return "ListNode [val=" + val + "]"; &#125;&#125;class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode fast = dummy, slow = dummy; for (int i = 0; i &lt; n; i++)&#123; fast = fast.next; &#125; while (fast.next != null)&#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return dummy.next; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode ln1= new ListNode(1); ListNode ln2= new ListNode(2); ListNode ln3= new ListNode(3); ListNode ln4= new ListNode(4); ListNode ln5= new ListNode(5); ln1.next=ln2; ln2.next=ln3; ln3.next=ln4; ln4.next=ln5; ln5.next=null; Solution sol = new Solution(); ListNode res = sol.removeNthFromEnd(ln1, 2); while (res!=null) &#123; System.out.println(res.toString()); res = res.next; &#125; &#125;&#125; 21. 合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题思路123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeTwoLists(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ if not l1: return l2 if not l2: return l1 dummy = ListNode(0) pre = dummy while l1 and l2: if l1.val &lt; l2.val: pre.next = ListNode(l1.val) l1 = l1.next else: pre.next = ListNode(l2.val) l2 = l2.next pre = pre.next pre.next = l1 if l1 else l2 return dummy.next 23. 合并K个排序链表题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例:1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解题思路分治+归并1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; if len(lists) == 0: return None if len(lists) == 1: return lists[0] mid = len(lists) // 2 left = self.mergeKLists(lists[:len(lists)//2]) right = self.mergeKLists(lists[len(lists)//2:]) return self.merge(left, right) def merge(self, left, right): if not left: return right if not right: return left dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 24. 两两交换链表中的节点题目描述给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 示例:1给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 说明: 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路设置头节点，向后遍历。 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while pre.next and pre.next.next: cur = pre.next pre.next = pre.next.next cur.next = cur.next.next pre.next.next = cur pre = pre.next.next return dummy.next 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public String toString() &#123; return "ListNode [val=" + val + "]"; &#125;&#125;class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if (head==null || head.next == null) return head; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; while (pre!=null &amp;&amp; pre.next!=null &amp;&amp; pre.next.next!=null)&#123; ListNode Node = new ListNode(pre.next.val); Node.next = pre.next.next.next; pre.next = pre.next.next; pre.next.next = Node; pre = pre.next.next; &#125; return dummy.next; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; ListNode ln1= new ListNode(1); ListNode ln2= new ListNode(2); ListNode ln3= new ListNode(3); ListNode ln4= new ListNode(4); ListNode ln5= new ListNode(5); ln1.next=ln2; ln2.next=ln3; ln3.next=ln4; ln4.next=ln5; ln5.next=null; Solution sol = new Solution(); ListNode res = sol.swapPairs(ln1); while (res!=null) &#123; System.out.println(res.toString()); res = res.next; &#125; &#125;&#125; 25. K 个一组翻转链表题目描述给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例 :12345给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 解题思路求出翻转的次数+对每一次进行反转 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseKGroup(self, head, k): &quot;&quot;&quot; :type head: ListNode :type k: int :rtype: ListNode &quot;&quot;&quot; if not head or not head.next or k &lt;= 1: return head length = 0 pre = head while pre: length += 1 pre = pre.next cycle = length // k dummy = ListNode(0) dummy.next = head pre = dummy for i in range(cycle): start, end = i*k, (i+1)*k-1 cur = pre.next for i in range(start, end): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp for i in range(k): pre = pre.next return dummy.next 61. 旋转链表题目描述给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1:12345输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2:1234567输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解题思路先求链表长度，当k&gt;length时，k对length求余，然后将链表后k个移到开头；使用快慢指针的方法找到后面k个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def rotateRight(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ if not head or not head.next: return head length = 0 cur = head while cur: cur = cur.next length += 1 k = k % length if k == 0: return head fast, slow = head, head for i in range(k): fast = fast.next while fast.next: fast = fast.next slow = slow.next temp = slow.next slow.next = None fast.next = head # temp 就是结果，直接返回也可 head = temp return head 82. 删除排序链表中的重复元素 II题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1:12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2:12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解题思路要删除重复的节点，而头节点就有可能是重复的节点，因此新建头节点，同样的值略过。 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy while head and head.next: if head.val != head.next.val: head = head.next pre = pre.next else: val = head.val while head and head.val == val: head = head.next pre.next = head return dummy.next 83. 删除排序链表中的重复元素题目描述给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1:12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2:12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解题思路每次迭代判断当前节点和下一节点是否相等，若相等，该节点的下个节点等于下个节点的下个节点，相当于下个节点和当前节点相等，就跳过下个节点。 当当前节点和下一节点不相等时，当前节点往前走，判断下一节点。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head cur = head while cur.next: if cur.val == cur.next.val: cur.next = cur.next.next else: cur = cur.next return head 86. 分隔链表题目描述给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例:12输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解题思路用两个指针，分别保存比x小的及比x大的值，对原链表进行遍历根据值的大小拼接在相应的链表后面，最后在把两个链表拼接在一起就可以了。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def partition(self, head, x): """ :type head: ListNode :type x: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) pre = dummy larger = ListNode(0) temp = larger while head: if head.val &lt; x: pre.next = head pre = pre.next else: node = ListNode(head.val) temp.next = node temp = temp.next head = head.next pre.next = larger.next return dummy.next 92. 反转链表 II题目描述反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy count = 1 while pre.next and count &lt; m: pre = pre.next count += 1 if count &lt; m: return head mNode = pre.next cur = mNode.next while cur and count &lt; n: Next = cur.next cur.next = pre.next pre.next = cur mNode.next = Next cur = Next count += 1 return dummy.next 123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head pre = dummy for i in range(m-1): pre = pre.next cur = pre.next for i in range(n-m): temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 109. 有序链表转换二叉搜索树题目描述给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例:123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解题思路将链表转换为数组，然后构建二叉搜索树。 12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = None# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedListToBST(self, head): """ :type head: ListNode :rtype: TreeNode """ if not head: return None array = [] while head: array.append(head.val) head = head.next return self.helper(array) def helper(self, array): if len(array) == 0: return None mid = len(array)//2 root = TreeNode(array[mid]) root.left = self.helper(array[:mid]) root.right = self.helper(array[mid+1:]) return root 138. 复制带随机指针的链表题目描述给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深度拷贝。 解题思路首先复制label和next指针，然后复制random指针，最后拆分新旧链表。 12345678910111213141516171819202122232425262728293031323334353637383940# Definition for singly-linked list with a random pointer.# class RandomListNode(object):# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution(object): def copyRandomList(self, head): """ :type head: RandomListNode :rtype: RandomListNode """ if not head: return head pre = head while pre: temp = pre.next pre.next = RandomListNode(pre.label) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next cur = res pre = head while pre: pre.next = pre.next.next if cur.next: cur.next = cur.next.next pre = pre.next cur = cur.next return res 二刷1234567891011121314151617181920212223242526272829303132333435363738394041"""# Definition for a Node.class Node(object): def __init__(self, val, next, random): self.val = val self.next = next self.random = random"""class Solution(object): def copyRandomList(self, head): """ :type head: Node :rtype: Node """ if not head: return head pre = head while pre: temp = pre.next pre.next = Node(pre.val, None, None) pre.next.next = temp pre = pre.next.next pre = head while pre: if pre.random: pre.next.random = pre.random.next pre = pre.next.next res = head.next pre = res while head: head.next = head.next.next if pre.next: pre.next = pre.next.next head = head.next pre = pre.next return res 141. 环形链表题目描述给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路使用快慢指针，如果有环一定相遇。 1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def hasCycle(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return False fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 142. 环形链表 II题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 解题思路快慢指针，找到换之后，一个指针从头遍历。 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: fast = head while fast != slow: fast = fast.next slow = slow.next return fast return None 集合。将访问过的节点保存起来，遍历节点，如果节点在字典中，则说明重复是为环的入口；否则没有环。1234567891011121314151617181920212223# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def detectCycle(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return None Dict = set() while head: if head in Dict: return head Dict.add(head) head = head.next return None 143. 重排链表题目描述给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1:1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2:1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路 使用快慢指针先将链表从中间截断为两个链表，如果链表长度为奇数，则第一条链表长度多1；如1,2,3,4,5，拆分为1,2,3和4,5； 将第二条链表翻转；即4,5翻转为5,4 然后归并合并。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reorderList(self, head): """ :type head: ListNode :rtype: void Do not return anything, modify head in-place instead. """ if not head or not head.next or not head.next.next: return fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next frontend = head backend = slow.next slow.next = None dummy = ListNode(0) dummy.next = backend cur = backend.next backend.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp backend = dummy.next p1 = frontend p2 = backend while p2: temp1 = p1.next temp2 = p2.next p1.next = p2 p2.next = temp1 p1 = temp1 p2 = temp2 147. 对链表进行插入排序题目描述对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1：12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2：12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路如果链表本来就是升序的，则往后遍历；否则如果一个节点的值小于前一个节点，寻找合适的位置插入。12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def insertionSortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head while cur.next: if cur.val &lt; cur.next.val: cur = cur.next else: pre = dummy while pre.next and pre.next.val &lt; cur.next.val: pre = pre.next temp = cur.next cur.next = temp.next temp.next = pre.next pre.next = temp return dummy.next 148. 排序链表题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1:12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2:12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解题思路归并排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def sortList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head mid = self.getmiddle(head) leftHead = head rightHead = mid.next mid.next = None left = self.sortList(leftHead) right = self.sortList(rightHead) return self.merge(left, right) def getmiddle(self, head): if not head or not head.next: return head fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next return slow def merge(self, left, right): dummy = ListNode(0) pre = dummy while left and right: if left.val &lt; right.val: pre.next = left left = left.next else: pre.next = right right = right.next pre = pre.next pre.next = left if left else right return dummy.next 160. 相交链表题目描述编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1：123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路链表拼接 1234567891011121314151617181920212223242526# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None a, b = headA, headB while a or b: if not a: a = headB if not b: b = headA if a == b: return a a, b = a.next, b.next return None 第一次遍历，先计算两个链表的长度；第二次遍历，让长的先走长度差，然后同时移动，判断是否有相同节点。12345678910111213141516171819202122232425262728293031323334353637# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def getIntersectionNode(self, headA, headB): """ :type head1, head1: ListNode :rtype: ListNode """ if not headA or not headB: return None countA = countB = 0 a, b = headA, headB while a: a = a.next countA += 1 while b: b = b.next countB += 1 if countA &gt; countB: for i in range(countA-countB): headA = headA.next else: for i in range(countB-countA): headB = headB.next while headA and headB: if headA == headB: return headA headA, headB = headA.next, headB.next return None 206. 反转链表题目描述反转一个单链表。 示例:12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路迭代123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122232425# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseList(self, head): """ :type head: ListNode :rtype: ListNode """ if not head or not head.next: return head return self.helper(head, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 234. 回文链表题目描述请判断一个链表是否为回文链表。 示例 1:12输入: 1-&gt;2输出: false 示例 2:12输入: 1-&gt;2-&gt;2-&gt;1输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 解题思路12345678910111213141516171819202122232425262728293031323334353637383940414243444546# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True fast, slow = head, head while fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None dummy = ListNode(0) dummy.next = right cur = right.next right.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp right = dummy.next while right: if right.val != left.val: return False right = right.next left = left.next return True 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bool """ if not head or not head.next: return True left, right = self.splitLink(head) right = self.reverseLink(right) while right: if right.val != left.val: return False right = right.next left = left.next return True def splitLink(self, head): fast, slow = head, head while fast and fast.next and fast.next.next: fast = fast.next.next slow = slow.next left = head right = slow.next slow.next = None return left, right def reverseLink(self, head): if not head or not head.next: return head dummy = ListNode(0) dummy.next = head cur = head.next head.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 123456789101112131415161718192021# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def isPalindrome(self, head): """ :type head: ListNode :rtype: bosol """ if not head or not head.next: return True res = [] while head: res.append(head.val) head = head.next return res == res[::-1]]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode题解 - 哈希表]]></title>
    <url>%2F2019%2F07%2F16%2FLeetCode%2FLeetcode-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为Leetcode刷题笔记，刷题平台为Leetcode中文站， 刷题按Tag分类。本系列题解汇总如下 (持续更新…)： 本文主要是哈希表相关题目题解总结。 [TOC] 哈希表哈希表使用O(N)的空间复杂度存储数据，并且以O(1)的时间复杂度求解问题。 1. 两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路123456789101112131415class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [] Dict = &#123;&#125; for i in range(len(nums)): if target-nums[i] in Dict: return [Dict[target-nums[i]], i] else: Dict[nums[i]] = i 3. 无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1:123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解题思路使用字典保存字符最后一次出现的位置，如果这个字符在前面出现过，即这个区间已经有重复的字符了，需要更新左边界，移动到当前遍历字符在字典中保存的位置的下一个位置，同时更新当前字符的位置（右边界）。 123456789101112131415161718class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ if not s: return 0 res = 0 left = 0 Dict = &#123;&#125; for right in range(len(s)): if s[right] in Dict: left = max(left, Dict[s[right]]+1) Dict[s[right]] = right res = max(res, right-left+1) return res 18. 四数之和题目描述给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例：12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解题思路先对数组进行排序，使用字典保存每两个元素和的下标组成的元祖，例如[1,2,2,3]，Dict={3:[(0,1),(0,2)], 4:[(0,3),(1,2)], 5:[(2,3)]}，然后对数组进行两层遍历，判断target-nums[i]-nums[j]在不在字典中，如果在字典中，则找到了一组解。由于需要去重，使用set()类型的数据结构。 1234567891011121314151617181920212223242526272829class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() Dict = &#123;&#125; for i in range(len(nums)): for j in range(i+1, len(nums)): if nums[i]+nums[j] not in Dict: Dict[nums[i]+nums[j]] = [(i, j)] else: Dict[nums[i]+nums[j]].append((i, j)) res = set() for i in range(len(nums)): for j in range(i+1, len(nums)-2): residue = target-nums[i]-nums[j] if residue in Dict: for pair in Dict[residue]: if pair[0] &gt; j: res.add((nums[i], nums[j], nums[pair[0]], nums[pair[1]])) return list(res) 首先做排序，对前两个数遍历，后两个数在剩下的区间内寻找，找的方式使用两个指针指向首尾，判断四个数组成的和是否为target。注意需要在移动过程中去重。(超出时间限制)1234567891011121314151617181920212223242526272829303132333435363738394041class Solution: def fourSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[List[int]] """ if len(nums) &lt; 4: return [] nums.sort() res = [] n = len(nums) for i in range(n-3): if (i &gt; 0 and nums[i] == nums[i-1]) or nums[i]+nums[n-3]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[i+1]+nums[i+2]+nums[i+3] &gt; target: break for j in range(i+1, n-2): if (j &gt; i+1 and nums[j] == nums[j-1]) or nums[i]+nums[j]+nums[n-2]+nums[n-1] &lt; target: continue if nums[i]+nums[j]+nums[j+1]+nums[j+2] &gt; target: break left, right = j+1, n-1 while left &lt; right: temp = nums[i]+nums[j]+nums[left]+nums[right] if temp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) left += 1 right -= 1 while left &lt; right: if nums[left] == nums[left-1]: left += 1 while left &lt; right: if nums[right] == nums[right+1]: right -= 1 elif temp &gt; target: right -= 1 else: left += 1 return res 36. 有效的数独题目描述判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 示例 1:12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 解题思路遍历每一个不为’.’的位置，将其值保存下来，并将其所在位置暂时替换为无关字符，然后判断其所在行、列和9宫格内是否重复，如果重复则直接返回，否则将其位置重新赋原来的值。1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False for x in range(len(board)): for y in range(len(board[0])): if board[x][y] == '.': continue val = board[x][y] board[x][y] = 'D' if not self.isValid(x, y, board, val): return False else: board[x][y] = val return True def isValid(self, x, y, board, val): for i in range(len(board)): if board[i][y] == val: return False for i in range(len(board[0])): if board[x][i] == val: return False for i in range(3): for j in range(3): if board[(x//3)*3+i][(y//3)*3+j] == val: return False return True 依次判断行、列和九宫格是否有重复的，使用set去重然后与没去重的比较长度。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ if len(board) == 0: return False return self.isValidRow(board) and self.isValidCol(board) and self.isValidSpace(board) def isValidRow(self, board): for row in range(len(board)): temp = [board[row][col] for col in range(len(board[0])) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidCol(self, board): for col in range(len(board[0])): temp = [board[row][col] for row in range(len(board)) if board[row][col] != '.'] if len(set(temp)) != len(temp): return False return True def isValidSpace(self, board): for i in range(0, len(board), 3): for j in range(0, len(board[0]), 3): temp = [] for row in range(3): for col in range(3): if board[row+i][col+j] != '.': temp.append(board[row+i][col+j]) if len(set(temp)) != len(temp): return False return True 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def isValidSudoku(self, board): """ :type board: List[List[str]] :rtype: bool """ for i in range(9): if not self.judge(board[i]): return False for i in range(9): temp = [] for j in range(9): temp.append(board[j][i]) if not self.judge(temp): return False for i in range(0,9,3): for j in range(0,9,3): temp = [] for row in range(3): for col in range(3): temp.append(board[row+i][col+j]) if not self.judge(temp): return False return True def judge(self, nums): Dict = &#123;&#125; for x in nums: if x == '.': continue if x in Dict: return False Dict[x] = 1 return True 37. 解数独题目描述编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。空白格用 ‘.’ 表示。一个数独。答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 ‘.’ 。你可以假设给定的数独只有唯一解。给定数独永远是 9x9 形式的。 解题思路某个位置里放入的数字，必须不在其所在行，列及3x3宫内出现过，所以首先统计每行，列，宫内未出现的数字，则该位置只能填入该位置对应的行列宫都未出现的数字（即三者交集）。然后遍历数独，当遍历到需要’.’时，将该位置可能填入的数字（行列宫交集）逐一尝试，该位置填入数字，并将行列宫中的数字删除，如果填入的数字可以继续填入数字则返回True，否则填错了，将该位置恢复成’.’，并将行列宫中的被删除的数字恢复。 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def solveSudoku(self, board): """ :type board: List[List[str]] :rtype: None Do not return anything, modify board in-place instead. """ nums = set([str(j) for j in range(1, 10)]) rows = [set([str(j) for j in range(1, 10)]) for i in range(9)] cols = [set([str(j) for j in range(1, 10)]) for i in range(9)] spaces = [set([str(j) for j in range(1, 10)]) for i in range(9)] for i in range(9): for j in range(9): n = (i//3)*3 + j//3 if board[i][j] != '.': rows[i].remove(board[i][j]) cols[j].remove(board[i][j]) spaces[n].remove(board[i][j]) self.dfs(board, rows, cols, spaces) def dfs(self, board, rows, cols, spaces): for i in range(9): for j in range(9): n = (i//3)*3 + j//3 intersection = rows[i]&amp;cols[j]&amp;spaces[n] if board[i][j] == '.': for item in intersection: board[i][j] = item rows[i].remove(item) cols[j].remove(item) spaces[n].remove(item) if self.dfs(board, rows, cols, spaces): return True board[i][j] = '.' rows[i].add(item) cols[j].add(item) spaces[n].add(item) return False return True 49. 字母异位词分组题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例:1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 解题思路遍历字符串，对字符串进行排序，使用字典将同样的字符串放在一起。 123456789101112131415161718192021222324class Solution(object): def groupAnagrams(self, strs): """ :type strs: List[str] :rtype: List[List[str]] """ if len(strs) == 0: return [] Dict = &#123;&#125; for x in strs: temp = ''.join(sorted(x)) if temp not in Dict: Dict[temp] = [x] else: Dict[temp].append(x) # res = []# for val in Dict.values():# res.append(val) # return res return list(Dict.values()) 166. 分数到小数题目描述给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。 如果小数部分为循环小数，则将循环的部分括在括号内。 示例 1:12输入: numerator = 1, denominator = 2输出: &quot;0.5&quot; 示例 2:12输入: numerator = 2, denominator = 1输出: &quot;2&quot; 示例 3:12输入: numerator = 2, denominator = 3输出: &quot;0.(6)&quot; 解题思路用字典保存余数及余数对应的结果的长度，当余数存在于字典中时，说明为循环小数，循环起始位字典中保存的位置。1234567891011121314151617181920212223242526272829303132333435class Solution(object): def fractionToDecimal(self, numerator, denominator): """ :type numerator: int :type denominator: int :rtype: str """ res = '' if numerator * denominator &lt; 0: res += '-' numerator, denominator = abs(numerator), abs(denominator) res += str(numerator // denominator) residue = numerator % denominator if residue == 0: return res res += '.' Dict = &#123;&#125; Dict[residue] = len(res) while residue: numerator = residue * 10 res += str(numerator // denominator) residue = numerator % denominator if residue not in Dict: Dict[residue] = len(res) else: start = Dict[residue] res = res[:start] + '(' + res[start:] + ')' break return res 187. 重复的DNA序列题目描述所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。 示例:123输入: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;输出: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;] 解题思路12345678910111213141516class Solution(object): def findRepeatedDnaSequences(self, s): """ :type s: str :rtype: List[str] """ res = set() seen = set() for i in range(len(s)-9): if s[i:i+10] in seen: res.add(s[i:i+10]) else: seen.add(s[i:i+10]) return list(res) 205. 同构字符串题目描述给定两个字符串 s 和 t，判断它们是否是同构的。 如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。 所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。 示例 1:12输入: s = &quot;egg&quot;, t = &quot;add&quot;输出: true 示例 2:12输入: s = &quot;foo&quot;, t = &quot;bar&quot;输出: false 示例 3:12输入: s = &quot;paper&quot;, t = &quot;title&quot;输出: true 说明:你可以假设 s 和 t 具有相同的长度。 解题思路遍历数组，用哈希表保存s和t中的对应关系，当s[i]不在哈希表的key中，如果t[i]在哈希表的value中，则返回False，如ab和aa的情况，否则将s[i]—t[i]保存到哈希表中，当s[i]在哈希表的key中，检查对应的值是否和t[i]相等，如果不相等，则返回False。遍历完成最后返回True。 123456789101112131415161718192021222324class Solution(object): def isIsomorphic(self, s, t): """ :type s: str :type t: str :rtype: bool """ if s == t: return True if len(s) != len(t): return False Dict = &#123;&#125; for i in range(len(s)): if s[i] not in Dict: if t[i] in Dict.values(): return False Dict[s[i]] = t[i] else: if Dict[s[i]] != t[i]: return False return True 242. 有效的字母异位词题目描述给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1:12输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true 示例 2:12输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路水123456789class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ return sorted(s) == sorted(t) 词频统计1234567891011121314151617181920212223class Solution(object): def isAnagram(self, s, t): """ :type s: str :type t: str :rtype: bool """ if len(s) != len(t): return False scnt = [0] * 26 tcnt = [0] * 26 for i in range(len(s)): scnt[ord(s[i]) - 97] += 1 tcnt[ord(t[i]) - 97] += 1 for i in range(26): if scnt[i] != tcnt[i]: return False return True 274. H指数题目描述给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 h 指数的定义: “h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）至多有 h 篇论文分别被引用了至少 h 次。（其余的 N - h 篇论文每篇被引用次数不多于 h 次。）” 示例:1234输入: citations = [3,0,6,1,5]输出: 3 解释: 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。 由于研究者有 3 篇论文每篇至少被引用了 3 次，其余两篇论文每篇被引用不多于 3 次，所以她的 h 指数是 3。 解题思路好难理解。。。1234567891011121314151617class Solution(object): def hIndex(self, citations): """ :type citations: List[int] :rtype: int """ if len(citations) == 0: return 0 maxi = len(citations) for x in sorted(citations):#假设h为N 那么所有的论文引用次数都大于等于N，如果存在引用次数小于N,h- if x &gt;= maxi: break else: maxi -= 1 return maxi 290. 单词模式题目描述给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。 这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。 示例1:12输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true 示例 2:12输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false 示例 3:12输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false 示例 4:12输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;输出: false 说明:你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 解题思路分别将pattern和str分割，如果长度不一致则返回False 使用hash表，遍历pattern，依次保存pattern和str的映射关系 如果某个pattern[i]不存在hash表中，需要首先判断对应的str[i]是否已经在hash表中，如果在说明该str[i]已经被其他pattern占用，返回False; 如果某个pattern[i]已经在hash中，那么只需要判断当前对应的str[i]是否和保存起来的str是否一致即可。 12345678910111213141516171819202122232425class Solution(object): def wordPattern(self, pattern, str): """ :type pattern: str :type str: str :rtype: bool """ pattern = list(pattern) str = str.split() if len(pattern) != len(str): return False Dict = &#123;&#125; for i in range(len(pattern)): if pattern[i] not in Dict: if str[i] in Dict.values(): return False Dict[pattern[i]] = str[i] else: if str[i] != Dict[pattern[i]]: return False return True 299. 猜数字游戏题目描述你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。 请注意秘密数字和朋友的猜测数都可能含有重复数字。 示例 1:12345输入: secret = &quot;1807&quot;, guess = &quot;7810&quot;输出: &quot;1A3B&quot;解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 示例 2:12345输入: secret = &quot;1123&quot;, guess = &quot;0111&quot;输出: &quot;1A1B&quot;解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 解题思路用hash表保存secret中数字重现的次数；定义两个变量，allmatch统计secret和guess中都出现的次数，另一个统计Bulls；然后遍历guess，如果当前字符在hash中出现过，说明这个字符在secret和guess都出现过，allmatch+=1，同时判断位置在这secret和guess的位置是否相同，相同Bulls+=1;最后Cows = allmatch - bulls。 12345678910111213141516171819202122232425262728293031class Solution(object): def getHint(self, secret, guess): """ :type secret: str :type guess: str :rtype: str """ if len(secret) != len(guess) or len(secret) == 0: return "" Dict = &#123;&#125; for c in secret: if c not in Dict: Dict[c] = 1 else: Dict[c] += 1 allmatch = 0 Bulls = 0 for i in range(len(guess)): if guess[i] in Dict and Dict[guess[i]] != 0: Dict[guess[i]] -= 1 allmatch += 1 if secret[i] == guess[i]: Bulls += 1 Cows = allmatch - Bulls return str(Bulls) + 'A' + str(Cows) + 'B' 347. 前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1:12输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2:12输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。 你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路hash统计，values降序，取前k个 123456789101112131415161718192021class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums) &lt; k or k &lt;= 0: return [] Dict = &#123;&#125; for x in nums: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 Dict = sorted(Dict.items(), key = lambda item:-item[1]) return [Dict[i][0] for i in range(k)] 349. 两个数组的交集题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [9,4] 说明: 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。解题思路 123456789101112131415161718class Solution(object): def intersection(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] res = [] for x in nums2: if x in nums1 and x not in res: res.append(x) return res 350. 两个数组的交集 II题目描述给定两个数组，编写一个函数来计算它们的交集。 示例 1:12输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2] 示例 2:12输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 解题思路先用hash表将nums1的数字和对应次数保存起来，遍历nums2，查看当前遍历元素是否在Dict中存在，且次数大于0,如果存在需要将Dict[x] -= 11234567891011121314151617181920212223242526class Solution(object): def intersect(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: List[int] """ if not nums1 or not nums2: return [] Dict = &#123;&#125; for x in nums1: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for x in nums2: if x in Dict and Dict[x] != 0: res.append(x) Dict[x] -= 1 return res 380. 常数时间插入、删除和获取随机元素题目描述设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。 insert(val)：当元素 val 不存在时，向集合中插入该项。 remove(val)：元素 val 存在时，从集合中移除该项。 getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。 示例 :1234567891011121314151617181920212223// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom(); 解题思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.keyIndex = &#123;&#125;#记录键、下标对 self.indexKey = &#123;&#125;#记录下标、键对 self.len = 0#记录长度，便于随机返回元素 def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ #插入时，分别对两个哈希表都进行插入，同时len+1 if val not in self.keyIndex: self.len += 1 self.keyIndex[val] = self.len self.indexKey[self.len] = val return True return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ #删除时将index_key中键为len的覆盖到键为key_index[val]，然后删除键为len的；key_index操作类似。最后len-1 if val in self.keyIndex: self.indexKey[self.keyIndex[val]] = self.indexKey[self.len] self.keyIndex[self.indexKey[self.len]] = self.keyIndex[val] self.indexKey.pop(self.len) self.keyIndex.pop(val) self.len -= 1 return True return False def getRandom(self): """ Get a random element from the set. :rtype: int """ return self.indexKey[random.randint(1, self.len)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class RandomizedSet(object): def __init__(self): """ Initialize your data structure here. """ self.set = [] def insert(self, val): """ Inserts a value to the set. Returns true if the set did not already contain the specified element. :type val: int :rtype: bool """ if val not in self.set: self.set.append(val) return True else: return False def remove(self, val): """ Removes a value from the set. Returns true if the set contained the specified element. :type val: int :rtype: bool """ if val in self.set: self.set.remove(val) return True else: return False def getRandom(self): """ Get a random element from the set. :rtype: int """ import random return self.set[random.randint(0, len(self.set)-1)]# Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom() 389. 找不同题目描述给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例:123456789输入：s = &quot;abcd&quot;t = &quot;abcde&quot;输出：e解释：&apos;e&apos; 是那个被添加的字母。 解题思路123456789101112131415161718192021class Solution(object): def findTheDifference(self, s, t): """ :type s: str :type t: str :rtype: str """ if not t or len(s) &gt;= len(t): return '' s = list(s) for c in t: if c not in s: return c else: s.remove(c) return '']]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>算法题解</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 栈]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是栈相关题目题解总结。 [TOC] 5. 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 解题思路入栈时把数据压入stack1，出栈时若stack2不为空，直接弹出，若stack2为空，则将stack1的全部元素压入stack2，在弹出stack2. 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stack1 = [] self.stack2 = [] def push(self, node): # write code here self.stack1.append(node) def pop(self): # return xx if self.stack2: return self.stack2.pop() else: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop()if __name__ == '__main__': result = Solution() result.push(1) result.push(2) result.pop() result.push(4) result.pop() result.pop() 20 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 解题思路使用两个栈，一个为数据栈，一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子：入栈时：首先往空的数字栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来压入数字4，由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。出栈时：当数据栈和辅助栈相同，辅助栈和数据栈的栈顶元素都要出栈，否则，仅数据栈的栈顶元素出栈。获取栈顶元素时：直接返回数据栈的栈顶元素栈最小元素：直接返回辅助栈的栈顶元素1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class Solution: def __init__(self): self.dataStack = [] self.minStack = [] def push(self, node): # write code here self.dataStack.append(node) if len(self.minStack) &lt;= 0 or node &lt; self.minStack[-1]: self.minStack.append(node) def pop(self): # write code here val = self.dataStack.pop() if val == self.minStack[-1]: self.minStack.pop() return val def top(self): # write code here return self.dataStack[-1] def min(self): # write code here return self.minStack[-1]if __name__ == '__main__': result = Solution() result.push(2) result.push(4) result.push(1) result.push(3) result.pop() result.top() result.min() 21 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1！=4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def IsPopOrder(self, pushV, popV): # write code here stack = [] for x in pushV: stack.append(x) while stack and stack[-1] == popV[0]: stack.pop() popV.pop(0) return False if stack else Trueif __name__ == '__main__': # 入栈：1,2,3,4,5 # 可能的出栈：4,5,3,2,1 # 不能的出栈：4,3,5,1,2 result = Solution().IsPopOrder([1,2,3,4,5],[4,3,5,1,2]) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-红黑树]]></title>
    <url>%2F2019%2F07%2F12%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 红黑树定义红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在$O(logn)$时间内做查找，插入和删除，这里的$n$是树中元素的数目。 红黑树性质红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。除二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 性质1：节点是红色或黑色 性质2：根节点是黑色 性质3：所有叶子节点都是黑色（叶子是NIL节点） 性质4：每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。) 性质5.：从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 注意： 性质3中的叶子节点，是只为空(NIL或null)的节点。 性质5确保从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，因而，红黑树是相对是接近平衡的二叉树。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。 红黑树示例： 红黑树的应用红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。 例如，Java集合中的TreeSet和TreeMap，C++的STL中的Set、Map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 红黑树基本操作左旋如上图所示，当在某个结点pivot上，做左旋操作时，我们假设它的右孩子Y不是NULL，pivot可以为任何不是NULL的左子结点。左旋以pivot到Y之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的左孩子b则成为pivot的右孩子。 右旋如上图所示，当在某个结点pivot上，做右旋操作时，我们假设它的左孩子Y不是NULL，pivot可以为任何不是NULL的右子结点。右旋以Y到pivot之间的链为“支轴”进行，它使Y成为该子树的新根，而Y的右孩子b则成为pivot的左孩子。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-位图]]></title>
    <url>%2F2019%2F07%2F11%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BD%8D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 位图所谓bit-map就是用一个bit位来标记某个元素的value，而bit数组的下标是表示该元素，由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省。位图通过使用位数组来表示已知范围内的某些元素是否存在，可进行数据的快速查找、判重、删除 举例：假设我们要对0~7内的5个元素（4,7,2,5,3）排序（这里假设这些元素没有重复），可以采用bit-map的方法来达到排序的目的，要表示8个数，我们就只需要8个bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有bit位都置为0，如下图：然后遍历这五个元素，首先第一个是4，那么就把4对应的位置5（从0开始）置1：然后在处理第二个元素7，将第8个位置置1，接着在处理第三个元素，一直到最后一个元素，处理完的bit位状态：现在我们遍历一遍bit区域，将该位是1的位的编号输出（2,3,4,5,7），这样就达到了排序的目的。 举例2：我们有1千万个整数，整数的范围在1到1亿之间。如何快速查找某个整数是否在这1千万个整数中呢？ 使用位图。我们申请一个大小为1亿、数据类型为布尔类型（true或者false）的数组。我们将这1千万个整数作为数组下标，将对应的数组值设置成true。比如，整数5对应下标为5的数组值设置为true，也就是array[5]=true。 当我们查询某个整数K是否在这1千万个整数中的时候，我们只需要将对应的数组值array[K]取出来，看是否等于true。如果等于true，那说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。 问题实例： 已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数8位最多99999999，大概需要99M个bit，大概10几M的内存即可，然后进行遍历将对应的位置1，统计位置上出现1的个数。 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置为0，则置1，如果是1，则置2，如果是2，则保持不变。最后统计位置上的值为1的个数。 实现网页爬虫中的URL去重功能同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？假设需要判重的网页有10亿，那我们可以用一个10倍大小的位图来存储，也就是100亿个二进制位，换算成字节，那就是大约1.2GB。（即布隆过滤器，因为该位图无法覆盖所有的网页，会出现误判冲突，布隆过滤器利用K个哈希函数实现有误判的位图，降低存储空间，提高效率。点击查看布隆过滤器） 应用适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下基本思想：使用bit数组表示某些元素是否存在。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-赫夫曼树及赫夫曼编码]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 赫夫曼树先看如下两棵树： 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。 二叉树 a 中， 根结点到结点 D 的路径长度为 4，二叉树 b 中根结点到结点 D 的路径长度为 2。 树的路径长度就是从树根到每一结点的路径长度之和 。 二 叉树 a 的树路径长度就为 1+1+2+2+3+3+4+4=20。二叉树 b 的树路径长度就为1+2+3+3+2+1+2+2=16。 考虑到带权的结点，结点的带权的路径长度为该结点到树根之间的路径长度与结点上权的乘积。树的带权路径长度为树中所有叶子结点的带权路径长度之和。假设有n个权值$\{w_1,w_2,…,w_n\}$，构造一棵有 n 个叶子结点的二叉树，每个叶子结点带权 $W_k$，每个叶子的路径长度为 $l_k$，则其中带权路径长度(WPL)最小的二叉树称做赫夫曼树，也称为最优二叉树。 二叉树 a 的 $WPL=5 1+15 2+40 3+30 4+10 * 4 = 315 $ 二叉树 b 的 $WPL=5 3+ 15 3+40 2+30 2+ 10 * 2 = 220 $ 2 赫夫曼树构造方法 先把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即 : A5，E10 , B15 , D30, C40。 取头两个最小权值的结点作为一个新节点 N1的两个子结点， 注意相对较小的 是左孩子，这里就是 A 为 N1 的左孩子， E 为 N1的右孩子，如图 6-12-5 所 示。新结点的权值为两个叶子权值的和 5+10=15。 将 N1替换 A 与 E，插入有序序列中， 保持从小到大排列。 即: N1-15, B-15 , D-30, C-40。 重复步骤 2. 将 N1 与 B 作为一个新节点 N2的两个子结点。 如图 6-12-6 所 示。 N2 的权值=15+15=30。 将 N2 替换 N1 与 B ，插入有序序列中， 保持从小到大排列。 即: N2-30 , D-30, C-40。 重复步骤 2. 将 N2 与 D 作为一个新节点 N3 的两个子结点。 如图 6-12-7 所示。 N3 的权值=30+30=60。 将 N3替换 N2与 D，插入有序序列中，保持从小到大排列。即 : C-40 , N3-60。 重复步骤 2。将 C 与 N3 作为一个新节点 T 的两个子结点，如图 6-12-8 所示。 由于 T 即是根结点，完成赫夫曼树的构造。 构造赫夫曼树的赫夫曼算法描述： 根据给定的 n 个权值$\{w_1,w_2,…,w_n\}$构成 n 棵二叉树的集合 $F = \{T_1,T_2,…,T_n\}$， 其中每棵二叉树 $T_i $中只有一个带权为 $w_i$根结点，其左右子树均为空。 在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且 置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。 重复 2 和 3 步骤，直到 F 只含一棵树为止。这棵树便是赫夫曼树。 3 赫夫曼编码用于压缩和解压缩文件，把要压缩的文本进行重新编码，以减少不必要的空间。比如我们有一段文字内容为 “BADCADFEED” 要网络传输给别人，显然用二进制 的数字 (0 和 1) 来表示是很自然的想法。我们现在这段文字只有六个字母 ABCDEF，那么我们可以用相应的二进制数据表示： 这样真正传输的数据就是编码后的 “001000011010000011101100100011“， 对 方接收时可以按照 3 位划分来译码。效率低下。 根据不同词频使用赫夫曼树重新编码。 假设六个字母的频率为 A 27 , B 8, C 15 , D 15 , E 30, F 5 ，合起来正好是 100%。 那就意味着，我们完全可以重新按照赫夫曼树来规划它们。 以下左图为按照第2节的赫夫曼树构造方法得到的赫夫曼树，右图为将所有左分支改为0，右分支改为1后的赫夫曼树。 对着六个字母重新编码如下： 我们将文字内容为 “BADCADFEED” 再次编码，对比可以看到结果串变小了 。 原编码二进制串 :001000011010000011101100100011(共30个字符) 新编码二进制率: 1001010010101001000111100(共 25 个字符) 数据被压缩了。 4 赫夫曼解码前缀编码：编码中非 0 即 1，长短不等的话其实是很容易混淆的，所以若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称做前缀编码。 在解码时，还是要用到赫夫曼树，即发送方和接收方必须要约定好同样的赫夫曼编码规则。 当我们接收到 1001010010101001000111100 时，按约定好的赫夫曼树可知， 1001 得到第一个字母是 B，接下来的01意味着第二个字符是 A，如图 6-12-10 所示， 其余的也相应的可以得到，从而成功解码。 5 赫夫曼编码定义一般地，设需要编码的字符集为$\{d_1,d_2,…,d_n\}$，各个字符在电文中出现的次数或频率集合为$\{w_1,w_2,…,w_n\}$ ，以 $d_1,d_2,…,d_n$作为叶子结点，以 $w_1,w_2,…,w_n$ 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1， 则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 其他]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%85%B6%E4%BB%96%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是其他相关题目题解总结。 [TOC] 11.二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路思路1：从右往左逐位判断 思路2：为了避免死循环，我们可以不右移输入的数据n。首先把n和1做与运算，判断n的最低位是不是为1，接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1.。。这样反复左移，每次都能判断n的其中一位是不是1.注意flag要设定范围。循环次数等于二进制的位数。 思路3：（最优）如果一个整数不为0，那么这个整数至少有一位是1，如果我们把整数减1，那么原来处在整数最右边的1就会变为0, 原来在1后面的所有0都会变为1（如果最右边的1后面还有0的话）。其余所有位将不受影响。 举个例子：一个二进制数1100，从右边起第三位是处于最右边的1，减去1后，第三位变为0，他后面的两个0变为1了，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0.如1100&amp;1011 = 1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。在python中，由于负数使用补码表示的，对于负数，最高位为1，而负数在计算机中是以补码存在的，往右移，符号位不变，符号位往右移，最终可能会出现全1的情况，导致死循环。与oxffffffff想与，就可以消去负数的影响。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def NumberOf1(self, n): # write code here # 思路1 # if n &lt; 0: # n = n &amp; 0xffffffff # count = 0 # while n: # if n%2 == 1: # count += 1 # n = n &gt;&gt; 1 # return count # 思路2 # flag = 1 # count = 0 # while flag and flag &lt;= 0xffffffff: # if n &amp; flag: # count += 1 # flag = flag &lt;&lt; 1 # return count # 思路3 if n &lt; 0: n = n &amp; 0xffffffff count = 0 while n: count += 1 n = (n-1)&amp;n return countif __name__ == '__main__': result = Solution().NumberOf1(42) print(result) 12 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 解题思路二分求幂，递归。 如果n=0，返回1； 如果n为负数，相当于求(1.0/x)^(-n)。 如果n为正奇数，相当于求 x (x^2)^(n//2)； 如果n为正偶数，相当于求 (x^2)^(n//2)。 1234567891011121314# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0.0 if exponent == 0: return 1.0 if exponent &lt; 0: return 1.0 / self.Power(base, -exponent) elif exponent%2: return self.Power(base*base, exponent//2)*base else: return self.Power(base*base, exponent//2) python中等于没有误差，因此可以写出如下代码：1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def Power(self, base, exponent): # write code here if base == 0.0: return 0 flag = 0 if exponent &lt; 0: flag = 1 exponent = -exponent res = 1 for i in range(exponent): res *= base if flag: res = 1.0/res return resif __name__ == '__main__': result = Solution().Power(2,-3) print(result) 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路从左往右，再从上往下，再从右往左，最后从下往上遍历.123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: # matrix类型为二维列表，需要返回列表 def printMatrix(self, matrix): # write code here rows = len(matrix) cols = len(matrix[0]) left, right = 0, cols-1 top, bottom = 0, rows-1 res = [] while left &lt;= right and top &lt;= bottom: for i in range(left, right+1): res.append(matrix[top][i]) for i in range(top+1,bottom+1): res.append(matrix[i][right]) if top != bottom: for i in range(right-1,left-1,-1): res.append(matrix[bottom][i]) if left != right: for i in range(bottom-1,top,-1): res.append(matrix[i][left]) left += 1 right -= 1 top += 1 bottom -= 1 return resif __name__ == '__main__': result = Solution().printMatrix([[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]) print(result) 29 最小的K个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 解题思路思路1：使用冒泡排序，找出最小的k个数返回，时间复杂度O(n^2)。思路2：另一种O(nlogk)的算法是基于堆排序的，特别适合处理海量数据。我们可以先创建一个大小为k的数据容器来存储最小的k个数字，接下来我们每次从输入的n个整数中的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器已经有k个数字了，也就是容器满了，此时我们不能再插入新的数字而只能替换已有的数字。找出这已有的k个数中的最大值，然后拿这次待插入的整数和最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换当前已有的最大值；如果待插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，于是我们可以抛弃这个整数。因此当容器满了之后，我们要做3件事情：一是在k个整数中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf-8 -*-class Solution: def GetLeastNumbers_Solution(self, tinput, k): # write code here # 思路1 冒泡排序 # if k &lt; 0 or k &gt; len(tinput): # return [] # count = k # for i in range(len(tinput)): # min = tinput[i] # for j in range(i+1,len(tinput)): # if tinput[j]&lt;min: # min = tinput[j] # index = j # if min!=tinput[i]: # tinput[i], tinput[index] = tinput[index], tinput[i] # count = count-1 # if count == 0: # break # return tinput[:k] # 思路2 堆排序 res = [] length = len(tinput) change = True if length &lt;= 0 or k &lt;= 0 or k &gt; length: return res res = tinput[:k] for i in range(k, length + 1): if change == True: for j in range(0, k // 2 + 1)[::-1]: self.HeadAdjust(res, j, k) for j in range(1, k)[::-1]: res[0], res[j] = res[j], res[0] self.HeadAdjust(res, 0, j) change = False if i != length and res[k - 1] &gt; tinput[i]: res[k - 1] = tinput[i] change = True return res def HeadAdjust(self, input_list, parent, length): temp = input_list[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and input_list[child] &lt; input_list[child + 1]: child += 1 if temp &gt;= input_list[child]: break input_list[parent] = input_list[child] parent = child child = 2 * parent + 1 input_list[parent] = tempif __name__ == '__main__': result = Solution().GetLeastNumbers_Solution([4, 5, 1, 6, 2, 7, 3, 8], 4) print(result) 31 整数中1出现的次数（从1到n整数中1出现的次数）题目描述求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解题思路思路1 从1到n遍历。对每一个数字，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断，我们对每个数字都要做求余和除法运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。 思路2 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。 1) 个位 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图： 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以： count = round+1 = 53 + 1 = 54 如果此时weight为0（n=530），说明第54轮到0就停止了，那么： count = round = 53 2) 十位对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图： 不同点在于：从1到n，每增加10，十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次。即round*10。 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则： count = round10+10 = 510+10 = 60 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：count = round10+10 = 510 = 50 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：count = round10+former +1= 510+4 +1= 55 3) 更高位更高位的计算方式其实与十位是一致的，不再阐述。 4) 总结 将n的各个位分为两类：个位与其它位。 对个位来说： 若个位大于0，1出现的次数为round1+1 若个位等于0，1出现的次数为round1 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图： 则： 若weight为0，则1出现次数为round*base 若weight为1，则1出现次数为round*base+former+1 若weight大于1，则1出现次数为rount*base+base 比如： 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（531+1）+（510+10）+（0*100+100）= 214 530 = （531）+（510+10）+（0*100+100） = 213 504 = （501+1）+（510）+（0*100+100） = 201 514 = （511+1）+（510+4+1）+（0*100+100） = 207 10 = (11)+(010+0+1) = 2 来自 https://blog.csdn.net/yi_afly/article/details/52012593 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def NumberOf1Between1AndN_Solution(self, n): # write code here # res = 0 # for i in range(1,n+1): # while i: # if i%10 == 1: # res += 1 # i //= 10 # return res # 思路2 if n &lt; 1: return 0 count, base, Round = 0,1,n while Round &gt; 0: weight = Round%10 Round //= 10 count += Round*base if weight == 1: count += n%base+1 elif weight&gt;1: count += base base *= 10 return countif __name__ == '__main__': result = Solution().NumberOf1Between1AndN_Solution(13) print(result) 33 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 解题思路思路：用空间换时间创建一个数组，里面的数字是排好序的丑数，每个丑数都是前面的丑数乘以2,3,或5得到的。1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def GetUglyNumber_Solution(self, index): # write code here if index &lt;= 0: return 0 t2, t3, t5 = 0, 0, 0 res = [1] for i in range(1, index): res.append(min(res[t2]*2, res[t3]*3, res[t5]*5)) if res[-1] == res[t2]*2: t2 += 1 if res[-1] == res[t3]*3: t3 += 1 if res[-1] == res[t5]*5: t5 += 1 return res[-1] 41 和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序 解题思路设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数设为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值。如果第一个数到最后一个数的和正好是要求的和，那么把所有的数都添加到一个序列中。如果大于要求的和，这说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，此时当前和变为减去原来的第一个数的值。如果小于要求的和，说明范围太小，因此把最后一个数加1，此时当前和变为加上最后一个数的值。这样不断修改第一个和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。连续序列和公式:sum = (a+b)(b-a+1)/2 123456789101112131415161718192021222324# -*- coding:utf-8 -*-class Solution: def FindContinuousSequence(self, tsum): # write code here if tsum &lt;= 2: return [] res = [] left, right = 1, 2 while left &lt; right: temp = (left+right)*(right-left+1)//2 if temp == tsum: res.append([x for x in range(left, right+1)]) left += 1 elif temp &gt; tsum: left += 1 else: right += 1 return resif __name__ == '__main__': result = Solution().FindContinuousSequence(100) print(result) 42 和为S的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路对于一个数组，我们可以定义两个指针，一个从左往右遍历（l），另一个从右往左遍历（r）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字tsum，如果curSum == tsum，那么这两个数字就是我们要找的数字，直接输出，这里已经保证了乘积的最小。如果curSum &gt; tsum，我们需要减小输入值，r向左移动一位。如果curSum &lt; tsum，我们需要加大输入值，l向右移动一位。如果没有找到，输出[]。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: def FindNumbersWithSum(self, array, tsum): # write code here if len(array)&lt;=1: return [] left, right = 0, len(array)-1 while left &lt; right: if array[left]+array[right]==tsum: return [array[left],array[right]] elif array[left]+array[right] &gt; tsum: right -= 1 else: left += 1 return []if __name__ == '__main__': result = Solution().FindNumbersWithSum([1,2,3,4,6],5) print(result) 45 扑克牌顺子题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 解题思路满足一下信息才认为是顺子：输入数据个数为5输入数据都在0-13之间没有相同的数字最大值与最小值之差不大于5 注意为什么是numbers[big]-numbers[small]-1，因为0是用来填补空缺的，如果空缺是1则不用填补，这个做法我们看出不等于1的空缺有多少。 12345678910111213141516171819202122232425262728293031# -*- coding:utf-8 -*-class Solution: def IsContinuous(self, numbers): # write code here if len(numbers) != 5: return False dic = &#123;'A':1,'J':11,'Q':12,'K':13&#125; for i in range(len(numbers)): if numbers[i] in dic: numbers[i] = dic[numbers[i]] numbers.sort() if numbers[0] &lt; 0 or numbers[-1] &gt; 13: return False i = 0 count = 0 while numbers[i] == 0: count += 1 i += 1 for j in range(i,len(numbers)-1): if numbers[j+1] == numbers[j]: return False temp = numbers[j+1]-numbers[j]-1 if count &gt;= temp: count -= temp else: return False return Trueif __name__ == '__main__': result = Solution().IsContinuous(['A',3,0,0,6]) print(result) 46 孩子们的游戏（圆圈中最后剩下的数）题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 解题思路第一个被删除的数字是(m-1)%n，记为k，那么删除k之后的数字为0,1,…,k-1,k+1,…,n-1，并且下一个开始计数的数字是k+1。即有以下关系k+1—&gt;0k+2—&gt;1n-1 —&gt; n-k-20 — &gt; n-k-1 k-1 —&gt; n-2 总结：设置变化前有n个元素，出现小孩序号为k，那么k=(m-1)%n，设置剩余小孩调整前原始序号为x，那么调整后为f(x)=(x-k-1)%n，将k值代入有:f(x) = x0 = (x-(m-1)%n - 1)%n = (x-m)%n 所以已知x0新序号推原序号为x=(x0+m)%n 12345678910111213# -*- coding:utf-8 -*-class Solution: def LastRemaining_Solution(self, n, m): # write code here if n &lt; 1 or m &lt; 1: return -1 last = 0 for i in range(2, n + 1): last = (last + m) % i return lastif __name__ == '__main__': result = Solution().LastRemaining_Solution(6,4) print (result) 47 求1+2+3+…+n题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 解题思路思路1：递归思路2：与逻辑的短路特性做递归停止条件123456789101112131415# -*- coding:utf-8 -*-class Solution: def Sum_Solution(self, n): # write code here #思路1 #if n == 1: # return 1 #return self.Sum_Solution(n-1)+n # 思路2 return n&gt;0 and n + self.Sum_Solution(n-1)if __name__ == '__main__': result = Solution().Sum_Solution(10) print(result) 48 不用加减乘除的加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 解题思路首先看十进制是如何做的： 5+7=12， 可以使用三步走： 第一步：相加各位的值，不算进位，得到2。 第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 同样我们可以 三步走的方式计算二进制值相加： 5-101，7-111 第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。 第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。 第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 Python需要处理负数1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def Add(self, num1, num2): # write code here unit = (num1^num2)&amp; 0xFFFFFFFF carry = ((num1&amp;num2)&lt;&lt;1) &amp; 0xFFFFFFFF while carry: temp1 = unit temp2 = carry unit = (temp1^temp2) &amp; 0xFFFFFFFF carry = ((temp1&amp;temp2)&lt;&lt;1) &amp; 0xFFFFFFFF return unit if unit&lt;=0x7FFFFFFF else ~(unit^0xFFFFFFFF)if __name__ == '__main__': result = Solution().Add(-12,-104) print (result) 54 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。 解题思路这道题还是很简单的。将字节流保存起来，通过哈希表统计字符流中每个字符出现的次数，顺便将字符流保存在string中，然后再遍历string，从哈希表中找到第一个出现一次的字符。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回对应char def FirstAppearingOnce(self): # write code here for i in self.word: if self.charCount[i] == 1: return i return '#' def Insert(self, char): # write code here self.word += char if char not in self.charCount: self.charCount[char] = 1 else: self.charCount[char] += 1 def __init__(self): self.word = '' self.charCount = &#123;&#125;if __name__ == '__main__': word = 'google' S = Solution() for c in word: S.Insert(c) result = S.FirstAppearingOnce() print(result) 63 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 解题思路初始化一个数组，读入数据后，排序，直接计算12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: def __init__(self): self.numbers = [] def Insert(self, num): # write code here self.numbers.append(num) def GetMedian(self): # write code here self.numbers.sort() if len(self.numbers) % 2 == 1: return self.numbers[len(self.numbers)//2] else: return (self.numbers[len(self.numbers)//2]+self.numbers[len(self.numbers)//2-1])/2.0if __name__ == '__main__': numbers = [1,2,3,4] S = Solution() for i in numbers: S.Insert(i) result = S.GetMedian() print(result) 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def maxInWindows(self, num, size): # write code here if len(num) &lt; size or size == 0: return [] # left, right = 0, size-1 # res = [] # while right &lt; len(num): # maxindex = left # for j in range(left+1,right+1): # if num[j] &gt; num[maxindex]: # maxindex = j # res.append(num[maxindex]) # left += 1 # right += 1 # return res res = [] for i in range(len(num)-size+1): res.append(max(num[i:i+size])) return resif __name__ == '__main__': result = Solution().maxInWindows([2,3,4,2,6,2,5,1],3) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 字符串]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是字符串相关题目题解总结。 2.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路 思路1：开辟一个新的字符串，遍历给定字符串，当字符为空格时，在新字符串后添加%20，否则，添加原字符 思路2：将字符串转换成列表，遍历字符串，当字符为空格时，依次在列表后面添加’%’，’2’，’0’；否则，添加原字符 思路3：如果直接每次遇到空格添加’%20’，那么空格后面的数字就需要频繁向后移动。遇到这种移动问题，我们可以尝试先给出最终需要的长度，然后从后向前扫描，同时给定两个指针来保证定位。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here if len(s) == 0: return '' # 思路1 # newString = '' # for i in s: # if i == ' ': # newString += '%20' # else: # newString += i # return newString # 思路2： # lis = list(s) # newLis = [] # for i in lis: # if i == ' ': # newLis.append('%') # newLis.append('2') # newLis.append('0') # else: # newLis.append(i) # return "".join(newLis) # 思路3 count = 0 for i in s: if i == ' ': count += 1 newLen = len(s) + count * 2 newStr = newLen * [None] indexOfNew, indexOfOri = len(newStr)-1, len(s)-1 while indexOfNew &gt;= 0 and indexOfNew &gt;= indexOfOri: if s[indexOfOri] == ' ': newStr[indexOfNew-2:indexOfNew+1] = ['%','2','0'] indexOfNew -= 3 indexOfOri -= 1 else: newStr[indexOfNew] = s[indexOfOri] indexOfNew -= 1 indexOfOri -= 1 return "".join(newStr)if __name__ == '__main__': result = Solution().replaceSpace('We are happy.') print(result) 27 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 解题思路我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。是典型的递归思路。1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-class Solution: def Permutation(self, ss): # write code here if len(ss) == 0: return [] if len(ss) == 1: return [ss] # 写法1 # res = [] # self.perm(ss, res, '') # uniq = list(set(res)) # return sorted(res) # def perm(self, ss, res, path): # if ss == '': # res.append(path) # else: # for i in range(len(ss)): # self.perm(ss[:i] + ss[i + 1:], res, path + ss[i]) # 写法2: res = [] for i in range(len(ss)): if i &gt; 1 and ss[i] == ss[i-1]: continue temp = self.Permutation(ss[:i]+ss[i+1:]) for x in temp: res.append(ss[i]+x) return sorted(list(set(res)))if __name__ == '__main__': result = Solution().Permutation('aba') print(result) 34 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 解题思路思路：两轮遍历第一轮，使用hash表，记录各字符出现的次数第二轮，当次数为1时，返回位置123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def FirstNotRepeatingChar(self, s): # write code here if not s: return -1 if len(s) == 1: return 0 hash = &#123;&#125; for i in range(len(s)): if s[i] not in hash: hash[s[i]] = 1 else: hash[s[i]] += 1 for i in range(len(s)): if hash[s[i]] == 1: return i return -1if __name__ == '__main__': result = Solution().FirstNotRepeatingChar('abcabcdef') print(result) 43 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 解题思路思路1：利用字符串切片思路2：多次翻转，先将0~n-1翻转，n~len(s)-1翻转，最后将整个字符串翻转12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def LeftRotateString(self, s, n): # write code here if len(s) &lt;= 1: return s n = n % len(s) # 处理n&gt;len(s)的情况 # 思路1 # return s[k:] + s[:k] # 思路2 # return (s[:n][::-1]+s[n:][::-1])[::-1] # 思路2 s = list(s) self.reverse(s,0,n-1) self.reverse(s,n,len(s)-1) self.reverse(s,0,len(s)-1) return "".join(s) def reverse(self, s,start,end): while start &lt; end: s[start],s[end] = s[end],s[start] start += 1 end -= 1if __name__ == '__main__': result = Solution().LeftRotateString('abcXYZdef',4) print(result) 44 翻转单词顺序序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 解题思路思路1：分割成列表，然后对列表翻转，返回合并的字符串。思路2：先翻转整个字符串，然后翻转每个单词，用两个指针记录每个单词的开始和结尾的位置。遇到 ‘ ‘ 说明单词的结尾，需要调节指针。另外需要注意的是，字符串不能直接修改，需要转成list之后才能直接对每一位进行修改。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def ReverseSentence(self, s): # write code here if not s: return s # 思路1 # s = s.split(' ') # s.reverse() # return " ".join(s) # 思路2: if len(s) == 0: return s s = list(s) self.reverse(s, 0, len(s)-1) start, end = 0, 0 while end &lt;= len(s)-1: while end &lt;= len(s)-1 and s[end] != ' ': end += 1 self.reverse(s, start, end-1) start = end+1 end = start return ''.join(s) def reverse(self, s, left, right): i, j = left, right while i &lt;= j: s[i], s[j] = s[j], s[i] i, j = i+1, j-1if __name__ == '__main__': result = Solution().ReverseSentence('student. a am I') print(result) 49 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。1234输入描述:输入一个字符串,包括数字字母符号,可以为空输出描述:如果是合法的数值表达则返回该数字，否则返回0 示例1123456输入+2147483647 1a33输出2147483647 0 解题思路思路1： 使用了ord函数考虑首位是否有符号位遍历字符串，如果字符串为字母，跳出循环字符0对应的ASCII码为48，对于每个字符，求其ASCII-48 思路2：使用hash将’0’~’9’和数字0~9映射，在遍历1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-class Solution: def StrToInt(self, s): # write code here if not s: return 0 sign = 1 if s[0] == '+' or s[0] == '-': if s[0] == '-': sign = -1 s = s[1:] # 思路1 # res = 0 # for x in s: # if x &gt; '9' or x &lt; '0': # return 0 # res = res * 10 + ord(x)- 48 # return res * sign # 思路2： dict = &#123;'0':0,'1':1,'2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9&#125; res = 0 for x in s: if x &gt; '9' or x &lt; '0': return 0 res = res * 10 + dict[x] return res * signif __name__ == '__main__': result = Solution().StrToInt('-123') print(result) 52 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 解题思路我们先来分析如何匹配一个字符，现在只考虑’.’，不考虑&#39;*&#39;：如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符&#39;*&#39;考虑进去，它可以匹配任意次的字符，当然出现0次也可以：而当模式中的第二个字符是*时：如果字符串第一个字符跟模式第一个字符匹配（包括模式串为’.’的情况），可以有3种匹配方式： 模式后移2字符，相当于x*被忽略； 字符串后移1字符，模式后移2字符，正好匹配x*中的&#39;x&#39;位； 字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配，相当于把模式串中的当前字符和&#39;*&#39;忽略掉。 当模式中的第二个字符不是*时，也就是上面说的只有字符’.’的情况。 如果字符串第一个字符和模式中的第一个字符相匹配（包括模式串为’.’的情况），那么字符串和模式都后移一个字符，然后匹配剩余的。 如果字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # s, pattern都是字符串 def match(self, s, pattern): if s == pattern: return True if not pattern: return False if len(pattern) &gt; 1 and pattern[1] == '*': if s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s,pattern[2:]) or self.match(s[1:],pattern[2:]) or self.match(s[1:],pattern) else: return self.match(s,pattern[2:]) elif s and (s[0] == pattern[0] or pattern[0] == '.'): return self.match(s[1:],pattern[1:]) return Falseif __name__ == '__main__': result = Solution().match('a','.') print(result) 53 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 解题思路定义两个标志位，分别表示E或者e是否出现过，以及小数点.是否出现过。 以e（或E）为分隔，获得两个子字符串；e之前的字符串小数点只能出现一次；e之后的字符串不允许出现小数点； 符号位+或-只可能出现在两个子字符串的首位； e（或E）、小数点.不能出现在末尾12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s字符串 def isNumeric(self, s): # write code here isAllowDot = True isAllowE = True for i in range(len(s)): if (i==0 or s[i-1] in 'eE') and s[i] in '+-' and i &lt; len(s)-1: continue elif isAllowDot and s[i]=='.': isAllowDot = False if i &gt;= len(s)-1 or s[i+1] not in '0123456789': return False elif isAllowE and s[i] in 'eE': isAllowDot = False isAllowE = False if i&gt;=len(s)-1 or s[i+1] not in '0123456789+-': return False elif s[i] not in '0123456789': return False return True]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 回溯]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是回溯相关题目题解总结。 [TOC] 65.矩阵中的路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 解题思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-class Solution: def hasPath(self, matrix, rows, cols, path): # write code here if len(matrix) == 0 or rows &lt;= 0 or cols &lt;= 0: return False if len(path) == 0: return True visited = [False]*(rows*cols) for i in range(rows): for j in range(cols): if self.HasPath(matrix, rows, cols, path, i, j, visited, 0): return True return False def HasPath(self, matrix, rows, cols, path, i, j, visited, pathLen): if pathLen == len(path): return True curHasPath = False if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and matrix[i*cols+j] == path[pathLen] and not visited[i*cols+j]: visited[i*cols+j] = True pathLen += 1 curHasPath = self.HasPath(matrix, rows, cols, path, i+1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i-1, j, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j+1, visited, pathLen) or self.HasPath(matrix, rows, cols, path, i, j-1, visited, pathLen) if not curHasPath: pathLen -= 1 visited[i*cols+j] = False return curHasPath 66 机器人的运动范围题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def movingCount(self, threshold, rows, cols): # write code here if rows &lt;= 0 or cols &lt;= 0: return 0 visited = [False]*(rows*cols) return self.moving(threshold, rows, cols, 0, 0, visited) def moving(self, threshold, rows, cols, i, j, visited): count = 0 if 0 &lt;= i &lt; rows and 0 &lt;= j &lt; cols and self.getnum(i)+self.getnum(j) &lt;= threshold and not visited[i*cols+j]: visited[i*cols+j] = True count = 1 + self.moving(threshold, rows, cols, i+1, j, visited)+ \ self.moving(threshold, rows, cols, i-1, j, visited) + \ self.moving(threshold, rows, cols, i, j+1, visited) + \ self.moving(threshold, rows, cols, i, j-1, visited) return count def getnum(self, num): res = 0 while num: res += num%10 num //= 10 return res]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 递归]]></title>
    <url>%2F2019%2F06%2F15%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是递归相关题目题解总结。 [TOC] 7.裴波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;=39）斐波那契数列公式为： 解题思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示：我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。所以，使用简单的循环方法来实现。 123456789101112131415# -*- coding:utf-8 -*-class Solution: def Fibonacci(self, n): # write code here if n &lt;= 1: return n a, b = 0,1 for i in range(1,n): c = a + b a, b = b, c return c if __name__ == '__main__': result = Solution().Fibonacci(6) print(result) 8 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 解题思路首先我们考虑最简单的情况。如果只有1级台阶，那么显然只一种跳法。如果有2级台阶，那就有两种跳法：一种是分两次跳，每次跳1级；另一种是一次跳2级。 接着，我们来讨论一般情况。我们把n级台阶时的跳法看成是n的函数，记为f(n)。当n&gt;2时，第一次跳的时候就有两种不同的选择：一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；另外一种选择是跳一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)。分析到这里，我们不难看出这实际上就是斐波那契数列了。12345678910111213141516# -*- coding:utf-8 -*-class Solution: def jumpFloor(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2, number): c = a + b a, b = b, c return cif __name__ == '__main__': result = Solution().jumpFloor(5) print(result) 9 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题思路当n=1时，结果为1；当n=2时，结果为2；当n=3时，结果为4；以此类推，我们使用数学归纳法不难发现，跳法f(n)=2^(n-1)。1234567891011# -*- coding:utf-8 -*-class Solution: def jumpFloorII(self, number): # write code here if number &lt;= 2: return number return 2**(number-1)if __name__ == '__main__': result = Solution().jumpFloorII(4) print(result) 10 矩形覆盖题目描述我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 解题思路以2x8的矩形为例。示意图如下：我们先把2x8的覆盖方法记为f(8)。用第一个1x2小矩阵覆盖大矩形的最左边时有两个选择，竖着放或者横着放。当竖着放的时候，右边还剩下2x7的区域，这种情况下的覆盖方法记为f(7)。接下来考虑横着放的情况。当1x2的小矩形横着放在左上角的时候，左下角和横着放一个1x2的小矩形，而在右边还剩下2x6的区域，这种情况下的覆盖方法记为f(6)。因此f(8)=f(7)+f(6)。此时我们可以看出，这仍然是斐波那契数列。123456789101112131415# -*- coding:utf-8 -*-class Solution: def rectCover(self, number): # write code here if number &lt;= 3: return number a, b = 1, 2 for i in range(2,number): c = a+b a,b = b,c return cif __name__ == '__main__': result = Solution().rectCover(4) print(result)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 链表]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是链表相关题目题解总结。 [TOC] 3. 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路使用Python库函数，新建一个列表，使用insert每次插入到最前面，或者使用append最后在使用reverse。123456789101112131415161718192021222324252627282930313233343536# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def printListFromTailToHead(self, listNode): # 方法1：使用insert函数 # c = [] # while listNode: # c.insert(0,listNode.val) # listNode = listNode.next # return c # 方法2：使用append，最后reverse c = [] while listNode: c.append(listNode.val) listNode = listNode.next c.reverse() return cif __name__ == '__main__': run = Solution() result = run.printListFromTailToHead(node1) print(result) 14.链表中倒数第k个结点题目描述输入一个链表，输出该链表中倒数第k个结点。 解题思路 三个特例： 如果输入的链表为空； k大于链表的长度； k为0的情况。 对于正常情况，设置两个指针分别指向头结点，第一个指针向前走k-1步，走到正数第k个结点，同时保持第二个指针不动，然后第一个指针和第二个指针每次同时前移一步，这样第一个指针指向尾结点的时候，第二个指针指向倒数第k个结点。判断尾结点的条件是 p.next == None。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = None# 单向链表链表 node1: 1-&gt;2-&gt;3node1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4class Solution: def FindKthToTail(self, head, k): if not head or k &lt;= 0: # 链表为空或k小于等于0 return None p = head q = head for i in range(1,k): if p.next == None: # k大于链表的长度 return None else: p = p.next while p.next: p = p.next q = q.next return qif __name__ == '__main__': originList = node1 print('链表:',end = ' ') while originList: print(originList.val, end = ' ') originList = originList.next k = 5 result = Solution().FindKthToTail(node1,k) print('\n倒数第&#123;0&#125;个结点:'.format(k),end = ' ') while result: print(result.val,end = ' ') result = result.next 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间1234567891011121314151617181920212223 def FindMidNode(self,head): """ 推广: 寻找中间节点, 两个指针一起, 第一个指针每次走两步, 第二个指针每次走一步, 快指针指到尾部, 慢指针正好指到中间 """ if not head: return None p = head q = head p = p.next while p: p = p.next if p: p = p.next q = q.next return qmid = Solution().FindMidNode(node1) print('\n中间结点:',end = ' ') while mid: print(mid.val, end = ' ') mid = mid.next 15.反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 解题思路迭代123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead dummy = ListNode(0) dummy.next = pHead cur = pHead.next pHead.next = None while cur: temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return dummy.next 递归12345678910111213141516171819202122# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回ListNode def ReverseList(self, pHead): # write code here if not pHead or not pHead.next: return pHead return self.helper(pHead, ListNode(0)) def helper(self, cur, dummy): if not cur: return dummy.next temp = cur.next cur.next = dummy.next dummy.next = cur cur = temp return self.helper(cur, dummy) 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路思路1：循环：如果两个链表不为空，进行比较，将小的赋给合并的指针头，小的链表走一步，合并链表走一步，如果有一个为空，跳出循环，并将另一不为空的链表后续部分赋给合并链表 思路2：递归：如果第一个链表为空，则返回第二个链表，如果第二个链表为空，则返回第一个链表，如果两个链表都为空，结果为空两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表的值小，即赋给合并链表指针。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(3)node3 = ListNode(5)node1.next = node2node2.next = node3node4 = ListNode(2)node5 = ListNode(4)node6 = ListNode(6)node4.next = node5node5.next = node6class Solution: # 返回合并后列表 def Merge(self, pHead1, pHead2): # 循环 # newHead = ListNode(-1) # pre = newHead # while pHead1 and pHead2: # if pHead1.val &lt; pHead2.val: # pre.next = pHead1 # pHead1 = pHead1.next # else: # pre.next = pHead2 # pHead2 = pHead2.next # pre = pre.next # pre.next = pHead1 if pHead1 else pHead2 # return newHead.next # 递归 if not pHead1: return pHead2 if not pHead2: return pHead1 newHead = None if pHead1.val &lt; pHead2.val: newHead = pHead1 newHead.next = self.Merge(pHead1.next, pHead2) else: newHead = pHead2 newHead.next = self.Merge(pHead1, pHead2.next) return newHeadif __name__ == '__main__': result = Solution().Merge(node1,node4) print('合并链表：',end = ' ') while result: print(result.val,end = ' ') result = result.next 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 解题思路我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。有图思路更清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:utf-8 -*-class RandomListNode: def __init__(self, x): self.label = x self.next = None self.random = None# 复杂链表node1 = RandomListNode(1)node2 = RandomListNode(2)node3 = RandomListNode(3)node4 = RandomListNode(4)node1.next = node2node2.next = node3node3.next = node4node1.random = node3node2.random = node4node3.random = node2node4.random = node1# -*- coding:utf-8 -*-# class RandomListNode:# def __init__(self, x):# self.label = x# self.next = None# self.random = Noneclass Solution: # 返回 RandomListNode def Clone(self, pHead): # write code here if not pHead: return pHead # 复制节点在源节点后面 cur = pHead while cur: temp = cur.next cur.next = RandomListNode(cur.label) cur.next.next = temp cur = temp #复杂随机节点 cur = pHead while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next #分离新旧节点 res = pHead.next temp = res cur = pHead while cur: cur.next = cur.next.next if temp.next: temp.next = temp.next.next cur = cur.next temp = temp.next return resif __name__ == '__main__': result = Solution().Clone(node1) while result: print(result.label, end = ' ') result = result.next 36 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 解题思路思路1：把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后，这样，生成了两个相同长度的链表，我们只要同时遍历这两个表，就一定能找到公共节点。时间复杂度O(m+n)，空间复杂度O(m+n). 思路2：首先依次遍历两个链表，记录两个链表的长度m和n，如果 m &gt; n，那么我们就先让长度为m的链表走m-n个结点，然后两个链表同时遍历，当遍历到相同的结点的时候停止即可。对于 m &lt; n，同理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node5 = ListNode(5)node6 = ListNode(6)node1.next = node2node2.next = node5node5.next = node6node3.next = node4node4.next = node5class Solution: def FindFirstCommonNode(self, pHead1, pHead2): # 方法1 # if not pHead1 or not pHead2: # return None # cur1, cur2 = pHead1, pHead2 # while cur1 != cur2: # cur1 = cur1.next if cur1 else pHead2 # cur2 = cur2.next if cur2 else pHead1 # return cur1 # 方法2 if not pHead1 or not pHead2: return None m = n = 0 cur1, cur2 = pHead1, pHead2 while cur1: m += 1 cur1 = cur1.next while cur2: n += 1 cur2 = cur2.next if m &gt; n: for i in range(m-n): pHead1 = pHead1.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next else: for i in range(n-m): pHead2 = pHead2.next while pHead1: if pHead1 == pHead2: return pHead1 pHead1, pHead2 = pHead1.next, pHead2.next return Noneif __name__ == '__main__': result = Solution().FindFirstCommonNode(node1, node3) while result: print(result.val, end = ' ') result = result.next 55 链表中环的入口结点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 解题思路第一步：判断是否存在环，用快慢指针，一个走一步，一个走两步，如果最终达到同一节点，则说明有环 第二步：寻找环的入口，假设入口结点距离头结点a个单位，fast和slow相遇在距离入口结点b个单位的位置，环剩下的长度为c，则有a+b+c+b = 2*(a+b) —&gt; a = c 。因此，在重合时候，将fast置为head，再一步一步地走，当与slow重合时的结点即为入口结点。 1234567891011121314151617181920212223242526272829303132333435# -*- coding:utf-8 -*-class ListNode: def __init__(self,x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(4)node1.next = node2node2.next = node3node3.next = node4node4.next = node2class Solution: def EntryNodeOfLoop(self, pHead): # write code here if not pHead or not pHead.next: return None fast = slow = pHead while fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: # 有环 fast = pHead while fast != slow: fast = fast.next slow = slow.next return fast return Noneif __name__ == '__main__': result = Solution().EntryNodeOfLoop(node1) 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 解题思路要删除有序链表中所有的重复节点，而头结点有可能就是重复节点。这样的比较好的解决方式就是新建头结点，然后往后遍历，同样的值就全部略过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding:utf-8 -*-class ListNode: def __init__(self, x): self.val = x self.next = Nonenode1 = ListNode(1)node2 = ListNode(2)node3 = ListNode(3)node4 = ListNode(3)node5 = ListNode(4)node6 = ListNode(4)node7 = ListNode(5)node1.next = node2node2.next = node3node3.next = node4node4.next = node5node5.next = node6node6.next = node7class Solution: def deleteDuplication(self, pHead): # write code here if not pHead or not pHead.next: return pHead first = ListNode(-1) first.next = pHead last = first cur = pHead while cur and cur.next: if cur.val != cur.next.val: cur = cur.next last = last.next else: val = cur.val while cur and cur.val == val: cur = cur.next last.next = cur return first.nextif __name__ == '__main__': result = Solution().deleteDuplication(node1) while result: print(result.val, end = ' ') result = result.next]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 数组]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是数组相关题目题解总结。 1 二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路思路：由于数组是有序的，从左下角看，向上为递减，向右为递增，因此可以从左下角开始查找，当左下角元素比整数大时，上移，当左下角元素比整数小时，右移。 Python 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here if len(array) == 0: return False rows, cols = len(array), len(array[0]) row, col = rows-1, 0 while row &gt;= 0 and col &lt;= cols-1: if array[row][col] == target: return True elif array[row][col] &gt; target: row -= 1 else: col += 1 return False Java12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array.length == 0) return false; int row = array.length - 1; int col = 0; while(row &gt;= 0 &amp;&amp; col &lt; array[0].length) &#123; if(array[row][col] == target) return true; else if (array[row][col] &gt; target) row -= 1; else col += 1; &#125; return false; &#125;&#125; 6 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 解题思路旋转之后的数组可以划分成两个有序的子数组，前面子数组的元素都大于后面子数组的元素，并且第一个元素大于最后一个元素 最小的元素就是两个子数组的分界线 使用二分查找，O(logn) 使用两个指针分别指向数组的第一个和最后一个元素 若中间元素小于它前一个元素，则中间元素为最小 若中间元素大于右边界，此时最小值位于中间元素之后（mid+1,r），左指针指向中间元素加1 若中间元素小于右边界，此时最小元素位于中间元素的前面(l, mid-1)，右指针指向中间元素减1. Python 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def minNumberInRotateArray(self, rotateArray): # write code here if len(rotateArray) == 0: return 0 left, right = 0, len(rotateArray)-1 while left &lt;= right: mid = left + (right-left)//2 if rotateArray[mid] &lt; rotateArray[mid-1]: return rotateArray[mid] if rotateArray[mid] &gt; rotateArray[right]: left = mid + 1 else: right = mid - 1 Java 1234567891011121314151617181920212223import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) return 0; if(array.length == 1) return array[0]; int left = 0; int right = array.length-1; while(left &lt;= right) &#123; int mid = (left+right)/2; if(array[mid] &lt; array[mid-1]) return array[mid]; else if (array[mid] &gt; array[right]) left = mid + 1; else right = mid - 1; &#125; return 0; &#125;&#125; 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路对于不需要考虑奇数与奇数，偶数与偶数之间的相对位置不变的话，只需要设置左右两个指针，然后交换就行。 但考虑相对位置不变的话最简单的方法就是新建两个数组。1234567891011121314# -*- coding:utf-8 -*-class Solution: def reOrderArray(self, array): # write code here if len(array) == 0 or len(array) == 1: return array odd, even = [], [] for x in array: if x % 2 == 1: odd.append(x) else: even.append(x) return odd + even 28 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 解题思路思路1：使用hash函数，第一次遍历将每个数字出现次数保存下来，第二次遍历寻找次数超过数组长度一半的数字。 思路2：如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。 在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: def MoreThanHalfNum_Solution(self, numbers): # write code here if len(numbers) == 0: return 0 Dict = &#123;&#125; for x in numbers: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 for key, val in Dict.items(): if val &gt; len(numbers)//2: return key return 0 30 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 解题思路思路： 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def FindGreatestSumOfSubArray(self, array): # write code here if len(array) == 0: return 0 maxsum = array[0] temp = 0 for x in array: temp += x if temp &gt; maxsum: maxsum = temp if temp &lt; 0: temp = 0 return maxsum 32 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 解题思路首先将数组中的数字全部转换为字符串存储在一个新的数组中，然后比较每两个数字串的拼接的mn和nm的大小，若mn&lt;nm，则m更小，反之n更小，然后把更小的数放入一个新的List中，最后输出即可。使用冒泡排序很方便。 1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def PrintMinNumber(self, numbers): # write code here if len(numbers) == 0: return '' if len(numbers) == 1: return str(numbers[0]) numbers = [str(num) for num in numbers] for i in range(len(numbers)-1): for j in range(i+1, len(numbers)): if numbers[i]+numbers[j] &gt; numbers[j] + numbers[i]: numbers[i], numbers[j] = numbers[j], numbers[i] return ''.join(numbers) 35 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述: 题目保证输入的数组中没有的相同的数字1234数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5 示例112输入 1,2,3,4,5,6,7,0输出 7 解题思路思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，先分后治,如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。 逆序对的总数 = 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下： 这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列。 设置两个下标：两个有序序列的首部。每次比较两个首部值，如果前首尾小于等于后首值，将较小值赋给辅助数组，第一个序列往前走一步，没有逆序对；否则，第二个序列值赋给辅助数组，第二个序列向前走一步，则有”第一个序列当前值及其后的长度“个逆序对；即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 123456789101112131415161718192021222324252627282930313233# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here return self.Msort(data, 0, len(data)-1) %1000000007 def Msort(self, data, left, right): if left &gt;= right: return 0 mid = left + (right-left) // 2 l = self.Msort(data, left, mid) r = self.Msort(data, mid+1, right) return l + r + self.merge(data, left, mid, right) def merge(self, data, left, mid, right): res = 0 i, j = left, mid+1 temp = [] while i &lt;= mid and j &lt;= right: if data[i] &lt; data[j]: temp.append(data[i]) i += 1 else: res += (mid-i+1) temp.append(data[j]) j += 1 temp += data[i:mid+1] if i!=mid+1 else data[j:right+1] data[left:right+1] = temp[:] return res 超时123456789101112131415# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code here if len(data) &lt;= 1: return 0 p = 0 for i in range(len(data)-1): for j in range(i+1, len(data)): if data[i] &gt; data[j]: count += 1 return p%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data)&lt;=1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data,temp,0,len(data)-1)% 1000000007 def MSort(self,data,temp,low,high): if low&gt;=high: temp[low] = data[low] return 0 mid = (low+high)//2 left = self.MSort(temp,data,low,mid) right = self.MSort(temp,data,mid+1,high) count = 0 i = low j = mid+1 index = low while i &lt;=mid and j &lt;= high: if data[i]&lt;=data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid-i+1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count + left + right 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:utf-8 -*-class Solution: def InversePairs(self, data): # write code her if len(data) &lt;= 1: return 0 # 思路1：运行超时 # p = 0 # for i in range(len(data)-1): # for j in range(i+1,len(data)): # if data[i] &gt; data[j]: # p += 1 # return p % 1000000007 # 思路2：归并排序 temp = [x for x in data] return self.MSort(data, temp, 0, len(data) - 1) % 1000000007 def MSort(self, data, temp, low, high): if low &gt;= high: temp[low] = data[low] return 0 mid = (low + high) // 2 left = self.MSort(temp, data, low, mid) right = self.MSort(temp, data, mid + 1, high) return left + right + self.merge(data, temp, low, mid, high) def merge(self, data, temp, low, mid, high): count = 0 i = low j = mid + 1 index = low while i &lt;= mid and j &lt;= high: if data[i] &lt;= data[j]: temp[index] = data[i] i += 1 else: temp[index] = data[j] j += 1 count += mid - i + 1 index += 1 while i &lt;= mid: temp[index] = data[i] i += 1 index += 1 while j &lt;= high: temp[index] = data[j] j += 1 index += 1 return count 37 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 解题思路使用二分搜索，当搜索到与关键字相等时，在上下限之间遍历，计数。没找到则返回0 123456789101112131415161718192021# -*- coding:utf-8 -*-class Solution: def GetNumberOfK(self, data, k): # write code here if len(data) == 0: return 0 left, right = 0, len(data)-1 while left &lt;= right: mid = (left+right)//2 if data[mid] == k: count = 0 for i in range(left, right+1): if data[i] == k: count += 1 return count elif data[mid] &gt; k: right = mid-1 else: left = mid+1 return 0 40数组中只出现一次的数字题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路思路1：考虑用哈希表的方法，但是空间复杂度不是O（1）。应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 思路2： 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here Dict = &#123;&#125; for x in array: if x not in Dict: Dict[x] = 1 else: Dict[x] += 1 res = [] for key, val in Dict.items(): if val == 1: res.append(key) return res 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-class Solution: # 返回[a,b] 其中ab是出现一次的两个数字 def FindNumsAppearOnce(self, array): # write code here num = 0 for x in array: num ^= x index = self.getfitstBitIs1(num) num1, num2 = 0, 0 for x in array: if self.BitIs1(x, index): num1 ^= x else: num2 ^= x return num1, num2 def getfitstBitIs1(self, num): index = 0 while num&amp;1 == 0 and index &lt;= 32: index += 1 num = num&gt;&gt;1 return index def BitIs1(self, num, index): num = num &gt;&gt; index return num &amp; 1 50数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路1：建立一个哈希表，这样实在O(n)的时间查找到，但是空间复杂度O(n) 思路2： 还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 如果还是不懂，看下面的实例分析就懂了！ 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等,但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 123456789101112131415161718# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False seen = [] for x in numbers: if x not in seen: seen.append(x) else: duplication[0] = x return True return False 12345678910111213141516171819# -*- coding:utf-8 -*-class Solution: # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0] # 函数返回True/False def duplicate(self, numbers, duplication): # write code here if len(numbers) &lt;= 1: return False for i in range(len(numbers)): while i != numbers[i]: if numbers[i] == numbers[numbers[i]]: duplication[0] = numbers[i] return True else: numbers[numbers[i]], numbers[i] = numbers[i], numbers[numbers[i]] return False 51构建乘积数组题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 解题思路观察下公式，你会发现，B[i]公式中没有A[i]项，也就是说如果可以使用除法，就可以用公式B[i]=A[0]A[1]…..A[n-1]/A[i]来计算B[i]，但是题目要求不能使用，因此我们只能另想办法。 可以把B[i]=A[0]A[1]…..A[i-1]A[i+1]…..A[n-1]。看成A[0]A[1]…..A[i-1]和A[i+1]…..A[n-2]A[n-1]两部分的乘积。 即通过A[i]项将B[i]分为两部分的乘积。效果如下图所示：不妨设定C[i]=A[0]A[1]…A[i-1]，D[i]=A[i+1]…A[n-2]A[n-1]。C[i]可以用自上而下的顺序计算出来，即C[i]=C[i-1]A[i-1]。类似的，D[i]可以用自下而上的顺序计算出来，即D[i]=D[i+1]A[i+1]。 如果还是不明白，没有关系，直接看下代码，细细体会下就懂了。第一个for循环用来计算上图1范围的数，第二个for循环用来计算上图2范围的数。1234567891011121314151617# -*- coding:utf-8 -*-class Solution: def multiply(self, A): # write code here if len(A) &lt;= 1: return False B = [1] * len(A) for i in range(1, len(A)): B[i] = B[i-1]*A[i-1] temp = 1 for i in range(len(A)-2,-1, -1): temp *= A[i+1] B[i] *= temp return B]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解 - 树]]></title>
    <url>%2F2019%2F06%2F14%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[本系列为剑指offer刷题笔记，刷题平台为牛客网。 本文主要是树相关题目题解总结。 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路前序遍历先根节点再左子树最后右子树，第一个元素肯定是根节点，然后在中序遍历中寻找根节点的索引，按照中序遍历的规则：先左子树再根节点最后右子树，根节点前的一定是左子树的中序数组，根节点后的一定是右子树的中序数组。因此，我们每次都需要在前序遍历中找根结点并创建一个根结点，然后在中序遍历中确定根结点位置，并确定当前根结点的左右子树，然后以同样的方法去构建左右子树。这整个过程是一个递归的过程。 123456789101112131415161718192021# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0 or len(pre) != len(tin): return None rootval = pre[0] index = tin.index(rootval) root = TreeNode(rootval) root.left = self.reConstructBinaryTree(pre[1:index+1], tin[:index]) root.right = self.reConstructBinaryTree(pre[index+1:], tin[index+1:]) return root 17 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路如果树1或树2为空时，返回False在树1中找到和树2一样的根结点R，然后在判断树1中以R为根结点的子树是否与树2有一样的结构。先以树1 的根结点为起点寻找是否包含树B，如果找不到就以树A的左结点为起点寻找，若还找不到，以树A的右结点为起点寻找，递归进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node2.right = node3node3.left = node4node3.right = node5class Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: # 找到根结点相同的结点 result = self.isSubTree(pRoot1, pRoot2) if not result: # 没找到，在左子树寻找 result = self.HasSubtree(pRoot1.left, pRoot2) if not result: # 还没找到，在右子树寻找 result = self.HasSubtree(pRoot1.right, pRoot2) return result def isSubTree(self,tree1, tree2): if not tree2: return True if not tree1: return False if tree1.val != tree2.val: return False return self.isSubTree(tree1.left,tree2.left) and self.isSubTree(tree1.right,tree2.right)if __name__ == '__main__': result = Solution().HasSubtree(node1, node3) print(result) 123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def HasSubtree(self, pRoot1, pRoot2): # write code here if not pRoot1 or not pRoot2: return False result = False if pRoot1.val == pRoot2.val: result = self.judge(pRoot1, pRoot2) return result or self.HasSubtree(pRoot1.left, pRoot2) or self.HasSubtree(pRoot1.right, pRoot2) def judge(self, pRoot1, pRoot2): if not pRoot2: return True if not pRoot1 or pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left, pRoot2.left) and self.judge(pRoot1.right, pRoot2.right) 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 解题思路递归，判断根节点是否为空，为空时，无需交换，不为空时，交换其左右节点。对左右子树进行递归。12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回镜像树的根节点 def Mirror(self, root): # 递归 if not root: return temp = root.left root.left = root.right root.right = temp # if root.left: self.Mirror(root.left) # if root.right: self.Mirror(root.right) return rootif __name__ == '__main__': result = Solution().Mirror(node1) print(result) 迭代。使用栈123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回镜像树的根节点 def Mirror(self, root): # write code here if not root: return None stack = [root] while stack: node = stack.pop(0) temp = node.left node.left = node.right node.right = temp if node.left: stack.append(node.left) if node.right: stack.append(node.right) return root 22 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 解题思路思路:使用队列 因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点8开始分析。为了接下来能够打印值为8的两个子结点，我们应该遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值为10,5和7。接下来我们从容器中取出值为10的结点，注意到值为10的结点比值为5,7的结点先放入容器，此时又比这两个结点先取出，同时将9和11放入数据容器，这就是我们通常说的先入先出，因此数据容器为一个队列。由于值为5,7,9,11的结点都没有子结点，因此只要依次打印即可。 通过例子，我们找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的左右结点依次放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有结点都打印出来为止。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(11)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here ans = [] if not root: return ans queue = [] queue.append(root) while queue: cur = queue.pop(0) ans.append(cur.val) if cur.left: queue.append(cur.left) if cur.right: queue.append(cur.right) return ansif __name__ == '__main__': result = Solution().PrintFromTopToBottom(node1) print(result) 递归123456789101112131415161718192021222324252627282930# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回从上到下每个节点值列表，例：[1,2,3] def PrintFromTopToBottom(self, root): # write code here if not root: return [] res = [] self.level(root, 0, res) ans = [] for x in res: ans += x return ans def level(self, root, level, res): if not root: return if level == len(res): res.append([]) res[level].append(root.val) self.level(root.left, level+1, res) self.level(root.right, level+1, res) 23 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 解题思路 以[5,7,6,9,11,10,8]为例，后序遍历结果的最后一个数字8 就是根结点的值，在这个数组中，前三个数字5、7和6都比8小，是值为8的结点的左子树结点；后三个数字9、11和10都比8大，是值为8的结点的右子树。 用同样的方法确定与数组每一部分对应的子树的结构，这其实就是一个递归的过程，对于序列5,7,6，最后一个数字6是左子树的根结点的值，数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 使用递归的方法，先判断数组的左子树和右子树的位置，找出左子树后。判断右子树是不是二叉搜索树。 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-class Solution: def VerifySquenceOfBST(self, sequence): # write code here if len(sequence) == 0: return False if len(sequence) &lt;= 2: return True rootval = sequence[-1] k = 0 while k &lt; len(sequence)-1 and sequence[k] &lt; rootval: k += 1 for i in range(k, len(sequence)-1): if sequence[i] &lt;= rootval: return False left = right = True if sequence[:k]: left = self.VerifySquenceOfBST(sequence[:k]) if sequence[k:-1]: right = self.VerifySquenceOfBST(sequence[k:-1]) return left and right 24 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 解题思路递归，深度优先搜索，使用前序遍历。每次遍历，判断当前root是否同时满足： 与给定数值相等 左子树为空 右子树为空 如果满足条件，返回val值。如果不是叶子结点，我们分别对根结点的左子树右子树进行递归，直到找到叶子结点，然后遍历把叶子结点和父节点对应的val组成的序列返回上一层；如果叶子结点不满足与给定值相等，其实也返回了序列，只不过是空序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node7 = TreeNode(1)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表，内部每个列表表示找到的路径 def FindPath(self, root, expectNumber): # write code here if not root: return [] res = [] self.dfs(root, expectNumber, [root.val], res) return res def dfs(self, root, expectNumber, path, res): if not root: return if not root.left and not root.right and sum(path) == expectNumber: res.append(path) return if root.left: self.dfs(root.left, expectNumber, path+[root.left.val], res) if root.right: self.dfs(root.right, expectNumber, path+[root.right.val], res)if __name__ == '__main__': result = Solution().FindPath(node1, 19) print(result) 26二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 解题思路 二叉搜索树如上图所示，我们将其转换为排序双向链表根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的排序，就是排序的顺序。因此，确定了二叉搜索树的遍历方法。接下来，我们可以把树分成三部分，值为10的结点，根节点为6的左子树，根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 根据中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点；接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。最后，设置从最左边的结点开始123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(14)node4 = TreeNode(4)node5 = TreeNode(8)node6 = TreeNode(12)node7 = TreeNode(16)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6node3.right = node7class Solution: def Convert(self, pRootOfTree): # write code here if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right): return pRootOfTree #处理左子树 self.Convert(pRootOfTree.left) left = pRootOfTree.left #左子树最右节点与根节点链接 if left: while left.right: left = left.right left.right = pRootOfTree pRootOfTree.left = left #处理右子树 self.Convert(pRootOfTree.right) right = pRootOfTree.right #右子树最左节点与根节点链接 if right: while right.left: right = right.left right.left = pRootOfTree pRootOfTree.right = right while pRootOfTree.left: pRootOfTree = pRootOfTree.left return pRootOfTreeif __name__ == '__main__': result = Solution().Convert(node1) 38 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 解题思路 思路1： 递归，结点为空时，返回0 不为0时，遍历左右子树，在较深的子树上加1 思路2：bfs 层次遍历 每遍历完一层，层数加1q为当前层的结点，遍历q中的每个结点，然后用tmp保存当前每个结点可能有的左结点和右结点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding:utf-8 -*-class TreeNode: def __init__(self,x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(8)node2 = TreeNode(6)node3 = TreeNode(10)node4 = TreeNode(5)node5 = TreeNode(7)node6 = TreeNode(9)node1.left = node2node1.right = node3node2.left = node4node2.right = node5node3.left = node6class Solution: def TreeDepth(self, pRoot): # write code here # 思路1 # if not pRoot: # return 0 # return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1 # 思路2 if not pRoot: return 0 count = self.levelOrder(pRoot) return count def levelOrder(self,pRoot): count = 0 if not pRoot: return count queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) if r.left: queue.append(r.left) if r.right: queue.append(r.right) temp.append(r.val) if temp: count += 1 return countif __name__ == '__main__': result = Solution().TreeDepth(node1) print(result) 39 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 解题思路平衡二叉树：它是一棵空树，或者它的两个子树的高度差的绝对值不超过1，并且左右两棵子树都是一棵平衡二叉树。 重复遍历多次：BST的定义为|height(lefttree)−height(righttree)|&lt;=1，原问题拆分为计算树高度和判断高度差但是，在遍历每个结点时，调用函数TreeDepth得到它的左右子树的深度，如果每个结点的左右子树的深度相差不超过1，则这是一颗平衡的二叉树。这种方法的缺点是，首先判断根结点是不是平衡的，需要使用TreeDepth获得左右子树的深度，然后还需要继续判断子树是不是平衡的，还是需要使用TreeDepth获得子树的左右子树的深度，这导致了大量的重复遍历。 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def IsBalanced_Solution(self, pRoot): # write code here if not pRoot: return True if abs(self.depth(pRoot.left) - self.depth(pRoot.right)) &lt;= 1: return True return False def depth(self, pRoot): if not pRoot: return 0 return max(self.depth(pRoot.left), self.depth(pRoot.right)) + 1 57 二叉树的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 解题思路三种情况 当前结点有右子树。当前结点的下一结点是右子树中的最左子结点，如node=8，它的下一结点为12. 当前结点无右子树，且当前结点是其父结点的左孩子。下一结点为当前结点的父结点，如node=8，它的下一个结点为12。 当前结点无右子树，且当前结点是其父结点的右孩子。则一直向上遍历，直到找到最靠近的一个祖先节点pNode且pNode是其父节点的左子节点，那么输入节点的下一个结点就是pNode的父节点。如node=14，它的下一个结点为16. 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: def GetNext(self, pNode): # write code here if not pNode: return None if pNode.right: pNode = pNode.right while pNode.left: pNode = pNode.left return pNode if pNode.next and pNode == pNode.next.left: return pNode.next if pNode.next and pNode == pNode.next.right: pNode = pNode.next while pNode.next and pNode == pNode.next.right: pNode = pNode.next return pNode.next return None 58 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 解题思路判断一棵二叉树是不是对称的，等价于判断其左右子树是不是镜像对称的。判断镜像对称即判断对称位置上的元素是不是相等的。两个结点AB对称等价于： 两个结点值相等 结点A的左子树和结点B的右子树对称 结点A的右子树和结点B的左子树对称 12345678910111213141516171819202122# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetrical(self, pRoot): # write code here if not pRoot: return True return self.judge(pRoot.left, pRoot.right) def judge(self, pRoot1, pRoot2): if not pRoot1 and not pRoot2: return True if not pRoot1 or not pRoot2: return False if pRoot1.val != pRoot2.val: return False return self.judge(pRoot1.left,pRoot2.right) and self.judge(pRoot1.right,pRoot2.left) 59 按之字顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 解题思路 层次遍历保存结点，最后奇数层翻转 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Nonenode1 = TreeNode(1)node2 = TreeNode(2)node3 = TreeNode(3)node4 = TreeNode(4)node5 = TreeNode(5)node1.left = node2node1.right = node3node2.left = node4node3.right = node5class Solution: def Print(self, pRoot): # write code here # 层次遍历保存结点，最后奇数层翻转 ans = [] if not pRoot: return ans queue = [] queue.append(pRoot) while queue: temp = [] for i in range(len(queue)): r = queue.pop(0) temp.append(r.val) if r.left: queue.append(r.left) if r.right: queue.append(r.right) ans.append(temp) for i in range(1,len(ans),2): ans[i] = ans[i][::-1] return ansif __name__ == '__main__': # [[1] [3 2] [4 5]] result = Solution().Print(node1) print(result) 递归12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) for i in range(1, len(res), 2): res[i] = res[i][::-1] return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 60 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 解题思路比上题简单，直接层次遍历 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] stack = [pRoot] while stack: temp = [] for i in range(len(stack)): node = stack.pop(0) temp.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) res.append(temp) return res 递归123456789101112131415161718192021222324# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回二维列表[[1,2],[4,5]] def Print(self, pRoot): # write code here if not pRoot: return [] res = [] self.level(pRoot, 0, res) return res def level(self, pRoot, level, res): if not pRoot: return if level == len(res): res.append([]) res[level].append(pRoot.val) self.level(pRoot.left, level+1, res) self.level(pRoot.right, level+1, res) 61 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 解题思路序列化二叉树：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串。需要注意的是，序列化二叉树的过程中，如果遇到空节点，需要以某种符号（这里用#）表示。以下图二叉树为例，序列化二叉树时，需要将空节点也存入字符串中。 序列化可以基于先序/中序/后序/按层等遍历方式进行，这里采用先序遍历的方式实现，字符串之间用 “，”隔开。 反序列化二叉树：根据某种遍历顺序得到的序列化字符串，重构二叉树。具体思路是按前序遍历“根左右”的顺序，根节点位于其左右子节点的前面，即非空（#）的第一个节点是某子树的根节点，左右子节点在该根节点后，以空节点#为分隔符。 12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def Serialize(self, root): # write code here if not root: return '#' return str(root.val)+','+self.Serialize(root.left)+','+self.Serialize(root.right) def Deserialize(self, s): # write code here s = s.split(',') return self.Tree(s) def Tree(self, s): if not s: return None val = s.pop(0) root = None if val != '#': root = TreeNode(int(val)) root.left = self.Tree(s) root.right = self.Tree(s) return root 62二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，123456 5 / \ 3 7 / \ / \ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路思路1: 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。遇到bst（二叉搜索树）想到中序遍历，先中序遍历，然后找出第k个结点。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] self.inorder(pRoot, res) return res[k-1] if k &lt;= len(res) else None def inorder(self, pRoot, res): if not pRoot: return self.inorder(pRoot.left, res) res.append(pRoot) self.inorder(pRoot.right, res) if __name__ == '__main__': result = Solution().KthNode(node1,3) print(result.val) 思路2. 先将全部左子树入栈，然后依次出栈，出栈过程中，如果右子树存在，则将其全部左子树入栈。12345678910111213141516171819202122232425262728# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [] self.allLeftinStack(pRoot, stack) while stack: node = stack.pop() res.append(node) if node.right: self.allLeftinStack(node.right, stack) return res[k-1] if k &lt;= len(res) else None def allLeftinStack(self, root, stack): while root: stack.append(root) root = root.left 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # 返回对应节点TreeNode def KthNode(self, pRoot, k): # write code here if not pRoot or k &lt;= 0: return None res = [] stack = [pRoot] while pRoot.left: stack.append(pRoot.left) pRoot = pRoot.left while stack: node = stack.pop() res.append(node) if node.right: stack.append(node.right) temp = node.right while temp.left: stack.append(temp.left) temp = temp.left return res[k-1] if k &lt;= len(res) else None]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 - 排序算法]]></title>
    <url>%2F2019%2F05%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本系列为数据结构学习笔记(待汇总)。 1 排序假设含有n个记录的序列为${r_1,r_2,…,r_n}$，其相应的关键字分别为$(k_1,k_2,…,k_n)$，需确定$1,2,…,n$的一种排列$p_1,p_2,…,p_n$,使其相应的关键字满足$K_{p1} \leq k_{p2} \leq … \leq k_{pn}$关系，即使得序列成为一个按关键字有序的序列$r_{p1},r_{p2},…,r_{pn}$，这样的操作就称为排序。 1.1 排序的稳定性假设$k_i = k_j (1 \leq i \leq n，1 \leq j \leq n，i \neq j)$，且在排序前的序列中$r_i$领先于$r_j$（即$i＜j$）。如果排序后$r_i$仍领先于$r_j$，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$，则称所用的排序方法是不稳定的。 1.2 内排序与外排序内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要内外存之间多次交换数据才能进行。 对于内排序来说，排序算法的性能主要受3个方面影响： 时间性能：内排序中主要进行两种操作，比较和移动。高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间：辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性：算法本身的复杂度，而不是指算法的时间复杂度。 内排序按主要操作分类：插入排序交换排序选择排序归并排序 排序按复杂度分类简单算法：冒泡排序，简单选择排序，直接插入排序改进算法：希尔排序，堆排序，归并排序，快速排序 2 常见排序算法2.1 冒泡排序冒泡排序是一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，知道没有反序的记录为止。 2.1.1 冒泡排序初级版让每一个关键字，都和他后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在一次循环后一定变成最小值。123456789def BubbleSort0(L): for i in range(len(L)): for j in range(i+1,len(L)): if L[i]&gt;L[j]: L[i],L[j] = L[j],L[i] return Lif __name__ == '__main__': result = BubbleSort0([9,1,5,8,3,7,4,6,2]) print(result) 2.1.2 冒泡排序正宗版123456789def BubbleSort(L): for i in range(len(L)): for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.3 冒泡排序优化当i=2时，我们已经对9与8,8与7，。。。，3与2作了比较，没有任何数据交换，说明此序列已经有序，不需要再继续后面的循环判断工作了。增加标记变量flag来实现这一算法的改进。 12345678910111213def BubbleSort(L): flag = True for i in range(len(L)): if flag: flag = False for j in range(len(L)-2,i-1,-1): if L[j] &gt; L[j+1]: L[j],L[j+1]=L[j+1],L[j] flag = True return Lif __name__ == '__main__': result = BubbleSort([9,1,5,8,3,7,4,6,2]) print(result) 2.1.4 冒泡排序的算法复杂度：最好情况：要排序的表本身就是有序的，需要$n-1$次比较，没有数据交换，时间复杂度为$O(n)$。最坏情况：待排序表示逆序的情况，需要比较$1+2+3+…+(n-1) = n(n-1)/2$次，并做等数量级的记录移动，总时间复杂度为$O(n^2)$。冒泡排序是稳定的。 2.2 简单选择排序通过$n-i$次关键字间的比较，从$n-i+1$个记录中选出关键字最小的记录，并和第$i,(1≤i≤n)$个记录交换之。123456789101112def SelectSort(L): for i in range(len(L)): min = i for j in range(i+1,len(L)): if L[j] &lt; L[min]: min = j if min != i: L[i],L[min] = L[min],L[i] return Lif __name__ == '__main__': result = SelectSort([9,1,5,8,3,7,4,6,2]) print(result) 2.2.1 简单选择排序复杂度分析简单选择排序最大的特点是交换移动数据次数相当少。无论最好最差的情况，其比较次数都是一样多，第$i$躺排序需要进行$n-i$次关键字的比较，需要比较$(n-1)+(n-2)+…+1 = n(n-1)/2$次;而对于交换次数而言，最好的时候交换0次，最坏时候交换n-1次。总的时间复杂度仍为$O(n^2)$。性能略优于冒泡排序，简单选择排序是稳定的。 2.3 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。12345678910111213def InsertSort(L): for i in range(1,len(L)): if L[i] &lt; L[i-1]: temp = L[i]#设置哨兵 k = i while temp &lt; L[k-1] and k &gt;= 1: L[k] = L[k-1]#记录后移 k -= 1 L[k] = temp#插入到正确位置 return Lif __name__ == '__main__': result = InsertSort([9,1,5,8,3,7,4,6,2]) print(result) 2.3.1 直接插入排序复杂度分析 空间复杂度：只需要一个记录的辅助空间，$O(1)$ 最好时间复杂度：待排序表是有序时，n-1次比较，0次移动，复杂度为$O(n)$ 最坏时间复杂度：待排序表示逆序时，需要比较$2+3+…+n=(n+2)(n-1)/2$次，移动$(n+4)(n-1)/2$次。 平均比较和移动次数$n^2/4$次。总的时间复杂度为$O(n^2)$，直接插入排序法比冒泡和简单选择排序的性能要好一些。 直接插入排序是稳定的。 2.4 希尔排序希尔排序算法是突破$O(n^2)$这个时间复杂度的第一批算法。采用跳跃分割的策略：将相距某个“增量”的记录组成一个字序列，这样才能保证在子序列内分别进行插入排序后得到的结果就是基本有序而不是局部有序。 123456789101112131415def ShellSort(L): increment = len(L) // 2 while increment &gt; 0: for i in range(increment,len(L)): temp = L[i] k = i - increment while temp &lt; L[k] and k &gt;= 0: L[k+increment] = L[k] k -= increment L[k+increment] = temp increment = increment // 2 return Lif __name__ == '__main__': result = ShellSort([9,1,5,8,3,7,4,6,2]) print(result) 2.4.1 希尔排序复杂度分析增量的选取很关键，迄今为止还没有人找到一种最好的增量序列。增量序列的最后一个增量值必须等于1才行，由于记录是跳跃式的移动，希尔排序并不是一种稳定的算法。时间复杂度为$O(n^{3/2})$。优于直接排序的$O(n^2)$。 2.5 堆排序堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如果按照层序遍历的方式给结点从1进行编号，则结点之间满足以下关系： 2.5.1 堆排序算法堆排序就是利用堆（假设利用大顶堆求升序）进行排序的方法，他的基本思想是：将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的$n-1$个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。1234567891011121314151617181920212223def HeapSort(L): for i in range(len(L)//2,-1,-1): HeapAdjust(L,i,len(L)) for j in range(1,len(L))[::-1]: L[j],L[0] = L[0],L[j] HeapAdjust(L,0,j) return Ldef HeapAdjust(L,parent,length): temp = L[parent] child = 2*parent+1 while child &lt; length: if child+1&lt;length and L[child]&lt;L[child+1]: child += 1 if temp &gt;= L[child]: break L[parent] = L[child] parent = child child = 2*parent+1 L[parent] = tempif __name__ == '__main__': result = HeapSort([9,1,5,8,3,7,4,6,2]) print(result) 2.5.2 堆排序复杂度分析运行时间主要消耗在初始构建堆和重建堆的反复筛选。 构建堆的时间复杂度为$O(n)$ 重建堆的时间复杂度为$O(nlogn)$ 总的时间复杂度为$O(nlogn)$ 空间复杂度，只需要一个用来交换的暂存单元，$O(1)$。 堆排序是不稳定的。 2.6 归并排序归并排序的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两合并，得到[n//2]个长度为2或1的有序子序列；再两两合并，…，如此重复，直至得到一个长度为n的有序序列为止，这种方法称为2路归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940def MergeSort(L): temp = [0]*len(L) MSort(L,temp,0,len(L)-1) return Ldef MSort(L,temp,left,right): if left &gt;= right: return mid = (left+right)//2 MSort(L,temp,left,mid) MSort(L,temp,mid+1,right) Merge(L,temp,left,mid,right)def Merge(L,temp,left,mid,right): l,r = left,mid+1 k = 0 while l &lt;= mid and r &lt;= right: if L[l]&lt;L[r]: temp[k] = L[l] l += 1 else: temp[k] = L[r] r += 1 k += 1 while l &lt;= mid: temp[k] = L[l] l+=1 k+=1 while r &lt;= right: temp[k] = L[r] r += 1 k += 1 k = 0 while left &lt;= right: L[left] = temp[k] left += 1 k += 1 if __name__ == '__main__': result = MergeSort([9,1,5,8,3,7,4,6,2]) print(result) 2.6.1 归并排序复杂度分析一趟归并需要将待排序序列中的所有记录扫描一遍，耗费$O(n)$时间，而由完全二叉树的深度可知，整个归并排序需要进行$[log2^n]$次，因此总的时间复杂度为$O(nlogn)$，而且这是归并排序算法中最好、最坏、平均的时间性能。由于归并排序在归并过程中需要与原始记录序列同样数量的存储空间存放归并结果以及递归时深度为$log2^n$的栈空间，因此空间复杂度为$O(n+logn)$。由于Merge函数中有$if L[l]&lt;L[r]$语句，说明需要两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。归并排序是一种比较占用内存，但效率高且稳定的算法。 2.7 快速排序快速排序的基本思想是：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可以分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 12345678910111213141516171819202122def QuickSort(L): QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) Partition 函数要做的，就是先选取当中的一个关键字，比如选择第一个关键字，然后想尽办法将它放到一个位置，使得它左边的值都比它小，右边的值比它大，我们将这样的关键字称为枢轴( pivot) 。 2.7.1 快速排序复杂度分析快速排序的时间性能取决于快速排序递归的深度。 在最优情况下,Partition每次划分都很均匀，如果排序n个关键字，其递归树的深度就为$[logn]+1$，仅需递归$logn$次，需要时间为$T(n)$的话，第一次Partition应该是对整个数组扫描一遍，做n次比较。然后获得的枢轴将数组一份为二，那么各自还需要$T(n/2)$的时间。 在最优的情况下，快速排序算法的时间复杂度为$O(nlogn) $。 最坏时间复杂度为$O(n^2)$。 空间复杂度主要是递归造成的栈空间的使用: 最好情况，递归树的深度为$logn$ ，其空间复杂度也就为$O(logn)$ 最坏情况，需要进行$n - 1$ 递归调用，其空间复杂度为$O(n)$ 平均情况， 空间复杂度也为$O (logn) $。 由于关键字的比较和交换是跳跃进行的，因此，快速排序是一种不稳定的排序方法。 2.7.2 快速排序优化2.7.2.1 优化选取枢轴三数取中：即取三个关键字先进行排序，将中间数作为枢轴， 一般是取左端、右端和中间三个数。三数取中对小数组来说有很大的概率选择到一个比较好的pivotkey ， 123456789101112131415161718192021222324252627282930def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low],L[high] = L[high],L[low] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[low], L[high] = L[high], L[low] return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.2 优化不必要的交换1234567891011121314151617181920212223242526272829303132def QuickSort(L): temp = [0]*len(L) QSort(L,0,len(L)-1) return Ldef QSort(L,low,high): if low &lt;high: pivot = Partition(L,low,high) QSort(L,low,pivot-1) QSort(L,pivot+1,high)def Partition(L,low,high): m= low+(high-low)//2 if L[low]&gt;L[high]: L[low], L[high] = L[high], L[low] if L[m]&gt;L[high]: L[m], L[high] = L[high], L[m] if L[m]&gt;L[low]: L[m], L[low] = L[low], L[m] pivotkey = L[low] temp = pivotkey while low&lt;high: while low&lt;high and L[high]&gt;=pivotkey: high -= 1 L[low] = L[high] while low&lt;high and L[low]&lt;=pivotkey: low += 1 L[high] = L[low] L[low] = temp return lowif __name__ == '__main__': result = QuickSort([9,1,5,8,3,7,4,6,2]) print(result) 2.7.2.3 优化小数组时的排序方案2.7.2.4 优化递归操作2.8 桶排序使用空间换时间，首先统计出数组中元素的频次。接着，将数组中的元素按照出现频次进行分组，即出现频次为 i 的元素存放在第 i 个桶。最后，从桶中逆序取出前 k 个元素；桶排序使用Hashmap散列表。 2.8.1 桶排序复杂度分析假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有$n/m$个数字。如果 对每个桶中的数字采用快速排序，那么整个算法的复杂度是$O(n + m n/mlog(n/m)) = O(n + nlogn - nlogm) $ 当m接近n的时候，桶排序复杂度接近$O(n)$。前面说的几大排序算法 ，大部分时间复杂度都是$O(n^2)$，也有部分排序算法时间复杂度是$O(nlogn)$。而桶式排序却能实现$O(n)$的时间复杂度。但桶排序的缺点是： 首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。 其次待排序的元素都要在一定的范围内。 桶式排序是一种分配排序。分配排序的特点是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 参考 2.8.2 桶排序实现桶排序求前K个高频元素题目描述给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 示例 2: 输入: nums = [1], k = 1输出: [1] 说明： 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。 解题思路 使用桶排序算法 首先使用散列表统计数组中元素出现的频次； 接着新建len(nums)+1个桶，用于保存出现次数对应的元素； 最后，从逆序桶中取出前k个元素。 1234567891011121314151617181920212223242526class Solution(object): def topKFrequent(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ if len(nums)&lt;k: return [] Dict = &#123;&#125; for x in nums: Dict[x] = Dict.get(x,0)+1 bucket = [[] for _ in range(len(nums)+1)] for key, val in Dict.items(): bucket[val].append(key) res = [] for i in range(len(nums),-1,-1): if bucket[i]: res.extend(bucket[i]) if len(res)&gt;=k: break return resif __name__ == '__main__': result = Solution().topKFrequent([1,1,1,2,2,3], 2) print(result) 根据字符出现频率排序题目描述给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 示例 1: 输入:”tree”输出: “eert”解释: ‘e’出现两次，’r’和’t’都只出现一次。因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。 示例 2: 输入:”cccaaa”输出:”cccaaa”解释:’c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。注意”cacaca”是不正确的，因为相同的字母必须放在一起。 示例 3: 输入:”Aabb”输出:”bbAa”解释:此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。注意’A’和’a’被认为是两种不同的字符。 解题思路 桶排序 1234567891011121314151617181920212223class Solution(object): def frequencySort(self, s): """ :type s: str :rtype: str """ if len(s)==0: return '' Dict = &#123;&#125; for x in s: Dict[x] = Dict.get(x,0)+1 bucket = ['' for _ in range(len(s)+1)] for key,val in Dict.items(): bucket[val] += val * key res = '' for i in range(len(s),-1,-1): if bucket[i]: res += bucket[i] return resif __name__ == '__main__': result = Solution().frequencySort('tree') print(result) 3 总结 参考文献：程杰. 大话数据结构]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
